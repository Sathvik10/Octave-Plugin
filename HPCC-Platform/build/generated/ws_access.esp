// *** Source file generated by HIDL Version 1.3 from ws_access.ecm ***
// *** Not to be hand edited (changes will be lost on re-generation) ***

#ifndef ws_access_ESPGEN_INCLUDED
#define ws_access_ESPGEN_INCLUDED

#include "ws_access_esp.ipp"

#ifdef _WIN32
#include "edwin.h"
#include <process.h>
#endif



//=======================================================
// class CUserInfo Implementation
//=======================================================

CUserInfo::CUserInfo(const char *serviceName, IRpcMessageBinding *init)
	: m_username(nilIgnore),m_fullname(nilIgnore),m_passwordexpiration(nilIgnore),m_employeeID(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("UserInfo");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CUserInfo::CUserInfo(const char *serviceName, const char *bc)
	: m_username(nilIgnore),m_fullname(nilIgnore),m_passwordexpiration(nilIgnore),m_employeeID(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("UserInfo");
}

StringBuffer &CUserInfo::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:complexType name=\"%s\">\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"username\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"fullname\" type=\"xsd:string\"/>\n");
		if (!context.suppressed("UserInfo","passwordexpiration")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"passwordexpiration\" type=\"xsd:string\"/>\n");
		}
		if (!context.suppressed("UserInfo","employeeID")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"employeeID\" type=\"xsd:string\"/>\n");
		}
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType>\n");
		}
	}
	return schema;
}

void CUserInfo::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CUserInfo::getMapInfo(IMapInfo& info, BoolHash& added)
{
	info.addMinVersion("UserInfo","passwordexpiration",1.07);
	info.addMinVersion("UserInfo","employeeID",1.1);
}

StringBuffer &CUserInfo::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("username");
	form.appendf("  <tr><td><b>username: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("fullname");
	form.appendf("  <tr><td><b>fullname: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (!context.suppressed("UserInfo","passwordexpiration")) {
		extfix.clear();
		if (prefix && *prefix)
			extfix.append(prefix).append(".");
		extfix.append("passwordexpiration");
		form.appendf("  <tr><td><b>passwordexpiration: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
		form.append("</td></tr>\n");
	}
	if (!context.suppressed("UserInfo","employeeID")) {
		extfix.clear();
		if (prefix && *prefix)
			extfix.append(prefix).append(".");
		extfix.append("employeeID");
		form.appendf("  <tr><td><b>employeeID: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
		form.append("</td></tr>\n");
	}
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CUserInfo::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CUserInfo::serialize(IRpcMessage& rpc_resp)
{
	IEspContext* ctx = rpc_resp.queryContext();
	double clientVer= ctx ? ctx->getClientVersion() : -1; /* no context gets everything */
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_username.marshall(rpc_resp, "username", "", "", "");
	m_fullname.marshall(rpc_resp, "fullname", "", "", "");
	if ((clientVer==-1.0 || clientVer>=1.07))
		m_passwordexpiration.marshall(rpc_resp, "passwordexpiration", "", "", "");
	if ((clientVer==-1.0 || clientVer>=1.1))
		m_employeeID.marshall(rpc_resp, "employeeID", "", "", "");
}


void CUserInfo::copy(CUserInfo &from)
{
	m_username.copy(from.m_username);
	m_fullname.copy(from.m_fullname);
	m_passwordexpiration.copy(from.m_passwordexpiration);
	m_employeeID.copy(from.m_employeeID);
}


void CUserInfo::copy(IConstUserInfo &ifrom)
{
	setUsername(ifrom.getUsername());
	setFullname(ifrom.getFullname());
	setPasswordexpiration(ifrom.getPasswordexpiration());
	setEmployeeID(ifrom.getEmployeeID());
}


void CUserInfo::getAttributes(IProperties &attributes)
{
}


void CUserInfo::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	double clientVer = ctx ? ctx->getClientVersion() : -1;
	m_username.toStr(ctx, buffer, "username", "", true, "", "");
	m_fullname.toStr(ctx, buffer, "fullname", "", true, "", "");
	if ((clientVer==-1.0 || clientVer>=1.07))
		m_passwordexpiration.toStr(ctx, buffer, "passwordexpiration", "", true, "", "");
	if ((clientVer==-1.0 || clientVer>=1.1))
		m_employeeID.toStr(ctx, buffer, "employeeID", "", true, "", "");
}


void CUserInfo::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CUserInfo::serializer(IEspContext* ctx, IConstUserInfo &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<UserInfo>");
	double clientVer = ctx ? ctx->getClientVersion() : -1;
	// field username
	{
		const char* s = src.getUsername();
		if (s && *s)
		{
			buffer.append("<username>");
			encodeUtf8XML(s,buffer);
			buffer.append("</username>");
		}
	}
	// field fullname
	{
		const char* s = src.getFullname();
		if (s && *s)
		{
			buffer.append("<fullname>");
			encodeUtf8XML(s,buffer);
			buffer.append("</fullname>");
		}
	}
	// field passwordexpiration
	if ((clientVer==-1.0 || clientVer>=1.07))
	{
		const char* s = src.getPasswordexpiration();
		if (s && *s)
		{
			buffer.append("<passwordexpiration>");
			encodeUtf8XML(s,buffer);
			buffer.append("</passwordexpiration>");
		}
	}
	// field employeeID
	if ((clientVer==-1.0 || clientVer>=1.1))
	{
		const char* s = src.getEmployeeID();
		if (s && *s)
		{
			buffer.append("<employeeID>");
			encodeUtf8XML(s,buffer);
			buffer.append("</employeeID>");
		}
	}
	if (keepRootTag)
		buffer.append("</UserInfo>");
}

bool CUserInfo::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_username.unmarshall(rpc_request, "username", basepath);
	hasValue |= m_fullname.unmarshall(rpc_request, "fullname", basepath);
	hasValue |= m_passwordexpiration.unmarshall(rpc_request, "passwordexpiration", basepath);
	hasValue |= m_employeeID.unmarshall(rpc_request, "employeeID", basepath);
	return hasValue;
}

bool CUserInfo::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_username.unmarshall(ctx, soapval, "username");
	hasValue |= m_fullname.unmarshall(ctx, soapval, "fullname");
	hasValue |= m_passwordexpiration.unmarshall(ctx, soapval, "passwordexpiration");
	hasValue |= m_employeeID.unmarshall(ctx, soapval, "employeeID");
	return hasValue;
}

bool CUserInfo::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_username.unmarshall(ctx, params, attachments, "username", basepath);
	hasValue |= m_fullname.unmarshall(ctx, params, attachments, "fullname", basepath);
	hasValue |= m_passwordexpiration.unmarshall(ctx, params, attachments, "passwordexpiration", basepath);
	hasValue |= m_employeeID.unmarshall(ctx, params, attachments, "employeeID", basepath);
	return hasValue;
}

const char * CUserInfo::getUsername() { return m_username.query();}
const char * CUserInfo::getFullname() { return m_fullname.query();}
const char * CUserInfo::getPasswordexpiration() { return m_passwordexpiration.query();}
const char * CUserInfo::getEmployeeID() { return m_employeeID.query();}
void CUserInfo::setUsername(const char * val){ m_username.set(val); }
void CUserInfo::setFullname(const char * val){ m_fullname.set(val); }
void CUserInfo::setPasswordexpiration(const char * val){ m_passwordexpiration.set(val); }
void CUserInfo::setEmployeeID(const char * val){ m_employeeID.set(val); }
extern "C"  IEspUserInfo *createUserInfo(const char *serv, const char *msgname){return ((IEspUserInfo *)new CUserInfo(serv /*, msgname*/));}
extern "C"  IClientUserInfo *createClientUserInfo(const char *serv, const char *msgname){return ((IClientUserInfo *)new CUserInfo(serv /*, msgname*/));}

//=======================================================
// class CGroupInfo Implementation
//=======================================================

CGroupInfo::CGroupInfo(const char *serviceName, IRpcMessageBinding *init)
	: m_name(nilIgnore),m_deletable(nilIgnore),m_groupOwner(nilIgnore),m_groupDesc(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GroupInfo");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CGroupInfo::CGroupInfo(const char *serviceName, const char *bc)
	: m_name(nilIgnore),m_deletable(nilIgnore),m_groupOwner(nilIgnore),m_groupDesc(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GroupInfo");
}

StringBuffer &CGroupInfo::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:complexType name=\"%s\">\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"name\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"deletable\" type=\"xsd:boolean\"/>\n");
		if (!context.suppressed("GroupInfo","groupOwner")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"groupOwner\" type=\"xsd:string\"/>\n");
		}
		if (!context.suppressed("GroupInfo","groupDesc")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"groupDesc\" type=\"xsd:string\"/>\n");
		}
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType>\n");
		}
	}
	return schema;
}

void CGroupInfo::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CGroupInfo::getMapInfo(IMapInfo& info, BoolHash& added)
{
	info.addMinVersion("GroupInfo","groupOwner",1.09);
	info.addMinVersion("GroupInfo","groupDesc",1.09);
}

StringBuffer &CGroupInfo::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("name");
	form.appendf("  <tr><td><b>name: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("deletable");
	
	form.appendf("  <tr><td><b>deletable? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	if (!context.suppressed("GroupInfo","groupOwner")) {
		extfix.clear();
		if (prefix && *prefix)
			extfix.append(prefix).append(".");
		extfix.append("groupOwner");
		form.appendf("  <tr><td><b>groupOwner: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
		form.append("</td></tr>\n");
	}
	if (!context.suppressed("GroupInfo","groupDesc")) {
		extfix.clear();
		if (prefix && *prefix)
			extfix.append(prefix).append(".");
		extfix.append("groupDesc");
		form.appendf("  <tr><td><b>groupDesc: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
		form.append("</td></tr>\n");
	}
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CGroupInfo::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CGroupInfo::serialize(IRpcMessage& rpc_resp)
{
	IEspContext* ctx = rpc_resp.queryContext();
	double clientVer= ctx ? ctx->getClientVersion() : -1; /* no context gets everything */
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_name.marshall(rpc_resp, "name", "", "", "");
	m_deletable.marshall(rpc_resp, "deletable", "", "", "");
	if ((clientVer==-1.0 || clientVer>=1.09))
		m_groupOwner.marshall(rpc_resp, "groupOwner", "", "", "");
	if ((clientVer==-1.0 || clientVer>=1.09))
		m_groupDesc.marshall(rpc_resp, "groupDesc", "", "", "");
}


void CGroupInfo::copy(CGroupInfo &from)
{
	m_name.copy(from.m_name);
	m_deletable.copy(from.m_deletable);
	m_groupOwner.copy(from.m_groupOwner);
	m_groupDesc.copy(from.m_groupDesc);
}


void CGroupInfo::copy(IConstGroupInfo &ifrom)
{
	setName(ifrom.getName());
	setDeletable(ifrom.getDeletable());
	setGroupOwner(ifrom.getGroupOwner());
	setGroupDesc(ifrom.getGroupDesc());
}


void CGroupInfo::getAttributes(IProperties &attributes)
{
}


void CGroupInfo::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	double clientVer = ctx ? ctx->getClientVersion() : -1;
	m_name.toStr(ctx, buffer, "name", "", true, "", "");
	m_deletable.toStr(ctx, buffer, "deletable", "", true, "", "");
	if ((clientVer==-1.0 || clientVer>=1.09))
		m_groupOwner.toStr(ctx, buffer, "groupOwner", "", true, "", "");
	if ((clientVer==-1.0 || clientVer>=1.09))
		m_groupDesc.toStr(ctx, buffer, "groupDesc", "", true, "", "");
}


void CGroupInfo::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CGroupInfo::serializer(IEspContext* ctx, IConstGroupInfo &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<GroupInfo>");
	double clientVer = ctx ? ctx->getClientVersion() : -1;
	// field name
	{
		const char* s = src.getName();
		if (s && *s)
		{
			buffer.append("<name>");
			encodeUtf8XML(s,buffer);
			buffer.append("</name>");
		}
	}
	// field deletable
	{
		bool b = src.getDeletable();
		if (b)
			buffer.appendf("<deletable>1</deletable>");
	}
	// field groupOwner
	if ((clientVer==-1.0 || clientVer>=1.09))
	{
		const char* s = src.getGroupOwner();
		if (s && *s)
		{
			buffer.append("<groupOwner>");
			encodeUtf8XML(s,buffer);
			buffer.append("</groupOwner>");
		}
	}
	// field groupDesc
	if ((clientVer==-1.0 || clientVer>=1.09))
	{
		const char* s = src.getGroupDesc();
		if (s && *s)
		{
			buffer.append("<groupDesc>");
			encodeUtf8XML(s,buffer);
			buffer.append("</groupDesc>");
		}
	}
	if (keepRootTag)
		buffer.append("</GroupInfo>");
}

bool CGroupInfo::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_name.unmarshall(rpc_request, "name", basepath);
	hasValue |= m_deletable.unmarshall(rpc_request, "deletable", basepath);
	hasValue |= m_groupOwner.unmarshall(rpc_request, "groupOwner", basepath);
	hasValue |= m_groupDesc.unmarshall(rpc_request, "groupDesc", basepath);
	return hasValue;
}

bool CGroupInfo::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_name.unmarshall(ctx, soapval, "name");
	hasValue |= m_deletable.unmarshall(ctx, soapval, "deletable");
	hasValue |= m_groupOwner.unmarshall(ctx, soapval, "groupOwner");
	hasValue |= m_groupDesc.unmarshall(ctx, soapval, "groupDesc");
	return hasValue;
}

bool CGroupInfo::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_name.unmarshall(ctx, params, attachments, "name", basepath);
	hasValue |= m_deletable.unmarshall(ctx, params, attachments, "deletable", basepath);
	hasValue |= m_groupOwner.unmarshall(ctx, params, attachments, "groupOwner", basepath);
	hasValue |= m_groupDesc.unmarshall(ctx, params, attachments, "groupDesc", basepath);
	return hasValue;
}

const char * CGroupInfo::getName() { return m_name.query();}
bool CGroupInfo::getDeletable() { return m_deletable;}
const char * CGroupInfo::getGroupOwner() { return m_groupOwner.query();}
const char * CGroupInfo::getGroupDesc() { return m_groupDesc.query();}
void CGroupInfo::setName(const char * val){ m_name.set(val); }
void CGroupInfo::setDeletable(bool val){ m_deletable=val; }
void CGroupInfo::setGroupOwner(const char * val){ m_groupOwner.set(val); }
void CGroupInfo::setGroupDesc(const char * val){ m_groupDesc.set(val); }
extern "C"  IEspGroupInfo *createGroupInfo(const char *serv, const char *msgname){return ((IEspGroupInfo *)new CGroupInfo(serv /*, msgname*/));}
extern "C"  IClientGroupInfo *createClientGroupInfo(const char *serv, const char *msgname){return ((IClientGroupInfo *)new CGroupInfo(serv /*, msgname*/));}

//=======================================================
// class CAccountPermission Implementation
//=======================================================

CAccountPermission::CAccountPermission(const char *serviceName, IRpcMessageBinding *init)
	: m_basedn(nilIgnore),m_RType(nilIgnore),m_rname(nilIgnore),m_rtitle(nilIgnore),m_prefix(nilIgnore),m_ResourceName(nilIgnore),m_PermissionName(nilIgnore),m_allow_access(nilIgnore),m_allow_read(nilIgnore),m_allow_write(nilIgnore),m_allow_full(nilIgnore),m_deny_access(nilIgnore),m_deny_read(nilIgnore),m_deny_write(nilIgnore),m_deny_full(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("AccountPermission");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CAccountPermission::CAccountPermission(const char *serviceName, const char *bc)
	: m_basedn(nilIgnore),m_RType(nilIgnore),m_rname(nilIgnore),m_rtitle(nilIgnore),m_prefix(nilIgnore),m_ResourceName(nilIgnore),m_PermissionName(nilIgnore),m_allow_access(nilIgnore),m_allow_read(nilIgnore),m_allow_write(nilIgnore),m_allow_full(nilIgnore),m_deny_access(nilIgnore),m_deny_read(nilIgnore),m_deny_write(nilIgnore),m_deny_full(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("AccountPermission");
}

StringBuffer &CAccountPermission::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:complexType name=\"%s\">\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"basedn\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"RType\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"rname\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"rtitle\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"prefix\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"ResourceName\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"PermissionName\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"allow_access\" type=\"xsd:boolean\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"allow_read\" type=\"xsd:boolean\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"allow_write\" type=\"xsd:boolean\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"allow_full\" type=\"xsd:boolean\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"deny_access\" type=\"xsd:boolean\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"deny_read\" type=\"xsd:boolean\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"deny_write\" type=\"xsd:boolean\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"deny_full\" type=\"xsd:boolean\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType>\n");
		}
	}
	return schema;
}

void CAccountPermission::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CAccountPermission::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CAccountPermission::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("basedn");
	form.appendf("  <tr><td><b>basedn: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("RType");
	form.appendf("  <tr><td><b>RType: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("rname");
	form.appendf("  <tr><td><b>rname: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("rtitle");
	form.appendf("  <tr><td><b>rtitle: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("prefix");
	form.appendf("  <tr><td><b>prefix: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("ResourceName");
	form.appendf("  <tr><td><b>ResourceName: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("PermissionName");
	form.appendf("  <tr><td><b>PermissionName: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("allow_access");
	
	form.appendf("  <tr><td><b>allow_access? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("allow_read");
	
	form.appendf("  <tr><td><b>allow_read? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("allow_write");
	
	form.appendf("  <tr><td><b>allow_write? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("allow_full");
	
	form.appendf("  <tr><td><b>allow_full? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("deny_access");
	
	form.appendf("  <tr><td><b>deny_access? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("deny_read");
	
	form.appendf("  <tr><td><b>deny_read? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("deny_write");
	
	form.appendf("  <tr><td><b>deny_write? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("deny_full");
	
	form.appendf("  <tr><td><b>deny_full? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CAccountPermission::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CAccountPermission::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_basedn.marshall(rpc_resp, "basedn", "", "", "");
	m_RType.marshall(rpc_resp, "RType", "", "", "");
	m_rname.marshall(rpc_resp, "rname", "", "", "");
	m_rtitle.marshall(rpc_resp, "rtitle", "", "", "");
	m_prefix.marshall(rpc_resp, "prefix", "", "", "");
	m_ResourceName.marshall(rpc_resp, "ResourceName", "", "", "");
	m_PermissionName.marshall(rpc_resp, "PermissionName", "", "", "");
	m_allow_access.marshall(rpc_resp, "allow_access", "", "", "");
	m_allow_read.marshall(rpc_resp, "allow_read", "", "", "");
	m_allow_write.marshall(rpc_resp, "allow_write", "", "", "");
	m_allow_full.marshall(rpc_resp, "allow_full", "", "", "");
	m_deny_access.marshall(rpc_resp, "deny_access", "", "", "");
	m_deny_read.marshall(rpc_resp, "deny_read", "", "", "");
	m_deny_write.marshall(rpc_resp, "deny_write", "", "", "");
	m_deny_full.marshall(rpc_resp, "deny_full", "", "", "");
}


void CAccountPermission::copy(CAccountPermission &from)
{
	m_basedn.copy(from.m_basedn);
	m_RType.copy(from.m_RType);
	m_rname.copy(from.m_rname);
	m_rtitle.copy(from.m_rtitle);
	m_prefix.copy(from.m_prefix);
	m_ResourceName.copy(from.m_ResourceName);
	m_PermissionName.copy(from.m_PermissionName);
	m_allow_access.copy(from.m_allow_access);
	m_allow_read.copy(from.m_allow_read);
	m_allow_write.copy(from.m_allow_write);
	m_allow_full.copy(from.m_allow_full);
	m_deny_access.copy(from.m_deny_access);
	m_deny_read.copy(from.m_deny_read);
	m_deny_write.copy(from.m_deny_write);
	m_deny_full.copy(from.m_deny_full);
}


void CAccountPermission::copy(IConstAccountPermission &ifrom)
{
	setBasedn(ifrom.getBasedn());
	setRType(ifrom.getRType());
	setRname(ifrom.getRname());
	setRtitle(ifrom.getRtitle());
	setPrefix(ifrom.getPrefix());
	setResourceName(ifrom.getResourceName());
	setPermissionName(ifrom.getPermissionName());
	setAllow_access(ifrom.getAllow_access());
	setAllow_read(ifrom.getAllow_read());
	setAllow_write(ifrom.getAllow_write());
	setAllow_full(ifrom.getAllow_full());
	setDeny_access(ifrom.getDeny_access());
	setDeny_read(ifrom.getDeny_read());
	setDeny_write(ifrom.getDeny_write());
	setDeny_full(ifrom.getDeny_full());
}


void CAccountPermission::getAttributes(IProperties &attributes)
{
}


void CAccountPermission::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_basedn.toStr(ctx, buffer, "basedn", "", true, "", "");
	m_RType.toStr(ctx, buffer, "RType", "", true, "", "");
	m_rname.toStr(ctx, buffer, "rname", "", true, "", "");
	m_rtitle.toStr(ctx, buffer, "rtitle", "", true, "", "");
	m_prefix.toStr(ctx, buffer, "prefix", "", true, "", "");
	m_ResourceName.toStr(ctx, buffer, "ResourceName", "", true, "", "");
	m_PermissionName.toStr(ctx, buffer, "PermissionName", "", true, "", "");
	m_allow_access.toStr(ctx, buffer, "allow_access", "", true, "", "");
	m_allow_read.toStr(ctx, buffer, "allow_read", "", true, "", "");
	m_allow_write.toStr(ctx, buffer, "allow_write", "", true, "", "");
	m_allow_full.toStr(ctx, buffer, "allow_full", "", true, "", "");
	m_deny_access.toStr(ctx, buffer, "deny_access", "", true, "", "");
	m_deny_read.toStr(ctx, buffer, "deny_read", "", true, "", "");
	m_deny_write.toStr(ctx, buffer, "deny_write", "", true, "", "");
	m_deny_full.toStr(ctx, buffer, "deny_full", "", true, "", "");
}


void CAccountPermission::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CAccountPermission::serializer(IEspContext* ctx, IConstAccountPermission &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<AccountPermission>");
	// field basedn
	{
		const char* s = src.getBasedn();
		if (s && *s)
		{
			buffer.append("<basedn>");
			encodeUtf8XML(s,buffer);
			buffer.append("</basedn>");
		}
	}
	// field RType
	{
		const char* s = src.getRType();
		if (s && *s)
		{
			buffer.append("<RType>");
			encodeUtf8XML(s,buffer);
			buffer.append("</RType>");
		}
	}
	// field rname
	{
		const char* s = src.getRname();
		if (s && *s)
		{
			buffer.append("<rname>");
			encodeUtf8XML(s,buffer);
			buffer.append("</rname>");
		}
	}
	// field rtitle
	{
		const char* s = src.getRtitle();
		if (s && *s)
		{
			buffer.append("<rtitle>");
			encodeUtf8XML(s,buffer);
			buffer.append("</rtitle>");
		}
	}
	// field prefix
	{
		const char* s = src.getPrefix();
		if (s && *s)
		{
			buffer.append("<prefix>");
			encodeUtf8XML(s,buffer);
			buffer.append("</prefix>");
		}
	}
	// field ResourceName
	{
		const char* s = src.getResourceName();
		if (s && *s)
		{
			buffer.append("<ResourceName>");
			encodeUtf8XML(s,buffer);
			buffer.append("</ResourceName>");
		}
	}
	// field PermissionName
	{
		const char* s = src.getPermissionName();
		if (s && *s)
		{
			buffer.append("<PermissionName>");
			encodeUtf8XML(s,buffer);
			buffer.append("</PermissionName>");
		}
	}
	// field allow_access
	{
		bool b = src.getAllow_access();
		if (b)
			buffer.appendf("<allow_access>1</allow_access>");
	}
	// field allow_read
	{
		bool b = src.getAllow_read();
		if (b)
			buffer.appendf("<allow_read>1</allow_read>");
	}
	// field allow_write
	{
		bool b = src.getAllow_write();
		if (b)
			buffer.appendf("<allow_write>1</allow_write>");
	}
	// field allow_full
	{
		bool b = src.getAllow_full();
		if (b)
			buffer.appendf("<allow_full>1</allow_full>");
	}
	// field deny_access
	{
		bool b = src.getDeny_access();
		if (b)
			buffer.appendf("<deny_access>1</deny_access>");
	}
	// field deny_read
	{
		bool b = src.getDeny_read();
		if (b)
			buffer.appendf("<deny_read>1</deny_read>");
	}
	// field deny_write
	{
		bool b = src.getDeny_write();
		if (b)
			buffer.appendf("<deny_write>1</deny_write>");
	}
	// field deny_full
	{
		bool b = src.getDeny_full();
		if (b)
			buffer.appendf("<deny_full>1</deny_full>");
	}
	if (keepRootTag)
		buffer.append("</AccountPermission>");
}

bool CAccountPermission::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_basedn.unmarshall(rpc_request, "basedn", basepath);
	hasValue |= m_RType.unmarshall(rpc_request, "RType", basepath);
	hasValue |= m_rname.unmarshall(rpc_request, "rname", basepath);
	hasValue |= m_rtitle.unmarshall(rpc_request, "rtitle", basepath);
	hasValue |= m_prefix.unmarshall(rpc_request, "prefix", basepath);
	hasValue |= m_ResourceName.unmarshall(rpc_request, "ResourceName", basepath);
	hasValue |= m_PermissionName.unmarshall(rpc_request, "PermissionName", basepath);
	hasValue |= m_allow_access.unmarshall(rpc_request, "allow_access", basepath);
	hasValue |= m_allow_read.unmarshall(rpc_request, "allow_read", basepath);
	hasValue |= m_allow_write.unmarshall(rpc_request, "allow_write", basepath);
	hasValue |= m_allow_full.unmarshall(rpc_request, "allow_full", basepath);
	hasValue |= m_deny_access.unmarshall(rpc_request, "deny_access", basepath);
	hasValue |= m_deny_read.unmarshall(rpc_request, "deny_read", basepath);
	hasValue |= m_deny_write.unmarshall(rpc_request, "deny_write", basepath);
	hasValue |= m_deny_full.unmarshall(rpc_request, "deny_full", basepath);
	return hasValue;
}

bool CAccountPermission::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_basedn.unmarshall(ctx, soapval, "basedn");
	hasValue |= m_RType.unmarshall(ctx, soapval, "RType");
	hasValue |= m_rname.unmarshall(ctx, soapval, "rname");
	hasValue |= m_rtitle.unmarshall(ctx, soapval, "rtitle");
	hasValue |= m_prefix.unmarshall(ctx, soapval, "prefix");
	hasValue |= m_ResourceName.unmarshall(ctx, soapval, "ResourceName");
	hasValue |= m_PermissionName.unmarshall(ctx, soapval, "PermissionName");
	hasValue |= m_allow_access.unmarshall(ctx, soapval, "allow_access");
	hasValue |= m_allow_read.unmarshall(ctx, soapval, "allow_read");
	hasValue |= m_allow_write.unmarshall(ctx, soapval, "allow_write");
	hasValue |= m_allow_full.unmarshall(ctx, soapval, "allow_full");
	hasValue |= m_deny_access.unmarshall(ctx, soapval, "deny_access");
	hasValue |= m_deny_read.unmarshall(ctx, soapval, "deny_read");
	hasValue |= m_deny_write.unmarshall(ctx, soapval, "deny_write");
	hasValue |= m_deny_full.unmarshall(ctx, soapval, "deny_full");
	return hasValue;
}

bool CAccountPermission::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_basedn.unmarshall(ctx, params, attachments, "basedn", basepath);
	hasValue |= m_RType.unmarshall(ctx, params, attachments, "RType", basepath);
	hasValue |= m_rname.unmarshall(ctx, params, attachments, "rname", basepath);
	hasValue |= m_rtitle.unmarshall(ctx, params, attachments, "rtitle", basepath);
	hasValue |= m_prefix.unmarshall(ctx, params, attachments, "prefix", basepath);
	hasValue |= m_ResourceName.unmarshall(ctx, params, attachments, "ResourceName", basepath);
	hasValue |= m_PermissionName.unmarshall(ctx, params, attachments, "PermissionName", basepath);
	hasValue |= m_allow_access.unmarshall(ctx, params, attachments, "allow_access", basepath);
	hasValue |= m_allow_read.unmarshall(ctx, params, attachments, "allow_read", basepath);
	hasValue |= m_allow_write.unmarshall(ctx, params, attachments, "allow_write", basepath);
	hasValue |= m_allow_full.unmarshall(ctx, params, attachments, "allow_full", basepath);
	hasValue |= m_deny_access.unmarshall(ctx, params, attachments, "deny_access", basepath);
	hasValue |= m_deny_read.unmarshall(ctx, params, attachments, "deny_read", basepath);
	hasValue |= m_deny_write.unmarshall(ctx, params, attachments, "deny_write", basepath);
	hasValue |= m_deny_full.unmarshall(ctx, params, attachments, "deny_full", basepath);
	return hasValue;
}

const char * CAccountPermission::getBasedn() { return m_basedn.query();}
const char * CAccountPermission::getRType() { return m_RType.query();}
const char * CAccountPermission::getRname() { return m_rname.query();}
const char * CAccountPermission::getRtitle() { return m_rtitle.query();}
const char * CAccountPermission::getPrefix() { return m_prefix.query();}
const char * CAccountPermission::getResourceName() { return m_ResourceName.query();}
const char * CAccountPermission::getPermissionName() { return m_PermissionName.query();}
bool CAccountPermission::getAllow_access() { return m_allow_access;}
bool CAccountPermission::getAllow_read() { return m_allow_read;}
bool CAccountPermission::getAllow_write() { return m_allow_write;}
bool CAccountPermission::getAllow_full() { return m_allow_full;}
bool CAccountPermission::getDeny_access() { return m_deny_access;}
bool CAccountPermission::getDeny_read() { return m_deny_read;}
bool CAccountPermission::getDeny_write() { return m_deny_write;}
bool CAccountPermission::getDeny_full() { return m_deny_full;}
void CAccountPermission::setBasedn(const char * val){ m_basedn.set(val); }
void CAccountPermission::setRType(const char * val){ m_RType.set(val); }
void CAccountPermission::setRname(const char * val){ m_rname.set(val); }
void CAccountPermission::setRtitle(const char * val){ m_rtitle.set(val); }
void CAccountPermission::setPrefix(const char * val){ m_prefix.set(val); }
void CAccountPermission::setResourceName(const char * val){ m_ResourceName.set(val); }
void CAccountPermission::setPermissionName(const char * val){ m_PermissionName.set(val); }
void CAccountPermission::setAllow_access(bool val){ m_allow_access=val; }
void CAccountPermission::setAllow_read(bool val){ m_allow_read=val; }
void CAccountPermission::setAllow_write(bool val){ m_allow_write=val; }
void CAccountPermission::setAllow_full(bool val){ m_allow_full=val; }
void CAccountPermission::setDeny_access(bool val){ m_deny_access=val; }
void CAccountPermission::setDeny_read(bool val){ m_deny_read=val; }
void CAccountPermission::setDeny_write(bool val){ m_deny_write=val; }
void CAccountPermission::setDeny_full(bool val){ m_deny_full=val; }
extern "C"  IEspAccountPermission *createAccountPermission(const char *serv, const char *msgname){return ((IEspAccountPermission *)new CAccountPermission(serv /*, msgname*/));}
extern "C"  IClientAccountPermission *createClientAccountPermission(const char *serv, const char *msgname){return ((IClientAccountPermission *)new CAccountPermission(serv /*, msgname*/));}

//=======================================================
// class CGroupAccountPermission Implementation
//=======================================================

CGroupAccountPermission::CGroupAccountPermission(const char *serviceName, IRpcMessageBinding *init)
	: m_GroupName(nilIgnore),m_BasednNames(nilIgnore),m_Permissions(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GroupAccountPermission");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CGroupAccountPermission::CGroupAccountPermission(const char *serviceName, const char *bc)
	: m_GroupName(nilIgnore),m_BasednNames(nilIgnore),m_Permissions(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GroupAccountPermission");
}

StringBuffer &CGroupAccountPermission::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:complexType name=\"%s\">\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"GroupName\" type=\"xsd:string\"/>\n");
		if (!context.suppressed("GroupAccountPermission","BasednNames")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"BasednNames\" type=\"tns:EspStringArray\"/>\n");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Permissions\">\n");
		schema.append("<xsd:complexType><xsd:sequence>\n");
		schema.append("<xsd:element minOccurs=\"0\" maxOccurs=\"unbounded\" name=\"Permission\" type=\"tns:AccountPermission\"/>");
		schema.append("</xsd:sequence></xsd:complexType>");
		schema.append("</xsd:element>");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType>\n");
		}
	}
	if (!(flags & 0x10)  || (flags & 0x100))
	{
		CAccountPermission::getXsdDefinition(context, request, schema, added);
	}
	if (added.getValue("EspStringArray")==NULL) {
		addEspNativeArray(schema,"string","EspStringArray");
		added.setValue("EspStringArray",1);
	}
	return schema;
}

void CGroupAccountPermission::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CGroupAccountPermission::getMapInfo(IMapInfo& info, BoolHash& added)
{
	info.addMinVersion("GroupAccountPermission","BasednNames",1.06);
	if (!added.getValue("AccountPermission"))
	{
		added.setValue("AccountPermission",1);
		CAccountPermission::getMapInfo(info,added);
	}
}

StringBuffer &CGroupAccountPermission::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("GroupName");
	form.appendf("  <tr><td><b>GroupName: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (!context.suppressed("GroupAccountPermission","BasednNames")) {
		extfix.clear();
		if (prefix && *prefix)
			extfix.append(prefix).append(".");
		extfix.append("BasednNames");
		form.appendf("<tr><td><b>BasednNames: </b></td><td>");
		form.appendf("<textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea>", extfix.str());
		form.append("</td></tr>");
	}
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Permissions");
	form.appendf("<tr><td><b>Permissions: </b></td><td>");
	form.appendf("<table><tr><td><textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea></td>", extfix.str());
	form.append("</tr></table>");
	form.append("</td></tr>");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CGroupAccountPermission::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CGroupAccountPermission::serialize(IRpcMessage& rpc_resp)
{
	IEspContext* ctx = rpc_resp.queryContext();
	double clientVer= ctx ? ctx->getClientVersion() : -1; /* no context gets everything */
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_GroupName.marshall(rpc_resp, "GroupName", "", "", "");
	if ((clientVer==-1.0 || clientVer>=1.06))
		m_BasednNames.marshall(rpc_resp, "BasednNames", "Item");
	m_Permissions.marshall(rpc_resp, "Permissions", "Permission");
}


void CGroupAccountPermission::copy(CGroupAccountPermission &from)
{
	m_GroupName.copy(from.m_GroupName);
	m_BasednNames.copy(from.m_BasednNames);
	m_Permissions.copy(from.m_Permissions);
}


void CGroupAccountPermission::copy(IConstGroupAccountPermission &ifrom)
{
	setGroupName(ifrom.getGroupName());
	setBasednNames(ifrom.getBasednNames());
	setPermissions(ifrom.getPermissions());
}


void CGroupAccountPermission::getAttributes(IProperties &attributes)
{
}


void CGroupAccountPermission::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	double clientVer = ctx ? ctx->getClientVersion() : -1;
	m_GroupName.toStr(ctx, buffer, "GroupName", "", true, "", "");
	if ((clientVer==-1.0 || clientVer>=1.06))
		m_BasednNames.toStr(ctx, buffer, "BasednNames", "Item");
	m_Permissions.toStr(ctx, buffer, "Permissions", "Permission");
}


void CGroupAccountPermission::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CGroupAccountPermission::serializer(IEspContext* ctx, IConstGroupAccountPermission &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<GroupAccountPermission>");
	double clientVer = ctx ? ctx->getClientVersion() : -1;
	// field GroupName
	{
		const char* s = src.getGroupName();
		if (s && *s)
		{
			buffer.append("<GroupName>");
			encodeUtf8XML(s,buffer);
			buffer.append("</GroupName>");
		}
	}
	// field BasednNames
	if ((clientVer==-1.0 || clientVer>=1.06))
	{
		StringArray& v = src.getBasednNames();
		if (v.length()>0)
			buffer.append("<BasednNames>");
		for (size32_t i=0;i<v.length();i++)
			buffer.appendf("<Item>%s</Item>",v.item(i));
		if (v.length()>0)
			buffer.append("</BasednNames>");
	}
	// field Permissions
	{
		IArrayOf<IConstAccountPermission>& v = src.getPermissions();
		int size = v.length();
		if (size>0)
			buffer.append("<Permissions>");
		for (int i=0;i<size;i++)
		{
			buffer.append("<Permission>");
			CAccountPermission::serializer(ctx,v.item(i),buffer,false);
			buffer.append("</Permission>");
		}
		if (size>0)
			buffer.append("</Permissions>");
	}
	if (keepRootTag)
		buffer.append("</GroupAccountPermission>");
}

bool CGroupAccountPermission::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_GroupName.unmarshall(rpc_request, "GroupName", basepath);
	hasValue |= m_BasednNames.unmarshall(rpc_request, "BasednNames", basepath);
	hasValue |= m_Permissions.unmarshall(rpc_request, "Permissions", basepath);
	return hasValue;
}

bool CGroupAccountPermission::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_GroupName.unmarshall(ctx, soapval, "GroupName");
	hasValue |= m_BasednNames.unmarshall(ctx, soapval, "BasednNames");
	hasValue |= m_Permissions.unmarshall(ctx, soapval, "Permissions");
	return hasValue;
}

bool CGroupAccountPermission::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_GroupName.unmarshall(ctx, params, attachments, "GroupName", basepath);
	hasValue |= m_BasednNames.unmarshall(ctx, params, attachments, "BasednNames", basepath);
	hasValue |= m_Permissions.unmarshall(ctx, params, attachments, "Permissions", basepath);
	return hasValue;
}

const char * CGroupAccountPermission::getGroupName() { return m_GroupName.query();}
StringArray & CGroupAccountPermission::getBasednNames() { return (StringArray &) m_BasednNames; }
IArrayOf<IConstAccountPermission> & CGroupAccountPermission::getPermissions() { return (IArrayOf<IConstAccountPermission> &) m_Permissions; }
void CGroupAccountPermission::setGroupName(const char * val){ m_GroupName.set(val); }
void CGroupAccountPermission::setBasednNames(StringArray &val){ m_BasednNames->kill();  CloneArray(m_BasednNames.getValue(), val); }
void CGroupAccountPermission::setPermissions(IArrayOf<IEspAccountPermission> &val)
{
	m_Permissions->kill();
	IArrayOf<IConstAccountPermission> &target = m_Permissions.getValue();
	ForEachItemIn(idx, val)
	{
		IEspAccountPermission &item = (val).item(idx);
		item.Link();
		target.append(item);
	}
}
void CGroupAccountPermission::setPermissions(IArrayOf<IConstAccountPermission> &val)
{
	m_Permissions->kill();
	IArrayOf<IConstAccountPermission> &target = m_Permissions.getValue();
	ForEachItemIn(idx, val)
	{
		IConstAccountPermission &item = val.item(idx);
		item.Link();
		target.append(item);
	}
}
extern "C"  IEspGroupAccountPermission *createGroupAccountPermission(const char *serv, const char *msgname){return ((IEspGroupAccountPermission *)new CGroupAccountPermission(serv /*, msgname*/));}
extern "C"  IClientGroupAccountPermission *createClientGroupAccountPermission(const char *serv, const char *msgname){return ((IClientGroupAccountPermission *)new CGroupAccountPermission(serv /*, msgname*/));}

//=======================================================
// class CUserRequest Implementation
//=======================================================

CUserRequest::CUserRequest(const char *serviceName, IRpcMessageBinding *init)
	: m_searchinput(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("UserRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CUserRequest::CUserRequest(const char *serviceName, const char *bc)
	: m_searchinput(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("UserRequest");
}

CUserRequest::CUserRequest(const char *serviceName, IRpcMessage* rpcmsg)
	: m_searchinput(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("UserRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CUserRequest::CUserRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_searchinput(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("UserRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CUserRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"searchinput\" type=\"xsd:string\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CUserRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CUserRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CUserRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("searchinput");
	form.appendf("  <tr><td><b>searchinput: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CUserRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CUserRequest::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_searchinput.marshall(rpc_resp, "searchinput", "", "", "");
}


void CUserRequest::copy(CUserRequest &from)
{
	m_searchinput.copy(from.m_searchinput);
}


void CUserRequest::copy(IConstUserRequest &ifrom)
{
	setSearchinput(ifrom.getSearchinput());
}


void CUserRequest::getAttributes(IProperties &attributes)
{
}


void CUserRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_searchinput.toStr(ctx, buffer, "searchinput", "", true, "", "");
}


void CUserRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CUserRequest::serializer(IEspContext* ctx, IConstUserRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<UserRequest>");
	// field searchinput
	{
		const char* s = src.getSearchinput();
		if (s && *s)
		{
			buffer.append("<searchinput>");
			encodeUtf8XML(s,buffer);
			buffer.append("</searchinput>");
		}
	}
	if (keepRootTag)
		buffer.append("</UserRequest>");
}

bool CUserRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_searchinput.unmarshall(rpc_request, "searchinput", basepath);
	return hasValue;
}

bool CUserRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_searchinput.unmarshall(ctx, soapval, "searchinput");
	return hasValue;
}

bool CUserRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_searchinput.unmarshall(ctx, params, attachments, "searchinput", basepath);
	return hasValue;
}

const char * CUserRequest::getSearchinput() { return m_searchinput.query();}
void CUserRequest::setSearchinput(const char * val){ m_searchinput.set(val); }
extern "C"  IEspUserRequest *createUserRequest(const char *serv){return ((IEspUserRequest *)new CUserRequest(serv));}
extern "C"  IClientUserRequest *createClientUserRequest(const char *serv){return ((IClientUserRequest *)new CUserRequest(serv));}

//=======================================================
// class CUserResponse Implementation
//=======================================================

CUserResponse::CUserResponse(const char *serviceName, IRpcMessageBinding *init)
	: m_NoSecMngr(0, nilIgnore,false),m_toomany(nilIgnore),m_posixok(nilIgnore),m_Users(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("UserResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CUserResponse::CUserResponse(const char *serviceName, const char *bc)
	: m_NoSecMngr(0, nilIgnore,false),m_toomany(nilIgnore),m_posixok(nilIgnore),m_Users(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("UserResponse");
}

CUserResponse::CUserResponse(const char *serviceName, IRpcMessage* rpcmsg)
	: m_NoSecMngr(0, nilIgnore,false),m_toomany(nilIgnore),m_posixok(nilIgnore),m_Users(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("UserResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CUserResponse::CUserResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_NoSecMngr(0, nilIgnore,false),m_toomany(nilIgnore),m_posixok(nilIgnore),m_Users(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("UserResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CUserResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		if (!context.suppressed("UserResponse","NoSecMngr")) {
			schema.append("<xsd:element minOccurs=\"0\" default=\"false\" name=\"NoSecMngr\" type=\"xsd:boolean\"/>\n");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"toomany\" type=\"xsd:boolean\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"posixok\" type=\"xsd:boolean\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Users\">\n");
		schema.append("<xsd:complexType><xsd:sequence>\n");
		schema.append("<xsd:element minOccurs=\"0\" maxOccurs=\"unbounded\" name=\"User\" type=\"tns:UserInfo\"/>");
		schema.append("</xsd:sequence></xsd:complexType>");
		schema.append("</xsd:element>");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	if (!(flags & 0x10)  || (flags & 0x100))
	{
		CUserInfo::getXsdDefinition(context, request, schema, added);
	}
	return schema;
}

void CUserResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CUserResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
	info.addMinVersion("UserResponse","NoSecMngr",1.04);
	if (!added.getValue("UserInfo"))
	{
		added.setValue("UserInfo",1);
		CUserInfo::getMapInfo(info,added);
	}
}

StringBuffer &CUserResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	if (!context.suppressed("UserResponse","NoSecMngr")) {
		extfix.clear();
		if (prefix && *prefix)
			extfix.append(prefix).append(".");
		extfix.append("NoSecMngr");
		
	form.appendf("  <tr><td><b>NoSecMngr? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	}
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("toomany");
	
	form.appendf("  <tr><td><b>toomany? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("posixok");
	
	form.appendf("  <tr><td><b>posixok? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Users");
	form.appendf("<tr><td><b>Users: </b></td><td>");
	form.appendf("<table><tr><td><textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea></td>", extfix.str());
	form.append("</tr></table>");
	form.append("</td></tr>");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CUserResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CUserResponse::serialize(IRpcMessage& rpc_resp)
{
	IEspContext* ctx = rpc_resp.queryContext();
	double clientVer= ctx ? ctx->getClientVersion() : -1; /* no context gets everything */
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
		if ((clientVer==-1.0 || clientVer>=1.04))
			m_NoSecMngr.marshall(rpc_resp, "NoSecMngr", "", "", "");
		m_toomany.marshall(rpc_resp, "toomany", "", "", "");
		m_posixok.marshall(rpc_resp, "posixok", "", "", "");
		m_Users.marshall(rpc_resp, "Users", "User");
	}
}


void CUserResponse::copy(CUserResponse &from)
{
	m_NoSecMngr.copy(from.m_NoSecMngr);
	m_toomany.copy(from.m_toomany);
	m_posixok.copy(from.m_posixok);
	m_Users.copy(from.m_Users);
}


void CUserResponse::copy(IConstUserResponse &ifrom)
{
	setNoSecMngr(ifrom.getNoSecMngr());
	setToomany(ifrom.getToomany());
	setPosixok(ifrom.getPosixok());
	setUsers(ifrom.getUsers());
}


void CUserResponse::getAttributes(IProperties &attributes)
{
}


void CUserResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
		double clientVer = ctx ? ctx->getClientVersion() : -1;
		if ((clientVer==-1.0 || clientVer>=1.04))
			m_NoSecMngr.toStr(ctx, buffer, "NoSecMngr", "", true, "", "");
		m_toomany.toStr(ctx, buffer, "toomany", "", true, "", "");
		m_posixok.toStr(ctx, buffer, "posixok", "", true, "", "");
		m_Users.toStr(ctx, buffer, "Users", "User");
	}
}


void CUserResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CUserResponse::serializer(IEspContext* ctx, IConstUserResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<UserResponse>");
	double clientVer = ctx ? ctx->getClientVersion() : -1;
	// field NoSecMngr
	if ((clientVer==-1.0 || clientVer>=1.04))
	{
		bool b = src.getNoSecMngr();
		if (b)
			buffer.appendf("<NoSecMngr>1</NoSecMngr>");
	}
	// field toomany
	{
		bool b = src.getToomany();
		if (b)
			buffer.appendf("<toomany>1</toomany>");
	}
	// field posixok
	{
		bool b = src.getPosixok();
		if (b)
			buffer.appendf("<posixok>1</posixok>");
	}
	// field Users
	{
		IArrayOf<IConstUserInfo>& v = src.getUsers();
		int size = v.length();
		if (size>0)
			buffer.append("<Users>");
		for (int i=0;i<size;i++)
		{
			buffer.append("<User>");
			CUserInfo::serializer(ctx,v.item(i),buffer,false);
			buffer.append("</User>");
		}
		if (size>0)
			buffer.append("</Users>");
	}
	if (keepRootTag)
		buffer.append("</UserResponse>");
}

bool CUserResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
		hasValue |= m_NoSecMngr.unmarshall(rpc_request, "NoSecMngr", basepath);
		hasValue |= m_toomany.unmarshall(rpc_request, "toomany", basepath);
		hasValue |= m_posixok.unmarshall(rpc_request, "posixok", basepath);
		hasValue |= m_Users.unmarshall(rpc_request, "Users", basepath);
	}
	return hasValue;
}

bool CUserResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_NoSecMngr.unmarshall(ctx, soapval, "NoSecMngr");
	hasValue |= m_toomany.unmarshall(ctx, soapval, "toomany");
	hasValue |= m_posixok.unmarshall(ctx, soapval, "posixok");
	hasValue |= m_Users.unmarshall(ctx, soapval, "Users");
	return hasValue;
}

bool CUserResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_NoSecMngr.unmarshall(ctx, params, attachments, "NoSecMngr", basepath);
	hasValue |= m_toomany.unmarshall(ctx, params, attachments, "toomany", basepath);
	hasValue |= m_posixok.unmarshall(ctx, params, attachments, "posixok", basepath);
	hasValue |= m_Users.unmarshall(ctx, params, attachments, "Users", basepath);
	return hasValue;
}

bool CUserResponse::getNoSecMngr() { return m_NoSecMngr;}
bool CUserResponse::getToomany() { return m_toomany;}
bool CUserResponse::getPosixok() { return m_posixok;}
IArrayOf<IConstUserInfo> & CUserResponse::getUsers() { return (IArrayOf<IConstUserInfo> &) m_Users; }
void CUserResponse::setNoSecMngr(bool val){ m_NoSecMngr=val; }
void CUserResponse::setToomany(bool val){ m_toomany=val; }
void CUserResponse::setPosixok(bool val){ m_posixok=val; }
void CUserResponse::setUsers(IArrayOf<IEspUserInfo> &val)
{
	m_Users->kill();
	IArrayOf<IConstUserInfo> &target = m_Users.getValue();
	ForEachItemIn(idx, val)
	{
		IEspUserInfo &item = (val).item(idx);
		item.Link();
		target.append(item);
	}
}
void CUserResponse::setUsers(IArrayOf<IConstUserInfo> &val)
{
	m_Users->kill();
	IArrayOf<IConstUserInfo> &target = m_Users.getValue();
	ForEachItemIn(idx, val)
	{
		IConstUserInfo &item = val.item(idx);
		item.Link();
		target.append(item);
	}
}
extern "C"  IEspUserResponse *createUserResponse(const char *serv){return ((IEspUserResponse *)new CUserResponse(serv));}
extern "C"  IClientUserResponse *createClientUserResponse(const char *serv){return ((IClientUserResponse *)new CUserResponse(serv));}

//=======================================================
// class CUserQueryRequest Implementation
//=======================================================

CUserQueryRequest::CUserQueryRequest(const char *serviceName, IRpcMessageBinding *init)
	: m_Name(nilRemove),m_PageSize(nilRemove),m_PageStartFrom(nilRemove),m_SortBy(nilRemove),m_Descending(0, nilRemove,false),m_CacheHint(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("UserQueryRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CUserQueryRequest::CUserQueryRequest(const char *serviceName, const char *bc)
	: m_Name(nilRemove),m_PageSize(nilRemove),m_PageStartFrom(nilRemove),m_SortBy(nilRemove),m_Descending(0, nilRemove,false),m_CacheHint(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("UserQueryRequest");
}

CUserQueryRequest::CUserQueryRequest(const char *serviceName, IRpcMessage* rpcmsg)
	: m_Name(nilRemove),m_PageSize(nilRemove),m_PageStartFrom(nilRemove),m_SortBy(nilRemove),m_Descending(0, nilRemove,false),m_CacheHint(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("UserQueryRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CUserQueryRequest::CUserQueryRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_Name(nilRemove),m_PageSize(nilRemove),m_PageStartFrom(nilRemove),m_SortBy(nilRemove),m_Descending(0, nilRemove,false),m_CacheHint(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("UserQueryRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CUserQueryRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Name\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"PageSize\" type=\"xsd:unsignedInt\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"PageStartFrom\" type=\"xsd:long\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"SortBy\" type=\"tns:UserSortBy\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" default=\"false\" name=\"Descending\" type=\"xsd:boolean\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"CacheHint\" type=\"xsd:long\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	if (!(flags & 0x10)  || (flags & 0x100))
	{
		CXUserSortBy::getXsdDefinition(context, request, schema, added);
	}
	return schema;
}

void CUserQueryRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CUserQueryRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
	if (!added.getValue("UserSortBy"))
	{
		added.setValue("UserSortBy",1);
		CXUserSortBy::getMapInfo(info,added);
	}
}

StringBuffer &CUserQueryRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Name");
	form.appendf("  <tr><td><b>Name: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix) extfix.append(prefix).append(".");
		extfix.append("PageSize");
	form.appendf("  <tr><td><b>PageSize: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("PageStartFrom");
	form.appendf("  <tr><td><b>PageStartFrom: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("SortBy");
	form.appendf("  <tr><td><b>SortBy: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Descending");
	
	form.appendf("  <tr><td><b>Descending? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("CacheHint");
	form.appendf("  <tr><td><b>CacheHint: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CUserQueryRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CUserQueryRequest::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_Name.marshall(rpc_resp, "Name", "", "", "");
	m_PageSize.marshall(rpc_resp, "PageSize", "", "", "");
	m_PageStartFrom.marshall(rpc_resp, "PageStartFrom", "", "", "");
	m_SortBy.marshall(rpc_resp, "SortBy", "", "", "");
	m_Descending.marshall(rpc_resp, "Descending", "", "", "");
	m_CacheHint.marshall(rpc_resp, "CacheHint", "", "", "");
}


void CUserQueryRequest::copy(CUserQueryRequest &from)
{
	m_Name.copy(from.m_Name);
	m_PageSize.copy(from.m_PageSize);
	m_PageStartFrom.copy(from.m_PageStartFrom);
	m_SortBy.copy(from.m_SortBy);
	m_Descending.copy(from.m_Descending);
	m_CacheHint.copy(from.m_CacheHint);
}


void CUserQueryRequest::copy(IConstUserQueryRequest &ifrom)
{
	setName(ifrom.getName());
	setPageSize(ifrom.getPageSize());
	setPageStartFrom(ifrom.getPageStartFrom());
	setSortBy(ifrom.getSortBy());
	setDescending(ifrom.getDescending());
	setCacheHint(ifrom.getCacheHint());
}


void CUserQueryRequest::getAttributes(IProperties &attributes)
{
}


void CUserQueryRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_Name.toStr(ctx, buffer, "Name", "", true, "", "");
	m_PageSize.toStr(ctx, buffer, "PageSize", "", true, "", "");
	m_PageStartFrom.toStr(ctx, buffer, "PageStartFrom", "", true, "", "");
	m_SortBy.toStr(ctx, buffer, "SortBy", "", true, "", "");
	m_Descending.toStr(ctx, buffer, "Descending", "", true, "", "");
	m_CacheHint.toStr(ctx, buffer, "CacheHint", "", true, "", "");
}


void CUserQueryRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CUserQueryRequest::serializer(IEspContext* ctx, IConstUserQueryRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<UserQueryRequest>");
	// field Name
	{
		const char* s = src.getName();
		if (s && *s)
		{
			buffer.append("<Name>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Name>");
		}
	}
	// field PageSize
	{
		//*** default kind: TK_UNSIGNED; type=(null), name=PageSize
		buffer.append("<PageSize>");
		buffer.append(src.getPageSize());
		buffer.append("</PageSize>");
	}
	// field PageStartFrom
	{
		//*** default kind: TK_INT; type=int64, name=PageStartFrom
		buffer.append("<PageStartFrom>");
		buffer.append(src.getPageStartFrom());
		buffer.append("</PageStartFrom>");
	}
	// field SortBy
	{
		const char* s = src.getSortByAsString();
		buffer.append("<SortBy>");
		encodeUtf8XML(s,buffer);
		buffer.append("</SortBy>");
	}
	// field Descending
	{
		bool b = src.getDescending();
		if (b)
			buffer.appendf("<Descending>1</Descending>");
	}
	// field CacheHint
	{
		//*** default kind: TK_INT; type=int64, name=CacheHint
		buffer.append("<CacheHint>");
		buffer.append(src.getCacheHint());
		buffer.append("</CacheHint>");
	}
	if (keepRootTag)
		buffer.append("</UserQueryRequest>");
}

bool CUserQueryRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_Name.unmarshall(rpc_request, "Name", basepath);
	hasValue |= m_PageSize.unmarshall(rpc_request, "PageSize", basepath);
	hasValue |= m_PageStartFrom.unmarshall(rpc_request, "PageStartFrom", basepath);
	hasValue |= m_SortBy.unmarshall(rpc_request, "SortBy", basepath);
	hasValue |= m_Descending.unmarshall(rpc_request, "Descending", basepath);
	hasValue |= m_CacheHint.unmarshall(rpc_request, "CacheHint", basepath);
	return hasValue;
}

bool CUserQueryRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Name.unmarshall(ctx, soapval, "Name");
	hasValue |= m_PageSize.unmarshall(ctx, soapval, "PageSize");
	hasValue |= m_PageStartFrom.unmarshall(ctx, soapval, "PageStartFrom");
	hasValue |= m_SortBy.unmarshall(ctx, soapval, "SortBy");
	hasValue |= m_Descending.unmarshall(ctx, soapval, "Descending");
	hasValue |= m_CacheHint.unmarshall(ctx, soapval, "CacheHint");
	return hasValue;
}

bool CUserQueryRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Name.unmarshall(ctx, params, attachments, "Name", basepath);
	hasValue |= m_PageSize.unmarshall(ctx, params, attachments, "PageSize", basepath);
	hasValue |= m_PageStartFrom.unmarshall(ctx, params, attachments, "PageStartFrom", basepath);
	hasValue |= m_SortBy.unmarshall(ctx, params, attachments, "SortBy", basepath);
	hasValue |= m_Descending.unmarshall(ctx, params, attachments, "Descending", basepath);
	hasValue |= m_CacheHint.unmarshall(ctx, params, attachments, "CacheHint", basepath);
	return hasValue;
}

const char * CUserQueryRequest::getName() { return m_Name.query();}
bool CUserQueryRequest::getPageSize_isNull(){return m_PageSize.is_nil();}
unsigned int CUserQueryRequest::getPageSize() { return m_PageSize;}
bool CUserQueryRequest::getPageStartFrom_isNull(){return m_PageStartFrom.is_nil();}
__int64 CUserQueryRequest::getPageStartFrom() { return m_PageStartFrom;}
CUserSortBy CUserQueryRequest::getSortBy() { return m_SortBy.getValue(); }
const char* CUserQueryRequest::getSortByAsString() {  return (const char*)m_SortBy; }
bool CUserQueryRequest::getDescending_isNull(){return m_Descending.is_nil();}
bool CUserQueryRequest::getDescending() { return m_Descending;}
bool CUserQueryRequest::getCacheHint_isNull(){return m_CacheHint.is_nil();}
__int64 CUserQueryRequest::getCacheHint() { return m_CacheHint;}
void CUserQueryRequest::setName(const char * val){ m_Name.set(val); }
void CUserQueryRequest::setPageSize_null(){ m_PageSize.Nil(); }void CUserQueryRequest::setPageSize(unsigned int val){ m_PageSize=val; }
void CUserQueryRequest::setPageStartFrom_null(){ m_PageStartFrom.Nil(); }void CUserQueryRequest::setPageStartFrom(__int64 val){ m_PageStartFrom=val; }
void CUserQueryRequest::setSortBy(CUserSortBy val) { m_SortBy.setValue(val); }
void CUserQueryRequest::setSortBy(const char* val) { m_SortBy.setValue(val); }
void CUserQueryRequest::setDescending_null(){ m_Descending.Nil(); }void CUserQueryRequest::setDescending(bool val){ m_Descending=val; }
void CUserQueryRequest::setCacheHint_null(){ m_CacheHint.Nil(); }void CUserQueryRequest::setCacheHint(__int64 val){ m_CacheHint=val; }
extern "C"  IEspUserQueryRequest *createUserQueryRequest(const char *serv){return ((IEspUserQueryRequest *)new CUserQueryRequest(serv));}
extern "C"  IClientUserQueryRequest *createClientUserQueryRequest(const char *serv){return ((IClientUserQueryRequest *)new CUserQueryRequest(serv));}

//=======================================================
// class CUserQueryResponse Implementation
//=======================================================

CUserQueryResponse::CUserQueryResponse(const char *serviceName, IRpcMessageBinding *init)
	: m_NoSecMngr(0, nilRemove,false),m_Users(nilRemove),m_TotalUsers(nilRemove),m_CacheHint(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("UserQueryResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CUserQueryResponse::CUserQueryResponse(const char *serviceName, const char *bc)
	: m_NoSecMngr(0, nilRemove,false),m_Users(nilRemove),m_TotalUsers(nilRemove),m_CacheHint(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("UserQueryResponse");
}

CUserQueryResponse::CUserQueryResponse(const char *serviceName, IRpcMessage* rpcmsg)
	: m_NoSecMngr(0, nilRemove,false),m_Users(nilRemove),m_TotalUsers(nilRemove),m_CacheHint(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("UserQueryResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CUserQueryResponse::CUserQueryResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_NoSecMngr(0, nilRemove,false),m_Users(nilRemove),m_TotalUsers(nilRemove),m_CacheHint(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("UserQueryResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CUserQueryResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" default=\"false\" name=\"NoSecMngr\" type=\"xsd:boolean\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Users\">\n");
		schema.append("<xsd:complexType><xsd:sequence>\n");
		schema.append("<xsd:element minOccurs=\"0\" maxOccurs=\"unbounded\" name=\"User\" type=\"tns:UserInfo\"/>");
		schema.append("</xsd:sequence></xsd:complexType>");
		schema.append("</xsd:element>");
		schema.append("<xsd:element minOccurs=\"0\" name=\"TotalUsers\" type=\"xsd:long\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"CacheHint\" type=\"xsd:long\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	if (!(flags & 0x10)  || (flags & 0x100))
	{
		CUserInfo::getXsdDefinition(context, request, schema, added);
	}
	return schema;
}

void CUserQueryResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CUserQueryResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
	if (!added.getValue("UserInfo"))
	{
		added.setValue("UserInfo",1);
		CUserInfo::getMapInfo(info,added);
	}
}

StringBuffer &CUserQueryResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("NoSecMngr");
	
	form.appendf("  <tr><td><b>NoSecMngr? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Users");
	form.appendf("<tr><td><b>Users: </b></td><td>");
	form.appendf("<table><tr><td><textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea></td>", extfix.str());
	form.append("</tr></table>");
	form.append("</td></tr>");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("TotalUsers");
	form.appendf("  <tr><td><b>TotalUsers: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("CacheHint");
	form.appendf("  <tr><td><b>CacheHint: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CUserQueryResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CUserQueryResponse::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
		m_NoSecMngr.marshall(rpc_resp, "NoSecMngr", "", "", "");
		m_Users.marshall(rpc_resp, "Users", "User");
		m_TotalUsers.marshall(rpc_resp, "TotalUsers", "", "", "");
		m_CacheHint.marshall(rpc_resp, "CacheHint", "", "", "");
	}
}


void CUserQueryResponse::copy(CUserQueryResponse &from)
{
	m_NoSecMngr.copy(from.m_NoSecMngr);
	m_Users.copy(from.m_Users);
	m_TotalUsers.copy(from.m_TotalUsers);
	m_CacheHint.copy(from.m_CacheHint);
}


void CUserQueryResponse::copy(IConstUserQueryResponse &ifrom)
{
	setNoSecMngr(ifrom.getNoSecMngr());
	setUsers(ifrom.getUsers());
	setTotalUsers(ifrom.getTotalUsers());
	setCacheHint(ifrom.getCacheHint());
}


void CUserQueryResponse::getAttributes(IProperties &attributes)
{
}


void CUserQueryResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
		m_NoSecMngr.toStr(ctx, buffer, "NoSecMngr", "", true, "", "");
		m_Users.toStr(ctx, buffer, "Users", "User");
		m_TotalUsers.toStr(ctx, buffer, "TotalUsers", "", true, "", "");
		m_CacheHint.toStr(ctx, buffer, "CacheHint", "", true, "", "");
	}
}


void CUserQueryResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CUserQueryResponse::serializer(IEspContext* ctx, IConstUserQueryResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<UserQueryResponse>");
	// field NoSecMngr
	{
		bool b = src.getNoSecMngr();
		if (b)
			buffer.appendf("<NoSecMngr>1</NoSecMngr>");
	}
	// field Users
	{
		IArrayOf<IConstUserInfo>& v = src.getUsers();
		int size = v.length();
		if (size>0)
			buffer.append("<Users>");
		for (int i=0;i<size;i++)
		{
			buffer.append("<User>");
			CUserInfo::serializer(ctx,v.item(i),buffer,false);
			buffer.append("</User>");
		}
		if (size>0)
			buffer.append("</Users>");
	}
	// field TotalUsers
	{
		//*** default kind: TK_INT; type=int64, name=TotalUsers
		buffer.append("<TotalUsers>");
		buffer.append(src.getTotalUsers());
		buffer.append("</TotalUsers>");
	}
	// field CacheHint
	{
		//*** default kind: TK_INT; type=int64, name=CacheHint
		buffer.append("<CacheHint>");
		buffer.append(src.getCacheHint());
		buffer.append("</CacheHint>");
	}
	if (keepRootTag)
		buffer.append("</UserQueryResponse>");
}

bool CUserQueryResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
		hasValue |= m_NoSecMngr.unmarshall(rpc_request, "NoSecMngr", basepath);
		hasValue |= m_Users.unmarshall(rpc_request, "Users", basepath);
		hasValue |= m_TotalUsers.unmarshall(rpc_request, "TotalUsers", basepath);
		hasValue |= m_CacheHint.unmarshall(rpc_request, "CacheHint", basepath);
	}
	return hasValue;
}

bool CUserQueryResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_NoSecMngr.unmarshall(ctx, soapval, "NoSecMngr");
	hasValue |= m_Users.unmarshall(ctx, soapval, "Users");
	hasValue |= m_TotalUsers.unmarshall(ctx, soapval, "TotalUsers");
	hasValue |= m_CacheHint.unmarshall(ctx, soapval, "CacheHint");
	return hasValue;
}

bool CUserQueryResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_NoSecMngr.unmarshall(ctx, params, attachments, "NoSecMngr", basepath);
	hasValue |= m_Users.unmarshall(ctx, params, attachments, "Users", basepath);
	hasValue |= m_TotalUsers.unmarshall(ctx, params, attachments, "TotalUsers", basepath);
	hasValue |= m_CacheHint.unmarshall(ctx, params, attachments, "CacheHint", basepath);
	return hasValue;
}

bool CUserQueryResponse::getNoSecMngr_isNull(){return m_NoSecMngr.is_nil();}
bool CUserQueryResponse::getNoSecMngr() { return m_NoSecMngr;}
IArrayOf<IConstUserInfo> & CUserQueryResponse::getUsers() { return (IArrayOf<IConstUserInfo> &) m_Users; }
bool CUserQueryResponse::getTotalUsers_isNull(){return m_TotalUsers.is_nil();}
__int64 CUserQueryResponse::getTotalUsers() { return m_TotalUsers;}
bool CUserQueryResponse::getCacheHint_isNull(){return m_CacheHint.is_nil();}
__int64 CUserQueryResponse::getCacheHint() { return m_CacheHint;}
void CUserQueryResponse::setNoSecMngr_null(){ m_NoSecMngr.Nil(); }void CUserQueryResponse::setNoSecMngr(bool val){ m_NoSecMngr=val; }
void CUserQueryResponse::setUsers(IArrayOf<IEspUserInfo> &val)
{
	m_Users->kill();
	IArrayOf<IConstUserInfo> &target = m_Users.getValue();
	ForEachItemIn(idx, val)
	{
		IEspUserInfo &item = (val).item(idx);
		item.Link();
		target.append(item);
	}
}
void CUserQueryResponse::setUsers(IArrayOf<IConstUserInfo> &val)
{
	m_Users->kill();
	IArrayOf<IConstUserInfo> &target = m_Users.getValue();
	ForEachItemIn(idx, val)
	{
		IConstUserInfo &item = val.item(idx);
		item.Link();
		target.append(item);
	}
}
void CUserQueryResponse::setTotalUsers_null(){ m_TotalUsers.Nil(); }void CUserQueryResponse::setTotalUsers(__int64 val){ m_TotalUsers=val; }
void CUserQueryResponse::setCacheHint_null(){ m_CacheHint.Nil(); }void CUserQueryResponse::setCacheHint(__int64 val){ m_CacheHint=val; }
extern "C"  IEspUserQueryResponse *createUserQueryResponse(const char *serv){return ((IEspUserQueryResponse *)new CUserQueryResponse(serv));}
extern "C"  IClientUserQueryResponse *createClientUserQueryResponse(const char *serv){return ((IClientUserQueryResponse *)new CUserQueryResponse(serv));}

//=======================================================
// class CUserEditRequest Implementation
//=======================================================

CUserEditRequest::CUserEditRequest(const char *serviceName, IRpcMessageBinding *init)
	: m_username(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("UserEditRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CUserEditRequest::CUserEditRequest(const char *serviceName, const char *bc)
	: m_username(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("UserEditRequest");
}

CUserEditRequest::CUserEditRequest(const char *serviceName, IRpcMessage* rpcmsg)
	: m_username(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("UserEditRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CUserEditRequest::CUserEditRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_username(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("UserEditRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CUserEditRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"username\" type=\"xsd:string\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CUserEditRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CUserEditRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CUserEditRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("username");
	form.appendf("  <tr><td><b>username: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CUserEditRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CUserEditRequest::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_username.marshall(rpc_resp, "username", "", "", "");
}


void CUserEditRequest::copy(CUserEditRequest &from)
{
	m_username.copy(from.m_username);
}


void CUserEditRequest::copy(IConstUserEditRequest &ifrom)
{
	setUsername(ifrom.getUsername());
}


void CUserEditRequest::getAttributes(IProperties &attributes)
{
}


void CUserEditRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_username.toStr(ctx, buffer, "username", "", true, "", "");
}


void CUserEditRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CUserEditRequest::serializer(IEspContext* ctx, IConstUserEditRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<UserEditRequest>");
	// field username
	{
		const char* s = src.getUsername();
		if (s && *s)
		{
			buffer.append("<username>");
			encodeUtf8XML(s,buffer);
			buffer.append("</username>");
		}
	}
	if (keepRootTag)
		buffer.append("</UserEditRequest>");
}

bool CUserEditRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_username.unmarshall(rpc_request, "username", basepath);
	return hasValue;
}

bool CUserEditRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_username.unmarshall(ctx, soapval, "username");
	return hasValue;
}

bool CUserEditRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_username.unmarshall(ctx, params, attachments, "username", basepath);
	return hasValue;
}

const char * CUserEditRequest::getUsername() { return m_username.query();}
void CUserEditRequest::setUsername(const char * val){ m_username.set(val); }
extern "C"  IEspUserEditRequest *createUserEditRequest(const char *serv){return ((IEspUserEditRequest *)new CUserEditRequest(serv));}
extern "C"  IClientUserEditRequest *createClientUserEditRequest(const char *serv){return ((IClientUserEditRequest *)new CUserEditRequest(serv));}

//=======================================================
// class CUserEditResponse Implementation
//=======================================================

CUserEditResponse::CUserEditResponse(const char *serviceName, IRpcMessageBinding *init)
	: m_username(nilIgnore),m_Groups(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("UserEditResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CUserEditResponse::CUserEditResponse(const char *serviceName, const char *bc)
	: m_username(nilIgnore),m_Groups(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("UserEditResponse");
}

CUserEditResponse::CUserEditResponse(const char *serviceName, IRpcMessage* rpcmsg)
	: m_username(nilIgnore),m_Groups(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("UserEditResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CUserEditResponse::CUserEditResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_username(nilIgnore),m_Groups(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("UserEditResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CUserEditResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"username\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Groups\">\n");
		schema.append("<xsd:complexType><xsd:sequence>\n");
		schema.append("<xsd:element minOccurs=\"0\" maxOccurs=\"unbounded\" name=\"Group\" type=\"tns:GroupInfo\"/>");
		schema.append("</xsd:sequence></xsd:complexType>");
		schema.append("</xsd:element>");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	if (!(flags & 0x10)  || (flags & 0x100))
	{
		CGroupInfo::getXsdDefinition(context, request, schema, added);
	}
	return schema;
}

void CUserEditResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CUserEditResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
	if (!added.getValue("GroupInfo"))
	{
		added.setValue("GroupInfo",1);
		CGroupInfo::getMapInfo(info,added);
	}
}

StringBuffer &CUserEditResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("username");
	form.appendf("  <tr><td><b>username: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Groups");
	form.appendf("<tr><td><b>Groups: </b></td><td>");
	form.appendf("<table><tr><td><textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea></td>", extfix.str());
	form.append("</tr></table>");
	form.append("</td></tr>");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CUserEditResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CUserEditResponse::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
		m_username.marshall(rpc_resp, "username", "", "", "");
		m_Groups.marshall(rpc_resp, "Groups", "Group");
	}
}


void CUserEditResponse::copy(CUserEditResponse &from)
{
	m_username.copy(from.m_username);
	m_Groups.copy(from.m_Groups);
}


void CUserEditResponse::copy(IConstUserEditResponse &ifrom)
{
	setUsername(ifrom.getUsername());
	setGroups(ifrom.getGroups());
}


void CUserEditResponse::getAttributes(IProperties &attributes)
{
}


void CUserEditResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
		m_username.toStr(ctx, buffer, "username", "", true, "", "");
		m_Groups.toStr(ctx, buffer, "Groups", "Group");
	}
}


void CUserEditResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CUserEditResponse::serializer(IEspContext* ctx, IConstUserEditResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<UserEditResponse>");
	// field username
	{
		const char* s = src.getUsername();
		if (s && *s)
		{
			buffer.append("<username>");
			encodeUtf8XML(s,buffer);
			buffer.append("</username>");
		}
	}
	// field Groups
	{
		IArrayOf<IConstGroupInfo>& v = src.getGroups();
		int size = v.length();
		if (size>0)
			buffer.append("<Groups>");
		for (int i=0;i<size;i++)
		{
			buffer.append("<Group>");
			CGroupInfo::serializer(ctx,v.item(i),buffer,false);
			buffer.append("</Group>");
		}
		if (size>0)
			buffer.append("</Groups>");
	}
	if (keepRootTag)
		buffer.append("</UserEditResponse>");
}

bool CUserEditResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
		hasValue |= m_username.unmarshall(rpc_request, "username", basepath);
		hasValue |= m_Groups.unmarshall(rpc_request, "Groups", basepath);
	}
	return hasValue;
}

bool CUserEditResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_username.unmarshall(ctx, soapval, "username");
	hasValue |= m_Groups.unmarshall(ctx, soapval, "Groups");
	return hasValue;
}

bool CUserEditResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_username.unmarshall(ctx, params, attachments, "username", basepath);
	hasValue |= m_Groups.unmarshall(ctx, params, attachments, "Groups", basepath);
	return hasValue;
}

const char * CUserEditResponse::getUsername() { return m_username.query();}
IArrayOf<IConstGroupInfo> & CUserEditResponse::getGroups() { return (IArrayOf<IConstGroupInfo> &) m_Groups; }
void CUserEditResponse::setUsername(const char * val){ m_username.set(val); }
void CUserEditResponse::setGroups(IArrayOf<IEspGroupInfo> &val)
{
	m_Groups->kill();
	IArrayOf<IConstGroupInfo> &target = m_Groups.getValue();
	ForEachItemIn(idx, val)
	{
		IEspGroupInfo &item = (val).item(idx);
		item.Link();
		target.append(item);
	}
}
void CUserEditResponse::setGroups(IArrayOf<IConstGroupInfo> &val)
{
	m_Groups->kill();
	IArrayOf<IConstGroupInfo> &target = m_Groups.getValue();
	ForEachItemIn(idx, val)
	{
		IConstGroupInfo &item = val.item(idx);
		item.Link();
		target.append(item);
	}
}
extern "C"  IEspUserEditResponse *createUserEditResponse(const char *serv){return ((IEspUserEditResponse *)new CUserEditResponse(serv));}
extern "C"  IClientUserEditResponse *createClientUserEditResponse(const char *serv){return ((IClientUserEditResponse *)new CUserEditResponse(serv));}

//=======================================================
// class CUserGroupEditInputRequest Implementation
//=======================================================

CUserGroupEditInputRequest::CUserGroupEditInputRequest(const char *serviceName, IRpcMessageBinding *init)
	: m_username(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("UserGroupEditInputRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CUserGroupEditInputRequest::CUserGroupEditInputRequest(const char *serviceName, const char *bc)
	: m_username(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("UserGroupEditInputRequest");
}

CUserGroupEditInputRequest::CUserGroupEditInputRequest(const char *serviceName, IRpcMessage* rpcmsg)
	: m_username(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("UserGroupEditInputRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CUserGroupEditInputRequest::CUserGroupEditInputRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_username(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("UserGroupEditInputRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CUserGroupEditInputRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"username\" type=\"xsd:string\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CUserGroupEditInputRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CUserGroupEditInputRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CUserGroupEditInputRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("username");
	form.appendf("  <tr><td><b>username: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CUserGroupEditInputRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CUserGroupEditInputRequest::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_username.marshall(rpc_resp, "username", "", "", "");
}


void CUserGroupEditInputRequest::copy(CUserGroupEditInputRequest &from)
{
	m_username.copy(from.m_username);
}


void CUserGroupEditInputRequest::copy(IConstUserGroupEditInputRequest &ifrom)
{
	setUsername(ifrom.getUsername());
}


void CUserGroupEditInputRequest::getAttributes(IProperties &attributes)
{
}


void CUserGroupEditInputRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_username.toStr(ctx, buffer, "username", "", true, "", "");
}


void CUserGroupEditInputRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CUserGroupEditInputRequest::serializer(IEspContext* ctx, IConstUserGroupEditInputRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<UserGroupEditInputRequest>");
	// field username
	{
		const char* s = src.getUsername();
		if (s && *s)
		{
			buffer.append("<username>");
			encodeUtf8XML(s,buffer);
			buffer.append("</username>");
		}
	}
	if (keepRootTag)
		buffer.append("</UserGroupEditInputRequest>");
}

bool CUserGroupEditInputRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_username.unmarshall(rpc_request, "username", basepath);
	return hasValue;
}

bool CUserGroupEditInputRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_username.unmarshall(ctx, soapval, "username");
	return hasValue;
}

bool CUserGroupEditInputRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_username.unmarshall(ctx, params, attachments, "username", basepath);
	return hasValue;
}

const char * CUserGroupEditInputRequest::getUsername() { return m_username.query();}
void CUserGroupEditInputRequest::setUsername(const char * val){ m_username.set(val); }
extern "C"  IEspUserGroupEditInputRequest *createUserGroupEditInputRequest(const char *serv){return ((IEspUserGroupEditInputRequest *)new CUserGroupEditInputRequest(serv));}
extern "C"  IClientUserGroupEditInputRequest *createClientUserGroupEditInputRequest(const char *serv){return ((IClientUserGroupEditInputRequest *)new CUserGroupEditInputRequest(serv));}

//=======================================================
// class CUserGroupEditInputResponse Implementation
//=======================================================

CUserGroupEditInputResponse::CUserGroupEditInputResponse(const char *serviceName, IRpcMessageBinding *init)
	: m_username(nilIgnore),m_Groups(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("UserGroupEditInputResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CUserGroupEditInputResponse::CUserGroupEditInputResponse(const char *serviceName, const char *bc)
	: m_username(nilIgnore),m_Groups(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("UserGroupEditInputResponse");
}

CUserGroupEditInputResponse::CUserGroupEditInputResponse(const char *serviceName, IRpcMessage* rpcmsg)
	: m_username(nilIgnore),m_Groups(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("UserGroupEditInputResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CUserGroupEditInputResponse::CUserGroupEditInputResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_username(nilIgnore),m_Groups(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("UserGroupEditInputResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CUserGroupEditInputResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"username\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Groups\">\n");
		schema.append("<xsd:complexType><xsd:sequence>\n");
		schema.append("<xsd:element minOccurs=\"0\" maxOccurs=\"unbounded\" name=\"Group\" type=\"tns:GroupInfo\"/>");
		schema.append("</xsd:sequence></xsd:complexType>");
		schema.append("</xsd:element>");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	if (!(flags & 0x10)  || (flags & 0x100))
	{
		CGroupInfo::getXsdDefinition(context, request, schema, added);
	}
	return schema;
}

void CUserGroupEditInputResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CUserGroupEditInputResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
	if (!added.getValue("GroupInfo"))
	{
		added.setValue("GroupInfo",1);
		CGroupInfo::getMapInfo(info,added);
	}
}

StringBuffer &CUserGroupEditInputResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("username");
	form.appendf("  <tr><td><b>username: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Groups");
	form.appendf("<tr><td><b>Groups: </b></td><td>");
	form.appendf("<table><tr><td><textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea></td>", extfix.str());
	form.append("</tr></table>");
	form.append("</td></tr>");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CUserGroupEditInputResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CUserGroupEditInputResponse::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
		m_username.marshall(rpc_resp, "username", "", "", "");
		m_Groups.marshall(rpc_resp, "Groups", "Group");
	}
}


void CUserGroupEditInputResponse::copy(CUserGroupEditInputResponse &from)
{
	m_username.copy(from.m_username);
	m_Groups.copy(from.m_Groups);
}


void CUserGroupEditInputResponse::copy(IConstUserGroupEditInputResponse &ifrom)
{
	setUsername(ifrom.getUsername());
	setGroups(ifrom.getGroups());
}


void CUserGroupEditInputResponse::getAttributes(IProperties &attributes)
{
}


void CUserGroupEditInputResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
		m_username.toStr(ctx, buffer, "username", "", true, "", "");
		m_Groups.toStr(ctx, buffer, "Groups", "Group");
	}
}


void CUserGroupEditInputResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CUserGroupEditInputResponse::serializer(IEspContext* ctx, IConstUserGroupEditInputResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<UserGroupEditInputResponse>");
	// field username
	{
		const char* s = src.getUsername();
		if (s && *s)
		{
			buffer.append("<username>");
			encodeUtf8XML(s,buffer);
			buffer.append("</username>");
		}
	}
	// field Groups
	{
		IArrayOf<IConstGroupInfo>& v = src.getGroups();
		int size = v.length();
		if (size>0)
			buffer.append("<Groups>");
		for (int i=0;i<size;i++)
		{
			buffer.append("<Group>");
			CGroupInfo::serializer(ctx,v.item(i),buffer,false);
			buffer.append("</Group>");
		}
		if (size>0)
			buffer.append("</Groups>");
	}
	if (keepRootTag)
		buffer.append("</UserGroupEditInputResponse>");
}

bool CUserGroupEditInputResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
		hasValue |= m_username.unmarshall(rpc_request, "username", basepath);
		hasValue |= m_Groups.unmarshall(rpc_request, "Groups", basepath);
	}
	return hasValue;
}

bool CUserGroupEditInputResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_username.unmarshall(ctx, soapval, "username");
	hasValue |= m_Groups.unmarshall(ctx, soapval, "Groups");
	return hasValue;
}

bool CUserGroupEditInputResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_username.unmarshall(ctx, params, attachments, "username", basepath);
	hasValue |= m_Groups.unmarshall(ctx, params, attachments, "Groups", basepath);
	return hasValue;
}

const char * CUserGroupEditInputResponse::getUsername() { return m_username.query();}
IArrayOf<IConstGroupInfo> & CUserGroupEditInputResponse::getGroups() { return (IArrayOf<IConstGroupInfo> &) m_Groups; }
void CUserGroupEditInputResponse::setUsername(const char * val){ m_username.set(val); }
void CUserGroupEditInputResponse::setGroups(IArrayOf<IEspGroupInfo> &val)
{
	m_Groups->kill();
	IArrayOf<IConstGroupInfo> &target = m_Groups.getValue();
	ForEachItemIn(idx, val)
	{
		IEspGroupInfo &item = (val).item(idx);
		item.Link();
		target.append(item);
	}
}
void CUserGroupEditInputResponse::setGroups(IArrayOf<IConstGroupInfo> &val)
{
	m_Groups->kill();
	IArrayOf<IConstGroupInfo> &target = m_Groups.getValue();
	ForEachItemIn(idx, val)
	{
		IConstGroupInfo &item = val.item(idx);
		item.Link();
		target.append(item);
	}
}
extern "C"  IEspUserGroupEditInputResponse *createUserGroupEditInputResponse(const char *serv){return ((IEspUserGroupEditInputResponse *)new CUserGroupEditInputResponse(serv));}
extern "C"  IClientUserGroupEditInputResponse *createClientUserGroupEditInputResponse(const char *serv){return ((IClientUserGroupEditInputResponse *)new CUserGroupEditInputResponse(serv));}

//=======================================================
// class CUserGroupEditRequest Implementation
//=======================================================

CUserGroupEditRequest::CUserGroupEditRequest(const char *serviceName, IRpcMessageBinding *init)
	: m_username(nilIgnore),m_action(nilIgnore),m_groupnames(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("UserGroupEditRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CUserGroupEditRequest::CUserGroupEditRequest(const char *serviceName, const char *bc)
	: m_username(nilIgnore),m_action(nilIgnore),m_groupnames(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("UserGroupEditRequest");
}

CUserGroupEditRequest::CUserGroupEditRequest(const char *serviceName, IRpcMessage* rpcmsg)
	: m_username(nilIgnore),m_action(nilIgnore),m_groupnames(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("UserGroupEditRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CUserGroupEditRequest::CUserGroupEditRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_username(nilIgnore),m_action(nilIgnore),m_groupnames(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("UserGroupEditRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CUserGroupEditRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"username\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"action\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"groupnames\" type=\"tns:EspStringArray\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	if (added.getValue("EspStringArray")==NULL) {
		addEspNativeArray(schema,"string","EspStringArray");
		added.setValue("EspStringArray",1);
	}
	return schema;
}

void CUserGroupEditRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CUserGroupEditRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CUserGroupEditRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("username");
	form.appendf("  <tr><td><b>username: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("action");
	form.appendf("  <tr><td><b>action: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("groupnames");
	form.appendf("<tr><td><b>groupnames: </b></td><td>");
	form.appendf("<textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea>", extfix.str());
	form.append("</td></tr>");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CUserGroupEditRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CUserGroupEditRequest::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_username.marshall(rpc_resp, "username", "", "", "");
	m_action.marshall(rpc_resp, "action", "", "", "");
	m_groupnames.marshall(rpc_resp, "groupnames", "Item");
}


void CUserGroupEditRequest::copy(CUserGroupEditRequest &from)
{
	m_username.copy(from.m_username);
	m_action.copy(from.m_action);
	m_groupnames.copy(from.m_groupnames);
}


void CUserGroupEditRequest::copy(IConstUserGroupEditRequest &ifrom)
{
	setUsername(ifrom.getUsername());
	setAction(ifrom.getAction());
	setGroupnames(ifrom.getGroupnames());
}


void CUserGroupEditRequest::getAttributes(IProperties &attributes)
{
}


void CUserGroupEditRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_username.toStr(ctx, buffer, "username", "", true, "", "");
	m_action.toStr(ctx, buffer, "action", "", true, "", "");
	m_groupnames.toStr(ctx, buffer, "groupnames", "Item");
}


void CUserGroupEditRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CUserGroupEditRequest::serializer(IEspContext* ctx, IConstUserGroupEditRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<UserGroupEditRequest>");
	// field username
	{
		const char* s = src.getUsername();
		if (s && *s)
		{
			buffer.append("<username>");
			encodeUtf8XML(s,buffer);
			buffer.append("</username>");
		}
	}
	// field action
	{
		const char* s = src.getAction();
		if (s && *s)
		{
			buffer.append("<action>");
			encodeUtf8XML(s,buffer);
			buffer.append("</action>");
		}
	}
	// field groupnames
	{
		StringArray& v = src.getGroupnames();
		if (v.length()>0)
			buffer.append("<groupnames>");
		for (size32_t i=0;i<v.length();i++)
			buffer.appendf("<Item>%s</Item>",v.item(i));
		if (v.length()>0)
			buffer.append("</groupnames>");
	}
	if (keepRootTag)
		buffer.append("</UserGroupEditRequest>");
}

bool CUserGroupEditRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_username.unmarshall(rpc_request, "username", basepath);
	hasValue |= m_action.unmarshall(rpc_request, "action", basepath);
	hasValue |= m_groupnames.unmarshall(rpc_request, "groupnames", basepath);
	return hasValue;
}

bool CUserGroupEditRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_username.unmarshall(ctx, soapval, "username");
	hasValue |= m_action.unmarshall(ctx, soapval, "action");
	hasValue |= m_groupnames.unmarshall(ctx, soapval, "groupnames");
	return hasValue;
}

bool CUserGroupEditRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_username.unmarshall(ctx, params, attachments, "username", basepath);
	hasValue |= m_action.unmarshall(ctx, params, attachments, "action", basepath);
	hasValue |= m_groupnames.unmarshall(ctx, params, attachments, "groupnames", basepath);
	return hasValue;
}

const char * CUserGroupEditRequest::getUsername() { return m_username.query();}
const char * CUserGroupEditRequest::getAction() { return m_action.query();}
StringArray & CUserGroupEditRequest::getGroupnames() { return (StringArray &) m_groupnames; }
void CUserGroupEditRequest::setUsername(const char * val){ m_username.set(val); }
void CUserGroupEditRequest::setAction(const char * val){ m_action.set(val); }
void CUserGroupEditRequest::setGroupnames(StringArray &val){ m_groupnames->kill();  CloneArray(m_groupnames.getValue(), val); }
extern "C"  IEspUserGroupEditRequest *createUserGroupEditRequest(const char *serv){return ((IEspUserGroupEditRequest *)new CUserGroupEditRequest(serv));}
extern "C"  IClientUserGroupEditRequest *createClientUserGroupEditRequest(const char *serv){return ((IClientUserGroupEditRequest *)new CUserGroupEditRequest(serv));}

//=======================================================
// class CUserGroupEditResponse Implementation
//=======================================================

CUserGroupEditResponse::CUserGroupEditResponse(const char *serviceName, IRpcMessageBinding *init)
	: m_username(nilIgnore),m_action(nilIgnore),m_retcode(nilIgnore),m_retmsg(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("UserGroupEditResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CUserGroupEditResponse::CUserGroupEditResponse(const char *serviceName, const char *bc)
	: m_username(nilIgnore),m_action(nilIgnore),m_retcode(nilIgnore),m_retmsg(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("UserGroupEditResponse");
}

CUserGroupEditResponse::CUserGroupEditResponse(const char *serviceName, IRpcMessage* rpcmsg)
	: m_username(nilIgnore),m_action(nilIgnore),m_retcode(nilIgnore),m_retmsg(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("UserGroupEditResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CUserGroupEditResponse::CUserGroupEditResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_username(nilIgnore),m_action(nilIgnore),m_retcode(nilIgnore),m_retmsg(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("UserGroupEditResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CUserGroupEditResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"username\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"action\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"retcode\" type=\"xsd:int\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"retmsg\" type=\"xsd:string\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CUserGroupEditResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CUserGroupEditResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CUserGroupEditResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("username");
	form.appendf("  <tr><td><b>username: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("action");
	form.appendf("  <tr><td><b>action: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix) extfix.append(prefix).append(".");
		extfix.append("retcode");
	form.appendf("  <tr><td><b>retcode: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("retmsg");
	form.appendf("  <tr><td><b>retmsg: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CUserGroupEditResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CUserGroupEditResponse::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
		m_username.marshall(rpc_resp, "username", "", "", "");
		m_action.marshall(rpc_resp, "action", "", "", "");
		m_retcode.marshall(rpc_resp, "retcode", "", "", "");
		m_retmsg.marshall(rpc_resp, "retmsg", "", "", "");
	}
}


void CUserGroupEditResponse::copy(CUserGroupEditResponse &from)
{
	m_username.copy(from.m_username);
	m_action.copy(from.m_action);
	m_retcode.copy(from.m_retcode);
	m_retmsg.copy(from.m_retmsg);
}


void CUserGroupEditResponse::copy(IConstUserGroupEditResponse &ifrom)
{
	setUsername(ifrom.getUsername());
	setAction(ifrom.getAction());
	setRetcode(ifrom.getRetcode());
	setRetmsg(ifrom.getRetmsg());
}


void CUserGroupEditResponse::getAttributes(IProperties &attributes)
{
}


void CUserGroupEditResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
		m_username.toStr(ctx, buffer, "username", "", true, "", "");
		m_action.toStr(ctx, buffer, "action", "", true, "", "");
		m_retcode.toStr(ctx, buffer, "retcode", "", true, "", "");
		m_retmsg.toStr(ctx, buffer, "retmsg", "", true, "", "");
	}
}


void CUserGroupEditResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CUserGroupEditResponse::serializer(IEspContext* ctx, IConstUserGroupEditResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<UserGroupEditResponse>");
	// field username
	{
		const char* s = src.getUsername();
		if (s && *s)
		{
			buffer.append("<username>");
			encodeUtf8XML(s,buffer);
			buffer.append("</username>");
		}
	}
	// field action
	{
		const char* s = src.getAction();
		if (s && *s)
		{
			buffer.append("<action>");
			encodeUtf8XML(s,buffer);
			buffer.append("</action>");
		}
	}
	// field retcode
	{
		int n = src.getRetcode();
		if (n)
			buffer.appendf("<retcode>%d</retcode>", n);
	}
	// field retmsg
	{
		const char* s = src.getRetmsg();
		if (s && *s)
		{
			buffer.append("<retmsg>");
			encodeUtf8XML(s,buffer);
			buffer.append("</retmsg>");
		}
	}
	if (keepRootTag)
		buffer.append("</UserGroupEditResponse>");
}

bool CUserGroupEditResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
		hasValue |= m_username.unmarshall(rpc_request, "username", basepath);
		hasValue |= m_action.unmarshall(rpc_request, "action", basepath);
		hasValue |= m_retcode.unmarshall(rpc_request, "retcode", basepath);
		hasValue |= m_retmsg.unmarshall(rpc_request, "retmsg", basepath);
	}
	return hasValue;
}

bool CUserGroupEditResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_username.unmarshall(ctx, soapval, "username");
	hasValue |= m_action.unmarshall(ctx, soapval, "action");
	hasValue |= m_retcode.unmarshall(ctx, soapval, "retcode");
	hasValue |= m_retmsg.unmarshall(ctx, soapval, "retmsg");
	return hasValue;
}

bool CUserGroupEditResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_username.unmarshall(ctx, params, attachments, "username", basepath);
	hasValue |= m_action.unmarshall(ctx, params, attachments, "action", basepath);
	hasValue |= m_retcode.unmarshall(ctx, params, attachments, "retcode", basepath);
	hasValue |= m_retmsg.unmarshall(ctx, params, attachments, "retmsg", basepath);
	return hasValue;
}

const char * CUserGroupEditResponse::getUsername() { return m_username.query();}
const char * CUserGroupEditResponse::getAction() { return m_action.query();}
int CUserGroupEditResponse::getRetcode() { return m_retcode;}
const char * CUserGroupEditResponse::getRetmsg() { return m_retmsg.query();}
void CUserGroupEditResponse::setUsername(const char * val){ m_username.set(val); }
void CUserGroupEditResponse::setAction(const char * val){ m_action.set(val); }
void CUserGroupEditResponse::setRetcode(int val){ m_retcode=val; }
void CUserGroupEditResponse::setRetmsg(const char * val){ m_retmsg.set(val); }
extern "C"  IEspUserGroupEditResponse *createUserGroupEditResponse(const char *serv){return ((IEspUserGroupEditResponse *)new CUserGroupEditResponse(serv));}
extern "C"  IClientUserGroupEditResponse *createClientUserGroupEditResponse(const char *serv){return ((IClientUserGroupEditResponse *)new CUserGroupEditResponse(serv));}

//=======================================================
// class CUserPosixInputRequest Implementation
//=======================================================

CUserPosixInputRequest::CUserPosixInputRequest(const char *serviceName, IRpcMessageBinding *init)
	: m_username(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("UserPosixInputRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CUserPosixInputRequest::CUserPosixInputRequest(const char *serviceName, const char *bc)
	: m_username(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("UserPosixInputRequest");
}

CUserPosixInputRequest::CUserPosixInputRequest(const char *serviceName, IRpcMessage* rpcmsg)
	: m_username(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("UserPosixInputRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CUserPosixInputRequest::CUserPosixInputRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_username(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("UserPosixInputRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CUserPosixInputRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"username\" type=\"xsd:string\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CUserPosixInputRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CUserPosixInputRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CUserPosixInputRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("username");
	form.appendf("  <tr><td><b>username: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CUserPosixInputRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CUserPosixInputRequest::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_username.marshall(rpc_resp, "username", "", "", "");
}


void CUserPosixInputRequest::copy(CUserPosixInputRequest &from)
{
	m_username.copy(from.m_username);
}


void CUserPosixInputRequest::copy(IConstUserPosixInputRequest &ifrom)
{
	setUsername(ifrom.getUsername());
}


void CUserPosixInputRequest::getAttributes(IProperties &attributes)
{
}


void CUserPosixInputRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_username.toStr(ctx, buffer, "username", "", true, "", "");
}


void CUserPosixInputRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CUserPosixInputRequest::serializer(IEspContext* ctx, IConstUserPosixInputRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<UserPosixInputRequest>");
	// field username
	{
		const char* s = src.getUsername();
		if (s && *s)
		{
			buffer.append("<username>");
			encodeUtf8XML(s,buffer);
			buffer.append("</username>");
		}
	}
	if (keepRootTag)
		buffer.append("</UserPosixInputRequest>");
}

bool CUserPosixInputRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_username.unmarshall(rpc_request, "username", basepath);
	return hasValue;
}

bool CUserPosixInputRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_username.unmarshall(ctx, soapval, "username");
	return hasValue;
}

bool CUserPosixInputRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_username.unmarshall(ctx, params, attachments, "username", basepath);
	return hasValue;
}

const char * CUserPosixInputRequest::getUsername() { return m_username.query();}
void CUserPosixInputRequest::setUsername(const char * val){ m_username.set(val); }
extern "C"  IEspUserPosixInputRequest *createUserPosixInputRequest(const char *serv){return ((IEspUserPosixInputRequest *)new CUserPosixInputRequest(serv));}
extern "C"  IClientUserPosixInputRequest *createClientUserPosixInputRequest(const char *serv){return ((IClientUserPosixInputRequest *)new CUserPosixInputRequest(serv));}

//=======================================================
// class CUserPosixInputResponse Implementation
//=======================================================

CUserPosixInputResponse::CUserPosixInputResponse(const char *serviceName, IRpcMessageBinding *init)
	: m_username(nilIgnore),m_posixenabled(nilIgnore),m_gidnumber(nilIgnore),m_uidnumber(nilIgnore),m_homedirectory(nilIgnore),m_loginshell(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("UserPosixInputResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CUserPosixInputResponse::CUserPosixInputResponse(const char *serviceName, const char *bc)
	: m_username(nilIgnore),m_posixenabled(nilIgnore),m_gidnumber(nilIgnore),m_uidnumber(nilIgnore),m_homedirectory(nilIgnore),m_loginshell(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("UserPosixInputResponse");
}

CUserPosixInputResponse::CUserPosixInputResponse(const char *serviceName, IRpcMessage* rpcmsg)
	: m_username(nilIgnore),m_posixenabled(nilIgnore),m_gidnumber(nilIgnore),m_uidnumber(nilIgnore),m_homedirectory(nilIgnore),m_loginshell(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("UserPosixInputResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CUserPosixInputResponse::CUserPosixInputResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_username(nilIgnore),m_posixenabled(nilIgnore),m_gidnumber(nilIgnore),m_uidnumber(nilIgnore),m_homedirectory(nilIgnore),m_loginshell(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("UserPosixInputResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CUserPosixInputResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"username\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"posixenabled\" type=\"xsd:boolean\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"gidnumber\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"uidnumber\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"homedirectory\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"loginshell\" type=\"xsd:string\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CUserPosixInputResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CUserPosixInputResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CUserPosixInputResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("username");
	form.appendf("  <tr><td><b>username: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("posixenabled");
	
	form.appendf("  <tr><td><b>posixenabled? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("gidnumber");
	form.appendf("  <tr><td><b>gidnumber: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("uidnumber");
	form.appendf("  <tr><td><b>uidnumber: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("homedirectory");
	form.appendf("  <tr><td><b>homedirectory: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("loginshell");
	form.appendf("  <tr><td><b>loginshell: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CUserPosixInputResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CUserPosixInputResponse::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
		m_username.marshall(rpc_resp, "username", "", "", "");
		m_posixenabled.marshall(rpc_resp, "posixenabled", "", "", "");
		m_gidnumber.marshall(rpc_resp, "gidnumber", "", "", "");
		m_uidnumber.marshall(rpc_resp, "uidnumber", "", "", "");
		m_homedirectory.marshall(rpc_resp, "homedirectory", "", "", "");
		m_loginshell.marshall(rpc_resp, "loginshell", "", "", "");
	}
}


void CUserPosixInputResponse::copy(CUserPosixInputResponse &from)
{
	m_username.copy(from.m_username);
	m_posixenabled.copy(from.m_posixenabled);
	m_gidnumber.copy(from.m_gidnumber);
	m_uidnumber.copy(from.m_uidnumber);
	m_homedirectory.copy(from.m_homedirectory);
	m_loginshell.copy(from.m_loginshell);
}


void CUserPosixInputResponse::copy(IConstUserPosixInputResponse &ifrom)
{
	setUsername(ifrom.getUsername());
	setPosixenabled(ifrom.getPosixenabled());
	setGidnumber(ifrom.getGidnumber());
	setUidnumber(ifrom.getUidnumber());
	setHomedirectory(ifrom.getHomedirectory());
	setLoginshell(ifrom.getLoginshell());
}


void CUserPosixInputResponse::getAttributes(IProperties &attributes)
{
}


void CUserPosixInputResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
		m_username.toStr(ctx, buffer, "username", "", true, "", "");
		m_posixenabled.toStr(ctx, buffer, "posixenabled", "", true, "", "");
		m_gidnumber.toStr(ctx, buffer, "gidnumber", "", true, "", "");
		m_uidnumber.toStr(ctx, buffer, "uidnumber", "", true, "", "");
		m_homedirectory.toStr(ctx, buffer, "homedirectory", "", true, "", "");
		m_loginshell.toStr(ctx, buffer, "loginshell", "", true, "", "");
	}
}


void CUserPosixInputResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CUserPosixInputResponse::serializer(IEspContext* ctx, IConstUserPosixInputResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<UserPosixInputResponse>");
	// field username
	{
		const char* s = src.getUsername();
		if (s && *s)
		{
			buffer.append("<username>");
			encodeUtf8XML(s,buffer);
			buffer.append("</username>");
		}
	}
	// field posixenabled
	{
		bool b = src.getPosixenabled();
		if (b)
			buffer.appendf("<posixenabled>1</posixenabled>");
	}
	// field gidnumber
	{
		const char* s = src.getGidnumber();
		if (s && *s)
		{
			buffer.append("<gidnumber>");
			encodeUtf8XML(s,buffer);
			buffer.append("</gidnumber>");
		}
	}
	// field uidnumber
	{
		const char* s = src.getUidnumber();
		if (s && *s)
		{
			buffer.append("<uidnumber>");
			encodeUtf8XML(s,buffer);
			buffer.append("</uidnumber>");
		}
	}
	// field homedirectory
	{
		const char* s = src.getHomedirectory();
		if (s && *s)
		{
			buffer.append("<homedirectory>");
			encodeUtf8XML(s,buffer);
			buffer.append("</homedirectory>");
		}
	}
	// field loginshell
	{
		const char* s = src.getLoginshell();
		if (s && *s)
		{
			buffer.append("<loginshell>");
			encodeUtf8XML(s,buffer);
			buffer.append("</loginshell>");
		}
	}
	if (keepRootTag)
		buffer.append("</UserPosixInputResponse>");
}

bool CUserPosixInputResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
		hasValue |= m_username.unmarshall(rpc_request, "username", basepath);
		hasValue |= m_posixenabled.unmarshall(rpc_request, "posixenabled", basepath);
		hasValue |= m_gidnumber.unmarshall(rpc_request, "gidnumber", basepath);
		hasValue |= m_uidnumber.unmarshall(rpc_request, "uidnumber", basepath);
		hasValue |= m_homedirectory.unmarshall(rpc_request, "homedirectory", basepath);
		hasValue |= m_loginshell.unmarshall(rpc_request, "loginshell", basepath);
	}
	return hasValue;
}

bool CUserPosixInputResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_username.unmarshall(ctx, soapval, "username");
	hasValue |= m_posixenabled.unmarshall(ctx, soapval, "posixenabled");
	hasValue |= m_gidnumber.unmarshall(ctx, soapval, "gidnumber");
	hasValue |= m_uidnumber.unmarshall(ctx, soapval, "uidnumber");
	hasValue |= m_homedirectory.unmarshall(ctx, soapval, "homedirectory");
	hasValue |= m_loginshell.unmarshall(ctx, soapval, "loginshell");
	return hasValue;
}

bool CUserPosixInputResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_username.unmarshall(ctx, params, attachments, "username", basepath);
	hasValue |= m_posixenabled.unmarshall(ctx, params, attachments, "posixenabled", basepath);
	hasValue |= m_gidnumber.unmarshall(ctx, params, attachments, "gidnumber", basepath);
	hasValue |= m_uidnumber.unmarshall(ctx, params, attachments, "uidnumber", basepath);
	hasValue |= m_homedirectory.unmarshall(ctx, params, attachments, "homedirectory", basepath);
	hasValue |= m_loginshell.unmarshall(ctx, params, attachments, "loginshell", basepath);
	return hasValue;
}

const char * CUserPosixInputResponse::getUsername() { return m_username.query();}
bool CUserPosixInputResponse::getPosixenabled() { return m_posixenabled;}
const char * CUserPosixInputResponse::getGidnumber() { return m_gidnumber.query();}
const char * CUserPosixInputResponse::getUidnumber() { return m_uidnumber.query();}
const char * CUserPosixInputResponse::getHomedirectory() { return m_homedirectory.query();}
const char * CUserPosixInputResponse::getLoginshell() { return m_loginshell.query();}
void CUserPosixInputResponse::setUsername(const char * val){ m_username.set(val); }
void CUserPosixInputResponse::setPosixenabled(bool val){ m_posixenabled=val; }
void CUserPosixInputResponse::setGidnumber(const char * val){ m_gidnumber.set(val); }
void CUserPosixInputResponse::setUidnumber(const char * val){ m_uidnumber.set(val); }
void CUserPosixInputResponse::setHomedirectory(const char * val){ m_homedirectory.set(val); }
void CUserPosixInputResponse::setLoginshell(const char * val){ m_loginshell.set(val); }
extern "C"  IEspUserPosixInputResponse *createUserPosixInputResponse(const char *serv){return ((IEspUserPosixInputResponse *)new CUserPosixInputResponse(serv));}
extern "C"  IClientUserPosixInputResponse *createClientUserPosixInputResponse(const char *serv){return ((IClientUserPosixInputResponse *)new CUserPosixInputResponse(serv));}

//=======================================================
// class CUserPosixRequest Implementation
//=======================================================

CUserPosixRequest::CUserPosixRequest(const char *serviceName, IRpcMessageBinding *init)
	: m_username(nilIgnore),m_posixenabled(nilIgnore),m_gidnumber(nilIgnore),m_uidnumber(nilIgnore),m_homedirectory(nilIgnore),m_loginshell(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("UserPosixRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CUserPosixRequest::CUserPosixRequest(const char *serviceName, const char *bc)
	: m_username(nilIgnore),m_posixenabled(nilIgnore),m_gidnumber(nilIgnore),m_uidnumber(nilIgnore),m_homedirectory(nilIgnore),m_loginshell(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("UserPosixRequest");
}

CUserPosixRequest::CUserPosixRequest(const char *serviceName, IRpcMessage* rpcmsg)
	: m_username(nilIgnore),m_posixenabled(nilIgnore),m_gidnumber(nilIgnore),m_uidnumber(nilIgnore),m_homedirectory(nilIgnore),m_loginshell(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("UserPosixRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CUserPosixRequest::CUserPosixRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_username(nilIgnore),m_posixenabled(nilIgnore),m_gidnumber(nilIgnore),m_uidnumber(nilIgnore),m_homedirectory(nilIgnore),m_loginshell(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("UserPosixRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CUserPosixRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"username\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"posixenabled\" type=\"xsd:boolean\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"gidnumber\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"uidnumber\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"homedirectory\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"loginshell\" type=\"xsd:string\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CUserPosixRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CUserPosixRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CUserPosixRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("username");
	form.appendf("  <tr><td><b>username: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("posixenabled");
	
	form.appendf("  <tr><td><b>posixenabled? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("gidnumber");
	form.appendf("  <tr><td><b>gidnumber: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("uidnumber");
	form.appendf("  <tr><td><b>uidnumber: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("homedirectory");
	form.appendf("  <tr><td><b>homedirectory: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("loginshell");
	form.appendf("  <tr><td><b>loginshell: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CUserPosixRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CUserPosixRequest::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_username.marshall(rpc_resp, "username", "", "", "");
	m_posixenabled.marshall(rpc_resp, "posixenabled", "", "", "");
	m_gidnumber.marshall(rpc_resp, "gidnumber", "", "", "");
	m_uidnumber.marshall(rpc_resp, "uidnumber", "", "", "");
	m_homedirectory.marshall(rpc_resp, "homedirectory", "", "", "");
	m_loginshell.marshall(rpc_resp, "loginshell", "", "", "");
}


void CUserPosixRequest::copy(CUserPosixRequest &from)
{
	m_username.copy(from.m_username);
	m_posixenabled.copy(from.m_posixenabled);
	m_gidnumber.copy(from.m_gidnumber);
	m_uidnumber.copy(from.m_uidnumber);
	m_homedirectory.copy(from.m_homedirectory);
	m_loginshell.copy(from.m_loginshell);
}


void CUserPosixRequest::copy(IConstUserPosixRequest &ifrom)
{
	setUsername(ifrom.getUsername());
	setPosixenabled(ifrom.getPosixenabled());
	setGidnumber(ifrom.getGidnumber());
	setUidnumber(ifrom.getUidnumber());
	setHomedirectory(ifrom.getHomedirectory());
	setLoginshell(ifrom.getLoginshell());
}


void CUserPosixRequest::getAttributes(IProperties &attributes)
{
}


void CUserPosixRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_username.toStr(ctx, buffer, "username", "", true, "", "");
	m_posixenabled.toStr(ctx, buffer, "posixenabled", "", true, "", "");
	m_gidnumber.toStr(ctx, buffer, "gidnumber", "", true, "", "");
	m_uidnumber.toStr(ctx, buffer, "uidnumber", "", true, "", "");
	m_homedirectory.toStr(ctx, buffer, "homedirectory", "", true, "", "");
	m_loginshell.toStr(ctx, buffer, "loginshell", "", true, "", "");
}


void CUserPosixRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CUserPosixRequest::serializer(IEspContext* ctx, IConstUserPosixRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<UserPosixRequest>");
	// field username
	{
		const char* s = src.getUsername();
		if (s && *s)
		{
			buffer.append("<username>");
			encodeUtf8XML(s,buffer);
			buffer.append("</username>");
		}
	}
	// field posixenabled
	{
		bool b = src.getPosixenabled();
		if (b)
			buffer.appendf("<posixenabled>1</posixenabled>");
	}
	// field gidnumber
	{
		const char* s = src.getGidnumber();
		if (s && *s)
		{
			buffer.append("<gidnumber>");
			encodeUtf8XML(s,buffer);
			buffer.append("</gidnumber>");
		}
	}
	// field uidnumber
	{
		const char* s = src.getUidnumber();
		if (s && *s)
		{
			buffer.append("<uidnumber>");
			encodeUtf8XML(s,buffer);
			buffer.append("</uidnumber>");
		}
	}
	// field homedirectory
	{
		const char* s = src.getHomedirectory();
		if (s && *s)
		{
			buffer.append("<homedirectory>");
			encodeUtf8XML(s,buffer);
			buffer.append("</homedirectory>");
		}
	}
	// field loginshell
	{
		const char* s = src.getLoginshell();
		if (s && *s)
		{
			buffer.append("<loginshell>");
			encodeUtf8XML(s,buffer);
			buffer.append("</loginshell>");
		}
	}
	if (keepRootTag)
		buffer.append("</UserPosixRequest>");
}

bool CUserPosixRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_username.unmarshall(rpc_request, "username", basepath);
	hasValue |= m_posixenabled.unmarshall(rpc_request, "posixenabled", basepath);
	hasValue |= m_gidnumber.unmarshall(rpc_request, "gidnumber", basepath);
	hasValue |= m_uidnumber.unmarshall(rpc_request, "uidnumber", basepath);
	hasValue |= m_homedirectory.unmarshall(rpc_request, "homedirectory", basepath);
	hasValue |= m_loginshell.unmarshall(rpc_request, "loginshell", basepath);
	return hasValue;
}

bool CUserPosixRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_username.unmarshall(ctx, soapval, "username");
	hasValue |= m_posixenabled.unmarshall(ctx, soapval, "posixenabled");
	hasValue |= m_gidnumber.unmarshall(ctx, soapval, "gidnumber");
	hasValue |= m_uidnumber.unmarshall(ctx, soapval, "uidnumber");
	hasValue |= m_homedirectory.unmarshall(ctx, soapval, "homedirectory");
	hasValue |= m_loginshell.unmarshall(ctx, soapval, "loginshell");
	return hasValue;
}

bool CUserPosixRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_username.unmarshall(ctx, params, attachments, "username", basepath);
	hasValue |= m_posixenabled.unmarshall(ctx, params, attachments, "posixenabled", basepath);
	hasValue |= m_gidnumber.unmarshall(ctx, params, attachments, "gidnumber", basepath);
	hasValue |= m_uidnumber.unmarshall(ctx, params, attachments, "uidnumber", basepath);
	hasValue |= m_homedirectory.unmarshall(ctx, params, attachments, "homedirectory", basepath);
	hasValue |= m_loginshell.unmarshall(ctx, params, attachments, "loginshell", basepath);
	return hasValue;
}

const char * CUserPosixRequest::getUsername() { return m_username.query();}
bool CUserPosixRequest::getPosixenabled() { return m_posixenabled;}
const char * CUserPosixRequest::getGidnumber() { return m_gidnumber.query();}
const char * CUserPosixRequest::getUidnumber() { return m_uidnumber.query();}
const char * CUserPosixRequest::getHomedirectory() { return m_homedirectory.query();}
const char * CUserPosixRequest::getLoginshell() { return m_loginshell.query();}
void CUserPosixRequest::setUsername(const char * val){ m_username.set(val); }
void CUserPosixRequest::setPosixenabled(bool val){ m_posixenabled=val; }
void CUserPosixRequest::setGidnumber(const char * val){ m_gidnumber.set(val); }
void CUserPosixRequest::setUidnumber(const char * val){ m_uidnumber.set(val); }
void CUserPosixRequest::setHomedirectory(const char * val){ m_homedirectory.set(val); }
void CUserPosixRequest::setLoginshell(const char * val){ m_loginshell.set(val); }
extern "C"  IEspUserPosixRequest *createUserPosixRequest(const char *serv){return ((IEspUserPosixRequest *)new CUserPosixRequest(serv));}
extern "C"  IClientUserPosixRequest *createClientUserPosixRequest(const char *serv){return ((IClientUserPosixRequest *)new CUserPosixRequest(serv));}

//=======================================================
// class CUserPosixResponse Implementation
//=======================================================

CUserPosixResponse::CUserPosixResponse(const char *serviceName, IRpcMessageBinding *init)
	: m_username(nilIgnore),m_retcode(nilIgnore),m_retmsg(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("UserPosixResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CUserPosixResponse::CUserPosixResponse(const char *serviceName, const char *bc)
	: m_username(nilIgnore),m_retcode(nilIgnore),m_retmsg(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("UserPosixResponse");
}

CUserPosixResponse::CUserPosixResponse(const char *serviceName, IRpcMessage* rpcmsg)
	: m_username(nilIgnore),m_retcode(nilIgnore),m_retmsg(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("UserPosixResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CUserPosixResponse::CUserPosixResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_username(nilIgnore),m_retcode(nilIgnore),m_retmsg(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("UserPosixResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CUserPosixResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"username\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"retcode\" type=\"xsd:int\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"retmsg\" type=\"xsd:string\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CUserPosixResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CUserPosixResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CUserPosixResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("username");
	form.appendf("  <tr><td><b>username: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix) extfix.append(prefix).append(".");
		extfix.append("retcode");
	form.appendf("  <tr><td><b>retcode: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("retmsg");
	form.appendf("  <tr><td><b>retmsg: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CUserPosixResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CUserPosixResponse::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
		m_username.marshall(rpc_resp, "username", "", "", "");
		m_retcode.marshall(rpc_resp, "retcode", "", "", "");
		m_retmsg.marshall(rpc_resp, "retmsg", "", "", "");
	}
}


void CUserPosixResponse::copy(CUserPosixResponse &from)
{
	m_username.copy(from.m_username);
	m_retcode.copy(from.m_retcode);
	m_retmsg.copy(from.m_retmsg);
}


void CUserPosixResponse::copy(IConstUserPosixResponse &ifrom)
{
	setUsername(ifrom.getUsername());
	setRetcode(ifrom.getRetcode());
	setRetmsg(ifrom.getRetmsg());
}


void CUserPosixResponse::getAttributes(IProperties &attributes)
{
}


void CUserPosixResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
		m_username.toStr(ctx, buffer, "username", "", true, "", "");
		m_retcode.toStr(ctx, buffer, "retcode", "", true, "", "");
		m_retmsg.toStr(ctx, buffer, "retmsg", "", true, "", "");
	}
}


void CUserPosixResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CUserPosixResponse::serializer(IEspContext* ctx, IConstUserPosixResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<UserPosixResponse>");
	// field username
	{
		const char* s = src.getUsername();
		if (s && *s)
		{
			buffer.append("<username>");
			encodeUtf8XML(s,buffer);
			buffer.append("</username>");
		}
	}
	// field retcode
	{
		int n = src.getRetcode();
		if (n)
			buffer.appendf("<retcode>%d</retcode>", n);
	}
	// field retmsg
	{
		const char* s = src.getRetmsg();
		if (s && *s)
		{
			buffer.append("<retmsg>");
			encodeUtf8XML(s,buffer);
			buffer.append("</retmsg>");
		}
	}
	if (keepRootTag)
		buffer.append("</UserPosixResponse>");
}

bool CUserPosixResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
		hasValue |= m_username.unmarshall(rpc_request, "username", basepath);
		hasValue |= m_retcode.unmarshall(rpc_request, "retcode", basepath);
		hasValue |= m_retmsg.unmarshall(rpc_request, "retmsg", basepath);
	}
	return hasValue;
}

bool CUserPosixResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_username.unmarshall(ctx, soapval, "username");
	hasValue |= m_retcode.unmarshall(ctx, soapval, "retcode");
	hasValue |= m_retmsg.unmarshall(ctx, soapval, "retmsg");
	return hasValue;
}

bool CUserPosixResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_username.unmarshall(ctx, params, attachments, "username", basepath);
	hasValue |= m_retcode.unmarshall(ctx, params, attachments, "retcode", basepath);
	hasValue |= m_retmsg.unmarshall(ctx, params, attachments, "retmsg", basepath);
	return hasValue;
}

const char * CUserPosixResponse::getUsername() { return m_username.query();}
int CUserPosixResponse::getRetcode() { return m_retcode;}
const char * CUserPosixResponse::getRetmsg() { return m_retmsg.query();}
void CUserPosixResponse::setUsername(const char * val){ m_username.set(val); }
void CUserPosixResponse::setRetcode(int val){ m_retcode=val; }
void CUserPosixResponse::setRetmsg(const char * val){ m_retmsg.set(val); }
extern "C"  IEspUserPosixResponse *createUserPosixResponse(const char *serv){return ((IEspUserPosixResponse *)new CUserPosixResponse(serv));}
extern "C"  IClientUserPosixResponse *createClientUserPosixResponse(const char *serv){return ((IClientUserPosixResponse *)new CUserPosixResponse(serv));}

//=======================================================
// class CUserSudoersInputRequest Implementation
//=======================================================

CUserSudoersInputRequest::CUserSudoersInputRequest(const char *serviceName, IRpcMessageBinding *init)
	: m_username(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("UserSudoersInputRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CUserSudoersInputRequest::CUserSudoersInputRequest(const char *serviceName, const char *bc)
	: m_username(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("UserSudoersInputRequest");
}

CUserSudoersInputRequest::CUserSudoersInputRequest(const char *serviceName, IRpcMessage* rpcmsg)
	: m_username(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("UserSudoersInputRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CUserSudoersInputRequest::CUserSudoersInputRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_username(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("UserSudoersInputRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CUserSudoersInputRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"username\" type=\"xsd:string\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CUserSudoersInputRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CUserSudoersInputRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CUserSudoersInputRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("username");
	form.appendf("  <tr><td><b>username: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CUserSudoersInputRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CUserSudoersInputRequest::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_username.marshall(rpc_resp, "username", "", "", "");
}


void CUserSudoersInputRequest::copy(CUserSudoersInputRequest &from)
{
	m_username.copy(from.m_username);
}


void CUserSudoersInputRequest::copy(IConstUserSudoersInputRequest &ifrom)
{
	setUsername(ifrom.getUsername());
}


void CUserSudoersInputRequest::getAttributes(IProperties &attributes)
{
}


void CUserSudoersInputRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_username.toStr(ctx, buffer, "username", "", true, "", "");
}


void CUserSudoersInputRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CUserSudoersInputRequest::serializer(IEspContext* ctx, IConstUserSudoersInputRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<UserSudoersInputRequest>");
	// field username
	{
		const char* s = src.getUsername();
		if (s && *s)
		{
			buffer.append("<username>");
			encodeUtf8XML(s,buffer);
			buffer.append("</username>");
		}
	}
	if (keepRootTag)
		buffer.append("</UserSudoersInputRequest>");
}

bool CUserSudoersInputRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_username.unmarshall(rpc_request, "username", basepath);
	return hasValue;
}

bool CUserSudoersInputRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_username.unmarshall(ctx, soapval, "username");
	return hasValue;
}

bool CUserSudoersInputRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_username.unmarshall(ctx, params, attachments, "username", basepath);
	return hasValue;
}

const char * CUserSudoersInputRequest::getUsername() { return m_username.query();}
void CUserSudoersInputRequest::setUsername(const char * val){ m_username.set(val); }
extern "C"  IEspUserSudoersInputRequest *createUserSudoersInputRequest(const char *serv){return ((IEspUserSudoersInputRequest *)new CUserSudoersInputRequest(serv));}
extern "C"  IClientUserSudoersInputRequest *createClientUserSudoersInputRequest(const char *serv){return ((IClientUserSudoersInputRequest *)new CUserSudoersInputRequest(serv));}

//=======================================================
// class CUserSudoersInputResponse Implementation
//=======================================================

CUserSudoersInputResponse::CUserSudoersInputResponse(const char *serviceName, IRpcMessageBinding *init)
	: m_username(nilIgnore),m_insudoers(nilIgnore),m_sudoHost(nilIgnore),m_sudoCommand(nilIgnore),m_sudoOption(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("UserSudoersInputResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CUserSudoersInputResponse::CUserSudoersInputResponse(const char *serviceName, const char *bc)
	: m_username(nilIgnore),m_insudoers(nilIgnore),m_sudoHost(nilIgnore),m_sudoCommand(nilIgnore),m_sudoOption(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("UserSudoersInputResponse");
}

CUserSudoersInputResponse::CUserSudoersInputResponse(const char *serviceName, IRpcMessage* rpcmsg)
	: m_username(nilIgnore),m_insudoers(nilIgnore),m_sudoHost(nilIgnore),m_sudoCommand(nilIgnore),m_sudoOption(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("UserSudoersInputResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CUserSudoersInputResponse::CUserSudoersInputResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_username(nilIgnore),m_insudoers(nilIgnore),m_sudoHost(nilIgnore),m_sudoCommand(nilIgnore),m_sudoOption(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("UserSudoersInputResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CUserSudoersInputResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"username\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"insudoers\" type=\"xsd:boolean\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"sudoHost\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"sudoCommand\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"sudoOption\" type=\"xsd:string\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CUserSudoersInputResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CUserSudoersInputResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CUserSudoersInputResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("username");
	form.appendf("  <tr><td><b>username: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("insudoers");
	
	form.appendf("  <tr><td><b>insudoers? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("sudoHost");
	form.appendf("  <tr><td><b>sudoHost: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("sudoCommand");
	form.appendf("  <tr><td><b>sudoCommand: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("sudoOption");
	form.appendf("  <tr><td><b>sudoOption: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CUserSudoersInputResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CUserSudoersInputResponse::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
		m_username.marshall(rpc_resp, "username", "", "", "");
		m_insudoers.marshall(rpc_resp, "insudoers", "", "", "");
		m_sudoHost.marshall(rpc_resp, "sudoHost", "", "", "");
		m_sudoCommand.marshall(rpc_resp, "sudoCommand", "", "", "");
		m_sudoOption.marshall(rpc_resp, "sudoOption", "", "", "");
	}
}


void CUserSudoersInputResponse::copy(CUserSudoersInputResponse &from)
{
	m_username.copy(from.m_username);
	m_insudoers.copy(from.m_insudoers);
	m_sudoHost.copy(from.m_sudoHost);
	m_sudoCommand.copy(from.m_sudoCommand);
	m_sudoOption.copy(from.m_sudoOption);
}


void CUserSudoersInputResponse::copy(IConstUserSudoersInputResponse &ifrom)
{
	setUsername(ifrom.getUsername());
	setInsudoers(ifrom.getInsudoers());
	setSudoHost(ifrom.getSudoHost());
	setSudoCommand(ifrom.getSudoCommand());
	setSudoOption(ifrom.getSudoOption());
}


void CUserSudoersInputResponse::getAttributes(IProperties &attributes)
{
}


void CUserSudoersInputResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
		m_username.toStr(ctx, buffer, "username", "", true, "", "");
		m_insudoers.toStr(ctx, buffer, "insudoers", "", true, "", "");
		m_sudoHost.toStr(ctx, buffer, "sudoHost", "", true, "", "");
		m_sudoCommand.toStr(ctx, buffer, "sudoCommand", "", true, "", "");
		m_sudoOption.toStr(ctx, buffer, "sudoOption", "", true, "", "");
	}
}


void CUserSudoersInputResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CUserSudoersInputResponse::serializer(IEspContext* ctx, IConstUserSudoersInputResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<UserSudoersInputResponse>");
	// field username
	{
		const char* s = src.getUsername();
		if (s && *s)
		{
			buffer.append("<username>");
			encodeUtf8XML(s,buffer);
			buffer.append("</username>");
		}
	}
	// field insudoers
	{
		bool b = src.getInsudoers();
		if (b)
			buffer.appendf("<insudoers>1</insudoers>");
	}
	// field sudoHost
	{
		const char* s = src.getSudoHost();
		if (s && *s)
		{
			buffer.append("<sudoHost>");
			encodeUtf8XML(s,buffer);
			buffer.append("</sudoHost>");
		}
	}
	// field sudoCommand
	{
		const char* s = src.getSudoCommand();
		if (s && *s)
		{
			buffer.append("<sudoCommand>");
			encodeUtf8XML(s,buffer);
			buffer.append("</sudoCommand>");
		}
	}
	// field sudoOption
	{
		const char* s = src.getSudoOption();
		if (s && *s)
		{
			buffer.append("<sudoOption>");
			encodeUtf8XML(s,buffer);
			buffer.append("</sudoOption>");
		}
	}
	if (keepRootTag)
		buffer.append("</UserSudoersInputResponse>");
}

bool CUserSudoersInputResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
		hasValue |= m_username.unmarshall(rpc_request, "username", basepath);
		hasValue |= m_insudoers.unmarshall(rpc_request, "insudoers", basepath);
		hasValue |= m_sudoHost.unmarshall(rpc_request, "sudoHost", basepath);
		hasValue |= m_sudoCommand.unmarshall(rpc_request, "sudoCommand", basepath);
		hasValue |= m_sudoOption.unmarshall(rpc_request, "sudoOption", basepath);
	}
	return hasValue;
}

bool CUserSudoersInputResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_username.unmarshall(ctx, soapval, "username");
	hasValue |= m_insudoers.unmarshall(ctx, soapval, "insudoers");
	hasValue |= m_sudoHost.unmarshall(ctx, soapval, "sudoHost");
	hasValue |= m_sudoCommand.unmarshall(ctx, soapval, "sudoCommand");
	hasValue |= m_sudoOption.unmarshall(ctx, soapval, "sudoOption");
	return hasValue;
}

bool CUserSudoersInputResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_username.unmarshall(ctx, params, attachments, "username", basepath);
	hasValue |= m_insudoers.unmarshall(ctx, params, attachments, "insudoers", basepath);
	hasValue |= m_sudoHost.unmarshall(ctx, params, attachments, "sudoHost", basepath);
	hasValue |= m_sudoCommand.unmarshall(ctx, params, attachments, "sudoCommand", basepath);
	hasValue |= m_sudoOption.unmarshall(ctx, params, attachments, "sudoOption", basepath);
	return hasValue;
}

const char * CUserSudoersInputResponse::getUsername() { return m_username.query();}
bool CUserSudoersInputResponse::getInsudoers() { return m_insudoers;}
const char * CUserSudoersInputResponse::getSudoHost() { return m_sudoHost.query();}
const char * CUserSudoersInputResponse::getSudoCommand() { return m_sudoCommand.query();}
const char * CUserSudoersInputResponse::getSudoOption() { return m_sudoOption.query();}
void CUserSudoersInputResponse::setUsername(const char * val){ m_username.set(val); }
void CUserSudoersInputResponse::setInsudoers(bool val){ m_insudoers=val; }
void CUserSudoersInputResponse::setSudoHost(const char * val){ m_sudoHost.set(val); }
void CUserSudoersInputResponse::setSudoCommand(const char * val){ m_sudoCommand.set(val); }
void CUserSudoersInputResponse::setSudoOption(const char * val){ m_sudoOption.set(val); }
extern "C"  IEspUserSudoersInputResponse *createUserSudoersInputResponse(const char *serv){return ((IEspUserSudoersInputResponse *)new CUserSudoersInputResponse(serv));}
extern "C"  IClientUserSudoersInputResponse *createClientUserSudoersInputResponse(const char *serv){return ((IClientUserSudoersInputResponse *)new CUserSudoersInputResponse(serv));}

//=======================================================
// class CUserSudoersRequest Implementation
//=======================================================

CUserSudoersRequest::CUserSudoersRequest(const char *serviceName, IRpcMessageBinding *init)
	: m_username(nilIgnore),m_action(nilIgnore),m_sudoHost(nilIgnore),m_sudoCommand(nilIgnore),m_sudoOption(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("UserSudoersRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CUserSudoersRequest::CUserSudoersRequest(const char *serviceName, const char *bc)
	: m_username(nilIgnore),m_action(nilIgnore),m_sudoHost(nilIgnore),m_sudoCommand(nilIgnore),m_sudoOption(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("UserSudoersRequest");
}

CUserSudoersRequest::CUserSudoersRequest(const char *serviceName, IRpcMessage* rpcmsg)
	: m_username(nilIgnore),m_action(nilIgnore),m_sudoHost(nilIgnore),m_sudoCommand(nilIgnore),m_sudoOption(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("UserSudoersRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CUserSudoersRequest::CUserSudoersRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_username(nilIgnore),m_action(nilIgnore),m_sudoHost(nilIgnore),m_sudoCommand(nilIgnore),m_sudoOption(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("UserSudoersRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CUserSudoersRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"username\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"action\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"sudoHost\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"sudoCommand\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"sudoOption\" type=\"xsd:string\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CUserSudoersRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CUserSudoersRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CUserSudoersRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("username");
	form.appendf("  <tr><td><b>username: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("action");
	form.appendf("  <tr><td><b>action: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("sudoHost");
	form.appendf("  <tr><td><b>sudoHost: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("sudoCommand");
	form.appendf("  <tr><td><b>sudoCommand: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("sudoOption");
	form.appendf("  <tr><td><b>sudoOption: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CUserSudoersRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CUserSudoersRequest::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_username.marshall(rpc_resp, "username", "", "", "");
	m_action.marshall(rpc_resp, "action", "", "", "");
	m_sudoHost.marshall(rpc_resp, "sudoHost", "", "", "");
	m_sudoCommand.marshall(rpc_resp, "sudoCommand", "", "", "");
	m_sudoOption.marshall(rpc_resp, "sudoOption", "", "", "");
}


void CUserSudoersRequest::copy(CUserSudoersRequest &from)
{
	m_username.copy(from.m_username);
	m_action.copy(from.m_action);
	m_sudoHost.copy(from.m_sudoHost);
	m_sudoCommand.copy(from.m_sudoCommand);
	m_sudoOption.copy(from.m_sudoOption);
}


void CUserSudoersRequest::copy(IConstUserSudoersRequest &ifrom)
{
	setUsername(ifrom.getUsername());
	setAction(ifrom.getAction());
	setSudoHost(ifrom.getSudoHost());
	setSudoCommand(ifrom.getSudoCommand());
	setSudoOption(ifrom.getSudoOption());
}


void CUserSudoersRequest::getAttributes(IProperties &attributes)
{
}


void CUserSudoersRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_username.toStr(ctx, buffer, "username", "", true, "", "");
	m_action.toStr(ctx, buffer, "action", "", true, "", "");
	m_sudoHost.toStr(ctx, buffer, "sudoHost", "", true, "", "");
	m_sudoCommand.toStr(ctx, buffer, "sudoCommand", "", true, "", "");
	m_sudoOption.toStr(ctx, buffer, "sudoOption", "", true, "", "");
}


void CUserSudoersRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CUserSudoersRequest::serializer(IEspContext* ctx, IConstUserSudoersRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<UserSudoersRequest>");
	// field username
	{
		const char* s = src.getUsername();
		if (s && *s)
		{
			buffer.append("<username>");
			encodeUtf8XML(s,buffer);
			buffer.append("</username>");
		}
	}
	// field action
	{
		const char* s = src.getAction();
		if (s && *s)
		{
			buffer.append("<action>");
			encodeUtf8XML(s,buffer);
			buffer.append("</action>");
		}
	}
	// field sudoHost
	{
		const char* s = src.getSudoHost();
		if (s && *s)
		{
			buffer.append("<sudoHost>");
			encodeUtf8XML(s,buffer);
			buffer.append("</sudoHost>");
		}
	}
	// field sudoCommand
	{
		const char* s = src.getSudoCommand();
		if (s && *s)
		{
			buffer.append("<sudoCommand>");
			encodeUtf8XML(s,buffer);
			buffer.append("</sudoCommand>");
		}
	}
	// field sudoOption
	{
		const char* s = src.getSudoOption();
		if (s && *s)
		{
			buffer.append("<sudoOption>");
			encodeUtf8XML(s,buffer);
			buffer.append("</sudoOption>");
		}
	}
	if (keepRootTag)
		buffer.append("</UserSudoersRequest>");
}

bool CUserSudoersRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_username.unmarshall(rpc_request, "username", basepath);
	hasValue |= m_action.unmarshall(rpc_request, "action", basepath);
	hasValue |= m_sudoHost.unmarshall(rpc_request, "sudoHost", basepath);
	hasValue |= m_sudoCommand.unmarshall(rpc_request, "sudoCommand", basepath);
	hasValue |= m_sudoOption.unmarshall(rpc_request, "sudoOption", basepath);
	return hasValue;
}

bool CUserSudoersRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_username.unmarshall(ctx, soapval, "username");
	hasValue |= m_action.unmarshall(ctx, soapval, "action");
	hasValue |= m_sudoHost.unmarshall(ctx, soapval, "sudoHost");
	hasValue |= m_sudoCommand.unmarshall(ctx, soapval, "sudoCommand");
	hasValue |= m_sudoOption.unmarshall(ctx, soapval, "sudoOption");
	return hasValue;
}

bool CUserSudoersRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_username.unmarshall(ctx, params, attachments, "username", basepath);
	hasValue |= m_action.unmarshall(ctx, params, attachments, "action", basepath);
	hasValue |= m_sudoHost.unmarshall(ctx, params, attachments, "sudoHost", basepath);
	hasValue |= m_sudoCommand.unmarshall(ctx, params, attachments, "sudoCommand", basepath);
	hasValue |= m_sudoOption.unmarshall(ctx, params, attachments, "sudoOption", basepath);
	return hasValue;
}

const char * CUserSudoersRequest::getUsername() { return m_username.query();}
const char * CUserSudoersRequest::getAction() { return m_action.query();}
const char * CUserSudoersRequest::getSudoHost() { return m_sudoHost.query();}
const char * CUserSudoersRequest::getSudoCommand() { return m_sudoCommand.query();}
const char * CUserSudoersRequest::getSudoOption() { return m_sudoOption.query();}
void CUserSudoersRequest::setUsername(const char * val){ m_username.set(val); }
void CUserSudoersRequest::setAction(const char * val){ m_action.set(val); }
void CUserSudoersRequest::setSudoHost(const char * val){ m_sudoHost.set(val); }
void CUserSudoersRequest::setSudoCommand(const char * val){ m_sudoCommand.set(val); }
void CUserSudoersRequest::setSudoOption(const char * val){ m_sudoOption.set(val); }
extern "C"  IEspUserSudoersRequest *createUserSudoersRequest(const char *serv){return ((IEspUserSudoersRequest *)new CUserSudoersRequest(serv));}
extern "C"  IClientUserSudoersRequest *createClientUserSudoersRequest(const char *serv){return ((IClientUserSudoersRequest *)new CUserSudoersRequest(serv));}

//=======================================================
// class CUserSudoersResponse Implementation
//=======================================================

CUserSudoersResponse::CUserSudoersResponse(const char *serviceName, IRpcMessageBinding *init)
	: m_username(nilIgnore),m_retcode(nilIgnore),m_retmsg(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("UserSudoersResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CUserSudoersResponse::CUserSudoersResponse(const char *serviceName, const char *bc)
	: m_username(nilIgnore),m_retcode(nilIgnore),m_retmsg(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("UserSudoersResponse");
}

CUserSudoersResponse::CUserSudoersResponse(const char *serviceName, IRpcMessage* rpcmsg)
	: m_username(nilIgnore),m_retcode(nilIgnore),m_retmsg(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("UserSudoersResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CUserSudoersResponse::CUserSudoersResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_username(nilIgnore),m_retcode(nilIgnore),m_retmsg(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("UserSudoersResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CUserSudoersResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"username\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"retcode\" type=\"xsd:int\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"retmsg\" type=\"xsd:string\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CUserSudoersResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CUserSudoersResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CUserSudoersResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("username");
	form.appendf("  <tr><td><b>username: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix) extfix.append(prefix).append(".");
		extfix.append("retcode");
	form.appendf("  <tr><td><b>retcode: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("retmsg");
	form.appendf("  <tr><td><b>retmsg: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CUserSudoersResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CUserSudoersResponse::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
		m_username.marshall(rpc_resp, "username", "", "", "");
		m_retcode.marshall(rpc_resp, "retcode", "", "", "");
		m_retmsg.marshall(rpc_resp, "retmsg", "", "", "");
	}
}


void CUserSudoersResponse::copy(CUserSudoersResponse &from)
{
	m_username.copy(from.m_username);
	m_retcode.copy(from.m_retcode);
	m_retmsg.copy(from.m_retmsg);
}


void CUserSudoersResponse::copy(IConstUserSudoersResponse &ifrom)
{
	setUsername(ifrom.getUsername());
	setRetcode(ifrom.getRetcode());
	setRetmsg(ifrom.getRetmsg());
}


void CUserSudoersResponse::getAttributes(IProperties &attributes)
{
}


void CUserSudoersResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
		m_username.toStr(ctx, buffer, "username", "", true, "", "");
		m_retcode.toStr(ctx, buffer, "retcode", "", true, "", "");
		m_retmsg.toStr(ctx, buffer, "retmsg", "", true, "", "");
	}
}


void CUserSudoersResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CUserSudoersResponse::serializer(IEspContext* ctx, IConstUserSudoersResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<UserSudoersResponse>");
	// field username
	{
		const char* s = src.getUsername();
		if (s && *s)
		{
			buffer.append("<username>");
			encodeUtf8XML(s,buffer);
			buffer.append("</username>");
		}
	}
	// field retcode
	{
		int n = src.getRetcode();
		if (n)
			buffer.appendf("<retcode>%d</retcode>", n);
	}
	// field retmsg
	{
		const char* s = src.getRetmsg();
		if (s && *s)
		{
			buffer.append("<retmsg>");
			encodeUtf8XML(s,buffer);
			buffer.append("</retmsg>");
		}
	}
	if (keepRootTag)
		buffer.append("</UserSudoersResponse>");
}

bool CUserSudoersResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
		hasValue |= m_username.unmarshall(rpc_request, "username", basepath);
		hasValue |= m_retcode.unmarshall(rpc_request, "retcode", basepath);
		hasValue |= m_retmsg.unmarshall(rpc_request, "retmsg", basepath);
	}
	return hasValue;
}

bool CUserSudoersResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_username.unmarshall(ctx, soapval, "username");
	hasValue |= m_retcode.unmarshall(ctx, soapval, "retcode");
	hasValue |= m_retmsg.unmarshall(ctx, soapval, "retmsg");
	return hasValue;
}

bool CUserSudoersResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_username.unmarshall(ctx, params, attachments, "username", basepath);
	hasValue |= m_retcode.unmarshall(ctx, params, attachments, "retcode", basepath);
	hasValue |= m_retmsg.unmarshall(ctx, params, attachments, "retmsg", basepath);
	return hasValue;
}

const char * CUserSudoersResponse::getUsername() { return m_username.query();}
int CUserSudoersResponse::getRetcode() { return m_retcode;}
const char * CUserSudoersResponse::getRetmsg() { return m_retmsg.query();}
void CUserSudoersResponse::setUsername(const char * val){ m_username.set(val); }
void CUserSudoersResponse::setRetcode(int val){ m_retcode=val; }
void CUserSudoersResponse::setRetmsg(const char * val){ m_retmsg.set(val); }
extern "C"  IEspUserSudoersResponse *createUserSudoersResponse(const char *serv){return ((IEspUserSudoersResponse *)new CUserSudoersResponse(serv));}
extern "C"  IClientUserSudoersResponse *createClientUserSudoersResponse(const char *serv){return ((IClientUserSudoersResponse *)new CUserSudoersResponse(serv));}

//=======================================================
// class CUserInfoEditInputRequest Implementation
//=======================================================

CUserInfoEditInputRequest::CUserInfoEditInputRequest(const char *serviceName, IRpcMessageBinding *init)
	: m_username(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("UserInfoEditInputRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CUserInfoEditInputRequest::CUserInfoEditInputRequest(const char *serviceName, const char *bc)
	: m_username(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("UserInfoEditInputRequest");
}

CUserInfoEditInputRequest::CUserInfoEditInputRequest(const char *serviceName, IRpcMessage* rpcmsg)
	: m_username(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("UserInfoEditInputRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CUserInfoEditInputRequest::CUserInfoEditInputRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_username(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("UserInfoEditInputRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CUserInfoEditInputRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"username\" type=\"xsd:string\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CUserInfoEditInputRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CUserInfoEditInputRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CUserInfoEditInputRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("username");
	form.appendf("  <tr><td><b>username: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CUserInfoEditInputRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CUserInfoEditInputRequest::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_username.marshall(rpc_resp, "username", "", "", "");
}


void CUserInfoEditInputRequest::copy(CUserInfoEditInputRequest &from)
{
	m_username.copy(from.m_username);
}


void CUserInfoEditInputRequest::copy(IConstUserInfoEditInputRequest &ifrom)
{
	setUsername(ifrom.getUsername());
}


void CUserInfoEditInputRequest::getAttributes(IProperties &attributes)
{
}


void CUserInfoEditInputRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_username.toStr(ctx, buffer, "username", "", true, "", "");
}


void CUserInfoEditInputRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CUserInfoEditInputRequest::serializer(IEspContext* ctx, IConstUserInfoEditInputRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<UserInfoEditInputRequest>");
	// field username
	{
		const char* s = src.getUsername();
		if (s && *s)
		{
			buffer.append("<username>");
			encodeUtf8XML(s,buffer);
			buffer.append("</username>");
		}
	}
	if (keepRootTag)
		buffer.append("</UserInfoEditInputRequest>");
}

bool CUserInfoEditInputRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_username.unmarshall(rpc_request, "username", basepath);
	return hasValue;
}

bool CUserInfoEditInputRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_username.unmarshall(ctx, soapval, "username");
	return hasValue;
}

bool CUserInfoEditInputRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_username.unmarshall(ctx, params, attachments, "username", basepath);
	return hasValue;
}

const char * CUserInfoEditInputRequest::getUsername() { return m_username.query();}
void CUserInfoEditInputRequest::setUsername(const char * val){ m_username.set(val); }
extern "C"  IEspUserInfoEditInputRequest *createUserInfoEditInputRequest(const char *serv){return ((IEspUserInfoEditInputRequest *)new CUserInfoEditInputRequest(serv));}
extern "C"  IClientUserInfoEditInputRequest *createClientUserInfoEditInputRequest(const char *serv){return ((IClientUserInfoEditInputRequest *)new CUserInfoEditInputRequest(serv));}

//=======================================================
// class CUserInfoEditInputResponse Implementation
//=======================================================

CUserInfoEditInputResponse::CUserInfoEditInputResponse(const char *serviceName, IRpcMessageBinding *init)
	: m_username(nilIgnore),m_firstname(nilIgnore),m_lastname(nilIgnore),m_employeeID(nilIgnore),m_PasswordExpiration(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("UserInfoEditInputResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CUserInfoEditInputResponse::CUserInfoEditInputResponse(const char *serviceName, const char *bc)
	: m_username(nilIgnore),m_firstname(nilIgnore),m_lastname(nilIgnore),m_employeeID(nilIgnore),m_PasswordExpiration(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("UserInfoEditInputResponse");
}

CUserInfoEditInputResponse::CUserInfoEditInputResponse(const char *serviceName, IRpcMessage* rpcmsg)
	: m_username(nilIgnore),m_firstname(nilIgnore),m_lastname(nilIgnore),m_employeeID(nilIgnore),m_PasswordExpiration(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("UserInfoEditInputResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CUserInfoEditInputResponse::CUserInfoEditInputResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_username(nilIgnore),m_firstname(nilIgnore),m_lastname(nilIgnore),m_employeeID(nilIgnore),m_PasswordExpiration(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("UserInfoEditInputResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CUserInfoEditInputResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"username\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"firstname\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"lastname\" type=\"xsd:string\"/>\n");
		if (!context.suppressed("UserInfoEditInputResponse","employeeID")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"employeeID\" type=\"xsd:string\"/>\n");
		}
		if (!context.suppressed("UserInfoEditInputResponse","PasswordExpiration")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"PasswordExpiration\" type=\"xsd:string\"/>\n");
		}
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CUserInfoEditInputResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CUserInfoEditInputResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
	info.addMinVersion("UserInfoEditInputResponse","employeeID",1.1);
	info.addMinVersion("UserInfoEditInputResponse","PasswordExpiration",1.12);
}

StringBuffer &CUserInfoEditInputResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("username");
	form.appendf("  <tr><td><b>username: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("firstname");
	form.appendf("  <tr><td><b>firstname: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("lastname");
	form.appendf("  <tr><td><b>lastname: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (!context.suppressed("UserInfoEditInputResponse","employeeID")) {
		extfix.clear();
		if (prefix && *prefix)
			extfix.append(prefix).append(".");
		extfix.append("employeeID");
		form.appendf("  <tr><td><b>employeeID: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
		form.append("</td></tr>\n");
	}
	if (!context.suppressed("UserInfoEditInputResponse","PasswordExpiration")) {
		extfix.clear();
		if (prefix && *prefix)
			extfix.append(prefix).append(".");
		extfix.append("PasswordExpiration");
		form.appendf("  <tr><td><b>PasswordExpiration: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
		form.append("</td></tr>\n");
	}
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CUserInfoEditInputResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CUserInfoEditInputResponse::serialize(IRpcMessage& rpc_resp)
{
	IEspContext* ctx = rpc_resp.queryContext();
	double clientVer= ctx ? ctx->getClientVersion() : -1; /* no context gets everything */
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
		m_username.marshall(rpc_resp, "username", "", "", "");
		m_firstname.marshall(rpc_resp, "firstname", "", "", "");
		m_lastname.marshall(rpc_resp, "lastname", "", "", "");
		if ((clientVer==-1.0 || clientVer>=1.1))
			m_employeeID.marshall(rpc_resp, "employeeID", "", "", "");
		if ((clientVer==-1.0 || clientVer>=1.12))
			m_PasswordExpiration.marshall(rpc_resp, "PasswordExpiration", "", "", "");
	}
}


void CUserInfoEditInputResponse::copy(CUserInfoEditInputResponse &from)
{
	m_username.copy(from.m_username);
	m_firstname.copy(from.m_firstname);
	m_lastname.copy(from.m_lastname);
	m_employeeID.copy(from.m_employeeID);
	m_PasswordExpiration.copy(from.m_PasswordExpiration);
}


void CUserInfoEditInputResponse::copy(IConstUserInfoEditInputResponse &ifrom)
{
	setUsername(ifrom.getUsername());
	setFirstname(ifrom.getFirstname());
	setLastname(ifrom.getLastname());
	setEmployeeID(ifrom.getEmployeeID());
	setPasswordExpiration(ifrom.getPasswordExpiration());
}


void CUserInfoEditInputResponse::getAttributes(IProperties &attributes)
{
}


void CUserInfoEditInputResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
		double clientVer = ctx ? ctx->getClientVersion() : -1;
		m_username.toStr(ctx, buffer, "username", "", true, "", "");
		m_firstname.toStr(ctx, buffer, "firstname", "", true, "", "");
		m_lastname.toStr(ctx, buffer, "lastname", "", true, "", "");
		if ((clientVer==-1.0 || clientVer>=1.1))
			m_employeeID.toStr(ctx, buffer, "employeeID", "", true, "", "");
		if ((clientVer==-1.0 || clientVer>=1.12))
			m_PasswordExpiration.toStr(ctx, buffer, "PasswordExpiration", "", true, "", "");
	}
}


void CUserInfoEditInputResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CUserInfoEditInputResponse::serializer(IEspContext* ctx, IConstUserInfoEditInputResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<UserInfoEditInputResponse>");
	double clientVer = ctx ? ctx->getClientVersion() : -1;
	// field username
	{
		const char* s = src.getUsername();
		if (s && *s)
		{
			buffer.append("<username>");
			encodeUtf8XML(s,buffer);
			buffer.append("</username>");
		}
	}
	// field firstname
	{
		const char* s = src.getFirstname();
		if (s && *s)
		{
			buffer.append("<firstname>");
			encodeUtf8XML(s,buffer);
			buffer.append("</firstname>");
		}
	}
	// field lastname
	{
		const char* s = src.getLastname();
		if (s && *s)
		{
			buffer.append("<lastname>");
			encodeUtf8XML(s,buffer);
			buffer.append("</lastname>");
		}
	}
	// field employeeID
	if ((clientVer==-1.0 || clientVer>=1.1))
	{
		const char* s = src.getEmployeeID();
		if (s && *s)
		{
			buffer.append("<employeeID>");
			encodeUtf8XML(s,buffer);
			buffer.append("</employeeID>");
		}
	}
	// field PasswordExpiration
	if ((clientVer==-1.0 || clientVer>=1.12))
	{
		const char* s = src.getPasswordExpiration();
		if (s && *s)
		{
			buffer.append("<PasswordExpiration>");
			encodeUtf8XML(s,buffer);
			buffer.append("</PasswordExpiration>");
		}
	}
	if (keepRootTag)
		buffer.append("</UserInfoEditInputResponse>");
}

bool CUserInfoEditInputResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
		hasValue |= m_username.unmarshall(rpc_request, "username", basepath);
		hasValue |= m_firstname.unmarshall(rpc_request, "firstname", basepath);
		hasValue |= m_lastname.unmarshall(rpc_request, "lastname", basepath);
		hasValue |= m_employeeID.unmarshall(rpc_request, "employeeID", basepath);
		hasValue |= m_PasswordExpiration.unmarshall(rpc_request, "PasswordExpiration", basepath);
	}
	return hasValue;
}

bool CUserInfoEditInputResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_username.unmarshall(ctx, soapval, "username");
	hasValue |= m_firstname.unmarshall(ctx, soapval, "firstname");
	hasValue |= m_lastname.unmarshall(ctx, soapval, "lastname");
	hasValue |= m_employeeID.unmarshall(ctx, soapval, "employeeID");
	hasValue |= m_PasswordExpiration.unmarshall(ctx, soapval, "PasswordExpiration");
	return hasValue;
}

bool CUserInfoEditInputResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_username.unmarshall(ctx, params, attachments, "username", basepath);
	hasValue |= m_firstname.unmarshall(ctx, params, attachments, "firstname", basepath);
	hasValue |= m_lastname.unmarshall(ctx, params, attachments, "lastname", basepath);
	hasValue |= m_employeeID.unmarshall(ctx, params, attachments, "employeeID", basepath);
	hasValue |= m_PasswordExpiration.unmarshall(ctx, params, attachments, "PasswordExpiration", basepath);
	return hasValue;
}

const char * CUserInfoEditInputResponse::getUsername() { return m_username.query();}
const char * CUserInfoEditInputResponse::getFirstname() { return m_firstname.query();}
const char * CUserInfoEditInputResponse::getLastname() { return m_lastname.query();}
const char * CUserInfoEditInputResponse::getEmployeeID() { return m_employeeID.query();}
const char * CUserInfoEditInputResponse::getPasswordExpiration() { return m_PasswordExpiration.query();}
void CUserInfoEditInputResponse::setUsername(const char * val){ m_username.set(val); }
void CUserInfoEditInputResponse::setFirstname(const char * val){ m_firstname.set(val); }
void CUserInfoEditInputResponse::setLastname(const char * val){ m_lastname.set(val); }
void CUserInfoEditInputResponse::setEmployeeID(const char * val){ m_employeeID.set(val); }
void CUserInfoEditInputResponse::setPasswordExpiration(const char * val){ m_PasswordExpiration.set(val); }
extern "C"  IEspUserInfoEditInputResponse *createUserInfoEditInputResponse(const char *serv){return ((IEspUserInfoEditInputResponse *)new CUserInfoEditInputResponse(serv));}
extern "C"  IClientUserInfoEditInputResponse *createClientUserInfoEditInputResponse(const char *serv){return ((IClientUserInfoEditInputResponse *)new CUserInfoEditInputResponse(serv));}

//=======================================================
// class CUserInfoEditRequest Implementation
//=======================================================

CUserInfoEditRequest::CUserInfoEditRequest(const char *serviceName, IRpcMessageBinding *init)
	: m_username(nilIgnore),m_firstname(nilIgnore),m_lastname(nilIgnore),m_employeeID(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("UserInfoEditRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CUserInfoEditRequest::CUserInfoEditRequest(const char *serviceName, const char *bc)
	: m_username(nilIgnore),m_firstname(nilIgnore),m_lastname(nilIgnore),m_employeeID(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("UserInfoEditRequest");
}

CUserInfoEditRequest::CUserInfoEditRequest(const char *serviceName, IRpcMessage* rpcmsg)
	: m_username(nilIgnore),m_firstname(nilIgnore),m_lastname(nilIgnore),m_employeeID(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("UserInfoEditRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CUserInfoEditRequest::CUserInfoEditRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_username(nilIgnore),m_firstname(nilIgnore),m_lastname(nilIgnore),m_employeeID(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("UserInfoEditRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CUserInfoEditRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"username\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"firstname\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"lastname\" type=\"xsd:string\"/>\n");
		if (!context.suppressed("UserInfoEditRequest","employeeID")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"employeeID\" type=\"xsd:string\"/>\n");
		}
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CUserInfoEditRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CUserInfoEditRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
	info.addMinVersion("UserInfoEditRequest","employeeID",1.1);
}

StringBuffer &CUserInfoEditRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("username");
	form.appendf("  <tr><td><b>username: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("firstname");
	form.appendf("  <tr><td><b>firstname: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("lastname");
	form.appendf("  <tr><td><b>lastname: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (!context.suppressed("UserInfoEditRequest","employeeID")) {
		extfix.clear();
		if (prefix && *prefix)
			extfix.append(prefix).append(".");
		extfix.append("employeeID");
		form.appendf("  <tr><td><b>employeeID: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
		form.append("</td></tr>\n");
	}
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CUserInfoEditRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CUserInfoEditRequest::serialize(IRpcMessage& rpc_resp)
{
	IEspContext* ctx = rpc_resp.queryContext();
	double clientVer= ctx ? ctx->getClientVersion() : -1; /* no context gets everything */
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_username.marshall(rpc_resp, "username", "", "", "");
	m_firstname.marshall(rpc_resp, "firstname", "", "", "");
	m_lastname.marshall(rpc_resp, "lastname", "", "", "");
	if ((clientVer==-1.0 || clientVer>=1.1))
		m_employeeID.marshall(rpc_resp, "employeeID", "", "", "");
}


void CUserInfoEditRequest::copy(CUserInfoEditRequest &from)
{
	m_username.copy(from.m_username);
	m_firstname.copy(from.m_firstname);
	m_lastname.copy(from.m_lastname);
	m_employeeID.copy(from.m_employeeID);
}


void CUserInfoEditRequest::copy(IConstUserInfoEditRequest &ifrom)
{
	setUsername(ifrom.getUsername());
	setFirstname(ifrom.getFirstname());
	setLastname(ifrom.getLastname());
	setEmployeeID(ifrom.getEmployeeID());
}


void CUserInfoEditRequest::getAttributes(IProperties &attributes)
{
}


void CUserInfoEditRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	double clientVer = ctx ? ctx->getClientVersion() : -1;
	m_username.toStr(ctx, buffer, "username", "", true, "", "");
	m_firstname.toStr(ctx, buffer, "firstname", "", true, "", "");
	m_lastname.toStr(ctx, buffer, "lastname", "", true, "", "");
	if ((clientVer==-1.0 || clientVer>=1.1))
		m_employeeID.toStr(ctx, buffer, "employeeID", "", true, "", "");
}


void CUserInfoEditRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CUserInfoEditRequest::serializer(IEspContext* ctx, IConstUserInfoEditRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<UserInfoEditRequest>");
	double clientVer = ctx ? ctx->getClientVersion() : -1;
	// field username
	{
		const char* s = src.getUsername();
		if (s && *s)
		{
			buffer.append("<username>");
			encodeUtf8XML(s,buffer);
			buffer.append("</username>");
		}
	}
	// field firstname
	{
		const char* s = src.getFirstname();
		if (s && *s)
		{
			buffer.append("<firstname>");
			encodeUtf8XML(s,buffer);
			buffer.append("</firstname>");
		}
	}
	// field lastname
	{
		const char* s = src.getLastname();
		if (s && *s)
		{
			buffer.append("<lastname>");
			encodeUtf8XML(s,buffer);
			buffer.append("</lastname>");
		}
	}
	// field employeeID
	if ((clientVer==-1.0 || clientVer>=1.1))
	{
		const char* s = src.getEmployeeID();
		if (s && *s)
		{
			buffer.append("<employeeID>");
			encodeUtf8XML(s,buffer);
			buffer.append("</employeeID>");
		}
	}
	if (keepRootTag)
		buffer.append("</UserInfoEditRequest>");
}

bool CUserInfoEditRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_username.unmarshall(rpc_request, "username", basepath);
	hasValue |= m_firstname.unmarshall(rpc_request, "firstname", basepath);
	hasValue |= m_lastname.unmarshall(rpc_request, "lastname", basepath);
	hasValue |= m_employeeID.unmarshall(rpc_request, "employeeID", basepath);
	return hasValue;
}

bool CUserInfoEditRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_username.unmarshall(ctx, soapval, "username");
	hasValue |= m_firstname.unmarshall(ctx, soapval, "firstname");
	hasValue |= m_lastname.unmarshall(ctx, soapval, "lastname");
	hasValue |= m_employeeID.unmarshall(ctx, soapval, "employeeID");
	return hasValue;
}

bool CUserInfoEditRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_username.unmarshall(ctx, params, attachments, "username", basepath);
	hasValue |= m_firstname.unmarshall(ctx, params, attachments, "firstname", basepath);
	hasValue |= m_lastname.unmarshall(ctx, params, attachments, "lastname", basepath);
	hasValue |= m_employeeID.unmarshall(ctx, params, attachments, "employeeID", basepath);
	return hasValue;
}

const char * CUserInfoEditRequest::getUsername() { return m_username.query();}
const char * CUserInfoEditRequest::getFirstname() { return m_firstname.query();}
const char * CUserInfoEditRequest::getLastname() { return m_lastname.query();}
const char * CUserInfoEditRequest::getEmployeeID() { return m_employeeID.query();}
void CUserInfoEditRequest::setUsername(const char * val){ m_username.set(val); }
void CUserInfoEditRequest::setFirstname(const char * val){ m_firstname.set(val); }
void CUserInfoEditRequest::setLastname(const char * val){ m_lastname.set(val); }
void CUserInfoEditRequest::setEmployeeID(const char * val){ m_employeeID.set(val); }
extern "C"  IEspUserInfoEditRequest *createUserInfoEditRequest(const char *serv){return ((IEspUserInfoEditRequest *)new CUserInfoEditRequest(serv));}
extern "C"  IClientUserInfoEditRequest *createClientUserInfoEditRequest(const char *serv){return ((IClientUserInfoEditRequest *)new CUserInfoEditRequest(serv));}

//=======================================================
// class CUserInfoEditResponse Implementation
//=======================================================

CUserInfoEditResponse::CUserInfoEditResponse(const char *serviceName, IRpcMessageBinding *init)
	: m_username(nilIgnore),m_retcode(nilIgnore),m_retmsg(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("UserInfoEditResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CUserInfoEditResponse::CUserInfoEditResponse(const char *serviceName, const char *bc)
	: m_username(nilIgnore),m_retcode(nilIgnore),m_retmsg(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("UserInfoEditResponse");
}

CUserInfoEditResponse::CUserInfoEditResponse(const char *serviceName, IRpcMessage* rpcmsg)
	: m_username(nilIgnore),m_retcode(nilIgnore),m_retmsg(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("UserInfoEditResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CUserInfoEditResponse::CUserInfoEditResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_username(nilIgnore),m_retcode(nilIgnore),m_retmsg(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("UserInfoEditResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CUserInfoEditResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"username\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"retcode\" type=\"xsd:int\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"retmsg\" type=\"xsd:string\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CUserInfoEditResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CUserInfoEditResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CUserInfoEditResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("username");
	form.appendf("  <tr><td><b>username: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix) extfix.append(prefix).append(".");
		extfix.append("retcode");
	form.appendf("  <tr><td><b>retcode: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("retmsg");
	form.appendf("  <tr><td><b>retmsg: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CUserInfoEditResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CUserInfoEditResponse::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
		m_username.marshall(rpc_resp, "username", "", "", "");
		m_retcode.marshall(rpc_resp, "retcode", "", "", "");
		m_retmsg.marshall(rpc_resp, "retmsg", "", "", "");
	}
}


void CUserInfoEditResponse::copy(CUserInfoEditResponse &from)
{
	m_username.copy(from.m_username);
	m_retcode.copy(from.m_retcode);
	m_retmsg.copy(from.m_retmsg);
}


void CUserInfoEditResponse::copy(IConstUserInfoEditResponse &ifrom)
{
	setUsername(ifrom.getUsername());
	setRetcode(ifrom.getRetcode());
	setRetmsg(ifrom.getRetmsg());
}


void CUserInfoEditResponse::getAttributes(IProperties &attributes)
{
}


void CUserInfoEditResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
		m_username.toStr(ctx, buffer, "username", "", true, "", "");
		m_retcode.toStr(ctx, buffer, "retcode", "", true, "", "");
		m_retmsg.toStr(ctx, buffer, "retmsg", "", true, "", "");
	}
}


void CUserInfoEditResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CUserInfoEditResponse::serializer(IEspContext* ctx, IConstUserInfoEditResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<UserInfoEditResponse>");
	// field username
	{
		const char* s = src.getUsername();
		if (s && *s)
		{
			buffer.append("<username>");
			encodeUtf8XML(s,buffer);
			buffer.append("</username>");
		}
	}
	// field retcode
	{
		int n = src.getRetcode();
		if (n)
			buffer.appendf("<retcode>%d</retcode>", n);
	}
	// field retmsg
	{
		const char* s = src.getRetmsg();
		if (s && *s)
		{
			buffer.append("<retmsg>");
			encodeUtf8XML(s,buffer);
			buffer.append("</retmsg>");
		}
	}
	if (keepRootTag)
		buffer.append("</UserInfoEditResponse>");
}

bool CUserInfoEditResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
		hasValue |= m_username.unmarshall(rpc_request, "username", basepath);
		hasValue |= m_retcode.unmarshall(rpc_request, "retcode", basepath);
		hasValue |= m_retmsg.unmarshall(rpc_request, "retmsg", basepath);
	}
	return hasValue;
}

bool CUserInfoEditResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_username.unmarshall(ctx, soapval, "username");
	hasValue |= m_retcode.unmarshall(ctx, soapval, "retcode");
	hasValue |= m_retmsg.unmarshall(ctx, soapval, "retmsg");
	return hasValue;
}

bool CUserInfoEditResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_username.unmarshall(ctx, params, attachments, "username", basepath);
	hasValue |= m_retcode.unmarshall(ctx, params, attachments, "retcode", basepath);
	hasValue |= m_retmsg.unmarshall(ctx, params, attachments, "retmsg", basepath);
	return hasValue;
}

const char * CUserInfoEditResponse::getUsername() { return m_username.query();}
int CUserInfoEditResponse::getRetcode() { return m_retcode;}
const char * CUserInfoEditResponse::getRetmsg() { return m_retmsg.query();}
void CUserInfoEditResponse::setUsername(const char * val){ m_username.set(val); }
void CUserInfoEditResponse::setRetcode(int val){ m_retcode=val; }
void CUserInfoEditResponse::setRetmsg(const char * val){ m_retmsg.set(val); }
extern "C"  IEspUserInfoEditResponse *createUserInfoEditResponse(const char *serv){return ((IEspUserInfoEditResponse *)new CUserInfoEditResponse(serv));}
extern "C"  IClientUserInfoEditResponse *createClientUserInfoEditResponse(const char *serv){return ((IClientUserInfoEditResponse *)new CUserInfoEditResponse(serv));}

//=======================================================
// class CAddUserRequest Implementation
//=======================================================

CAddUserRequest::CAddUserRequest(const char *serviceName, IRpcMessageBinding *init)
	: m_username(nilIgnore),m_firstname(nilIgnore),m_lastname(nilIgnore),m_password1(nilIgnore),m_password2(nilIgnore),m_employeeID(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("AddUserRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CAddUserRequest::CAddUserRequest(const char *serviceName, const char *bc)
	: m_username(nilIgnore),m_firstname(nilIgnore),m_lastname(nilIgnore),m_password1(nilIgnore),m_password2(nilIgnore),m_employeeID(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("AddUserRequest");
}

CAddUserRequest::CAddUserRequest(const char *serviceName, IRpcMessage* rpcmsg)
	: m_username(nilIgnore),m_firstname(nilIgnore),m_lastname(nilIgnore),m_password1(nilIgnore),m_password2(nilIgnore),m_employeeID(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("AddUserRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CAddUserRequest::CAddUserRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_username(nilIgnore),m_firstname(nilIgnore),m_lastname(nilIgnore),m_password1(nilIgnore),m_password2(nilIgnore),m_employeeID(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("AddUserRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CAddUserRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"username\" type=\"xsd:string\"");
		if (context.queryOptions()&ESPCTX_ALL_ANNOTATION)
			schema.append("> <xsd:annotation><xsd:appinfo><form formCols=\"20\"/></xsd:appinfo></xsd:annotation></xsd:element>\n");
		else
			schema.append("/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"firstname\" type=\"xsd:string\"");
		if (context.queryOptions()&ESPCTX_ALL_ANNOTATION)
			schema.append("> <xsd:annotation><xsd:appinfo><form formCols=\"20\"/></xsd:appinfo></xsd:annotation></xsd:element>\n");
		else
			schema.append("/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"lastname\" type=\"xsd:string\"");
		if (context.queryOptions()&ESPCTX_ALL_ANNOTATION)
			schema.append("> <xsd:annotation><xsd:appinfo><form formCols=\"20\"/></xsd:appinfo></xsd:annotation></xsd:element>\n");
		else
			schema.append("/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"password1\" type=\"xsd:string\"");
		if (context.queryOptions()&ESPCTX_ALL_ANNOTATION)
			schema.append("> <xsd:annotation><xsd:appinfo><form formType=\"password\" formCols=\"20\"/></xsd:appinfo></xsd:annotation></xsd:element>\n");
		else
			schema.append("/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"password2\" type=\"xsd:string\"");
		if (context.queryOptions()&ESPCTX_ALL_ANNOTATION)
			schema.append("> <xsd:annotation><xsd:appinfo><form formType=\"password\" formCols=\"20\"/></xsd:appinfo></xsd:annotation></xsd:element>\n");
		else
			schema.append("/>\n");
		if (!context.suppressed("AddUserRequest","employeeID")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"employeeID\" type=\"xsd:string\"");
			if (context.queryOptions()&ESPCTX_ALL_ANNOTATION)
				schema.append("> <xsd:annotation><xsd:appinfo><form formCols=\"20\"/></xsd:appinfo></xsd:annotation></xsd:element>\n");
			else
				schema.append("/>\n");
		}
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CAddUserRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CAddUserRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
	info.addMinVersion("AddUserRequest","employeeID",1.1);
}

StringBuffer &CAddUserRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("username");
	form.appendf("  <tr><td><b>User Name: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("firstname");
	form.appendf("  <tr><td><b>First Name: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("lastname");
	form.appendf("  <tr><td><b>Last Name: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("password1");
	form.appendf("  <tr><td><b>Password: </b></td><td><input type=\"password\" name=\"%s\" size=\"20\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("password2");
	form.appendf("  <tr><td><b>Retype password: </b></td><td><input type=\"password\" name=\"%s\" size=\"20\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (!context.suppressed("AddUserRequest","employeeID")) {
		extfix.clear();
		if (prefix && *prefix)
			extfix.append(prefix).append(".");
		extfix.append("employeeID");
		form.appendf("  <tr><td><b>Employee ID: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\" value=\"\" />", extfix.str());
		form.append("</td></tr>\n");
	}
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CAddUserRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CAddUserRequest::serialize(IRpcMessage& rpc_resp)
{
	IEspContext* ctx = rpc_resp.queryContext();
	double clientVer= ctx ? ctx->getClientVersion() : -1; /* no context gets everything */
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_username.marshall(rpc_resp, "username", "", "", "");
	m_firstname.marshall(rpc_resp, "firstname", "", "", "");
	m_lastname.marshall(rpc_resp, "lastname", "", "", "");
	m_password1.marshall(rpc_resp, "password1", "", "", "");
	m_password2.marshall(rpc_resp, "password2", "", "", "");
	if ((clientVer==-1.0 || clientVer>=1.1))
		m_employeeID.marshall(rpc_resp, "employeeID", "", "", "");
}


void CAddUserRequest::copy(CAddUserRequest &from)
{
	m_username.copy(from.m_username);
	m_firstname.copy(from.m_firstname);
	m_lastname.copy(from.m_lastname);
	m_password1.copy(from.m_password1);
	m_password2.copy(from.m_password2);
	m_employeeID.copy(from.m_employeeID);
}


void CAddUserRequest::copy(IConstAddUserRequest &ifrom)
{
	setUsername(ifrom.getUsername());
	setFirstname(ifrom.getFirstname());
	setLastname(ifrom.getLastname());
	setPassword1(ifrom.getPassword1());
	setPassword2(ifrom.getPassword2());
	setEmployeeID(ifrom.getEmployeeID());
}


void CAddUserRequest::getAttributes(IProperties &attributes)
{
}


void CAddUserRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	double clientVer = ctx ? ctx->getClientVersion() : -1;
	m_username.toStr(ctx, buffer, "username", "", true, "", "");
	m_firstname.toStr(ctx, buffer, "firstname", "", true, "", "");
	m_lastname.toStr(ctx, buffer, "lastname", "", true, "", "");
	m_password1.toStr(ctx, buffer, "password1", "", true, "", "");
	m_password2.toStr(ctx, buffer, "password2", "", true, "", "");
	if ((clientVer==-1.0 || clientVer>=1.1))
		m_employeeID.toStr(ctx, buffer, "employeeID", "", true, "", "");
}


void CAddUserRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CAddUserRequest::serializer(IEspContext* ctx, IConstAddUserRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<AddUserRequest>");
	double clientVer = ctx ? ctx->getClientVersion() : -1;
	// field username
	{
		const char* s = src.getUsername();
		if (s && *s)
		{
			buffer.append("<username>");
			encodeUtf8XML(s,buffer);
			buffer.append("</username>");
		}
	}
	// field firstname
	{
		const char* s = src.getFirstname();
		if (s && *s)
		{
			buffer.append("<firstname>");
			encodeUtf8XML(s,buffer);
			buffer.append("</firstname>");
		}
	}
	// field lastname
	{
		const char* s = src.getLastname();
		if (s && *s)
		{
			buffer.append("<lastname>");
			encodeUtf8XML(s,buffer);
			buffer.append("</lastname>");
		}
	}
	// field password1
	{
		const char* s = src.getPassword1();
		if (s && *s)
		{
			buffer.append("<password1>");
			encodeUtf8XML(s,buffer);
			buffer.append("</password1>");
		}
	}
	// field password2
	{
		const char* s = src.getPassword2();
		if (s && *s)
		{
			buffer.append("<password2>");
			encodeUtf8XML(s,buffer);
			buffer.append("</password2>");
		}
	}
	// field employeeID
	if ((clientVer==-1.0 || clientVer>=1.1))
	{
		const char* s = src.getEmployeeID();
		if (s && *s)
		{
			buffer.append("<employeeID>");
			encodeUtf8XML(s,buffer);
			buffer.append("</employeeID>");
		}
	}
	if (keepRootTag)
		buffer.append("</AddUserRequest>");
}

bool CAddUserRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_username.unmarshall(rpc_request, "username", basepath);
	hasValue |= m_firstname.unmarshall(rpc_request, "firstname", basepath);
	hasValue |= m_lastname.unmarshall(rpc_request, "lastname", basepath);
	hasValue |= m_password1.unmarshall(rpc_request, "password1", basepath);
	hasValue |= m_password2.unmarshall(rpc_request, "password2", basepath);
	hasValue |= m_employeeID.unmarshall(rpc_request, "employeeID", basepath);
	return hasValue;
}

bool CAddUserRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_username.unmarshall(ctx, soapval, "username");
	hasValue |= m_firstname.unmarshall(ctx, soapval, "firstname");
	hasValue |= m_lastname.unmarshall(ctx, soapval, "lastname");
	hasValue |= m_password1.unmarshall(ctx, soapval, "password1");
	hasValue |= m_password2.unmarshall(ctx, soapval, "password2");
	hasValue |= m_employeeID.unmarshall(ctx, soapval, "employeeID");
	return hasValue;
}

bool CAddUserRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_username.unmarshall(ctx, params, attachments, "username", basepath);
	hasValue |= m_firstname.unmarshall(ctx, params, attachments, "firstname", basepath);
	hasValue |= m_lastname.unmarshall(ctx, params, attachments, "lastname", basepath);
	hasValue |= m_password1.unmarshall(ctx, params, attachments, "password1", basepath);
	hasValue |= m_password2.unmarshall(ctx, params, attachments, "password2", basepath);
	hasValue |= m_employeeID.unmarshall(ctx, params, attachments, "employeeID", basepath);
	return hasValue;
}

const char * CAddUserRequest::getUsername() { return m_username.query();}
const char * CAddUserRequest::getFirstname() { return m_firstname.query();}
const char * CAddUserRequest::getLastname() { return m_lastname.query();}
const char * CAddUserRequest::getPassword1() { return m_password1.query();}
const char * CAddUserRequest::getPassword2() { return m_password2.query();}
const char * CAddUserRequest::getEmployeeID() { return m_employeeID.query();}
void CAddUserRequest::setUsername(const char * val){ m_username.set(val); }
void CAddUserRequest::setFirstname(const char * val){ m_firstname.set(val); }
void CAddUserRequest::setLastname(const char * val){ m_lastname.set(val); }
void CAddUserRequest::setPassword1(const char * val){ m_password1.set(val); }
void CAddUserRequest::setPassword2(const char * val){ m_password2.set(val); }
void CAddUserRequest::setEmployeeID(const char * val){ m_employeeID.set(val); }
extern "C"  IEspAddUserRequest *createAddUserRequest(const char *serv){return ((IEspAddUserRequest *)new CAddUserRequest(serv));}
extern "C"  IClientAddUserRequest *createClientAddUserRequest(const char *serv){return ((IClientAddUserRequest *)new CAddUserRequest(serv));}

//=======================================================
// class CAddUserResponse Implementation
//=======================================================

CAddUserResponse::CAddUserResponse(const char *serviceName, IRpcMessageBinding *init)
	: m_retcode(nilIgnore),m_retmsg(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("AddUserResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CAddUserResponse::CAddUserResponse(const char *serviceName, const char *bc)
	: m_retcode(nilIgnore),m_retmsg(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("AddUserResponse");
}

CAddUserResponse::CAddUserResponse(const char *serviceName, IRpcMessage* rpcmsg)
	: m_retcode(nilIgnore),m_retmsg(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("AddUserResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CAddUserResponse::CAddUserResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_retcode(nilIgnore),m_retmsg(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("AddUserResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CAddUserResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"retcode\" type=\"xsd:int\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"retmsg\" type=\"xsd:string\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CAddUserResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CAddUserResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CAddUserResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix) extfix.append(prefix).append(".");
		extfix.append("retcode");
	form.appendf("  <tr><td><b>retcode: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("retmsg");
	form.appendf("  <tr><td><b>retmsg: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CAddUserResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CAddUserResponse::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
		m_retcode.marshall(rpc_resp, "retcode", "", "", "");
		m_retmsg.marshall(rpc_resp, "retmsg", "", "", "");
	}
}


void CAddUserResponse::copy(CAddUserResponse &from)
{
	m_retcode.copy(from.m_retcode);
	m_retmsg.copy(from.m_retmsg);
}


void CAddUserResponse::copy(IConstAddUserResponse &ifrom)
{
	setRetcode(ifrom.getRetcode());
	setRetmsg(ifrom.getRetmsg());
}


void CAddUserResponse::getAttributes(IProperties &attributes)
{
}


void CAddUserResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
		m_retcode.toStr(ctx, buffer, "retcode", "", true, "", "");
		m_retmsg.toStr(ctx, buffer, "retmsg", "", true, "", "");
	}
}


void CAddUserResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CAddUserResponse::serializer(IEspContext* ctx, IConstAddUserResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<AddUserResponse>");
	// field retcode
	{
		int n = src.getRetcode();
		if (n)
			buffer.appendf("<retcode>%d</retcode>", n);
	}
	// field retmsg
	{
		const char* s = src.getRetmsg();
		if (s && *s)
		{
			buffer.append("<retmsg>");
			encodeUtf8XML(s,buffer);
			buffer.append("</retmsg>");
		}
	}
	if (keepRootTag)
		buffer.append("</AddUserResponse>");
}

bool CAddUserResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
		hasValue |= m_retcode.unmarshall(rpc_request, "retcode", basepath);
		hasValue |= m_retmsg.unmarshall(rpc_request, "retmsg", basepath);
	}
	return hasValue;
}

bool CAddUserResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_retcode.unmarshall(ctx, soapval, "retcode");
	hasValue |= m_retmsg.unmarshall(ctx, soapval, "retmsg");
	return hasValue;
}

bool CAddUserResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_retcode.unmarshall(ctx, params, attachments, "retcode", basepath);
	hasValue |= m_retmsg.unmarshall(ctx, params, attachments, "retmsg", basepath);
	return hasValue;
}

int CAddUserResponse::getRetcode() { return m_retcode;}
const char * CAddUserResponse::getRetmsg() { return m_retmsg.query();}
void CAddUserResponse::setRetcode(int val){ m_retcode=val; }
void CAddUserResponse::setRetmsg(const char * val){ m_retmsg.set(val); }
extern "C"  IEspAddUserResponse *createAddUserResponse(const char *serv){return ((IEspAddUserResponse *)new CAddUserResponse(serv));}
extern "C"  IClientAddUserResponse *createClientAddUserResponse(const char *serv){return ((IClientAddUserResponse *)new CAddUserResponse(serv));}

//=======================================================
// class CUserActionRequest Implementation
//=======================================================

CUserActionRequest::CUserActionRequest(const char *serviceName, IRpcMessageBinding *init)
	: m_action(nilIgnore),m_ActionType(nilIgnore),m_usernames(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("UserActionRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CUserActionRequest::CUserActionRequest(const char *serviceName, const char *bc)
	: m_action(nilIgnore),m_ActionType(nilIgnore),m_usernames(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("UserActionRequest");
}

CUserActionRequest::CUserActionRequest(const char *serviceName, IRpcMessage* rpcmsg)
	: m_action(nilIgnore),m_ActionType(nilIgnore),m_usernames(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("UserActionRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CUserActionRequest::CUserActionRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_action(nilIgnore),m_ActionType(nilIgnore),m_usernames(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("UserActionRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CUserActionRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"action\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"ActionType\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"usernames\" type=\"tns:EspStringArray\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	if (added.getValue("EspStringArray")==NULL) {
		addEspNativeArray(schema,"string","EspStringArray");
		added.setValue("EspStringArray",1);
	}
	return schema;
}

void CUserActionRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CUserActionRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CUserActionRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("action");
	form.appendf("  <tr><td><b>action: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("ActionType");
	form.appendf("  <tr><td><b>ActionType: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("usernames");
	form.appendf("<tr><td><b>usernames: </b></td><td>");
	form.appendf("<textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea>", extfix.str());
	form.append("</td></tr>");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CUserActionRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CUserActionRequest::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_action.marshall(rpc_resp, "action", "", "", "");
	m_ActionType.marshall(rpc_resp, "ActionType", "", "", "");
	m_usernames.marshall(rpc_resp, "usernames", "Item");
}


void CUserActionRequest::copy(CUserActionRequest &from)
{
	m_action.copy(from.m_action);
	m_ActionType.copy(from.m_ActionType);
	m_usernames.copy(from.m_usernames);
}


void CUserActionRequest::copy(IConstUserActionRequest &ifrom)
{
	setAction(ifrom.getAction());
	setActionType(ifrom.getActionType());
	setUsernames(ifrom.getUsernames());
}


void CUserActionRequest::getAttributes(IProperties &attributes)
{
}


void CUserActionRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_action.toStr(ctx, buffer, "action", "", true, "", "");
	m_ActionType.toStr(ctx, buffer, "ActionType", "", true, "", "");
	m_usernames.toStr(ctx, buffer, "usernames", "Item");
}


void CUserActionRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CUserActionRequest::serializer(IEspContext* ctx, IConstUserActionRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<UserActionRequest>");
	// field action
	{
		const char* s = src.getAction();
		if (s && *s)
		{
			buffer.append("<action>");
			encodeUtf8XML(s,buffer);
			buffer.append("</action>");
		}
	}
	// field ActionType
	{
		const char* s = src.getActionType();
		if (s && *s)
		{
			buffer.append("<ActionType>");
			encodeUtf8XML(s,buffer);
			buffer.append("</ActionType>");
		}
	}
	// field usernames
	{
		StringArray& v = src.getUsernames();
		if (v.length()>0)
			buffer.append("<usernames>");
		for (size32_t i=0;i<v.length();i++)
			buffer.appendf("<Item>%s</Item>",v.item(i));
		if (v.length()>0)
			buffer.append("</usernames>");
	}
	if (keepRootTag)
		buffer.append("</UserActionRequest>");
}

bool CUserActionRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_action.unmarshall(rpc_request, "action", basepath);
	hasValue |= m_ActionType.unmarshall(rpc_request, "ActionType", basepath);
	hasValue |= m_usernames.unmarshall(rpc_request, "usernames", basepath);
	return hasValue;
}

bool CUserActionRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_action.unmarshall(ctx, soapval, "action");
	hasValue |= m_ActionType.unmarshall(ctx, soapval, "ActionType");
	hasValue |= m_usernames.unmarshall(ctx, soapval, "usernames");
	return hasValue;
}

bool CUserActionRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_action.unmarshall(ctx, params, attachments, "action", basepath);
	hasValue |= m_ActionType.unmarshall(ctx, params, attachments, "ActionType", basepath);
	hasValue |= m_usernames.unmarshall(ctx, params, attachments, "usernames", basepath);
	return hasValue;
}

const char * CUserActionRequest::getAction() { return m_action.query();}
const char * CUserActionRequest::getActionType() { return m_ActionType.query();}
StringArray & CUserActionRequest::getUsernames() { return (StringArray &) m_usernames; }
void CUserActionRequest::setAction(const char * val){ m_action.set(val); }
void CUserActionRequest::setActionType(const char * val){ m_ActionType.set(val); }
void CUserActionRequest::setUsernames(StringArray &val){ m_usernames->kill();  CloneArray(m_usernames.getValue(), val); }
extern "C"  IEspUserActionRequest *createUserActionRequest(const char *serv){return ((IEspUserActionRequest *)new CUserActionRequest(serv));}
extern "C"  IClientUserActionRequest *createClientUserActionRequest(const char *serv){return ((IClientUserActionRequest *)new CUserActionRequest(serv));}

//=======================================================
// class CUserActionResponse Implementation
//=======================================================

CUserActionResponse::CUserActionResponse(const char *serviceName, IRpcMessageBinding *init)
	: m_action(nilIgnore),m_retcode(nilIgnore),m_retmsg(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("UserActionResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CUserActionResponse::CUserActionResponse(const char *serviceName, const char *bc)
	: m_action(nilIgnore),m_retcode(nilIgnore),m_retmsg(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("UserActionResponse");
}

CUserActionResponse::CUserActionResponse(const char *serviceName, IRpcMessage* rpcmsg)
	: m_action(nilIgnore),m_retcode(nilIgnore),m_retmsg(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("UserActionResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CUserActionResponse::CUserActionResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_action(nilIgnore),m_retcode(nilIgnore),m_retmsg(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("UserActionResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CUserActionResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"action\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"retcode\" type=\"xsd:int\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"retmsg\" type=\"xsd:string\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CUserActionResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CUserActionResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CUserActionResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("action");
	form.appendf("  <tr><td><b>action: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix) extfix.append(prefix).append(".");
		extfix.append("retcode");
	form.appendf("  <tr><td><b>retcode: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("retmsg");
	form.appendf("  <tr><td><b>retmsg: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CUserActionResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CUserActionResponse::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
		m_action.marshall(rpc_resp, "action", "", "", "");
		m_retcode.marshall(rpc_resp, "retcode", "", "", "");
		m_retmsg.marshall(rpc_resp, "retmsg", "", "", "");
	}
}


void CUserActionResponse::copy(CUserActionResponse &from)
{
	m_action.copy(from.m_action);
	m_retcode.copy(from.m_retcode);
	m_retmsg.copy(from.m_retmsg);
}


void CUserActionResponse::copy(IConstUserActionResponse &ifrom)
{
	setAction(ifrom.getAction());
	setRetcode(ifrom.getRetcode());
	setRetmsg(ifrom.getRetmsg());
}


void CUserActionResponse::getAttributes(IProperties &attributes)
{
}


void CUserActionResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
		m_action.toStr(ctx, buffer, "action", "", true, "", "");
		m_retcode.toStr(ctx, buffer, "retcode", "", true, "", "");
		m_retmsg.toStr(ctx, buffer, "retmsg", "", true, "", "");
	}
}


void CUserActionResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CUserActionResponse::serializer(IEspContext* ctx, IConstUserActionResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<UserActionResponse>");
	// field action
	{
		const char* s = src.getAction();
		if (s && *s)
		{
			buffer.append("<action>");
			encodeUtf8XML(s,buffer);
			buffer.append("</action>");
		}
	}
	// field retcode
	{
		int n = src.getRetcode();
		if (n)
			buffer.appendf("<retcode>%d</retcode>", n);
	}
	// field retmsg
	{
		const char* s = src.getRetmsg();
		if (s && *s)
		{
			buffer.append("<retmsg>");
			encodeUtf8XML(s,buffer);
			buffer.append("</retmsg>");
		}
	}
	if (keepRootTag)
		buffer.append("</UserActionResponse>");
}

bool CUserActionResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
		hasValue |= m_action.unmarshall(rpc_request, "action", basepath);
		hasValue |= m_retcode.unmarshall(rpc_request, "retcode", basepath);
		hasValue |= m_retmsg.unmarshall(rpc_request, "retmsg", basepath);
	}
	return hasValue;
}

bool CUserActionResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_action.unmarshall(ctx, soapval, "action");
	hasValue |= m_retcode.unmarshall(ctx, soapval, "retcode");
	hasValue |= m_retmsg.unmarshall(ctx, soapval, "retmsg");
	return hasValue;
}

bool CUserActionResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_action.unmarshall(ctx, params, attachments, "action", basepath);
	hasValue |= m_retcode.unmarshall(ctx, params, attachments, "retcode", basepath);
	hasValue |= m_retmsg.unmarshall(ctx, params, attachments, "retmsg", basepath);
	return hasValue;
}

const char * CUserActionResponse::getAction() { return m_action.query();}
int CUserActionResponse::getRetcode() { return m_retcode;}
const char * CUserActionResponse::getRetmsg() { return m_retmsg.query();}
void CUserActionResponse::setAction(const char * val){ m_action.set(val); }
void CUserActionResponse::setRetcode(int val){ m_retcode=val; }
void CUserActionResponse::setRetmsg(const char * val){ m_retmsg.set(val); }
extern "C"  IEspUserActionResponse *createUserActionResponse(const char *serv){return ((IEspUserActionResponse *)new CUserActionResponse(serv));}
extern "C"  IClientUserActionResponse *createClientUserActionResponse(const char *serv){return ((IClientUserActionResponse *)new CUserActionResponse(serv));}

//=======================================================
// class CUserResetPassInputRequest Implementation
//=======================================================

CUserResetPassInputRequest::CUserResetPassInputRequest(const char *serviceName, IRpcMessageBinding *init)
	: m_username(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("UserResetPassInputRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CUserResetPassInputRequest::CUserResetPassInputRequest(const char *serviceName, const char *bc)
	: m_username(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("UserResetPassInputRequest");
}

CUserResetPassInputRequest::CUserResetPassInputRequest(const char *serviceName, IRpcMessage* rpcmsg)
	: m_username(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("UserResetPassInputRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CUserResetPassInputRequest::CUserResetPassInputRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_username(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("UserResetPassInputRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CUserResetPassInputRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"username\" type=\"xsd:string\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CUserResetPassInputRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CUserResetPassInputRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CUserResetPassInputRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("username");
	form.appendf("  <tr><td><b>username: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CUserResetPassInputRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CUserResetPassInputRequest::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_username.marshall(rpc_resp, "username", "", "", "");
}


void CUserResetPassInputRequest::copy(CUserResetPassInputRequest &from)
{
	m_username.copy(from.m_username);
}


void CUserResetPassInputRequest::copy(IConstUserResetPassInputRequest &ifrom)
{
	setUsername(ifrom.getUsername());
}


void CUserResetPassInputRequest::getAttributes(IProperties &attributes)
{
}


void CUserResetPassInputRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_username.toStr(ctx, buffer, "username", "", true, "", "");
}


void CUserResetPassInputRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CUserResetPassInputRequest::serializer(IEspContext* ctx, IConstUserResetPassInputRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<UserResetPassInputRequest>");
	// field username
	{
		const char* s = src.getUsername();
		if (s && *s)
		{
			buffer.append("<username>");
			encodeUtf8XML(s,buffer);
			buffer.append("</username>");
		}
	}
	if (keepRootTag)
		buffer.append("</UserResetPassInputRequest>");
}

bool CUserResetPassInputRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_username.unmarshall(rpc_request, "username", basepath);
	return hasValue;
}

bool CUserResetPassInputRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_username.unmarshall(ctx, soapval, "username");
	return hasValue;
}

bool CUserResetPassInputRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_username.unmarshall(ctx, params, attachments, "username", basepath);
	return hasValue;
}

const char * CUserResetPassInputRequest::getUsername() { return m_username.query();}
void CUserResetPassInputRequest::setUsername(const char * val){ m_username.set(val); }
extern "C"  IEspUserResetPassInputRequest *createUserResetPassInputRequest(const char *serv){return ((IEspUserResetPassInputRequest *)new CUserResetPassInputRequest(serv));}
extern "C"  IClientUserResetPassInputRequest *createClientUserResetPassInputRequest(const char *serv){return ((IClientUserResetPassInputRequest *)new CUserResetPassInputRequest(serv));}

//=======================================================
// class CUserResetPassInputResponse Implementation
//=======================================================

CUserResetPassInputResponse::CUserResetPassInputResponse(const char *serviceName, IRpcMessageBinding *init)
	: m_username(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("UserResetPassInputResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CUserResetPassInputResponse::CUserResetPassInputResponse(const char *serviceName, const char *bc)
	: m_username(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("UserResetPassInputResponse");
}

CUserResetPassInputResponse::CUserResetPassInputResponse(const char *serviceName, IRpcMessage* rpcmsg)
	: m_username(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("UserResetPassInputResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CUserResetPassInputResponse::CUserResetPassInputResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_username(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("UserResetPassInputResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CUserResetPassInputResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"username\" type=\"xsd:string\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CUserResetPassInputResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CUserResetPassInputResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CUserResetPassInputResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("username");
	form.appendf("  <tr><td><b>username: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CUserResetPassInputResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CUserResetPassInputResponse::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
		m_username.marshall(rpc_resp, "username", "", "", "");
	}
}


void CUserResetPassInputResponse::copy(CUserResetPassInputResponse &from)
{
	m_username.copy(from.m_username);
}


void CUserResetPassInputResponse::copy(IConstUserResetPassInputResponse &ifrom)
{
	setUsername(ifrom.getUsername());
}


void CUserResetPassInputResponse::getAttributes(IProperties &attributes)
{
}


void CUserResetPassInputResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
		m_username.toStr(ctx, buffer, "username", "", true, "", "");
	}
}


void CUserResetPassInputResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CUserResetPassInputResponse::serializer(IEspContext* ctx, IConstUserResetPassInputResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<UserResetPassInputResponse>");
	// field username
	{
		const char* s = src.getUsername();
		if (s && *s)
		{
			buffer.append("<username>");
			encodeUtf8XML(s,buffer);
			buffer.append("</username>");
		}
	}
	if (keepRootTag)
		buffer.append("</UserResetPassInputResponse>");
}

bool CUserResetPassInputResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
		hasValue |= m_username.unmarshall(rpc_request, "username", basepath);
	}
	return hasValue;
}

bool CUserResetPassInputResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_username.unmarshall(ctx, soapval, "username");
	return hasValue;
}

bool CUserResetPassInputResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_username.unmarshall(ctx, params, attachments, "username", basepath);
	return hasValue;
}

const char * CUserResetPassInputResponse::getUsername() { return m_username.query();}
void CUserResetPassInputResponse::setUsername(const char * val){ m_username.set(val); }
extern "C"  IEspUserResetPassInputResponse *createUserResetPassInputResponse(const char *serv){return ((IEspUserResetPassInputResponse *)new CUserResetPassInputResponse(serv));}
extern "C"  IClientUserResetPassInputResponse *createClientUserResetPassInputResponse(const char *serv){return ((IClientUserResetPassInputResponse *)new CUserResetPassInputResponse(serv));}

//=======================================================
// class CUserResetPassRequest Implementation
//=======================================================

CUserResetPassRequest::CUserResetPassRequest(const char *serviceName, IRpcMessageBinding *init)
	: m_username(nilIgnore),m_newPassword(nilIgnore),m_newPasswordRetype(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("UserResetPassRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CUserResetPassRequest::CUserResetPassRequest(const char *serviceName, const char *bc)
	: m_username(nilIgnore),m_newPassword(nilIgnore),m_newPasswordRetype(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("UserResetPassRequest");
}

CUserResetPassRequest::CUserResetPassRequest(const char *serviceName, IRpcMessage* rpcmsg)
	: m_username(nilIgnore),m_newPassword(nilIgnore),m_newPasswordRetype(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("UserResetPassRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CUserResetPassRequest::CUserResetPassRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_username(nilIgnore),m_newPassword(nilIgnore),m_newPasswordRetype(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("UserResetPassRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CUserResetPassRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"username\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"newPassword\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"newPasswordRetype\" type=\"xsd:string\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CUserResetPassRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CUserResetPassRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CUserResetPassRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("username");
	form.appendf("  <tr><td><b>username: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("newPassword");
	form.appendf("  <tr><td><b>newPassword: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("newPasswordRetype");
	form.appendf("  <tr><td><b>newPasswordRetype: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CUserResetPassRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CUserResetPassRequest::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_username.marshall(rpc_resp, "username", "", "", "");
	m_newPassword.marshall(rpc_resp, "newPassword", "", "", "");
	m_newPasswordRetype.marshall(rpc_resp, "newPasswordRetype", "", "", "");
}


void CUserResetPassRequest::copy(CUserResetPassRequest &from)
{
	m_username.copy(from.m_username);
	m_newPassword.copy(from.m_newPassword);
	m_newPasswordRetype.copy(from.m_newPasswordRetype);
}


void CUserResetPassRequest::copy(IConstUserResetPassRequest &ifrom)
{
	setUsername(ifrom.getUsername());
	setNewPassword(ifrom.getNewPassword());
	setNewPasswordRetype(ifrom.getNewPasswordRetype());
}


void CUserResetPassRequest::getAttributes(IProperties &attributes)
{
}


void CUserResetPassRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_username.toStr(ctx, buffer, "username", "", true, "", "");
	m_newPassword.toStr(ctx, buffer, "newPassword", "", true, "", "");
	m_newPasswordRetype.toStr(ctx, buffer, "newPasswordRetype", "", true, "", "");
}


void CUserResetPassRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CUserResetPassRequest::serializer(IEspContext* ctx, IConstUserResetPassRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<UserResetPassRequest>");
	// field username
	{
		const char* s = src.getUsername();
		if (s && *s)
		{
			buffer.append("<username>");
			encodeUtf8XML(s,buffer);
			buffer.append("</username>");
		}
	}
	// field newPassword
	{
		const char* s = src.getNewPassword();
		if (s && *s)
		{
			buffer.append("<newPassword>");
			encodeUtf8XML(s,buffer);
			buffer.append("</newPassword>");
		}
	}
	// field newPasswordRetype
	{
		const char* s = src.getNewPasswordRetype();
		if (s && *s)
		{
			buffer.append("<newPasswordRetype>");
			encodeUtf8XML(s,buffer);
			buffer.append("</newPasswordRetype>");
		}
	}
	if (keepRootTag)
		buffer.append("</UserResetPassRequest>");
}

bool CUserResetPassRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_username.unmarshall(rpc_request, "username", basepath);
	hasValue |= m_newPassword.unmarshall(rpc_request, "newPassword", basepath);
	hasValue |= m_newPasswordRetype.unmarshall(rpc_request, "newPasswordRetype", basepath);
	return hasValue;
}

bool CUserResetPassRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_username.unmarshall(ctx, soapval, "username");
	hasValue |= m_newPassword.unmarshall(ctx, soapval, "newPassword");
	hasValue |= m_newPasswordRetype.unmarshall(ctx, soapval, "newPasswordRetype");
	return hasValue;
}

bool CUserResetPassRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_username.unmarshall(ctx, params, attachments, "username", basepath);
	hasValue |= m_newPassword.unmarshall(ctx, params, attachments, "newPassword", basepath);
	hasValue |= m_newPasswordRetype.unmarshall(ctx, params, attachments, "newPasswordRetype", basepath);
	return hasValue;
}

const char * CUserResetPassRequest::getUsername() { return m_username.query();}
const char * CUserResetPassRequest::getNewPassword() { return m_newPassword.query();}
const char * CUserResetPassRequest::getNewPasswordRetype() { return m_newPasswordRetype.query();}
void CUserResetPassRequest::setUsername(const char * val){ m_username.set(val); }
void CUserResetPassRequest::setNewPassword(const char * val){ m_newPassword.set(val); }
void CUserResetPassRequest::setNewPasswordRetype(const char * val){ m_newPasswordRetype.set(val); }
extern "C"  IEspUserResetPassRequest *createUserResetPassRequest(const char *serv){return ((IEspUserResetPassRequest *)new CUserResetPassRequest(serv));}
extern "C"  IClientUserResetPassRequest *createClientUserResetPassRequest(const char *serv){return ((IClientUserResetPassRequest *)new CUserResetPassRequest(serv));}

//=======================================================
// class CUserResetPassResponse Implementation
//=======================================================

CUserResetPassResponse::CUserResetPassResponse(const char *serviceName, IRpcMessageBinding *init)
	: m_username(nilIgnore),m_retcode(nilIgnore),m_retmsg(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("UserResetPassResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CUserResetPassResponse::CUserResetPassResponse(const char *serviceName, const char *bc)
	: m_username(nilIgnore),m_retcode(nilIgnore),m_retmsg(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("UserResetPassResponse");
}

CUserResetPassResponse::CUserResetPassResponse(const char *serviceName, IRpcMessage* rpcmsg)
	: m_username(nilIgnore),m_retcode(nilIgnore),m_retmsg(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("UserResetPassResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CUserResetPassResponse::CUserResetPassResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_username(nilIgnore),m_retcode(nilIgnore),m_retmsg(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("UserResetPassResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CUserResetPassResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"username\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"retcode\" type=\"xsd:int\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"retmsg\" type=\"xsd:string\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CUserResetPassResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CUserResetPassResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CUserResetPassResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("username");
	form.appendf("  <tr><td><b>username: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix) extfix.append(prefix).append(".");
		extfix.append("retcode");
	form.appendf("  <tr><td><b>retcode: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("retmsg");
	form.appendf("  <tr><td><b>retmsg: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CUserResetPassResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CUserResetPassResponse::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
		m_username.marshall(rpc_resp, "username", "", "", "");
		m_retcode.marshall(rpc_resp, "retcode", "", "", "");
		m_retmsg.marshall(rpc_resp, "retmsg", "", "", "");
	}
}


void CUserResetPassResponse::copy(CUserResetPassResponse &from)
{
	m_username.copy(from.m_username);
	m_retcode.copy(from.m_retcode);
	m_retmsg.copy(from.m_retmsg);
}


void CUserResetPassResponse::copy(IConstUserResetPassResponse &ifrom)
{
	setUsername(ifrom.getUsername());
	setRetcode(ifrom.getRetcode());
	setRetmsg(ifrom.getRetmsg());
}


void CUserResetPassResponse::getAttributes(IProperties &attributes)
{
}


void CUserResetPassResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
		m_username.toStr(ctx, buffer, "username", "", true, "", "");
		m_retcode.toStr(ctx, buffer, "retcode", "", true, "", "");
		m_retmsg.toStr(ctx, buffer, "retmsg", "", true, "", "");
	}
}


void CUserResetPassResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CUserResetPassResponse::serializer(IEspContext* ctx, IConstUserResetPassResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<UserResetPassResponse>");
	// field username
	{
		const char* s = src.getUsername();
		if (s && *s)
		{
			buffer.append("<username>");
			encodeUtf8XML(s,buffer);
			buffer.append("</username>");
		}
	}
	// field retcode
	{
		int n = src.getRetcode();
		if (n)
			buffer.appendf("<retcode>%d</retcode>", n);
	}
	// field retmsg
	{
		const char* s = src.getRetmsg();
		if (s && *s)
		{
			buffer.append("<retmsg>");
			encodeUtf8XML(s,buffer);
			buffer.append("</retmsg>");
		}
	}
	if (keepRootTag)
		buffer.append("</UserResetPassResponse>");
}

bool CUserResetPassResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
		hasValue |= m_username.unmarshall(rpc_request, "username", basepath);
		hasValue |= m_retcode.unmarshall(rpc_request, "retcode", basepath);
		hasValue |= m_retmsg.unmarshall(rpc_request, "retmsg", basepath);
	}
	return hasValue;
}

bool CUserResetPassResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_username.unmarshall(ctx, soapval, "username");
	hasValue |= m_retcode.unmarshall(ctx, soapval, "retcode");
	hasValue |= m_retmsg.unmarshall(ctx, soapval, "retmsg");
	return hasValue;
}

bool CUserResetPassResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_username.unmarshall(ctx, params, attachments, "username", basepath);
	hasValue |= m_retcode.unmarshall(ctx, params, attachments, "retcode", basepath);
	hasValue |= m_retmsg.unmarshall(ctx, params, attachments, "retmsg", basepath);
	return hasValue;
}

const char * CUserResetPassResponse::getUsername() { return m_username.query();}
int CUserResetPassResponse::getRetcode() { return m_retcode;}
const char * CUserResetPassResponse::getRetmsg() { return m_retmsg.query();}
void CUserResetPassResponse::setUsername(const char * val){ m_username.set(val); }
void CUserResetPassResponse::setRetcode(int val){ m_retcode=val; }
void CUserResetPassResponse::setRetmsg(const char * val){ m_retmsg.set(val); }
extern "C"  IEspUserResetPassResponse *createUserResetPassResponse(const char *serv){return ((IEspUserResetPassResponse *)new CUserResetPassResponse(serv));}
extern "C"  IClientUserResetPassResponse *createClientUserResetPassResponse(const char *serv){return ((IClientUserResetPassResponse *)new CUserResetPassResponse(serv));}

//=======================================================
// class CGroupRequest Implementation
//=======================================================

CGroupRequest::CGroupRequest(const char *serviceName, IRpcMessageBinding *init)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GroupRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CGroupRequest::CGroupRequest(const char *serviceName, const char *bc)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GroupRequest");
}

CGroupRequest::CGroupRequest(const char *serviceName, IRpcMessage* rpcmsg)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GroupRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CGroupRequest::CGroupRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GroupRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CGroupRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType><xsd:all/></xsd:complexType></xsd:element>\n", msgTypeName);
		}
	}
	return schema;
}

void CGroupRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CGroupRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CGroupRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CGroupRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CGroupRequest::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

}


void CGroupRequest::copy(CGroupRequest &from)
{
}


void CGroupRequest::copy(IConstGroupRequest &ifrom)
{
}


void CGroupRequest::getAttributes(IProperties &attributes)
{
}


void CGroupRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
}


void CGroupRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CGroupRequest::serializer(IEspContext* ctx, IConstGroupRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<GroupRequest>");
	if (keepRootTag)
		buffer.append("</GroupRequest>");
}

bool CGroupRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	return hasValue;
}

bool CGroupRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	return hasValue;
}

bool CGroupRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	return hasValue;
}

extern "C"  IEspGroupRequest *createGroupRequest(const char *serv){return ((IEspGroupRequest *)new CGroupRequest(serv));}
extern "C"  IClientGroupRequest *createClientGroupRequest(const char *serv){return ((IClientGroupRequest *)new CGroupRequest(serv));}

//=======================================================
// class CGroupResponse Implementation
//=======================================================

CGroupResponse::CGroupResponse(const char *serviceName, IRpcMessageBinding *init)
	: m_NoSecMngr(0, nilIgnore,false),m_Groups(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GroupResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CGroupResponse::CGroupResponse(const char *serviceName, const char *bc)
	: m_NoSecMngr(0, nilIgnore,false),m_Groups(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GroupResponse");
}

CGroupResponse::CGroupResponse(const char *serviceName, IRpcMessage* rpcmsg)
	: m_NoSecMngr(0, nilIgnore,false),m_Groups(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GroupResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CGroupResponse::CGroupResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_NoSecMngr(0, nilIgnore,false),m_Groups(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GroupResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CGroupResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		if (!context.suppressed("GroupResponse","NoSecMngr")) {
			schema.append("<xsd:element minOccurs=\"0\" default=\"false\" name=\"NoSecMngr\" type=\"xsd:boolean\"/>\n");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Groups\">\n");
		schema.append("<xsd:complexType><xsd:sequence>\n");
		schema.append("<xsd:element minOccurs=\"0\" maxOccurs=\"unbounded\" name=\"Group\" type=\"tns:GroupInfo\"/>");
		schema.append("</xsd:sequence></xsd:complexType>");
		schema.append("</xsd:element>");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	if (!(flags & 0x10)  || (flags & 0x100))
	{
		CGroupInfo::getXsdDefinition(context, request, schema, added);
	}
	return schema;
}

void CGroupResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CGroupResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
	info.addMinVersion("GroupResponse","NoSecMngr",1.04);
	if (!added.getValue("GroupInfo"))
	{
		added.setValue("GroupInfo",1);
		CGroupInfo::getMapInfo(info,added);
	}
}

StringBuffer &CGroupResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	if (!context.suppressed("GroupResponse","NoSecMngr")) {
		extfix.clear();
		if (prefix && *prefix)
			extfix.append(prefix).append(".");
		extfix.append("NoSecMngr");
		
	form.appendf("  <tr><td><b>NoSecMngr? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	}
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Groups");
	form.appendf("<tr><td><b>Groups: </b></td><td>");
	form.appendf("<table><tr><td><textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea></td>", extfix.str());
	form.append("</tr></table>");
	form.append("</td></tr>");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CGroupResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CGroupResponse::serialize(IRpcMessage& rpc_resp)
{
	IEspContext* ctx = rpc_resp.queryContext();
	double clientVer= ctx ? ctx->getClientVersion() : -1; /* no context gets everything */
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
		if ((clientVer==-1.0 || clientVer>=1.04))
			m_NoSecMngr.marshall(rpc_resp, "NoSecMngr", "", "", "");
		m_Groups.marshall(rpc_resp, "Groups", "Group");
	}
}


void CGroupResponse::copy(CGroupResponse &from)
{
	m_NoSecMngr.copy(from.m_NoSecMngr);
	m_Groups.copy(from.m_Groups);
}


void CGroupResponse::copy(IConstGroupResponse &ifrom)
{
	setNoSecMngr(ifrom.getNoSecMngr());
	setGroups(ifrom.getGroups());
}


void CGroupResponse::getAttributes(IProperties &attributes)
{
}


void CGroupResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
		double clientVer = ctx ? ctx->getClientVersion() : -1;
		if ((clientVer==-1.0 || clientVer>=1.04))
			m_NoSecMngr.toStr(ctx, buffer, "NoSecMngr", "", true, "", "");
		m_Groups.toStr(ctx, buffer, "Groups", "Group");
	}
}


void CGroupResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CGroupResponse::serializer(IEspContext* ctx, IConstGroupResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<GroupResponse>");
	double clientVer = ctx ? ctx->getClientVersion() : -1;
	// field NoSecMngr
	if ((clientVer==-1.0 || clientVer>=1.04))
	{
		bool b = src.getNoSecMngr();
		if (b)
			buffer.appendf("<NoSecMngr>1</NoSecMngr>");
	}
	// field Groups
	{
		IArrayOf<IConstGroupInfo>& v = src.getGroups();
		int size = v.length();
		if (size>0)
			buffer.append("<Groups>");
		for (int i=0;i<size;i++)
		{
			buffer.append("<Group>");
			CGroupInfo::serializer(ctx,v.item(i),buffer,false);
			buffer.append("</Group>");
		}
		if (size>0)
			buffer.append("</Groups>");
	}
	if (keepRootTag)
		buffer.append("</GroupResponse>");
}

bool CGroupResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
		hasValue |= m_NoSecMngr.unmarshall(rpc_request, "NoSecMngr", basepath);
		hasValue |= m_Groups.unmarshall(rpc_request, "Groups", basepath);
	}
	return hasValue;
}

bool CGroupResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_NoSecMngr.unmarshall(ctx, soapval, "NoSecMngr");
	hasValue |= m_Groups.unmarshall(ctx, soapval, "Groups");
	return hasValue;
}

bool CGroupResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_NoSecMngr.unmarshall(ctx, params, attachments, "NoSecMngr", basepath);
	hasValue |= m_Groups.unmarshall(ctx, params, attachments, "Groups", basepath);
	return hasValue;
}

bool CGroupResponse::getNoSecMngr() { return m_NoSecMngr;}
IArrayOf<IConstGroupInfo> & CGroupResponse::getGroups() { return (IArrayOf<IConstGroupInfo> &) m_Groups; }
void CGroupResponse::setNoSecMngr(bool val){ m_NoSecMngr=val; }
void CGroupResponse::setGroups(IArrayOf<IEspGroupInfo> &val)
{
	m_Groups->kill();
	IArrayOf<IConstGroupInfo> &target = m_Groups.getValue();
	ForEachItemIn(idx, val)
	{
		IEspGroupInfo &item = (val).item(idx);
		item.Link();
		target.append(item);
	}
}
void CGroupResponse::setGroups(IArrayOf<IConstGroupInfo> &val)
{
	m_Groups->kill();
	IArrayOf<IConstGroupInfo> &target = m_Groups.getValue();
	ForEachItemIn(idx, val)
	{
		IConstGroupInfo &item = val.item(idx);
		item.Link();
		target.append(item);
	}
}
extern "C"  IEspGroupResponse *createGroupResponse(const char *serv){return ((IEspGroupResponse *)new CGroupResponse(serv));}
extern "C"  IClientGroupResponse *createClientGroupResponse(const char *serv){return ((IClientGroupResponse *)new CGroupResponse(serv));}

//=======================================================
// class CGroupQueryRequest Implementation
//=======================================================

CGroupQueryRequest::CGroupQueryRequest(const char *serviceName, IRpcMessageBinding *init)
	: m_PageSize(nilRemove),m_PageStartFrom(nilRemove),m_SortBy(nilRemove),m_Descending(0, nilRemove,false),m_CacheHint(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GroupQueryRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CGroupQueryRequest::CGroupQueryRequest(const char *serviceName, const char *bc)
	: m_PageSize(nilRemove),m_PageStartFrom(nilRemove),m_SortBy(nilRemove),m_Descending(0, nilRemove,false),m_CacheHint(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GroupQueryRequest");
}

CGroupQueryRequest::CGroupQueryRequest(const char *serviceName, IRpcMessage* rpcmsg)
	: m_PageSize(nilRemove),m_PageStartFrom(nilRemove),m_SortBy(nilRemove),m_Descending(0, nilRemove,false),m_CacheHint(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GroupQueryRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CGroupQueryRequest::CGroupQueryRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_PageSize(nilRemove),m_PageStartFrom(nilRemove),m_SortBy(nilRemove),m_Descending(0, nilRemove,false),m_CacheHint(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GroupQueryRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CGroupQueryRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"PageSize\" type=\"xsd:unsignedInt\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"PageStartFrom\" type=\"xsd:long\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"SortBy\" type=\"tns:GroupSortBy\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" default=\"false\" name=\"Descending\" type=\"xsd:boolean\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"CacheHint\" type=\"xsd:long\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	if (!(flags & 0x10)  || (flags & 0x100))
	{
		CXGroupSortBy::getXsdDefinition(context, request, schema, added);
	}
	return schema;
}

void CGroupQueryRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CGroupQueryRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
	if (!added.getValue("GroupSortBy"))
	{
		added.setValue("GroupSortBy",1);
		CXGroupSortBy::getMapInfo(info,added);
	}
}

StringBuffer &CGroupQueryRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix) extfix.append(prefix).append(".");
		extfix.append("PageSize");
	form.appendf("  <tr><td><b>PageSize: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("PageStartFrom");
	form.appendf("  <tr><td><b>PageStartFrom: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("SortBy");
	form.appendf("  <tr><td><b>SortBy: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Descending");
	
	form.appendf("  <tr><td><b>Descending? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("CacheHint");
	form.appendf("  <tr><td><b>CacheHint: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CGroupQueryRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CGroupQueryRequest::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_PageSize.marshall(rpc_resp, "PageSize", "", "", "");
	m_PageStartFrom.marshall(rpc_resp, "PageStartFrom", "", "", "");
	m_SortBy.marshall(rpc_resp, "SortBy", "", "", "");
	m_Descending.marshall(rpc_resp, "Descending", "", "", "");
	m_CacheHint.marshall(rpc_resp, "CacheHint", "", "", "");
}


void CGroupQueryRequest::copy(CGroupQueryRequest &from)
{
	m_PageSize.copy(from.m_PageSize);
	m_PageStartFrom.copy(from.m_PageStartFrom);
	m_SortBy.copy(from.m_SortBy);
	m_Descending.copy(from.m_Descending);
	m_CacheHint.copy(from.m_CacheHint);
}


void CGroupQueryRequest::copy(IConstGroupQueryRequest &ifrom)
{
	setPageSize(ifrom.getPageSize());
	setPageStartFrom(ifrom.getPageStartFrom());
	setSortBy(ifrom.getSortBy());
	setDescending(ifrom.getDescending());
	setCacheHint(ifrom.getCacheHint());
}


void CGroupQueryRequest::getAttributes(IProperties &attributes)
{
}


void CGroupQueryRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_PageSize.toStr(ctx, buffer, "PageSize", "", true, "", "");
	m_PageStartFrom.toStr(ctx, buffer, "PageStartFrom", "", true, "", "");
	m_SortBy.toStr(ctx, buffer, "SortBy", "", true, "", "");
	m_Descending.toStr(ctx, buffer, "Descending", "", true, "", "");
	m_CacheHint.toStr(ctx, buffer, "CacheHint", "", true, "", "");
}


void CGroupQueryRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CGroupQueryRequest::serializer(IEspContext* ctx, IConstGroupQueryRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<GroupQueryRequest>");
	// field PageSize
	{
		//*** default kind: TK_UNSIGNED; type=(null), name=PageSize
		buffer.append("<PageSize>");
		buffer.append(src.getPageSize());
		buffer.append("</PageSize>");
	}
	// field PageStartFrom
	{
		//*** default kind: TK_INT; type=int64, name=PageStartFrom
		buffer.append("<PageStartFrom>");
		buffer.append(src.getPageStartFrom());
		buffer.append("</PageStartFrom>");
	}
	// field SortBy
	{
		const char* s = src.getSortByAsString();
		buffer.append("<SortBy>");
		encodeUtf8XML(s,buffer);
		buffer.append("</SortBy>");
	}
	// field Descending
	{
		bool b = src.getDescending();
		if (b)
			buffer.appendf("<Descending>1</Descending>");
	}
	// field CacheHint
	{
		//*** default kind: TK_INT; type=int64, name=CacheHint
		buffer.append("<CacheHint>");
		buffer.append(src.getCacheHint());
		buffer.append("</CacheHint>");
	}
	if (keepRootTag)
		buffer.append("</GroupQueryRequest>");
}

bool CGroupQueryRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_PageSize.unmarshall(rpc_request, "PageSize", basepath);
	hasValue |= m_PageStartFrom.unmarshall(rpc_request, "PageStartFrom", basepath);
	hasValue |= m_SortBy.unmarshall(rpc_request, "SortBy", basepath);
	hasValue |= m_Descending.unmarshall(rpc_request, "Descending", basepath);
	hasValue |= m_CacheHint.unmarshall(rpc_request, "CacheHint", basepath);
	return hasValue;
}

bool CGroupQueryRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_PageSize.unmarshall(ctx, soapval, "PageSize");
	hasValue |= m_PageStartFrom.unmarshall(ctx, soapval, "PageStartFrom");
	hasValue |= m_SortBy.unmarshall(ctx, soapval, "SortBy");
	hasValue |= m_Descending.unmarshall(ctx, soapval, "Descending");
	hasValue |= m_CacheHint.unmarshall(ctx, soapval, "CacheHint");
	return hasValue;
}

bool CGroupQueryRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_PageSize.unmarshall(ctx, params, attachments, "PageSize", basepath);
	hasValue |= m_PageStartFrom.unmarshall(ctx, params, attachments, "PageStartFrom", basepath);
	hasValue |= m_SortBy.unmarshall(ctx, params, attachments, "SortBy", basepath);
	hasValue |= m_Descending.unmarshall(ctx, params, attachments, "Descending", basepath);
	hasValue |= m_CacheHint.unmarshall(ctx, params, attachments, "CacheHint", basepath);
	return hasValue;
}

bool CGroupQueryRequest::getPageSize_isNull(){return m_PageSize.is_nil();}
unsigned int CGroupQueryRequest::getPageSize() { return m_PageSize;}
bool CGroupQueryRequest::getPageStartFrom_isNull(){return m_PageStartFrom.is_nil();}
__int64 CGroupQueryRequest::getPageStartFrom() { return m_PageStartFrom;}
CGroupSortBy CGroupQueryRequest::getSortBy() { return m_SortBy.getValue(); }
const char* CGroupQueryRequest::getSortByAsString() {  return (const char*)m_SortBy; }
bool CGroupQueryRequest::getDescending_isNull(){return m_Descending.is_nil();}
bool CGroupQueryRequest::getDescending() { return m_Descending;}
bool CGroupQueryRequest::getCacheHint_isNull(){return m_CacheHint.is_nil();}
__int64 CGroupQueryRequest::getCacheHint() { return m_CacheHint;}
void CGroupQueryRequest::setPageSize_null(){ m_PageSize.Nil(); }void CGroupQueryRequest::setPageSize(unsigned int val){ m_PageSize=val; }
void CGroupQueryRequest::setPageStartFrom_null(){ m_PageStartFrom.Nil(); }void CGroupQueryRequest::setPageStartFrom(__int64 val){ m_PageStartFrom=val; }
void CGroupQueryRequest::setSortBy(CGroupSortBy val) { m_SortBy.setValue(val); }
void CGroupQueryRequest::setSortBy(const char* val) { m_SortBy.setValue(val); }
void CGroupQueryRequest::setDescending_null(){ m_Descending.Nil(); }void CGroupQueryRequest::setDescending(bool val){ m_Descending=val; }
void CGroupQueryRequest::setCacheHint_null(){ m_CacheHint.Nil(); }void CGroupQueryRequest::setCacheHint(__int64 val){ m_CacheHint=val; }
extern "C"  IEspGroupQueryRequest *createGroupQueryRequest(const char *serv){return ((IEspGroupQueryRequest *)new CGroupQueryRequest(serv));}
extern "C"  IClientGroupQueryRequest *createClientGroupQueryRequest(const char *serv){return ((IClientGroupQueryRequest *)new CGroupQueryRequest(serv));}

//=======================================================
// class CGroupQueryResponse Implementation
//=======================================================

CGroupQueryResponse::CGroupQueryResponse(const char *serviceName, IRpcMessageBinding *init)
	: m_NoSecMngr(0, nilRemove,false),m_Groups(nilRemove),m_TotalGroups(nilRemove),m_CacheHint(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GroupQueryResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CGroupQueryResponse::CGroupQueryResponse(const char *serviceName, const char *bc)
	: m_NoSecMngr(0, nilRemove,false),m_Groups(nilRemove),m_TotalGroups(nilRemove),m_CacheHint(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GroupQueryResponse");
}

CGroupQueryResponse::CGroupQueryResponse(const char *serviceName, IRpcMessage* rpcmsg)
	: m_NoSecMngr(0, nilRemove,false),m_Groups(nilRemove),m_TotalGroups(nilRemove),m_CacheHint(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GroupQueryResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CGroupQueryResponse::CGroupQueryResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_NoSecMngr(0, nilRemove,false),m_Groups(nilRemove),m_TotalGroups(nilRemove),m_CacheHint(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GroupQueryResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CGroupQueryResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" default=\"false\" name=\"NoSecMngr\" type=\"xsd:boolean\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Groups\">\n");
		schema.append("<xsd:complexType><xsd:sequence>\n");
		schema.append("<xsd:element minOccurs=\"0\" maxOccurs=\"unbounded\" name=\"Group\" type=\"tns:GroupInfo\"/>");
		schema.append("</xsd:sequence></xsd:complexType>");
		schema.append("</xsd:element>");
		schema.append("<xsd:element minOccurs=\"0\" name=\"TotalGroups\" type=\"xsd:long\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"CacheHint\" type=\"xsd:long\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	if (!(flags & 0x10)  || (flags & 0x100))
	{
		CGroupInfo::getXsdDefinition(context, request, schema, added);
	}
	return schema;
}

void CGroupQueryResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CGroupQueryResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
	if (!added.getValue("GroupInfo"))
	{
		added.setValue("GroupInfo",1);
		CGroupInfo::getMapInfo(info,added);
	}
}

StringBuffer &CGroupQueryResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("NoSecMngr");
	
	form.appendf("  <tr><td><b>NoSecMngr? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Groups");
	form.appendf("<tr><td><b>Groups: </b></td><td>");
	form.appendf("<table><tr><td><textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea></td>", extfix.str());
	form.append("</tr></table>");
	form.append("</td></tr>");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("TotalGroups");
	form.appendf("  <tr><td><b>TotalGroups: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("CacheHint");
	form.appendf("  <tr><td><b>CacheHint: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CGroupQueryResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CGroupQueryResponse::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
		m_NoSecMngr.marshall(rpc_resp, "NoSecMngr", "", "", "");
		m_Groups.marshall(rpc_resp, "Groups", "Group");
		m_TotalGroups.marshall(rpc_resp, "TotalGroups", "", "", "");
		m_CacheHint.marshall(rpc_resp, "CacheHint", "", "", "");
	}
}


void CGroupQueryResponse::copy(CGroupQueryResponse &from)
{
	m_NoSecMngr.copy(from.m_NoSecMngr);
	m_Groups.copy(from.m_Groups);
	m_TotalGroups.copy(from.m_TotalGroups);
	m_CacheHint.copy(from.m_CacheHint);
}


void CGroupQueryResponse::copy(IConstGroupQueryResponse &ifrom)
{
	setNoSecMngr(ifrom.getNoSecMngr());
	setGroups(ifrom.getGroups());
	setTotalGroups(ifrom.getTotalGroups());
	setCacheHint(ifrom.getCacheHint());
}


void CGroupQueryResponse::getAttributes(IProperties &attributes)
{
}


void CGroupQueryResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
		m_NoSecMngr.toStr(ctx, buffer, "NoSecMngr", "", true, "", "");
		m_Groups.toStr(ctx, buffer, "Groups", "Group");
		m_TotalGroups.toStr(ctx, buffer, "TotalGroups", "", true, "", "");
		m_CacheHint.toStr(ctx, buffer, "CacheHint", "", true, "", "");
	}
}


void CGroupQueryResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CGroupQueryResponse::serializer(IEspContext* ctx, IConstGroupQueryResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<GroupQueryResponse>");
	// field NoSecMngr
	{
		bool b = src.getNoSecMngr();
		if (b)
			buffer.appendf("<NoSecMngr>1</NoSecMngr>");
	}
	// field Groups
	{
		IArrayOf<IConstGroupInfo>& v = src.getGroups();
		int size = v.length();
		if (size>0)
			buffer.append("<Groups>");
		for (int i=0;i<size;i++)
		{
			buffer.append("<Group>");
			CGroupInfo::serializer(ctx,v.item(i),buffer,false);
			buffer.append("</Group>");
		}
		if (size>0)
			buffer.append("</Groups>");
	}
	// field TotalGroups
	{
		//*** default kind: TK_INT; type=int64, name=TotalGroups
		buffer.append("<TotalGroups>");
		buffer.append(src.getTotalGroups());
		buffer.append("</TotalGroups>");
	}
	// field CacheHint
	{
		//*** default kind: TK_INT; type=int64, name=CacheHint
		buffer.append("<CacheHint>");
		buffer.append(src.getCacheHint());
		buffer.append("</CacheHint>");
	}
	if (keepRootTag)
		buffer.append("</GroupQueryResponse>");
}

bool CGroupQueryResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
		hasValue |= m_NoSecMngr.unmarshall(rpc_request, "NoSecMngr", basepath);
		hasValue |= m_Groups.unmarshall(rpc_request, "Groups", basepath);
		hasValue |= m_TotalGroups.unmarshall(rpc_request, "TotalGroups", basepath);
		hasValue |= m_CacheHint.unmarshall(rpc_request, "CacheHint", basepath);
	}
	return hasValue;
}

bool CGroupQueryResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_NoSecMngr.unmarshall(ctx, soapval, "NoSecMngr");
	hasValue |= m_Groups.unmarshall(ctx, soapval, "Groups");
	hasValue |= m_TotalGroups.unmarshall(ctx, soapval, "TotalGroups");
	hasValue |= m_CacheHint.unmarshall(ctx, soapval, "CacheHint");
	return hasValue;
}

bool CGroupQueryResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_NoSecMngr.unmarshall(ctx, params, attachments, "NoSecMngr", basepath);
	hasValue |= m_Groups.unmarshall(ctx, params, attachments, "Groups", basepath);
	hasValue |= m_TotalGroups.unmarshall(ctx, params, attachments, "TotalGroups", basepath);
	hasValue |= m_CacheHint.unmarshall(ctx, params, attachments, "CacheHint", basepath);
	return hasValue;
}

bool CGroupQueryResponse::getNoSecMngr_isNull(){return m_NoSecMngr.is_nil();}
bool CGroupQueryResponse::getNoSecMngr() { return m_NoSecMngr;}
IArrayOf<IConstGroupInfo> & CGroupQueryResponse::getGroups() { return (IArrayOf<IConstGroupInfo> &) m_Groups; }
bool CGroupQueryResponse::getTotalGroups_isNull(){return m_TotalGroups.is_nil();}
__int64 CGroupQueryResponse::getTotalGroups() { return m_TotalGroups;}
bool CGroupQueryResponse::getCacheHint_isNull(){return m_CacheHint.is_nil();}
__int64 CGroupQueryResponse::getCacheHint() { return m_CacheHint;}
void CGroupQueryResponse::setNoSecMngr_null(){ m_NoSecMngr.Nil(); }void CGroupQueryResponse::setNoSecMngr(bool val){ m_NoSecMngr=val; }
void CGroupQueryResponse::setGroups(IArrayOf<IEspGroupInfo> &val)
{
	m_Groups->kill();
	IArrayOf<IConstGroupInfo> &target = m_Groups.getValue();
	ForEachItemIn(idx, val)
	{
		IEspGroupInfo &item = (val).item(idx);
		item.Link();
		target.append(item);
	}
}
void CGroupQueryResponse::setGroups(IArrayOf<IConstGroupInfo> &val)
{
	m_Groups->kill();
	IArrayOf<IConstGroupInfo> &target = m_Groups.getValue();
	ForEachItemIn(idx, val)
	{
		IConstGroupInfo &item = val.item(idx);
		item.Link();
		target.append(item);
	}
}
void CGroupQueryResponse::setTotalGroups_null(){ m_TotalGroups.Nil(); }void CGroupQueryResponse::setTotalGroups(__int64 val){ m_TotalGroups=val; }
void CGroupQueryResponse::setCacheHint_null(){ m_CacheHint.Nil(); }void CGroupQueryResponse::setCacheHint(__int64 val){ m_CacheHint=val; }
extern "C"  IEspGroupQueryResponse *createGroupQueryResponse(const char *serv){return ((IEspGroupQueryResponse *)new CGroupQueryResponse(serv));}
extern "C"  IClientGroupQueryResponse *createClientGroupQueryResponse(const char *serv){return ((IClientGroupQueryResponse *)new CGroupQueryResponse(serv));}

//=======================================================
// class CGroupAddRequest Implementation
//=======================================================

CGroupAddRequest::CGroupAddRequest(const char *serviceName, IRpcMessageBinding *init)
	: m_groupname(nilIgnore),m_groupOwner(nilIgnore),m_groupDesc(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GroupAddRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CGroupAddRequest::CGroupAddRequest(const char *serviceName, const char *bc)
	: m_groupname(nilIgnore),m_groupOwner(nilIgnore),m_groupDesc(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GroupAddRequest");
}

CGroupAddRequest::CGroupAddRequest(const char *serviceName, IRpcMessage* rpcmsg)
	: m_groupname(nilIgnore),m_groupOwner(nilIgnore),m_groupDesc(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GroupAddRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CGroupAddRequest::CGroupAddRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_groupname(nilIgnore),m_groupOwner(nilIgnore),m_groupDesc(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GroupAddRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CGroupAddRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"groupname\" type=\"xsd:string\"/>\n");
		if (!context.suppressed("GroupAddRequest","groupOwner")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"groupOwner\" type=\"xsd:string\"/>\n");
		}
		if (!context.suppressed("GroupAddRequest","groupDesc")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"groupDesc\" type=\"xsd:string\"/>\n");
		}
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CGroupAddRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CGroupAddRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
	info.addMinVersion("GroupAddRequest","groupOwner",1.09);
	info.addMinVersion("GroupAddRequest","groupDesc",1.09);
}

StringBuffer &CGroupAddRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("groupname");
	form.appendf("  <tr><td><b>groupname: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (!context.suppressed("GroupAddRequest","groupOwner")) {
		extfix.clear();
		if (prefix && *prefix)
			extfix.append(prefix).append(".");
		extfix.append("groupOwner");
		form.appendf("  <tr><td><b>groupOwner: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
		form.append("</td></tr>\n");
	}
	if (!context.suppressed("GroupAddRequest","groupDesc")) {
		extfix.clear();
		if (prefix && *prefix)
			extfix.append(prefix).append(".");
		extfix.append("groupDesc");
		form.appendf("  <tr><td><b>groupDesc: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
		form.append("</td></tr>\n");
	}
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CGroupAddRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CGroupAddRequest::serialize(IRpcMessage& rpc_resp)
{
	IEspContext* ctx = rpc_resp.queryContext();
	double clientVer= ctx ? ctx->getClientVersion() : -1; /* no context gets everything */
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_groupname.marshall(rpc_resp, "groupname", "", "", "");
	if ((clientVer==-1.0 || clientVer>=1.09))
		m_groupOwner.marshall(rpc_resp, "groupOwner", "", "", "");
	if ((clientVer==-1.0 || clientVer>=1.09))
		m_groupDesc.marshall(rpc_resp, "groupDesc", "", "", "");
}


void CGroupAddRequest::copy(CGroupAddRequest &from)
{
	m_groupname.copy(from.m_groupname);
	m_groupOwner.copy(from.m_groupOwner);
	m_groupDesc.copy(from.m_groupDesc);
}


void CGroupAddRequest::copy(IConstGroupAddRequest &ifrom)
{
	setGroupname(ifrom.getGroupname());
	setGroupOwner(ifrom.getGroupOwner());
	setGroupDesc(ifrom.getGroupDesc());
}


void CGroupAddRequest::getAttributes(IProperties &attributes)
{
}


void CGroupAddRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	double clientVer = ctx ? ctx->getClientVersion() : -1;
	m_groupname.toStr(ctx, buffer, "groupname", "", true, "", "");
	if ((clientVer==-1.0 || clientVer>=1.09))
		m_groupOwner.toStr(ctx, buffer, "groupOwner", "", true, "", "");
	if ((clientVer==-1.0 || clientVer>=1.09))
		m_groupDesc.toStr(ctx, buffer, "groupDesc", "", true, "", "");
}


void CGroupAddRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CGroupAddRequest::serializer(IEspContext* ctx, IConstGroupAddRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<GroupAddRequest>");
	double clientVer = ctx ? ctx->getClientVersion() : -1;
	// field groupname
	{
		const char* s = src.getGroupname();
		if (s && *s)
		{
			buffer.append("<groupname>");
			encodeUtf8XML(s,buffer);
			buffer.append("</groupname>");
		}
	}
	// field groupOwner
	if ((clientVer==-1.0 || clientVer>=1.09))
	{
		const char* s = src.getGroupOwner();
		if (s && *s)
		{
			buffer.append("<groupOwner>");
			encodeUtf8XML(s,buffer);
			buffer.append("</groupOwner>");
		}
	}
	// field groupDesc
	if ((clientVer==-1.0 || clientVer>=1.09))
	{
		const char* s = src.getGroupDesc();
		if (s && *s)
		{
			buffer.append("<groupDesc>");
			encodeUtf8XML(s,buffer);
			buffer.append("</groupDesc>");
		}
	}
	if (keepRootTag)
		buffer.append("</GroupAddRequest>");
}

bool CGroupAddRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_groupname.unmarshall(rpc_request, "groupname", basepath);
	hasValue |= m_groupOwner.unmarshall(rpc_request, "groupOwner", basepath);
	hasValue |= m_groupDesc.unmarshall(rpc_request, "groupDesc", basepath);
	return hasValue;
}

bool CGroupAddRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_groupname.unmarshall(ctx, soapval, "groupname");
	hasValue |= m_groupOwner.unmarshall(ctx, soapval, "groupOwner");
	hasValue |= m_groupDesc.unmarshall(ctx, soapval, "groupDesc");
	return hasValue;
}

bool CGroupAddRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_groupname.unmarshall(ctx, params, attachments, "groupname", basepath);
	hasValue |= m_groupOwner.unmarshall(ctx, params, attachments, "groupOwner", basepath);
	hasValue |= m_groupDesc.unmarshall(ctx, params, attachments, "groupDesc", basepath);
	return hasValue;
}

const char * CGroupAddRequest::getGroupname() { return m_groupname.query();}
const char * CGroupAddRequest::getGroupOwner() { return m_groupOwner.query();}
const char * CGroupAddRequest::getGroupDesc() { return m_groupDesc.query();}
void CGroupAddRequest::setGroupname(const char * val){ m_groupname.set(val); }
void CGroupAddRequest::setGroupOwner(const char * val){ m_groupOwner.set(val); }
void CGroupAddRequest::setGroupDesc(const char * val){ m_groupDesc.set(val); }
extern "C"  IEspGroupAddRequest *createGroupAddRequest(const char *serv){return ((IEspGroupAddRequest *)new CGroupAddRequest(serv));}
extern "C"  IClientGroupAddRequest *createClientGroupAddRequest(const char *serv){return ((IClientGroupAddRequest *)new CGroupAddRequest(serv));}

//=======================================================
// class CGroupAddResponse Implementation
//=======================================================

CGroupAddResponse::CGroupAddResponse(const char *serviceName, IRpcMessageBinding *init)
	: m_groupname(nilIgnore),m_retcode(nilIgnore),m_retmsg(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GroupAddResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CGroupAddResponse::CGroupAddResponse(const char *serviceName, const char *bc)
	: m_groupname(nilIgnore),m_retcode(nilIgnore),m_retmsg(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GroupAddResponse");
}

CGroupAddResponse::CGroupAddResponse(const char *serviceName, IRpcMessage* rpcmsg)
	: m_groupname(nilIgnore),m_retcode(nilIgnore),m_retmsg(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GroupAddResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CGroupAddResponse::CGroupAddResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_groupname(nilIgnore),m_retcode(nilIgnore),m_retmsg(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GroupAddResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CGroupAddResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"groupname\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"retcode\" type=\"xsd:int\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"retmsg\" type=\"xsd:string\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CGroupAddResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CGroupAddResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CGroupAddResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("groupname");
	form.appendf("  <tr><td><b>groupname: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix) extfix.append(prefix).append(".");
		extfix.append("retcode");
	form.appendf("  <tr><td><b>retcode: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("retmsg");
	form.appendf("  <tr><td><b>retmsg: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CGroupAddResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CGroupAddResponse::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
		m_groupname.marshall(rpc_resp, "groupname", "", "", "");
		m_retcode.marshall(rpc_resp, "retcode", "", "", "");
		m_retmsg.marshall(rpc_resp, "retmsg", "", "", "");
	}
}


void CGroupAddResponse::copy(CGroupAddResponse &from)
{
	m_groupname.copy(from.m_groupname);
	m_retcode.copy(from.m_retcode);
	m_retmsg.copy(from.m_retmsg);
}


void CGroupAddResponse::copy(IConstGroupAddResponse &ifrom)
{
	setGroupname(ifrom.getGroupname());
	setRetcode(ifrom.getRetcode());
	setRetmsg(ifrom.getRetmsg());
}


void CGroupAddResponse::getAttributes(IProperties &attributes)
{
}


void CGroupAddResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
		m_groupname.toStr(ctx, buffer, "groupname", "", true, "", "");
		m_retcode.toStr(ctx, buffer, "retcode", "", true, "", "");
		m_retmsg.toStr(ctx, buffer, "retmsg", "", true, "", "");
	}
}


void CGroupAddResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CGroupAddResponse::serializer(IEspContext* ctx, IConstGroupAddResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<GroupAddResponse>");
	// field groupname
	{
		const char* s = src.getGroupname();
		if (s && *s)
		{
			buffer.append("<groupname>");
			encodeUtf8XML(s,buffer);
			buffer.append("</groupname>");
		}
	}
	// field retcode
	{
		int n = src.getRetcode();
		if (n)
			buffer.appendf("<retcode>%d</retcode>", n);
	}
	// field retmsg
	{
		const char* s = src.getRetmsg();
		if (s && *s)
		{
			buffer.append("<retmsg>");
			encodeUtf8XML(s,buffer);
			buffer.append("</retmsg>");
		}
	}
	if (keepRootTag)
		buffer.append("</GroupAddResponse>");
}

bool CGroupAddResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
		hasValue |= m_groupname.unmarshall(rpc_request, "groupname", basepath);
		hasValue |= m_retcode.unmarshall(rpc_request, "retcode", basepath);
		hasValue |= m_retmsg.unmarshall(rpc_request, "retmsg", basepath);
	}
	return hasValue;
}

bool CGroupAddResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_groupname.unmarshall(ctx, soapval, "groupname");
	hasValue |= m_retcode.unmarshall(ctx, soapval, "retcode");
	hasValue |= m_retmsg.unmarshall(ctx, soapval, "retmsg");
	return hasValue;
}

bool CGroupAddResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_groupname.unmarshall(ctx, params, attachments, "groupname", basepath);
	hasValue |= m_retcode.unmarshall(ctx, params, attachments, "retcode", basepath);
	hasValue |= m_retmsg.unmarshall(ctx, params, attachments, "retmsg", basepath);
	return hasValue;
}

const char * CGroupAddResponse::getGroupname() { return m_groupname.query();}
int CGroupAddResponse::getRetcode() { return m_retcode;}
const char * CGroupAddResponse::getRetmsg() { return m_retmsg.query();}
void CGroupAddResponse::setGroupname(const char * val){ m_groupname.set(val); }
void CGroupAddResponse::setRetcode(int val){ m_retcode=val; }
void CGroupAddResponse::setRetmsg(const char * val){ m_retmsg.set(val); }
extern "C"  IEspGroupAddResponse *createGroupAddResponse(const char *serv){return ((IEspGroupAddResponse *)new CGroupAddResponse(serv));}
extern "C"  IClientGroupAddResponse *createClientGroupAddResponse(const char *serv){return ((IClientGroupAddResponse *)new CGroupAddResponse(serv));}

//=======================================================
// class CGroupActionRequest Implementation
//=======================================================

CGroupActionRequest::CGroupActionRequest(const char *serviceName, IRpcMessageBinding *init)
	: m_groupnames(nilRemove),m_ActionType(nilRemove),m_DeletePermission(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GroupActionRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CGroupActionRequest::CGroupActionRequest(const char *serviceName, const char *bc)
	: m_groupnames(nilRemove),m_ActionType(nilRemove),m_DeletePermission(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GroupActionRequest");
}

CGroupActionRequest::CGroupActionRequest(const char *serviceName, IRpcMessage* rpcmsg)
	: m_groupnames(nilRemove),m_ActionType(nilRemove),m_DeletePermission(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GroupActionRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CGroupActionRequest::CGroupActionRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_groupnames(nilRemove),m_ActionType(nilRemove),m_DeletePermission(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GroupActionRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CGroupActionRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"groupnames\" type=\"tns:EspStringArray\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"ActionType\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"DeletePermission\" type=\"xsd:boolean\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	if (added.getValue("EspStringArray")==NULL) {
		addEspNativeArray(schema,"string","EspStringArray");
		added.setValue("EspStringArray",1);
	}
	return schema;
}

void CGroupActionRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CGroupActionRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CGroupActionRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("groupnames");
	form.appendf("<tr><td><b>groupnames: </b></td><td>");
	form.appendf("<textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea>", extfix.str());
	form.append("</td></tr>");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("ActionType");
	form.appendf("  <tr><td><b>ActionType: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("DeletePermission");
	
	form.appendf("  <tr><td><b>DeletePermission? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CGroupActionRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CGroupActionRequest::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_groupnames.marshall(rpc_resp, "groupnames", "Item");
	m_ActionType.marshall(rpc_resp, "ActionType", "", "", "");
	m_DeletePermission.marshall(rpc_resp, "DeletePermission", "", "", "");
}


void CGroupActionRequest::copy(CGroupActionRequest &from)
{
	m_groupnames.copy(from.m_groupnames);
	m_ActionType.copy(from.m_ActionType);
	m_DeletePermission.copy(from.m_DeletePermission);
}


void CGroupActionRequest::copy(IConstGroupActionRequest &ifrom)
{
	setGroupnames(ifrom.getGroupnames());
	setActionType(ifrom.getActionType());
	setDeletePermission(ifrom.getDeletePermission());
}


void CGroupActionRequest::getAttributes(IProperties &attributes)
{
}


void CGroupActionRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_groupnames.toStr(ctx, buffer, "groupnames", "Item");
	m_ActionType.toStr(ctx, buffer, "ActionType", "", true, "", "");
	m_DeletePermission.toStr(ctx, buffer, "DeletePermission", "", true, "", "");
}


void CGroupActionRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CGroupActionRequest::serializer(IEspContext* ctx, IConstGroupActionRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<GroupActionRequest>");
	// field groupnames
	{
		StringArray& v = src.getGroupnames();
		if (v.length()>0)
			buffer.append("<groupnames>");
		for (size32_t i=0;i<v.length();i++)
			buffer.appendf("<Item>%s</Item>",v.item(i));
		if (v.length()>0)
			buffer.append("</groupnames>");
	}
	// field ActionType
	{
		const char* s = src.getActionType();
		if (s && *s)
		{
			buffer.append("<ActionType>");
			encodeUtf8XML(s,buffer);
			buffer.append("</ActionType>");
		}
	}
	// field DeletePermission
	{
		bool b = src.getDeletePermission();
		if (b)
			buffer.appendf("<DeletePermission>1</DeletePermission>");
	}
	if (keepRootTag)
		buffer.append("</GroupActionRequest>");
}

bool CGroupActionRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_groupnames.unmarshall(rpc_request, "groupnames", basepath);
	hasValue |= m_ActionType.unmarshall(rpc_request, "ActionType", basepath);
	hasValue |= m_DeletePermission.unmarshall(rpc_request, "DeletePermission", basepath);
	return hasValue;
}

bool CGroupActionRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_groupnames.unmarshall(ctx, soapval, "groupnames");
	hasValue |= m_ActionType.unmarshall(ctx, soapval, "ActionType");
	hasValue |= m_DeletePermission.unmarshall(ctx, soapval, "DeletePermission");
	return hasValue;
}

bool CGroupActionRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_groupnames.unmarshall(ctx, params, attachments, "groupnames", basepath);
	hasValue |= m_ActionType.unmarshall(ctx, params, attachments, "ActionType", basepath);
	hasValue |= m_DeletePermission.unmarshall(ctx, params, attachments, "DeletePermission", basepath);
	return hasValue;
}

StringArray & CGroupActionRequest::getGroupnames() { return (StringArray &) m_groupnames; }
const char * CGroupActionRequest::getActionType() { return m_ActionType.query();}
bool CGroupActionRequest::getDeletePermission_isNull(){return m_DeletePermission.is_nil();}
bool CGroupActionRequest::getDeletePermission() { return m_DeletePermission;}
void CGroupActionRequest::setGroupnames(StringArray &val){ m_groupnames->kill();  CloneArray(m_groupnames.getValue(), val); }
void CGroupActionRequest::setActionType(const char * val){ m_ActionType.set(val); }
void CGroupActionRequest::setDeletePermission_null(){ m_DeletePermission.Nil(); }void CGroupActionRequest::setDeletePermission(bool val){ m_DeletePermission=val; }
extern "C"  IEspGroupActionRequest *createGroupActionRequest(const char *serv){return ((IEspGroupActionRequest *)new CGroupActionRequest(serv));}
extern "C"  IClientGroupActionRequest *createClientGroupActionRequest(const char *serv){return ((IClientGroupActionRequest *)new CGroupActionRequest(serv));}

//=======================================================
// class CGroupActionResponse Implementation
//=======================================================

CGroupActionResponse::CGroupActionResponse(const char *serviceName, IRpcMessageBinding *init)
	: m_Groupnames(nilIgnore),m_Permissions(nilIgnore),m_retcode(nilIgnore),m_retmsg(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GroupActionResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CGroupActionResponse::CGroupActionResponse(const char *serviceName, const char *bc)
	: m_Groupnames(nilIgnore),m_Permissions(nilIgnore),m_retcode(nilIgnore),m_retmsg(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GroupActionResponse");
}

CGroupActionResponse::CGroupActionResponse(const char *serviceName, IRpcMessage* rpcmsg)
	: m_Groupnames(nilIgnore),m_Permissions(nilIgnore),m_retcode(nilIgnore),m_retmsg(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GroupActionResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CGroupActionResponse::CGroupActionResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_Groupnames(nilIgnore),m_Permissions(nilIgnore),m_retcode(nilIgnore),m_retmsg(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GroupActionResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CGroupActionResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Groupnames\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Permissions\">\n");
		schema.append("<xsd:complexType><xsd:sequence>\n");
		schema.append("<xsd:element minOccurs=\"0\" maxOccurs=\"unbounded\" name=\"Permission\" type=\"tns:AccountPermission\"/>");
		schema.append("</xsd:sequence></xsd:complexType>");
		schema.append("</xsd:element>");
		schema.append("<xsd:element minOccurs=\"0\" name=\"retcode\" type=\"xsd:int\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"retmsg\" type=\"xsd:string\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	if (!(flags & 0x10)  || (flags & 0x100))
	{
		CAccountPermission::getXsdDefinition(context, request, schema, added);
	}
	return schema;
}

void CGroupActionResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CGroupActionResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
	if (!added.getValue("AccountPermission"))
	{
		added.setValue("AccountPermission",1);
		CAccountPermission::getMapInfo(info,added);
	}
}

StringBuffer &CGroupActionResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Groupnames");
	form.appendf("  <tr><td><b>Groupnames: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Permissions");
	form.appendf("<tr><td><b>Permissions: </b></td><td>");
	form.appendf("<table><tr><td><textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea></td>", extfix.str());
	form.append("</tr></table>");
	form.append("</td></tr>");
	extfix.clear();
	if (prefix && *prefix) extfix.append(prefix).append(".");
		extfix.append("retcode");
	form.appendf("  <tr><td><b>retcode: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("retmsg");
	form.appendf("  <tr><td><b>retmsg: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CGroupActionResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CGroupActionResponse::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
		m_Groupnames.marshall(rpc_resp, "Groupnames", "", "", "");
		m_Permissions.marshall(rpc_resp, "Permissions", "Permission");
		m_retcode.marshall(rpc_resp, "retcode", "", "", "");
		m_retmsg.marshall(rpc_resp, "retmsg", "", "", "");
	}
}


void CGroupActionResponse::copy(CGroupActionResponse &from)
{
	m_Groupnames.copy(from.m_Groupnames);
	m_Permissions.copy(from.m_Permissions);
	m_retcode.copy(from.m_retcode);
	m_retmsg.copy(from.m_retmsg);
}


void CGroupActionResponse::copy(IConstGroupActionResponse &ifrom)
{
	setGroupnames(ifrom.getGroupnames());
	setPermissions(ifrom.getPermissions());
	setRetcode(ifrom.getRetcode());
	setRetmsg(ifrom.getRetmsg());
}


void CGroupActionResponse::getAttributes(IProperties &attributes)
{
}


void CGroupActionResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
		m_Groupnames.toStr(ctx, buffer, "Groupnames", "", true, "", "");
		m_Permissions.toStr(ctx, buffer, "Permissions", "Permission");
		m_retcode.toStr(ctx, buffer, "retcode", "", true, "", "");
		m_retmsg.toStr(ctx, buffer, "retmsg", "", true, "", "");
	}
}


void CGroupActionResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CGroupActionResponse::serializer(IEspContext* ctx, IConstGroupActionResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<GroupActionResponse>");
	// field Groupnames
	{
		const char* s = src.getGroupnames();
		if (s && *s)
		{
			buffer.append("<Groupnames>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Groupnames>");
		}
	}
	// field Permissions
	{
		IArrayOf<IConstAccountPermission>& v = src.getPermissions();
		int size = v.length();
		if (size>0)
			buffer.append("<Permissions>");
		for (int i=0;i<size;i++)
		{
			buffer.append("<Permission>");
			CAccountPermission::serializer(ctx,v.item(i),buffer,false);
			buffer.append("</Permission>");
		}
		if (size>0)
			buffer.append("</Permissions>");
	}
	// field retcode
	{
		int n = src.getRetcode();
		if (n)
			buffer.appendf("<retcode>%d</retcode>", n);
	}
	// field retmsg
	{
		const char* s = src.getRetmsg();
		if (s && *s)
		{
			buffer.append("<retmsg>");
			encodeUtf8XML(s,buffer);
			buffer.append("</retmsg>");
		}
	}
	if (keepRootTag)
		buffer.append("</GroupActionResponse>");
}

bool CGroupActionResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
		hasValue |= m_Groupnames.unmarshall(rpc_request, "Groupnames", basepath);
		hasValue |= m_Permissions.unmarshall(rpc_request, "Permissions", basepath);
		hasValue |= m_retcode.unmarshall(rpc_request, "retcode", basepath);
		hasValue |= m_retmsg.unmarshall(rpc_request, "retmsg", basepath);
	}
	return hasValue;
}

bool CGroupActionResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Groupnames.unmarshall(ctx, soapval, "Groupnames");
	hasValue |= m_Permissions.unmarshall(ctx, soapval, "Permissions");
	hasValue |= m_retcode.unmarshall(ctx, soapval, "retcode");
	hasValue |= m_retmsg.unmarshall(ctx, soapval, "retmsg");
	return hasValue;
}

bool CGroupActionResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Groupnames.unmarshall(ctx, params, attachments, "Groupnames", basepath);
	hasValue |= m_Permissions.unmarshall(ctx, params, attachments, "Permissions", basepath);
	hasValue |= m_retcode.unmarshall(ctx, params, attachments, "retcode", basepath);
	hasValue |= m_retmsg.unmarshall(ctx, params, attachments, "retmsg", basepath);
	return hasValue;
}

const char * CGroupActionResponse::getGroupnames() { return m_Groupnames.query();}
IArrayOf<IConstAccountPermission> & CGroupActionResponse::getPermissions() { return (IArrayOf<IConstAccountPermission> &) m_Permissions; }
int CGroupActionResponse::getRetcode() { return m_retcode;}
const char * CGroupActionResponse::getRetmsg() { return m_retmsg.query();}
void CGroupActionResponse::setGroupnames(const char * val){ m_Groupnames.set(val); }
void CGroupActionResponse::setPermissions(IArrayOf<IEspAccountPermission> &val)
{
	m_Permissions->kill();
	IArrayOf<IConstAccountPermission> &target = m_Permissions.getValue();
	ForEachItemIn(idx, val)
	{
		IEspAccountPermission &item = (val).item(idx);
		item.Link();
		target.append(item);
	}
}
void CGroupActionResponse::setPermissions(IArrayOf<IConstAccountPermission> &val)
{
	m_Permissions->kill();
	IArrayOf<IConstAccountPermission> &target = m_Permissions.getValue();
	ForEachItemIn(idx, val)
	{
		IConstAccountPermission &item = val.item(idx);
		item.Link();
		target.append(item);
	}
}
void CGroupActionResponse::setRetcode(int val){ m_retcode=val; }
void CGroupActionResponse::setRetmsg(const char * val){ m_retmsg.set(val); }
extern "C"  IEspGroupActionResponse *createGroupActionResponse(const char *serv){return ((IEspGroupActionResponse *)new CGroupActionResponse(serv));}
extern "C"  IClientGroupActionResponse *createClientGroupActionResponse(const char *serv){return ((IClientGroupActionResponse *)new CGroupActionResponse(serv));}

//=======================================================
// class CGroupEditRequest Implementation
//=======================================================

CGroupEditRequest::CGroupEditRequest(const char *serviceName, IRpcMessageBinding *init)
	: m_groupname(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GroupEditRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CGroupEditRequest::CGroupEditRequest(const char *serviceName, const char *bc)
	: m_groupname(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GroupEditRequest");
}

CGroupEditRequest::CGroupEditRequest(const char *serviceName, IRpcMessage* rpcmsg)
	: m_groupname(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GroupEditRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CGroupEditRequest::CGroupEditRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_groupname(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GroupEditRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CGroupEditRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"groupname\" type=\"xsd:string\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CGroupEditRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CGroupEditRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CGroupEditRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("groupname");
	form.appendf("  <tr><td><b>groupname: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CGroupEditRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CGroupEditRequest::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_groupname.marshall(rpc_resp, "groupname", "", "", "");
}


void CGroupEditRequest::copy(CGroupEditRequest &from)
{
	m_groupname.copy(from.m_groupname);
}


void CGroupEditRequest::copy(IConstGroupEditRequest &ifrom)
{
	setGroupname(ifrom.getGroupname());
}


void CGroupEditRequest::getAttributes(IProperties &attributes)
{
}


void CGroupEditRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_groupname.toStr(ctx, buffer, "groupname", "", true, "", "");
}


void CGroupEditRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CGroupEditRequest::serializer(IEspContext* ctx, IConstGroupEditRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<GroupEditRequest>");
	// field groupname
	{
		const char* s = src.getGroupname();
		if (s && *s)
		{
			buffer.append("<groupname>");
			encodeUtf8XML(s,buffer);
			buffer.append("</groupname>");
		}
	}
	if (keepRootTag)
		buffer.append("</GroupEditRequest>");
}

bool CGroupEditRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_groupname.unmarshall(rpc_request, "groupname", basepath);
	return hasValue;
}

bool CGroupEditRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_groupname.unmarshall(ctx, soapval, "groupname");
	return hasValue;
}

bool CGroupEditRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_groupname.unmarshall(ctx, params, attachments, "groupname", basepath);
	return hasValue;
}

const char * CGroupEditRequest::getGroupname() { return m_groupname.query();}
void CGroupEditRequest::setGroupname(const char * val){ m_groupname.set(val); }
extern "C"  IEspGroupEditRequest *createGroupEditRequest(const char *serv){return ((IEspGroupEditRequest *)new CGroupEditRequest(serv));}
extern "C"  IClientGroupEditRequest *createClientGroupEditRequest(const char *serv){return ((IClientGroupEditRequest *)new CGroupEditRequest(serv));}

//=======================================================
// class CGroupEditResponse Implementation
//=======================================================

CGroupEditResponse::CGroupEditResponse(const char *serviceName, IRpcMessageBinding *init)
	: m_groupname(nilIgnore),m_Users(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GroupEditResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CGroupEditResponse::CGroupEditResponse(const char *serviceName, const char *bc)
	: m_groupname(nilIgnore),m_Users(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GroupEditResponse");
}

CGroupEditResponse::CGroupEditResponse(const char *serviceName, IRpcMessage* rpcmsg)
	: m_groupname(nilIgnore),m_Users(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GroupEditResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CGroupEditResponse::CGroupEditResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_groupname(nilIgnore),m_Users(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GroupEditResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CGroupEditResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"groupname\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Users\">\n");
		schema.append("<xsd:complexType><xsd:sequence>\n");
		schema.append("<xsd:element minOccurs=\"0\" maxOccurs=\"unbounded\" name=\"User\" type=\"tns:UserInfo\"/>");
		schema.append("</xsd:sequence></xsd:complexType>");
		schema.append("</xsd:element>");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	if (!(flags & 0x10)  || (flags & 0x100))
	{
		CUserInfo::getXsdDefinition(context, request, schema, added);
	}
	return schema;
}

void CGroupEditResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CGroupEditResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
	if (!added.getValue("UserInfo"))
	{
		added.setValue("UserInfo",1);
		CUserInfo::getMapInfo(info,added);
	}
}

StringBuffer &CGroupEditResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("groupname");
	form.appendf("  <tr><td><b>groupname: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Users");
	form.appendf("<tr><td><b>Users: </b></td><td>");
	form.appendf("<table><tr><td><textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea></td>", extfix.str());
	form.append("</tr></table>");
	form.append("</td></tr>");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CGroupEditResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CGroupEditResponse::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
		m_groupname.marshall(rpc_resp, "groupname", "", "", "");
		m_Users.marshall(rpc_resp, "Users", "User");
	}
}


void CGroupEditResponse::copy(CGroupEditResponse &from)
{
	m_groupname.copy(from.m_groupname);
	m_Users.copy(from.m_Users);
}


void CGroupEditResponse::copy(IConstGroupEditResponse &ifrom)
{
	setGroupname(ifrom.getGroupname());
	setUsers(ifrom.getUsers());
}


void CGroupEditResponse::getAttributes(IProperties &attributes)
{
}


void CGroupEditResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
		m_groupname.toStr(ctx, buffer, "groupname", "", true, "", "");
		m_Users.toStr(ctx, buffer, "Users", "User");
	}
}


void CGroupEditResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CGroupEditResponse::serializer(IEspContext* ctx, IConstGroupEditResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<GroupEditResponse>");
	// field groupname
	{
		const char* s = src.getGroupname();
		if (s && *s)
		{
			buffer.append("<groupname>");
			encodeUtf8XML(s,buffer);
			buffer.append("</groupname>");
		}
	}
	// field Users
	{
		IArrayOf<IConstUserInfo>& v = src.getUsers();
		int size = v.length();
		if (size>0)
			buffer.append("<Users>");
		for (int i=0;i<size;i++)
		{
			buffer.append("<User>");
			CUserInfo::serializer(ctx,v.item(i),buffer,false);
			buffer.append("</User>");
		}
		if (size>0)
			buffer.append("</Users>");
	}
	if (keepRootTag)
		buffer.append("</GroupEditResponse>");
}

bool CGroupEditResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
		hasValue |= m_groupname.unmarshall(rpc_request, "groupname", basepath);
		hasValue |= m_Users.unmarshall(rpc_request, "Users", basepath);
	}
	return hasValue;
}

bool CGroupEditResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_groupname.unmarshall(ctx, soapval, "groupname");
	hasValue |= m_Users.unmarshall(ctx, soapval, "Users");
	return hasValue;
}

bool CGroupEditResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_groupname.unmarshall(ctx, params, attachments, "groupname", basepath);
	hasValue |= m_Users.unmarshall(ctx, params, attachments, "Users", basepath);
	return hasValue;
}

const char * CGroupEditResponse::getGroupname() { return m_groupname.query();}
IArrayOf<IConstUserInfo> & CGroupEditResponse::getUsers() { return (IArrayOf<IConstUserInfo> &) m_Users; }
void CGroupEditResponse::setGroupname(const char * val){ m_groupname.set(val); }
void CGroupEditResponse::setUsers(IArrayOf<IEspUserInfo> &val)
{
	m_Users->kill();
	IArrayOf<IConstUserInfo> &target = m_Users.getValue();
	ForEachItemIn(idx, val)
	{
		IEspUserInfo &item = (val).item(idx);
		item.Link();
		target.append(item);
	}
}
void CGroupEditResponse::setUsers(IArrayOf<IConstUserInfo> &val)
{
	m_Users->kill();
	IArrayOf<IConstUserInfo> &target = m_Users.getValue();
	ForEachItemIn(idx, val)
	{
		IConstUserInfo &item = val.item(idx);
		item.Link();
		target.append(item);
	}
}
extern "C"  IEspGroupEditResponse *createGroupEditResponse(const char *serv){return ((IEspGroupEditResponse *)new CGroupEditResponse(serv));}
extern "C"  IClientGroupEditResponse *createClientGroupEditResponse(const char *serv){return ((IClientGroupEditResponse *)new CGroupEditResponse(serv));}

//=======================================================
// class CGroupMemberQueryRequest Implementation
//=======================================================

CGroupMemberQueryRequest::CGroupMemberQueryRequest(const char *serviceName, IRpcMessageBinding *init)
	: m_GroupName(nilRemove),m_PageSize(nilRemove),m_PageStartFrom(nilRemove),m_SortBy(nilRemove),m_Descending(0, nilRemove,false),m_CacheHint(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GroupMemberQueryRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CGroupMemberQueryRequest::CGroupMemberQueryRequest(const char *serviceName, const char *bc)
	: m_GroupName(nilRemove),m_PageSize(nilRemove),m_PageStartFrom(nilRemove),m_SortBy(nilRemove),m_Descending(0, nilRemove,false),m_CacheHint(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GroupMemberQueryRequest");
}

CGroupMemberQueryRequest::CGroupMemberQueryRequest(const char *serviceName, IRpcMessage* rpcmsg)
	: m_GroupName(nilRemove),m_PageSize(nilRemove),m_PageStartFrom(nilRemove),m_SortBy(nilRemove),m_Descending(0, nilRemove,false),m_CacheHint(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GroupMemberQueryRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CGroupMemberQueryRequest::CGroupMemberQueryRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_GroupName(nilRemove),m_PageSize(nilRemove),m_PageStartFrom(nilRemove),m_SortBy(nilRemove),m_Descending(0, nilRemove,false),m_CacheHint(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GroupMemberQueryRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CGroupMemberQueryRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"GroupName\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"PageSize\" type=\"xsd:unsignedInt\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"PageStartFrom\" type=\"xsd:long\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"SortBy\" type=\"tns:UserSortBy\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" default=\"false\" name=\"Descending\" type=\"xsd:boolean\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"CacheHint\" type=\"xsd:long\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	if (!(flags & 0x10)  || (flags & 0x100))
	{
		CXUserSortBy::getXsdDefinition(context, request, schema, added);
	}
	return schema;
}

void CGroupMemberQueryRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CGroupMemberQueryRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
	if (!added.getValue("UserSortBy"))
	{
		added.setValue("UserSortBy",1);
		CXUserSortBy::getMapInfo(info,added);
	}
}

StringBuffer &CGroupMemberQueryRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("GroupName");
	form.appendf("  <tr><td><b>GroupName: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix) extfix.append(prefix).append(".");
		extfix.append("PageSize");
	form.appendf("  <tr><td><b>PageSize: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("PageStartFrom");
	form.appendf("  <tr><td><b>PageStartFrom: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("SortBy");
	form.appendf("  <tr><td><b>SortBy: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Descending");
	
	form.appendf("  <tr><td><b>Descending? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("CacheHint");
	form.appendf("  <tr><td><b>CacheHint: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CGroupMemberQueryRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CGroupMemberQueryRequest::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_GroupName.marshall(rpc_resp, "GroupName", "", "", "");
	m_PageSize.marshall(rpc_resp, "PageSize", "", "", "");
	m_PageStartFrom.marshall(rpc_resp, "PageStartFrom", "", "", "");
	m_SortBy.marshall(rpc_resp, "SortBy", "", "", "");
	m_Descending.marshall(rpc_resp, "Descending", "", "", "");
	m_CacheHint.marshall(rpc_resp, "CacheHint", "", "", "");
}


void CGroupMemberQueryRequest::copy(CGroupMemberQueryRequest &from)
{
	m_GroupName.copy(from.m_GroupName);
	m_PageSize.copy(from.m_PageSize);
	m_PageStartFrom.copy(from.m_PageStartFrom);
	m_SortBy.copy(from.m_SortBy);
	m_Descending.copy(from.m_Descending);
	m_CacheHint.copy(from.m_CacheHint);
}


void CGroupMemberQueryRequest::copy(IConstGroupMemberQueryRequest &ifrom)
{
	setGroupName(ifrom.getGroupName());
	setPageSize(ifrom.getPageSize());
	setPageStartFrom(ifrom.getPageStartFrom());
	setSortBy(ifrom.getSortBy());
	setDescending(ifrom.getDescending());
	setCacheHint(ifrom.getCacheHint());
}


void CGroupMemberQueryRequest::getAttributes(IProperties &attributes)
{
}


void CGroupMemberQueryRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_GroupName.toStr(ctx, buffer, "GroupName", "", true, "", "");
	m_PageSize.toStr(ctx, buffer, "PageSize", "", true, "", "");
	m_PageStartFrom.toStr(ctx, buffer, "PageStartFrom", "", true, "", "");
	m_SortBy.toStr(ctx, buffer, "SortBy", "", true, "", "");
	m_Descending.toStr(ctx, buffer, "Descending", "", true, "", "");
	m_CacheHint.toStr(ctx, buffer, "CacheHint", "", true, "", "");
}


void CGroupMemberQueryRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CGroupMemberQueryRequest::serializer(IEspContext* ctx, IConstGroupMemberQueryRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<GroupMemberQueryRequest>");
	// field GroupName
	{
		const char* s = src.getGroupName();
		if (s && *s)
		{
			buffer.append("<GroupName>");
			encodeUtf8XML(s,buffer);
			buffer.append("</GroupName>");
		}
	}
	// field PageSize
	{
		//*** default kind: TK_UNSIGNED; type=(null), name=PageSize
		buffer.append("<PageSize>");
		buffer.append(src.getPageSize());
		buffer.append("</PageSize>");
	}
	// field PageStartFrom
	{
		//*** default kind: TK_INT; type=int64, name=PageStartFrom
		buffer.append("<PageStartFrom>");
		buffer.append(src.getPageStartFrom());
		buffer.append("</PageStartFrom>");
	}
	// field SortBy
	{
		const char* s = src.getSortByAsString();
		buffer.append("<SortBy>");
		encodeUtf8XML(s,buffer);
		buffer.append("</SortBy>");
	}
	// field Descending
	{
		bool b = src.getDescending();
		if (b)
			buffer.appendf("<Descending>1</Descending>");
	}
	// field CacheHint
	{
		//*** default kind: TK_INT; type=int64, name=CacheHint
		buffer.append("<CacheHint>");
		buffer.append(src.getCacheHint());
		buffer.append("</CacheHint>");
	}
	if (keepRootTag)
		buffer.append("</GroupMemberQueryRequest>");
}

bool CGroupMemberQueryRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_GroupName.unmarshall(rpc_request, "GroupName", basepath);
	hasValue |= m_PageSize.unmarshall(rpc_request, "PageSize", basepath);
	hasValue |= m_PageStartFrom.unmarshall(rpc_request, "PageStartFrom", basepath);
	hasValue |= m_SortBy.unmarshall(rpc_request, "SortBy", basepath);
	hasValue |= m_Descending.unmarshall(rpc_request, "Descending", basepath);
	hasValue |= m_CacheHint.unmarshall(rpc_request, "CacheHint", basepath);
	return hasValue;
}

bool CGroupMemberQueryRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_GroupName.unmarshall(ctx, soapval, "GroupName");
	hasValue |= m_PageSize.unmarshall(ctx, soapval, "PageSize");
	hasValue |= m_PageStartFrom.unmarshall(ctx, soapval, "PageStartFrom");
	hasValue |= m_SortBy.unmarshall(ctx, soapval, "SortBy");
	hasValue |= m_Descending.unmarshall(ctx, soapval, "Descending");
	hasValue |= m_CacheHint.unmarshall(ctx, soapval, "CacheHint");
	return hasValue;
}

bool CGroupMemberQueryRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_GroupName.unmarshall(ctx, params, attachments, "GroupName", basepath);
	hasValue |= m_PageSize.unmarshall(ctx, params, attachments, "PageSize", basepath);
	hasValue |= m_PageStartFrom.unmarshall(ctx, params, attachments, "PageStartFrom", basepath);
	hasValue |= m_SortBy.unmarshall(ctx, params, attachments, "SortBy", basepath);
	hasValue |= m_Descending.unmarshall(ctx, params, attachments, "Descending", basepath);
	hasValue |= m_CacheHint.unmarshall(ctx, params, attachments, "CacheHint", basepath);
	return hasValue;
}

const char * CGroupMemberQueryRequest::getGroupName() { return m_GroupName.query();}
bool CGroupMemberQueryRequest::getPageSize_isNull(){return m_PageSize.is_nil();}
unsigned int CGroupMemberQueryRequest::getPageSize() { return m_PageSize;}
bool CGroupMemberQueryRequest::getPageStartFrom_isNull(){return m_PageStartFrom.is_nil();}
__int64 CGroupMemberQueryRequest::getPageStartFrom() { return m_PageStartFrom;}
CUserSortBy CGroupMemberQueryRequest::getSortBy() { return m_SortBy.getValue(); }
const char* CGroupMemberQueryRequest::getSortByAsString() {  return (const char*)m_SortBy; }
bool CGroupMemberQueryRequest::getDescending_isNull(){return m_Descending.is_nil();}
bool CGroupMemberQueryRequest::getDescending() { return m_Descending;}
bool CGroupMemberQueryRequest::getCacheHint_isNull(){return m_CacheHint.is_nil();}
__int64 CGroupMemberQueryRequest::getCacheHint() { return m_CacheHint;}
void CGroupMemberQueryRequest::setGroupName(const char * val){ m_GroupName.set(val); }
void CGroupMemberQueryRequest::setPageSize_null(){ m_PageSize.Nil(); }void CGroupMemberQueryRequest::setPageSize(unsigned int val){ m_PageSize=val; }
void CGroupMemberQueryRequest::setPageStartFrom_null(){ m_PageStartFrom.Nil(); }void CGroupMemberQueryRequest::setPageStartFrom(__int64 val){ m_PageStartFrom=val; }
void CGroupMemberQueryRequest::setSortBy(CUserSortBy val) { m_SortBy.setValue(val); }
void CGroupMemberQueryRequest::setSortBy(const char* val) { m_SortBy.setValue(val); }
void CGroupMemberQueryRequest::setDescending_null(){ m_Descending.Nil(); }void CGroupMemberQueryRequest::setDescending(bool val){ m_Descending=val; }
void CGroupMemberQueryRequest::setCacheHint_null(){ m_CacheHint.Nil(); }void CGroupMemberQueryRequest::setCacheHint(__int64 val){ m_CacheHint=val; }
extern "C"  IEspGroupMemberQueryRequest *createGroupMemberQueryRequest(const char *serv){return ((IEspGroupMemberQueryRequest *)new CGroupMemberQueryRequest(serv));}
extern "C"  IClientGroupMemberQueryRequest *createClientGroupMemberQueryRequest(const char *serv){return ((IClientGroupMemberQueryRequest *)new CGroupMemberQueryRequest(serv));}

//=======================================================
// class CGroupMemberQueryResponse Implementation
//=======================================================

CGroupMemberQueryResponse::CGroupMemberQueryResponse(const char *serviceName, IRpcMessageBinding *init)
	: m_NoSecMngr(0, nilRemove,false),m_Users(nilRemove),m_TotalUsers(nilRemove),m_CacheHint(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GroupMemberQueryResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CGroupMemberQueryResponse::CGroupMemberQueryResponse(const char *serviceName, const char *bc)
	: m_NoSecMngr(0, nilRemove,false),m_Users(nilRemove),m_TotalUsers(nilRemove),m_CacheHint(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GroupMemberQueryResponse");
}

CGroupMemberQueryResponse::CGroupMemberQueryResponse(const char *serviceName, IRpcMessage* rpcmsg)
	: m_NoSecMngr(0, nilRemove,false),m_Users(nilRemove),m_TotalUsers(nilRemove),m_CacheHint(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GroupMemberQueryResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CGroupMemberQueryResponse::CGroupMemberQueryResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_NoSecMngr(0, nilRemove,false),m_Users(nilRemove),m_TotalUsers(nilRemove),m_CacheHint(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GroupMemberQueryResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CGroupMemberQueryResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" default=\"false\" name=\"NoSecMngr\" type=\"xsd:boolean\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Users\">\n");
		schema.append("<xsd:complexType><xsd:sequence>\n");
		schema.append("<xsd:element minOccurs=\"0\" maxOccurs=\"unbounded\" name=\"User\" type=\"tns:UserInfo\"/>");
		schema.append("</xsd:sequence></xsd:complexType>");
		schema.append("</xsd:element>");
		schema.append("<xsd:element minOccurs=\"0\" name=\"TotalUsers\" type=\"xsd:long\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"CacheHint\" type=\"xsd:long\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	if (!(flags & 0x10)  || (flags & 0x100))
	{
		CUserInfo::getXsdDefinition(context, request, schema, added);
	}
	return schema;
}

void CGroupMemberQueryResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CGroupMemberQueryResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
	if (!added.getValue("UserInfo"))
	{
		added.setValue("UserInfo",1);
		CUserInfo::getMapInfo(info,added);
	}
}

StringBuffer &CGroupMemberQueryResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("NoSecMngr");
	
	form.appendf("  <tr><td><b>NoSecMngr? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Users");
	form.appendf("<tr><td><b>Users: </b></td><td>");
	form.appendf("<table><tr><td><textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea></td>", extfix.str());
	form.append("</tr></table>");
	form.append("</td></tr>");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("TotalUsers");
	form.appendf("  <tr><td><b>TotalUsers: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("CacheHint");
	form.appendf("  <tr><td><b>CacheHint: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CGroupMemberQueryResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CGroupMemberQueryResponse::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
		m_NoSecMngr.marshall(rpc_resp, "NoSecMngr", "", "", "");
		m_Users.marshall(rpc_resp, "Users", "User");
		m_TotalUsers.marshall(rpc_resp, "TotalUsers", "", "", "");
		m_CacheHint.marshall(rpc_resp, "CacheHint", "", "", "");
	}
}


void CGroupMemberQueryResponse::copy(CGroupMemberQueryResponse &from)
{
	m_NoSecMngr.copy(from.m_NoSecMngr);
	m_Users.copy(from.m_Users);
	m_TotalUsers.copy(from.m_TotalUsers);
	m_CacheHint.copy(from.m_CacheHint);
}


void CGroupMemberQueryResponse::copy(IConstGroupMemberQueryResponse &ifrom)
{
	setNoSecMngr(ifrom.getNoSecMngr());
	setUsers(ifrom.getUsers());
	setTotalUsers(ifrom.getTotalUsers());
	setCacheHint(ifrom.getCacheHint());
}


void CGroupMemberQueryResponse::getAttributes(IProperties &attributes)
{
}


void CGroupMemberQueryResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
		m_NoSecMngr.toStr(ctx, buffer, "NoSecMngr", "", true, "", "");
		m_Users.toStr(ctx, buffer, "Users", "User");
		m_TotalUsers.toStr(ctx, buffer, "TotalUsers", "", true, "", "");
		m_CacheHint.toStr(ctx, buffer, "CacheHint", "", true, "", "");
	}
}


void CGroupMemberQueryResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CGroupMemberQueryResponse::serializer(IEspContext* ctx, IConstGroupMemberQueryResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<GroupMemberQueryResponse>");
	// field NoSecMngr
	{
		bool b = src.getNoSecMngr();
		if (b)
			buffer.appendf("<NoSecMngr>1</NoSecMngr>");
	}
	// field Users
	{
		IArrayOf<IConstUserInfo>& v = src.getUsers();
		int size = v.length();
		if (size>0)
			buffer.append("<Users>");
		for (int i=0;i<size;i++)
		{
			buffer.append("<User>");
			CUserInfo::serializer(ctx,v.item(i),buffer,false);
			buffer.append("</User>");
		}
		if (size>0)
			buffer.append("</Users>");
	}
	// field TotalUsers
	{
		//*** default kind: TK_INT; type=int64, name=TotalUsers
		buffer.append("<TotalUsers>");
		buffer.append(src.getTotalUsers());
		buffer.append("</TotalUsers>");
	}
	// field CacheHint
	{
		//*** default kind: TK_INT; type=int64, name=CacheHint
		buffer.append("<CacheHint>");
		buffer.append(src.getCacheHint());
		buffer.append("</CacheHint>");
	}
	if (keepRootTag)
		buffer.append("</GroupMemberQueryResponse>");
}

bool CGroupMemberQueryResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
		hasValue |= m_NoSecMngr.unmarshall(rpc_request, "NoSecMngr", basepath);
		hasValue |= m_Users.unmarshall(rpc_request, "Users", basepath);
		hasValue |= m_TotalUsers.unmarshall(rpc_request, "TotalUsers", basepath);
		hasValue |= m_CacheHint.unmarshall(rpc_request, "CacheHint", basepath);
	}
	return hasValue;
}

bool CGroupMemberQueryResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_NoSecMngr.unmarshall(ctx, soapval, "NoSecMngr");
	hasValue |= m_Users.unmarshall(ctx, soapval, "Users");
	hasValue |= m_TotalUsers.unmarshall(ctx, soapval, "TotalUsers");
	hasValue |= m_CacheHint.unmarshall(ctx, soapval, "CacheHint");
	return hasValue;
}

bool CGroupMemberQueryResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_NoSecMngr.unmarshall(ctx, params, attachments, "NoSecMngr", basepath);
	hasValue |= m_Users.unmarshall(ctx, params, attachments, "Users", basepath);
	hasValue |= m_TotalUsers.unmarshall(ctx, params, attachments, "TotalUsers", basepath);
	hasValue |= m_CacheHint.unmarshall(ctx, params, attachments, "CacheHint", basepath);
	return hasValue;
}

bool CGroupMemberQueryResponse::getNoSecMngr_isNull(){return m_NoSecMngr.is_nil();}
bool CGroupMemberQueryResponse::getNoSecMngr() { return m_NoSecMngr;}
IArrayOf<IConstUserInfo> & CGroupMemberQueryResponse::getUsers() { return (IArrayOf<IConstUserInfo> &) m_Users; }
bool CGroupMemberQueryResponse::getTotalUsers_isNull(){return m_TotalUsers.is_nil();}
__int64 CGroupMemberQueryResponse::getTotalUsers() { return m_TotalUsers;}
bool CGroupMemberQueryResponse::getCacheHint_isNull(){return m_CacheHint.is_nil();}
__int64 CGroupMemberQueryResponse::getCacheHint() { return m_CacheHint;}
void CGroupMemberQueryResponse::setNoSecMngr_null(){ m_NoSecMngr.Nil(); }void CGroupMemberQueryResponse::setNoSecMngr(bool val){ m_NoSecMngr=val; }
void CGroupMemberQueryResponse::setUsers(IArrayOf<IEspUserInfo> &val)
{
	m_Users->kill();
	IArrayOf<IConstUserInfo> &target = m_Users.getValue();
	ForEachItemIn(idx, val)
	{
		IEspUserInfo &item = (val).item(idx);
		item.Link();
		target.append(item);
	}
}
void CGroupMemberQueryResponse::setUsers(IArrayOf<IConstUserInfo> &val)
{
	m_Users->kill();
	IArrayOf<IConstUserInfo> &target = m_Users.getValue();
	ForEachItemIn(idx, val)
	{
		IConstUserInfo &item = val.item(idx);
		item.Link();
		target.append(item);
	}
}
void CGroupMemberQueryResponse::setTotalUsers_null(){ m_TotalUsers.Nil(); }void CGroupMemberQueryResponse::setTotalUsers(__int64 val){ m_TotalUsers=val; }
void CGroupMemberQueryResponse::setCacheHint_null(){ m_CacheHint.Nil(); }void CGroupMemberQueryResponse::setCacheHint(__int64 val){ m_CacheHint=val; }
extern "C"  IEspGroupMemberQueryResponse *createGroupMemberQueryResponse(const char *serv){return ((IEspGroupMemberQueryResponse *)new CGroupMemberQueryResponse(serv));}
extern "C"  IClientGroupMemberQueryResponse *createClientGroupMemberQueryResponse(const char *serv){return ((IClientGroupMemberQueryResponse *)new CGroupMemberQueryResponse(serv));}

//=======================================================
// class CGroupMemberEditInputRequest Implementation
//=======================================================

CGroupMemberEditInputRequest::CGroupMemberEditInputRequest(const char *serviceName, IRpcMessageBinding *init)
	: m_searchinput(nilIgnore),m_groupname(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GroupMemberEditInputRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CGroupMemberEditInputRequest::CGroupMemberEditInputRequest(const char *serviceName, const char *bc)
	: m_searchinput(nilIgnore),m_groupname(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GroupMemberEditInputRequest");
}

CGroupMemberEditInputRequest::CGroupMemberEditInputRequest(const char *serviceName, IRpcMessage* rpcmsg)
	: m_searchinput(nilIgnore),m_groupname(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GroupMemberEditInputRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CGroupMemberEditInputRequest::CGroupMemberEditInputRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_searchinput(nilIgnore),m_groupname(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GroupMemberEditInputRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CGroupMemberEditInputRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"searchinput\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"groupname\" type=\"xsd:string\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CGroupMemberEditInputRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CGroupMemberEditInputRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CGroupMemberEditInputRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("searchinput");
	form.appendf("  <tr><td><b>searchinput: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("groupname");
	form.appendf("  <tr><td><b>groupname: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CGroupMemberEditInputRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CGroupMemberEditInputRequest::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_searchinput.marshall(rpc_resp, "searchinput", "", "", "");
	m_groupname.marshall(rpc_resp, "groupname", "", "", "");
}


void CGroupMemberEditInputRequest::copy(CGroupMemberEditInputRequest &from)
{
	m_searchinput.copy(from.m_searchinput);
	m_groupname.copy(from.m_groupname);
}


void CGroupMemberEditInputRequest::copy(IConstGroupMemberEditInputRequest &ifrom)
{
	setSearchinput(ifrom.getSearchinput());
	setGroupname(ifrom.getGroupname());
}


void CGroupMemberEditInputRequest::getAttributes(IProperties &attributes)
{
}


void CGroupMemberEditInputRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_searchinput.toStr(ctx, buffer, "searchinput", "", true, "", "");
	m_groupname.toStr(ctx, buffer, "groupname", "", true, "", "");
}


void CGroupMemberEditInputRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CGroupMemberEditInputRequest::serializer(IEspContext* ctx, IConstGroupMemberEditInputRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<GroupMemberEditInputRequest>");
	// field searchinput
	{
		const char* s = src.getSearchinput();
		if (s && *s)
		{
			buffer.append("<searchinput>");
			encodeUtf8XML(s,buffer);
			buffer.append("</searchinput>");
		}
	}
	// field groupname
	{
		const char* s = src.getGroupname();
		if (s && *s)
		{
			buffer.append("<groupname>");
			encodeUtf8XML(s,buffer);
			buffer.append("</groupname>");
		}
	}
	if (keepRootTag)
		buffer.append("</GroupMemberEditInputRequest>");
}

bool CGroupMemberEditInputRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_searchinput.unmarshall(rpc_request, "searchinput", basepath);
	hasValue |= m_groupname.unmarshall(rpc_request, "groupname", basepath);
	return hasValue;
}

bool CGroupMemberEditInputRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_searchinput.unmarshall(ctx, soapval, "searchinput");
	hasValue |= m_groupname.unmarshall(ctx, soapval, "groupname");
	return hasValue;
}

bool CGroupMemberEditInputRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_searchinput.unmarshall(ctx, params, attachments, "searchinput", basepath);
	hasValue |= m_groupname.unmarshall(ctx, params, attachments, "groupname", basepath);
	return hasValue;
}

const char * CGroupMemberEditInputRequest::getSearchinput() { return m_searchinput.query();}
const char * CGroupMemberEditInputRequest::getGroupname() { return m_groupname.query();}
void CGroupMemberEditInputRequest::setSearchinput(const char * val){ m_searchinput.set(val); }
void CGroupMemberEditInputRequest::setGroupname(const char * val){ m_groupname.set(val); }
extern "C"  IEspGroupMemberEditInputRequest *createGroupMemberEditInputRequest(const char *serv){return ((IEspGroupMemberEditInputRequest *)new CGroupMemberEditInputRequest(serv));}
extern "C"  IClientGroupMemberEditInputRequest *createClientGroupMemberEditInputRequest(const char *serv){return ((IClientGroupMemberEditInputRequest *)new CGroupMemberEditInputRequest(serv));}

//=======================================================
// class CGroupMemberEditInputResponse Implementation
//=======================================================

CGroupMemberEditInputResponse::CGroupMemberEditInputResponse(const char *serviceName, IRpcMessageBinding *init)
	: m_groupname(nilIgnore),m_toomany(nilIgnore),m_Users(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GroupMemberEditInputResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CGroupMemberEditInputResponse::CGroupMemberEditInputResponse(const char *serviceName, const char *bc)
	: m_groupname(nilIgnore),m_toomany(nilIgnore),m_Users(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GroupMemberEditInputResponse");
}

CGroupMemberEditInputResponse::CGroupMemberEditInputResponse(const char *serviceName, IRpcMessage* rpcmsg)
	: m_groupname(nilIgnore),m_toomany(nilIgnore),m_Users(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GroupMemberEditInputResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CGroupMemberEditInputResponse::CGroupMemberEditInputResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_groupname(nilIgnore),m_toomany(nilIgnore),m_Users(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GroupMemberEditInputResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CGroupMemberEditInputResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"groupname\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"toomany\" type=\"xsd:boolean\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Users\">\n");
		schema.append("<xsd:complexType><xsd:sequence>\n");
		schema.append("<xsd:element minOccurs=\"0\" maxOccurs=\"unbounded\" name=\"User\" type=\"tns:UserInfo\"/>");
		schema.append("</xsd:sequence></xsd:complexType>");
		schema.append("</xsd:element>");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	if (!(flags & 0x10)  || (flags & 0x100))
	{
		CUserInfo::getXsdDefinition(context, request, schema, added);
	}
	return schema;
}

void CGroupMemberEditInputResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CGroupMemberEditInputResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
	if (!added.getValue("UserInfo"))
	{
		added.setValue("UserInfo",1);
		CUserInfo::getMapInfo(info,added);
	}
}

StringBuffer &CGroupMemberEditInputResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("groupname");
	form.appendf("  <tr><td><b>groupname: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("toomany");
	
	form.appendf("  <tr><td><b>toomany? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Users");
	form.appendf("<tr><td><b>Users: </b></td><td>");
	form.appendf("<table><tr><td><textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea></td>", extfix.str());
	form.append("</tr></table>");
	form.append("</td></tr>");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CGroupMemberEditInputResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CGroupMemberEditInputResponse::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
		m_groupname.marshall(rpc_resp, "groupname", "", "", "");
		m_toomany.marshall(rpc_resp, "toomany", "", "", "");
		m_Users.marshall(rpc_resp, "Users", "User");
	}
}


void CGroupMemberEditInputResponse::copy(CGroupMemberEditInputResponse &from)
{
	m_groupname.copy(from.m_groupname);
	m_toomany.copy(from.m_toomany);
	m_Users.copy(from.m_Users);
}


void CGroupMemberEditInputResponse::copy(IConstGroupMemberEditInputResponse &ifrom)
{
	setGroupname(ifrom.getGroupname());
	setToomany(ifrom.getToomany());
	setUsers(ifrom.getUsers());
}


void CGroupMemberEditInputResponse::getAttributes(IProperties &attributes)
{
}


void CGroupMemberEditInputResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
		m_groupname.toStr(ctx, buffer, "groupname", "", true, "", "");
		m_toomany.toStr(ctx, buffer, "toomany", "", true, "", "");
		m_Users.toStr(ctx, buffer, "Users", "User");
	}
}


void CGroupMemberEditInputResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CGroupMemberEditInputResponse::serializer(IEspContext* ctx, IConstGroupMemberEditInputResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<GroupMemberEditInputResponse>");
	// field groupname
	{
		const char* s = src.getGroupname();
		if (s && *s)
		{
			buffer.append("<groupname>");
			encodeUtf8XML(s,buffer);
			buffer.append("</groupname>");
		}
	}
	// field toomany
	{
		bool b = src.getToomany();
		if (b)
			buffer.appendf("<toomany>1</toomany>");
	}
	// field Users
	{
		IArrayOf<IConstUserInfo>& v = src.getUsers();
		int size = v.length();
		if (size>0)
			buffer.append("<Users>");
		for (int i=0;i<size;i++)
		{
			buffer.append("<User>");
			CUserInfo::serializer(ctx,v.item(i),buffer,false);
			buffer.append("</User>");
		}
		if (size>0)
			buffer.append("</Users>");
	}
	if (keepRootTag)
		buffer.append("</GroupMemberEditInputResponse>");
}

bool CGroupMemberEditInputResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
		hasValue |= m_groupname.unmarshall(rpc_request, "groupname", basepath);
		hasValue |= m_toomany.unmarshall(rpc_request, "toomany", basepath);
		hasValue |= m_Users.unmarshall(rpc_request, "Users", basepath);
	}
	return hasValue;
}

bool CGroupMemberEditInputResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_groupname.unmarshall(ctx, soapval, "groupname");
	hasValue |= m_toomany.unmarshall(ctx, soapval, "toomany");
	hasValue |= m_Users.unmarshall(ctx, soapval, "Users");
	return hasValue;
}

bool CGroupMemberEditInputResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_groupname.unmarshall(ctx, params, attachments, "groupname", basepath);
	hasValue |= m_toomany.unmarshall(ctx, params, attachments, "toomany", basepath);
	hasValue |= m_Users.unmarshall(ctx, params, attachments, "Users", basepath);
	return hasValue;
}

const char * CGroupMemberEditInputResponse::getGroupname() { return m_groupname.query();}
bool CGroupMemberEditInputResponse::getToomany() { return m_toomany;}
IArrayOf<IConstUserInfo> & CGroupMemberEditInputResponse::getUsers() { return (IArrayOf<IConstUserInfo> &) m_Users; }
void CGroupMemberEditInputResponse::setGroupname(const char * val){ m_groupname.set(val); }
void CGroupMemberEditInputResponse::setToomany(bool val){ m_toomany=val; }
void CGroupMemberEditInputResponse::setUsers(IArrayOf<IEspUserInfo> &val)
{
	m_Users->kill();
	IArrayOf<IConstUserInfo> &target = m_Users.getValue();
	ForEachItemIn(idx, val)
	{
		IEspUserInfo &item = (val).item(idx);
		item.Link();
		target.append(item);
	}
}
void CGroupMemberEditInputResponse::setUsers(IArrayOf<IConstUserInfo> &val)
{
	m_Users->kill();
	IArrayOf<IConstUserInfo> &target = m_Users.getValue();
	ForEachItemIn(idx, val)
	{
		IConstUserInfo &item = val.item(idx);
		item.Link();
		target.append(item);
	}
}
extern "C"  IEspGroupMemberEditInputResponse *createGroupMemberEditInputResponse(const char *serv){return ((IEspGroupMemberEditInputResponse *)new CGroupMemberEditInputResponse(serv));}
extern "C"  IClientGroupMemberEditInputResponse *createClientGroupMemberEditInputResponse(const char *serv){return ((IClientGroupMemberEditInputResponse *)new CGroupMemberEditInputResponse(serv));}

//=======================================================
// class CGroupMemberEditRequest Implementation
//=======================================================

CGroupMemberEditRequest::CGroupMemberEditRequest(const char *serviceName, IRpcMessageBinding *init)
	: m_groupname(nilIgnore),m_action(nilIgnore),m_usernames(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GroupMemberEditRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CGroupMemberEditRequest::CGroupMemberEditRequest(const char *serviceName, const char *bc)
	: m_groupname(nilIgnore),m_action(nilIgnore),m_usernames(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GroupMemberEditRequest");
}

CGroupMemberEditRequest::CGroupMemberEditRequest(const char *serviceName, IRpcMessage* rpcmsg)
	: m_groupname(nilIgnore),m_action(nilIgnore),m_usernames(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GroupMemberEditRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CGroupMemberEditRequest::CGroupMemberEditRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_groupname(nilIgnore),m_action(nilIgnore),m_usernames(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GroupMemberEditRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CGroupMemberEditRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"groupname\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"action\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"usernames\" type=\"tns:EspStringArray\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	if (added.getValue("EspStringArray")==NULL) {
		addEspNativeArray(schema,"string","EspStringArray");
		added.setValue("EspStringArray",1);
	}
	return schema;
}

void CGroupMemberEditRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CGroupMemberEditRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CGroupMemberEditRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("groupname");
	form.appendf("  <tr><td><b>groupname: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("action");
	form.appendf("  <tr><td><b>action: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("usernames");
	form.appendf("<tr><td><b>usernames: </b></td><td>");
	form.appendf("<textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea>", extfix.str());
	form.append("</td></tr>");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CGroupMemberEditRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CGroupMemberEditRequest::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_groupname.marshall(rpc_resp, "groupname", "", "", "");
	m_action.marshall(rpc_resp, "action", "", "", "");
	m_usernames.marshall(rpc_resp, "usernames", "Item");
}


void CGroupMemberEditRequest::copy(CGroupMemberEditRequest &from)
{
	m_groupname.copy(from.m_groupname);
	m_action.copy(from.m_action);
	m_usernames.copy(from.m_usernames);
}


void CGroupMemberEditRequest::copy(IConstGroupMemberEditRequest &ifrom)
{
	setGroupname(ifrom.getGroupname());
	setAction(ifrom.getAction());
	setUsernames(ifrom.getUsernames());
}


void CGroupMemberEditRequest::getAttributes(IProperties &attributes)
{
}


void CGroupMemberEditRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_groupname.toStr(ctx, buffer, "groupname", "", true, "", "");
	m_action.toStr(ctx, buffer, "action", "", true, "", "");
	m_usernames.toStr(ctx, buffer, "usernames", "Item");
}


void CGroupMemberEditRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CGroupMemberEditRequest::serializer(IEspContext* ctx, IConstGroupMemberEditRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<GroupMemberEditRequest>");
	// field groupname
	{
		const char* s = src.getGroupname();
		if (s && *s)
		{
			buffer.append("<groupname>");
			encodeUtf8XML(s,buffer);
			buffer.append("</groupname>");
		}
	}
	// field action
	{
		const char* s = src.getAction();
		if (s && *s)
		{
			buffer.append("<action>");
			encodeUtf8XML(s,buffer);
			buffer.append("</action>");
		}
	}
	// field usernames
	{
		StringArray& v = src.getUsernames();
		if (v.length()>0)
			buffer.append("<usernames>");
		for (size32_t i=0;i<v.length();i++)
			buffer.appendf("<Item>%s</Item>",v.item(i));
		if (v.length()>0)
			buffer.append("</usernames>");
	}
	if (keepRootTag)
		buffer.append("</GroupMemberEditRequest>");
}

bool CGroupMemberEditRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_groupname.unmarshall(rpc_request, "groupname", basepath);
	hasValue |= m_action.unmarshall(rpc_request, "action", basepath);
	hasValue |= m_usernames.unmarshall(rpc_request, "usernames", basepath);
	return hasValue;
}

bool CGroupMemberEditRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_groupname.unmarshall(ctx, soapval, "groupname");
	hasValue |= m_action.unmarshall(ctx, soapval, "action");
	hasValue |= m_usernames.unmarshall(ctx, soapval, "usernames");
	return hasValue;
}

bool CGroupMemberEditRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_groupname.unmarshall(ctx, params, attachments, "groupname", basepath);
	hasValue |= m_action.unmarshall(ctx, params, attachments, "action", basepath);
	hasValue |= m_usernames.unmarshall(ctx, params, attachments, "usernames", basepath);
	return hasValue;
}

const char * CGroupMemberEditRequest::getGroupname() { return m_groupname.query();}
const char * CGroupMemberEditRequest::getAction() { return m_action.query();}
StringArray & CGroupMemberEditRequest::getUsernames() { return (StringArray &) m_usernames; }
void CGroupMemberEditRequest::setGroupname(const char * val){ m_groupname.set(val); }
void CGroupMemberEditRequest::setAction(const char * val){ m_action.set(val); }
void CGroupMemberEditRequest::setUsernames(StringArray &val){ m_usernames->kill();  CloneArray(m_usernames.getValue(), val); }
extern "C"  IEspGroupMemberEditRequest *createGroupMemberEditRequest(const char *serv){return ((IEspGroupMemberEditRequest *)new CGroupMemberEditRequest(serv));}
extern "C"  IClientGroupMemberEditRequest *createClientGroupMemberEditRequest(const char *serv){return ((IClientGroupMemberEditRequest *)new CGroupMemberEditRequest(serv));}

//=======================================================
// class CGroupMemberEditResponse Implementation
//=======================================================

CGroupMemberEditResponse::CGroupMemberEditResponse(const char *serviceName, IRpcMessageBinding *init)
	: m_groupname(nilIgnore),m_action(nilIgnore),m_retcode(nilIgnore),m_retmsg(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GroupMemberEditResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CGroupMemberEditResponse::CGroupMemberEditResponse(const char *serviceName, const char *bc)
	: m_groupname(nilIgnore),m_action(nilIgnore),m_retcode(nilIgnore),m_retmsg(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GroupMemberEditResponse");
}

CGroupMemberEditResponse::CGroupMemberEditResponse(const char *serviceName, IRpcMessage* rpcmsg)
	: m_groupname(nilIgnore),m_action(nilIgnore),m_retcode(nilIgnore),m_retmsg(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GroupMemberEditResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CGroupMemberEditResponse::CGroupMemberEditResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_groupname(nilIgnore),m_action(nilIgnore),m_retcode(nilIgnore),m_retmsg(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GroupMemberEditResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CGroupMemberEditResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"groupname\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"action\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"retcode\" type=\"xsd:int\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"retmsg\" type=\"xsd:string\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CGroupMemberEditResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CGroupMemberEditResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CGroupMemberEditResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("groupname");
	form.appendf("  <tr><td><b>groupname: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("action");
	form.appendf("  <tr><td><b>action: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix) extfix.append(prefix).append(".");
		extfix.append("retcode");
	form.appendf("  <tr><td><b>retcode: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("retmsg");
	form.appendf("  <tr><td><b>retmsg: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CGroupMemberEditResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CGroupMemberEditResponse::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
		m_groupname.marshall(rpc_resp, "groupname", "", "", "");
		m_action.marshall(rpc_resp, "action", "", "", "");
		m_retcode.marshall(rpc_resp, "retcode", "", "", "");
		m_retmsg.marshall(rpc_resp, "retmsg", "", "", "");
	}
}


void CGroupMemberEditResponse::copy(CGroupMemberEditResponse &from)
{
	m_groupname.copy(from.m_groupname);
	m_action.copy(from.m_action);
	m_retcode.copy(from.m_retcode);
	m_retmsg.copy(from.m_retmsg);
}


void CGroupMemberEditResponse::copy(IConstGroupMemberEditResponse &ifrom)
{
	setGroupname(ifrom.getGroupname());
	setAction(ifrom.getAction());
	setRetcode(ifrom.getRetcode());
	setRetmsg(ifrom.getRetmsg());
}


void CGroupMemberEditResponse::getAttributes(IProperties &attributes)
{
}


void CGroupMemberEditResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
		m_groupname.toStr(ctx, buffer, "groupname", "", true, "", "");
		m_action.toStr(ctx, buffer, "action", "", true, "", "");
		m_retcode.toStr(ctx, buffer, "retcode", "", true, "", "");
		m_retmsg.toStr(ctx, buffer, "retmsg", "", true, "", "");
	}
}


void CGroupMemberEditResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CGroupMemberEditResponse::serializer(IEspContext* ctx, IConstGroupMemberEditResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<GroupMemberEditResponse>");
	// field groupname
	{
		const char* s = src.getGroupname();
		if (s && *s)
		{
			buffer.append("<groupname>");
			encodeUtf8XML(s,buffer);
			buffer.append("</groupname>");
		}
	}
	// field action
	{
		const char* s = src.getAction();
		if (s && *s)
		{
			buffer.append("<action>");
			encodeUtf8XML(s,buffer);
			buffer.append("</action>");
		}
	}
	// field retcode
	{
		int n = src.getRetcode();
		if (n)
			buffer.appendf("<retcode>%d</retcode>", n);
	}
	// field retmsg
	{
		const char* s = src.getRetmsg();
		if (s && *s)
		{
			buffer.append("<retmsg>");
			encodeUtf8XML(s,buffer);
			buffer.append("</retmsg>");
		}
	}
	if (keepRootTag)
		buffer.append("</GroupMemberEditResponse>");
}

bool CGroupMemberEditResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
		hasValue |= m_groupname.unmarshall(rpc_request, "groupname", basepath);
		hasValue |= m_action.unmarshall(rpc_request, "action", basepath);
		hasValue |= m_retcode.unmarshall(rpc_request, "retcode", basepath);
		hasValue |= m_retmsg.unmarshall(rpc_request, "retmsg", basepath);
	}
	return hasValue;
}

bool CGroupMemberEditResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_groupname.unmarshall(ctx, soapval, "groupname");
	hasValue |= m_action.unmarshall(ctx, soapval, "action");
	hasValue |= m_retcode.unmarshall(ctx, soapval, "retcode");
	hasValue |= m_retmsg.unmarshall(ctx, soapval, "retmsg");
	return hasValue;
}

bool CGroupMemberEditResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_groupname.unmarshall(ctx, params, attachments, "groupname", basepath);
	hasValue |= m_action.unmarshall(ctx, params, attachments, "action", basepath);
	hasValue |= m_retcode.unmarshall(ctx, params, attachments, "retcode", basepath);
	hasValue |= m_retmsg.unmarshall(ctx, params, attachments, "retmsg", basepath);
	return hasValue;
}

const char * CGroupMemberEditResponse::getGroupname() { return m_groupname.query();}
const char * CGroupMemberEditResponse::getAction() { return m_action.query();}
int CGroupMemberEditResponse::getRetcode() { return m_retcode;}
const char * CGroupMemberEditResponse::getRetmsg() { return m_retmsg.query();}
void CGroupMemberEditResponse::setGroupname(const char * val){ m_groupname.set(val); }
void CGroupMemberEditResponse::setAction(const char * val){ m_action.set(val); }
void CGroupMemberEditResponse::setRetcode(int val){ m_retcode=val; }
void CGroupMemberEditResponse::setRetmsg(const char * val){ m_retmsg.set(val); }
extern "C"  IEspGroupMemberEditResponse *createGroupMemberEditResponse(const char *serv){return ((IEspGroupMemberEditResponse *)new CGroupMemberEditResponse(serv));}
extern "C"  IClientGroupMemberEditResponse *createClientGroupMemberEditResponse(const char *serv){return ((IClientGroupMemberEditResponse *)new CGroupMemberEditResponse(serv));}

//=======================================================
// class CBasednsRequest Implementation
//=======================================================

CBasednsRequest::CBasednsRequest(const char *serviceName, IRpcMessageBinding *init)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("BasednsRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CBasednsRequest::CBasednsRequest(const char *serviceName, const char *bc)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("BasednsRequest");
}

CBasednsRequest::CBasednsRequest(const char *serviceName, IRpcMessage* rpcmsg)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("BasednsRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CBasednsRequest::CBasednsRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("BasednsRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CBasednsRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType><xsd:all/></xsd:complexType></xsd:element>\n", msgTypeName);
		}
	}
	return schema;
}

void CBasednsRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CBasednsRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CBasednsRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CBasednsRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CBasednsRequest::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

}


void CBasednsRequest::copy(CBasednsRequest &from)
{
}


void CBasednsRequest::copy(IConstBasednsRequest &ifrom)
{
}


void CBasednsRequest::getAttributes(IProperties &attributes)
{
}


void CBasednsRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
}


void CBasednsRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CBasednsRequest::serializer(IEspContext* ctx, IConstBasednsRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<BasednsRequest>");
	if (keepRootTag)
		buffer.append("</BasednsRequest>");
}

bool CBasednsRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	return hasValue;
}

bool CBasednsRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	return hasValue;
}

bool CBasednsRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	return hasValue;
}

extern "C"  IEspBasednsRequest *createBasednsRequest(const char *serv){return ((IEspBasednsRequest *)new CBasednsRequest(serv));}
extern "C"  IClientBasednsRequest *createClientBasednsRequest(const char *serv){return ((IClientBasednsRequest *)new CBasednsRequest(serv));}

//=======================================================
// class CDnStruct Implementation
//=======================================================

CDnStruct::CDnStruct(const char *serviceName, IRpcMessageBinding *init)
	: m_name(nilIgnore),m_basedn(nilIgnore),m_rtype(nilIgnore),m_rtitle(nilIgnore),m_templatename(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("DnStruct");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CDnStruct::CDnStruct(const char *serviceName, const char *bc)
	: m_name(nilIgnore),m_basedn(nilIgnore),m_rtype(nilIgnore),m_rtitle(nilIgnore),m_templatename(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("DnStruct");
}

StringBuffer &CDnStruct::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:complexType name=\"%s\">\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"name\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"basedn\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"rtype\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"rtitle\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"templatename\" type=\"xsd:string\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType>\n");
		}
	}
	return schema;
}

void CDnStruct::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CDnStruct::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CDnStruct::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("name");
	form.appendf("  <tr><td><b>name: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("basedn");
	form.appendf("  <tr><td><b>basedn: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("rtype");
	form.appendf("  <tr><td><b>rtype: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("rtitle");
	form.appendf("  <tr><td><b>rtitle: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("templatename");
	form.appendf("  <tr><td><b>templatename: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CDnStruct::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CDnStruct::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_name.marshall(rpc_resp, "name", "", "", "");
	m_basedn.marshall(rpc_resp, "basedn", "", "", "");
	m_rtype.marshall(rpc_resp, "rtype", "", "", "");
	m_rtitle.marshall(rpc_resp, "rtitle", "", "", "");
	m_templatename.marshall(rpc_resp, "templatename", "", "", "");
}


void CDnStruct::copy(CDnStruct &from)
{
	m_name.copy(from.m_name);
	m_basedn.copy(from.m_basedn);
	m_rtype.copy(from.m_rtype);
	m_rtitle.copy(from.m_rtitle);
	m_templatename.copy(from.m_templatename);
}


void CDnStruct::copy(IConstDnStruct &ifrom)
{
	setName(ifrom.getName());
	setBasedn(ifrom.getBasedn());
	setRtype(ifrom.getRtype());
	setRtitle(ifrom.getRtitle());
	setTemplatename(ifrom.getTemplatename());
}


void CDnStruct::getAttributes(IProperties &attributes)
{
}


void CDnStruct::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_name.toStr(ctx, buffer, "name", "", true, "", "");
	m_basedn.toStr(ctx, buffer, "basedn", "", true, "", "");
	m_rtype.toStr(ctx, buffer, "rtype", "", true, "", "");
	m_rtitle.toStr(ctx, buffer, "rtitle", "", true, "", "");
	m_templatename.toStr(ctx, buffer, "templatename", "", true, "", "");
}


void CDnStruct::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CDnStruct::serializer(IEspContext* ctx, IConstDnStruct &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<DnStruct>");
	// field name
	{
		const char* s = src.getName();
		if (s && *s)
		{
			buffer.append("<name>");
			encodeUtf8XML(s,buffer);
			buffer.append("</name>");
		}
	}
	// field basedn
	{
		const char* s = src.getBasedn();
		if (s && *s)
		{
			buffer.append("<basedn>");
			encodeUtf8XML(s,buffer);
			buffer.append("</basedn>");
		}
	}
	// field rtype
	{
		const char* s = src.getRtype();
		if (s && *s)
		{
			buffer.append("<rtype>");
			encodeUtf8XML(s,buffer);
			buffer.append("</rtype>");
		}
	}
	// field rtitle
	{
		const char* s = src.getRtitle();
		if (s && *s)
		{
			buffer.append("<rtitle>");
			encodeUtf8XML(s,buffer);
			buffer.append("</rtitle>");
		}
	}
	// field templatename
	{
		const char* s = src.getTemplatename();
		if (s && *s)
		{
			buffer.append("<templatename>");
			encodeUtf8XML(s,buffer);
			buffer.append("</templatename>");
		}
	}
	if (keepRootTag)
		buffer.append("</DnStruct>");
}

bool CDnStruct::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_name.unmarshall(rpc_request, "name", basepath);
	hasValue |= m_basedn.unmarshall(rpc_request, "basedn", basepath);
	hasValue |= m_rtype.unmarshall(rpc_request, "rtype", basepath);
	hasValue |= m_rtitle.unmarshall(rpc_request, "rtitle", basepath);
	hasValue |= m_templatename.unmarshall(rpc_request, "templatename", basepath);
	return hasValue;
}

bool CDnStruct::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_name.unmarshall(ctx, soapval, "name");
	hasValue |= m_basedn.unmarshall(ctx, soapval, "basedn");
	hasValue |= m_rtype.unmarshall(ctx, soapval, "rtype");
	hasValue |= m_rtitle.unmarshall(ctx, soapval, "rtitle");
	hasValue |= m_templatename.unmarshall(ctx, soapval, "templatename");
	return hasValue;
}

bool CDnStruct::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_name.unmarshall(ctx, params, attachments, "name", basepath);
	hasValue |= m_basedn.unmarshall(ctx, params, attachments, "basedn", basepath);
	hasValue |= m_rtype.unmarshall(ctx, params, attachments, "rtype", basepath);
	hasValue |= m_rtitle.unmarshall(ctx, params, attachments, "rtitle", basepath);
	hasValue |= m_templatename.unmarshall(ctx, params, attachments, "templatename", basepath);
	return hasValue;
}

const char * CDnStruct::getName() { return m_name.query();}
const char * CDnStruct::getBasedn() { return m_basedn.query();}
const char * CDnStruct::getRtype() { return m_rtype.query();}
const char * CDnStruct::getRtitle() { return m_rtitle.query();}
const char * CDnStruct::getTemplatename() { return m_templatename.query();}
void CDnStruct::setName(const char * val){ m_name.set(val); }
void CDnStruct::setBasedn(const char * val){ m_basedn.set(val); }
void CDnStruct::setRtype(const char * val){ m_rtype.set(val); }
void CDnStruct::setRtitle(const char * val){ m_rtitle.set(val); }
void CDnStruct::setTemplatename(const char * val){ m_templatename.set(val); }
extern "C"  IEspDnStruct *createDnStruct(const char *serv, const char *msgname){return ((IEspDnStruct *)new CDnStruct(serv /*, msgname*/));}
extern "C"  IClientDnStruct *createClientDnStruct(const char *serv, const char *msgname){return ((IClientDnStruct *)new CDnStruct(serv /*, msgname*/));}

//=======================================================
// class CBasednsResponse Implementation
//=======================================================

CBasednsResponse::CBasednsResponse(const char *serviceName, IRpcMessageBinding *init)
	: m_NoSecMngr(0, nilIgnore,false),m_Basedns(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("BasednsResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CBasednsResponse::CBasednsResponse(const char *serviceName, const char *bc)
	: m_NoSecMngr(0, nilIgnore,false),m_Basedns(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("BasednsResponse");
}

CBasednsResponse::CBasednsResponse(const char *serviceName, IRpcMessage* rpcmsg)
	: m_NoSecMngr(0, nilIgnore,false),m_Basedns(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("BasednsResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CBasednsResponse::CBasednsResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_NoSecMngr(0, nilIgnore,false),m_Basedns(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("BasednsResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CBasednsResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		if (!context.suppressed("BasednsResponse","NoSecMngr")) {
			schema.append("<xsd:element minOccurs=\"0\" default=\"false\" name=\"NoSecMngr\" type=\"xsd:boolean\"/>\n");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Basedns\">\n");
		schema.append("<xsd:complexType><xsd:sequence>\n");
		schema.append("<xsd:element minOccurs=\"0\" maxOccurs=\"unbounded\" name=\"Basedn\" type=\"tns:DnStruct\"/>");
		schema.append("</xsd:sequence></xsd:complexType>");
		schema.append("</xsd:element>");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	if (!(flags & 0x10)  || (flags & 0x100))
	{
		CDnStruct::getXsdDefinition(context, request, schema, added);
	}
	return schema;
}

void CBasednsResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CBasednsResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
	info.addMinVersion("BasednsResponse","NoSecMngr",1.04);
	if (!added.getValue("DnStruct"))
	{
		added.setValue("DnStruct",1);
		CDnStruct::getMapInfo(info,added);
	}
}

StringBuffer &CBasednsResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	if (!context.suppressed("BasednsResponse","NoSecMngr")) {
		extfix.clear();
		if (prefix && *prefix)
			extfix.append(prefix).append(".");
		extfix.append("NoSecMngr");
		
	form.appendf("  <tr><td><b>NoSecMngr? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	}
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Basedns");
	form.appendf("<tr><td><b>Basedns: </b></td><td>");
	form.appendf("<table><tr><td><textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea></td>", extfix.str());
	form.append("</tr></table>");
	form.append("</td></tr>");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CBasednsResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CBasednsResponse::serialize(IRpcMessage& rpc_resp)
{
	IEspContext* ctx = rpc_resp.queryContext();
	double clientVer= ctx ? ctx->getClientVersion() : -1; /* no context gets everything */
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
		if ((clientVer==-1.0 || clientVer>=1.04))
			m_NoSecMngr.marshall(rpc_resp, "NoSecMngr", "", "", "");
		m_Basedns.marshall(rpc_resp, "Basedns", "Basedn");
	}
}


void CBasednsResponse::copy(CBasednsResponse &from)
{
	m_NoSecMngr.copy(from.m_NoSecMngr);
	m_Basedns.copy(from.m_Basedns);
}


void CBasednsResponse::copy(IConstBasednsResponse &ifrom)
{
	setNoSecMngr(ifrom.getNoSecMngr());
	setBasedns(ifrom.getBasedns());
}


void CBasednsResponse::getAttributes(IProperties &attributes)
{
}


void CBasednsResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
		double clientVer = ctx ? ctx->getClientVersion() : -1;
		if ((clientVer==-1.0 || clientVer>=1.04))
			m_NoSecMngr.toStr(ctx, buffer, "NoSecMngr", "", true, "", "");
		m_Basedns.toStr(ctx, buffer, "Basedns", "Basedn");
	}
}


void CBasednsResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CBasednsResponse::serializer(IEspContext* ctx, IConstBasednsResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<BasednsResponse>");
	double clientVer = ctx ? ctx->getClientVersion() : -1;
	// field NoSecMngr
	if ((clientVer==-1.0 || clientVer>=1.04))
	{
		bool b = src.getNoSecMngr();
		if (b)
			buffer.appendf("<NoSecMngr>1</NoSecMngr>");
	}
	// field Basedns
	{
		IArrayOf<IConstDnStruct>& v = src.getBasedns();
		int size = v.length();
		if (size>0)
			buffer.append("<Basedns>");
		for (int i=0;i<size;i++)
		{
			buffer.append("<Basedn>");
			CDnStruct::serializer(ctx,v.item(i),buffer,false);
			buffer.append("</Basedn>");
		}
		if (size>0)
			buffer.append("</Basedns>");
	}
	if (keepRootTag)
		buffer.append("</BasednsResponse>");
}

bool CBasednsResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
		hasValue |= m_NoSecMngr.unmarshall(rpc_request, "NoSecMngr", basepath);
		hasValue |= m_Basedns.unmarshall(rpc_request, "Basedns", basepath);
	}
	return hasValue;
}

bool CBasednsResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_NoSecMngr.unmarshall(ctx, soapval, "NoSecMngr");
	hasValue |= m_Basedns.unmarshall(ctx, soapval, "Basedns");
	return hasValue;
}

bool CBasednsResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_NoSecMngr.unmarshall(ctx, params, attachments, "NoSecMngr", basepath);
	hasValue |= m_Basedns.unmarshall(ctx, params, attachments, "Basedns", basepath);
	return hasValue;
}

bool CBasednsResponse::getNoSecMngr() { return m_NoSecMngr;}
IArrayOf<IConstDnStruct> & CBasednsResponse::getBasedns() { return (IArrayOf<IConstDnStruct> &) m_Basedns; }
void CBasednsResponse::setNoSecMngr(bool val){ m_NoSecMngr=val; }
void CBasednsResponse::setBasedns(IArrayOf<IEspDnStruct> &val)
{
	m_Basedns->kill();
	IArrayOf<IConstDnStruct> &target = m_Basedns.getValue();
	ForEachItemIn(idx, val)
	{
		IEspDnStruct &item = (val).item(idx);
		item.Link();
		target.append(item);
	}
}
void CBasednsResponse::setBasedns(IArrayOf<IConstDnStruct> &val)
{
	m_Basedns->kill();
	IArrayOf<IConstDnStruct> &target = m_Basedns.getValue();
	ForEachItemIn(idx, val)
	{
		IConstDnStruct &item = val.item(idx);
		item.Link();
		target.append(item);
	}
}
extern "C"  IEspBasednsResponse *createBasednsResponse(const char *serv){return ((IEspBasednsResponse *)new CBasednsResponse(serv));}
extern "C"  IClientBasednsResponse *createClientBasednsResponse(const char *serv){return ((IClientBasednsResponse *)new CBasednsResponse(serv));}

//=======================================================
// class CResourcesRequest Implementation
//=======================================================

CResourcesRequest::CResourcesRequest(const char *serviceName, IRpcMessageBinding *init)
	: m_basedn(nilIgnore),m_rtype(nilIgnore),m_rtitle(nilIgnore),m_templatename(nilIgnore),m_prefix(nilIgnore),m_searchinput(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ResourcesRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CResourcesRequest::CResourcesRequest(const char *serviceName, const char *bc)
	: m_basedn(nilIgnore),m_rtype(nilIgnore),m_rtitle(nilIgnore),m_templatename(nilIgnore),m_prefix(nilIgnore),m_searchinput(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ResourcesRequest");
}

CResourcesRequest::CResourcesRequest(const char *serviceName, IRpcMessage* rpcmsg)
	: m_basedn(nilIgnore),m_rtype(nilIgnore),m_rtitle(nilIgnore),m_templatename(nilIgnore),m_prefix(nilIgnore),m_searchinput(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ResourcesRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CResourcesRequest::CResourcesRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_basedn(nilIgnore),m_rtype(nilIgnore),m_rtitle(nilIgnore),m_templatename(nilIgnore),m_prefix(nilIgnore),m_searchinput(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ResourcesRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CResourcesRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"basedn\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"rtype\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"rtitle\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"templatename\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"prefix\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"searchinput\" type=\"xsd:string\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CResourcesRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CResourcesRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CResourcesRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("basedn");
	form.appendf("  <tr><td><b>basedn: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("rtype");
	form.appendf("  <tr><td><b>rtype: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("rtitle");
	form.appendf("  <tr><td><b>rtitle: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("templatename");
	form.appendf("  <tr><td><b>templatename: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("prefix");
	form.appendf("  <tr><td><b>prefix: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("searchinput");
	form.appendf("  <tr><td><b>searchinput: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CResourcesRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CResourcesRequest::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_basedn.marshall(rpc_resp, "basedn", "", "", "");
	m_rtype.marshall(rpc_resp, "rtype", "", "", "");
	m_rtitle.marshall(rpc_resp, "rtitle", "", "", "");
	m_templatename.marshall(rpc_resp, "templatename", "", "", "");
	m_prefix.marshall(rpc_resp, "prefix", "", "", "");
	m_searchinput.marshall(rpc_resp, "searchinput", "", "", "");
}


void CResourcesRequest::copy(CResourcesRequest &from)
{
	m_basedn.copy(from.m_basedn);
	m_rtype.copy(from.m_rtype);
	m_rtitle.copy(from.m_rtitle);
	m_templatename.copy(from.m_templatename);
	m_prefix.copy(from.m_prefix);
	m_searchinput.copy(from.m_searchinput);
}


void CResourcesRequest::copy(IConstResourcesRequest &ifrom)
{
	setBasedn(ifrom.getBasedn());
	setRtype(ifrom.getRtype());
	setRtitle(ifrom.getRtitle());
	setTemplatename(ifrom.getTemplatename());
	setPrefix(ifrom.getPrefix());
	setSearchinput(ifrom.getSearchinput());
}


void CResourcesRequest::getAttributes(IProperties &attributes)
{
}


void CResourcesRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_basedn.toStr(ctx, buffer, "basedn", "", true, "", "");
	m_rtype.toStr(ctx, buffer, "rtype", "", true, "", "");
	m_rtitle.toStr(ctx, buffer, "rtitle", "", true, "", "");
	m_templatename.toStr(ctx, buffer, "templatename", "", true, "", "");
	m_prefix.toStr(ctx, buffer, "prefix", "", true, "", "");
	m_searchinput.toStr(ctx, buffer, "searchinput", "", true, "", "");
}


void CResourcesRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CResourcesRequest::serializer(IEspContext* ctx, IConstResourcesRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<ResourcesRequest>");
	// field basedn
	{
		const char* s = src.getBasedn();
		if (s && *s)
		{
			buffer.append("<basedn>");
			encodeUtf8XML(s,buffer);
			buffer.append("</basedn>");
		}
	}
	// field rtype
	{
		const char* s = src.getRtype();
		if (s && *s)
		{
			buffer.append("<rtype>");
			encodeUtf8XML(s,buffer);
			buffer.append("</rtype>");
		}
	}
	// field rtitle
	{
		const char* s = src.getRtitle();
		if (s && *s)
		{
			buffer.append("<rtitle>");
			encodeUtf8XML(s,buffer);
			buffer.append("</rtitle>");
		}
	}
	// field templatename
	{
		const char* s = src.getTemplatename();
		if (s && *s)
		{
			buffer.append("<templatename>");
			encodeUtf8XML(s,buffer);
			buffer.append("</templatename>");
		}
	}
	// field prefix
	{
		const char* s = src.getPrefix();
		if (s && *s)
		{
			buffer.append("<prefix>");
			encodeUtf8XML(s,buffer);
			buffer.append("</prefix>");
		}
	}
	// field searchinput
	{
		const char* s = src.getSearchinput();
		if (s && *s)
		{
			buffer.append("<searchinput>");
			encodeUtf8XML(s,buffer);
			buffer.append("</searchinput>");
		}
	}
	if (keepRootTag)
		buffer.append("</ResourcesRequest>");
}

bool CResourcesRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_basedn.unmarshall(rpc_request, "basedn", basepath);
	hasValue |= m_rtype.unmarshall(rpc_request, "rtype", basepath);
	hasValue |= m_rtitle.unmarshall(rpc_request, "rtitle", basepath);
	hasValue |= m_templatename.unmarshall(rpc_request, "templatename", basepath);
	hasValue |= m_prefix.unmarshall(rpc_request, "prefix", basepath);
	hasValue |= m_searchinput.unmarshall(rpc_request, "searchinput", basepath);
	return hasValue;
}

bool CResourcesRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_basedn.unmarshall(ctx, soapval, "basedn");
	hasValue |= m_rtype.unmarshall(ctx, soapval, "rtype");
	hasValue |= m_rtitle.unmarshall(ctx, soapval, "rtitle");
	hasValue |= m_templatename.unmarshall(ctx, soapval, "templatename");
	hasValue |= m_prefix.unmarshall(ctx, soapval, "prefix");
	hasValue |= m_searchinput.unmarshall(ctx, soapval, "searchinput");
	return hasValue;
}

bool CResourcesRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_basedn.unmarshall(ctx, params, attachments, "basedn", basepath);
	hasValue |= m_rtype.unmarshall(ctx, params, attachments, "rtype", basepath);
	hasValue |= m_rtitle.unmarshall(ctx, params, attachments, "rtitle", basepath);
	hasValue |= m_templatename.unmarshall(ctx, params, attachments, "templatename", basepath);
	hasValue |= m_prefix.unmarshall(ctx, params, attachments, "prefix", basepath);
	hasValue |= m_searchinput.unmarshall(ctx, params, attachments, "searchinput", basepath);
	return hasValue;
}

const char * CResourcesRequest::getBasedn() { return m_basedn.query();}
const char * CResourcesRequest::getRtype() { return m_rtype.query();}
const char * CResourcesRequest::getRtitle() { return m_rtitle.query();}
const char * CResourcesRequest::getTemplatename() { return m_templatename.query();}
const char * CResourcesRequest::getPrefix() { return m_prefix.query();}
const char * CResourcesRequest::getSearchinput() { return m_searchinput.query();}
void CResourcesRequest::setBasedn(const char * val){ m_basedn.set(val); }
void CResourcesRequest::setRtype(const char * val){ m_rtype.set(val); }
void CResourcesRequest::setRtitle(const char * val){ m_rtitle.set(val); }
void CResourcesRequest::setTemplatename(const char * val){ m_templatename.set(val); }
void CResourcesRequest::setPrefix(const char * val){ m_prefix.set(val); }
void CResourcesRequest::setSearchinput(const char * val){ m_searchinput.set(val); }
extern "C"  IEspResourcesRequest *createResourcesRequest(const char *serv){return ((IEspResourcesRequest *)new CResourcesRequest(serv));}
extern "C"  IClientResourcesRequest *createClientResourcesRequest(const char *serv){return ((IClientResourcesRequest *)new CResourcesRequest(serv));}

//=======================================================
// class CResource Implementation
//=======================================================

CResource::CResource(const char *serviceName, IRpcMessageBinding *init)
	: m_name(nilIgnore),m_description(nilIgnore),m_isSpecial(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("Resource");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CResource::CResource(const char *serviceName, const char *bc)
	: m_name(nilIgnore),m_description(nilIgnore),m_isSpecial(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("Resource");
}

StringBuffer &CResource::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:complexType name=\"%s\">\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"name\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"description\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"isSpecial\" type=\"xsd:boolean\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType>\n");
		}
	}
	return schema;
}

void CResource::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CResource::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CResource::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("name");
	form.appendf("  <tr><td><b>name: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("description");
	form.appendf("  <tr><td><b>description: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("isSpecial");
	
	form.appendf("  <tr><td><b>isSpecial? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CResource::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CResource::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_name.marshall(rpc_resp, "name", "", "", "");
	m_description.marshall(rpc_resp, "description", "", "", "");
	m_isSpecial.marshall(rpc_resp, "isSpecial", "", "", "");
}


void CResource::copy(CResource &from)
{
	m_name.copy(from.m_name);
	m_description.copy(from.m_description);
	m_isSpecial.copy(from.m_isSpecial);
}


void CResource::copy(IConstResource &ifrom)
{
	setName(ifrom.getName());
	setDescription(ifrom.getDescription());
	setIsSpecial(ifrom.getIsSpecial());
}


void CResource::getAttributes(IProperties &attributes)
{
}


void CResource::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_name.toStr(ctx, buffer, "name", "", true, "", "");
	m_description.toStr(ctx, buffer, "description", "", true, "", "");
	m_isSpecial.toStr(ctx, buffer, "isSpecial", "", true, "", "");
}


void CResource::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CResource::serializer(IEspContext* ctx, IConstResource &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<Resource>");
	// field name
	{
		const char* s = src.getName();
		if (s && *s)
		{
			buffer.append("<name>");
			encodeUtf8XML(s,buffer);
			buffer.append("</name>");
		}
	}
	// field description
	{
		const char* s = src.getDescription();
		if (s && *s)
		{
			buffer.append("<description>");
			encodeUtf8XML(s,buffer);
			buffer.append("</description>");
		}
	}
	// field isSpecial
	{
		bool b = src.getIsSpecial();
		if (b)
			buffer.appendf("<isSpecial>1</isSpecial>");
	}
	if (keepRootTag)
		buffer.append("</Resource>");
}

bool CResource::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_name.unmarshall(rpc_request, "name", basepath);
	hasValue |= m_description.unmarshall(rpc_request, "description", basepath);
	hasValue |= m_isSpecial.unmarshall(rpc_request, "isSpecial", basepath);
	return hasValue;
}

bool CResource::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_name.unmarshall(ctx, soapval, "name");
	hasValue |= m_description.unmarshall(ctx, soapval, "description");
	hasValue |= m_isSpecial.unmarshall(ctx, soapval, "isSpecial");
	return hasValue;
}

bool CResource::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_name.unmarshall(ctx, params, attachments, "name", basepath);
	hasValue |= m_description.unmarshall(ctx, params, attachments, "description", basepath);
	hasValue |= m_isSpecial.unmarshall(ctx, params, attachments, "isSpecial", basepath);
	return hasValue;
}

const char * CResource::getName() { return m_name.query();}
const char * CResource::getDescription() { return m_description.query();}
bool CResource::getIsSpecial() { return m_isSpecial;}
void CResource::setName(const char * val){ m_name.set(val); }
void CResource::setDescription(const char * val){ m_description.set(val); }
void CResource::setIsSpecial(bool val){ m_isSpecial=val; }
extern "C"  IEspResource *createResource(const char *serv, const char *msgname){return ((IEspResource *)new CResource(serv /*, msgname*/));}
extern "C"  IClientResource *createClientResource(const char *serv, const char *msgname){return ((IClientResource *)new CResource(serv /*, msgname*/));}

//=======================================================
// class CScopeScanStatusStruct Implementation
//=======================================================

CScopeScanStatusStruct::CScopeScanStatusStruct(const char *serviceName, IRpcMessageBinding *init)
	: m_isEnabled(nilIgnore),m_retcode(nilIgnore),m_retmsg(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ScopeScanStatusStruct");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CScopeScanStatusStruct::CScopeScanStatusStruct(const char *serviceName, const char *bc)
	: m_isEnabled(nilIgnore),m_retcode(nilIgnore),m_retmsg(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ScopeScanStatusStruct");
}

StringBuffer &CScopeScanStatusStruct::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:complexType name=\"%s\">\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"isEnabled\" type=\"xsd:boolean\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"retcode\" type=\"xsd:int\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"retmsg\" type=\"xsd:string\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType>\n");
		}
	}
	return schema;
}

void CScopeScanStatusStruct::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CScopeScanStatusStruct::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CScopeScanStatusStruct::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("isEnabled");
	
	form.appendf("  <tr><td><b>isEnabled? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	extfix.clear();
	if (prefix && *prefix) extfix.append(prefix).append(".");
		extfix.append("retcode");
	form.appendf("  <tr><td><b>retcode: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("retmsg");
	form.appendf("  <tr><td><b>retmsg: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CScopeScanStatusStruct::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CScopeScanStatusStruct::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_isEnabled.marshall(rpc_resp, "isEnabled", "", "", "");
	m_retcode.marshall(rpc_resp, "retcode", "", "", "");
	m_retmsg.marshall(rpc_resp, "retmsg", "", "", "");
}


void CScopeScanStatusStruct::copy(CScopeScanStatusStruct &from)
{
	m_isEnabled.copy(from.m_isEnabled);
	m_retcode.copy(from.m_retcode);
	m_retmsg.copy(from.m_retmsg);
}


void CScopeScanStatusStruct::copy(IConstScopeScanStatusStruct &ifrom)
{
	setIsEnabled(ifrom.getIsEnabled());
	setRetcode(ifrom.getRetcode());
	setRetmsg(ifrom.getRetmsg());
}


void CScopeScanStatusStruct::getAttributes(IProperties &attributes)
{
}


void CScopeScanStatusStruct::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_isEnabled.toStr(ctx, buffer, "isEnabled", "", true, "", "");
	m_retcode.toStr(ctx, buffer, "retcode", "", true, "", "");
	m_retmsg.toStr(ctx, buffer, "retmsg", "", true, "", "");
}


void CScopeScanStatusStruct::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CScopeScanStatusStruct::serializer(IEspContext* ctx, IConstScopeScanStatusStruct &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<ScopeScanStatusStruct>");
	// field isEnabled
	{
		bool b = src.getIsEnabled();
		if (b)
			buffer.appendf("<isEnabled>1</isEnabled>");
	}
	// field retcode
	{
		int n = src.getRetcode();
		if (n)
			buffer.appendf("<retcode>%d</retcode>", n);
	}
	// field retmsg
	{
		const char* s = src.getRetmsg();
		if (s && *s)
		{
			buffer.append("<retmsg>");
			encodeUtf8XML(s,buffer);
			buffer.append("</retmsg>");
		}
	}
	if (keepRootTag)
		buffer.append("</ScopeScanStatusStruct>");
}

bool CScopeScanStatusStruct::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_isEnabled.unmarshall(rpc_request, "isEnabled", basepath);
	hasValue |= m_retcode.unmarshall(rpc_request, "retcode", basepath);
	hasValue |= m_retmsg.unmarshall(rpc_request, "retmsg", basepath);
	return hasValue;
}

bool CScopeScanStatusStruct::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_isEnabled.unmarshall(ctx, soapval, "isEnabled");
	hasValue |= m_retcode.unmarshall(ctx, soapval, "retcode");
	hasValue |= m_retmsg.unmarshall(ctx, soapval, "retmsg");
	return hasValue;
}

bool CScopeScanStatusStruct::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_isEnabled.unmarshall(ctx, params, attachments, "isEnabled", basepath);
	hasValue |= m_retcode.unmarshall(ctx, params, attachments, "retcode", basepath);
	hasValue |= m_retmsg.unmarshall(ctx, params, attachments, "retmsg", basepath);
	return hasValue;
}

bool CScopeScanStatusStruct::getIsEnabled() { return m_isEnabled;}
int CScopeScanStatusStruct::getRetcode() { return m_retcode;}
const char * CScopeScanStatusStruct::getRetmsg() { return m_retmsg.query();}
void CScopeScanStatusStruct::setIsEnabled(bool val){ m_isEnabled=val; }
void CScopeScanStatusStruct::setRetcode(int val){ m_retcode=val; }
void CScopeScanStatusStruct::setRetmsg(const char * val){ m_retmsg.set(val); }
extern "C"  IEspScopeScanStatusStruct *createScopeScanStatusStruct(const char *serv, const char *msgname){return ((IEspScopeScanStatusStruct *)new CScopeScanStatusStruct(serv /*, msgname*/));}
extern "C"  IClientScopeScanStatusStruct *createClientScopeScanStatusStruct(const char *serv, const char *msgname){return ((IClientScopeScanStatusStruct *)new CScopeScanStatusStruct(serv /*, msgname*/));}

//=======================================================
// class CResourcesResponse Implementation
//=======================================================

CResourcesResponse::CResourcesResponse(const char *serviceName, IRpcMessageBinding *init)
	: m_basedn(nilIgnore),m_rtype(nilIgnore),m_rtitle(nilIgnore),m_Resources(nilIgnore),m_default_basedn(nilIgnore),m_default_name(nilIgnore),m_prefix(nilIgnore),m_toomany(nilIgnore),m_scopeScansStatus(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ResourcesResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CResourcesResponse::CResourcesResponse(const char *serviceName, const char *bc)
	: m_basedn(nilIgnore),m_rtype(nilIgnore),m_rtitle(nilIgnore),m_Resources(nilIgnore),m_default_basedn(nilIgnore),m_default_name(nilIgnore),m_prefix(nilIgnore),m_toomany(nilIgnore),m_scopeScansStatus(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ResourcesResponse");
}

CResourcesResponse::CResourcesResponse(const char *serviceName, IRpcMessage* rpcmsg)
	: m_basedn(nilIgnore),m_rtype(nilIgnore),m_rtitle(nilIgnore),m_Resources(nilIgnore),m_default_basedn(nilIgnore),m_default_name(nilIgnore),m_prefix(nilIgnore),m_toomany(nilIgnore),m_scopeScansStatus(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ResourcesResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CResourcesResponse::CResourcesResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_basedn(nilIgnore),m_rtype(nilIgnore),m_rtitle(nilIgnore),m_Resources(nilIgnore),m_default_basedn(nilIgnore),m_default_name(nilIgnore),m_prefix(nilIgnore),m_toomany(nilIgnore),m_scopeScansStatus(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ResourcesResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CResourcesResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"basedn\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"rtype\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"rtitle\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Resources\">\n");
		schema.append("<xsd:complexType><xsd:sequence>\n");
		schema.append("<xsd:element minOccurs=\"0\" maxOccurs=\"unbounded\" name=\"Resource\" type=\"tns:Resource\"/>");
		schema.append("</xsd:sequence></xsd:complexType>");
		schema.append("</xsd:element>");
		schema.append("<xsd:element minOccurs=\"0\" name=\"default_basedn\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"default_name\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"prefix\" type=\"xsd:string\"/>\n");
		if (!context.suppressed("ResourcesResponse","toomany")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"toomany\" type=\"xsd:boolean\"/>\n");
		}
		if (!context.suppressed("ResourcesResponse","scopeScansStatus")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"scopeScansStatus\" type=\"tns:ScopeScanStatusStruct\"/>\n");
		}
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	if (!(flags & 0x10)  || (flags & 0x100))
	{
		CResource::getXsdDefinition(context, request, schema, added);
		if (!context.suppressed("ResourcesResponse","scopeScansStatus"))
			CScopeScanStatusStruct::getXsdDefinition(context, request, schema, added);
	}
	return schema;
}

void CResourcesResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CResourcesResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
	info.addMinVersion("ResourcesResponse","toomany",1.05);
	info.addMinVersion("ResourcesResponse","scopeScansStatus",1.08);
	if (!added.getValue("Resource"))
	{
		added.setValue("Resource",1);
		CResource::getMapInfo(info,added);
	}
	if (!added.getValue("ScopeScanStatusStruct"))
	{
		added.setValue("ScopeScanStatusStruct",1);
		CScopeScanStatusStruct::getMapInfo(info,added);
	}
}

StringBuffer &CResourcesResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("basedn");
	form.appendf("  <tr><td><b>basedn: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("rtype");
	form.appendf("  <tr><td><b>rtype: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("rtitle");
	form.appendf("  <tr><td><b>rtitle: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Resources");
	form.appendf("<tr><td><b>Resources: </b></td><td>");
	form.appendf("<table><tr><td><textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea></td>", extfix.str());
	form.append("</tr></table>");
	form.append("</td></tr>");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("default_basedn");
	form.appendf("  <tr><td><b>default_basedn: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("default_name");
	form.appendf("  <tr><td><b>default_name: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("prefix");
	form.appendf("  <tr><td><b>prefix: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (!context.suppressed("ResourcesResponse","toomany")) {
		extfix.clear();
		if (prefix && *prefix)
			extfix.append(prefix).append(".");
		extfix.append("toomany");
		
	form.appendf("  <tr><td><b>toomany? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	}
	if (!context.suppressed("ResourcesResponse","scopeScansStatus")) {
		extfix.clear();
		if (prefix && *prefix)
			extfix.append(prefix).append(".");
		extfix.append("scopeScansStatus");
		form.append("<tr>").append("<td><b>scopeScansStatus: </b></td><td><hr/>");
		CScopeScanStatusStruct::getHtmlForm(context, request, serv, method, form, false, extfix.str());
		form.append("<hr/></td></tr>");
	}
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CResourcesResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CResourcesResponse::serialize(IRpcMessage& rpc_resp)
{
	IEspContext* ctx = rpc_resp.queryContext();
	double clientVer= ctx ? ctx->getClientVersion() : -1; /* no context gets everything */
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
		m_basedn.marshall(rpc_resp, "basedn", "", "", "");
		m_rtype.marshall(rpc_resp, "rtype", "", "", "");
		m_rtitle.marshall(rpc_resp, "rtitle", "", "", "");
		m_Resources.marshall(rpc_resp, "Resources", "Resource");
		m_default_basedn.marshall(rpc_resp, "default_basedn", "", "", "");
		m_default_name.marshall(rpc_resp, "default_name", "", "", "");
		m_prefix.marshall(rpc_resp, "prefix", "", "", "");
		if ((clientVer==-1.0 || clientVer>=1.05))
			m_toomany.marshall(rpc_resp, "toomany", "", "", "");
		if ((clientVer==-1.0 || clientVer>=1.08))
			m_scopeScansStatus.marshall(rpc_resp, "scopeScansStatus", "", "", "");
	}
}


void CResourcesResponse::copy(CResourcesResponse &from)
{
	m_basedn.copy(from.m_basedn);
	m_rtype.copy(from.m_rtype);
	m_rtitle.copy(from.m_rtitle);
	m_Resources.copy(from.m_Resources);
	m_default_basedn.copy(from.m_default_basedn);
	m_default_name.copy(from.m_default_name);
	m_prefix.copy(from.m_prefix);
	m_toomany.copy(from.m_toomany);
	m_scopeScansStatus.copy(from.m_scopeScansStatus);
}


void CResourcesResponse::copy(IConstResourcesResponse &ifrom)
{
	setBasedn(ifrom.getBasedn());
	setRtype(ifrom.getRtype());
	setRtitle(ifrom.getRtitle());
	setResources(ifrom.getResources());
	setDefault_basedn(ifrom.getDefault_basedn());
	setDefault_name(ifrom.getDefault_name());
	setPrefix(ifrom.getPrefix());
	setToomany(ifrom.getToomany());
	setScopeScansStatus(ifrom.getScopeScansStatus());
}


void CResourcesResponse::getAttributes(IProperties &attributes)
{
}


void CResourcesResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
		double clientVer = ctx ? ctx->getClientVersion() : -1;
		m_basedn.toStr(ctx, buffer, "basedn", "", true, "", "");
		m_rtype.toStr(ctx, buffer, "rtype", "", true, "", "");
		m_rtitle.toStr(ctx, buffer, "rtitle", "", true, "", "");
		m_Resources.toStr(ctx, buffer, "Resources", "Resource");
		m_default_basedn.toStr(ctx, buffer, "default_basedn", "", true, "", "");
		m_default_name.toStr(ctx, buffer, "default_name", "", true, "", "");
		m_prefix.toStr(ctx, buffer, "prefix", "", true, "", "");
		if ((clientVer==-1.0 || clientVer>=1.05))
			m_toomany.toStr(ctx, buffer, "toomany", "", true, "", "");
		if ((clientVer==-1.0 || clientVer>=1.08))
			m_scopeScansStatus.toStr(ctx, buffer, "scopeScansStatus", "", false, "", "");
	}
}


void CResourcesResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CResourcesResponse::serializer(IEspContext* ctx, IConstResourcesResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<ResourcesResponse>");
	double clientVer = ctx ? ctx->getClientVersion() : -1;
	// field basedn
	{
		const char* s = src.getBasedn();
		if (s && *s)
		{
			buffer.append("<basedn>");
			encodeUtf8XML(s,buffer);
			buffer.append("</basedn>");
		}
	}
	// field rtype
	{
		const char* s = src.getRtype();
		if (s && *s)
		{
			buffer.append("<rtype>");
			encodeUtf8XML(s,buffer);
			buffer.append("</rtype>");
		}
	}
	// field rtitle
	{
		const char* s = src.getRtitle();
		if (s && *s)
		{
			buffer.append("<rtitle>");
			encodeUtf8XML(s,buffer);
			buffer.append("</rtitle>");
		}
	}
	// field Resources
	{
		IArrayOf<IConstResource>& v = src.getResources();
		int size = v.length();
		if (size>0)
			buffer.append("<Resources>");
		for (int i=0;i<size;i++)
		{
			buffer.append("<Resource>");
			CResource::serializer(ctx,v.item(i),buffer,false);
			buffer.append("</Resource>");
		}
		if (size>0)
			buffer.append("</Resources>");
	}
	// field default_basedn
	{
		const char* s = src.getDefault_basedn();
		if (s && *s)
		{
			buffer.append("<default_basedn>");
			encodeUtf8XML(s,buffer);
			buffer.append("</default_basedn>");
		}
	}
	// field default_name
	{
		const char* s = src.getDefault_name();
		if (s && *s)
		{
			buffer.append("<default_name>");
			encodeUtf8XML(s,buffer);
			buffer.append("</default_name>");
		}
	}
	// field prefix
	{
		const char* s = src.getPrefix();
		if (s && *s)
		{
			buffer.append("<prefix>");
			encodeUtf8XML(s,buffer);
			buffer.append("</prefix>");
		}
	}
	// field toomany
	if ((clientVer==-1.0 || clientVer>=1.05))
	{
		bool b = src.getToomany();
		if (b)
			buffer.appendf("<toomany>1</toomany>");
	}
	// field scopeScansStatus
	if ((clientVer==-1.0 || clientVer>=1.08))
	{
		StringBuffer tmp;
		CScopeScanStatusStruct::serializer(ctx,src.getScopeScansStatus(), tmp, false);
		if (tmp.length()>0)
			buffer.appendf("<scopeScansStatus>%s</scopeScansStatus>",tmp.str());
	}
	if (keepRootTag)
		buffer.append("</ResourcesResponse>");
}

bool CResourcesResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
		hasValue |= m_basedn.unmarshall(rpc_request, "basedn", basepath);
		hasValue |= m_rtype.unmarshall(rpc_request, "rtype", basepath);
		hasValue |= m_rtitle.unmarshall(rpc_request, "rtitle", basepath);
		hasValue |= m_Resources.unmarshall(rpc_request, "Resources", basepath);
		hasValue |= m_default_basedn.unmarshall(rpc_request, "default_basedn", basepath);
		hasValue |= m_default_name.unmarshall(rpc_request, "default_name", basepath);
		hasValue |= m_prefix.unmarshall(rpc_request, "prefix", basepath);
		hasValue |= m_toomany.unmarshall(rpc_request, "toomany", basepath);
		hasValue |= m_scopeScansStatus.unmarshall(rpc_request, "scopeScansStatus", basepath);
	}
	return hasValue;
}

bool CResourcesResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_basedn.unmarshall(ctx, soapval, "basedn");
	hasValue |= m_rtype.unmarshall(ctx, soapval, "rtype");
	hasValue |= m_rtitle.unmarshall(ctx, soapval, "rtitle");
	hasValue |= m_Resources.unmarshall(ctx, soapval, "Resources");
	hasValue |= m_default_basedn.unmarshall(ctx, soapval, "default_basedn");
	hasValue |= m_default_name.unmarshall(ctx, soapval, "default_name");
	hasValue |= m_prefix.unmarshall(ctx, soapval, "prefix");
	hasValue |= m_toomany.unmarshall(ctx, soapval, "toomany");
	hasValue |= m_scopeScansStatus.unmarshall(ctx, soapval, "scopeScansStatus");
	return hasValue;
}

bool CResourcesResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_basedn.unmarshall(ctx, params, attachments, "basedn", basepath);
	hasValue |= m_rtype.unmarshall(ctx, params, attachments, "rtype", basepath);
	hasValue |= m_rtitle.unmarshall(ctx, params, attachments, "rtitle", basepath);
	hasValue |= m_Resources.unmarshall(ctx, params, attachments, "Resources", basepath);
	hasValue |= m_default_basedn.unmarshall(ctx, params, attachments, "default_basedn", basepath);
	hasValue |= m_default_name.unmarshall(ctx, params, attachments, "default_name", basepath);
	hasValue |= m_prefix.unmarshall(ctx, params, attachments, "prefix", basepath);
	hasValue |= m_toomany.unmarshall(ctx, params, attachments, "toomany", basepath);
	hasValue |= m_scopeScansStatus.unmarshall(ctx, params, attachments, "scopeScansStatus", basepath);
	return hasValue;
}

const char * CResourcesResponse::getBasedn() { return m_basedn.query();}
const char * CResourcesResponse::getRtype() { return m_rtype.query();}
const char * CResourcesResponse::getRtitle() { return m_rtitle.query();}
IArrayOf<IConstResource> & CResourcesResponse::getResources() { return (IArrayOf<IConstResource> &) m_Resources; }
const char * CResourcesResponse::getDefault_basedn() { return m_default_basedn.query();}
const char * CResourcesResponse::getDefault_name() { return m_default_name.query();}
const char * CResourcesResponse::getPrefix() { return m_prefix.query();}
bool CResourcesResponse::getToomany() { return m_toomany;}
IConstScopeScanStatusStruct & CResourcesResponse::getScopeScansStatus() { return (IConstScopeScanStatusStruct &) m_scopeScansStatus.getValue();}
void CResourcesResponse::setBasedn(const char * val){ m_basedn.set(val); }
void CResourcesResponse::setRtype(const char * val){ m_rtype.set(val); }
void CResourcesResponse::setRtitle(const char * val){ m_rtitle.set(val); }
void CResourcesResponse::setResources(IArrayOf<IEspResource> &val)
{
	m_Resources->kill();
	IArrayOf<IConstResource> &target = m_Resources.getValue();
	ForEachItemIn(idx, val)
	{
		IEspResource &item = (val).item(idx);
		item.Link();
		target.append(item);
	}
}
void CResourcesResponse::setResources(IArrayOf<IConstResource> &val)
{
	m_Resources->kill();
	IArrayOf<IConstResource> &target = m_Resources.getValue();
	ForEachItemIn(idx, val)
	{
		IConstResource &item = val.item(idx);
		item.Link();
		target.append(item);
	}
}
void CResourcesResponse::setDefault_basedn(const char * val){ m_default_basedn.set(val); }
void CResourcesResponse::setDefault_name(const char * val){ m_default_name.set(val); }
void CResourcesResponse::setPrefix(const char * val){ m_prefix.set(val); }
void CResourcesResponse::setToomany(bool val){ m_toomany=val; }
IEspScopeScanStatusStruct & CResourcesResponse::updateScopeScansStatus(){ return (IEspScopeScanStatusStruct &) m_scopeScansStatus.getValue(); }
void CResourcesResponse::setScopeScansStatus(IConstScopeScanStatusStruct &ifrom){ m_scopeScansStatus.copy(ifrom); }
extern "C"  IEspResourcesResponse *createResourcesResponse(const char *serv){return ((IEspResourcesResponse *)new CResourcesResponse(serv));}
extern "C"  IClientResourcesResponse *createClientResourcesResponse(const char *serv){return ((IClientResourcesResponse *)new CResourcesResponse(serv));}

//=======================================================
// class CResourceQueryRequest Implementation
//=======================================================

CResourceQueryRequest::CResourceQueryRequest(const char *serviceName, IRpcMessageBinding *init)
	: m_basedn(nilRemove),m_rtype(nilRemove),m_rtitle(nilRemove),m_prefix(nilRemove),m_Name(nilRemove),m_PageSize(nilRemove),m_PageStartFrom(nilRemove),m_SortBy(nilRemove),m_Descending(0, nilRemove,false),m_CacheHint(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ResourceQueryRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CResourceQueryRequest::CResourceQueryRequest(const char *serviceName, const char *bc)
	: m_basedn(nilRemove),m_rtype(nilRemove),m_rtitle(nilRemove),m_prefix(nilRemove),m_Name(nilRemove),m_PageSize(nilRemove),m_PageStartFrom(nilRemove),m_SortBy(nilRemove),m_Descending(0, nilRemove,false),m_CacheHint(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ResourceQueryRequest");
}

CResourceQueryRequest::CResourceQueryRequest(const char *serviceName, IRpcMessage* rpcmsg)
	: m_basedn(nilRemove),m_rtype(nilRemove),m_rtitle(nilRemove),m_prefix(nilRemove),m_Name(nilRemove),m_PageSize(nilRemove),m_PageStartFrom(nilRemove),m_SortBy(nilRemove),m_Descending(0, nilRemove,false),m_CacheHint(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ResourceQueryRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CResourceQueryRequest::CResourceQueryRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_basedn(nilRemove),m_rtype(nilRemove),m_rtitle(nilRemove),m_prefix(nilRemove),m_Name(nilRemove),m_PageSize(nilRemove),m_PageStartFrom(nilRemove),m_SortBy(nilRemove),m_Descending(0, nilRemove,false),m_CacheHint(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ResourceQueryRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CResourceQueryRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"basedn\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"rtype\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"rtitle\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"prefix\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Name\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"PageSize\" type=\"xsd:unsignedInt\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"PageStartFrom\" type=\"xsd:long\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"SortBy\" type=\"tns:ResourceSortBy\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" default=\"false\" name=\"Descending\" type=\"xsd:boolean\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"CacheHint\" type=\"xsd:long\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	if (!(flags & 0x10)  || (flags & 0x100))
	{
		CXResourceSortBy::getXsdDefinition(context, request, schema, added);
	}
	return schema;
}

void CResourceQueryRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CResourceQueryRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
	if (!added.getValue("ResourceSortBy"))
	{
		added.setValue("ResourceSortBy",1);
		CXResourceSortBy::getMapInfo(info,added);
	}
}

StringBuffer &CResourceQueryRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("basedn");
	form.appendf("  <tr><td><b>basedn: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("rtype");
	form.appendf("  <tr><td><b>rtype: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("rtitle");
	form.appendf("  <tr><td><b>rtitle: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("prefix");
	form.appendf("  <tr><td><b>prefix: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Name");
	form.appendf("  <tr><td><b>Name: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix) extfix.append(prefix).append(".");
		extfix.append("PageSize");
	form.appendf("  <tr><td><b>PageSize: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("PageStartFrom");
	form.appendf("  <tr><td><b>PageStartFrom: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("SortBy");
	form.appendf("  <tr><td><b>SortBy: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Descending");
	
	form.appendf("  <tr><td><b>Descending? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("CacheHint");
	form.appendf("  <tr><td><b>CacheHint: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CResourceQueryRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CResourceQueryRequest::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_basedn.marshall(rpc_resp, "basedn", "", "", "");
	m_rtype.marshall(rpc_resp, "rtype", "", "", "");
	m_rtitle.marshall(rpc_resp, "rtitle", "", "", "");
	m_prefix.marshall(rpc_resp, "prefix", "", "", "");
	m_Name.marshall(rpc_resp, "Name", "", "", "");
	m_PageSize.marshall(rpc_resp, "PageSize", "", "", "");
	m_PageStartFrom.marshall(rpc_resp, "PageStartFrom", "", "", "");
	m_SortBy.marshall(rpc_resp, "SortBy", "", "", "");
	m_Descending.marshall(rpc_resp, "Descending", "", "", "");
	m_CacheHint.marshall(rpc_resp, "CacheHint", "", "", "");
}


void CResourceQueryRequest::copy(CResourceQueryRequest &from)
{
	m_basedn.copy(from.m_basedn);
	m_rtype.copy(from.m_rtype);
	m_rtitle.copy(from.m_rtitle);
	m_prefix.copy(from.m_prefix);
	m_Name.copy(from.m_Name);
	m_PageSize.copy(from.m_PageSize);
	m_PageStartFrom.copy(from.m_PageStartFrom);
	m_SortBy.copy(from.m_SortBy);
	m_Descending.copy(from.m_Descending);
	m_CacheHint.copy(from.m_CacheHint);
}


void CResourceQueryRequest::copy(IConstResourceQueryRequest &ifrom)
{
	setBasedn(ifrom.getBasedn());
	setRtype(ifrom.getRtype());
	setRtitle(ifrom.getRtitle());
	setPrefix(ifrom.getPrefix());
	setName(ifrom.getName());
	setPageSize(ifrom.getPageSize());
	setPageStartFrom(ifrom.getPageStartFrom());
	setSortBy(ifrom.getSortBy());
	setDescending(ifrom.getDescending());
	setCacheHint(ifrom.getCacheHint());
}


void CResourceQueryRequest::getAttributes(IProperties &attributes)
{
}


void CResourceQueryRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_basedn.toStr(ctx, buffer, "basedn", "", true, "", "");
	m_rtype.toStr(ctx, buffer, "rtype", "", true, "", "");
	m_rtitle.toStr(ctx, buffer, "rtitle", "", true, "", "");
	m_prefix.toStr(ctx, buffer, "prefix", "", true, "", "");
	m_Name.toStr(ctx, buffer, "Name", "", true, "", "");
	m_PageSize.toStr(ctx, buffer, "PageSize", "", true, "", "");
	m_PageStartFrom.toStr(ctx, buffer, "PageStartFrom", "", true, "", "");
	m_SortBy.toStr(ctx, buffer, "SortBy", "", true, "", "");
	m_Descending.toStr(ctx, buffer, "Descending", "", true, "", "");
	m_CacheHint.toStr(ctx, buffer, "CacheHint", "", true, "", "");
}


void CResourceQueryRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CResourceQueryRequest::serializer(IEspContext* ctx, IConstResourceQueryRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<ResourceQueryRequest>");
	// field basedn
	{
		const char* s = src.getBasedn();
		if (s && *s)
		{
			buffer.append("<basedn>");
			encodeUtf8XML(s,buffer);
			buffer.append("</basedn>");
		}
	}
	// field rtype
	{
		const char* s = src.getRtype();
		if (s && *s)
		{
			buffer.append("<rtype>");
			encodeUtf8XML(s,buffer);
			buffer.append("</rtype>");
		}
	}
	// field rtitle
	{
		const char* s = src.getRtitle();
		if (s && *s)
		{
			buffer.append("<rtitle>");
			encodeUtf8XML(s,buffer);
			buffer.append("</rtitle>");
		}
	}
	// field prefix
	{
		const char* s = src.getPrefix();
		if (s && *s)
		{
			buffer.append("<prefix>");
			encodeUtf8XML(s,buffer);
			buffer.append("</prefix>");
		}
	}
	// field Name
	{
		const char* s = src.getName();
		if (s && *s)
		{
			buffer.append("<Name>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Name>");
		}
	}
	// field PageSize
	{
		//*** default kind: TK_UNSIGNED; type=(null), name=PageSize
		buffer.append("<PageSize>");
		buffer.append(src.getPageSize());
		buffer.append("</PageSize>");
	}
	// field PageStartFrom
	{
		//*** default kind: TK_INT; type=int64, name=PageStartFrom
		buffer.append("<PageStartFrom>");
		buffer.append(src.getPageStartFrom());
		buffer.append("</PageStartFrom>");
	}
	// field SortBy
	{
		const char* s = src.getSortByAsString();
		buffer.append("<SortBy>");
		encodeUtf8XML(s,buffer);
		buffer.append("</SortBy>");
	}
	// field Descending
	{
		bool b = src.getDescending();
		if (b)
			buffer.appendf("<Descending>1</Descending>");
	}
	// field CacheHint
	{
		//*** default kind: TK_INT; type=int64, name=CacheHint
		buffer.append("<CacheHint>");
		buffer.append(src.getCacheHint());
		buffer.append("</CacheHint>");
	}
	if (keepRootTag)
		buffer.append("</ResourceQueryRequest>");
}

bool CResourceQueryRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_basedn.unmarshall(rpc_request, "basedn", basepath);
	hasValue |= m_rtype.unmarshall(rpc_request, "rtype", basepath);
	hasValue |= m_rtitle.unmarshall(rpc_request, "rtitle", basepath);
	hasValue |= m_prefix.unmarshall(rpc_request, "prefix", basepath);
	hasValue |= m_Name.unmarshall(rpc_request, "Name", basepath);
	hasValue |= m_PageSize.unmarshall(rpc_request, "PageSize", basepath);
	hasValue |= m_PageStartFrom.unmarshall(rpc_request, "PageStartFrom", basepath);
	hasValue |= m_SortBy.unmarshall(rpc_request, "SortBy", basepath);
	hasValue |= m_Descending.unmarshall(rpc_request, "Descending", basepath);
	hasValue |= m_CacheHint.unmarshall(rpc_request, "CacheHint", basepath);
	return hasValue;
}

bool CResourceQueryRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_basedn.unmarshall(ctx, soapval, "basedn");
	hasValue |= m_rtype.unmarshall(ctx, soapval, "rtype");
	hasValue |= m_rtitle.unmarshall(ctx, soapval, "rtitle");
	hasValue |= m_prefix.unmarshall(ctx, soapval, "prefix");
	hasValue |= m_Name.unmarshall(ctx, soapval, "Name");
	hasValue |= m_PageSize.unmarshall(ctx, soapval, "PageSize");
	hasValue |= m_PageStartFrom.unmarshall(ctx, soapval, "PageStartFrom");
	hasValue |= m_SortBy.unmarshall(ctx, soapval, "SortBy");
	hasValue |= m_Descending.unmarshall(ctx, soapval, "Descending");
	hasValue |= m_CacheHint.unmarshall(ctx, soapval, "CacheHint");
	return hasValue;
}

bool CResourceQueryRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_basedn.unmarshall(ctx, params, attachments, "basedn", basepath);
	hasValue |= m_rtype.unmarshall(ctx, params, attachments, "rtype", basepath);
	hasValue |= m_rtitle.unmarshall(ctx, params, attachments, "rtitle", basepath);
	hasValue |= m_prefix.unmarshall(ctx, params, attachments, "prefix", basepath);
	hasValue |= m_Name.unmarshall(ctx, params, attachments, "Name", basepath);
	hasValue |= m_PageSize.unmarshall(ctx, params, attachments, "PageSize", basepath);
	hasValue |= m_PageStartFrom.unmarshall(ctx, params, attachments, "PageStartFrom", basepath);
	hasValue |= m_SortBy.unmarshall(ctx, params, attachments, "SortBy", basepath);
	hasValue |= m_Descending.unmarshall(ctx, params, attachments, "Descending", basepath);
	hasValue |= m_CacheHint.unmarshall(ctx, params, attachments, "CacheHint", basepath);
	return hasValue;
}

const char * CResourceQueryRequest::getBasedn() { return m_basedn.query();}
const char * CResourceQueryRequest::getRtype() { return m_rtype.query();}
const char * CResourceQueryRequest::getRtitle() { return m_rtitle.query();}
const char * CResourceQueryRequest::getPrefix() { return m_prefix.query();}
const char * CResourceQueryRequest::getName() { return m_Name.query();}
bool CResourceQueryRequest::getPageSize_isNull(){return m_PageSize.is_nil();}
unsigned int CResourceQueryRequest::getPageSize() { return m_PageSize;}
bool CResourceQueryRequest::getPageStartFrom_isNull(){return m_PageStartFrom.is_nil();}
__int64 CResourceQueryRequest::getPageStartFrom() { return m_PageStartFrom;}
CResourceSortBy CResourceQueryRequest::getSortBy() { return m_SortBy.getValue(); }
const char* CResourceQueryRequest::getSortByAsString() {  return (const char*)m_SortBy; }
bool CResourceQueryRequest::getDescending_isNull(){return m_Descending.is_nil();}
bool CResourceQueryRequest::getDescending() { return m_Descending;}
bool CResourceQueryRequest::getCacheHint_isNull(){return m_CacheHint.is_nil();}
__int64 CResourceQueryRequest::getCacheHint() { return m_CacheHint;}
void CResourceQueryRequest::setBasedn(const char * val){ m_basedn.set(val); }
void CResourceQueryRequest::setRtype(const char * val){ m_rtype.set(val); }
void CResourceQueryRequest::setRtitle(const char * val){ m_rtitle.set(val); }
void CResourceQueryRequest::setPrefix(const char * val){ m_prefix.set(val); }
void CResourceQueryRequest::setName(const char * val){ m_Name.set(val); }
void CResourceQueryRequest::setPageSize_null(){ m_PageSize.Nil(); }void CResourceQueryRequest::setPageSize(unsigned int val){ m_PageSize=val; }
void CResourceQueryRequest::setPageStartFrom_null(){ m_PageStartFrom.Nil(); }void CResourceQueryRequest::setPageStartFrom(__int64 val){ m_PageStartFrom=val; }
void CResourceQueryRequest::setSortBy(CResourceSortBy val) { m_SortBy.setValue(val); }
void CResourceQueryRequest::setSortBy(const char* val) { m_SortBy.setValue(val); }
void CResourceQueryRequest::setDescending_null(){ m_Descending.Nil(); }void CResourceQueryRequest::setDescending(bool val){ m_Descending=val; }
void CResourceQueryRequest::setCacheHint_null(){ m_CacheHint.Nil(); }void CResourceQueryRequest::setCacheHint(__int64 val){ m_CacheHint=val; }
extern "C"  IEspResourceQueryRequest *createResourceQueryRequest(const char *serv){return ((IEspResourceQueryRequest *)new CResourceQueryRequest(serv));}
extern "C"  IClientResourceQueryRequest *createClientResourceQueryRequest(const char *serv){return ((IClientResourceQueryRequest *)new CResourceQueryRequest(serv));}

//=======================================================
// class CResourceQueryResponse Implementation
//=======================================================

CResourceQueryResponse::CResourceQueryResponse(const char *serviceName, IRpcMessageBinding *init)
	: m_NoSecMngr(0, nilRemove,false),m_Resources(nilRemove),m_TotalResources(nilRemove),m_CacheHint(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ResourceQueryResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CResourceQueryResponse::CResourceQueryResponse(const char *serviceName, const char *bc)
	: m_NoSecMngr(0, nilRemove,false),m_Resources(nilRemove),m_TotalResources(nilRemove),m_CacheHint(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ResourceQueryResponse");
}

CResourceQueryResponse::CResourceQueryResponse(const char *serviceName, IRpcMessage* rpcmsg)
	: m_NoSecMngr(0, nilRemove,false),m_Resources(nilRemove),m_TotalResources(nilRemove),m_CacheHint(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ResourceQueryResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CResourceQueryResponse::CResourceQueryResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_NoSecMngr(0, nilRemove,false),m_Resources(nilRemove),m_TotalResources(nilRemove),m_CacheHint(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ResourceQueryResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CResourceQueryResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" default=\"false\" name=\"NoSecMngr\" type=\"xsd:boolean\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Resources\">\n");
		schema.append("<xsd:complexType><xsd:sequence>\n");
		schema.append("<xsd:element minOccurs=\"0\" maxOccurs=\"unbounded\" name=\"Resource\" type=\"tns:Resource\"/>");
		schema.append("</xsd:sequence></xsd:complexType>");
		schema.append("</xsd:element>");
		schema.append("<xsd:element minOccurs=\"0\" name=\"TotalResources\" type=\"xsd:long\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"CacheHint\" type=\"xsd:long\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	if (!(flags & 0x10)  || (flags & 0x100))
	{
		CResource::getXsdDefinition(context, request, schema, added);
	}
	return schema;
}

void CResourceQueryResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CResourceQueryResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
	if (!added.getValue("Resource"))
	{
		added.setValue("Resource",1);
		CResource::getMapInfo(info,added);
	}
}

StringBuffer &CResourceQueryResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("NoSecMngr");
	
	form.appendf("  <tr><td><b>NoSecMngr? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Resources");
	form.appendf("<tr><td><b>Resources: </b></td><td>");
	form.appendf("<table><tr><td><textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea></td>", extfix.str());
	form.append("</tr></table>");
	form.append("</td></tr>");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("TotalResources");
	form.appendf("  <tr><td><b>TotalResources: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("CacheHint");
	form.appendf("  <tr><td><b>CacheHint: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CResourceQueryResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CResourceQueryResponse::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
		m_NoSecMngr.marshall(rpc_resp, "NoSecMngr", "", "", "");
		m_Resources.marshall(rpc_resp, "Resources", "Resource");
		m_TotalResources.marshall(rpc_resp, "TotalResources", "", "", "");
		m_CacheHint.marshall(rpc_resp, "CacheHint", "", "", "");
	}
}


void CResourceQueryResponse::copy(CResourceQueryResponse &from)
{
	m_NoSecMngr.copy(from.m_NoSecMngr);
	m_Resources.copy(from.m_Resources);
	m_TotalResources.copy(from.m_TotalResources);
	m_CacheHint.copy(from.m_CacheHint);
}


void CResourceQueryResponse::copy(IConstResourceQueryResponse &ifrom)
{
	setNoSecMngr(ifrom.getNoSecMngr());
	setResources(ifrom.getResources());
	setTotalResources(ifrom.getTotalResources());
	setCacheHint(ifrom.getCacheHint());
}


void CResourceQueryResponse::getAttributes(IProperties &attributes)
{
}


void CResourceQueryResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
		m_NoSecMngr.toStr(ctx, buffer, "NoSecMngr", "", true, "", "");
		m_Resources.toStr(ctx, buffer, "Resources", "Resource");
		m_TotalResources.toStr(ctx, buffer, "TotalResources", "", true, "", "");
		m_CacheHint.toStr(ctx, buffer, "CacheHint", "", true, "", "");
	}
}


void CResourceQueryResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CResourceQueryResponse::serializer(IEspContext* ctx, IConstResourceQueryResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<ResourceQueryResponse>");
	// field NoSecMngr
	{
		bool b = src.getNoSecMngr();
		if (b)
			buffer.appendf("<NoSecMngr>1</NoSecMngr>");
	}
	// field Resources
	{
		IArrayOf<IConstResource>& v = src.getResources();
		int size = v.length();
		if (size>0)
			buffer.append("<Resources>");
		for (int i=0;i<size;i++)
		{
			buffer.append("<Resource>");
			CResource::serializer(ctx,v.item(i),buffer,false);
			buffer.append("</Resource>");
		}
		if (size>0)
			buffer.append("</Resources>");
	}
	// field TotalResources
	{
		//*** default kind: TK_INT; type=int64, name=TotalResources
		buffer.append("<TotalResources>");
		buffer.append(src.getTotalResources());
		buffer.append("</TotalResources>");
	}
	// field CacheHint
	{
		//*** default kind: TK_INT; type=int64, name=CacheHint
		buffer.append("<CacheHint>");
		buffer.append(src.getCacheHint());
		buffer.append("</CacheHint>");
	}
	if (keepRootTag)
		buffer.append("</ResourceQueryResponse>");
}

bool CResourceQueryResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
		hasValue |= m_NoSecMngr.unmarshall(rpc_request, "NoSecMngr", basepath);
		hasValue |= m_Resources.unmarshall(rpc_request, "Resources", basepath);
		hasValue |= m_TotalResources.unmarshall(rpc_request, "TotalResources", basepath);
		hasValue |= m_CacheHint.unmarshall(rpc_request, "CacheHint", basepath);
	}
	return hasValue;
}

bool CResourceQueryResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_NoSecMngr.unmarshall(ctx, soapval, "NoSecMngr");
	hasValue |= m_Resources.unmarshall(ctx, soapval, "Resources");
	hasValue |= m_TotalResources.unmarshall(ctx, soapval, "TotalResources");
	hasValue |= m_CacheHint.unmarshall(ctx, soapval, "CacheHint");
	return hasValue;
}

bool CResourceQueryResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_NoSecMngr.unmarshall(ctx, params, attachments, "NoSecMngr", basepath);
	hasValue |= m_Resources.unmarshall(ctx, params, attachments, "Resources", basepath);
	hasValue |= m_TotalResources.unmarshall(ctx, params, attachments, "TotalResources", basepath);
	hasValue |= m_CacheHint.unmarshall(ctx, params, attachments, "CacheHint", basepath);
	return hasValue;
}

bool CResourceQueryResponse::getNoSecMngr_isNull(){return m_NoSecMngr.is_nil();}
bool CResourceQueryResponse::getNoSecMngr() { return m_NoSecMngr;}
IArrayOf<IConstResource> & CResourceQueryResponse::getResources() { return (IArrayOf<IConstResource> &) m_Resources; }
bool CResourceQueryResponse::getTotalResources_isNull(){return m_TotalResources.is_nil();}
__int64 CResourceQueryResponse::getTotalResources() { return m_TotalResources;}
bool CResourceQueryResponse::getCacheHint_isNull(){return m_CacheHint.is_nil();}
__int64 CResourceQueryResponse::getCacheHint() { return m_CacheHint;}
void CResourceQueryResponse::setNoSecMngr_null(){ m_NoSecMngr.Nil(); }void CResourceQueryResponse::setNoSecMngr(bool val){ m_NoSecMngr=val; }
void CResourceQueryResponse::setResources(IArrayOf<IEspResource> &val)
{
	m_Resources->kill();
	IArrayOf<IConstResource> &target = m_Resources.getValue();
	ForEachItemIn(idx, val)
	{
		IEspResource &item = (val).item(idx);
		item.Link();
		target.append(item);
	}
}
void CResourceQueryResponse::setResources(IArrayOf<IConstResource> &val)
{
	m_Resources->kill();
	IArrayOf<IConstResource> &target = m_Resources.getValue();
	ForEachItemIn(idx, val)
	{
		IConstResource &item = val.item(idx);
		item.Link();
		target.append(item);
	}
}
void CResourceQueryResponse::setTotalResources_null(){ m_TotalResources.Nil(); }void CResourceQueryResponse::setTotalResources(__int64 val){ m_TotalResources=val; }
void CResourceQueryResponse::setCacheHint_null(){ m_CacheHint.Nil(); }void CResourceQueryResponse::setCacheHint(__int64 val){ m_CacheHint=val; }
extern "C"  IEspResourceQueryResponse *createResourceQueryResponse(const char *serv){return ((IEspResourceQueryResponse *)new CResourceQueryResponse(serv));}
extern "C"  IClientResourceQueryResponse *createClientResourceQueryResponse(const char *serv){return ((IClientResourceQueryResponse *)new CResourceQueryResponse(serv));}

//=======================================================
// class CResourceAddInputRequest Implementation
//=======================================================

CResourceAddInputRequest::CResourceAddInputRequest(const char *serviceName, IRpcMessageBinding *init)
	: m_basedn(nilIgnore),m_rtype(nilIgnore),m_rtitle(nilIgnore),m_prefix(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ResourceAddInputRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CResourceAddInputRequest::CResourceAddInputRequest(const char *serviceName, const char *bc)
	: m_basedn(nilIgnore),m_rtype(nilIgnore),m_rtitle(nilIgnore),m_prefix(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ResourceAddInputRequest");
}

CResourceAddInputRequest::CResourceAddInputRequest(const char *serviceName, IRpcMessage* rpcmsg)
	: m_basedn(nilIgnore),m_rtype(nilIgnore),m_rtitle(nilIgnore),m_prefix(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ResourceAddInputRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CResourceAddInputRequest::CResourceAddInputRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_basedn(nilIgnore),m_rtype(nilIgnore),m_rtitle(nilIgnore),m_prefix(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ResourceAddInputRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CResourceAddInputRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"basedn\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"rtype\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"rtitle\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"prefix\" type=\"xsd:string\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CResourceAddInputRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CResourceAddInputRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CResourceAddInputRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("basedn");
	form.appendf("  <tr><td><b>basedn: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("rtype");
	form.appendf("  <tr><td><b>rtype: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("rtitle");
	form.appendf("  <tr><td><b>rtitle: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("prefix");
	form.appendf("  <tr><td><b>prefix: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CResourceAddInputRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CResourceAddInputRequest::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_basedn.marshall(rpc_resp, "basedn", "", "", "");
	m_rtype.marshall(rpc_resp, "rtype", "", "", "");
	m_rtitle.marshall(rpc_resp, "rtitle", "", "", "");
	m_prefix.marshall(rpc_resp, "prefix", "", "", "");
}


void CResourceAddInputRequest::copy(CResourceAddInputRequest &from)
{
	m_basedn.copy(from.m_basedn);
	m_rtype.copy(from.m_rtype);
	m_rtitle.copy(from.m_rtitle);
	m_prefix.copy(from.m_prefix);
}


void CResourceAddInputRequest::copy(IConstResourceAddInputRequest &ifrom)
{
	setBasedn(ifrom.getBasedn());
	setRtype(ifrom.getRtype());
	setRtitle(ifrom.getRtitle());
	setPrefix(ifrom.getPrefix());
}


void CResourceAddInputRequest::getAttributes(IProperties &attributes)
{
}


void CResourceAddInputRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_basedn.toStr(ctx, buffer, "basedn", "", true, "", "");
	m_rtype.toStr(ctx, buffer, "rtype", "", true, "", "");
	m_rtitle.toStr(ctx, buffer, "rtitle", "", true, "", "");
	m_prefix.toStr(ctx, buffer, "prefix", "", true, "", "");
}


void CResourceAddInputRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CResourceAddInputRequest::serializer(IEspContext* ctx, IConstResourceAddInputRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<ResourceAddInputRequest>");
	// field basedn
	{
		const char* s = src.getBasedn();
		if (s && *s)
		{
			buffer.append("<basedn>");
			encodeUtf8XML(s,buffer);
			buffer.append("</basedn>");
		}
	}
	// field rtype
	{
		const char* s = src.getRtype();
		if (s && *s)
		{
			buffer.append("<rtype>");
			encodeUtf8XML(s,buffer);
			buffer.append("</rtype>");
		}
	}
	// field rtitle
	{
		const char* s = src.getRtitle();
		if (s && *s)
		{
			buffer.append("<rtitle>");
			encodeUtf8XML(s,buffer);
			buffer.append("</rtitle>");
		}
	}
	// field prefix
	{
		const char* s = src.getPrefix();
		if (s && *s)
		{
			buffer.append("<prefix>");
			encodeUtf8XML(s,buffer);
			buffer.append("</prefix>");
		}
	}
	if (keepRootTag)
		buffer.append("</ResourceAddInputRequest>");
}

bool CResourceAddInputRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_basedn.unmarshall(rpc_request, "basedn", basepath);
	hasValue |= m_rtype.unmarshall(rpc_request, "rtype", basepath);
	hasValue |= m_rtitle.unmarshall(rpc_request, "rtitle", basepath);
	hasValue |= m_prefix.unmarshall(rpc_request, "prefix", basepath);
	return hasValue;
}

bool CResourceAddInputRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_basedn.unmarshall(ctx, soapval, "basedn");
	hasValue |= m_rtype.unmarshall(ctx, soapval, "rtype");
	hasValue |= m_rtitle.unmarshall(ctx, soapval, "rtitle");
	hasValue |= m_prefix.unmarshall(ctx, soapval, "prefix");
	return hasValue;
}

bool CResourceAddInputRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_basedn.unmarshall(ctx, params, attachments, "basedn", basepath);
	hasValue |= m_rtype.unmarshall(ctx, params, attachments, "rtype", basepath);
	hasValue |= m_rtitle.unmarshall(ctx, params, attachments, "rtitle", basepath);
	hasValue |= m_prefix.unmarshall(ctx, params, attachments, "prefix", basepath);
	return hasValue;
}

const char * CResourceAddInputRequest::getBasedn() { return m_basedn.query();}
const char * CResourceAddInputRequest::getRtype() { return m_rtype.query();}
const char * CResourceAddInputRequest::getRtitle() { return m_rtitle.query();}
const char * CResourceAddInputRequest::getPrefix() { return m_prefix.query();}
void CResourceAddInputRequest::setBasedn(const char * val){ m_basedn.set(val); }
void CResourceAddInputRequest::setRtype(const char * val){ m_rtype.set(val); }
void CResourceAddInputRequest::setRtitle(const char * val){ m_rtitle.set(val); }
void CResourceAddInputRequest::setPrefix(const char * val){ m_prefix.set(val); }
extern "C"  IEspResourceAddInputRequest *createResourceAddInputRequest(const char *serv){return ((IEspResourceAddInputRequest *)new CResourceAddInputRequest(serv));}
extern "C"  IClientResourceAddInputRequest *createClientResourceAddInputRequest(const char *serv){return ((IClientResourceAddInputRequest *)new CResourceAddInputRequest(serv));}

//=======================================================
// class CResourceAddInputResponse Implementation
//=======================================================

CResourceAddInputResponse::CResourceAddInputResponse(const char *serviceName, IRpcMessageBinding *init)
	: m_basedn(nilIgnore),m_rtype(nilIgnore),m_rtitle(nilIgnore),m_prefix(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ResourceAddInputResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CResourceAddInputResponse::CResourceAddInputResponse(const char *serviceName, const char *bc)
	: m_basedn(nilIgnore),m_rtype(nilIgnore),m_rtitle(nilIgnore),m_prefix(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ResourceAddInputResponse");
}

CResourceAddInputResponse::CResourceAddInputResponse(const char *serviceName, IRpcMessage* rpcmsg)
	: m_basedn(nilIgnore),m_rtype(nilIgnore),m_rtitle(nilIgnore),m_prefix(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ResourceAddInputResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CResourceAddInputResponse::CResourceAddInputResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_basedn(nilIgnore),m_rtype(nilIgnore),m_rtitle(nilIgnore),m_prefix(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ResourceAddInputResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CResourceAddInputResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"basedn\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"rtype\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"rtitle\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"prefix\" type=\"xsd:string\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CResourceAddInputResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CResourceAddInputResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CResourceAddInputResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("basedn");
	form.appendf("  <tr><td><b>basedn: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("rtype");
	form.appendf("  <tr><td><b>rtype: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("rtitle");
	form.appendf("  <tr><td><b>rtitle: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("prefix");
	form.appendf("  <tr><td><b>prefix: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CResourceAddInputResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CResourceAddInputResponse::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
		m_basedn.marshall(rpc_resp, "basedn", "", "", "");
		m_rtype.marshall(rpc_resp, "rtype", "", "", "");
		m_rtitle.marshall(rpc_resp, "rtitle", "", "", "");
		m_prefix.marshall(rpc_resp, "prefix", "", "", "");
	}
}


void CResourceAddInputResponse::copy(CResourceAddInputResponse &from)
{
	m_basedn.copy(from.m_basedn);
	m_rtype.copy(from.m_rtype);
	m_rtitle.copy(from.m_rtitle);
	m_prefix.copy(from.m_prefix);
}


void CResourceAddInputResponse::copy(IConstResourceAddInputResponse &ifrom)
{
	setBasedn(ifrom.getBasedn());
	setRtype(ifrom.getRtype());
	setRtitle(ifrom.getRtitle());
	setPrefix(ifrom.getPrefix());
}


void CResourceAddInputResponse::getAttributes(IProperties &attributes)
{
}


void CResourceAddInputResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
		m_basedn.toStr(ctx, buffer, "basedn", "", true, "", "");
		m_rtype.toStr(ctx, buffer, "rtype", "", true, "", "");
		m_rtitle.toStr(ctx, buffer, "rtitle", "", true, "", "");
		m_prefix.toStr(ctx, buffer, "prefix", "", true, "", "");
	}
}


void CResourceAddInputResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CResourceAddInputResponse::serializer(IEspContext* ctx, IConstResourceAddInputResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<ResourceAddInputResponse>");
	// field basedn
	{
		const char* s = src.getBasedn();
		if (s && *s)
		{
			buffer.append("<basedn>");
			encodeUtf8XML(s,buffer);
			buffer.append("</basedn>");
		}
	}
	// field rtype
	{
		const char* s = src.getRtype();
		if (s && *s)
		{
			buffer.append("<rtype>");
			encodeUtf8XML(s,buffer);
			buffer.append("</rtype>");
		}
	}
	// field rtitle
	{
		const char* s = src.getRtitle();
		if (s && *s)
		{
			buffer.append("<rtitle>");
			encodeUtf8XML(s,buffer);
			buffer.append("</rtitle>");
		}
	}
	// field prefix
	{
		const char* s = src.getPrefix();
		if (s && *s)
		{
			buffer.append("<prefix>");
			encodeUtf8XML(s,buffer);
			buffer.append("</prefix>");
		}
	}
	if (keepRootTag)
		buffer.append("</ResourceAddInputResponse>");
}

bool CResourceAddInputResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
		hasValue |= m_basedn.unmarshall(rpc_request, "basedn", basepath);
		hasValue |= m_rtype.unmarshall(rpc_request, "rtype", basepath);
		hasValue |= m_rtitle.unmarshall(rpc_request, "rtitle", basepath);
		hasValue |= m_prefix.unmarshall(rpc_request, "prefix", basepath);
	}
	return hasValue;
}

bool CResourceAddInputResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_basedn.unmarshall(ctx, soapval, "basedn");
	hasValue |= m_rtype.unmarshall(ctx, soapval, "rtype");
	hasValue |= m_rtitle.unmarshall(ctx, soapval, "rtitle");
	hasValue |= m_prefix.unmarshall(ctx, soapval, "prefix");
	return hasValue;
}

bool CResourceAddInputResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_basedn.unmarshall(ctx, params, attachments, "basedn", basepath);
	hasValue |= m_rtype.unmarshall(ctx, params, attachments, "rtype", basepath);
	hasValue |= m_rtitle.unmarshall(ctx, params, attachments, "rtitle", basepath);
	hasValue |= m_prefix.unmarshall(ctx, params, attachments, "prefix", basepath);
	return hasValue;
}

const char * CResourceAddInputResponse::getBasedn() { return m_basedn.query();}
const char * CResourceAddInputResponse::getRtype() { return m_rtype.query();}
const char * CResourceAddInputResponse::getRtitle() { return m_rtitle.query();}
const char * CResourceAddInputResponse::getPrefix() { return m_prefix.query();}
void CResourceAddInputResponse::setBasedn(const char * val){ m_basedn.set(val); }
void CResourceAddInputResponse::setRtype(const char * val){ m_rtype.set(val); }
void CResourceAddInputResponse::setRtitle(const char * val){ m_rtitle.set(val); }
void CResourceAddInputResponse::setPrefix(const char * val){ m_prefix.set(val); }
extern "C"  IEspResourceAddInputResponse *createResourceAddInputResponse(const char *serv){return ((IEspResourceAddInputResponse *)new CResourceAddInputResponse(serv));}
extern "C"  IClientResourceAddInputResponse *createClientResourceAddInputResponse(const char *serv){return ((IClientResourceAddInputResponse *)new CResourceAddInputResponse(serv));}

//=======================================================
// class CResourceAddRequest Implementation
//=======================================================

CResourceAddRequest::CResourceAddRequest(const char *serviceName, IRpcMessageBinding *init)
	: m_basedn(nilIgnore),m_rtype(nilIgnore),m_rtitle(nilIgnore),m_name(nilIgnore),m_description(nilIgnore),m_prefix(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ResourceAddRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CResourceAddRequest::CResourceAddRequest(const char *serviceName, const char *bc)
	: m_basedn(nilIgnore),m_rtype(nilIgnore),m_rtitle(nilIgnore),m_name(nilIgnore),m_description(nilIgnore),m_prefix(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ResourceAddRequest");
}

CResourceAddRequest::CResourceAddRequest(const char *serviceName, IRpcMessage* rpcmsg)
	: m_basedn(nilIgnore),m_rtype(nilIgnore),m_rtitle(nilIgnore),m_name(nilIgnore),m_description(nilIgnore),m_prefix(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ResourceAddRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CResourceAddRequest::CResourceAddRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_basedn(nilIgnore),m_rtype(nilIgnore),m_rtitle(nilIgnore),m_name(nilIgnore),m_description(nilIgnore),m_prefix(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ResourceAddRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CResourceAddRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"basedn\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"rtype\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"rtitle\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"name\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"description\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"prefix\" type=\"xsd:string\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CResourceAddRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CResourceAddRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CResourceAddRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("basedn");
	form.appendf("  <tr><td><b>basedn: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("rtype");
	form.appendf("  <tr><td><b>rtype: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("rtitle");
	form.appendf("  <tr><td><b>rtitle: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("name");
	form.appendf("  <tr><td><b>name: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("description");
	form.appendf("  <tr><td><b>description: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("prefix");
	form.appendf("  <tr><td><b>prefix: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CResourceAddRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CResourceAddRequest::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_basedn.marshall(rpc_resp, "basedn", "", "", "");
	m_rtype.marshall(rpc_resp, "rtype", "", "", "");
	m_rtitle.marshall(rpc_resp, "rtitle", "", "", "");
	m_name.marshall(rpc_resp, "name", "", "", "");
	m_description.marshall(rpc_resp, "description", "", "", "");
	m_prefix.marshall(rpc_resp, "prefix", "", "", "");
}


void CResourceAddRequest::copy(CResourceAddRequest &from)
{
	m_basedn.copy(from.m_basedn);
	m_rtype.copy(from.m_rtype);
	m_rtitle.copy(from.m_rtitle);
	m_name.copy(from.m_name);
	m_description.copy(from.m_description);
	m_prefix.copy(from.m_prefix);
}


void CResourceAddRequest::copy(IConstResourceAddRequest &ifrom)
{
	setBasedn(ifrom.getBasedn());
	setRtype(ifrom.getRtype());
	setRtitle(ifrom.getRtitle());
	setName(ifrom.getName());
	setDescription(ifrom.getDescription());
	setPrefix(ifrom.getPrefix());
}


void CResourceAddRequest::getAttributes(IProperties &attributes)
{
}


void CResourceAddRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_basedn.toStr(ctx, buffer, "basedn", "", true, "", "");
	m_rtype.toStr(ctx, buffer, "rtype", "", true, "", "");
	m_rtitle.toStr(ctx, buffer, "rtitle", "", true, "", "");
	m_name.toStr(ctx, buffer, "name", "", true, "", "");
	m_description.toStr(ctx, buffer, "description", "", true, "", "");
	m_prefix.toStr(ctx, buffer, "prefix", "", true, "", "");
}


void CResourceAddRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CResourceAddRequest::serializer(IEspContext* ctx, IConstResourceAddRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<ResourceAddRequest>");
	// field basedn
	{
		const char* s = src.getBasedn();
		if (s && *s)
		{
			buffer.append("<basedn>");
			encodeUtf8XML(s,buffer);
			buffer.append("</basedn>");
		}
	}
	// field rtype
	{
		const char* s = src.getRtype();
		if (s && *s)
		{
			buffer.append("<rtype>");
			encodeUtf8XML(s,buffer);
			buffer.append("</rtype>");
		}
	}
	// field rtitle
	{
		const char* s = src.getRtitle();
		if (s && *s)
		{
			buffer.append("<rtitle>");
			encodeUtf8XML(s,buffer);
			buffer.append("</rtitle>");
		}
	}
	// field name
	{
		const char* s = src.getName();
		if (s && *s)
		{
			buffer.append("<name>");
			encodeUtf8XML(s,buffer);
			buffer.append("</name>");
		}
	}
	// field description
	{
		const char* s = src.getDescription();
		if (s && *s)
		{
			buffer.append("<description>");
			encodeUtf8XML(s,buffer);
			buffer.append("</description>");
		}
	}
	// field prefix
	{
		const char* s = src.getPrefix();
		if (s && *s)
		{
			buffer.append("<prefix>");
			encodeUtf8XML(s,buffer);
			buffer.append("</prefix>");
		}
	}
	if (keepRootTag)
		buffer.append("</ResourceAddRequest>");
}

bool CResourceAddRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_basedn.unmarshall(rpc_request, "basedn", basepath);
	hasValue |= m_rtype.unmarshall(rpc_request, "rtype", basepath);
	hasValue |= m_rtitle.unmarshall(rpc_request, "rtitle", basepath);
	hasValue |= m_name.unmarshall(rpc_request, "name", basepath);
	hasValue |= m_description.unmarshall(rpc_request, "description", basepath);
	hasValue |= m_prefix.unmarshall(rpc_request, "prefix", basepath);
	return hasValue;
}

bool CResourceAddRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_basedn.unmarshall(ctx, soapval, "basedn");
	hasValue |= m_rtype.unmarshall(ctx, soapval, "rtype");
	hasValue |= m_rtitle.unmarshall(ctx, soapval, "rtitle");
	hasValue |= m_name.unmarshall(ctx, soapval, "name");
	hasValue |= m_description.unmarshall(ctx, soapval, "description");
	hasValue |= m_prefix.unmarshall(ctx, soapval, "prefix");
	return hasValue;
}

bool CResourceAddRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_basedn.unmarshall(ctx, params, attachments, "basedn", basepath);
	hasValue |= m_rtype.unmarshall(ctx, params, attachments, "rtype", basepath);
	hasValue |= m_rtitle.unmarshall(ctx, params, attachments, "rtitle", basepath);
	hasValue |= m_name.unmarshall(ctx, params, attachments, "name", basepath);
	hasValue |= m_description.unmarshall(ctx, params, attachments, "description", basepath);
	hasValue |= m_prefix.unmarshall(ctx, params, attachments, "prefix", basepath);
	return hasValue;
}

const char * CResourceAddRequest::getBasedn() { return m_basedn.query();}
const char * CResourceAddRequest::getRtype() { return m_rtype.query();}
const char * CResourceAddRequest::getRtitle() { return m_rtitle.query();}
const char * CResourceAddRequest::getName() { return m_name.query();}
const char * CResourceAddRequest::getDescription() { return m_description.query();}
const char * CResourceAddRequest::getPrefix() { return m_prefix.query();}
void CResourceAddRequest::setBasedn(const char * val){ m_basedn.set(val); }
void CResourceAddRequest::setRtype(const char * val){ m_rtype.set(val); }
void CResourceAddRequest::setRtitle(const char * val){ m_rtitle.set(val); }
void CResourceAddRequest::setName(const char * val){ m_name.set(val); }
void CResourceAddRequest::setDescription(const char * val){ m_description.set(val); }
void CResourceAddRequest::setPrefix(const char * val){ m_prefix.set(val); }
extern "C"  IEspResourceAddRequest *createResourceAddRequest(const char *serv){return ((IEspResourceAddRequest *)new CResourceAddRequest(serv));}
extern "C"  IClientResourceAddRequest *createClientResourceAddRequest(const char *serv){return ((IClientResourceAddRequest *)new CResourceAddRequest(serv));}

//=======================================================
// class CResourceAddResponse Implementation
//=======================================================

CResourceAddResponse::CResourceAddResponse(const char *serviceName, IRpcMessageBinding *init)
	: m_basedn(nilIgnore),m_rtype(nilIgnore),m_rtitle(nilIgnore),m_prefix(nilIgnore),m_retcode(nilIgnore),m_retmsg(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ResourceAddResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CResourceAddResponse::CResourceAddResponse(const char *serviceName, const char *bc)
	: m_basedn(nilIgnore),m_rtype(nilIgnore),m_rtitle(nilIgnore),m_prefix(nilIgnore),m_retcode(nilIgnore),m_retmsg(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ResourceAddResponse");
}

CResourceAddResponse::CResourceAddResponse(const char *serviceName, IRpcMessage* rpcmsg)
	: m_basedn(nilIgnore),m_rtype(nilIgnore),m_rtitle(nilIgnore),m_prefix(nilIgnore),m_retcode(nilIgnore),m_retmsg(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ResourceAddResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CResourceAddResponse::CResourceAddResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_basedn(nilIgnore),m_rtype(nilIgnore),m_rtitle(nilIgnore),m_prefix(nilIgnore),m_retcode(nilIgnore),m_retmsg(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ResourceAddResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CResourceAddResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"basedn\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"rtype\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"rtitle\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"prefix\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"retcode\" type=\"xsd:int\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"retmsg\" type=\"xsd:string\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CResourceAddResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CResourceAddResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CResourceAddResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("basedn");
	form.appendf("  <tr><td><b>basedn: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("rtype");
	form.appendf("  <tr><td><b>rtype: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("rtitle");
	form.appendf("  <tr><td><b>rtitle: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("prefix");
	form.appendf("  <tr><td><b>prefix: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix) extfix.append(prefix).append(".");
		extfix.append("retcode");
	form.appendf("  <tr><td><b>retcode: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("retmsg");
	form.appendf("  <tr><td><b>retmsg: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CResourceAddResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CResourceAddResponse::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
		m_basedn.marshall(rpc_resp, "basedn", "", "", "");
		m_rtype.marshall(rpc_resp, "rtype", "", "", "");
		m_rtitle.marshall(rpc_resp, "rtitle", "", "", "");
		m_prefix.marshall(rpc_resp, "prefix", "", "", "");
		m_retcode.marshall(rpc_resp, "retcode", "", "", "");
		m_retmsg.marshall(rpc_resp, "retmsg", "", "", "");
	}
}


void CResourceAddResponse::copy(CResourceAddResponse &from)
{
	m_basedn.copy(from.m_basedn);
	m_rtype.copy(from.m_rtype);
	m_rtitle.copy(from.m_rtitle);
	m_prefix.copy(from.m_prefix);
	m_retcode.copy(from.m_retcode);
	m_retmsg.copy(from.m_retmsg);
}


void CResourceAddResponse::copy(IConstResourceAddResponse &ifrom)
{
	setBasedn(ifrom.getBasedn());
	setRtype(ifrom.getRtype());
	setRtitle(ifrom.getRtitle());
	setPrefix(ifrom.getPrefix());
	setRetcode(ifrom.getRetcode());
	setRetmsg(ifrom.getRetmsg());
}


void CResourceAddResponse::getAttributes(IProperties &attributes)
{
}


void CResourceAddResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
		m_basedn.toStr(ctx, buffer, "basedn", "", true, "", "");
		m_rtype.toStr(ctx, buffer, "rtype", "", true, "", "");
		m_rtitle.toStr(ctx, buffer, "rtitle", "", true, "", "");
		m_prefix.toStr(ctx, buffer, "prefix", "", true, "", "");
		m_retcode.toStr(ctx, buffer, "retcode", "", true, "", "");
		m_retmsg.toStr(ctx, buffer, "retmsg", "", true, "", "");
	}
}


void CResourceAddResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CResourceAddResponse::serializer(IEspContext* ctx, IConstResourceAddResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<ResourceAddResponse>");
	// field basedn
	{
		const char* s = src.getBasedn();
		if (s && *s)
		{
			buffer.append("<basedn>");
			encodeUtf8XML(s,buffer);
			buffer.append("</basedn>");
		}
	}
	// field rtype
	{
		const char* s = src.getRtype();
		if (s && *s)
		{
			buffer.append("<rtype>");
			encodeUtf8XML(s,buffer);
			buffer.append("</rtype>");
		}
	}
	// field rtitle
	{
		const char* s = src.getRtitle();
		if (s && *s)
		{
			buffer.append("<rtitle>");
			encodeUtf8XML(s,buffer);
			buffer.append("</rtitle>");
		}
	}
	// field prefix
	{
		const char* s = src.getPrefix();
		if (s && *s)
		{
			buffer.append("<prefix>");
			encodeUtf8XML(s,buffer);
			buffer.append("</prefix>");
		}
	}
	// field retcode
	{
		int n = src.getRetcode();
		if (n)
			buffer.appendf("<retcode>%d</retcode>", n);
	}
	// field retmsg
	{
		const char* s = src.getRetmsg();
		if (s && *s)
		{
			buffer.append("<retmsg>");
			encodeUtf8XML(s,buffer);
			buffer.append("</retmsg>");
		}
	}
	if (keepRootTag)
		buffer.append("</ResourceAddResponse>");
}

bool CResourceAddResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
		hasValue |= m_basedn.unmarshall(rpc_request, "basedn", basepath);
		hasValue |= m_rtype.unmarshall(rpc_request, "rtype", basepath);
		hasValue |= m_rtitle.unmarshall(rpc_request, "rtitle", basepath);
		hasValue |= m_prefix.unmarshall(rpc_request, "prefix", basepath);
		hasValue |= m_retcode.unmarshall(rpc_request, "retcode", basepath);
		hasValue |= m_retmsg.unmarshall(rpc_request, "retmsg", basepath);
	}
	return hasValue;
}

bool CResourceAddResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_basedn.unmarshall(ctx, soapval, "basedn");
	hasValue |= m_rtype.unmarshall(ctx, soapval, "rtype");
	hasValue |= m_rtitle.unmarshall(ctx, soapval, "rtitle");
	hasValue |= m_prefix.unmarshall(ctx, soapval, "prefix");
	hasValue |= m_retcode.unmarshall(ctx, soapval, "retcode");
	hasValue |= m_retmsg.unmarshall(ctx, soapval, "retmsg");
	return hasValue;
}

bool CResourceAddResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_basedn.unmarshall(ctx, params, attachments, "basedn", basepath);
	hasValue |= m_rtype.unmarshall(ctx, params, attachments, "rtype", basepath);
	hasValue |= m_rtitle.unmarshall(ctx, params, attachments, "rtitle", basepath);
	hasValue |= m_prefix.unmarshall(ctx, params, attachments, "prefix", basepath);
	hasValue |= m_retcode.unmarshall(ctx, params, attachments, "retcode", basepath);
	hasValue |= m_retmsg.unmarshall(ctx, params, attachments, "retmsg", basepath);
	return hasValue;
}

const char * CResourceAddResponse::getBasedn() { return m_basedn.query();}
const char * CResourceAddResponse::getRtype() { return m_rtype.query();}
const char * CResourceAddResponse::getRtitle() { return m_rtitle.query();}
const char * CResourceAddResponse::getPrefix() { return m_prefix.query();}
int CResourceAddResponse::getRetcode() { return m_retcode;}
const char * CResourceAddResponse::getRetmsg() { return m_retmsg.query();}
void CResourceAddResponse::setBasedn(const char * val){ m_basedn.set(val); }
void CResourceAddResponse::setRtype(const char * val){ m_rtype.set(val); }
void CResourceAddResponse::setRtitle(const char * val){ m_rtitle.set(val); }
void CResourceAddResponse::setPrefix(const char * val){ m_prefix.set(val); }
void CResourceAddResponse::setRetcode(int val){ m_retcode=val; }
void CResourceAddResponse::setRetmsg(const char * val){ m_retmsg.set(val); }
extern "C"  IEspResourceAddResponse *createResourceAddResponse(const char *serv){return ((IEspResourceAddResponse *)new CResourceAddResponse(serv));}
extern "C"  IClientResourceAddResponse *createClientResourceAddResponse(const char *serv){return ((IClientResourceAddResponse *)new CResourceAddResponse(serv));}

//=======================================================
// class CResourceDeleteRequest Implementation
//=======================================================

CResourceDeleteRequest::CResourceDeleteRequest(const char *serviceName, IRpcMessageBinding *init)
	: m_basedn(nilIgnore),m_rtype(nilIgnore),m_rtitle(nilIgnore),m_prefix(nilIgnore),m_names(nilIgnore),m_DoUpdate(0, nilIgnore,false)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ResourceDeleteRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CResourceDeleteRequest::CResourceDeleteRequest(const char *serviceName, const char *bc)
	: m_basedn(nilIgnore),m_rtype(nilIgnore),m_rtitle(nilIgnore),m_prefix(nilIgnore),m_names(nilIgnore),m_DoUpdate(0, nilIgnore,false)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ResourceDeleteRequest");
}

CResourceDeleteRequest::CResourceDeleteRequest(const char *serviceName, IRpcMessage* rpcmsg)
	: m_basedn(nilIgnore),m_rtype(nilIgnore),m_rtitle(nilIgnore),m_prefix(nilIgnore),m_names(nilIgnore),m_DoUpdate(0, nilIgnore,false)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ResourceDeleteRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CResourceDeleteRequest::CResourceDeleteRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_basedn(nilIgnore),m_rtype(nilIgnore),m_rtitle(nilIgnore),m_prefix(nilIgnore),m_names(nilIgnore),m_DoUpdate(0, nilIgnore,false)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ResourceDeleteRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CResourceDeleteRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"basedn\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"rtype\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"rtitle\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"prefix\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"names\" type=\"tns:EspStringArray\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"DoUpdate\" type=\"xsd:int\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	if (added.getValue("EspStringArray")==NULL) {
		addEspNativeArray(schema,"string","EspStringArray");
		added.setValue("EspStringArray",1);
	}
	return schema;
}

void CResourceDeleteRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CResourceDeleteRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CResourceDeleteRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("basedn");
	form.appendf("  <tr><td><b>basedn: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("rtype");
	form.appendf("  <tr><td><b>rtype: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("rtitle");
	form.appendf("  <tr><td><b>rtitle: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("prefix");
	form.appendf("  <tr><td><b>prefix: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("names");
	form.appendf("<tr><td><b>names: </b></td><td>");
	form.appendf("<textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea>", extfix.str());
	form.append("</td></tr>");
	extfix.clear();
	if (prefix && *prefix) extfix.append(prefix).append(".");
		extfix.append("DoUpdate");
	form.appendf("  <tr><td><b>DoUpdate: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CResourceDeleteRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CResourceDeleteRequest::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_basedn.marshall(rpc_resp, "basedn", "", "", "");
	m_rtype.marshall(rpc_resp, "rtype", "", "", "");
	m_rtitle.marshall(rpc_resp, "rtitle", "", "", "");
	m_prefix.marshall(rpc_resp, "prefix", "", "", "");
	m_names.marshall(rpc_resp, "names", "Item");
	m_DoUpdate.marshall(rpc_resp, "DoUpdate", "", "", "");
}


void CResourceDeleteRequest::copy(CResourceDeleteRequest &from)
{
	m_basedn.copy(from.m_basedn);
	m_rtype.copy(from.m_rtype);
	m_rtitle.copy(from.m_rtitle);
	m_prefix.copy(from.m_prefix);
	m_names.copy(from.m_names);
	m_DoUpdate.copy(from.m_DoUpdate);
}


void CResourceDeleteRequest::copy(IConstResourceDeleteRequest &ifrom)
{
	setBasedn(ifrom.getBasedn());
	setRtype(ifrom.getRtype());
	setRtitle(ifrom.getRtitle());
	setPrefix(ifrom.getPrefix());
	setNames(ifrom.getNames());
	setDoUpdate(ifrom.getDoUpdate());
}


void CResourceDeleteRequest::getAttributes(IProperties &attributes)
{
}


void CResourceDeleteRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_basedn.toStr(ctx, buffer, "basedn", "", true, "", "");
	m_rtype.toStr(ctx, buffer, "rtype", "", true, "", "");
	m_rtitle.toStr(ctx, buffer, "rtitle", "", true, "", "");
	m_prefix.toStr(ctx, buffer, "prefix", "", true, "", "");
	m_names.toStr(ctx, buffer, "names", "Item");
	m_DoUpdate.toStr(ctx, buffer, "DoUpdate", "", true, "", "");
}


void CResourceDeleteRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CResourceDeleteRequest::serializer(IEspContext* ctx, IConstResourceDeleteRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<ResourceDeleteRequest>");
	// field basedn
	{
		const char* s = src.getBasedn();
		if (s && *s)
		{
			buffer.append("<basedn>");
			encodeUtf8XML(s,buffer);
			buffer.append("</basedn>");
		}
	}
	// field rtype
	{
		const char* s = src.getRtype();
		if (s && *s)
		{
			buffer.append("<rtype>");
			encodeUtf8XML(s,buffer);
			buffer.append("</rtype>");
		}
	}
	// field rtitle
	{
		const char* s = src.getRtitle();
		if (s && *s)
		{
			buffer.append("<rtitle>");
			encodeUtf8XML(s,buffer);
			buffer.append("</rtitle>");
		}
	}
	// field prefix
	{
		const char* s = src.getPrefix();
		if (s && *s)
		{
			buffer.append("<prefix>");
			encodeUtf8XML(s,buffer);
			buffer.append("</prefix>");
		}
	}
	// field names
	{
		StringArray& v = src.getNames();
		if (v.length()>0)
			buffer.append("<names>");
		for (size32_t i=0;i<v.length();i++)
			buffer.appendf("<Item>%s</Item>",v.item(i));
		if (v.length()>0)
			buffer.append("</names>");
	}
	// field DoUpdate
	{
		int n = src.getDoUpdate();
		if (n)
			buffer.appendf("<DoUpdate>%d</DoUpdate>", n);
	}
	if (keepRootTag)
		buffer.append("</ResourceDeleteRequest>");
}

bool CResourceDeleteRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_basedn.unmarshall(rpc_request, "basedn", basepath);
	hasValue |= m_rtype.unmarshall(rpc_request, "rtype", basepath);
	hasValue |= m_rtitle.unmarshall(rpc_request, "rtitle", basepath);
	hasValue |= m_prefix.unmarshall(rpc_request, "prefix", basepath);
	hasValue |= m_names.unmarshall(rpc_request, "names", basepath);
	hasValue |= m_DoUpdate.unmarshall(rpc_request, "DoUpdate", basepath);
	return hasValue;
}

bool CResourceDeleteRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_basedn.unmarshall(ctx, soapval, "basedn");
	hasValue |= m_rtype.unmarshall(ctx, soapval, "rtype");
	hasValue |= m_rtitle.unmarshall(ctx, soapval, "rtitle");
	hasValue |= m_prefix.unmarshall(ctx, soapval, "prefix");
	hasValue |= m_names.unmarshall(ctx, soapval, "names");
	hasValue |= m_DoUpdate.unmarshall(ctx, soapval, "DoUpdate");
	return hasValue;
}

bool CResourceDeleteRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_basedn.unmarshall(ctx, params, attachments, "basedn", basepath);
	hasValue |= m_rtype.unmarshall(ctx, params, attachments, "rtype", basepath);
	hasValue |= m_rtitle.unmarshall(ctx, params, attachments, "rtitle", basepath);
	hasValue |= m_prefix.unmarshall(ctx, params, attachments, "prefix", basepath);
	hasValue |= m_names.unmarshall(ctx, params, attachments, "names", basepath);
	hasValue |= m_DoUpdate.unmarshall(ctx, params, attachments, "DoUpdate", basepath);
	return hasValue;
}

const char * CResourceDeleteRequest::getBasedn() { return m_basedn.query();}
const char * CResourceDeleteRequest::getRtype() { return m_rtype.query();}
const char * CResourceDeleteRequest::getRtitle() { return m_rtitle.query();}
const char * CResourceDeleteRequest::getPrefix() { return m_prefix.query();}
StringArray & CResourceDeleteRequest::getNames() { return (StringArray &) m_names; }
int CResourceDeleteRequest::getDoUpdate() { return m_DoUpdate;}
void CResourceDeleteRequest::setBasedn(const char * val){ m_basedn.set(val); }
void CResourceDeleteRequest::setRtype(const char * val){ m_rtype.set(val); }
void CResourceDeleteRequest::setRtitle(const char * val){ m_rtitle.set(val); }
void CResourceDeleteRequest::setPrefix(const char * val){ m_prefix.set(val); }
void CResourceDeleteRequest::setNames(StringArray &val){ m_names->kill();  CloneArray(m_names.getValue(), val); }
void CResourceDeleteRequest::setDoUpdate(int val){ m_DoUpdate=val; }
extern "C"  IEspResourceDeleteRequest *createResourceDeleteRequest(const char *serv){return ((IEspResourceDeleteRequest *)new CResourceDeleteRequest(serv));}
extern "C"  IClientResourceDeleteRequest *createClientResourceDeleteRequest(const char *serv){return ((IClientResourceDeleteRequest *)new CResourceDeleteRequest(serv));}

//=======================================================
// class CResourceDeleteResponse Implementation
//=======================================================

CResourceDeleteResponse::CResourceDeleteResponse(const char *serviceName, IRpcMessageBinding *init)
	: m_basedn(nilIgnore),m_rtype(nilIgnore),m_rtitle(nilIgnore),m_prefix(nilIgnore),m_retcode(nilIgnore),m_retmsg(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ResourceDeleteResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CResourceDeleteResponse::CResourceDeleteResponse(const char *serviceName, const char *bc)
	: m_basedn(nilIgnore),m_rtype(nilIgnore),m_rtitle(nilIgnore),m_prefix(nilIgnore),m_retcode(nilIgnore),m_retmsg(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ResourceDeleteResponse");
}

CResourceDeleteResponse::CResourceDeleteResponse(const char *serviceName, IRpcMessage* rpcmsg)
	: m_basedn(nilIgnore),m_rtype(nilIgnore),m_rtitle(nilIgnore),m_prefix(nilIgnore),m_retcode(nilIgnore),m_retmsg(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ResourceDeleteResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CResourceDeleteResponse::CResourceDeleteResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_basedn(nilIgnore),m_rtype(nilIgnore),m_rtitle(nilIgnore),m_prefix(nilIgnore),m_retcode(nilIgnore),m_retmsg(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ResourceDeleteResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CResourceDeleteResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"basedn\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"rtype\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"rtitle\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"prefix\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"retcode\" type=\"xsd:int\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"retmsg\" type=\"xsd:string\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CResourceDeleteResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CResourceDeleteResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CResourceDeleteResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("basedn");
	form.appendf("  <tr><td><b>basedn: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("rtype");
	form.appendf("  <tr><td><b>rtype: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("rtitle");
	form.appendf("  <tr><td><b>rtitle: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("prefix");
	form.appendf("  <tr><td><b>prefix: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix) extfix.append(prefix).append(".");
		extfix.append("retcode");
	form.appendf("  <tr><td><b>retcode: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("retmsg");
	form.appendf("  <tr><td><b>retmsg: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CResourceDeleteResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CResourceDeleteResponse::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
		m_basedn.marshall(rpc_resp, "basedn", "", "", "");
		m_rtype.marshall(rpc_resp, "rtype", "", "", "");
		m_rtitle.marshall(rpc_resp, "rtitle", "", "", "");
		m_prefix.marshall(rpc_resp, "prefix", "", "", "");
		m_retcode.marshall(rpc_resp, "retcode", "", "", "");
		m_retmsg.marshall(rpc_resp, "retmsg", "", "", "");
	}
}


void CResourceDeleteResponse::copy(CResourceDeleteResponse &from)
{
	m_basedn.copy(from.m_basedn);
	m_rtype.copy(from.m_rtype);
	m_rtitle.copy(from.m_rtitle);
	m_prefix.copy(from.m_prefix);
	m_retcode.copy(from.m_retcode);
	m_retmsg.copy(from.m_retmsg);
}


void CResourceDeleteResponse::copy(IConstResourceDeleteResponse &ifrom)
{
	setBasedn(ifrom.getBasedn());
	setRtype(ifrom.getRtype());
	setRtitle(ifrom.getRtitle());
	setPrefix(ifrom.getPrefix());
	setRetcode(ifrom.getRetcode());
	setRetmsg(ifrom.getRetmsg());
}


void CResourceDeleteResponse::getAttributes(IProperties &attributes)
{
}


void CResourceDeleteResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
		m_basedn.toStr(ctx, buffer, "basedn", "", true, "", "");
		m_rtype.toStr(ctx, buffer, "rtype", "", true, "", "");
		m_rtitle.toStr(ctx, buffer, "rtitle", "", true, "", "");
		m_prefix.toStr(ctx, buffer, "prefix", "", true, "", "");
		m_retcode.toStr(ctx, buffer, "retcode", "", true, "", "");
		m_retmsg.toStr(ctx, buffer, "retmsg", "", true, "", "");
	}
}


void CResourceDeleteResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CResourceDeleteResponse::serializer(IEspContext* ctx, IConstResourceDeleteResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<ResourceDeleteResponse>");
	// field basedn
	{
		const char* s = src.getBasedn();
		if (s && *s)
		{
			buffer.append("<basedn>");
			encodeUtf8XML(s,buffer);
			buffer.append("</basedn>");
		}
	}
	// field rtype
	{
		const char* s = src.getRtype();
		if (s && *s)
		{
			buffer.append("<rtype>");
			encodeUtf8XML(s,buffer);
			buffer.append("</rtype>");
		}
	}
	// field rtitle
	{
		const char* s = src.getRtitle();
		if (s && *s)
		{
			buffer.append("<rtitle>");
			encodeUtf8XML(s,buffer);
			buffer.append("</rtitle>");
		}
	}
	// field prefix
	{
		const char* s = src.getPrefix();
		if (s && *s)
		{
			buffer.append("<prefix>");
			encodeUtf8XML(s,buffer);
			buffer.append("</prefix>");
		}
	}
	// field retcode
	{
		int n = src.getRetcode();
		if (n)
			buffer.appendf("<retcode>%d</retcode>", n);
	}
	// field retmsg
	{
		const char* s = src.getRetmsg();
		if (s && *s)
		{
			buffer.append("<retmsg>");
			encodeUtf8XML(s,buffer);
			buffer.append("</retmsg>");
		}
	}
	if (keepRootTag)
		buffer.append("</ResourceDeleteResponse>");
}

bool CResourceDeleteResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
		hasValue |= m_basedn.unmarshall(rpc_request, "basedn", basepath);
		hasValue |= m_rtype.unmarshall(rpc_request, "rtype", basepath);
		hasValue |= m_rtitle.unmarshall(rpc_request, "rtitle", basepath);
		hasValue |= m_prefix.unmarshall(rpc_request, "prefix", basepath);
		hasValue |= m_retcode.unmarshall(rpc_request, "retcode", basepath);
		hasValue |= m_retmsg.unmarshall(rpc_request, "retmsg", basepath);
	}
	return hasValue;
}

bool CResourceDeleteResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_basedn.unmarshall(ctx, soapval, "basedn");
	hasValue |= m_rtype.unmarshall(ctx, soapval, "rtype");
	hasValue |= m_rtitle.unmarshall(ctx, soapval, "rtitle");
	hasValue |= m_prefix.unmarshall(ctx, soapval, "prefix");
	hasValue |= m_retcode.unmarshall(ctx, soapval, "retcode");
	hasValue |= m_retmsg.unmarshall(ctx, soapval, "retmsg");
	return hasValue;
}

bool CResourceDeleteResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_basedn.unmarshall(ctx, params, attachments, "basedn", basepath);
	hasValue |= m_rtype.unmarshall(ctx, params, attachments, "rtype", basepath);
	hasValue |= m_rtitle.unmarshall(ctx, params, attachments, "rtitle", basepath);
	hasValue |= m_prefix.unmarshall(ctx, params, attachments, "prefix", basepath);
	hasValue |= m_retcode.unmarshall(ctx, params, attachments, "retcode", basepath);
	hasValue |= m_retmsg.unmarshall(ctx, params, attachments, "retmsg", basepath);
	return hasValue;
}

const char * CResourceDeleteResponse::getBasedn() { return m_basedn.query();}
const char * CResourceDeleteResponse::getRtype() { return m_rtype.query();}
const char * CResourceDeleteResponse::getRtitle() { return m_rtitle.query();}
const char * CResourceDeleteResponse::getPrefix() { return m_prefix.query();}
int CResourceDeleteResponse::getRetcode() { return m_retcode;}
const char * CResourceDeleteResponse::getRetmsg() { return m_retmsg.query();}
void CResourceDeleteResponse::setBasedn(const char * val){ m_basedn.set(val); }
void CResourceDeleteResponse::setRtype(const char * val){ m_rtype.set(val); }
void CResourceDeleteResponse::setRtitle(const char * val){ m_rtitle.set(val); }
void CResourceDeleteResponse::setPrefix(const char * val){ m_prefix.set(val); }
void CResourceDeleteResponse::setRetcode(int val){ m_retcode=val; }
void CResourceDeleteResponse::setRetmsg(const char * val){ m_retmsg.set(val); }
extern "C"  IEspResourceDeleteResponse *createResourceDeleteResponse(const char *serv){return ((IEspResourceDeleteResponse *)new CResourceDeleteResponse(serv));}
extern "C"  IClientResourceDeleteResponse *createClientResourceDeleteResponse(const char *serv){return ((IClientResourceDeleteResponse *)new CResourceDeleteResponse(serv));}

//=======================================================
// class CResourcePermissionsRequest Implementation
//=======================================================

CResourcePermissionsRequest::CResourcePermissionsRequest(const char *serviceName, IRpcMessageBinding *init)
	: m_basedn(nilIgnore),m_rtype(nilIgnore),m_name(nilIgnore),m_rtitle(nilIgnore),m_prefix(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ResourcePermissionsRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CResourcePermissionsRequest::CResourcePermissionsRequest(const char *serviceName, const char *bc)
	: m_basedn(nilIgnore),m_rtype(nilIgnore),m_name(nilIgnore),m_rtitle(nilIgnore),m_prefix(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ResourcePermissionsRequest");
}

CResourcePermissionsRequest::CResourcePermissionsRequest(const char *serviceName, IRpcMessage* rpcmsg)
	: m_basedn(nilIgnore),m_rtype(nilIgnore),m_name(nilIgnore),m_rtitle(nilIgnore),m_prefix(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ResourcePermissionsRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CResourcePermissionsRequest::CResourcePermissionsRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_basedn(nilIgnore),m_rtype(nilIgnore),m_name(nilIgnore),m_rtitle(nilIgnore),m_prefix(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ResourcePermissionsRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CResourcePermissionsRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"basedn\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"rtype\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"name\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"rtitle\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"prefix\" type=\"xsd:string\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CResourcePermissionsRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CResourcePermissionsRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CResourcePermissionsRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("basedn");
	form.appendf("  <tr><td><b>basedn: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("rtype");
	form.appendf("  <tr><td><b>rtype: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("name");
	form.appendf("  <tr><td><b>name: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("rtitle");
	form.appendf("  <tr><td><b>rtitle: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("prefix");
	form.appendf("  <tr><td><b>prefix: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CResourcePermissionsRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CResourcePermissionsRequest::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_basedn.marshall(rpc_resp, "basedn", "", "", "");
	m_rtype.marshall(rpc_resp, "rtype", "", "", "");
	m_name.marshall(rpc_resp, "name", "", "", "");
	m_rtitle.marshall(rpc_resp, "rtitle", "", "", "");
	m_prefix.marshall(rpc_resp, "prefix", "", "", "");
}


void CResourcePermissionsRequest::copy(CResourcePermissionsRequest &from)
{
	m_basedn.copy(from.m_basedn);
	m_rtype.copy(from.m_rtype);
	m_name.copy(from.m_name);
	m_rtitle.copy(from.m_rtitle);
	m_prefix.copy(from.m_prefix);
}


void CResourcePermissionsRequest::copy(IConstResourcePermissionsRequest &ifrom)
{
	setBasedn(ifrom.getBasedn());
	setRtype(ifrom.getRtype());
	setName(ifrom.getName());
	setRtitle(ifrom.getRtitle());
	setPrefix(ifrom.getPrefix());
}


void CResourcePermissionsRequest::getAttributes(IProperties &attributes)
{
}


void CResourcePermissionsRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_basedn.toStr(ctx, buffer, "basedn", "", true, "", "");
	m_rtype.toStr(ctx, buffer, "rtype", "", true, "", "");
	m_name.toStr(ctx, buffer, "name", "", true, "", "");
	m_rtitle.toStr(ctx, buffer, "rtitle", "", true, "", "");
	m_prefix.toStr(ctx, buffer, "prefix", "", true, "", "");
}


void CResourcePermissionsRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CResourcePermissionsRequest::serializer(IEspContext* ctx, IConstResourcePermissionsRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<ResourcePermissionsRequest>");
	// field basedn
	{
		const char* s = src.getBasedn();
		if (s && *s)
		{
			buffer.append("<basedn>");
			encodeUtf8XML(s,buffer);
			buffer.append("</basedn>");
		}
	}
	// field rtype
	{
		const char* s = src.getRtype();
		if (s && *s)
		{
			buffer.append("<rtype>");
			encodeUtf8XML(s,buffer);
			buffer.append("</rtype>");
		}
	}
	// field name
	{
		const char* s = src.getName();
		if (s && *s)
		{
			buffer.append("<name>");
			encodeUtf8XML(s,buffer);
			buffer.append("</name>");
		}
	}
	// field rtitle
	{
		const char* s = src.getRtitle();
		if (s && *s)
		{
			buffer.append("<rtitle>");
			encodeUtf8XML(s,buffer);
			buffer.append("</rtitle>");
		}
	}
	// field prefix
	{
		const char* s = src.getPrefix();
		if (s && *s)
		{
			buffer.append("<prefix>");
			encodeUtf8XML(s,buffer);
			buffer.append("</prefix>");
		}
	}
	if (keepRootTag)
		buffer.append("</ResourcePermissionsRequest>");
}

bool CResourcePermissionsRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_basedn.unmarshall(rpc_request, "basedn", basepath);
	hasValue |= m_rtype.unmarshall(rpc_request, "rtype", basepath);
	hasValue |= m_name.unmarshall(rpc_request, "name", basepath);
	hasValue |= m_rtitle.unmarshall(rpc_request, "rtitle", basepath);
	hasValue |= m_prefix.unmarshall(rpc_request, "prefix", basepath);
	return hasValue;
}

bool CResourcePermissionsRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_basedn.unmarshall(ctx, soapval, "basedn");
	hasValue |= m_rtype.unmarshall(ctx, soapval, "rtype");
	hasValue |= m_name.unmarshall(ctx, soapval, "name");
	hasValue |= m_rtitle.unmarshall(ctx, soapval, "rtitle");
	hasValue |= m_prefix.unmarshall(ctx, soapval, "prefix");
	return hasValue;
}

bool CResourcePermissionsRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_basedn.unmarshall(ctx, params, attachments, "basedn", basepath);
	hasValue |= m_rtype.unmarshall(ctx, params, attachments, "rtype", basepath);
	hasValue |= m_name.unmarshall(ctx, params, attachments, "name", basepath);
	hasValue |= m_rtitle.unmarshall(ctx, params, attachments, "rtitle", basepath);
	hasValue |= m_prefix.unmarshall(ctx, params, attachments, "prefix", basepath);
	return hasValue;
}

const char * CResourcePermissionsRequest::getBasedn() { return m_basedn.query();}
const char * CResourcePermissionsRequest::getRtype() { return m_rtype.query();}
const char * CResourcePermissionsRequest::getName() { return m_name.query();}
const char * CResourcePermissionsRequest::getRtitle() { return m_rtitle.query();}
const char * CResourcePermissionsRequest::getPrefix() { return m_prefix.query();}
void CResourcePermissionsRequest::setBasedn(const char * val){ m_basedn.set(val); }
void CResourcePermissionsRequest::setRtype(const char * val){ m_rtype.set(val); }
void CResourcePermissionsRequest::setName(const char * val){ m_name.set(val); }
void CResourcePermissionsRequest::setRtitle(const char * val){ m_rtitle.set(val); }
void CResourcePermissionsRequest::setPrefix(const char * val){ m_prefix.set(val); }
extern "C"  IEspResourcePermissionsRequest *createResourcePermissionsRequest(const char *serv){return ((IEspResourcePermissionsRequest *)new CResourcePermissionsRequest(serv));}
extern "C"  IClientResourcePermissionsRequest *createClientResourcePermissionsRequest(const char *serv){return ((IClientResourcePermissionsRequest *)new CResourcePermissionsRequest(serv));}

//=======================================================
// class CResourcePermission Implementation
//=======================================================

CResourcePermission::CResourcePermission(const char *serviceName, IRpcMessageBinding *init)
	: m_account_name(nilIgnore),m_escaped_account_name(nilIgnore),m_account_type(nilIgnore),m_allow_access(nilIgnore),m_allow_read(nilIgnore),m_allow_write(nilIgnore),m_allow_full(nilIgnore),m_deny_access(nilIgnore),m_deny_read(nilIgnore),m_deny_write(nilIgnore),m_deny_full(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ResourcePermission");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CResourcePermission::CResourcePermission(const char *serviceName, const char *bc)
	: m_account_name(nilIgnore),m_escaped_account_name(nilIgnore),m_account_type(nilIgnore),m_allow_access(nilIgnore),m_allow_read(nilIgnore),m_allow_write(nilIgnore),m_allow_full(nilIgnore),m_deny_access(nilIgnore),m_deny_read(nilIgnore),m_deny_write(nilIgnore),m_deny_full(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ResourcePermission");
}

StringBuffer &CResourcePermission::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:complexType name=\"%s\">\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"account_name\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"escaped_account_name\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"account_type\" type=\"xsd:int\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"allow_access\" type=\"xsd:boolean\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"allow_read\" type=\"xsd:boolean\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"allow_write\" type=\"xsd:boolean\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"allow_full\" type=\"xsd:boolean\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"deny_access\" type=\"xsd:boolean\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"deny_read\" type=\"xsd:boolean\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"deny_write\" type=\"xsd:boolean\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"deny_full\" type=\"xsd:boolean\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType>\n");
		}
	}
	return schema;
}

void CResourcePermission::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CResourcePermission::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CResourcePermission::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("account_name");
	form.appendf("  <tr><td><b>account_name: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("escaped_account_name");
	form.appendf("  <tr><td><b>escaped_account_name: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix) extfix.append(prefix).append(".");
		extfix.append("account_type");
	form.appendf("  <tr><td><b>account_type: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("allow_access");
	
	form.appendf("  <tr><td><b>allow_access? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("allow_read");
	
	form.appendf("  <tr><td><b>allow_read? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("allow_write");
	
	form.appendf("  <tr><td><b>allow_write? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("allow_full");
	
	form.appendf("  <tr><td><b>allow_full? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("deny_access");
	
	form.appendf("  <tr><td><b>deny_access? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("deny_read");
	
	form.appendf("  <tr><td><b>deny_read? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("deny_write");
	
	form.appendf("  <tr><td><b>deny_write? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("deny_full");
	
	form.appendf("  <tr><td><b>deny_full? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CResourcePermission::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CResourcePermission::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_account_name.marshall(rpc_resp, "account_name", "", "", "");
	m_escaped_account_name.marshall(rpc_resp, "escaped_account_name", "", "", "");
	m_account_type.marshall(rpc_resp, "account_type", "", "", "");
	m_allow_access.marshall(rpc_resp, "allow_access", "", "", "");
	m_allow_read.marshall(rpc_resp, "allow_read", "", "", "");
	m_allow_write.marshall(rpc_resp, "allow_write", "", "", "");
	m_allow_full.marshall(rpc_resp, "allow_full", "", "", "");
	m_deny_access.marshall(rpc_resp, "deny_access", "", "", "");
	m_deny_read.marshall(rpc_resp, "deny_read", "", "", "");
	m_deny_write.marshall(rpc_resp, "deny_write", "", "", "");
	m_deny_full.marshall(rpc_resp, "deny_full", "", "", "");
}


void CResourcePermission::copy(CResourcePermission &from)
{
	m_account_name.copy(from.m_account_name);
	m_escaped_account_name.copy(from.m_escaped_account_name);
	m_account_type.copy(from.m_account_type);
	m_allow_access.copy(from.m_allow_access);
	m_allow_read.copy(from.m_allow_read);
	m_allow_write.copy(from.m_allow_write);
	m_allow_full.copy(from.m_allow_full);
	m_deny_access.copy(from.m_deny_access);
	m_deny_read.copy(from.m_deny_read);
	m_deny_write.copy(from.m_deny_write);
	m_deny_full.copy(from.m_deny_full);
}


void CResourcePermission::copy(IConstResourcePermission &ifrom)
{
	setAccount_name(ifrom.getAccount_name());
	setEscaped_account_name(ifrom.getEscaped_account_name());
	setAccount_type(ifrom.getAccount_type());
	setAllow_access(ifrom.getAllow_access());
	setAllow_read(ifrom.getAllow_read());
	setAllow_write(ifrom.getAllow_write());
	setAllow_full(ifrom.getAllow_full());
	setDeny_access(ifrom.getDeny_access());
	setDeny_read(ifrom.getDeny_read());
	setDeny_write(ifrom.getDeny_write());
	setDeny_full(ifrom.getDeny_full());
}


void CResourcePermission::getAttributes(IProperties &attributes)
{
}


void CResourcePermission::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_account_name.toStr(ctx, buffer, "account_name", "", true, "", "");
	m_escaped_account_name.toStr(ctx, buffer, "escaped_account_name", "", true, "", "");
	m_account_type.toStr(ctx, buffer, "account_type", "", true, "", "");
	m_allow_access.toStr(ctx, buffer, "allow_access", "", true, "", "");
	m_allow_read.toStr(ctx, buffer, "allow_read", "", true, "", "");
	m_allow_write.toStr(ctx, buffer, "allow_write", "", true, "", "");
	m_allow_full.toStr(ctx, buffer, "allow_full", "", true, "", "");
	m_deny_access.toStr(ctx, buffer, "deny_access", "", true, "", "");
	m_deny_read.toStr(ctx, buffer, "deny_read", "", true, "", "");
	m_deny_write.toStr(ctx, buffer, "deny_write", "", true, "", "");
	m_deny_full.toStr(ctx, buffer, "deny_full", "", true, "", "");
}


void CResourcePermission::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CResourcePermission::serializer(IEspContext* ctx, IConstResourcePermission &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<ResourcePermission>");
	// field account_name
	{
		const char* s = src.getAccount_name();
		if (s && *s)
		{
			buffer.append("<account_name>");
			encodeUtf8XML(s,buffer);
			buffer.append("</account_name>");
		}
	}
	// field escaped_account_name
	{
		const char* s = src.getEscaped_account_name();
		if (s && *s)
		{
			buffer.append("<escaped_account_name>");
			encodeUtf8XML(s,buffer);
			buffer.append("</escaped_account_name>");
		}
	}
	// field account_type
	{
		int n = src.getAccount_type();
		if (n)
			buffer.appendf("<account_type>%d</account_type>", n);
	}
	// field allow_access
	{
		bool b = src.getAllow_access();
		if (b)
			buffer.appendf("<allow_access>1</allow_access>");
	}
	// field allow_read
	{
		bool b = src.getAllow_read();
		if (b)
			buffer.appendf("<allow_read>1</allow_read>");
	}
	// field allow_write
	{
		bool b = src.getAllow_write();
		if (b)
			buffer.appendf("<allow_write>1</allow_write>");
	}
	// field allow_full
	{
		bool b = src.getAllow_full();
		if (b)
			buffer.appendf("<allow_full>1</allow_full>");
	}
	// field deny_access
	{
		bool b = src.getDeny_access();
		if (b)
			buffer.appendf("<deny_access>1</deny_access>");
	}
	// field deny_read
	{
		bool b = src.getDeny_read();
		if (b)
			buffer.appendf("<deny_read>1</deny_read>");
	}
	// field deny_write
	{
		bool b = src.getDeny_write();
		if (b)
			buffer.appendf("<deny_write>1</deny_write>");
	}
	// field deny_full
	{
		bool b = src.getDeny_full();
		if (b)
			buffer.appendf("<deny_full>1</deny_full>");
	}
	if (keepRootTag)
		buffer.append("</ResourcePermission>");
}

bool CResourcePermission::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_account_name.unmarshall(rpc_request, "account_name", basepath);
	hasValue |= m_escaped_account_name.unmarshall(rpc_request, "escaped_account_name", basepath);
	hasValue |= m_account_type.unmarshall(rpc_request, "account_type", basepath);
	hasValue |= m_allow_access.unmarshall(rpc_request, "allow_access", basepath);
	hasValue |= m_allow_read.unmarshall(rpc_request, "allow_read", basepath);
	hasValue |= m_allow_write.unmarshall(rpc_request, "allow_write", basepath);
	hasValue |= m_allow_full.unmarshall(rpc_request, "allow_full", basepath);
	hasValue |= m_deny_access.unmarshall(rpc_request, "deny_access", basepath);
	hasValue |= m_deny_read.unmarshall(rpc_request, "deny_read", basepath);
	hasValue |= m_deny_write.unmarshall(rpc_request, "deny_write", basepath);
	hasValue |= m_deny_full.unmarshall(rpc_request, "deny_full", basepath);
	return hasValue;
}

bool CResourcePermission::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_account_name.unmarshall(ctx, soapval, "account_name");
	hasValue |= m_escaped_account_name.unmarshall(ctx, soapval, "escaped_account_name");
	hasValue |= m_account_type.unmarshall(ctx, soapval, "account_type");
	hasValue |= m_allow_access.unmarshall(ctx, soapval, "allow_access");
	hasValue |= m_allow_read.unmarshall(ctx, soapval, "allow_read");
	hasValue |= m_allow_write.unmarshall(ctx, soapval, "allow_write");
	hasValue |= m_allow_full.unmarshall(ctx, soapval, "allow_full");
	hasValue |= m_deny_access.unmarshall(ctx, soapval, "deny_access");
	hasValue |= m_deny_read.unmarshall(ctx, soapval, "deny_read");
	hasValue |= m_deny_write.unmarshall(ctx, soapval, "deny_write");
	hasValue |= m_deny_full.unmarshall(ctx, soapval, "deny_full");
	return hasValue;
}

bool CResourcePermission::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_account_name.unmarshall(ctx, params, attachments, "account_name", basepath);
	hasValue |= m_escaped_account_name.unmarshall(ctx, params, attachments, "escaped_account_name", basepath);
	hasValue |= m_account_type.unmarshall(ctx, params, attachments, "account_type", basepath);
	hasValue |= m_allow_access.unmarshall(ctx, params, attachments, "allow_access", basepath);
	hasValue |= m_allow_read.unmarshall(ctx, params, attachments, "allow_read", basepath);
	hasValue |= m_allow_write.unmarshall(ctx, params, attachments, "allow_write", basepath);
	hasValue |= m_allow_full.unmarshall(ctx, params, attachments, "allow_full", basepath);
	hasValue |= m_deny_access.unmarshall(ctx, params, attachments, "deny_access", basepath);
	hasValue |= m_deny_read.unmarshall(ctx, params, attachments, "deny_read", basepath);
	hasValue |= m_deny_write.unmarshall(ctx, params, attachments, "deny_write", basepath);
	hasValue |= m_deny_full.unmarshall(ctx, params, attachments, "deny_full", basepath);
	return hasValue;
}

const char * CResourcePermission::getAccount_name() { return m_account_name.query();}
const char * CResourcePermission::getEscaped_account_name() { return m_escaped_account_name.query();}
int CResourcePermission::getAccount_type() { return m_account_type;}
bool CResourcePermission::getAllow_access() { return m_allow_access;}
bool CResourcePermission::getAllow_read() { return m_allow_read;}
bool CResourcePermission::getAllow_write() { return m_allow_write;}
bool CResourcePermission::getAllow_full() { return m_allow_full;}
bool CResourcePermission::getDeny_access() { return m_deny_access;}
bool CResourcePermission::getDeny_read() { return m_deny_read;}
bool CResourcePermission::getDeny_write() { return m_deny_write;}
bool CResourcePermission::getDeny_full() { return m_deny_full;}
void CResourcePermission::setAccount_name(const char * val){ m_account_name.set(val); }
void CResourcePermission::setEscaped_account_name(const char * val){ m_escaped_account_name.set(val); }
void CResourcePermission::setAccount_type(int val){ m_account_type=val; }
void CResourcePermission::setAllow_access(bool val){ m_allow_access=val; }
void CResourcePermission::setAllow_read(bool val){ m_allow_read=val; }
void CResourcePermission::setAllow_write(bool val){ m_allow_write=val; }
void CResourcePermission::setAllow_full(bool val){ m_allow_full=val; }
void CResourcePermission::setDeny_access(bool val){ m_deny_access=val; }
void CResourcePermission::setDeny_read(bool val){ m_deny_read=val; }
void CResourcePermission::setDeny_write(bool val){ m_deny_write=val; }
void CResourcePermission::setDeny_full(bool val){ m_deny_full=val; }
extern "C"  IEspResourcePermission *createResourcePermission(const char *serv, const char *msgname){return ((IEspResourcePermission *)new CResourcePermission(serv /*, msgname*/));}
extern "C"  IClientResourcePermission *createClientResourcePermission(const char *serv, const char *msgname){return ((IClientResourcePermission *)new CResourcePermission(serv /*, msgname*/));}

//=======================================================
// class CResourcePermissionsResponse Implementation
//=======================================================

CResourcePermissionsResponse::CResourcePermissionsResponse(const char *serviceName, IRpcMessageBinding *init)
	: m_basedn(nilIgnore),m_rtype(nilIgnore),m_name(nilIgnore),m_rtitle(nilIgnore),m_prefix(nilIgnore),m_Permissions(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ResourcePermissionsResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CResourcePermissionsResponse::CResourcePermissionsResponse(const char *serviceName, const char *bc)
	: m_basedn(nilIgnore),m_rtype(nilIgnore),m_name(nilIgnore),m_rtitle(nilIgnore),m_prefix(nilIgnore),m_Permissions(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ResourcePermissionsResponse");
}

CResourcePermissionsResponse::CResourcePermissionsResponse(const char *serviceName, IRpcMessage* rpcmsg)
	: m_basedn(nilIgnore),m_rtype(nilIgnore),m_name(nilIgnore),m_rtitle(nilIgnore),m_prefix(nilIgnore),m_Permissions(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ResourcePermissionsResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CResourcePermissionsResponse::CResourcePermissionsResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_basedn(nilIgnore),m_rtype(nilIgnore),m_name(nilIgnore),m_rtitle(nilIgnore),m_prefix(nilIgnore),m_Permissions(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ResourcePermissionsResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CResourcePermissionsResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"basedn\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"rtype\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"name\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"rtitle\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"prefix\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Permissions\">\n");
		schema.append("<xsd:complexType><xsd:sequence>\n");
		schema.append("<xsd:element minOccurs=\"0\" maxOccurs=\"unbounded\" name=\"Permission\" type=\"tns:ResourcePermission\"/>");
		schema.append("</xsd:sequence></xsd:complexType>");
		schema.append("</xsd:element>");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	if (!(flags & 0x10)  || (flags & 0x100))
	{
		CResourcePermission::getXsdDefinition(context, request, schema, added);
	}
	return schema;
}

void CResourcePermissionsResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CResourcePermissionsResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
	if (!added.getValue("ResourcePermission"))
	{
		added.setValue("ResourcePermission",1);
		CResourcePermission::getMapInfo(info,added);
	}
}

StringBuffer &CResourcePermissionsResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("basedn");
	form.appendf("  <tr><td><b>basedn: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("rtype");
	form.appendf("  <tr><td><b>rtype: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("name");
	form.appendf("  <tr><td><b>name: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("rtitle");
	form.appendf("  <tr><td><b>rtitle: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("prefix");
	form.appendf("  <tr><td><b>prefix: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Permissions");
	form.appendf("<tr><td><b>Permissions: </b></td><td>");
	form.appendf("<table><tr><td><textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea></td>", extfix.str());
	form.append("</tr></table>");
	form.append("</td></tr>");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CResourcePermissionsResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CResourcePermissionsResponse::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
		m_basedn.marshall(rpc_resp, "basedn", "", "", "");
		m_rtype.marshall(rpc_resp, "rtype", "", "", "");
		m_name.marshall(rpc_resp, "name", "", "", "");
		m_rtitle.marshall(rpc_resp, "rtitle", "", "", "");
		m_prefix.marshall(rpc_resp, "prefix", "", "", "");
		m_Permissions.marshall(rpc_resp, "Permissions", "Permission");
	}
}


void CResourcePermissionsResponse::copy(CResourcePermissionsResponse &from)
{
	m_basedn.copy(from.m_basedn);
	m_rtype.copy(from.m_rtype);
	m_name.copy(from.m_name);
	m_rtitle.copy(from.m_rtitle);
	m_prefix.copy(from.m_prefix);
	m_Permissions.copy(from.m_Permissions);
}


void CResourcePermissionsResponse::copy(IConstResourcePermissionsResponse &ifrom)
{
	setBasedn(ifrom.getBasedn());
	setRtype(ifrom.getRtype());
	setName(ifrom.getName());
	setRtitle(ifrom.getRtitle());
	setPrefix(ifrom.getPrefix());
	setPermissions(ifrom.getPermissions());
}


void CResourcePermissionsResponse::getAttributes(IProperties &attributes)
{
}


void CResourcePermissionsResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
		m_basedn.toStr(ctx, buffer, "basedn", "", true, "", "");
		m_rtype.toStr(ctx, buffer, "rtype", "", true, "", "");
		m_name.toStr(ctx, buffer, "name", "", true, "", "");
		m_rtitle.toStr(ctx, buffer, "rtitle", "", true, "", "");
		m_prefix.toStr(ctx, buffer, "prefix", "", true, "", "");
		m_Permissions.toStr(ctx, buffer, "Permissions", "Permission");
	}
}


void CResourcePermissionsResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CResourcePermissionsResponse::serializer(IEspContext* ctx, IConstResourcePermissionsResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<ResourcePermissionsResponse>");
	// field basedn
	{
		const char* s = src.getBasedn();
		if (s && *s)
		{
			buffer.append("<basedn>");
			encodeUtf8XML(s,buffer);
			buffer.append("</basedn>");
		}
	}
	// field rtype
	{
		const char* s = src.getRtype();
		if (s && *s)
		{
			buffer.append("<rtype>");
			encodeUtf8XML(s,buffer);
			buffer.append("</rtype>");
		}
	}
	// field name
	{
		const char* s = src.getName();
		if (s && *s)
		{
			buffer.append("<name>");
			encodeUtf8XML(s,buffer);
			buffer.append("</name>");
		}
	}
	// field rtitle
	{
		const char* s = src.getRtitle();
		if (s && *s)
		{
			buffer.append("<rtitle>");
			encodeUtf8XML(s,buffer);
			buffer.append("</rtitle>");
		}
	}
	// field prefix
	{
		const char* s = src.getPrefix();
		if (s && *s)
		{
			buffer.append("<prefix>");
			encodeUtf8XML(s,buffer);
			buffer.append("</prefix>");
		}
	}
	// field Permissions
	{
		IArrayOf<IConstResourcePermission>& v = src.getPermissions();
		int size = v.length();
		if (size>0)
			buffer.append("<Permissions>");
		for (int i=0;i<size;i++)
		{
			buffer.append("<Permission>");
			CResourcePermission::serializer(ctx,v.item(i),buffer,false);
			buffer.append("</Permission>");
		}
		if (size>0)
			buffer.append("</Permissions>");
	}
	if (keepRootTag)
		buffer.append("</ResourcePermissionsResponse>");
}

bool CResourcePermissionsResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
		hasValue |= m_basedn.unmarshall(rpc_request, "basedn", basepath);
		hasValue |= m_rtype.unmarshall(rpc_request, "rtype", basepath);
		hasValue |= m_name.unmarshall(rpc_request, "name", basepath);
		hasValue |= m_rtitle.unmarshall(rpc_request, "rtitle", basepath);
		hasValue |= m_prefix.unmarshall(rpc_request, "prefix", basepath);
		hasValue |= m_Permissions.unmarshall(rpc_request, "Permissions", basepath);
	}
	return hasValue;
}

bool CResourcePermissionsResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_basedn.unmarshall(ctx, soapval, "basedn");
	hasValue |= m_rtype.unmarshall(ctx, soapval, "rtype");
	hasValue |= m_name.unmarshall(ctx, soapval, "name");
	hasValue |= m_rtitle.unmarshall(ctx, soapval, "rtitle");
	hasValue |= m_prefix.unmarshall(ctx, soapval, "prefix");
	hasValue |= m_Permissions.unmarshall(ctx, soapval, "Permissions");
	return hasValue;
}

bool CResourcePermissionsResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_basedn.unmarshall(ctx, params, attachments, "basedn", basepath);
	hasValue |= m_rtype.unmarshall(ctx, params, attachments, "rtype", basepath);
	hasValue |= m_name.unmarshall(ctx, params, attachments, "name", basepath);
	hasValue |= m_rtitle.unmarshall(ctx, params, attachments, "rtitle", basepath);
	hasValue |= m_prefix.unmarshall(ctx, params, attachments, "prefix", basepath);
	hasValue |= m_Permissions.unmarshall(ctx, params, attachments, "Permissions", basepath);
	return hasValue;
}

const char * CResourcePermissionsResponse::getBasedn() { return m_basedn.query();}
const char * CResourcePermissionsResponse::getRtype() { return m_rtype.query();}
const char * CResourcePermissionsResponse::getName() { return m_name.query();}
const char * CResourcePermissionsResponse::getRtitle() { return m_rtitle.query();}
const char * CResourcePermissionsResponse::getPrefix() { return m_prefix.query();}
IArrayOf<IConstResourcePermission> & CResourcePermissionsResponse::getPermissions() { return (IArrayOf<IConstResourcePermission> &) m_Permissions; }
void CResourcePermissionsResponse::setBasedn(const char * val){ m_basedn.set(val); }
void CResourcePermissionsResponse::setRtype(const char * val){ m_rtype.set(val); }
void CResourcePermissionsResponse::setName(const char * val){ m_name.set(val); }
void CResourcePermissionsResponse::setRtitle(const char * val){ m_rtitle.set(val); }
void CResourcePermissionsResponse::setPrefix(const char * val){ m_prefix.set(val); }
void CResourcePermissionsResponse::setPermissions(IArrayOf<IEspResourcePermission> &val)
{
	m_Permissions->kill();
	IArrayOf<IConstResourcePermission> &target = m_Permissions.getValue();
	ForEachItemIn(idx, val)
	{
		IEspResourcePermission &item = (val).item(idx);
		item.Link();
		target.append(item);
	}
}
void CResourcePermissionsResponse::setPermissions(IArrayOf<IConstResourcePermission> &val)
{
	m_Permissions->kill();
	IArrayOf<IConstResourcePermission> &target = m_Permissions.getValue();
	ForEachItemIn(idx, val)
	{
		IConstResourcePermission &item = val.item(idx);
		item.Link();
		target.append(item);
	}
}
extern "C"  IEspResourcePermissionsResponse *createResourcePermissionsResponse(const char *serv){return ((IEspResourcePermissionsResponse *)new CResourcePermissionsResponse(serv));}
extern "C"  IClientResourcePermissionsResponse *createClientResourcePermissionsResponse(const char *serv){return ((IClientResourcePermissionsResponse *)new CResourcePermissionsResponse(serv));}

//=======================================================
// class CResourcePermissionQueryRequest Implementation
//=======================================================

CResourcePermissionQueryRequest::CResourcePermissionQueryRequest(const char *serviceName, IRpcMessageBinding *init)
	: m_basedn(nilRemove),m_rtype(nilRemove),m_rtitle(nilRemove),m_prefix(nilRemove),m_Name(nilRemove),m_AccountType(nilRemove),m_PageSize(nilRemove),m_PageStartFrom(nilRemove),m_SortBy(nilRemove),m_Descending(0, nilRemove,false),m_CacheHint(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ResourcePermissionQueryRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CResourcePermissionQueryRequest::CResourcePermissionQueryRequest(const char *serviceName, const char *bc)
	: m_basedn(nilRemove),m_rtype(nilRemove),m_rtitle(nilRemove),m_prefix(nilRemove),m_Name(nilRemove),m_AccountType(nilRemove),m_PageSize(nilRemove),m_PageStartFrom(nilRemove),m_SortBy(nilRemove),m_Descending(0, nilRemove,false),m_CacheHint(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ResourcePermissionQueryRequest");
}

CResourcePermissionQueryRequest::CResourcePermissionQueryRequest(const char *serviceName, IRpcMessage* rpcmsg)
	: m_basedn(nilRemove),m_rtype(nilRemove),m_rtitle(nilRemove),m_prefix(nilRemove),m_Name(nilRemove),m_AccountType(nilRemove),m_PageSize(nilRemove),m_PageStartFrom(nilRemove),m_SortBy(nilRemove),m_Descending(0, nilRemove,false),m_CacheHint(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ResourcePermissionQueryRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CResourcePermissionQueryRequest::CResourcePermissionQueryRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_basedn(nilRemove),m_rtype(nilRemove),m_rtitle(nilRemove),m_prefix(nilRemove),m_Name(nilRemove),m_AccountType(nilRemove),m_PageSize(nilRemove),m_PageStartFrom(nilRemove),m_SortBy(nilRemove),m_Descending(0, nilRemove,false),m_CacheHint(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ResourcePermissionQueryRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CResourcePermissionQueryRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"basedn\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"rtype\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"rtitle\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"prefix\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Name\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"AccountType\" type=\"tns:AccountTypeReq\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"PageSize\" type=\"xsd:unsignedInt\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"PageStartFrom\" type=\"xsd:long\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"SortBy\" type=\"tns:ResourcePermissionSortBy\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" default=\"false\" name=\"Descending\" type=\"xsd:boolean\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"CacheHint\" type=\"xsd:long\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	if (!(flags & 0x10)  || (flags & 0x100))
	{
		CXAccountTypeReq::getXsdDefinition(context, request, schema, added);
		CXResourcePermissionSortBy::getXsdDefinition(context, request, schema, added);
	}
	return schema;
}

void CResourcePermissionQueryRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CResourcePermissionQueryRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
	if (!added.getValue("AccountTypeReq"))
	{
		added.setValue("AccountTypeReq",1);
		CXAccountTypeReq::getMapInfo(info,added);
	}
	if (!added.getValue("ResourcePermissionSortBy"))
	{
		added.setValue("ResourcePermissionSortBy",1);
		CXResourcePermissionSortBy::getMapInfo(info,added);
	}
}

StringBuffer &CResourcePermissionQueryRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("basedn");
	form.appendf("  <tr><td><b>basedn: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("rtype");
	form.appendf("  <tr><td><b>rtype: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("rtitle");
	form.appendf("  <tr><td><b>rtitle: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("prefix");
	form.appendf("  <tr><td><b>prefix: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Name");
	form.appendf("  <tr><td><b>Name: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("AccountType");
	form.appendf("  <tr><td><b>AccountType: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix) extfix.append(prefix).append(".");
		extfix.append("PageSize");
	form.appendf("  <tr><td><b>PageSize: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("PageStartFrom");
	form.appendf("  <tr><td><b>PageStartFrom: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("SortBy");
	form.appendf("  <tr><td><b>SortBy: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Descending");
	
	form.appendf("  <tr><td><b>Descending? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("CacheHint");
	form.appendf("  <tr><td><b>CacheHint: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CResourcePermissionQueryRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CResourcePermissionQueryRequest::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_basedn.marshall(rpc_resp, "basedn", "", "", "");
	m_rtype.marshall(rpc_resp, "rtype", "", "", "");
	m_rtitle.marshall(rpc_resp, "rtitle", "", "", "");
	m_prefix.marshall(rpc_resp, "prefix", "", "", "");
	m_Name.marshall(rpc_resp, "Name", "", "", "");
	m_AccountType.marshall(rpc_resp, "AccountType", "", "", "");
	m_PageSize.marshall(rpc_resp, "PageSize", "", "", "");
	m_PageStartFrom.marshall(rpc_resp, "PageStartFrom", "", "", "");
	m_SortBy.marshall(rpc_resp, "SortBy", "", "", "");
	m_Descending.marshall(rpc_resp, "Descending", "", "", "");
	m_CacheHint.marshall(rpc_resp, "CacheHint", "", "", "");
}


void CResourcePermissionQueryRequest::copy(CResourcePermissionQueryRequest &from)
{
	m_basedn.copy(from.m_basedn);
	m_rtype.copy(from.m_rtype);
	m_rtitle.copy(from.m_rtitle);
	m_prefix.copy(from.m_prefix);
	m_Name.copy(from.m_Name);
	m_AccountType.copy(from.m_AccountType);
	m_PageSize.copy(from.m_PageSize);
	m_PageStartFrom.copy(from.m_PageStartFrom);
	m_SortBy.copy(from.m_SortBy);
	m_Descending.copy(from.m_Descending);
	m_CacheHint.copy(from.m_CacheHint);
}


void CResourcePermissionQueryRequest::copy(IConstResourcePermissionQueryRequest &ifrom)
{
	setBasedn(ifrom.getBasedn());
	setRtype(ifrom.getRtype());
	setRtitle(ifrom.getRtitle());
	setPrefix(ifrom.getPrefix());
	setName(ifrom.getName());
	setAccountType(ifrom.getAccountType());
	setPageSize(ifrom.getPageSize());
	setPageStartFrom(ifrom.getPageStartFrom());
	setSortBy(ifrom.getSortBy());
	setDescending(ifrom.getDescending());
	setCacheHint(ifrom.getCacheHint());
}


void CResourcePermissionQueryRequest::getAttributes(IProperties &attributes)
{
}


void CResourcePermissionQueryRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_basedn.toStr(ctx, buffer, "basedn", "", true, "", "");
	m_rtype.toStr(ctx, buffer, "rtype", "", true, "", "");
	m_rtitle.toStr(ctx, buffer, "rtitle", "", true, "", "");
	m_prefix.toStr(ctx, buffer, "prefix", "", true, "", "");
	m_Name.toStr(ctx, buffer, "Name", "", true, "", "");
	m_AccountType.toStr(ctx, buffer, "AccountType", "", true, "", "");
	m_PageSize.toStr(ctx, buffer, "PageSize", "", true, "", "");
	m_PageStartFrom.toStr(ctx, buffer, "PageStartFrom", "", true, "", "");
	m_SortBy.toStr(ctx, buffer, "SortBy", "", true, "", "");
	m_Descending.toStr(ctx, buffer, "Descending", "", true, "", "");
	m_CacheHint.toStr(ctx, buffer, "CacheHint", "", true, "", "");
}


void CResourcePermissionQueryRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CResourcePermissionQueryRequest::serializer(IEspContext* ctx, IConstResourcePermissionQueryRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<ResourcePermissionQueryRequest>");
	// field basedn
	{
		const char* s = src.getBasedn();
		if (s && *s)
		{
			buffer.append("<basedn>");
			encodeUtf8XML(s,buffer);
			buffer.append("</basedn>");
		}
	}
	// field rtype
	{
		const char* s = src.getRtype();
		if (s && *s)
		{
			buffer.append("<rtype>");
			encodeUtf8XML(s,buffer);
			buffer.append("</rtype>");
		}
	}
	// field rtitle
	{
		const char* s = src.getRtitle();
		if (s && *s)
		{
			buffer.append("<rtitle>");
			encodeUtf8XML(s,buffer);
			buffer.append("</rtitle>");
		}
	}
	// field prefix
	{
		const char* s = src.getPrefix();
		if (s && *s)
		{
			buffer.append("<prefix>");
			encodeUtf8XML(s,buffer);
			buffer.append("</prefix>");
		}
	}
	// field Name
	{
		const char* s = src.getName();
		if (s && *s)
		{
			buffer.append("<Name>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Name>");
		}
	}
	// field AccountType
	{
		const char* s = src.getAccountTypeAsString();
		buffer.append("<AccountType>");
		encodeUtf8XML(s,buffer);
		buffer.append("</AccountType>");
	}
	// field PageSize
	{
		//*** default kind: TK_UNSIGNED; type=(null), name=PageSize
		buffer.append("<PageSize>");
		buffer.append(src.getPageSize());
		buffer.append("</PageSize>");
	}
	// field PageStartFrom
	{
		//*** default kind: TK_INT; type=int64, name=PageStartFrom
		buffer.append("<PageStartFrom>");
		buffer.append(src.getPageStartFrom());
		buffer.append("</PageStartFrom>");
	}
	// field SortBy
	{
		const char* s = src.getSortByAsString();
		buffer.append("<SortBy>");
		encodeUtf8XML(s,buffer);
		buffer.append("</SortBy>");
	}
	// field Descending
	{
		bool b = src.getDescending();
		if (b)
			buffer.appendf("<Descending>1</Descending>");
	}
	// field CacheHint
	{
		//*** default kind: TK_INT; type=int64, name=CacheHint
		buffer.append("<CacheHint>");
		buffer.append(src.getCacheHint());
		buffer.append("</CacheHint>");
	}
	if (keepRootTag)
		buffer.append("</ResourcePermissionQueryRequest>");
}

bool CResourcePermissionQueryRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_basedn.unmarshall(rpc_request, "basedn", basepath);
	hasValue |= m_rtype.unmarshall(rpc_request, "rtype", basepath);
	hasValue |= m_rtitle.unmarshall(rpc_request, "rtitle", basepath);
	hasValue |= m_prefix.unmarshall(rpc_request, "prefix", basepath);
	hasValue |= m_Name.unmarshall(rpc_request, "Name", basepath);
	hasValue |= m_AccountType.unmarshall(rpc_request, "AccountType", basepath);
	hasValue |= m_PageSize.unmarshall(rpc_request, "PageSize", basepath);
	hasValue |= m_PageStartFrom.unmarshall(rpc_request, "PageStartFrom", basepath);
	hasValue |= m_SortBy.unmarshall(rpc_request, "SortBy", basepath);
	hasValue |= m_Descending.unmarshall(rpc_request, "Descending", basepath);
	hasValue |= m_CacheHint.unmarshall(rpc_request, "CacheHint", basepath);
	return hasValue;
}

bool CResourcePermissionQueryRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_basedn.unmarshall(ctx, soapval, "basedn");
	hasValue |= m_rtype.unmarshall(ctx, soapval, "rtype");
	hasValue |= m_rtitle.unmarshall(ctx, soapval, "rtitle");
	hasValue |= m_prefix.unmarshall(ctx, soapval, "prefix");
	hasValue |= m_Name.unmarshall(ctx, soapval, "Name");
	hasValue |= m_AccountType.unmarshall(ctx, soapval, "AccountType");
	hasValue |= m_PageSize.unmarshall(ctx, soapval, "PageSize");
	hasValue |= m_PageStartFrom.unmarshall(ctx, soapval, "PageStartFrom");
	hasValue |= m_SortBy.unmarshall(ctx, soapval, "SortBy");
	hasValue |= m_Descending.unmarshall(ctx, soapval, "Descending");
	hasValue |= m_CacheHint.unmarshall(ctx, soapval, "CacheHint");
	return hasValue;
}

bool CResourcePermissionQueryRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_basedn.unmarshall(ctx, params, attachments, "basedn", basepath);
	hasValue |= m_rtype.unmarshall(ctx, params, attachments, "rtype", basepath);
	hasValue |= m_rtitle.unmarshall(ctx, params, attachments, "rtitle", basepath);
	hasValue |= m_prefix.unmarshall(ctx, params, attachments, "prefix", basepath);
	hasValue |= m_Name.unmarshall(ctx, params, attachments, "Name", basepath);
	hasValue |= m_AccountType.unmarshall(ctx, params, attachments, "AccountType", basepath);
	hasValue |= m_PageSize.unmarshall(ctx, params, attachments, "PageSize", basepath);
	hasValue |= m_PageStartFrom.unmarshall(ctx, params, attachments, "PageStartFrom", basepath);
	hasValue |= m_SortBy.unmarshall(ctx, params, attachments, "SortBy", basepath);
	hasValue |= m_Descending.unmarshall(ctx, params, attachments, "Descending", basepath);
	hasValue |= m_CacheHint.unmarshall(ctx, params, attachments, "CacheHint", basepath);
	return hasValue;
}

const char * CResourcePermissionQueryRequest::getBasedn() { return m_basedn.query();}
const char * CResourcePermissionQueryRequest::getRtype() { return m_rtype.query();}
const char * CResourcePermissionQueryRequest::getRtitle() { return m_rtitle.query();}
const char * CResourcePermissionQueryRequest::getPrefix() { return m_prefix.query();}
const char * CResourcePermissionQueryRequest::getName() { return m_Name.query();}
CAccountTypeReq CResourcePermissionQueryRequest::getAccountType() { return m_AccountType.getValue(); }
const char* CResourcePermissionQueryRequest::getAccountTypeAsString() {  return (const char*)m_AccountType; }
bool CResourcePermissionQueryRequest::getPageSize_isNull(){return m_PageSize.is_nil();}
unsigned int CResourcePermissionQueryRequest::getPageSize() { return m_PageSize;}
bool CResourcePermissionQueryRequest::getPageStartFrom_isNull(){return m_PageStartFrom.is_nil();}
__int64 CResourcePermissionQueryRequest::getPageStartFrom() { return m_PageStartFrom;}
CResourcePermissionSortBy CResourcePermissionQueryRequest::getSortBy() { return m_SortBy.getValue(); }
const char* CResourcePermissionQueryRequest::getSortByAsString() {  return (const char*)m_SortBy; }
bool CResourcePermissionQueryRequest::getDescending_isNull(){return m_Descending.is_nil();}
bool CResourcePermissionQueryRequest::getDescending() { return m_Descending;}
bool CResourcePermissionQueryRequest::getCacheHint_isNull(){return m_CacheHint.is_nil();}
__int64 CResourcePermissionQueryRequest::getCacheHint() { return m_CacheHint;}
void CResourcePermissionQueryRequest::setBasedn(const char * val){ m_basedn.set(val); }
void CResourcePermissionQueryRequest::setRtype(const char * val){ m_rtype.set(val); }
void CResourcePermissionQueryRequest::setRtitle(const char * val){ m_rtitle.set(val); }
void CResourcePermissionQueryRequest::setPrefix(const char * val){ m_prefix.set(val); }
void CResourcePermissionQueryRequest::setName(const char * val){ m_Name.set(val); }
void CResourcePermissionQueryRequest::setAccountType(CAccountTypeReq val) { m_AccountType.setValue(val); }
void CResourcePermissionQueryRequest::setAccountType(const char* val) { m_AccountType.setValue(val); }
void CResourcePermissionQueryRequest::setPageSize_null(){ m_PageSize.Nil(); }void CResourcePermissionQueryRequest::setPageSize(unsigned int val){ m_PageSize=val; }
void CResourcePermissionQueryRequest::setPageStartFrom_null(){ m_PageStartFrom.Nil(); }void CResourcePermissionQueryRequest::setPageStartFrom(__int64 val){ m_PageStartFrom=val; }
void CResourcePermissionQueryRequest::setSortBy(CResourcePermissionSortBy val) { m_SortBy.setValue(val); }
void CResourcePermissionQueryRequest::setSortBy(const char* val) { m_SortBy.setValue(val); }
void CResourcePermissionQueryRequest::setDescending_null(){ m_Descending.Nil(); }void CResourcePermissionQueryRequest::setDescending(bool val){ m_Descending=val; }
void CResourcePermissionQueryRequest::setCacheHint_null(){ m_CacheHint.Nil(); }void CResourcePermissionQueryRequest::setCacheHint(__int64 val){ m_CacheHint=val; }
extern "C"  IEspResourcePermissionQueryRequest *createResourcePermissionQueryRequest(const char *serv){return ((IEspResourcePermissionQueryRequest *)new CResourcePermissionQueryRequest(serv));}
extern "C"  IClientResourcePermissionQueryRequest *createClientResourcePermissionQueryRequest(const char *serv){return ((IClientResourcePermissionQueryRequest *)new CResourcePermissionQueryRequest(serv));}

//=======================================================
// class CResourcePermissionQueryResponse Implementation
//=======================================================

CResourcePermissionQueryResponse::CResourcePermissionQueryResponse(const char *serviceName, IRpcMessageBinding *init)
	: m_NoSecMngr(0, nilRemove,false),m_Permissions(nilRemove),m_TotalResourcePermissions(nilRemove),m_CacheHint(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ResourcePermissionQueryResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CResourcePermissionQueryResponse::CResourcePermissionQueryResponse(const char *serviceName, const char *bc)
	: m_NoSecMngr(0, nilRemove,false),m_Permissions(nilRemove),m_TotalResourcePermissions(nilRemove),m_CacheHint(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ResourcePermissionQueryResponse");
}

CResourcePermissionQueryResponse::CResourcePermissionQueryResponse(const char *serviceName, IRpcMessage* rpcmsg)
	: m_NoSecMngr(0, nilRemove,false),m_Permissions(nilRemove),m_TotalResourcePermissions(nilRemove),m_CacheHint(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ResourcePermissionQueryResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CResourcePermissionQueryResponse::CResourcePermissionQueryResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_NoSecMngr(0, nilRemove,false),m_Permissions(nilRemove),m_TotalResourcePermissions(nilRemove),m_CacheHint(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ResourcePermissionQueryResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CResourcePermissionQueryResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" default=\"false\" name=\"NoSecMngr\" type=\"xsd:boolean\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Permissions\">\n");
		schema.append("<xsd:complexType><xsd:sequence>\n");
		schema.append("<xsd:element minOccurs=\"0\" maxOccurs=\"unbounded\" name=\"Permission\" type=\"tns:ResourcePermission\"/>");
		schema.append("</xsd:sequence></xsd:complexType>");
		schema.append("</xsd:element>");
		schema.append("<xsd:element minOccurs=\"0\" name=\"TotalResourcePermissions\" type=\"xsd:long\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"CacheHint\" type=\"xsd:long\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	if (!(flags & 0x10)  || (flags & 0x100))
	{
		CResourcePermission::getXsdDefinition(context, request, schema, added);
	}
	return schema;
}

void CResourcePermissionQueryResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CResourcePermissionQueryResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
	if (!added.getValue("ResourcePermission"))
	{
		added.setValue("ResourcePermission",1);
		CResourcePermission::getMapInfo(info,added);
	}
}

StringBuffer &CResourcePermissionQueryResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("NoSecMngr");
	
	form.appendf("  <tr><td><b>NoSecMngr? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Permissions");
	form.appendf("<tr><td><b>Permissions: </b></td><td>");
	form.appendf("<table><tr><td><textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea></td>", extfix.str());
	form.append("</tr></table>");
	form.append("</td></tr>");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("TotalResourcePermissions");
	form.appendf("  <tr><td><b>TotalResourcePermissions: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("CacheHint");
	form.appendf("  <tr><td><b>CacheHint: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CResourcePermissionQueryResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CResourcePermissionQueryResponse::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
		m_NoSecMngr.marshall(rpc_resp, "NoSecMngr", "", "", "");
		m_Permissions.marshall(rpc_resp, "Permissions", "Permission");
		m_TotalResourcePermissions.marshall(rpc_resp, "TotalResourcePermissions", "", "", "");
		m_CacheHint.marshall(rpc_resp, "CacheHint", "", "", "");
	}
}


void CResourcePermissionQueryResponse::copy(CResourcePermissionQueryResponse &from)
{
	m_NoSecMngr.copy(from.m_NoSecMngr);
	m_Permissions.copy(from.m_Permissions);
	m_TotalResourcePermissions.copy(from.m_TotalResourcePermissions);
	m_CacheHint.copy(from.m_CacheHint);
}


void CResourcePermissionQueryResponse::copy(IConstResourcePermissionQueryResponse &ifrom)
{
	setNoSecMngr(ifrom.getNoSecMngr());
	setPermissions(ifrom.getPermissions());
	setTotalResourcePermissions(ifrom.getTotalResourcePermissions());
	setCacheHint(ifrom.getCacheHint());
}


void CResourcePermissionQueryResponse::getAttributes(IProperties &attributes)
{
}


void CResourcePermissionQueryResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
		m_NoSecMngr.toStr(ctx, buffer, "NoSecMngr", "", true, "", "");
		m_Permissions.toStr(ctx, buffer, "Permissions", "Permission");
		m_TotalResourcePermissions.toStr(ctx, buffer, "TotalResourcePermissions", "", true, "", "");
		m_CacheHint.toStr(ctx, buffer, "CacheHint", "", true, "", "");
	}
}


void CResourcePermissionQueryResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CResourcePermissionQueryResponse::serializer(IEspContext* ctx, IConstResourcePermissionQueryResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<ResourcePermissionQueryResponse>");
	// field NoSecMngr
	{
		bool b = src.getNoSecMngr();
		if (b)
			buffer.appendf("<NoSecMngr>1</NoSecMngr>");
	}
	// field Permissions
	{
		IArrayOf<IConstResourcePermission>& v = src.getPermissions();
		int size = v.length();
		if (size>0)
			buffer.append("<Permissions>");
		for (int i=0;i<size;i++)
		{
			buffer.append("<Permission>");
			CResourcePermission::serializer(ctx,v.item(i),buffer,false);
			buffer.append("</Permission>");
		}
		if (size>0)
			buffer.append("</Permissions>");
	}
	// field TotalResourcePermissions
	{
		//*** default kind: TK_INT; type=int64, name=TotalResourcePermissions
		buffer.append("<TotalResourcePermissions>");
		buffer.append(src.getTotalResourcePermissions());
		buffer.append("</TotalResourcePermissions>");
	}
	// field CacheHint
	{
		//*** default kind: TK_INT; type=int64, name=CacheHint
		buffer.append("<CacheHint>");
		buffer.append(src.getCacheHint());
		buffer.append("</CacheHint>");
	}
	if (keepRootTag)
		buffer.append("</ResourcePermissionQueryResponse>");
}

bool CResourcePermissionQueryResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
		hasValue |= m_NoSecMngr.unmarshall(rpc_request, "NoSecMngr", basepath);
		hasValue |= m_Permissions.unmarshall(rpc_request, "Permissions", basepath);
		hasValue |= m_TotalResourcePermissions.unmarshall(rpc_request, "TotalResourcePermissions", basepath);
		hasValue |= m_CacheHint.unmarshall(rpc_request, "CacheHint", basepath);
	}
	return hasValue;
}

bool CResourcePermissionQueryResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_NoSecMngr.unmarshall(ctx, soapval, "NoSecMngr");
	hasValue |= m_Permissions.unmarshall(ctx, soapval, "Permissions");
	hasValue |= m_TotalResourcePermissions.unmarshall(ctx, soapval, "TotalResourcePermissions");
	hasValue |= m_CacheHint.unmarshall(ctx, soapval, "CacheHint");
	return hasValue;
}

bool CResourcePermissionQueryResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_NoSecMngr.unmarshall(ctx, params, attachments, "NoSecMngr", basepath);
	hasValue |= m_Permissions.unmarshall(ctx, params, attachments, "Permissions", basepath);
	hasValue |= m_TotalResourcePermissions.unmarshall(ctx, params, attachments, "TotalResourcePermissions", basepath);
	hasValue |= m_CacheHint.unmarshall(ctx, params, attachments, "CacheHint", basepath);
	return hasValue;
}

bool CResourcePermissionQueryResponse::getNoSecMngr_isNull(){return m_NoSecMngr.is_nil();}
bool CResourcePermissionQueryResponse::getNoSecMngr() { return m_NoSecMngr;}
IArrayOf<IConstResourcePermission> & CResourcePermissionQueryResponse::getPermissions() { return (IArrayOf<IConstResourcePermission> &) m_Permissions; }
bool CResourcePermissionQueryResponse::getTotalResourcePermissions_isNull(){return m_TotalResourcePermissions.is_nil();}
__int64 CResourcePermissionQueryResponse::getTotalResourcePermissions() { return m_TotalResourcePermissions;}
bool CResourcePermissionQueryResponse::getCacheHint_isNull(){return m_CacheHint.is_nil();}
__int64 CResourcePermissionQueryResponse::getCacheHint() { return m_CacheHint;}
void CResourcePermissionQueryResponse::setNoSecMngr_null(){ m_NoSecMngr.Nil(); }void CResourcePermissionQueryResponse::setNoSecMngr(bool val){ m_NoSecMngr=val; }
void CResourcePermissionQueryResponse::setPermissions(IArrayOf<IEspResourcePermission> &val)
{
	m_Permissions->kill();
	IArrayOf<IConstResourcePermission> &target = m_Permissions.getValue();
	ForEachItemIn(idx, val)
	{
		IEspResourcePermission &item = (val).item(idx);
		item.Link();
		target.append(item);
	}
}
void CResourcePermissionQueryResponse::setPermissions(IArrayOf<IConstResourcePermission> &val)
{
	m_Permissions->kill();
	IArrayOf<IConstResourcePermission> &target = m_Permissions.getValue();
	ForEachItemIn(idx, val)
	{
		IConstResourcePermission &item = val.item(idx);
		item.Link();
		target.append(item);
	}
}
void CResourcePermissionQueryResponse::setTotalResourcePermissions_null(){ m_TotalResourcePermissions.Nil(); }void CResourcePermissionQueryResponse::setTotalResourcePermissions(__int64 val){ m_TotalResourcePermissions=val; }
void CResourcePermissionQueryResponse::setCacheHint_null(){ m_CacheHint.Nil(); }void CResourcePermissionQueryResponse::setCacheHint(__int64 val){ m_CacheHint=val; }
extern "C"  IEspResourcePermissionQueryResponse *createResourcePermissionQueryResponse(const char *serv){return ((IEspResourcePermissionQueryResponse *)new CResourcePermissionQueryResponse(serv));}
extern "C"  IClientResourcePermissionQueryResponse *createClientResourcePermissionQueryResponse(const char *serv){return ((IClientResourcePermissionQueryResponse *)new CResourcePermissionQueryResponse(serv));}

//=======================================================
// class CView Implementation
//=======================================================

CView::CView(const char *serviceName, IRpcMessageBinding *init)
	: m_viewname(nilIgnore),m_description(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("View");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CView::CView(const char *serviceName, const char *bc)
	: m_viewname(nilIgnore),m_description(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("View");
}

StringBuffer &CView::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:complexType name=\"%s\">\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"viewname\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"description\" type=\"xsd:string\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType>\n");
		}
	}
	return schema;
}

void CView::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CView::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CView::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("viewname");
	form.appendf("  <tr><td><b>viewname: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("description");
	form.appendf("  <tr><td><b>description: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CView::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CView::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_viewname.marshall(rpc_resp, "viewname", "", "", "");
	m_description.marshall(rpc_resp, "description", "", "", "");
}


void CView::copy(CView &from)
{
	m_viewname.copy(from.m_viewname);
	m_description.copy(from.m_description);
}


void CView::copy(IConstView &ifrom)
{
	setViewname(ifrom.getViewname());
	setDescription(ifrom.getDescription());
}


void CView::getAttributes(IProperties &attributes)
{
}


void CView::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_viewname.toStr(ctx, buffer, "viewname", "", true, "", "");
	m_description.toStr(ctx, buffer, "description", "", true, "", "");
}


void CView::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CView::serializer(IEspContext* ctx, IConstView &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<View>");
	// field viewname
	{
		const char* s = src.getViewname();
		if (s && *s)
		{
			buffer.append("<viewname>");
			encodeUtf8XML(s,buffer);
			buffer.append("</viewname>");
		}
	}
	// field description
	{
		const char* s = src.getDescription();
		if (s && *s)
		{
			buffer.append("<description>");
			encodeUtf8XML(s,buffer);
			buffer.append("</description>");
		}
	}
	if (keepRootTag)
		buffer.append("</View>");
}

bool CView::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_viewname.unmarshall(rpc_request, "viewname", basepath);
	hasValue |= m_description.unmarshall(rpc_request, "description", basepath);
	return hasValue;
}

bool CView::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_viewname.unmarshall(ctx, soapval, "viewname");
	hasValue |= m_description.unmarshall(ctx, soapval, "description");
	return hasValue;
}

bool CView::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_viewname.unmarshall(ctx, params, attachments, "viewname", basepath);
	hasValue |= m_description.unmarshall(ctx, params, attachments, "description", basepath);
	return hasValue;
}

const char * CView::getViewname() { return m_viewname.query();}
const char * CView::getDescription() { return m_description.query();}
void CView::setViewname(const char * val){ m_viewname.set(val); }
void CView::setDescription(const char * val){ m_description.set(val); }
extern "C"  IEspView *createView(const char *serv, const char *msgname){return ((IEspView *)new CView(serv /*, msgname*/));}
extern "C"  IClientView *createClientView(const char *serv, const char *msgname){return ((IClientView *)new CView(serv /*, msgname*/));}

//=======================================================
// class CQueryViewsRequest Implementation
//=======================================================

CQueryViewsRequest::CQueryViewsRequest(const char *serviceName, IRpcMessageBinding *init)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("QueryViewsRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CQueryViewsRequest::CQueryViewsRequest(const char *serviceName, const char *bc)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("QueryViewsRequest");
}

CQueryViewsRequest::CQueryViewsRequest(const char *serviceName, IRpcMessage* rpcmsg)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("QueryViewsRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CQueryViewsRequest::CQueryViewsRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("QueryViewsRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CQueryViewsRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType><xsd:all/></xsd:complexType></xsd:element>\n", msgTypeName);
		}
	}
	return schema;
}

void CQueryViewsRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CQueryViewsRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CQueryViewsRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CQueryViewsRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CQueryViewsRequest::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

}


void CQueryViewsRequest::copy(CQueryViewsRequest &from)
{
}


void CQueryViewsRequest::copy(IConstQueryViewsRequest &ifrom)
{
}


void CQueryViewsRequest::getAttributes(IProperties &attributes)
{
}


void CQueryViewsRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
}


void CQueryViewsRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CQueryViewsRequest::serializer(IEspContext* ctx, IConstQueryViewsRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<QueryViewsRequest>");
	if (keepRootTag)
		buffer.append("</QueryViewsRequest>");
}

bool CQueryViewsRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	return hasValue;
}

bool CQueryViewsRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	return hasValue;
}

bool CQueryViewsRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	return hasValue;
}

extern "C"  IEspQueryViewsRequest *createQueryViewsRequest(const char *serv){return ((IEspQueryViewsRequest *)new CQueryViewsRequest(serv));}
extern "C"  IClientQueryViewsRequest *createClientQueryViewsRequest(const char *serv){return ((IClientQueryViewsRequest *)new CQueryViewsRequest(serv));}

//=======================================================
// class CQueryViewsResponse Implementation
//=======================================================

CQueryViewsResponse::CQueryViewsResponse(const char *serviceName, IRpcMessageBinding *init)
	: m_views(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("QueryViewsResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CQueryViewsResponse::CQueryViewsResponse(const char *serviceName, const char *bc)
	: m_views(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("QueryViewsResponse");
}

CQueryViewsResponse::CQueryViewsResponse(const char *serviceName, IRpcMessage* rpcmsg)
	: m_views(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("QueryViewsResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CQueryViewsResponse::CQueryViewsResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_views(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("QueryViewsResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CQueryViewsResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"views\" type=\"tns:ArrayOfView\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	if (!(flags & 0x10)  || (flags & 0x100))
	{
		CView::getXsdDefinition(context, request, schema, added);
	}
	if (added.getValue("View") && added.getValue("ArrayOfView")==NULL) {
		schema.append("<xsd:complexType name=\"ArrayOfView\">\n");
		schema.append("<xsd:sequence>\n");
		schema.append("<xsd:element minOccurs=\"0\" maxOccurs=\"unbounded\" name=\"View\" type=\"tns:View\"/>\n");
		schema.append("</xsd:sequence>\n");
		schema.append("</xsd:complexType>\n");
		added.setValue("ArrayOfView",1);
	}
	return schema;
}

void CQueryViewsResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CQueryViewsResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
	if (!added.getValue("View"))
	{
		added.setValue("View",1);
		CView::getMapInfo(info,added);
	}
}

StringBuffer &CQueryViewsResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("views");
	form.appendf("<tr><td><b>views: </b></td><td>");
	form.appendf("<table><tr><td><textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea></td>", extfix.str());
	form.append("</tr></table>");
	form.append("</td></tr>");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CQueryViewsResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CQueryViewsResponse::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
		m_views.marshall(rpc_resp, "views", "View");
	}
}


void CQueryViewsResponse::copy(CQueryViewsResponse &from)
{
	m_views.copy(from.m_views);
}


void CQueryViewsResponse::copy(IConstQueryViewsResponse &ifrom)
{
	setViews(ifrom.getViews());
}


void CQueryViewsResponse::getAttributes(IProperties &attributes)
{
}


void CQueryViewsResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
		m_views.toStr(ctx, buffer, "views", "View");
	}
}


void CQueryViewsResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CQueryViewsResponse::serializer(IEspContext* ctx, IConstQueryViewsResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<QueryViewsResponse>");
	// field views
	{
		IArrayOf<IConstView>& v = src.getViews();
		int size = v.length();
		if (size>0)
			buffer.append("<views>");
		for (int i=0;i<size;i++)
		{
			buffer.append("<Item>");
			CView::serializer(ctx,v.item(i),buffer,false);
			buffer.append("</Item>");
		}
		if (size>0)
			buffer.append("</views>");
	}
	if (keepRootTag)
		buffer.append("</QueryViewsResponse>");
}

bool CQueryViewsResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
		hasValue |= m_views.unmarshall(rpc_request, "views", basepath);
	}
	return hasValue;
}

bool CQueryViewsResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_views.unmarshall(ctx, soapval, "views");
	return hasValue;
}

bool CQueryViewsResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_views.unmarshall(ctx, params, attachments, "views", basepath);
	return hasValue;
}

IArrayOf<IConstView> & CQueryViewsResponse::getViews() { return (IArrayOf<IConstView> &) m_views; }
void CQueryViewsResponse::setViews(IArrayOf<IEspView> &val)
{
	m_views->kill();
	IArrayOf<IConstView> &target = m_views.getValue();
	ForEachItemIn(idx, val)
	{
		IEspView &item = (val).item(idx);
		item.Link();
		target.append(item);
	}
}
void CQueryViewsResponse::setViews(IArrayOf<IConstView> &val)
{
	m_views->kill();
	IArrayOf<IConstView> &target = m_views.getValue();
	ForEachItemIn(idx, val)
	{
		IConstView &item = val.item(idx);
		item.Link();
		target.append(item);
	}
}
extern "C"  IEspQueryViewsResponse *createQueryViewsResponse(const char *serv){return ((IEspQueryViewsResponse *)new CQueryViewsResponse(serv));}
extern "C"  IClientQueryViewsResponse *createClientQueryViewsResponse(const char *serv){return ((IClientQueryViewsResponse *)new CQueryViewsResponse(serv));}

//=======================================================
// class CAddViewRequest Implementation
//=======================================================

CAddViewRequest::CAddViewRequest(const char *serviceName, IRpcMessageBinding *init)
	: m_viewname(nilIgnore),m_description(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("AddViewRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CAddViewRequest::CAddViewRequest(const char *serviceName, const char *bc)
	: m_viewname(nilIgnore),m_description(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("AddViewRequest");
}

CAddViewRequest::CAddViewRequest(const char *serviceName, IRpcMessage* rpcmsg)
	: m_viewname(nilIgnore),m_description(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("AddViewRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CAddViewRequest::CAddViewRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_viewname(nilIgnore),m_description(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("AddViewRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CAddViewRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"viewname\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"description\" type=\"xsd:string\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CAddViewRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CAddViewRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CAddViewRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("viewname");
	form.appendf("  <tr><td><b>viewname: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("description");
	form.appendf("  <tr><td><b>description: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CAddViewRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CAddViewRequest::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_viewname.marshall(rpc_resp, "viewname", "", "", "");
	m_description.marshall(rpc_resp, "description", "", "", "");
}


void CAddViewRequest::copy(CAddViewRequest &from)
{
	m_viewname.copy(from.m_viewname);
	m_description.copy(from.m_description);
}


void CAddViewRequest::copy(IConstAddViewRequest &ifrom)
{
	setViewname(ifrom.getViewname());
	setDescription(ifrom.getDescription());
}


void CAddViewRequest::getAttributes(IProperties &attributes)
{
}


void CAddViewRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_viewname.toStr(ctx, buffer, "viewname", "", true, "", "");
	m_description.toStr(ctx, buffer, "description", "", true, "", "");
}


void CAddViewRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CAddViewRequest::serializer(IEspContext* ctx, IConstAddViewRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<AddViewRequest>");
	// field viewname
	{
		const char* s = src.getViewname();
		if (s && *s)
		{
			buffer.append("<viewname>");
			encodeUtf8XML(s,buffer);
			buffer.append("</viewname>");
		}
	}
	// field description
	{
		const char* s = src.getDescription();
		if (s && *s)
		{
			buffer.append("<description>");
			encodeUtf8XML(s,buffer);
			buffer.append("</description>");
		}
	}
	if (keepRootTag)
		buffer.append("</AddViewRequest>");
}

bool CAddViewRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_viewname.unmarshall(rpc_request, "viewname", basepath);
	hasValue |= m_description.unmarshall(rpc_request, "description", basepath);
	return hasValue;
}

bool CAddViewRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_viewname.unmarshall(ctx, soapval, "viewname");
	hasValue |= m_description.unmarshall(ctx, soapval, "description");
	return hasValue;
}

bool CAddViewRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_viewname.unmarshall(ctx, params, attachments, "viewname", basepath);
	hasValue |= m_description.unmarshall(ctx, params, attachments, "description", basepath);
	return hasValue;
}

const char * CAddViewRequest::getViewname() { return m_viewname.query();}
const char * CAddViewRequest::getDescription() { return m_description.query();}
void CAddViewRequest::setViewname(const char * val){ m_viewname.set(val); }
void CAddViewRequest::setDescription(const char * val){ m_description.set(val); }
extern "C"  IEspAddViewRequest *createAddViewRequest(const char *serv){return ((IEspAddViewRequest *)new CAddViewRequest(serv));}
extern "C"  IClientAddViewRequest *createClientAddViewRequest(const char *serv){return ((IClientAddViewRequest *)new CAddViewRequest(serv));}

//=======================================================
// class CAddViewResponse Implementation
//=======================================================

CAddViewResponse::CAddViewResponse(const char *serviceName, IRpcMessageBinding *init)
	: m_viewname(nilIgnore),m_description(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("AddViewResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CAddViewResponse::CAddViewResponse(const char *serviceName, const char *bc)
	: m_viewname(nilIgnore),m_description(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("AddViewResponse");
}

CAddViewResponse::CAddViewResponse(const char *serviceName, IRpcMessage* rpcmsg)
	: m_viewname(nilIgnore),m_description(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("AddViewResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CAddViewResponse::CAddViewResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_viewname(nilIgnore),m_description(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("AddViewResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CAddViewResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"viewname\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"description\" type=\"xsd:string\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CAddViewResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CAddViewResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CAddViewResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("viewname");
	form.appendf("  <tr><td><b>viewname: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("description");
	form.appendf("  <tr><td><b>description: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CAddViewResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CAddViewResponse::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
		m_viewname.marshall(rpc_resp, "viewname", "", "", "");
		m_description.marshall(rpc_resp, "description", "", "", "");
	}
}


void CAddViewResponse::copy(CAddViewResponse &from)
{
	m_viewname.copy(from.m_viewname);
	m_description.copy(from.m_description);
}


void CAddViewResponse::copy(IConstAddViewResponse &ifrom)
{
	setViewname(ifrom.getViewname());
	setDescription(ifrom.getDescription());
}


void CAddViewResponse::getAttributes(IProperties &attributes)
{
}


void CAddViewResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
		m_viewname.toStr(ctx, buffer, "viewname", "", true, "", "");
		m_description.toStr(ctx, buffer, "description", "", true, "", "");
	}
}


void CAddViewResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CAddViewResponse::serializer(IEspContext* ctx, IConstAddViewResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<AddViewResponse>");
	// field viewname
	{
		const char* s = src.getViewname();
		if (s && *s)
		{
			buffer.append("<viewname>");
			encodeUtf8XML(s,buffer);
			buffer.append("</viewname>");
		}
	}
	// field description
	{
		const char* s = src.getDescription();
		if (s && *s)
		{
			buffer.append("<description>");
			encodeUtf8XML(s,buffer);
			buffer.append("</description>");
		}
	}
	if (keepRootTag)
		buffer.append("</AddViewResponse>");
}

bool CAddViewResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
		hasValue |= m_viewname.unmarshall(rpc_request, "viewname", basepath);
		hasValue |= m_description.unmarshall(rpc_request, "description", basepath);
	}
	return hasValue;
}

bool CAddViewResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_viewname.unmarshall(ctx, soapval, "viewname");
	hasValue |= m_description.unmarshall(ctx, soapval, "description");
	return hasValue;
}

bool CAddViewResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_viewname.unmarshall(ctx, params, attachments, "viewname", basepath);
	hasValue |= m_description.unmarshall(ctx, params, attachments, "description", basepath);
	return hasValue;
}

const char * CAddViewResponse::getViewname() { return m_viewname.query();}
const char * CAddViewResponse::getDescription() { return m_description.query();}
void CAddViewResponse::setViewname(const char * val){ m_viewname.set(val); }
void CAddViewResponse::setDescription(const char * val){ m_description.set(val); }
extern "C"  IEspAddViewResponse *createAddViewResponse(const char *serv){return ((IEspAddViewResponse *)new CAddViewResponse(serv));}
extern "C"  IClientAddViewResponse *createClientAddViewResponse(const char *serv){return ((IClientAddViewResponse *)new CAddViewResponse(serv));}

//=======================================================
// class CDeleteViewRequest Implementation
//=======================================================

CDeleteViewRequest::CDeleteViewRequest(const char *serviceName, IRpcMessageBinding *init)
	: m_viewname(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("DeleteViewRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CDeleteViewRequest::CDeleteViewRequest(const char *serviceName, const char *bc)
	: m_viewname(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("DeleteViewRequest");
}

CDeleteViewRequest::CDeleteViewRequest(const char *serviceName, IRpcMessage* rpcmsg)
	: m_viewname(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("DeleteViewRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CDeleteViewRequest::CDeleteViewRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_viewname(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("DeleteViewRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CDeleteViewRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"viewname\" type=\"xsd:string\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CDeleteViewRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CDeleteViewRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CDeleteViewRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("viewname");
	form.appendf("  <tr><td><b>viewname: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CDeleteViewRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CDeleteViewRequest::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_viewname.marshall(rpc_resp, "viewname", "", "", "");
}


void CDeleteViewRequest::copy(CDeleteViewRequest &from)
{
	m_viewname.copy(from.m_viewname);
}


void CDeleteViewRequest::copy(IConstDeleteViewRequest &ifrom)
{
	setViewname(ifrom.getViewname());
}


void CDeleteViewRequest::getAttributes(IProperties &attributes)
{
}


void CDeleteViewRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_viewname.toStr(ctx, buffer, "viewname", "", true, "", "");
}


void CDeleteViewRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CDeleteViewRequest::serializer(IEspContext* ctx, IConstDeleteViewRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<DeleteViewRequest>");
	// field viewname
	{
		const char* s = src.getViewname();
		if (s && *s)
		{
			buffer.append("<viewname>");
			encodeUtf8XML(s,buffer);
			buffer.append("</viewname>");
		}
	}
	if (keepRootTag)
		buffer.append("</DeleteViewRequest>");
}

bool CDeleteViewRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_viewname.unmarshall(rpc_request, "viewname", basepath);
	return hasValue;
}

bool CDeleteViewRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_viewname.unmarshall(ctx, soapval, "viewname");
	return hasValue;
}

bool CDeleteViewRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_viewname.unmarshall(ctx, params, attachments, "viewname", basepath);
	return hasValue;
}

const char * CDeleteViewRequest::getViewname() { return m_viewname.query();}
void CDeleteViewRequest::setViewname(const char * val){ m_viewname.set(val); }
extern "C"  IEspDeleteViewRequest *createDeleteViewRequest(const char *serv){return ((IEspDeleteViewRequest *)new CDeleteViewRequest(serv));}
extern "C"  IClientDeleteViewRequest *createClientDeleteViewRequest(const char *serv){return ((IClientDeleteViewRequest *)new CDeleteViewRequest(serv));}

//=======================================================
// class CDeleteViewResponse Implementation
//=======================================================

CDeleteViewResponse::CDeleteViewResponse(const char *serviceName, IRpcMessageBinding *init)
	: m_viewname(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("DeleteViewResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CDeleteViewResponse::CDeleteViewResponse(const char *serviceName, const char *bc)
	: m_viewname(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("DeleteViewResponse");
}

CDeleteViewResponse::CDeleteViewResponse(const char *serviceName, IRpcMessage* rpcmsg)
	: m_viewname(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("DeleteViewResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CDeleteViewResponse::CDeleteViewResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_viewname(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("DeleteViewResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CDeleteViewResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"viewname\" type=\"xsd:string\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CDeleteViewResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CDeleteViewResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CDeleteViewResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("viewname");
	form.appendf("  <tr><td><b>viewname: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CDeleteViewResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CDeleteViewResponse::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
		m_viewname.marshall(rpc_resp, "viewname", "", "", "");
	}
}


void CDeleteViewResponse::copy(CDeleteViewResponse &from)
{
	m_viewname.copy(from.m_viewname);
}


void CDeleteViewResponse::copy(IConstDeleteViewResponse &ifrom)
{
	setViewname(ifrom.getViewname());
}


void CDeleteViewResponse::getAttributes(IProperties &attributes)
{
}


void CDeleteViewResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
		m_viewname.toStr(ctx, buffer, "viewname", "", true, "", "");
	}
}


void CDeleteViewResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CDeleteViewResponse::serializer(IEspContext* ctx, IConstDeleteViewResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<DeleteViewResponse>");
	// field viewname
	{
		const char* s = src.getViewname();
		if (s && *s)
		{
			buffer.append("<viewname>");
			encodeUtf8XML(s,buffer);
			buffer.append("</viewname>");
		}
	}
	if (keepRootTag)
		buffer.append("</DeleteViewResponse>");
}

bool CDeleteViewResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
		hasValue |= m_viewname.unmarshall(rpc_request, "viewname", basepath);
	}
	return hasValue;
}

bool CDeleteViewResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_viewname.unmarshall(ctx, soapval, "viewname");
	return hasValue;
}

bool CDeleteViewResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_viewname.unmarshall(ctx, params, attachments, "viewname", basepath);
	return hasValue;
}

const char * CDeleteViewResponse::getViewname() { return m_viewname.query();}
void CDeleteViewResponse::setViewname(const char * val){ m_viewname.set(val); }
extern "C"  IEspDeleteViewResponse *createDeleteViewResponse(const char *serv){return ((IEspDeleteViewResponse *)new CDeleteViewResponse(serv));}
extern "C"  IClientDeleteViewResponse *createClientDeleteViewResponse(const char *serv){return ((IClientDeleteViewResponse *)new CDeleteViewResponse(serv));}

//=======================================================
// class CViewColumn Implementation
//=======================================================

CViewColumn::CViewColumn(const char *serviceName, IRpcMessageBinding *init)
	: m_viewname(nilIgnore),m_filename(nilIgnore),m_columnname(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ViewColumn");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CViewColumn::CViewColumn(const char *serviceName, const char *bc)
	: m_viewname(nilIgnore),m_filename(nilIgnore),m_columnname(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ViewColumn");
}

StringBuffer &CViewColumn::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:complexType name=\"%s\">\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"viewname\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"filename\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"columnname\" type=\"xsd:string\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType>\n");
		}
	}
	return schema;
}

void CViewColumn::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CViewColumn::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CViewColumn::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("viewname");
	form.appendf("  <tr><td><b>viewname: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("filename");
	form.appendf("  <tr><td><b>filename: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("columnname");
	form.appendf("  <tr><td><b>columnname: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CViewColumn::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CViewColumn::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_viewname.marshall(rpc_resp, "viewname", "", "", "");
	m_filename.marshall(rpc_resp, "filename", "", "", "");
	m_columnname.marshall(rpc_resp, "columnname", "", "", "");
}


void CViewColumn::copy(CViewColumn &from)
{
	m_viewname.copy(from.m_viewname);
	m_filename.copy(from.m_filename);
	m_columnname.copy(from.m_columnname);
}


void CViewColumn::copy(IConstViewColumn &ifrom)
{
	setViewname(ifrom.getViewname());
	setFilename(ifrom.getFilename());
	setColumnname(ifrom.getColumnname());
}


void CViewColumn::getAttributes(IProperties &attributes)
{
}


void CViewColumn::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_viewname.toStr(ctx, buffer, "viewname", "", true, "", "");
	m_filename.toStr(ctx, buffer, "filename", "", true, "", "");
	m_columnname.toStr(ctx, buffer, "columnname", "", true, "", "");
}


void CViewColumn::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CViewColumn::serializer(IEspContext* ctx, IConstViewColumn &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<ViewColumn>");
	// field viewname
	{
		const char* s = src.getViewname();
		if (s && *s)
		{
			buffer.append("<viewname>");
			encodeUtf8XML(s,buffer);
			buffer.append("</viewname>");
		}
	}
	// field filename
	{
		const char* s = src.getFilename();
		if (s && *s)
		{
			buffer.append("<filename>");
			encodeUtf8XML(s,buffer);
			buffer.append("</filename>");
		}
	}
	// field columnname
	{
		const char* s = src.getColumnname();
		if (s && *s)
		{
			buffer.append("<columnname>");
			encodeUtf8XML(s,buffer);
			buffer.append("</columnname>");
		}
	}
	if (keepRootTag)
		buffer.append("</ViewColumn>");
}

bool CViewColumn::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_viewname.unmarshall(rpc_request, "viewname", basepath);
	hasValue |= m_filename.unmarshall(rpc_request, "filename", basepath);
	hasValue |= m_columnname.unmarshall(rpc_request, "columnname", basepath);
	return hasValue;
}

bool CViewColumn::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_viewname.unmarshall(ctx, soapval, "viewname");
	hasValue |= m_filename.unmarshall(ctx, soapval, "filename");
	hasValue |= m_columnname.unmarshall(ctx, soapval, "columnname");
	return hasValue;
}

bool CViewColumn::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_viewname.unmarshall(ctx, params, attachments, "viewname", basepath);
	hasValue |= m_filename.unmarshall(ctx, params, attachments, "filename", basepath);
	hasValue |= m_columnname.unmarshall(ctx, params, attachments, "columnname", basepath);
	return hasValue;
}

const char * CViewColumn::getViewname() { return m_viewname.query();}
const char * CViewColumn::getFilename() { return m_filename.query();}
const char * CViewColumn::getColumnname() { return m_columnname.query();}
void CViewColumn::setViewname(const char * val){ m_viewname.set(val); }
void CViewColumn::setFilename(const char * val){ m_filename.set(val); }
void CViewColumn::setColumnname(const char * val){ m_columnname.set(val); }
extern "C"  IEspViewColumn *createViewColumn(const char *serv, const char *msgname){return ((IEspViewColumn *)new CViewColumn(serv /*, msgname*/));}
extern "C"  IClientViewColumn *createClientViewColumn(const char *serv, const char *msgname){return ((IClientViewColumn *)new CViewColumn(serv /*, msgname*/));}

//=======================================================
// class CQueryViewColumnsRequest Implementation
//=======================================================

CQueryViewColumnsRequest::CQueryViewColumnsRequest(const char *serviceName, IRpcMessageBinding *init)
	: m_viewname(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("QueryViewColumnsRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CQueryViewColumnsRequest::CQueryViewColumnsRequest(const char *serviceName, const char *bc)
	: m_viewname(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("QueryViewColumnsRequest");
}

CQueryViewColumnsRequest::CQueryViewColumnsRequest(const char *serviceName, IRpcMessage* rpcmsg)
	: m_viewname(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("QueryViewColumnsRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CQueryViewColumnsRequest::CQueryViewColumnsRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_viewname(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("QueryViewColumnsRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CQueryViewColumnsRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"viewname\" type=\"xsd:string\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CQueryViewColumnsRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CQueryViewColumnsRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CQueryViewColumnsRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("viewname");
	form.appendf("  <tr><td><b>viewname: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CQueryViewColumnsRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CQueryViewColumnsRequest::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_viewname.marshall(rpc_resp, "viewname", "", "", "");
}


void CQueryViewColumnsRequest::copy(CQueryViewColumnsRequest &from)
{
	m_viewname.copy(from.m_viewname);
}


void CQueryViewColumnsRequest::copy(IConstQueryViewColumnsRequest &ifrom)
{
	setViewname(ifrom.getViewname());
}


void CQueryViewColumnsRequest::getAttributes(IProperties &attributes)
{
}


void CQueryViewColumnsRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_viewname.toStr(ctx, buffer, "viewname", "", true, "", "");
}


void CQueryViewColumnsRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CQueryViewColumnsRequest::serializer(IEspContext* ctx, IConstQueryViewColumnsRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<QueryViewColumnsRequest>");
	// field viewname
	{
		const char* s = src.getViewname();
		if (s && *s)
		{
			buffer.append("<viewname>");
			encodeUtf8XML(s,buffer);
			buffer.append("</viewname>");
		}
	}
	if (keepRootTag)
		buffer.append("</QueryViewColumnsRequest>");
}

bool CQueryViewColumnsRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_viewname.unmarshall(rpc_request, "viewname", basepath);
	return hasValue;
}

bool CQueryViewColumnsRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_viewname.unmarshall(ctx, soapval, "viewname");
	return hasValue;
}

bool CQueryViewColumnsRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_viewname.unmarshall(ctx, params, attachments, "viewname", basepath);
	return hasValue;
}

const char * CQueryViewColumnsRequest::getViewname() { return m_viewname.query();}
void CQueryViewColumnsRequest::setViewname(const char * val){ m_viewname.set(val); }
extern "C"  IEspQueryViewColumnsRequest *createQueryViewColumnsRequest(const char *serv){return ((IEspQueryViewColumnsRequest *)new CQueryViewColumnsRequest(serv));}
extern "C"  IClientQueryViewColumnsRequest *createClientQueryViewColumnsRequest(const char *serv){return ((IClientQueryViewColumnsRequest *)new CQueryViewColumnsRequest(serv));}

//=======================================================
// class CQueryViewColumnsResponse Implementation
//=======================================================

CQueryViewColumnsResponse::CQueryViewColumnsResponse(const char *serviceName, IRpcMessageBinding *init)
	: m_viewname(nilIgnore),m_viewcolumns(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("QueryViewColumnsResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CQueryViewColumnsResponse::CQueryViewColumnsResponse(const char *serviceName, const char *bc)
	: m_viewname(nilIgnore),m_viewcolumns(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("QueryViewColumnsResponse");
}

CQueryViewColumnsResponse::CQueryViewColumnsResponse(const char *serviceName, IRpcMessage* rpcmsg)
	: m_viewname(nilIgnore),m_viewcolumns(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("QueryViewColumnsResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CQueryViewColumnsResponse::CQueryViewColumnsResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_viewname(nilIgnore),m_viewcolumns(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("QueryViewColumnsResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CQueryViewColumnsResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"viewname\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"viewcolumns\" type=\"tns:ArrayOfViewColumn\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	if (!(flags & 0x10)  || (flags & 0x100))
	{
		CViewColumn::getXsdDefinition(context, request, schema, added);
	}
	if (added.getValue("ViewColumn") && added.getValue("ArrayOfViewColumn")==NULL) {
		schema.append("<xsd:complexType name=\"ArrayOfViewColumn\">\n");
		schema.append("<xsd:sequence>\n");
		schema.append("<xsd:element minOccurs=\"0\" maxOccurs=\"unbounded\" name=\"ViewColumn\" type=\"tns:ViewColumn\"/>\n");
		schema.append("</xsd:sequence>\n");
		schema.append("</xsd:complexType>\n");
		added.setValue("ArrayOfViewColumn",1);
	}
	return schema;
}

void CQueryViewColumnsResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CQueryViewColumnsResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
	if (!added.getValue("ViewColumn"))
	{
		added.setValue("ViewColumn",1);
		CViewColumn::getMapInfo(info,added);
	}
}

StringBuffer &CQueryViewColumnsResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("viewname");
	form.appendf("  <tr><td><b>viewname: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("viewcolumns");
	form.appendf("<tr><td><b>viewcolumns: </b></td><td>");
	form.appendf("<table><tr><td><textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea></td>", extfix.str());
	form.append("</tr></table>");
	form.append("</td></tr>");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CQueryViewColumnsResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CQueryViewColumnsResponse::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
		m_viewname.marshall(rpc_resp, "viewname", "", "", "");
		m_viewcolumns.marshall(rpc_resp, "viewcolumns", "ViewColumn");
	}
}


void CQueryViewColumnsResponse::copy(CQueryViewColumnsResponse &from)
{
	m_viewname.copy(from.m_viewname);
	m_viewcolumns.copy(from.m_viewcolumns);
}


void CQueryViewColumnsResponse::copy(IConstQueryViewColumnsResponse &ifrom)
{
	setViewname(ifrom.getViewname());
	setViewcolumns(ifrom.getViewcolumns());
}


void CQueryViewColumnsResponse::getAttributes(IProperties &attributes)
{
}


void CQueryViewColumnsResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
		m_viewname.toStr(ctx, buffer, "viewname", "", true, "", "");
		m_viewcolumns.toStr(ctx, buffer, "viewcolumns", "ViewColumn");
	}
}


void CQueryViewColumnsResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CQueryViewColumnsResponse::serializer(IEspContext* ctx, IConstQueryViewColumnsResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<QueryViewColumnsResponse>");
	// field viewname
	{
		const char* s = src.getViewname();
		if (s && *s)
		{
			buffer.append("<viewname>");
			encodeUtf8XML(s,buffer);
			buffer.append("</viewname>");
		}
	}
	// field viewcolumns
	{
		IArrayOf<IConstViewColumn>& v = src.getViewcolumns();
		int size = v.length();
		if (size>0)
			buffer.append("<viewcolumns>");
		for (int i=0;i<size;i++)
		{
			buffer.append("<Item>");
			CViewColumn::serializer(ctx,v.item(i),buffer,false);
			buffer.append("</Item>");
		}
		if (size>0)
			buffer.append("</viewcolumns>");
	}
	if (keepRootTag)
		buffer.append("</QueryViewColumnsResponse>");
}

bool CQueryViewColumnsResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
		hasValue |= m_viewname.unmarshall(rpc_request, "viewname", basepath);
		hasValue |= m_viewcolumns.unmarshall(rpc_request, "viewcolumns", basepath);
	}
	return hasValue;
}

bool CQueryViewColumnsResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_viewname.unmarshall(ctx, soapval, "viewname");
	hasValue |= m_viewcolumns.unmarshall(ctx, soapval, "viewcolumns");
	return hasValue;
}

bool CQueryViewColumnsResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_viewname.unmarshall(ctx, params, attachments, "viewname", basepath);
	hasValue |= m_viewcolumns.unmarshall(ctx, params, attachments, "viewcolumns", basepath);
	return hasValue;
}

const char * CQueryViewColumnsResponse::getViewname() { return m_viewname.query();}
IArrayOf<IConstViewColumn> & CQueryViewColumnsResponse::getViewcolumns() { return (IArrayOf<IConstViewColumn> &) m_viewcolumns; }
void CQueryViewColumnsResponse::setViewname(const char * val){ m_viewname.set(val); }
void CQueryViewColumnsResponse::setViewcolumns(IArrayOf<IEspViewColumn> &val)
{
	m_viewcolumns->kill();
	IArrayOf<IConstViewColumn> &target = m_viewcolumns.getValue();
	ForEachItemIn(idx, val)
	{
		IEspViewColumn &item = (val).item(idx);
		item.Link();
		target.append(item);
	}
}
void CQueryViewColumnsResponse::setViewcolumns(IArrayOf<IConstViewColumn> &val)
{
	m_viewcolumns->kill();
	IArrayOf<IConstViewColumn> &target = m_viewcolumns.getValue();
	ForEachItemIn(idx, val)
	{
		IConstViewColumn &item = val.item(idx);
		item.Link();
		target.append(item);
	}
}
extern "C"  IEspQueryViewColumnsResponse *createQueryViewColumnsResponse(const char *serv){return ((IEspQueryViewColumnsResponse *)new CQueryViewColumnsResponse(serv));}
extern "C"  IClientQueryViewColumnsResponse *createClientQueryViewColumnsResponse(const char *serv){return ((IClientQueryViewColumnsResponse *)new CQueryViewColumnsResponse(serv));}

//=======================================================
// class CAddViewColumnRequest Implementation
//=======================================================

CAddViewColumnRequest::CAddViewColumnRequest(const char *serviceName, IRpcMessageBinding *init)
	: m_viewname(nilIgnore),m_filename(nilIgnore),m_columnname(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("AddViewColumnRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CAddViewColumnRequest::CAddViewColumnRequest(const char *serviceName, const char *bc)
	: m_viewname(nilIgnore),m_filename(nilIgnore),m_columnname(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("AddViewColumnRequest");
}

CAddViewColumnRequest::CAddViewColumnRequest(const char *serviceName, IRpcMessage* rpcmsg)
	: m_viewname(nilIgnore),m_filename(nilIgnore),m_columnname(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("AddViewColumnRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CAddViewColumnRequest::CAddViewColumnRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_viewname(nilIgnore),m_filename(nilIgnore),m_columnname(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("AddViewColumnRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CAddViewColumnRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"viewname\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"filename\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"columnname\" type=\"xsd:string\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CAddViewColumnRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CAddViewColumnRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CAddViewColumnRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("viewname");
	form.appendf("  <tr><td><b>viewname: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("filename");
	form.appendf("  <tr><td><b>filename: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("columnname");
	form.appendf("  <tr><td><b>columnname: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CAddViewColumnRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CAddViewColumnRequest::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_viewname.marshall(rpc_resp, "viewname", "", "", "");
	m_filename.marshall(rpc_resp, "filename", "", "", "");
	m_columnname.marshall(rpc_resp, "columnname", "", "", "");
}


void CAddViewColumnRequest::copy(CAddViewColumnRequest &from)
{
	m_viewname.copy(from.m_viewname);
	m_filename.copy(from.m_filename);
	m_columnname.copy(from.m_columnname);
}


void CAddViewColumnRequest::copy(IConstAddViewColumnRequest &ifrom)
{
	setViewname(ifrom.getViewname());
	setFilename(ifrom.getFilename());
	setColumnname(ifrom.getColumnname());
}


void CAddViewColumnRequest::getAttributes(IProperties &attributes)
{
}


void CAddViewColumnRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_viewname.toStr(ctx, buffer, "viewname", "", true, "", "");
	m_filename.toStr(ctx, buffer, "filename", "", true, "", "");
	m_columnname.toStr(ctx, buffer, "columnname", "", true, "", "");
}


void CAddViewColumnRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CAddViewColumnRequest::serializer(IEspContext* ctx, IConstAddViewColumnRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<AddViewColumnRequest>");
	// field viewname
	{
		const char* s = src.getViewname();
		if (s && *s)
		{
			buffer.append("<viewname>");
			encodeUtf8XML(s,buffer);
			buffer.append("</viewname>");
		}
	}
	// field filename
	{
		const char* s = src.getFilename();
		if (s && *s)
		{
			buffer.append("<filename>");
			encodeUtf8XML(s,buffer);
			buffer.append("</filename>");
		}
	}
	// field columnname
	{
		const char* s = src.getColumnname();
		if (s && *s)
		{
			buffer.append("<columnname>");
			encodeUtf8XML(s,buffer);
			buffer.append("</columnname>");
		}
	}
	if (keepRootTag)
		buffer.append("</AddViewColumnRequest>");
}

bool CAddViewColumnRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_viewname.unmarshall(rpc_request, "viewname", basepath);
	hasValue |= m_filename.unmarshall(rpc_request, "filename", basepath);
	hasValue |= m_columnname.unmarshall(rpc_request, "columnname", basepath);
	return hasValue;
}

bool CAddViewColumnRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_viewname.unmarshall(ctx, soapval, "viewname");
	hasValue |= m_filename.unmarshall(ctx, soapval, "filename");
	hasValue |= m_columnname.unmarshall(ctx, soapval, "columnname");
	return hasValue;
}

bool CAddViewColumnRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_viewname.unmarshall(ctx, params, attachments, "viewname", basepath);
	hasValue |= m_filename.unmarshall(ctx, params, attachments, "filename", basepath);
	hasValue |= m_columnname.unmarshall(ctx, params, attachments, "columnname", basepath);
	return hasValue;
}

const char * CAddViewColumnRequest::getViewname() { return m_viewname.query();}
const char * CAddViewColumnRequest::getFilename() { return m_filename.query();}
const char * CAddViewColumnRequest::getColumnname() { return m_columnname.query();}
void CAddViewColumnRequest::setViewname(const char * val){ m_viewname.set(val); }
void CAddViewColumnRequest::setFilename(const char * val){ m_filename.set(val); }
void CAddViewColumnRequest::setColumnname(const char * val){ m_columnname.set(val); }
extern "C"  IEspAddViewColumnRequest *createAddViewColumnRequest(const char *serv){return ((IEspAddViewColumnRequest *)new CAddViewColumnRequest(serv));}
extern "C"  IClientAddViewColumnRequest *createClientAddViewColumnRequest(const char *serv){return ((IClientAddViewColumnRequest *)new CAddViewColumnRequest(serv));}

//=======================================================
// class CAddViewColumnResponse Implementation
//=======================================================

CAddViewColumnResponse::CAddViewColumnResponse(const char *serviceName, IRpcMessageBinding *init)
	: m_viewname(nilIgnore),m_filename(nilIgnore),m_columnname(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("AddViewColumnResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CAddViewColumnResponse::CAddViewColumnResponse(const char *serviceName, const char *bc)
	: m_viewname(nilIgnore),m_filename(nilIgnore),m_columnname(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("AddViewColumnResponse");
}

CAddViewColumnResponse::CAddViewColumnResponse(const char *serviceName, IRpcMessage* rpcmsg)
	: m_viewname(nilIgnore),m_filename(nilIgnore),m_columnname(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("AddViewColumnResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CAddViewColumnResponse::CAddViewColumnResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_viewname(nilIgnore),m_filename(nilIgnore),m_columnname(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("AddViewColumnResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CAddViewColumnResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"viewname\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"filename\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"columnname\" type=\"xsd:string\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CAddViewColumnResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CAddViewColumnResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CAddViewColumnResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("viewname");
	form.appendf("  <tr><td><b>viewname: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("filename");
	form.appendf("  <tr><td><b>filename: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("columnname");
	form.appendf("  <tr><td><b>columnname: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CAddViewColumnResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CAddViewColumnResponse::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
		m_viewname.marshall(rpc_resp, "viewname", "", "", "");
		m_filename.marshall(rpc_resp, "filename", "", "", "");
		m_columnname.marshall(rpc_resp, "columnname", "", "", "");
	}
}


void CAddViewColumnResponse::copy(CAddViewColumnResponse &from)
{
	m_viewname.copy(from.m_viewname);
	m_filename.copy(from.m_filename);
	m_columnname.copy(from.m_columnname);
}


void CAddViewColumnResponse::copy(IConstAddViewColumnResponse &ifrom)
{
	setViewname(ifrom.getViewname());
	setFilename(ifrom.getFilename());
	setColumnname(ifrom.getColumnname());
}


void CAddViewColumnResponse::getAttributes(IProperties &attributes)
{
}


void CAddViewColumnResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
		m_viewname.toStr(ctx, buffer, "viewname", "", true, "", "");
		m_filename.toStr(ctx, buffer, "filename", "", true, "", "");
		m_columnname.toStr(ctx, buffer, "columnname", "", true, "", "");
	}
}


void CAddViewColumnResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CAddViewColumnResponse::serializer(IEspContext* ctx, IConstAddViewColumnResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<AddViewColumnResponse>");
	// field viewname
	{
		const char* s = src.getViewname();
		if (s && *s)
		{
			buffer.append("<viewname>");
			encodeUtf8XML(s,buffer);
			buffer.append("</viewname>");
		}
	}
	// field filename
	{
		const char* s = src.getFilename();
		if (s && *s)
		{
			buffer.append("<filename>");
			encodeUtf8XML(s,buffer);
			buffer.append("</filename>");
		}
	}
	// field columnname
	{
		const char* s = src.getColumnname();
		if (s && *s)
		{
			buffer.append("<columnname>");
			encodeUtf8XML(s,buffer);
			buffer.append("</columnname>");
		}
	}
	if (keepRootTag)
		buffer.append("</AddViewColumnResponse>");
}

bool CAddViewColumnResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
		hasValue |= m_viewname.unmarshall(rpc_request, "viewname", basepath);
		hasValue |= m_filename.unmarshall(rpc_request, "filename", basepath);
		hasValue |= m_columnname.unmarshall(rpc_request, "columnname", basepath);
	}
	return hasValue;
}

bool CAddViewColumnResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_viewname.unmarshall(ctx, soapval, "viewname");
	hasValue |= m_filename.unmarshall(ctx, soapval, "filename");
	hasValue |= m_columnname.unmarshall(ctx, soapval, "columnname");
	return hasValue;
}

bool CAddViewColumnResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_viewname.unmarshall(ctx, params, attachments, "viewname", basepath);
	hasValue |= m_filename.unmarshall(ctx, params, attachments, "filename", basepath);
	hasValue |= m_columnname.unmarshall(ctx, params, attachments, "columnname", basepath);
	return hasValue;
}

const char * CAddViewColumnResponse::getViewname() { return m_viewname.query();}
const char * CAddViewColumnResponse::getFilename() { return m_filename.query();}
const char * CAddViewColumnResponse::getColumnname() { return m_columnname.query();}
void CAddViewColumnResponse::setViewname(const char * val){ m_viewname.set(val); }
void CAddViewColumnResponse::setFilename(const char * val){ m_filename.set(val); }
void CAddViewColumnResponse::setColumnname(const char * val){ m_columnname.set(val); }
extern "C"  IEspAddViewColumnResponse *createAddViewColumnResponse(const char *serv){return ((IEspAddViewColumnResponse *)new CAddViewColumnResponse(serv));}
extern "C"  IClientAddViewColumnResponse *createClientAddViewColumnResponse(const char *serv){return ((IClientAddViewColumnResponse *)new CAddViewColumnResponse(serv));}

//=======================================================
// class CDeleteViewColumnRequest Implementation
//=======================================================

CDeleteViewColumnRequest::CDeleteViewColumnRequest(const char *serviceName, IRpcMessageBinding *init)
	: m_viewname(nilIgnore),m_filename(nilIgnore),m_columnname(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("DeleteViewColumnRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CDeleteViewColumnRequest::CDeleteViewColumnRequest(const char *serviceName, const char *bc)
	: m_viewname(nilIgnore),m_filename(nilIgnore),m_columnname(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("DeleteViewColumnRequest");
}

CDeleteViewColumnRequest::CDeleteViewColumnRequest(const char *serviceName, IRpcMessage* rpcmsg)
	: m_viewname(nilIgnore),m_filename(nilIgnore),m_columnname(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("DeleteViewColumnRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CDeleteViewColumnRequest::CDeleteViewColumnRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_viewname(nilIgnore),m_filename(nilIgnore),m_columnname(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("DeleteViewColumnRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CDeleteViewColumnRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"viewname\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"filename\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"columnname\" type=\"xsd:string\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CDeleteViewColumnRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CDeleteViewColumnRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CDeleteViewColumnRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("viewname");
	form.appendf("  <tr><td><b>viewname: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("filename");
	form.appendf("  <tr><td><b>filename: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("columnname");
	form.appendf("  <tr><td><b>columnname: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CDeleteViewColumnRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CDeleteViewColumnRequest::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_viewname.marshall(rpc_resp, "viewname", "", "", "");
	m_filename.marshall(rpc_resp, "filename", "", "", "");
	m_columnname.marshall(rpc_resp, "columnname", "", "", "");
}


void CDeleteViewColumnRequest::copy(CDeleteViewColumnRequest &from)
{
	m_viewname.copy(from.m_viewname);
	m_filename.copy(from.m_filename);
	m_columnname.copy(from.m_columnname);
}


void CDeleteViewColumnRequest::copy(IConstDeleteViewColumnRequest &ifrom)
{
	setViewname(ifrom.getViewname());
	setFilename(ifrom.getFilename());
	setColumnname(ifrom.getColumnname());
}


void CDeleteViewColumnRequest::getAttributes(IProperties &attributes)
{
}


void CDeleteViewColumnRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_viewname.toStr(ctx, buffer, "viewname", "", true, "", "");
	m_filename.toStr(ctx, buffer, "filename", "", true, "", "");
	m_columnname.toStr(ctx, buffer, "columnname", "", true, "", "");
}


void CDeleteViewColumnRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CDeleteViewColumnRequest::serializer(IEspContext* ctx, IConstDeleteViewColumnRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<DeleteViewColumnRequest>");
	// field viewname
	{
		const char* s = src.getViewname();
		if (s && *s)
		{
			buffer.append("<viewname>");
			encodeUtf8XML(s,buffer);
			buffer.append("</viewname>");
		}
	}
	// field filename
	{
		const char* s = src.getFilename();
		if (s && *s)
		{
			buffer.append("<filename>");
			encodeUtf8XML(s,buffer);
			buffer.append("</filename>");
		}
	}
	// field columnname
	{
		const char* s = src.getColumnname();
		if (s && *s)
		{
			buffer.append("<columnname>");
			encodeUtf8XML(s,buffer);
			buffer.append("</columnname>");
		}
	}
	if (keepRootTag)
		buffer.append("</DeleteViewColumnRequest>");
}

bool CDeleteViewColumnRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_viewname.unmarshall(rpc_request, "viewname", basepath);
	hasValue |= m_filename.unmarshall(rpc_request, "filename", basepath);
	hasValue |= m_columnname.unmarshall(rpc_request, "columnname", basepath);
	return hasValue;
}

bool CDeleteViewColumnRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_viewname.unmarshall(ctx, soapval, "viewname");
	hasValue |= m_filename.unmarshall(ctx, soapval, "filename");
	hasValue |= m_columnname.unmarshall(ctx, soapval, "columnname");
	return hasValue;
}

bool CDeleteViewColumnRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_viewname.unmarshall(ctx, params, attachments, "viewname", basepath);
	hasValue |= m_filename.unmarshall(ctx, params, attachments, "filename", basepath);
	hasValue |= m_columnname.unmarshall(ctx, params, attachments, "columnname", basepath);
	return hasValue;
}

const char * CDeleteViewColumnRequest::getViewname() { return m_viewname.query();}
const char * CDeleteViewColumnRequest::getFilename() { return m_filename.query();}
const char * CDeleteViewColumnRequest::getColumnname() { return m_columnname.query();}
void CDeleteViewColumnRequest::setViewname(const char * val){ m_viewname.set(val); }
void CDeleteViewColumnRequest::setFilename(const char * val){ m_filename.set(val); }
void CDeleteViewColumnRequest::setColumnname(const char * val){ m_columnname.set(val); }
extern "C"  IEspDeleteViewColumnRequest *createDeleteViewColumnRequest(const char *serv){return ((IEspDeleteViewColumnRequest *)new CDeleteViewColumnRequest(serv));}
extern "C"  IClientDeleteViewColumnRequest *createClientDeleteViewColumnRequest(const char *serv){return ((IClientDeleteViewColumnRequest *)new CDeleteViewColumnRequest(serv));}

//=======================================================
// class CDeleteViewColumnResponse Implementation
//=======================================================

CDeleteViewColumnResponse::CDeleteViewColumnResponse(const char *serviceName, IRpcMessageBinding *init)
	: m_viewname(nilIgnore),m_filename(nilIgnore),m_columnname(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("DeleteViewColumnResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CDeleteViewColumnResponse::CDeleteViewColumnResponse(const char *serviceName, const char *bc)
	: m_viewname(nilIgnore),m_filename(nilIgnore),m_columnname(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("DeleteViewColumnResponse");
}

CDeleteViewColumnResponse::CDeleteViewColumnResponse(const char *serviceName, IRpcMessage* rpcmsg)
	: m_viewname(nilIgnore),m_filename(nilIgnore),m_columnname(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("DeleteViewColumnResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CDeleteViewColumnResponse::CDeleteViewColumnResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_viewname(nilIgnore),m_filename(nilIgnore),m_columnname(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("DeleteViewColumnResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CDeleteViewColumnResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"viewname\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"filename\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"columnname\" type=\"xsd:string\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CDeleteViewColumnResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CDeleteViewColumnResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CDeleteViewColumnResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("viewname");
	form.appendf("  <tr><td><b>viewname: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("filename");
	form.appendf("  <tr><td><b>filename: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("columnname");
	form.appendf("  <tr><td><b>columnname: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CDeleteViewColumnResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CDeleteViewColumnResponse::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
		m_viewname.marshall(rpc_resp, "viewname", "", "", "");
		m_filename.marshall(rpc_resp, "filename", "", "", "");
		m_columnname.marshall(rpc_resp, "columnname", "", "", "");
	}
}


void CDeleteViewColumnResponse::copy(CDeleteViewColumnResponse &from)
{
	m_viewname.copy(from.m_viewname);
	m_filename.copy(from.m_filename);
	m_columnname.copy(from.m_columnname);
}


void CDeleteViewColumnResponse::copy(IConstDeleteViewColumnResponse &ifrom)
{
	setViewname(ifrom.getViewname());
	setFilename(ifrom.getFilename());
	setColumnname(ifrom.getColumnname());
}


void CDeleteViewColumnResponse::getAttributes(IProperties &attributes)
{
}


void CDeleteViewColumnResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
		m_viewname.toStr(ctx, buffer, "viewname", "", true, "", "");
		m_filename.toStr(ctx, buffer, "filename", "", true, "", "");
		m_columnname.toStr(ctx, buffer, "columnname", "", true, "", "");
	}
}


void CDeleteViewColumnResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CDeleteViewColumnResponse::serializer(IEspContext* ctx, IConstDeleteViewColumnResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<DeleteViewColumnResponse>");
	// field viewname
	{
		const char* s = src.getViewname();
		if (s && *s)
		{
			buffer.append("<viewname>");
			encodeUtf8XML(s,buffer);
			buffer.append("</viewname>");
		}
	}
	// field filename
	{
		const char* s = src.getFilename();
		if (s && *s)
		{
			buffer.append("<filename>");
			encodeUtf8XML(s,buffer);
			buffer.append("</filename>");
		}
	}
	// field columnname
	{
		const char* s = src.getColumnname();
		if (s && *s)
		{
			buffer.append("<columnname>");
			encodeUtf8XML(s,buffer);
			buffer.append("</columnname>");
		}
	}
	if (keepRootTag)
		buffer.append("</DeleteViewColumnResponse>");
}

bool CDeleteViewColumnResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
		hasValue |= m_viewname.unmarshall(rpc_request, "viewname", basepath);
		hasValue |= m_filename.unmarshall(rpc_request, "filename", basepath);
		hasValue |= m_columnname.unmarshall(rpc_request, "columnname", basepath);
	}
	return hasValue;
}

bool CDeleteViewColumnResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_viewname.unmarshall(ctx, soapval, "viewname");
	hasValue |= m_filename.unmarshall(ctx, soapval, "filename");
	hasValue |= m_columnname.unmarshall(ctx, soapval, "columnname");
	return hasValue;
}

bool CDeleteViewColumnResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_viewname.unmarshall(ctx, params, attachments, "viewname", basepath);
	hasValue |= m_filename.unmarshall(ctx, params, attachments, "filename", basepath);
	hasValue |= m_columnname.unmarshall(ctx, params, attachments, "columnname", basepath);
	return hasValue;
}

const char * CDeleteViewColumnResponse::getViewname() { return m_viewname.query();}
const char * CDeleteViewColumnResponse::getFilename() { return m_filename.query();}
const char * CDeleteViewColumnResponse::getColumnname() { return m_columnname.query();}
void CDeleteViewColumnResponse::setViewname(const char * val){ m_viewname.set(val); }
void CDeleteViewColumnResponse::setFilename(const char * val){ m_filename.set(val); }
void CDeleteViewColumnResponse::setColumnname(const char * val){ m_columnname.set(val); }
extern "C"  IEspDeleteViewColumnResponse *createDeleteViewColumnResponse(const char *serv){return ((IEspDeleteViewColumnResponse *)new CDeleteViewColumnResponse(serv));}
extern "C"  IClientDeleteViewColumnResponse *createClientDeleteViewColumnResponse(const char *serv){return ((IClientDeleteViewColumnResponse *)new CDeleteViewColumnResponse(serv));}

//=======================================================
// class CViewMember Implementation
//=======================================================

CViewMember::CViewMember(const char *serviceName, IRpcMessageBinding *init)
	: m_viewname(nilIgnore),m_name(nilIgnore),m_membertype(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ViewMember");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CViewMember::CViewMember(const char *serviceName, const char *bc)
	: m_viewname(nilIgnore),m_name(nilIgnore),m_membertype(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ViewMember");
}

StringBuffer &CViewMember::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:complexType name=\"%s\">\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"viewname\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"name\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"membertype\" type=\"tns:ViewMemberType\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType>\n");
		}
	}
	if (!(flags & 0x10)  || (flags & 0x100))
	{
		CXViewMemberType::getXsdDefinition(context, request, schema, added);
	}
	return schema;
}

void CViewMember::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CViewMember::getMapInfo(IMapInfo& info, BoolHash& added)
{
	if (!added.getValue("ViewMemberType"))
	{
		added.setValue("ViewMemberType",1);
		CXViewMemberType::getMapInfo(info,added);
	}
}

StringBuffer &CViewMember::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("viewname");
	form.appendf("  <tr><td><b>viewname: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("name");
	form.appendf("  <tr><td><b>name: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("membertype");
	form.appendf("  <tr><td><b>membertype: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CViewMember::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CViewMember::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_viewname.marshall(rpc_resp, "viewname", "", "", "");
	m_name.marshall(rpc_resp, "name", "", "", "");
	m_membertype.marshall(rpc_resp, "membertype", "", "", "");
}


void CViewMember::copy(CViewMember &from)
{
	m_viewname.copy(from.m_viewname);
	m_name.copy(from.m_name);
	m_membertype.copy(from.m_membertype);
}


void CViewMember::copy(IConstViewMember &ifrom)
{
	setViewname(ifrom.getViewname());
	setName(ifrom.getName());
	setMembertype(ifrom.getMembertype());
}


void CViewMember::getAttributes(IProperties &attributes)
{
}


void CViewMember::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_viewname.toStr(ctx, buffer, "viewname", "", true, "", "");
	m_name.toStr(ctx, buffer, "name", "", true, "", "");
	m_membertype.toStr(ctx, buffer, "membertype", "", true, "", "");
}


void CViewMember::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CViewMember::serializer(IEspContext* ctx, IConstViewMember &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<ViewMember>");
	// field viewname
	{
		const char* s = src.getViewname();
		if (s && *s)
		{
			buffer.append("<viewname>");
			encodeUtf8XML(s,buffer);
			buffer.append("</viewname>");
		}
	}
	// field name
	{
		const char* s = src.getName();
		if (s && *s)
		{
			buffer.append("<name>");
			encodeUtf8XML(s,buffer);
			buffer.append("</name>");
		}
	}
	// field membertype
	{
		const char* s = src.getMembertypeAsString();
		buffer.append("<membertype>");
		encodeUtf8XML(s,buffer);
		buffer.append("</membertype>");
	}
	if (keepRootTag)
		buffer.append("</ViewMember>");
}

bool CViewMember::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_viewname.unmarshall(rpc_request, "viewname", basepath);
	hasValue |= m_name.unmarshall(rpc_request, "name", basepath);
	hasValue |= m_membertype.unmarshall(rpc_request, "membertype", basepath);
	return hasValue;
}

bool CViewMember::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_viewname.unmarshall(ctx, soapval, "viewname");
	hasValue |= m_name.unmarshall(ctx, soapval, "name");
	hasValue |= m_membertype.unmarshall(ctx, soapval, "membertype");
	return hasValue;
}

bool CViewMember::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_viewname.unmarshall(ctx, params, attachments, "viewname", basepath);
	hasValue |= m_name.unmarshall(ctx, params, attachments, "name", basepath);
	hasValue |= m_membertype.unmarshall(ctx, params, attachments, "membertype", basepath);
	return hasValue;
}

const char * CViewMember::getViewname() { return m_viewname.query();}
const char * CViewMember::getName() { return m_name.query();}
CViewMemberType CViewMember::getMembertype() { return m_membertype.getValue(); }
const char* CViewMember::getMembertypeAsString() {  return (const char*)m_membertype; }
void CViewMember::setViewname(const char * val){ m_viewname.set(val); }
void CViewMember::setName(const char * val){ m_name.set(val); }
void CViewMember::setMembertype(CViewMemberType val) { m_membertype.setValue(val); }
void CViewMember::setMembertype(const char* val) { m_membertype.setValue(val); }
extern "C"  IEspViewMember *createViewMember(const char *serv, const char *msgname){return ((IEspViewMember *)new CViewMember(serv /*, msgname*/));}
extern "C"  IClientViewMember *createClientViewMember(const char *serv, const char *msgname){return ((IClientViewMember *)new CViewMember(serv /*, msgname*/));}

//=======================================================
// class CQueryViewMembersRequest Implementation
//=======================================================

CQueryViewMembersRequest::CQueryViewMembersRequest(const char *serviceName, IRpcMessageBinding *init)
	: m_viewname(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("QueryViewMembersRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CQueryViewMembersRequest::CQueryViewMembersRequest(const char *serviceName, const char *bc)
	: m_viewname(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("QueryViewMembersRequest");
}

CQueryViewMembersRequest::CQueryViewMembersRequest(const char *serviceName, IRpcMessage* rpcmsg)
	: m_viewname(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("QueryViewMembersRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CQueryViewMembersRequest::CQueryViewMembersRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_viewname(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("QueryViewMembersRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CQueryViewMembersRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"viewname\" type=\"xsd:string\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CQueryViewMembersRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CQueryViewMembersRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CQueryViewMembersRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("viewname");
	form.appendf("  <tr><td><b>viewname: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CQueryViewMembersRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CQueryViewMembersRequest::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_viewname.marshall(rpc_resp, "viewname", "", "", "");
}


void CQueryViewMembersRequest::copy(CQueryViewMembersRequest &from)
{
	m_viewname.copy(from.m_viewname);
}


void CQueryViewMembersRequest::copy(IConstQueryViewMembersRequest &ifrom)
{
	setViewname(ifrom.getViewname());
}


void CQueryViewMembersRequest::getAttributes(IProperties &attributes)
{
}


void CQueryViewMembersRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_viewname.toStr(ctx, buffer, "viewname", "", true, "", "");
}


void CQueryViewMembersRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CQueryViewMembersRequest::serializer(IEspContext* ctx, IConstQueryViewMembersRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<QueryViewMembersRequest>");
	// field viewname
	{
		const char* s = src.getViewname();
		if (s && *s)
		{
			buffer.append("<viewname>");
			encodeUtf8XML(s,buffer);
			buffer.append("</viewname>");
		}
	}
	if (keepRootTag)
		buffer.append("</QueryViewMembersRequest>");
}

bool CQueryViewMembersRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_viewname.unmarshall(rpc_request, "viewname", basepath);
	return hasValue;
}

bool CQueryViewMembersRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_viewname.unmarshall(ctx, soapval, "viewname");
	return hasValue;
}

bool CQueryViewMembersRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_viewname.unmarshall(ctx, params, attachments, "viewname", basepath);
	return hasValue;
}

const char * CQueryViewMembersRequest::getViewname() { return m_viewname.query();}
void CQueryViewMembersRequest::setViewname(const char * val){ m_viewname.set(val); }
extern "C"  IEspQueryViewMembersRequest *createQueryViewMembersRequest(const char *serv){return ((IEspQueryViewMembersRequest *)new CQueryViewMembersRequest(serv));}
extern "C"  IClientQueryViewMembersRequest *createClientQueryViewMembersRequest(const char *serv){return ((IClientQueryViewMembersRequest *)new CQueryViewMembersRequest(serv));}

//=======================================================
// class CQueryViewMembersResponse Implementation
//=======================================================

CQueryViewMembersResponse::CQueryViewMembersResponse(const char *serviceName, IRpcMessageBinding *init)
	: m_viewname(nilIgnore),m_viewmembers(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("QueryViewMembersResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CQueryViewMembersResponse::CQueryViewMembersResponse(const char *serviceName, const char *bc)
	: m_viewname(nilIgnore),m_viewmembers(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("QueryViewMembersResponse");
}

CQueryViewMembersResponse::CQueryViewMembersResponse(const char *serviceName, IRpcMessage* rpcmsg)
	: m_viewname(nilIgnore),m_viewmembers(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("QueryViewMembersResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CQueryViewMembersResponse::CQueryViewMembersResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_viewname(nilIgnore),m_viewmembers(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("QueryViewMembersResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CQueryViewMembersResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"viewname\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"viewmembers\" type=\"tns:ArrayOfViewMember\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	if (!(flags & 0x10)  || (flags & 0x100))
	{
		CViewMember::getXsdDefinition(context, request, schema, added);
	}
	if (added.getValue("ViewMember") && added.getValue("ArrayOfViewMember")==NULL) {
		schema.append("<xsd:complexType name=\"ArrayOfViewMember\">\n");
		schema.append("<xsd:sequence>\n");
		schema.append("<xsd:element minOccurs=\"0\" maxOccurs=\"unbounded\" name=\"ViewMember\" type=\"tns:ViewMember\"/>\n");
		schema.append("</xsd:sequence>\n");
		schema.append("</xsd:complexType>\n");
		added.setValue("ArrayOfViewMember",1);
	}
	return schema;
}

void CQueryViewMembersResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CQueryViewMembersResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
	if (!added.getValue("ViewMember"))
	{
		added.setValue("ViewMember",1);
		CViewMember::getMapInfo(info,added);
	}
}

StringBuffer &CQueryViewMembersResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("viewname");
	form.appendf("  <tr><td><b>viewname: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("viewmembers");
	form.appendf("<tr><td><b>viewmembers: </b></td><td>");
	form.appendf("<table><tr><td><textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea></td>", extfix.str());
	form.append("</tr></table>");
	form.append("</td></tr>");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CQueryViewMembersResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CQueryViewMembersResponse::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
		m_viewname.marshall(rpc_resp, "viewname", "", "", "");
		m_viewmembers.marshall(rpc_resp, "viewmembers", "ViewMember");
	}
}


void CQueryViewMembersResponse::copy(CQueryViewMembersResponse &from)
{
	m_viewname.copy(from.m_viewname);
	m_viewmembers.copy(from.m_viewmembers);
}


void CQueryViewMembersResponse::copy(IConstQueryViewMembersResponse &ifrom)
{
	setViewname(ifrom.getViewname());
	setViewmembers(ifrom.getViewmembers());
}


void CQueryViewMembersResponse::getAttributes(IProperties &attributes)
{
}


void CQueryViewMembersResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
		m_viewname.toStr(ctx, buffer, "viewname", "", true, "", "");
		m_viewmembers.toStr(ctx, buffer, "viewmembers", "ViewMember");
	}
}


void CQueryViewMembersResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CQueryViewMembersResponse::serializer(IEspContext* ctx, IConstQueryViewMembersResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<QueryViewMembersResponse>");
	// field viewname
	{
		const char* s = src.getViewname();
		if (s && *s)
		{
			buffer.append("<viewname>");
			encodeUtf8XML(s,buffer);
			buffer.append("</viewname>");
		}
	}
	// field viewmembers
	{
		IArrayOf<IConstViewMember>& v = src.getViewmembers();
		int size = v.length();
		if (size>0)
			buffer.append("<viewmembers>");
		for (int i=0;i<size;i++)
		{
			buffer.append("<Item>");
			CViewMember::serializer(ctx,v.item(i),buffer,false);
			buffer.append("</Item>");
		}
		if (size>0)
			buffer.append("</viewmembers>");
	}
	if (keepRootTag)
		buffer.append("</QueryViewMembersResponse>");
}

bool CQueryViewMembersResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
		hasValue |= m_viewname.unmarshall(rpc_request, "viewname", basepath);
		hasValue |= m_viewmembers.unmarshall(rpc_request, "viewmembers", basepath);
	}
	return hasValue;
}

bool CQueryViewMembersResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_viewname.unmarshall(ctx, soapval, "viewname");
	hasValue |= m_viewmembers.unmarshall(ctx, soapval, "viewmembers");
	return hasValue;
}

bool CQueryViewMembersResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_viewname.unmarshall(ctx, params, attachments, "viewname", basepath);
	hasValue |= m_viewmembers.unmarshall(ctx, params, attachments, "viewmembers", basepath);
	return hasValue;
}

const char * CQueryViewMembersResponse::getViewname() { return m_viewname.query();}
IArrayOf<IConstViewMember> & CQueryViewMembersResponse::getViewmembers() { return (IArrayOf<IConstViewMember> &) m_viewmembers; }
void CQueryViewMembersResponse::setViewname(const char * val){ m_viewname.set(val); }
void CQueryViewMembersResponse::setViewmembers(IArrayOf<IEspViewMember> &val)
{
	m_viewmembers->kill();
	IArrayOf<IConstViewMember> &target = m_viewmembers.getValue();
	ForEachItemIn(idx, val)
	{
		IEspViewMember &item = (val).item(idx);
		item.Link();
		target.append(item);
	}
}
void CQueryViewMembersResponse::setViewmembers(IArrayOf<IConstViewMember> &val)
{
	m_viewmembers->kill();
	IArrayOf<IConstViewMember> &target = m_viewmembers.getValue();
	ForEachItemIn(idx, val)
	{
		IConstViewMember &item = val.item(idx);
		item.Link();
		target.append(item);
	}
}
extern "C"  IEspQueryViewMembersResponse *createQueryViewMembersResponse(const char *serv){return ((IEspQueryViewMembersResponse *)new CQueryViewMembersResponse(serv));}
extern "C"  IClientQueryViewMembersResponse *createClientQueryViewMembersResponse(const char *serv){return ((IClientQueryViewMembersResponse *)new CQueryViewMembersResponse(serv));}

//=======================================================
// class CAddViewMemberRequest Implementation
//=======================================================

CAddViewMemberRequest::CAddViewMemberRequest(const char *serviceName, IRpcMessageBinding *init)
	: m_viewname(nilIgnore),m_membername(nilIgnore),m_membertype(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("AddViewMemberRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CAddViewMemberRequest::CAddViewMemberRequest(const char *serviceName, const char *bc)
	: m_viewname(nilIgnore),m_membername(nilIgnore),m_membertype(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("AddViewMemberRequest");
}

CAddViewMemberRequest::CAddViewMemberRequest(const char *serviceName, IRpcMessage* rpcmsg)
	: m_viewname(nilIgnore),m_membername(nilIgnore),m_membertype(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("AddViewMemberRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CAddViewMemberRequest::CAddViewMemberRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_viewname(nilIgnore),m_membername(nilIgnore),m_membertype(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("AddViewMemberRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CAddViewMemberRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"viewname\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"membername\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"membertype\" type=\"tns:ViewMemberType\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	if (!(flags & 0x10)  || (flags & 0x100))
	{
		CXViewMemberType::getXsdDefinition(context, request, schema, added);
	}
	return schema;
}

void CAddViewMemberRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CAddViewMemberRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
	if (!added.getValue("ViewMemberType"))
	{
		added.setValue("ViewMemberType",1);
		CXViewMemberType::getMapInfo(info,added);
	}
}

StringBuffer &CAddViewMemberRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("viewname");
	form.appendf("  <tr><td><b>viewname: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("membername");
	form.appendf("  <tr><td><b>membername: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("membertype");
	form.appendf("  <tr><td><b>membertype: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CAddViewMemberRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CAddViewMemberRequest::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_viewname.marshall(rpc_resp, "viewname", "", "", "");
	m_membername.marshall(rpc_resp, "membername", "", "", "");
	m_membertype.marshall(rpc_resp, "membertype", "", "", "");
}


void CAddViewMemberRequest::copy(CAddViewMemberRequest &from)
{
	m_viewname.copy(from.m_viewname);
	m_membername.copy(from.m_membername);
	m_membertype.copy(from.m_membertype);
}


void CAddViewMemberRequest::copy(IConstAddViewMemberRequest &ifrom)
{
	setViewname(ifrom.getViewname());
	setMembername(ifrom.getMembername());
	setMembertype(ifrom.getMembertype());
}


void CAddViewMemberRequest::getAttributes(IProperties &attributes)
{
}


void CAddViewMemberRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_viewname.toStr(ctx, buffer, "viewname", "", true, "", "");
	m_membername.toStr(ctx, buffer, "membername", "", true, "", "");
	m_membertype.toStr(ctx, buffer, "membertype", "", true, "", "");
}


void CAddViewMemberRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CAddViewMemberRequest::serializer(IEspContext* ctx, IConstAddViewMemberRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<AddViewMemberRequest>");
	// field viewname
	{
		const char* s = src.getViewname();
		if (s && *s)
		{
			buffer.append("<viewname>");
			encodeUtf8XML(s,buffer);
			buffer.append("</viewname>");
		}
	}
	// field membername
	{
		const char* s = src.getMembername();
		if (s && *s)
		{
			buffer.append("<membername>");
			encodeUtf8XML(s,buffer);
			buffer.append("</membername>");
		}
	}
	// field membertype
	{
		const char* s = src.getMembertypeAsString();
		buffer.append("<membertype>");
		encodeUtf8XML(s,buffer);
		buffer.append("</membertype>");
	}
	if (keepRootTag)
		buffer.append("</AddViewMemberRequest>");
}

bool CAddViewMemberRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_viewname.unmarshall(rpc_request, "viewname", basepath);
	hasValue |= m_membername.unmarshall(rpc_request, "membername", basepath);
	hasValue |= m_membertype.unmarshall(rpc_request, "membertype", basepath);
	return hasValue;
}

bool CAddViewMemberRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_viewname.unmarshall(ctx, soapval, "viewname");
	hasValue |= m_membername.unmarshall(ctx, soapval, "membername");
	hasValue |= m_membertype.unmarshall(ctx, soapval, "membertype");
	return hasValue;
}

bool CAddViewMemberRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_viewname.unmarshall(ctx, params, attachments, "viewname", basepath);
	hasValue |= m_membername.unmarshall(ctx, params, attachments, "membername", basepath);
	hasValue |= m_membertype.unmarshall(ctx, params, attachments, "membertype", basepath);
	return hasValue;
}

const char * CAddViewMemberRequest::getViewname() { return m_viewname.query();}
const char * CAddViewMemberRequest::getMembername() { return m_membername.query();}
CViewMemberType CAddViewMemberRequest::getMembertype() { return m_membertype.getValue(); }
const char* CAddViewMemberRequest::getMembertypeAsString() {  return (const char*)m_membertype; }
void CAddViewMemberRequest::setViewname(const char * val){ m_viewname.set(val); }
void CAddViewMemberRequest::setMembername(const char * val){ m_membername.set(val); }
void CAddViewMemberRequest::setMembertype(CViewMemberType val) { m_membertype.setValue(val); }
void CAddViewMemberRequest::setMembertype(const char* val) { m_membertype.setValue(val); }
extern "C"  IEspAddViewMemberRequest *createAddViewMemberRequest(const char *serv){return ((IEspAddViewMemberRequest *)new CAddViewMemberRequest(serv));}
extern "C"  IClientAddViewMemberRequest *createClientAddViewMemberRequest(const char *serv){return ((IClientAddViewMemberRequest *)new CAddViewMemberRequest(serv));}

//=======================================================
// class CAddViewMemberResponse Implementation
//=======================================================

CAddViewMemberResponse::CAddViewMemberResponse(const char *serviceName, IRpcMessageBinding *init)
	: m_viewname(nilIgnore),m_membername(nilIgnore),m_membertype(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("AddViewMemberResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CAddViewMemberResponse::CAddViewMemberResponse(const char *serviceName, const char *bc)
	: m_viewname(nilIgnore),m_membername(nilIgnore),m_membertype(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("AddViewMemberResponse");
}

CAddViewMemberResponse::CAddViewMemberResponse(const char *serviceName, IRpcMessage* rpcmsg)
	: m_viewname(nilIgnore),m_membername(nilIgnore),m_membertype(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("AddViewMemberResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CAddViewMemberResponse::CAddViewMemberResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_viewname(nilIgnore),m_membername(nilIgnore),m_membertype(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("AddViewMemberResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CAddViewMemberResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"viewname\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"membername\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"membertype\" type=\"tns:ViewMemberType\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	if (!(flags & 0x10)  || (flags & 0x100))
	{
		CXViewMemberType::getXsdDefinition(context, request, schema, added);
	}
	return schema;
}

void CAddViewMemberResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CAddViewMemberResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
	if (!added.getValue("ViewMemberType"))
	{
		added.setValue("ViewMemberType",1);
		CXViewMemberType::getMapInfo(info,added);
	}
}

StringBuffer &CAddViewMemberResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("viewname");
	form.appendf("  <tr><td><b>viewname: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("membername");
	form.appendf("  <tr><td><b>membername: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("membertype");
	form.appendf("  <tr><td><b>membertype: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CAddViewMemberResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CAddViewMemberResponse::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
		m_viewname.marshall(rpc_resp, "viewname", "", "", "");
		m_membername.marshall(rpc_resp, "membername", "", "", "");
		m_membertype.marshall(rpc_resp, "membertype", "", "", "");
	}
}


void CAddViewMemberResponse::copy(CAddViewMemberResponse &from)
{
	m_viewname.copy(from.m_viewname);
	m_membername.copy(from.m_membername);
	m_membertype.copy(from.m_membertype);
}


void CAddViewMemberResponse::copy(IConstAddViewMemberResponse &ifrom)
{
	setViewname(ifrom.getViewname());
	setMembername(ifrom.getMembername());
	setMembertype(ifrom.getMembertype());
}


void CAddViewMemberResponse::getAttributes(IProperties &attributes)
{
}


void CAddViewMemberResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
		m_viewname.toStr(ctx, buffer, "viewname", "", true, "", "");
		m_membername.toStr(ctx, buffer, "membername", "", true, "", "");
		m_membertype.toStr(ctx, buffer, "membertype", "", true, "", "");
	}
}


void CAddViewMemberResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CAddViewMemberResponse::serializer(IEspContext* ctx, IConstAddViewMemberResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<AddViewMemberResponse>");
	// field viewname
	{
		const char* s = src.getViewname();
		if (s && *s)
		{
			buffer.append("<viewname>");
			encodeUtf8XML(s,buffer);
			buffer.append("</viewname>");
		}
	}
	// field membername
	{
		const char* s = src.getMembername();
		if (s && *s)
		{
			buffer.append("<membername>");
			encodeUtf8XML(s,buffer);
			buffer.append("</membername>");
		}
	}
	// field membertype
	{
		const char* s = src.getMembertypeAsString();
		buffer.append("<membertype>");
		encodeUtf8XML(s,buffer);
		buffer.append("</membertype>");
	}
	if (keepRootTag)
		buffer.append("</AddViewMemberResponse>");
}

bool CAddViewMemberResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
		hasValue |= m_viewname.unmarshall(rpc_request, "viewname", basepath);
		hasValue |= m_membername.unmarshall(rpc_request, "membername", basepath);
		hasValue |= m_membertype.unmarshall(rpc_request, "membertype", basepath);
	}
	return hasValue;
}

bool CAddViewMemberResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_viewname.unmarshall(ctx, soapval, "viewname");
	hasValue |= m_membername.unmarshall(ctx, soapval, "membername");
	hasValue |= m_membertype.unmarshall(ctx, soapval, "membertype");
	return hasValue;
}

bool CAddViewMemberResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_viewname.unmarshall(ctx, params, attachments, "viewname", basepath);
	hasValue |= m_membername.unmarshall(ctx, params, attachments, "membername", basepath);
	hasValue |= m_membertype.unmarshall(ctx, params, attachments, "membertype", basepath);
	return hasValue;
}

const char * CAddViewMemberResponse::getViewname() { return m_viewname.query();}
const char * CAddViewMemberResponse::getMembername() { return m_membername.query();}
CViewMemberType CAddViewMemberResponse::getMembertype() { return m_membertype.getValue(); }
const char* CAddViewMemberResponse::getMembertypeAsString() {  return (const char*)m_membertype; }
void CAddViewMemberResponse::setViewname(const char * val){ m_viewname.set(val); }
void CAddViewMemberResponse::setMembername(const char * val){ m_membername.set(val); }
void CAddViewMemberResponse::setMembertype(CViewMemberType val) { m_membertype.setValue(val); }
void CAddViewMemberResponse::setMembertype(const char* val) { m_membertype.setValue(val); }
extern "C"  IEspAddViewMemberResponse *createAddViewMemberResponse(const char *serv){return ((IEspAddViewMemberResponse *)new CAddViewMemberResponse(serv));}
extern "C"  IClientAddViewMemberResponse *createClientAddViewMemberResponse(const char *serv){return ((IClientAddViewMemberResponse *)new CAddViewMemberResponse(serv));}

//=======================================================
// class CDeleteViewMemberRequest Implementation
//=======================================================

CDeleteViewMemberRequest::CDeleteViewMemberRequest(const char *serviceName, IRpcMessageBinding *init)
	: m_viewname(nilIgnore),m_membername(nilIgnore),m_membertype(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("DeleteViewMemberRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CDeleteViewMemberRequest::CDeleteViewMemberRequest(const char *serviceName, const char *bc)
	: m_viewname(nilIgnore),m_membername(nilIgnore),m_membertype(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("DeleteViewMemberRequest");
}

CDeleteViewMemberRequest::CDeleteViewMemberRequest(const char *serviceName, IRpcMessage* rpcmsg)
	: m_viewname(nilIgnore),m_membername(nilIgnore),m_membertype(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("DeleteViewMemberRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CDeleteViewMemberRequest::CDeleteViewMemberRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_viewname(nilIgnore),m_membername(nilIgnore),m_membertype(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("DeleteViewMemberRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CDeleteViewMemberRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"viewname\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"membername\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"membertype\" type=\"tns:ViewMemberType\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	if (!(flags & 0x10)  || (flags & 0x100))
	{
		CXViewMemberType::getXsdDefinition(context, request, schema, added);
	}
	return schema;
}

void CDeleteViewMemberRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CDeleteViewMemberRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
	if (!added.getValue("ViewMemberType"))
	{
		added.setValue("ViewMemberType",1);
		CXViewMemberType::getMapInfo(info,added);
	}
}

StringBuffer &CDeleteViewMemberRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("viewname");
	form.appendf("  <tr><td><b>viewname: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("membername");
	form.appendf("  <tr><td><b>membername: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("membertype");
	form.appendf("  <tr><td><b>membertype: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CDeleteViewMemberRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CDeleteViewMemberRequest::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_viewname.marshall(rpc_resp, "viewname", "", "", "");
	m_membername.marshall(rpc_resp, "membername", "", "", "");
	m_membertype.marshall(rpc_resp, "membertype", "", "", "");
}


void CDeleteViewMemberRequest::copy(CDeleteViewMemberRequest &from)
{
	m_viewname.copy(from.m_viewname);
	m_membername.copy(from.m_membername);
	m_membertype.copy(from.m_membertype);
}


void CDeleteViewMemberRequest::copy(IConstDeleteViewMemberRequest &ifrom)
{
	setViewname(ifrom.getViewname());
	setMembername(ifrom.getMembername());
	setMembertype(ifrom.getMembertype());
}


void CDeleteViewMemberRequest::getAttributes(IProperties &attributes)
{
}


void CDeleteViewMemberRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_viewname.toStr(ctx, buffer, "viewname", "", true, "", "");
	m_membername.toStr(ctx, buffer, "membername", "", true, "", "");
	m_membertype.toStr(ctx, buffer, "membertype", "", true, "", "");
}


void CDeleteViewMemberRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CDeleteViewMemberRequest::serializer(IEspContext* ctx, IConstDeleteViewMemberRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<DeleteViewMemberRequest>");
	// field viewname
	{
		const char* s = src.getViewname();
		if (s && *s)
		{
			buffer.append("<viewname>");
			encodeUtf8XML(s,buffer);
			buffer.append("</viewname>");
		}
	}
	// field membername
	{
		const char* s = src.getMembername();
		if (s && *s)
		{
			buffer.append("<membername>");
			encodeUtf8XML(s,buffer);
			buffer.append("</membername>");
		}
	}
	// field membertype
	{
		const char* s = src.getMembertypeAsString();
		buffer.append("<membertype>");
		encodeUtf8XML(s,buffer);
		buffer.append("</membertype>");
	}
	if (keepRootTag)
		buffer.append("</DeleteViewMemberRequest>");
}

bool CDeleteViewMemberRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_viewname.unmarshall(rpc_request, "viewname", basepath);
	hasValue |= m_membername.unmarshall(rpc_request, "membername", basepath);
	hasValue |= m_membertype.unmarshall(rpc_request, "membertype", basepath);
	return hasValue;
}

bool CDeleteViewMemberRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_viewname.unmarshall(ctx, soapval, "viewname");
	hasValue |= m_membername.unmarshall(ctx, soapval, "membername");
	hasValue |= m_membertype.unmarshall(ctx, soapval, "membertype");
	return hasValue;
}

bool CDeleteViewMemberRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_viewname.unmarshall(ctx, params, attachments, "viewname", basepath);
	hasValue |= m_membername.unmarshall(ctx, params, attachments, "membername", basepath);
	hasValue |= m_membertype.unmarshall(ctx, params, attachments, "membertype", basepath);
	return hasValue;
}

const char * CDeleteViewMemberRequest::getViewname() { return m_viewname.query();}
const char * CDeleteViewMemberRequest::getMembername() { return m_membername.query();}
CViewMemberType CDeleteViewMemberRequest::getMembertype() { return m_membertype.getValue(); }
const char* CDeleteViewMemberRequest::getMembertypeAsString() {  return (const char*)m_membertype; }
void CDeleteViewMemberRequest::setViewname(const char * val){ m_viewname.set(val); }
void CDeleteViewMemberRequest::setMembername(const char * val){ m_membername.set(val); }
void CDeleteViewMemberRequest::setMembertype(CViewMemberType val) { m_membertype.setValue(val); }
void CDeleteViewMemberRequest::setMembertype(const char* val) { m_membertype.setValue(val); }
extern "C"  IEspDeleteViewMemberRequest *createDeleteViewMemberRequest(const char *serv){return ((IEspDeleteViewMemberRequest *)new CDeleteViewMemberRequest(serv));}
extern "C"  IClientDeleteViewMemberRequest *createClientDeleteViewMemberRequest(const char *serv){return ((IClientDeleteViewMemberRequest *)new CDeleteViewMemberRequest(serv));}

//=======================================================
// class CDeleteViewMemberResponse Implementation
//=======================================================

CDeleteViewMemberResponse::CDeleteViewMemberResponse(const char *serviceName, IRpcMessageBinding *init)
	: m_viewname(nilIgnore),m_membername(nilIgnore),m_membertype(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("DeleteViewMemberResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CDeleteViewMemberResponse::CDeleteViewMemberResponse(const char *serviceName, const char *bc)
	: m_viewname(nilIgnore),m_membername(nilIgnore),m_membertype(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("DeleteViewMemberResponse");
}

CDeleteViewMemberResponse::CDeleteViewMemberResponse(const char *serviceName, IRpcMessage* rpcmsg)
	: m_viewname(nilIgnore),m_membername(nilIgnore),m_membertype(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("DeleteViewMemberResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CDeleteViewMemberResponse::CDeleteViewMemberResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_viewname(nilIgnore),m_membername(nilIgnore),m_membertype(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("DeleteViewMemberResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CDeleteViewMemberResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"viewname\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"membername\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"membertype\" type=\"tns:ViewMemberType\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	if (!(flags & 0x10)  || (flags & 0x100))
	{
		CXViewMemberType::getXsdDefinition(context, request, schema, added);
	}
	return schema;
}

void CDeleteViewMemberResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CDeleteViewMemberResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
	if (!added.getValue("ViewMemberType"))
	{
		added.setValue("ViewMemberType",1);
		CXViewMemberType::getMapInfo(info,added);
	}
}

StringBuffer &CDeleteViewMemberResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("viewname");
	form.appendf("  <tr><td><b>viewname: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("membername");
	form.appendf("  <tr><td><b>membername: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("membertype");
	form.appendf("  <tr><td><b>membertype: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CDeleteViewMemberResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CDeleteViewMemberResponse::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
		m_viewname.marshall(rpc_resp, "viewname", "", "", "");
		m_membername.marshall(rpc_resp, "membername", "", "", "");
		m_membertype.marshall(rpc_resp, "membertype", "", "", "");
	}
}


void CDeleteViewMemberResponse::copy(CDeleteViewMemberResponse &from)
{
	m_viewname.copy(from.m_viewname);
	m_membername.copy(from.m_membername);
	m_membertype.copy(from.m_membertype);
}


void CDeleteViewMemberResponse::copy(IConstDeleteViewMemberResponse &ifrom)
{
	setViewname(ifrom.getViewname());
	setMembername(ifrom.getMembername());
	setMembertype(ifrom.getMembertype());
}


void CDeleteViewMemberResponse::getAttributes(IProperties &attributes)
{
}


void CDeleteViewMemberResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
		m_viewname.toStr(ctx, buffer, "viewname", "", true, "", "");
		m_membername.toStr(ctx, buffer, "membername", "", true, "", "");
		m_membertype.toStr(ctx, buffer, "membertype", "", true, "", "");
	}
}


void CDeleteViewMemberResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CDeleteViewMemberResponse::serializer(IEspContext* ctx, IConstDeleteViewMemberResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<DeleteViewMemberResponse>");
	// field viewname
	{
		const char* s = src.getViewname();
		if (s && *s)
		{
			buffer.append("<viewname>");
			encodeUtf8XML(s,buffer);
			buffer.append("</viewname>");
		}
	}
	// field membername
	{
		const char* s = src.getMembername();
		if (s && *s)
		{
			buffer.append("<membername>");
			encodeUtf8XML(s,buffer);
			buffer.append("</membername>");
		}
	}
	// field membertype
	{
		const char* s = src.getMembertypeAsString();
		buffer.append("<membertype>");
		encodeUtf8XML(s,buffer);
		buffer.append("</membertype>");
	}
	if (keepRootTag)
		buffer.append("</DeleteViewMemberResponse>");
}

bool CDeleteViewMemberResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
		hasValue |= m_viewname.unmarshall(rpc_request, "viewname", basepath);
		hasValue |= m_membername.unmarshall(rpc_request, "membername", basepath);
		hasValue |= m_membertype.unmarshall(rpc_request, "membertype", basepath);
	}
	return hasValue;
}

bool CDeleteViewMemberResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_viewname.unmarshall(ctx, soapval, "viewname");
	hasValue |= m_membername.unmarshall(ctx, soapval, "membername");
	hasValue |= m_membertype.unmarshall(ctx, soapval, "membertype");
	return hasValue;
}

bool CDeleteViewMemberResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_viewname.unmarshall(ctx, params, attachments, "viewname", basepath);
	hasValue |= m_membername.unmarshall(ctx, params, attachments, "membername", basepath);
	hasValue |= m_membertype.unmarshall(ctx, params, attachments, "membertype", basepath);
	return hasValue;
}

const char * CDeleteViewMemberResponse::getViewname() { return m_viewname.query();}
const char * CDeleteViewMemberResponse::getMembername() { return m_membername.query();}
CViewMemberType CDeleteViewMemberResponse::getMembertype() { return m_membertype.getValue(); }
const char* CDeleteViewMemberResponse::getMembertypeAsString() {  return (const char*)m_membertype; }
void CDeleteViewMemberResponse::setViewname(const char * val){ m_viewname.set(val); }
void CDeleteViewMemberResponse::setMembername(const char * val){ m_membername.set(val); }
void CDeleteViewMemberResponse::setMembertype(CViewMemberType val) { m_membertype.setValue(val); }
void CDeleteViewMemberResponse::setMembertype(const char* val) { m_membertype.setValue(val); }
extern "C"  IEspDeleteViewMemberResponse *createDeleteViewMemberResponse(const char *serv){return ((IEspDeleteViewMemberResponse *)new CDeleteViewMemberResponse(serv));}
extern "C"  IClientDeleteViewMemberResponse *createClientDeleteViewMemberResponse(const char *serv){return ((IClientDeleteViewMemberResponse *)new CDeleteViewMemberResponse(serv));}

//=======================================================
// class CQueryUserViewColumnsRequest Implementation
//=======================================================

CQueryUserViewColumnsRequest::CQueryUserViewColumnsRequest(const char *serviceName, IRpcMessageBinding *init)
	: m_username(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("QueryUserViewColumnsRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CQueryUserViewColumnsRequest::CQueryUserViewColumnsRequest(const char *serviceName, const char *bc)
	: m_username(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("QueryUserViewColumnsRequest");
}

CQueryUserViewColumnsRequest::CQueryUserViewColumnsRequest(const char *serviceName, IRpcMessage* rpcmsg)
	: m_username(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("QueryUserViewColumnsRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CQueryUserViewColumnsRequest::CQueryUserViewColumnsRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_username(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("QueryUserViewColumnsRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CQueryUserViewColumnsRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"username\" type=\"xsd:string\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CQueryUserViewColumnsRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CQueryUserViewColumnsRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CQueryUserViewColumnsRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("username");
	form.appendf("  <tr><td><b>username: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CQueryUserViewColumnsRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CQueryUserViewColumnsRequest::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_username.marshall(rpc_resp, "username", "", "", "");
}


void CQueryUserViewColumnsRequest::copy(CQueryUserViewColumnsRequest &from)
{
	m_username.copy(from.m_username);
}


void CQueryUserViewColumnsRequest::copy(IConstQueryUserViewColumnsRequest &ifrom)
{
	setUsername(ifrom.getUsername());
}


void CQueryUserViewColumnsRequest::getAttributes(IProperties &attributes)
{
}


void CQueryUserViewColumnsRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_username.toStr(ctx, buffer, "username", "", true, "", "");
}


void CQueryUserViewColumnsRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CQueryUserViewColumnsRequest::serializer(IEspContext* ctx, IConstQueryUserViewColumnsRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<QueryUserViewColumnsRequest>");
	// field username
	{
		const char* s = src.getUsername();
		if (s && *s)
		{
			buffer.append("<username>");
			encodeUtf8XML(s,buffer);
			buffer.append("</username>");
		}
	}
	if (keepRootTag)
		buffer.append("</QueryUserViewColumnsRequest>");
}

bool CQueryUserViewColumnsRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_username.unmarshall(rpc_request, "username", basepath);
	return hasValue;
}

bool CQueryUserViewColumnsRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_username.unmarshall(ctx, soapval, "username");
	return hasValue;
}

bool CQueryUserViewColumnsRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_username.unmarshall(ctx, params, attachments, "username", basepath);
	return hasValue;
}

const char * CQueryUserViewColumnsRequest::getUsername() { return m_username.query();}
void CQueryUserViewColumnsRequest::setUsername(const char * val){ m_username.set(val); }
extern "C"  IEspQueryUserViewColumnsRequest *createQueryUserViewColumnsRequest(const char *serv){return ((IEspQueryUserViewColumnsRequest *)new CQueryUserViewColumnsRequest(serv));}
extern "C"  IClientQueryUserViewColumnsRequest *createClientQueryUserViewColumnsRequest(const char *serv){return ((IClientQueryUserViewColumnsRequest *)new CQueryUserViewColumnsRequest(serv));}

//=======================================================
// class CQueryUserViewColumnsResponse Implementation
//=======================================================

CQueryUserViewColumnsResponse::CQueryUserViewColumnsResponse(const char *serviceName, IRpcMessageBinding *init)
	: m_username(nilIgnore),m_viewcolumns(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("QueryUserViewColumnsResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CQueryUserViewColumnsResponse::CQueryUserViewColumnsResponse(const char *serviceName, const char *bc)
	: m_username(nilIgnore),m_viewcolumns(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("QueryUserViewColumnsResponse");
}

CQueryUserViewColumnsResponse::CQueryUserViewColumnsResponse(const char *serviceName, IRpcMessage* rpcmsg)
	: m_username(nilIgnore),m_viewcolumns(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("QueryUserViewColumnsResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CQueryUserViewColumnsResponse::CQueryUserViewColumnsResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_username(nilIgnore),m_viewcolumns(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("QueryUserViewColumnsResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CQueryUserViewColumnsResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"username\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"viewcolumns\" type=\"tns:ArrayOfViewColumn\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	if (!(flags & 0x10)  || (flags & 0x100))
	{
		CViewColumn::getXsdDefinition(context, request, schema, added);
	}
	if (added.getValue("ViewColumn") && added.getValue("ArrayOfViewColumn")==NULL) {
		schema.append("<xsd:complexType name=\"ArrayOfViewColumn\">\n");
		schema.append("<xsd:sequence>\n");
		schema.append("<xsd:element minOccurs=\"0\" maxOccurs=\"unbounded\" name=\"ViewColumn\" type=\"tns:ViewColumn\"/>\n");
		schema.append("</xsd:sequence>\n");
		schema.append("</xsd:complexType>\n");
		added.setValue("ArrayOfViewColumn",1);
	}
	return schema;
}

void CQueryUserViewColumnsResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CQueryUserViewColumnsResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
	if (!added.getValue("ViewColumn"))
	{
		added.setValue("ViewColumn",1);
		CViewColumn::getMapInfo(info,added);
	}
}

StringBuffer &CQueryUserViewColumnsResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("username");
	form.appendf("  <tr><td><b>username: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("viewcolumns");
	form.appendf("<tr><td><b>viewcolumns: </b></td><td>");
	form.appendf("<table><tr><td><textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea></td>", extfix.str());
	form.append("</tr></table>");
	form.append("</td></tr>");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CQueryUserViewColumnsResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CQueryUserViewColumnsResponse::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
		m_username.marshall(rpc_resp, "username", "", "", "");
		m_viewcolumns.marshall(rpc_resp, "viewcolumns", "ViewColumn");
	}
}


void CQueryUserViewColumnsResponse::copy(CQueryUserViewColumnsResponse &from)
{
	m_username.copy(from.m_username);
	m_viewcolumns.copy(from.m_viewcolumns);
}


void CQueryUserViewColumnsResponse::copy(IConstQueryUserViewColumnsResponse &ifrom)
{
	setUsername(ifrom.getUsername());
	setViewcolumns(ifrom.getViewcolumns());
}


void CQueryUserViewColumnsResponse::getAttributes(IProperties &attributes)
{
}


void CQueryUserViewColumnsResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
		m_username.toStr(ctx, buffer, "username", "", true, "", "");
		m_viewcolumns.toStr(ctx, buffer, "viewcolumns", "ViewColumn");
	}
}


void CQueryUserViewColumnsResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CQueryUserViewColumnsResponse::serializer(IEspContext* ctx, IConstQueryUserViewColumnsResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<QueryUserViewColumnsResponse>");
	// field username
	{
		const char* s = src.getUsername();
		if (s && *s)
		{
			buffer.append("<username>");
			encodeUtf8XML(s,buffer);
			buffer.append("</username>");
		}
	}
	// field viewcolumns
	{
		IArrayOf<IConstViewColumn>& v = src.getViewcolumns();
		int size = v.length();
		if (size>0)
			buffer.append("<viewcolumns>");
		for (int i=0;i<size;i++)
		{
			buffer.append("<Item>");
			CViewColumn::serializer(ctx,v.item(i),buffer,false);
			buffer.append("</Item>");
		}
		if (size>0)
			buffer.append("</viewcolumns>");
	}
	if (keepRootTag)
		buffer.append("</QueryUserViewColumnsResponse>");
}

bool CQueryUserViewColumnsResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
		hasValue |= m_username.unmarshall(rpc_request, "username", basepath);
		hasValue |= m_viewcolumns.unmarshall(rpc_request, "viewcolumns", basepath);
	}
	return hasValue;
}

bool CQueryUserViewColumnsResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_username.unmarshall(ctx, soapval, "username");
	hasValue |= m_viewcolumns.unmarshall(ctx, soapval, "viewcolumns");
	return hasValue;
}

bool CQueryUserViewColumnsResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_username.unmarshall(ctx, params, attachments, "username", basepath);
	hasValue |= m_viewcolumns.unmarshall(ctx, params, attachments, "viewcolumns", basepath);
	return hasValue;
}

const char * CQueryUserViewColumnsResponse::getUsername() { return m_username.query();}
IArrayOf<IConstViewColumn> & CQueryUserViewColumnsResponse::getViewcolumns() { return (IArrayOf<IConstViewColumn> &) m_viewcolumns; }
void CQueryUserViewColumnsResponse::setUsername(const char * val){ m_username.set(val); }
void CQueryUserViewColumnsResponse::setViewcolumns(IArrayOf<IEspViewColumn> &val)
{
	m_viewcolumns->kill();
	IArrayOf<IConstViewColumn> &target = m_viewcolumns.getValue();
	ForEachItemIn(idx, val)
	{
		IEspViewColumn &item = (val).item(idx);
		item.Link();
		target.append(item);
	}
}
void CQueryUserViewColumnsResponse::setViewcolumns(IArrayOf<IConstViewColumn> &val)
{
	m_viewcolumns->kill();
	IArrayOf<IConstViewColumn> &target = m_viewcolumns.getValue();
	ForEachItemIn(idx, val)
	{
		IConstViewColumn &item = val.item(idx);
		item.Link();
		target.append(item);
	}
}
extern "C"  IEspQueryUserViewColumnsResponse *createQueryUserViewColumnsResponse(const char *serv){return ((IEspQueryUserViewColumnsResponse *)new CQueryUserViewColumnsResponse(serv));}
extern "C"  IClientQueryUserViewColumnsResponse *createClientQueryUserViewColumnsResponse(const char *serv){return ((IClientQueryUserViewColumnsResponse *)new CQueryUserViewColumnsResponse(serv));}

//=======================================================
// class CPermissionAddRequest Implementation
//=======================================================

CPermissionAddRequest::CPermissionAddRequest(const char *serviceName, IRpcMessageBinding *init)
	: m_basedn(nilIgnore),m_rtype(nilIgnore),m_rtitle(nilIgnore),m_rname(nilIgnore),m_prefix(nilIgnore),m_BasednName(nilIgnore),m_AccountName(nilIgnore),m_AccountType(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("PermissionAddRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CPermissionAddRequest::CPermissionAddRequest(const char *serviceName, const char *bc)
	: m_basedn(nilIgnore),m_rtype(nilIgnore),m_rtitle(nilIgnore),m_rname(nilIgnore),m_prefix(nilIgnore),m_BasednName(nilIgnore),m_AccountName(nilIgnore),m_AccountType(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("PermissionAddRequest");
}

CPermissionAddRequest::CPermissionAddRequest(const char *serviceName, IRpcMessage* rpcmsg)
	: m_basedn(nilIgnore),m_rtype(nilIgnore),m_rtitle(nilIgnore),m_rname(nilIgnore),m_prefix(nilIgnore),m_BasednName(nilIgnore),m_AccountName(nilIgnore),m_AccountType(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("PermissionAddRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CPermissionAddRequest::CPermissionAddRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_basedn(nilIgnore),m_rtype(nilIgnore),m_rtitle(nilIgnore),m_rname(nilIgnore),m_prefix(nilIgnore),m_BasednName(nilIgnore),m_AccountName(nilIgnore),m_AccountType(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("PermissionAddRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CPermissionAddRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"basedn\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"rtype\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"rtitle\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"rname\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"prefix\" type=\"xsd:string\"/>\n");
		if (!context.suppressed("PermissionAddRequest","BasednName")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"BasednName\" type=\"xsd:string\"/>\n");
		}
		if (!context.suppressed("PermissionAddRequest","AccountName")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"AccountName\" type=\"xsd:string\"/>\n");
		}
		if (!context.suppressed("PermissionAddRequest","AccountType")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"AccountType\" type=\"xsd:int\"/>\n");
		}
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CPermissionAddRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CPermissionAddRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
	info.addMinVersion("PermissionAddRequest","BasednName",1.01);
	info.addMinVersion("PermissionAddRequest","AccountName",1.01);
	info.addMinVersion("PermissionAddRequest","AccountType",1.01);
}

StringBuffer &CPermissionAddRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("basedn");
	form.appendf("  <tr><td><b>basedn: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("rtype");
	form.appendf("  <tr><td><b>rtype: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("rtitle");
	form.appendf("  <tr><td><b>rtitle: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("rname");
	form.appendf("  <tr><td><b>rname: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("prefix");
	form.appendf("  <tr><td><b>prefix: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (!context.suppressed("PermissionAddRequest","BasednName")) {
		extfix.clear();
		if (prefix && *prefix)
			extfix.append(prefix).append(".");
		extfix.append("BasednName");
		form.appendf("  <tr><td><b>BasednName: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
		form.append("</td></tr>\n");
	}
	if (!context.suppressed("PermissionAddRequest","AccountName")) {
		extfix.clear();
		if (prefix && *prefix)
			extfix.append(prefix).append(".");
		extfix.append("AccountName");
		form.appendf("  <tr><td><b>AccountName: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
		form.append("</td></tr>\n");
	}
	if (!context.suppressed("PermissionAddRequest","AccountType")) {
		extfix.clear();
		if (prefix && *prefix) extfix.append(prefix).append(".");
			extfix.append("AccountType");
		form.appendf("  <tr><td><b>AccountType: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
		form.append("</td></tr>\n");
	}
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CPermissionAddRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CPermissionAddRequest::serialize(IRpcMessage& rpc_resp)
{
	IEspContext* ctx = rpc_resp.queryContext();
	double clientVer= ctx ? ctx->getClientVersion() : -1; /* no context gets everything */
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_basedn.marshall(rpc_resp, "basedn", "", "", "");
	m_rtype.marshall(rpc_resp, "rtype", "", "", "");
	m_rtitle.marshall(rpc_resp, "rtitle", "", "", "");
	m_rname.marshall(rpc_resp, "rname", "", "", "");
	m_prefix.marshall(rpc_resp, "prefix", "", "", "");
	if ((clientVer==-1.0 || clientVer>=1.01))
		m_BasednName.marshall(rpc_resp, "BasednName", "", "", "");
	if ((clientVer==-1.0 || clientVer>=1.01))
		m_AccountName.marshall(rpc_resp, "AccountName", "", "", "");
	if ((clientVer==-1.0 || clientVer>=1.01))
		m_AccountType.marshall(rpc_resp, "AccountType", "", "", "");
}


void CPermissionAddRequest::copy(CPermissionAddRequest &from)
{
	m_basedn.copy(from.m_basedn);
	m_rtype.copy(from.m_rtype);
	m_rtitle.copy(from.m_rtitle);
	m_rname.copy(from.m_rname);
	m_prefix.copy(from.m_prefix);
	m_BasednName.copy(from.m_BasednName);
	m_AccountName.copy(from.m_AccountName);
	m_AccountType.copy(from.m_AccountType);
}


void CPermissionAddRequest::copy(IConstPermissionAddRequest &ifrom)
{
	setBasedn(ifrom.getBasedn());
	setRtype(ifrom.getRtype());
	setRtitle(ifrom.getRtitle());
	setRname(ifrom.getRname());
	setPrefix(ifrom.getPrefix());
	setBasednName(ifrom.getBasednName());
	setAccountName(ifrom.getAccountName());
	setAccountType(ifrom.getAccountType());
}


void CPermissionAddRequest::getAttributes(IProperties &attributes)
{
}


void CPermissionAddRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	double clientVer = ctx ? ctx->getClientVersion() : -1;
	m_basedn.toStr(ctx, buffer, "basedn", "", true, "", "");
	m_rtype.toStr(ctx, buffer, "rtype", "", true, "", "");
	m_rtitle.toStr(ctx, buffer, "rtitle", "", true, "", "");
	m_rname.toStr(ctx, buffer, "rname", "", true, "", "");
	m_prefix.toStr(ctx, buffer, "prefix", "", true, "", "");
	if ((clientVer==-1.0 || clientVer>=1.01))
		m_BasednName.toStr(ctx, buffer, "BasednName", "", true, "", "");
	if ((clientVer==-1.0 || clientVer>=1.01))
		m_AccountName.toStr(ctx, buffer, "AccountName", "", true, "", "");
	if ((clientVer==-1.0 || clientVer>=1.01))
		m_AccountType.toStr(ctx, buffer, "AccountType", "", true, "", "");
}


void CPermissionAddRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CPermissionAddRequest::serializer(IEspContext* ctx, IConstPermissionAddRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<PermissionAddRequest>");
	double clientVer = ctx ? ctx->getClientVersion() : -1;
	// field basedn
	{
		const char* s = src.getBasedn();
		if (s && *s)
		{
			buffer.append("<basedn>");
			encodeUtf8XML(s,buffer);
			buffer.append("</basedn>");
		}
	}
	// field rtype
	{
		const char* s = src.getRtype();
		if (s && *s)
		{
			buffer.append("<rtype>");
			encodeUtf8XML(s,buffer);
			buffer.append("</rtype>");
		}
	}
	// field rtitle
	{
		const char* s = src.getRtitle();
		if (s && *s)
		{
			buffer.append("<rtitle>");
			encodeUtf8XML(s,buffer);
			buffer.append("</rtitle>");
		}
	}
	// field rname
	{
		const char* s = src.getRname();
		if (s && *s)
		{
			buffer.append("<rname>");
			encodeUtf8XML(s,buffer);
			buffer.append("</rname>");
		}
	}
	// field prefix
	{
		const char* s = src.getPrefix();
		if (s && *s)
		{
			buffer.append("<prefix>");
			encodeUtf8XML(s,buffer);
			buffer.append("</prefix>");
		}
	}
	// field BasednName
	if ((clientVer==-1.0 || clientVer>=1.01))
	{
		const char* s = src.getBasednName();
		if (s && *s)
		{
			buffer.append("<BasednName>");
			encodeUtf8XML(s,buffer);
			buffer.append("</BasednName>");
		}
	}
	// field AccountName
	if ((clientVer==-1.0 || clientVer>=1.01))
	{
		const char* s = src.getAccountName();
		if (s && *s)
		{
			buffer.append("<AccountName>");
			encodeUtf8XML(s,buffer);
			buffer.append("</AccountName>");
		}
	}
	// field AccountType
	if ((clientVer==-1.0 || clientVer>=1.01))
	{
		int n = src.getAccountType();
		if (n)
			buffer.appendf("<AccountType>%d</AccountType>", n);
	}
	if (keepRootTag)
		buffer.append("</PermissionAddRequest>");
}

bool CPermissionAddRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_basedn.unmarshall(rpc_request, "basedn", basepath);
	hasValue |= m_rtype.unmarshall(rpc_request, "rtype", basepath);
	hasValue |= m_rtitle.unmarshall(rpc_request, "rtitle", basepath);
	hasValue |= m_rname.unmarshall(rpc_request, "rname", basepath);
	hasValue |= m_prefix.unmarshall(rpc_request, "prefix", basepath);
	hasValue |= m_BasednName.unmarshall(rpc_request, "BasednName", basepath);
	hasValue |= m_AccountName.unmarshall(rpc_request, "AccountName", basepath);
	hasValue |= m_AccountType.unmarshall(rpc_request, "AccountType", basepath);
	return hasValue;
}

bool CPermissionAddRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_basedn.unmarshall(ctx, soapval, "basedn");
	hasValue |= m_rtype.unmarshall(ctx, soapval, "rtype");
	hasValue |= m_rtitle.unmarshall(ctx, soapval, "rtitle");
	hasValue |= m_rname.unmarshall(ctx, soapval, "rname");
	hasValue |= m_prefix.unmarshall(ctx, soapval, "prefix");
	hasValue |= m_BasednName.unmarshall(ctx, soapval, "BasednName");
	hasValue |= m_AccountName.unmarshall(ctx, soapval, "AccountName");
	hasValue |= m_AccountType.unmarshall(ctx, soapval, "AccountType");
	return hasValue;
}

bool CPermissionAddRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_basedn.unmarshall(ctx, params, attachments, "basedn", basepath);
	hasValue |= m_rtype.unmarshall(ctx, params, attachments, "rtype", basepath);
	hasValue |= m_rtitle.unmarshall(ctx, params, attachments, "rtitle", basepath);
	hasValue |= m_rname.unmarshall(ctx, params, attachments, "rname", basepath);
	hasValue |= m_prefix.unmarshall(ctx, params, attachments, "prefix", basepath);
	hasValue |= m_BasednName.unmarshall(ctx, params, attachments, "BasednName", basepath);
	hasValue |= m_AccountName.unmarshall(ctx, params, attachments, "AccountName", basepath);
	hasValue |= m_AccountType.unmarshall(ctx, params, attachments, "AccountType", basepath);
	return hasValue;
}

const char * CPermissionAddRequest::getBasedn() { return m_basedn.query();}
const char * CPermissionAddRequest::getRtype() { return m_rtype.query();}
const char * CPermissionAddRequest::getRtitle() { return m_rtitle.query();}
const char * CPermissionAddRequest::getRname() { return m_rname.query();}
const char * CPermissionAddRequest::getPrefix() { return m_prefix.query();}
const char * CPermissionAddRequest::getBasednName() { return m_BasednName.query();}
const char * CPermissionAddRequest::getAccountName() { return m_AccountName.query();}
int CPermissionAddRequest::getAccountType() { return m_AccountType;}
void CPermissionAddRequest::setBasedn(const char * val){ m_basedn.set(val); }
void CPermissionAddRequest::setRtype(const char * val){ m_rtype.set(val); }
void CPermissionAddRequest::setRtitle(const char * val){ m_rtitle.set(val); }
void CPermissionAddRequest::setRname(const char * val){ m_rname.set(val); }
void CPermissionAddRequest::setPrefix(const char * val){ m_prefix.set(val); }
void CPermissionAddRequest::setBasednName(const char * val){ m_BasednName.set(val); }
void CPermissionAddRequest::setAccountName(const char * val){ m_AccountName.set(val); }
void CPermissionAddRequest::setAccountType(int val){ m_AccountType=val; }
extern "C"  IEspPermissionAddRequest *createPermissionAddRequest(const char *serv){return ((IEspPermissionAddRequest *)new CPermissionAddRequest(serv));}
extern "C"  IClientPermissionAddRequest *createClientPermissionAddRequest(const char *serv){return ((IClientPermissionAddRequest *)new CPermissionAddRequest(serv));}

//=======================================================
// class CPermissionAddResponse Implementation
//=======================================================

CPermissionAddResponse::CPermissionAddResponse(const char *serviceName, IRpcMessageBinding *init)
	: m_basedn(nilIgnore),m_rtype(nilIgnore),m_rtitle(nilIgnore),m_rname(nilIgnore),m_prefix(nilIgnore),m_BasednName(nilIgnore),m_AccountName(nilIgnore),m_AccountType(nilIgnore),m_toomany(nilIgnore),m_Users(nilIgnore),m_Groups(nilIgnore),m_Resources(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("PermissionAddResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CPermissionAddResponse::CPermissionAddResponse(const char *serviceName, const char *bc)
	: m_basedn(nilIgnore),m_rtype(nilIgnore),m_rtitle(nilIgnore),m_rname(nilIgnore),m_prefix(nilIgnore),m_BasednName(nilIgnore),m_AccountName(nilIgnore),m_AccountType(nilIgnore),m_toomany(nilIgnore),m_Users(nilIgnore),m_Groups(nilIgnore),m_Resources(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("PermissionAddResponse");
}

CPermissionAddResponse::CPermissionAddResponse(const char *serviceName, IRpcMessage* rpcmsg)
	: m_basedn(nilIgnore),m_rtype(nilIgnore),m_rtitle(nilIgnore),m_rname(nilIgnore),m_prefix(nilIgnore),m_BasednName(nilIgnore),m_AccountName(nilIgnore),m_AccountType(nilIgnore),m_toomany(nilIgnore),m_Users(nilIgnore),m_Groups(nilIgnore),m_Resources(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("PermissionAddResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CPermissionAddResponse::CPermissionAddResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_basedn(nilIgnore),m_rtype(nilIgnore),m_rtitle(nilIgnore),m_rname(nilIgnore),m_prefix(nilIgnore),m_BasednName(nilIgnore),m_AccountName(nilIgnore),m_AccountType(nilIgnore),m_toomany(nilIgnore),m_Users(nilIgnore),m_Groups(nilIgnore),m_Resources(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("PermissionAddResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CPermissionAddResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"basedn\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"rtype\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"rtitle\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"rname\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"prefix\" type=\"xsd:string\"/>\n");
		if (!context.suppressed("PermissionAddResponse","BasednName")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"BasednName\" type=\"xsd:string\"/>\n");
		}
		if (!context.suppressed("PermissionAddResponse","AccountName")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"AccountName\" type=\"xsd:string\"/>\n");
		}
		if (!context.suppressed("PermissionAddResponse","AccountType")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"AccountType\" type=\"xsd:int\"/>\n");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"toomany\" type=\"xsd:boolean\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Users\">\n");
		schema.append("<xsd:complexType><xsd:sequence>\n");
		schema.append("<xsd:element minOccurs=\"0\" maxOccurs=\"unbounded\" name=\"User\" type=\"tns:UserInfo\"/>");
		schema.append("</xsd:sequence></xsd:complexType>");
		schema.append("</xsd:element>");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Groups\">\n");
		schema.append("<xsd:complexType><xsd:sequence>\n");
		schema.append("<xsd:element minOccurs=\"0\" maxOccurs=\"unbounded\" name=\"Group\" type=\"tns:GroupInfo\"/>");
		schema.append("</xsd:sequence></xsd:complexType>");
		schema.append("</xsd:element>");
		if (!context.suppressed("PermissionAddResponse","Resources")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"Resources\" type=\"tns:EspStringArray\"/>\n");
		}
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	if (!(flags & 0x10)  || (flags & 0x100))
	{
		CUserInfo::getXsdDefinition(context, request, schema, added);
		CGroupInfo::getXsdDefinition(context, request, schema, added);
	}
	if (added.getValue("EspStringArray")==NULL) {
		addEspNativeArray(schema,"string","EspStringArray");
		added.setValue("EspStringArray",1);
	}
	return schema;
}

void CPermissionAddResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CPermissionAddResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
	info.addMinVersion("PermissionAddResponse","BasednName",1.01);
	info.addMinVersion("PermissionAddResponse","AccountName",1.01);
	info.addMinVersion("PermissionAddResponse","AccountType",1.01);
	info.addMinVersion("PermissionAddResponse","Resources",1.01);
	if (!added.getValue("GroupInfo"))
	{
		added.setValue("GroupInfo",1);
		CGroupInfo::getMapInfo(info,added);
	}
	if (!added.getValue("UserInfo"))
	{
		added.setValue("UserInfo",1);
		CUserInfo::getMapInfo(info,added);
	}
}

StringBuffer &CPermissionAddResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("basedn");
	form.appendf("  <tr><td><b>basedn: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("rtype");
	form.appendf("  <tr><td><b>rtype: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("rtitle");
	form.appendf("  <tr><td><b>rtitle: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("rname");
	form.appendf("  <tr><td><b>rname: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("prefix");
	form.appendf("  <tr><td><b>prefix: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (!context.suppressed("PermissionAddResponse","BasednName")) {
		extfix.clear();
		if (prefix && *prefix)
			extfix.append(prefix).append(".");
		extfix.append("BasednName");
		form.appendf("  <tr><td><b>BasednName: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
		form.append("</td></tr>\n");
	}
	if (!context.suppressed("PermissionAddResponse","AccountName")) {
		extfix.clear();
		if (prefix && *prefix)
			extfix.append(prefix).append(".");
		extfix.append("AccountName");
		form.appendf("  <tr><td><b>AccountName: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
		form.append("</td></tr>\n");
	}
	if (!context.suppressed("PermissionAddResponse","AccountType")) {
		extfix.clear();
		if (prefix && *prefix) extfix.append(prefix).append(".");
			extfix.append("AccountType");
		form.appendf("  <tr><td><b>AccountType: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
		form.append("</td></tr>\n");
	}
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("toomany");
	
	form.appendf("  <tr><td><b>toomany? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Users");
	form.appendf("<tr><td><b>Users: </b></td><td>");
	form.appendf("<table><tr><td><textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea></td>", extfix.str());
	form.append("</tr></table>");
	form.append("</td></tr>");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Groups");
	form.appendf("<tr><td><b>Groups: </b></td><td>");
	form.appendf("<table><tr><td><textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea></td>", extfix.str());
	form.append("</tr></table>");
	form.append("</td></tr>");
	if (!context.suppressed("PermissionAddResponse","Resources")) {
		extfix.clear();
		if (prefix && *prefix)
			extfix.append(prefix).append(".");
		extfix.append("Resources");
		form.appendf("<tr><td><b>Resources: </b></td><td>");
		form.appendf("<textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea>", extfix.str());
		form.append("</td></tr>");
	}
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CPermissionAddResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CPermissionAddResponse::serialize(IRpcMessage& rpc_resp)
{
	IEspContext* ctx = rpc_resp.queryContext();
	double clientVer= ctx ? ctx->getClientVersion() : -1; /* no context gets everything */
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
		m_basedn.marshall(rpc_resp, "basedn", "", "", "");
		m_rtype.marshall(rpc_resp, "rtype", "", "", "");
		m_rtitle.marshall(rpc_resp, "rtitle", "", "", "");
		m_rname.marshall(rpc_resp, "rname", "", "", "");
		m_prefix.marshall(rpc_resp, "prefix", "", "", "");
		if ((clientVer==-1.0 || clientVer>=1.01))
			m_BasednName.marshall(rpc_resp, "BasednName", "", "", "");
		if ((clientVer==-1.0 || clientVer>=1.01))
			m_AccountName.marshall(rpc_resp, "AccountName", "", "", "");
		if ((clientVer==-1.0 || clientVer>=1.01))
			m_AccountType.marshall(rpc_resp, "AccountType", "", "", "");
		m_toomany.marshall(rpc_resp, "toomany", "", "", "");
		m_Users.marshall(rpc_resp, "Users", "User");
		m_Groups.marshall(rpc_resp, "Groups", "Group");
		if ((clientVer==-1.0 || clientVer>=1.01))
			m_Resources.marshall(rpc_resp, "Resources", "Item");
	}
}


void CPermissionAddResponse::copy(CPermissionAddResponse &from)
{
	m_basedn.copy(from.m_basedn);
	m_rtype.copy(from.m_rtype);
	m_rtitle.copy(from.m_rtitle);
	m_rname.copy(from.m_rname);
	m_prefix.copy(from.m_prefix);
	m_BasednName.copy(from.m_BasednName);
	m_AccountName.copy(from.m_AccountName);
	m_AccountType.copy(from.m_AccountType);
	m_toomany.copy(from.m_toomany);
	m_Users.copy(from.m_Users);
	m_Groups.copy(from.m_Groups);
	m_Resources.copy(from.m_Resources);
}


void CPermissionAddResponse::copy(IConstPermissionAddResponse &ifrom)
{
	setBasedn(ifrom.getBasedn());
	setRtype(ifrom.getRtype());
	setRtitle(ifrom.getRtitle());
	setRname(ifrom.getRname());
	setPrefix(ifrom.getPrefix());
	setBasednName(ifrom.getBasednName());
	setAccountName(ifrom.getAccountName());
	setAccountType(ifrom.getAccountType());
	setToomany(ifrom.getToomany());
	setUsers(ifrom.getUsers());
	setGroups(ifrom.getGroups());
	setResources(ifrom.getResources());
}


void CPermissionAddResponse::getAttributes(IProperties &attributes)
{
}


void CPermissionAddResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
		double clientVer = ctx ? ctx->getClientVersion() : -1;
		m_basedn.toStr(ctx, buffer, "basedn", "", true, "", "");
		m_rtype.toStr(ctx, buffer, "rtype", "", true, "", "");
		m_rtitle.toStr(ctx, buffer, "rtitle", "", true, "", "");
		m_rname.toStr(ctx, buffer, "rname", "", true, "", "");
		m_prefix.toStr(ctx, buffer, "prefix", "", true, "", "");
		if ((clientVer==-1.0 || clientVer>=1.01))
			m_BasednName.toStr(ctx, buffer, "BasednName", "", true, "", "");
		if ((clientVer==-1.0 || clientVer>=1.01))
			m_AccountName.toStr(ctx, buffer, "AccountName", "", true, "", "");
		if ((clientVer==-1.0 || clientVer>=1.01))
			m_AccountType.toStr(ctx, buffer, "AccountType", "", true, "", "");
		m_toomany.toStr(ctx, buffer, "toomany", "", true, "", "");
		m_Users.toStr(ctx, buffer, "Users", "User");
		m_Groups.toStr(ctx, buffer, "Groups", "Group");
		if ((clientVer==-1.0 || clientVer>=1.01))
			m_Resources.toStr(ctx, buffer, "Resources", "Item");
	}
}


void CPermissionAddResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CPermissionAddResponse::serializer(IEspContext* ctx, IConstPermissionAddResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<PermissionAddResponse>");
	double clientVer = ctx ? ctx->getClientVersion() : -1;
	// field basedn
	{
		const char* s = src.getBasedn();
		if (s && *s)
		{
			buffer.append("<basedn>");
			encodeUtf8XML(s,buffer);
			buffer.append("</basedn>");
		}
	}
	// field rtype
	{
		const char* s = src.getRtype();
		if (s && *s)
		{
			buffer.append("<rtype>");
			encodeUtf8XML(s,buffer);
			buffer.append("</rtype>");
		}
	}
	// field rtitle
	{
		const char* s = src.getRtitle();
		if (s && *s)
		{
			buffer.append("<rtitle>");
			encodeUtf8XML(s,buffer);
			buffer.append("</rtitle>");
		}
	}
	// field rname
	{
		const char* s = src.getRname();
		if (s && *s)
		{
			buffer.append("<rname>");
			encodeUtf8XML(s,buffer);
			buffer.append("</rname>");
		}
	}
	// field prefix
	{
		const char* s = src.getPrefix();
		if (s && *s)
		{
			buffer.append("<prefix>");
			encodeUtf8XML(s,buffer);
			buffer.append("</prefix>");
		}
	}
	// field BasednName
	if ((clientVer==-1.0 || clientVer>=1.01))
	{
		const char* s = src.getBasednName();
		if (s && *s)
		{
			buffer.append("<BasednName>");
			encodeUtf8XML(s,buffer);
			buffer.append("</BasednName>");
		}
	}
	// field AccountName
	if ((clientVer==-1.0 || clientVer>=1.01))
	{
		const char* s = src.getAccountName();
		if (s && *s)
		{
			buffer.append("<AccountName>");
			encodeUtf8XML(s,buffer);
			buffer.append("</AccountName>");
		}
	}
	// field AccountType
	if ((clientVer==-1.0 || clientVer>=1.01))
	{
		int n = src.getAccountType();
		if (n)
			buffer.appendf("<AccountType>%d</AccountType>", n);
	}
	// field toomany
	{
		bool b = src.getToomany();
		if (b)
			buffer.appendf("<toomany>1</toomany>");
	}
	// field Users
	{
		IArrayOf<IConstUserInfo>& v = src.getUsers();
		int size = v.length();
		if (size>0)
			buffer.append("<Users>");
		for (int i=0;i<size;i++)
		{
			buffer.append("<User>");
			CUserInfo::serializer(ctx,v.item(i),buffer,false);
			buffer.append("</User>");
		}
		if (size>0)
			buffer.append("</Users>");
	}
	// field Groups
	{
		IArrayOf<IConstGroupInfo>& v = src.getGroups();
		int size = v.length();
		if (size>0)
			buffer.append("<Groups>");
		for (int i=0;i<size;i++)
		{
			buffer.append("<Group>");
			CGroupInfo::serializer(ctx,v.item(i),buffer,false);
			buffer.append("</Group>");
		}
		if (size>0)
			buffer.append("</Groups>");
	}
	// field Resources
	if ((clientVer==-1.0 || clientVer>=1.01))
	{
		StringArray& v = src.getResources();
		if (v.length()>0)
			buffer.append("<Resources>");
		for (size32_t i=0;i<v.length();i++)
			buffer.appendf("<Item>%s</Item>",v.item(i));
		if (v.length()>0)
			buffer.append("</Resources>");
	}
	if (keepRootTag)
		buffer.append("</PermissionAddResponse>");
}

bool CPermissionAddResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
		hasValue |= m_basedn.unmarshall(rpc_request, "basedn", basepath);
		hasValue |= m_rtype.unmarshall(rpc_request, "rtype", basepath);
		hasValue |= m_rtitle.unmarshall(rpc_request, "rtitle", basepath);
		hasValue |= m_rname.unmarshall(rpc_request, "rname", basepath);
		hasValue |= m_prefix.unmarshall(rpc_request, "prefix", basepath);
		hasValue |= m_BasednName.unmarshall(rpc_request, "BasednName", basepath);
		hasValue |= m_AccountName.unmarshall(rpc_request, "AccountName", basepath);
		hasValue |= m_AccountType.unmarshall(rpc_request, "AccountType", basepath);
		hasValue |= m_toomany.unmarshall(rpc_request, "toomany", basepath);
		hasValue |= m_Users.unmarshall(rpc_request, "Users", basepath);
		hasValue |= m_Groups.unmarshall(rpc_request, "Groups", basepath);
		hasValue |= m_Resources.unmarshall(rpc_request, "Resources", basepath);
	}
	return hasValue;
}

bool CPermissionAddResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_basedn.unmarshall(ctx, soapval, "basedn");
	hasValue |= m_rtype.unmarshall(ctx, soapval, "rtype");
	hasValue |= m_rtitle.unmarshall(ctx, soapval, "rtitle");
	hasValue |= m_rname.unmarshall(ctx, soapval, "rname");
	hasValue |= m_prefix.unmarshall(ctx, soapval, "prefix");
	hasValue |= m_BasednName.unmarshall(ctx, soapval, "BasednName");
	hasValue |= m_AccountName.unmarshall(ctx, soapval, "AccountName");
	hasValue |= m_AccountType.unmarshall(ctx, soapval, "AccountType");
	hasValue |= m_toomany.unmarshall(ctx, soapval, "toomany");
	hasValue |= m_Users.unmarshall(ctx, soapval, "Users");
	hasValue |= m_Groups.unmarshall(ctx, soapval, "Groups");
	hasValue |= m_Resources.unmarshall(ctx, soapval, "Resources");
	return hasValue;
}

bool CPermissionAddResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_basedn.unmarshall(ctx, params, attachments, "basedn", basepath);
	hasValue |= m_rtype.unmarshall(ctx, params, attachments, "rtype", basepath);
	hasValue |= m_rtitle.unmarshall(ctx, params, attachments, "rtitle", basepath);
	hasValue |= m_rname.unmarshall(ctx, params, attachments, "rname", basepath);
	hasValue |= m_prefix.unmarshall(ctx, params, attachments, "prefix", basepath);
	hasValue |= m_BasednName.unmarshall(ctx, params, attachments, "BasednName", basepath);
	hasValue |= m_AccountName.unmarshall(ctx, params, attachments, "AccountName", basepath);
	hasValue |= m_AccountType.unmarshall(ctx, params, attachments, "AccountType", basepath);
	hasValue |= m_toomany.unmarshall(ctx, params, attachments, "toomany", basepath);
	hasValue |= m_Users.unmarshall(ctx, params, attachments, "Users", basepath);
	hasValue |= m_Groups.unmarshall(ctx, params, attachments, "Groups", basepath);
	hasValue |= m_Resources.unmarshall(ctx, params, attachments, "Resources", basepath);
	return hasValue;
}

const char * CPermissionAddResponse::getBasedn() { return m_basedn.query();}
const char * CPermissionAddResponse::getRtype() { return m_rtype.query();}
const char * CPermissionAddResponse::getRtitle() { return m_rtitle.query();}
const char * CPermissionAddResponse::getRname() { return m_rname.query();}
const char * CPermissionAddResponse::getPrefix() { return m_prefix.query();}
const char * CPermissionAddResponse::getBasednName() { return m_BasednName.query();}
const char * CPermissionAddResponse::getAccountName() { return m_AccountName.query();}
int CPermissionAddResponse::getAccountType() { return m_AccountType;}
bool CPermissionAddResponse::getToomany() { return m_toomany;}
IArrayOf<IConstUserInfo> & CPermissionAddResponse::getUsers() { return (IArrayOf<IConstUserInfo> &) m_Users; }
IArrayOf<IConstGroupInfo> & CPermissionAddResponse::getGroups() { return (IArrayOf<IConstGroupInfo> &) m_Groups; }
StringArray & CPermissionAddResponse::getResources() { return (StringArray &) m_Resources; }
void CPermissionAddResponse::setBasedn(const char * val){ m_basedn.set(val); }
void CPermissionAddResponse::setRtype(const char * val){ m_rtype.set(val); }
void CPermissionAddResponse::setRtitle(const char * val){ m_rtitle.set(val); }
void CPermissionAddResponse::setRname(const char * val){ m_rname.set(val); }
void CPermissionAddResponse::setPrefix(const char * val){ m_prefix.set(val); }
void CPermissionAddResponse::setBasednName(const char * val){ m_BasednName.set(val); }
void CPermissionAddResponse::setAccountName(const char * val){ m_AccountName.set(val); }
void CPermissionAddResponse::setAccountType(int val){ m_AccountType=val; }
void CPermissionAddResponse::setToomany(bool val){ m_toomany=val; }
void CPermissionAddResponse::setUsers(IArrayOf<IEspUserInfo> &val)
{
	m_Users->kill();
	IArrayOf<IConstUserInfo> &target = m_Users.getValue();
	ForEachItemIn(idx, val)
	{
		IEspUserInfo &item = (val).item(idx);
		item.Link();
		target.append(item);
	}
}
void CPermissionAddResponse::setUsers(IArrayOf<IConstUserInfo> &val)
{
	m_Users->kill();
	IArrayOf<IConstUserInfo> &target = m_Users.getValue();
	ForEachItemIn(idx, val)
	{
		IConstUserInfo &item = val.item(idx);
		item.Link();
		target.append(item);
	}
}
void CPermissionAddResponse::setGroups(IArrayOf<IEspGroupInfo> &val)
{
	m_Groups->kill();
	IArrayOf<IConstGroupInfo> &target = m_Groups.getValue();
	ForEachItemIn(idx, val)
	{
		IEspGroupInfo &item = (val).item(idx);
		item.Link();
		target.append(item);
	}
}
void CPermissionAddResponse::setGroups(IArrayOf<IConstGroupInfo> &val)
{
	m_Groups->kill();
	IArrayOf<IConstGroupInfo> &target = m_Groups.getValue();
	ForEachItemIn(idx, val)
	{
		IConstGroupInfo &item = val.item(idx);
		item.Link();
		target.append(item);
	}
}
void CPermissionAddResponse::setResources(StringArray &val){ m_Resources->kill();  CloneArray(m_Resources.getValue(), val); }
extern "C"  IEspPermissionAddResponse *createPermissionAddResponse(const char *serv){return ((IEspPermissionAddResponse *)new CPermissionAddResponse(serv));}
extern "C"  IClientPermissionAddResponse *createClientPermissionAddResponse(const char *serv){return ((IClientPermissionAddResponse *)new CPermissionAddResponse(serv));}

//=======================================================
// class CPermissionsResetInputRequest Implementation
//=======================================================

CPermissionsResetInputRequest::CPermissionsResetInputRequest(const char *serviceName, IRpcMessageBinding *init)
	: m_basedn(nilIgnore),m_rtype(nilIgnore),m_rtitle(nilIgnore),m_rname(nilIgnore),m_prefix(nilIgnore),m_names(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("PermissionsResetInputRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CPermissionsResetInputRequest::CPermissionsResetInputRequest(const char *serviceName, const char *bc)
	: m_basedn(nilIgnore),m_rtype(nilIgnore),m_rtitle(nilIgnore),m_rname(nilIgnore),m_prefix(nilIgnore),m_names(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("PermissionsResetInputRequest");
}

CPermissionsResetInputRequest::CPermissionsResetInputRequest(const char *serviceName, IRpcMessage* rpcmsg)
	: m_basedn(nilIgnore),m_rtype(nilIgnore),m_rtitle(nilIgnore),m_rname(nilIgnore),m_prefix(nilIgnore),m_names(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("PermissionsResetInputRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CPermissionsResetInputRequest::CPermissionsResetInputRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_basedn(nilIgnore),m_rtype(nilIgnore),m_rtitle(nilIgnore),m_rname(nilIgnore),m_prefix(nilIgnore),m_names(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("PermissionsResetInputRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CPermissionsResetInputRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"basedn\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"rtype\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"rtitle\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"rname\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"prefix\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"names\" type=\"tns:EspStringArray\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	if (added.getValue("EspStringArray")==NULL) {
		addEspNativeArray(schema,"string","EspStringArray");
		added.setValue("EspStringArray",1);
	}
	return schema;
}

void CPermissionsResetInputRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CPermissionsResetInputRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CPermissionsResetInputRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("basedn");
	form.appendf("  <tr><td><b>basedn: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("rtype");
	form.appendf("  <tr><td><b>rtype: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("rtitle");
	form.appendf("  <tr><td><b>rtitle: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("rname");
	form.appendf("  <tr><td><b>rname: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("prefix");
	form.appendf("  <tr><td><b>prefix: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("names");
	form.appendf("<tr><td><b>names: </b></td><td>");
	form.appendf("<textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea>", extfix.str());
	form.append("</td></tr>");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CPermissionsResetInputRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CPermissionsResetInputRequest::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_basedn.marshall(rpc_resp, "basedn", "", "", "");
	m_rtype.marshall(rpc_resp, "rtype", "", "", "");
	m_rtitle.marshall(rpc_resp, "rtitle", "", "", "");
	m_rname.marshall(rpc_resp, "rname", "", "", "");
	m_prefix.marshall(rpc_resp, "prefix", "", "", "");
	m_names.marshall(rpc_resp, "names", "Item");
}


void CPermissionsResetInputRequest::copy(CPermissionsResetInputRequest &from)
{
	m_basedn.copy(from.m_basedn);
	m_rtype.copy(from.m_rtype);
	m_rtitle.copy(from.m_rtitle);
	m_rname.copy(from.m_rname);
	m_prefix.copy(from.m_prefix);
	m_names.copy(from.m_names);
}


void CPermissionsResetInputRequest::copy(IConstPermissionsResetInputRequest &ifrom)
{
	setBasedn(ifrom.getBasedn());
	setRtype(ifrom.getRtype());
	setRtitle(ifrom.getRtitle());
	setRname(ifrom.getRname());
	setPrefix(ifrom.getPrefix());
	setNames(ifrom.getNames());
}


void CPermissionsResetInputRequest::getAttributes(IProperties &attributes)
{
}


void CPermissionsResetInputRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_basedn.toStr(ctx, buffer, "basedn", "", true, "", "");
	m_rtype.toStr(ctx, buffer, "rtype", "", true, "", "");
	m_rtitle.toStr(ctx, buffer, "rtitle", "", true, "", "");
	m_rname.toStr(ctx, buffer, "rname", "", true, "", "");
	m_prefix.toStr(ctx, buffer, "prefix", "", true, "", "");
	m_names.toStr(ctx, buffer, "names", "Item");
}


void CPermissionsResetInputRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CPermissionsResetInputRequest::serializer(IEspContext* ctx, IConstPermissionsResetInputRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<PermissionsResetInputRequest>");
	// field basedn
	{
		const char* s = src.getBasedn();
		if (s && *s)
		{
			buffer.append("<basedn>");
			encodeUtf8XML(s,buffer);
			buffer.append("</basedn>");
		}
	}
	// field rtype
	{
		const char* s = src.getRtype();
		if (s && *s)
		{
			buffer.append("<rtype>");
			encodeUtf8XML(s,buffer);
			buffer.append("</rtype>");
		}
	}
	// field rtitle
	{
		const char* s = src.getRtitle();
		if (s && *s)
		{
			buffer.append("<rtitle>");
			encodeUtf8XML(s,buffer);
			buffer.append("</rtitle>");
		}
	}
	// field rname
	{
		const char* s = src.getRname();
		if (s && *s)
		{
			buffer.append("<rname>");
			encodeUtf8XML(s,buffer);
			buffer.append("</rname>");
		}
	}
	// field prefix
	{
		const char* s = src.getPrefix();
		if (s && *s)
		{
			buffer.append("<prefix>");
			encodeUtf8XML(s,buffer);
			buffer.append("</prefix>");
		}
	}
	// field names
	{
		StringArray& v = src.getNames();
		if (v.length()>0)
			buffer.append("<names>");
		for (size32_t i=0;i<v.length();i++)
			buffer.appendf("<Item>%s</Item>",v.item(i));
		if (v.length()>0)
			buffer.append("</names>");
	}
	if (keepRootTag)
		buffer.append("</PermissionsResetInputRequest>");
}

bool CPermissionsResetInputRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_basedn.unmarshall(rpc_request, "basedn", basepath);
	hasValue |= m_rtype.unmarshall(rpc_request, "rtype", basepath);
	hasValue |= m_rtitle.unmarshall(rpc_request, "rtitle", basepath);
	hasValue |= m_rname.unmarshall(rpc_request, "rname", basepath);
	hasValue |= m_prefix.unmarshall(rpc_request, "prefix", basepath);
	hasValue |= m_names.unmarshall(rpc_request, "names", basepath);
	return hasValue;
}

bool CPermissionsResetInputRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_basedn.unmarshall(ctx, soapval, "basedn");
	hasValue |= m_rtype.unmarshall(ctx, soapval, "rtype");
	hasValue |= m_rtitle.unmarshall(ctx, soapval, "rtitle");
	hasValue |= m_rname.unmarshall(ctx, soapval, "rname");
	hasValue |= m_prefix.unmarshall(ctx, soapval, "prefix");
	hasValue |= m_names.unmarshall(ctx, soapval, "names");
	return hasValue;
}

bool CPermissionsResetInputRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_basedn.unmarshall(ctx, params, attachments, "basedn", basepath);
	hasValue |= m_rtype.unmarshall(ctx, params, attachments, "rtype", basepath);
	hasValue |= m_rtitle.unmarshall(ctx, params, attachments, "rtitle", basepath);
	hasValue |= m_rname.unmarshall(ctx, params, attachments, "rname", basepath);
	hasValue |= m_prefix.unmarshall(ctx, params, attachments, "prefix", basepath);
	hasValue |= m_names.unmarshall(ctx, params, attachments, "names", basepath);
	return hasValue;
}

const char * CPermissionsResetInputRequest::getBasedn() { return m_basedn.query();}
const char * CPermissionsResetInputRequest::getRtype() { return m_rtype.query();}
const char * CPermissionsResetInputRequest::getRtitle() { return m_rtitle.query();}
const char * CPermissionsResetInputRequest::getRname() { return m_rname.query();}
const char * CPermissionsResetInputRequest::getPrefix() { return m_prefix.query();}
StringArray & CPermissionsResetInputRequest::getNames() { return (StringArray &) m_names; }
void CPermissionsResetInputRequest::setBasedn(const char * val){ m_basedn.set(val); }
void CPermissionsResetInputRequest::setRtype(const char * val){ m_rtype.set(val); }
void CPermissionsResetInputRequest::setRtitle(const char * val){ m_rtitle.set(val); }
void CPermissionsResetInputRequest::setRname(const char * val){ m_rname.set(val); }
void CPermissionsResetInputRequest::setPrefix(const char * val){ m_prefix.set(val); }
void CPermissionsResetInputRequest::setNames(StringArray &val){ m_names->kill();  CloneArray(m_names.getValue(), val); }
extern "C"  IEspPermissionsResetInputRequest *createPermissionsResetInputRequest(const char *serv){return ((IEspPermissionsResetInputRequest *)new CPermissionsResetInputRequest(serv));}
extern "C"  IClientPermissionsResetInputRequest *createClientPermissionsResetInputRequest(const char *serv){return ((IClientPermissionsResetInputRequest *)new CPermissionsResetInputRequest(serv));}

//=======================================================
// class CPermissionsResetInputResponse Implementation
//=======================================================

CPermissionsResetInputResponse::CPermissionsResetInputResponse(const char *serviceName, IRpcMessageBinding *init)
	: m_basedn(nilIgnore),m_rtype(nilIgnore),m_rtitle(nilIgnore),m_rname(nilIgnore),m_prefix(nilIgnore),m_toomany(nilIgnore),m_Users(nilIgnore),m_Groups(nilIgnore),m_Resources(nilIgnore),m_ResourceList(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("PermissionsResetInputResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CPermissionsResetInputResponse::CPermissionsResetInputResponse(const char *serviceName, const char *bc)
	: m_basedn(nilIgnore),m_rtype(nilIgnore),m_rtitle(nilIgnore),m_rname(nilIgnore),m_prefix(nilIgnore),m_toomany(nilIgnore),m_Users(nilIgnore),m_Groups(nilIgnore),m_Resources(nilIgnore),m_ResourceList(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("PermissionsResetInputResponse");
}

CPermissionsResetInputResponse::CPermissionsResetInputResponse(const char *serviceName, IRpcMessage* rpcmsg)
	: m_basedn(nilIgnore),m_rtype(nilIgnore),m_rtitle(nilIgnore),m_rname(nilIgnore),m_prefix(nilIgnore),m_toomany(nilIgnore),m_Users(nilIgnore),m_Groups(nilIgnore),m_Resources(nilIgnore),m_ResourceList(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("PermissionsResetInputResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CPermissionsResetInputResponse::CPermissionsResetInputResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_basedn(nilIgnore),m_rtype(nilIgnore),m_rtitle(nilIgnore),m_rname(nilIgnore),m_prefix(nilIgnore),m_toomany(nilIgnore),m_Users(nilIgnore),m_Groups(nilIgnore),m_Resources(nilIgnore),m_ResourceList(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("PermissionsResetInputResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CPermissionsResetInputResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"basedn\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"rtype\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"rtitle\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"rname\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"prefix\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"toomany\" type=\"xsd:boolean\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Users\">\n");
		schema.append("<xsd:complexType><xsd:sequence>\n");
		schema.append("<xsd:element minOccurs=\"0\" maxOccurs=\"unbounded\" name=\"User\" type=\"tns:UserInfo\"/>");
		schema.append("</xsd:sequence></xsd:complexType>");
		schema.append("</xsd:element>");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Groups\">\n");
		schema.append("<xsd:complexType><xsd:sequence>\n");
		schema.append("<xsd:element minOccurs=\"0\" maxOccurs=\"unbounded\" name=\"Group\" type=\"tns:GroupInfo\"/>");
		schema.append("</xsd:sequence></xsd:complexType>");
		schema.append("</xsd:element>");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Resources\">");
		schema.append("<xsd:complexType><xsd:sequence>");
		schema.append("<xsd:element name=\"Resource\" type=\"xsd:string\" minOccurs=\"0\" maxOccurs=\"unbounded\"/>\n");
		schema.append("</xsd:sequence></xsd:complexType>\n");
		schema.append("</xsd:element>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"ResourceList\" type=\"xsd:string\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	if (!(flags & 0x10)  || (flags & 0x100))
	{
		CUserInfo::getXsdDefinition(context, request, schema, added);
		CGroupInfo::getXsdDefinition(context, request, schema, added);
	}
	return schema;
}

void CPermissionsResetInputResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CPermissionsResetInputResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
	if (!added.getValue("GroupInfo"))
	{
		added.setValue("GroupInfo",1);
		CGroupInfo::getMapInfo(info,added);
	}
	if (!added.getValue("UserInfo"))
	{
		added.setValue("UserInfo",1);
		CUserInfo::getMapInfo(info,added);
	}
}

StringBuffer &CPermissionsResetInputResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("basedn");
	form.appendf("  <tr><td><b>basedn: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("rtype");
	form.appendf("  <tr><td><b>rtype: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("rtitle");
	form.appendf("  <tr><td><b>rtitle: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("rname");
	form.appendf("  <tr><td><b>rname: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("prefix");
	form.appendf("  <tr><td><b>prefix: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("toomany");
	
	form.appendf("  <tr><td><b>toomany? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Users");
	form.appendf("<tr><td><b>Users: </b></td><td>");
	form.appendf("<table><tr><td><textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea></td>", extfix.str());
	form.append("</tr></table>");
	form.append("</td></tr>");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Groups");
	form.appendf("<tr><td><b>Groups: </b></td><td>");
	form.appendf("<table><tr><td><textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea></td>", extfix.str());
	form.append("</tr></table>");
	form.append("</td></tr>");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Resources");
	form.appendf("<tr><td><b>Resources: </b></td><td>");
	form.appendf("<textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea>", extfix.str());
	form.append("</td></tr>");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("ResourceList");
	form.appendf("  <tr><td><b>ResourceList: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CPermissionsResetInputResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CPermissionsResetInputResponse::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
		m_basedn.marshall(rpc_resp, "basedn", "", "", "");
		m_rtype.marshall(rpc_resp, "rtype", "", "", "");
		m_rtitle.marshall(rpc_resp, "rtitle", "", "", "");
		m_rname.marshall(rpc_resp, "rname", "", "", "");
		m_prefix.marshall(rpc_resp, "prefix", "", "", "");
		m_toomany.marshall(rpc_resp, "toomany", "", "", "");
		m_Users.marshall(rpc_resp, "Users", "User");
		m_Groups.marshall(rpc_resp, "Groups", "Group");
		m_Resources.marshall(rpc_resp, "Resources", "Resource");
		m_ResourceList.marshall(rpc_resp, "ResourceList", "", "", "");
	}
}


void CPermissionsResetInputResponse::copy(CPermissionsResetInputResponse &from)
{
	m_basedn.copy(from.m_basedn);
	m_rtype.copy(from.m_rtype);
	m_rtitle.copy(from.m_rtitle);
	m_rname.copy(from.m_rname);
	m_prefix.copy(from.m_prefix);
	m_toomany.copy(from.m_toomany);
	m_Users.copy(from.m_Users);
	m_Groups.copy(from.m_Groups);
	m_Resources.copy(from.m_Resources);
	m_ResourceList.copy(from.m_ResourceList);
}


void CPermissionsResetInputResponse::copy(IConstPermissionsResetInputResponse &ifrom)
{
	setBasedn(ifrom.getBasedn());
	setRtype(ifrom.getRtype());
	setRtitle(ifrom.getRtitle());
	setRname(ifrom.getRname());
	setPrefix(ifrom.getPrefix());
	setToomany(ifrom.getToomany());
	setUsers(ifrom.getUsers());
	setGroups(ifrom.getGroups());
	setResources(ifrom.getResources());
	setResourceList(ifrom.getResourceList());
}


void CPermissionsResetInputResponse::getAttributes(IProperties &attributes)
{
}


void CPermissionsResetInputResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
		m_basedn.toStr(ctx, buffer, "basedn", "", true, "", "");
		m_rtype.toStr(ctx, buffer, "rtype", "", true, "", "");
		m_rtitle.toStr(ctx, buffer, "rtitle", "", true, "", "");
		m_rname.toStr(ctx, buffer, "rname", "", true, "", "");
		m_prefix.toStr(ctx, buffer, "prefix", "", true, "", "");
		m_toomany.toStr(ctx, buffer, "toomany", "", true, "", "");
		m_Users.toStr(ctx, buffer, "Users", "User");
		m_Groups.toStr(ctx, buffer, "Groups", "Group");
		m_Resources.toStr(ctx, buffer, "Resources", "Resource");
		m_ResourceList.toStr(ctx, buffer, "ResourceList", "", true, "", "");
	}
}


void CPermissionsResetInputResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CPermissionsResetInputResponse::serializer(IEspContext* ctx, IConstPermissionsResetInputResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<PermissionsResetInputResponse>");
	// field basedn
	{
		const char* s = src.getBasedn();
		if (s && *s)
		{
			buffer.append("<basedn>");
			encodeUtf8XML(s,buffer);
			buffer.append("</basedn>");
		}
	}
	// field rtype
	{
		const char* s = src.getRtype();
		if (s && *s)
		{
			buffer.append("<rtype>");
			encodeUtf8XML(s,buffer);
			buffer.append("</rtype>");
		}
	}
	// field rtitle
	{
		const char* s = src.getRtitle();
		if (s && *s)
		{
			buffer.append("<rtitle>");
			encodeUtf8XML(s,buffer);
			buffer.append("</rtitle>");
		}
	}
	// field rname
	{
		const char* s = src.getRname();
		if (s && *s)
		{
			buffer.append("<rname>");
			encodeUtf8XML(s,buffer);
			buffer.append("</rname>");
		}
	}
	// field prefix
	{
		const char* s = src.getPrefix();
		if (s && *s)
		{
			buffer.append("<prefix>");
			encodeUtf8XML(s,buffer);
			buffer.append("</prefix>");
		}
	}
	// field toomany
	{
		bool b = src.getToomany();
		if (b)
			buffer.appendf("<toomany>1</toomany>");
	}
	// field Users
	{
		IArrayOf<IConstUserInfo>& v = src.getUsers();
		int size = v.length();
		if (size>0)
			buffer.append("<Users>");
		for (int i=0;i<size;i++)
		{
			buffer.append("<User>");
			CUserInfo::serializer(ctx,v.item(i),buffer,false);
			buffer.append("</User>");
		}
		if (size>0)
			buffer.append("</Users>");
	}
	// field Groups
	{
		IArrayOf<IConstGroupInfo>& v = src.getGroups();
		int size = v.length();
		if (size>0)
			buffer.append("<Groups>");
		for (int i=0;i<size;i++)
		{
			buffer.append("<Group>");
			CGroupInfo::serializer(ctx,v.item(i),buffer,false);
			buffer.append("</Group>");
		}
		if (size>0)
			buffer.append("</Groups>");
	}
	// field Resources
	{
		StringArray& v = src.getResources();
		if (v.length()>0)
			buffer.append("<Resources>");
		for (size32_t i=0;i<v.length();i++)
			buffer.appendf("<Resource>%s</Resource>",v.item(i));
		if (v.length()>0)
			buffer.append("</Resources>");
	}
	// field ResourceList
	{
		const char* s = src.getResourceList();
		if (s && *s)
		{
			buffer.append("<ResourceList>");
			encodeUtf8XML(s,buffer);
			buffer.append("</ResourceList>");
		}
	}
	if (keepRootTag)
		buffer.append("</PermissionsResetInputResponse>");
}

bool CPermissionsResetInputResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
		hasValue |= m_basedn.unmarshall(rpc_request, "basedn", basepath);
		hasValue |= m_rtype.unmarshall(rpc_request, "rtype", basepath);
		hasValue |= m_rtitle.unmarshall(rpc_request, "rtitle", basepath);
		hasValue |= m_rname.unmarshall(rpc_request, "rname", basepath);
		hasValue |= m_prefix.unmarshall(rpc_request, "prefix", basepath);
		hasValue |= m_toomany.unmarshall(rpc_request, "toomany", basepath);
		hasValue |= m_Users.unmarshall(rpc_request, "Users", basepath);
		hasValue |= m_Groups.unmarshall(rpc_request, "Groups", basepath);
		hasValue |= m_Resources.unmarshall(rpc_request, "Resources", basepath);
		hasValue |= m_ResourceList.unmarshall(rpc_request, "ResourceList", basepath);
	}
	return hasValue;
}

bool CPermissionsResetInputResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_basedn.unmarshall(ctx, soapval, "basedn");
	hasValue |= m_rtype.unmarshall(ctx, soapval, "rtype");
	hasValue |= m_rtitle.unmarshall(ctx, soapval, "rtitle");
	hasValue |= m_rname.unmarshall(ctx, soapval, "rname");
	hasValue |= m_prefix.unmarshall(ctx, soapval, "prefix");
	hasValue |= m_toomany.unmarshall(ctx, soapval, "toomany");
	hasValue |= m_Users.unmarshall(ctx, soapval, "Users");
	hasValue |= m_Groups.unmarshall(ctx, soapval, "Groups");
	hasValue |= m_Resources.unmarshall(ctx, soapval, "Resources");
	hasValue |= m_ResourceList.unmarshall(ctx, soapval, "ResourceList");
	return hasValue;
}

bool CPermissionsResetInputResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_basedn.unmarshall(ctx, params, attachments, "basedn", basepath);
	hasValue |= m_rtype.unmarshall(ctx, params, attachments, "rtype", basepath);
	hasValue |= m_rtitle.unmarshall(ctx, params, attachments, "rtitle", basepath);
	hasValue |= m_rname.unmarshall(ctx, params, attachments, "rname", basepath);
	hasValue |= m_prefix.unmarshall(ctx, params, attachments, "prefix", basepath);
	hasValue |= m_toomany.unmarshall(ctx, params, attachments, "toomany", basepath);
	hasValue |= m_Users.unmarshall(ctx, params, attachments, "Users", basepath);
	hasValue |= m_Groups.unmarshall(ctx, params, attachments, "Groups", basepath);
	hasValue |= m_Resources.unmarshall(ctx, params, attachments, "Resources", basepath);
	hasValue |= m_ResourceList.unmarshall(ctx, params, attachments, "ResourceList", basepath);
	return hasValue;
}

const char * CPermissionsResetInputResponse::getBasedn() { return m_basedn.query();}
const char * CPermissionsResetInputResponse::getRtype() { return m_rtype.query();}
const char * CPermissionsResetInputResponse::getRtitle() { return m_rtitle.query();}
const char * CPermissionsResetInputResponse::getRname() { return m_rname.query();}
const char * CPermissionsResetInputResponse::getPrefix() { return m_prefix.query();}
bool CPermissionsResetInputResponse::getToomany() { return m_toomany;}
IArrayOf<IConstUserInfo> & CPermissionsResetInputResponse::getUsers() { return (IArrayOf<IConstUserInfo> &) m_Users; }
IArrayOf<IConstGroupInfo> & CPermissionsResetInputResponse::getGroups() { return (IArrayOf<IConstGroupInfo> &) m_Groups; }
StringArray & CPermissionsResetInputResponse::getResources() { return (StringArray &) m_Resources; }
const char * CPermissionsResetInputResponse::getResourceList() { return m_ResourceList.query();}
void CPermissionsResetInputResponse::setBasedn(const char * val){ m_basedn.set(val); }
void CPermissionsResetInputResponse::setRtype(const char * val){ m_rtype.set(val); }
void CPermissionsResetInputResponse::setRtitle(const char * val){ m_rtitle.set(val); }
void CPermissionsResetInputResponse::setRname(const char * val){ m_rname.set(val); }
void CPermissionsResetInputResponse::setPrefix(const char * val){ m_prefix.set(val); }
void CPermissionsResetInputResponse::setToomany(bool val){ m_toomany=val; }
void CPermissionsResetInputResponse::setUsers(IArrayOf<IEspUserInfo> &val)
{
	m_Users->kill();
	IArrayOf<IConstUserInfo> &target = m_Users.getValue();
	ForEachItemIn(idx, val)
	{
		IEspUserInfo &item = (val).item(idx);
		item.Link();
		target.append(item);
	}
}
void CPermissionsResetInputResponse::setUsers(IArrayOf<IConstUserInfo> &val)
{
	m_Users->kill();
	IArrayOf<IConstUserInfo> &target = m_Users.getValue();
	ForEachItemIn(idx, val)
	{
		IConstUserInfo &item = val.item(idx);
		item.Link();
		target.append(item);
	}
}
void CPermissionsResetInputResponse::setGroups(IArrayOf<IEspGroupInfo> &val)
{
	m_Groups->kill();
	IArrayOf<IConstGroupInfo> &target = m_Groups.getValue();
	ForEachItemIn(idx, val)
	{
		IEspGroupInfo &item = (val).item(idx);
		item.Link();
		target.append(item);
	}
}
void CPermissionsResetInputResponse::setGroups(IArrayOf<IConstGroupInfo> &val)
{
	m_Groups->kill();
	IArrayOf<IConstGroupInfo> &target = m_Groups.getValue();
	ForEachItemIn(idx, val)
	{
		IConstGroupInfo &item = val.item(idx);
		item.Link();
		target.append(item);
	}
}
void CPermissionsResetInputResponse::setResources(StringArray &val){ m_Resources->kill();  CloneArray(m_Resources.getValue(), val); }
void CPermissionsResetInputResponse::setResourceList(const char * val){ m_ResourceList.set(val); }
extern "C"  IEspPermissionsResetInputResponse *createPermissionsResetInputResponse(const char *serv){return ((IEspPermissionsResetInputResponse *)new CPermissionsResetInputResponse(serv));}
extern "C"  IClientPermissionsResetInputResponse *createClientPermissionsResetInputResponse(const char *serv){return ((IClientPermissionsResetInputResponse *)new CPermissionsResetInputResponse(serv));}

//=======================================================
// class CPermissionsResetRequest Implementation
//=======================================================

CPermissionsResetRequest::CPermissionsResetRequest(const char *serviceName, IRpcMessageBinding *init)
	: m_basedn(nilIgnore),m_rtype(nilIgnore),m_rname(nilIgnore),m_rtitle(nilIgnore),m_prefix(nilIgnore),m_names(nilIgnore),m_allow_access(nilIgnore),m_allow_read(nilIgnore),m_allow_write(nilIgnore),m_allow_full(nilIgnore),m_deny_access(nilIgnore),m_deny_read(nilIgnore),m_deny_write(nilIgnore),m_deny_full(nilIgnore),m_userarray(nilIgnore),m_grouparray(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("PermissionsResetRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CPermissionsResetRequest::CPermissionsResetRequest(const char *serviceName, const char *bc)
	: m_basedn(nilIgnore),m_rtype(nilIgnore),m_rname(nilIgnore),m_rtitle(nilIgnore),m_prefix(nilIgnore),m_names(nilIgnore),m_allow_access(nilIgnore),m_allow_read(nilIgnore),m_allow_write(nilIgnore),m_allow_full(nilIgnore),m_deny_access(nilIgnore),m_deny_read(nilIgnore),m_deny_write(nilIgnore),m_deny_full(nilIgnore),m_userarray(nilIgnore),m_grouparray(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("PermissionsResetRequest");
}

CPermissionsResetRequest::CPermissionsResetRequest(const char *serviceName, IRpcMessage* rpcmsg)
	: m_basedn(nilIgnore),m_rtype(nilIgnore),m_rname(nilIgnore),m_rtitle(nilIgnore),m_prefix(nilIgnore),m_names(nilIgnore),m_allow_access(nilIgnore),m_allow_read(nilIgnore),m_allow_write(nilIgnore),m_allow_full(nilIgnore),m_deny_access(nilIgnore),m_deny_read(nilIgnore),m_deny_write(nilIgnore),m_deny_full(nilIgnore),m_userarray(nilIgnore),m_grouparray(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("PermissionsResetRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CPermissionsResetRequest::CPermissionsResetRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_basedn(nilIgnore),m_rtype(nilIgnore),m_rname(nilIgnore),m_rtitle(nilIgnore),m_prefix(nilIgnore),m_names(nilIgnore),m_allow_access(nilIgnore),m_allow_read(nilIgnore),m_allow_write(nilIgnore),m_allow_full(nilIgnore),m_deny_access(nilIgnore),m_deny_read(nilIgnore),m_deny_write(nilIgnore),m_deny_full(nilIgnore),m_userarray(nilIgnore),m_grouparray(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("PermissionsResetRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CPermissionsResetRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"basedn\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"rtype\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"rname\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"rtitle\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"prefix\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"names\" type=\"tns:EspStringArray\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"allow_access\" type=\"xsd:boolean\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"allow_read\" type=\"xsd:boolean\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"allow_write\" type=\"xsd:boolean\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"allow_full\" type=\"xsd:boolean\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"deny_access\" type=\"xsd:boolean\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"deny_read\" type=\"xsd:boolean\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"deny_write\" type=\"xsd:boolean\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"deny_full\" type=\"xsd:boolean\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"userarray\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"grouparray\" type=\"xsd:string\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	if (added.getValue("EspStringArray")==NULL) {
		addEspNativeArray(schema,"string","EspStringArray");
		added.setValue("EspStringArray",1);
	}
	return schema;
}

void CPermissionsResetRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CPermissionsResetRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CPermissionsResetRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("basedn");
	form.appendf("  <tr><td><b>basedn: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("rtype");
	form.appendf("  <tr><td><b>rtype: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("rname");
	form.appendf("  <tr><td><b>rname: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("rtitle");
	form.appendf("  <tr><td><b>rtitle: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("prefix");
	form.appendf("  <tr><td><b>prefix: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("names");
	form.appendf("<tr><td><b>names: </b></td><td>");
	form.appendf("<textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea>", extfix.str());
	form.append("</td></tr>");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("allow_access");
	
	form.appendf("  <tr><td><b>allow_access? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("allow_read");
	
	form.appendf("  <tr><td><b>allow_read? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("allow_write");
	
	form.appendf("  <tr><td><b>allow_write? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("allow_full");
	
	form.appendf("  <tr><td><b>allow_full? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("deny_access");
	
	form.appendf("  <tr><td><b>deny_access? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("deny_read");
	
	form.appendf("  <tr><td><b>deny_read? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("deny_write");
	
	form.appendf("  <tr><td><b>deny_write? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("deny_full");
	
	form.appendf("  <tr><td><b>deny_full? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("userarray");
	form.appendf("  <tr><td><b>userarray: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("grouparray");
	form.appendf("  <tr><td><b>grouparray: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CPermissionsResetRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CPermissionsResetRequest::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_basedn.marshall(rpc_resp, "basedn", "", "", "");
	m_rtype.marshall(rpc_resp, "rtype", "", "", "");
	m_rname.marshall(rpc_resp, "rname", "", "", "");
	m_rtitle.marshall(rpc_resp, "rtitle", "", "", "");
	m_prefix.marshall(rpc_resp, "prefix", "", "", "");
	m_names.marshall(rpc_resp, "names", "Item");
	m_allow_access.marshall(rpc_resp, "allow_access", "", "", "");
	m_allow_read.marshall(rpc_resp, "allow_read", "", "", "");
	m_allow_write.marshall(rpc_resp, "allow_write", "", "", "");
	m_allow_full.marshall(rpc_resp, "allow_full", "", "", "");
	m_deny_access.marshall(rpc_resp, "deny_access", "", "", "");
	m_deny_read.marshall(rpc_resp, "deny_read", "", "", "");
	m_deny_write.marshall(rpc_resp, "deny_write", "", "", "");
	m_deny_full.marshall(rpc_resp, "deny_full", "", "", "");
	m_userarray.marshall(rpc_resp, "userarray", "", "", "");
	m_grouparray.marshall(rpc_resp, "grouparray", "", "", "");
}


void CPermissionsResetRequest::copy(CPermissionsResetRequest &from)
{
	m_basedn.copy(from.m_basedn);
	m_rtype.copy(from.m_rtype);
	m_rname.copy(from.m_rname);
	m_rtitle.copy(from.m_rtitle);
	m_prefix.copy(from.m_prefix);
	m_names.copy(from.m_names);
	m_allow_access.copy(from.m_allow_access);
	m_allow_read.copy(from.m_allow_read);
	m_allow_write.copy(from.m_allow_write);
	m_allow_full.copy(from.m_allow_full);
	m_deny_access.copy(from.m_deny_access);
	m_deny_read.copy(from.m_deny_read);
	m_deny_write.copy(from.m_deny_write);
	m_deny_full.copy(from.m_deny_full);
	m_userarray.copy(from.m_userarray);
	m_grouparray.copy(from.m_grouparray);
}


void CPermissionsResetRequest::copy(IConstPermissionsResetRequest &ifrom)
{
	setBasedn(ifrom.getBasedn());
	setRtype(ifrom.getRtype());
	setRname(ifrom.getRname());
	setRtitle(ifrom.getRtitle());
	setPrefix(ifrom.getPrefix());
	setNames(ifrom.getNames());
	setAllow_access(ifrom.getAllow_access());
	setAllow_read(ifrom.getAllow_read());
	setAllow_write(ifrom.getAllow_write());
	setAllow_full(ifrom.getAllow_full());
	setDeny_access(ifrom.getDeny_access());
	setDeny_read(ifrom.getDeny_read());
	setDeny_write(ifrom.getDeny_write());
	setDeny_full(ifrom.getDeny_full());
	setUserarray(ifrom.getUserarray());
	setGrouparray(ifrom.getGrouparray());
}


void CPermissionsResetRequest::getAttributes(IProperties &attributes)
{
}


void CPermissionsResetRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_basedn.toStr(ctx, buffer, "basedn", "", true, "", "");
	m_rtype.toStr(ctx, buffer, "rtype", "", true, "", "");
	m_rname.toStr(ctx, buffer, "rname", "", true, "", "");
	m_rtitle.toStr(ctx, buffer, "rtitle", "", true, "", "");
	m_prefix.toStr(ctx, buffer, "prefix", "", true, "", "");
	m_names.toStr(ctx, buffer, "names", "Item");
	m_allow_access.toStr(ctx, buffer, "allow_access", "", true, "", "");
	m_allow_read.toStr(ctx, buffer, "allow_read", "", true, "", "");
	m_allow_write.toStr(ctx, buffer, "allow_write", "", true, "", "");
	m_allow_full.toStr(ctx, buffer, "allow_full", "", true, "", "");
	m_deny_access.toStr(ctx, buffer, "deny_access", "", true, "", "");
	m_deny_read.toStr(ctx, buffer, "deny_read", "", true, "", "");
	m_deny_write.toStr(ctx, buffer, "deny_write", "", true, "", "");
	m_deny_full.toStr(ctx, buffer, "deny_full", "", true, "", "");
	m_userarray.toStr(ctx, buffer, "userarray", "", true, "", "");
	m_grouparray.toStr(ctx, buffer, "grouparray", "", true, "", "");
}


void CPermissionsResetRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CPermissionsResetRequest::serializer(IEspContext* ctx, IConstPermissionsResetRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<PermissionsResetRequest>");
	// field basedn
	{
		const char* s = src.getBasedn();
		if (s && *s)
		{
			buffer.append("<basedn>");
			encodeUtf8XML(s,buffer);
			buffer.append("</basedn>");
		}
	}
	// field rtype
	{
		const char* s = src.getRtype();
		if (s && *s)
		{
			buffer.append("<rtype>");
			encodeUtf8XML(s,buffer);
			buffer.append("</rtype>");
		}
	}
	// field rname
	{
		const char* s = src.getRname();
		if (s && *s)
		{
			buffer.append("<rname>");
			encodeUtf8XML(s,buffer);
			buffer.append("</rname>");
		}
	}
	// field rtitle
	{
		const char* s = src.getRtitle();
		if (s && *s)
		{
			buffer.append("<rtitle>");
			encodeUtf8XML(s,buffer);
			buffer.append("</rtitle>");
		}
	}
	// field prefix
	{
		const char* s = src.getPrefix();
		if (s && *s)
		{
			buffer.append("<prefix>");
			encodeUtf8XML(s,buffer);
			buffer.append("</prefix>");
		}
	}
	// field names
	{
		StringArray& v = src.getNames();
		if (v.length()>0)
			buffer.append("<names>");
		for (size32_t i=0;i<v.length();i++)
			buffer.appendf("<Item>%s</Item>",v.item(i));
		if (v.length()>0)
			buffer.append("</names>");
	}
	// field allow_access
	{
		bool b = src.getAllow_access();
		if (b)
			buffer.appendf("<allow_access>1</allow_access>");
	}
	// field allow_read
	{
		bool b = src.getAllow_read();
		if (b)
			buffer.appendf("<allow_read>1</allow_read>");
	}
	// field allow_write
	{
		bool b = src.getAllow_write();
		if (b)
			buffer.appendf("<allow_write>1</allow_write>");
	}
	// field allow_full
	{
		bool b = src.getAllow_full();
		if (b)
			buffer.appendf("<allow_full>1</allow_full>");
	}
	// field deny_access
	{
		bool b = src.getDeny_access();
		if (b)
			buffer.appendf("<deny_access>1</deny_access>");
	}
	// field deny_read
	{
		bool b = src.getDeny_read();
		if (b)
			buffer.appendf("<deny_read>1</deny_read>");
	}
	// field deny_write
	{
		bool b = src.getDeny_write();
		if (b)
			buffer.appendf("<deny_write>1</deny_write>");
	}
	// field deny_full
	{
		bool b = src.getDeny_full();
		if (b)
			buffer.appendf("<deny_full>1</deny_full>");
	}
	// field userarray
	{
		const char* s = src.getUserarray();
		if (s && *s)
		{
			buffer.append("<userarray>");
			encodeUtf8XML(s,buffer);
			buffer.append("</userarray>");
		}
	}
	// field grouparray
	{
		const char* s = src.getGrouparray();
		if (s && *s)
		{
			buffer.append("<grouparray>");
			encodeUtf8XML(s,buffer);
			buffer.append("</grouparray>");
		}
	}
	if (keepRootTag)
		buffer.append("</PermissionsResetRequest>");
}

bool CPermissionsResetRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_basedn.unmarshall(rpc_request, "basedn", basepath);
	hasValue |= m_rtype.unmarshall(rpc_request, "rtype", basepath);
	hasValue |= m_rname.unmarshall(rpc_request, "rname", basepath);
	hasValue |= m_rtitle.unmarshall(rpc_request, "rtitle", basepath);
	hasValue |= m_prefix.unmarshall(rpc_request, "prefix", basepath);
	hasValue |= m_names.unmarshall(rpc_request, "names", basepath);
	hasValue |= m_allow_access.unmarshall(rpc_request, "allow_access", basepath);
	hasValue |= m_allow_read.unmarshall(rpc_request, "allow_read", basepath);
	hasValue |= m_allow_write.unmarshall(rpc_request, "allow_write", basepath);
	hasValue |= m_allow_full.unmarshall(rpc_request, "allow_full", basepath);
	hasValue |= m_deny_access.unmarshall(rpc_request, "deny_access", basepath);
	hasValue |= m_deny_read.unmarshall(rpc_request, "deny_read", basepath);
	hasValue |= m_deny_write.unmarshall(rpc_request, "deny_write", basepath);
	hasValue |= m_deny_full.unmarshall(rpc_request, "deny_full", basepath);
	hasValue |= m_userarray.unmarshall(rpc_request, "userarray", basepath);
	hasValue |= m_grouparray.unmarshall(rpc_request, "grouparray", basepath);
	return hasValue;
}

bool CPermissionsResetRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_basedn.unmarshall(ctx, soapval, "basedn");
	hasValue |= m_rtype.unmarshall(ctx, soapval, "rtype");
	hasValue |= m_rname.unmarshall(ctx, soapval, "rname");
	hasValue |= m_rtitle.unmarshall(ctx, soapval, "rtitle");
	hasValue |= m_prefix.unmarshall(ctx, soapval, "prefix");
	hasValue |= m_names.unmarshall(ctx, soapval, "names");
	hasValue |= m_allow_access.unmarshall(ctx, soapval, "allow_access");
	hasValue |= m_allow_read.unmarshall(ctx, soapval, "allow_read");
	hasValue |= m_allow_write.unmarshall(ctx, soapval, "allow_write");
	hasValue |= m_allow_full.unmarshall(ctx, soapval, "allow_full");
	hasValue |= m_deny_access.unmarshall(ctx, soapval, "deny_access");
	hasValue |= m_deny_read.unmarshall(ctx, soapval, "deny_read");
	hasValue |= m_deny_write.unmarshall(ctx, soapval, "deny_write");
	hasValue |= m_deny_full.unmarshall(ctx, soapval, "deny_full");
	hasValue |= m_userarray.unmarshall(ctx, soapval, "userarray");
	hasValue |= m_grouparray.unmarshall(ctx, soapval, "grouparray");
	return hasValue;
}

bool CPermissionsResetRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_basedn.unmarshall(ctx, params, attachments, "basedn", basepath);
	hasValue |= m_rtype.unmarshall(ctx, params, attachments, "rtype", basepath);
	hasValue |= m_rname.unmarshall(ctx, params, attachments, "rname", basepath);
	hasValue |= m_rtitle.unmarshall(ctx, params, attachments, "rtitle", basepath);
	hasValue |= m_prefix.unmarshall(ctx, params, attachments, "prefix", basepath);
	hasValue |= m_names.unmarshall(ctx, params, attachments, "names", basepath);
	hasValue |= m_allow_access.unmarshall(ctx, params, attachments, "allow_access", basepath);
	hasValue |= m_allow_read.unmarshall(ctx, params, attachments, "allow_read", basepath);
	hasValue |= m_allow_write.unmarshall(ctx, params, attachments, "allow_write", basepath);
	hasValue |= m_allow_full.unmarshall(ctx, params, attachments, "allow_full", basepath);
	hasValue |= m_deny_access.unmarshall(ctx, params, attachments, "deny_access", basepath);
	hasValue |= m_deny_read.unmarshall(ctx, params, attachments, "deny_read", basepath);
	hasValue |= m_deny_write.unmarshall(ctx, params, attachments, "deny_write", basepath);
	hasValue |= m_deny_full.unmarshall(ctx, params, attachments, "deny_full", basepath);
	hasValue |= m_userarray.unmarshall(ctx, params, attachments, "userarray", basepath);
	hasValue |= m_grouparray.unmarshall(ctx, params, attachments, "grouparray", basepath);
	return hasValue;
}

const char * CPermissionsResetRequest::getBasedn() { return m_basedn.query();}
const char * CPermissionsResetRequest::getRtype() { return m_rtype.query();}
const char * CPermissionsResetRequest::getRname() { return m_rname.query();}
const char * CPermissionsResetRequest::getRtitle() { return m_rtitle.query();}
const char * CPermissionsResetRequest::getPrefix() { return m_prefix.query();}
StringArray & CPermissionsResetRequest::getNames() { return (StringArray &) m_names; }
bool CPermissionsResetRequest::getAllow_access() { return m_allow_access;}
bool CPermissionsResetRequest::getAllow_read() { return m_allow_read;}
bool CPermissionsResetRequest::getAllow_write() { return m_allow_write;}
bool CPermissionsResetRequest::getAllow_full() { return m_allow_full;}
bool CPermissionsResetRequest::getDeny_access() { return m_deny_access;}
bool CPermissionsResetRequest::getDeny_read() { return m_deny_read;}
bool CPermissionsResetRequest::getDeny_write() { return m_deny_write;}
bool CPermissionsResetRequest::getDeny_full() { return m_deny_full;}
const char * CPermissionsResetRequest::getUserarray() { return m_userarray.query();}
const char * CPermissionsResetRequest::getGrouparray() { return m_grouparray.query();}
void CPermissionsResetRequest::setBasedn(const char * val){ m_basedn.set(val); }
void CPermissionsResetRequest::setRtype(const char * val){ m_rtype.set(val); }
void CPermissionsResetRequest::setRname(const char * val){ m_rname.set(val); }
void CPermissionsResetRequest::setRtitle(const char * val){ m_rtitle.set(val); }
void CPermissionsResetRequest::setPrefix(const char * val){ m_prefix.set(val); }
void CPermissionsResetRequest::setNames(StringArray &val){ m_names->kill();  CloneArray(m_names.getValue(), val); }
void CPermissionsResetRequest::setAllow_access(bool val){ m_allow_access=val; }
void CPermissionsResetRequest::setAllow_read(bool val){ m_allow_read=val; }
void CPermissionsResetRequest::setAllow_write(bool val){ m_allow_write=val; }
void CPermissionsResetRequest::setAllow_full(bool val){ m_allow_full=val; }
void CPermissionsResetRequest::setDeny_access(bool val){ m_deny_access=val; }
void CPermissionsResetRequest::setDeny_read(bool val){ m_deny_read=val; }
void CPermissionsResetRequest::setDeny_write(bool val){ m_deny_write=val; }
void CPermissionsResetRequest::setDeny_full(bool val){ m_deny_full=val; }
void CPermissionsResetRequest::setUserarray(const char * val){ m_userarray.set(val); }
void CPermissionsResetRequest::setGrouparray(const char * val){ m_grouparray.set(val); }
extern "C"  IEspPermissionsResetRequest *createPermissionsResetRequest(const char *serv){return ((IEspPermissionsResetRequest *)new CPermissionsResetRequest(serv));}
extern "C"  IClientPermissionsResetRequest *createClientPermissionsResetRequest(const char *serv){return ((IClientPermissionsResetRequest *)new CPermissionsResetRequest(serv));}

//=======================================================
// class CPermissionsResetResponse Implementation
//=======================================================

CPermissionsResetResponse::CPermissionsResetResponse(const char *serviceName, IRpcMessageBinding *init)
	: m_basedn(nilIgnore),m_rtype(nilIgnore),m_rname(nilIgnore),m_rtitle(nilIgnore),m_prefix(nilIgnore),m_retcode(nilIgnore),m_retmsg(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("PermissionsResetResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CPermissionsResetResponse::CPermissionsResetResponse(const char *serviceName, const char *bc)
	: m_basedn(nilIgnore),m_rtype(nilIgnore),m_rname(nilIgnore),m_rtitle(nilIgnore),m_prefix(nilIgnore),m_retcode(nilIgnore),m_retmsg(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("PermissionsResetResponse");
}

CPermissionsResetResponse::CPermissionsResetResponse(const char *serviceName, IRpcMessage* rpcmsg)
	: m_basedn(nilIgnore),m_rtype(nilIgnore),m_rname(nilIgnore),m_rtitle(nilIgnore),m_prefix(nilIgnore),m_retcode(nilIgnore),m_retmsg(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("PermissionsResetResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CPermissionsResetResponse::CPermissionsResetResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_basedn(nilIgnore),m_rtype(nilIgnore),m_rname(nilIgnore),m_rtitle(nilIgnore),m_prefix(nilIgnore),m_retcode(nilIgnore),m_retmsg(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("PermissionsResetResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CPermissionsResetResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"basedn\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"rtype\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"rname\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"rtitle\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"prefix\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"retcode\" type=\"xsd:int\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"retmsg\" type=\"xsd:string\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CPermissionsResetResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CPermissionsResetResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CPermissionsResetResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("basedn");
	form.appendf("  <tr><td><b>basedn: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("rtype");
	form.appendf("  <tr><td><b>rtype: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("rname");
	form.appendf("  <tr><td><b>rname: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("rtitle");
	form.appendf("  <tr><td><b>rtitle: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("prefix");
	form.appendf("  <tr><td><b>prefix: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix) extfix.append(prefix).append(".");
		extfix.append("retcode");
	form.appendf("  <tr><td><b>retcode: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("retmsg");
	form.appendf("  <tr><td><b>retmsg: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CPermissionsResetResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CPermissionsResetResponse::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
		m_basedn.marshall(rpc_resp, "basedn", "", "", "");
		m_rtype.marshall(rpc_resp, "rtype", "", "", "");
		m_rname.marshall(rpc_resp, "rname", "", "", "");
		m_rtitle.marshall(rpc_resp, "rtitle", "", "", "");
		m_prefix.marshall(rpc_resp, "prefix", "", "", "");
		m_retcode.marshall(rpc_resp, "retcode", "", "", "");
		m_retmsg.marshall(rpc_resp, "retmsg", "", "", "");
	}
}


void CPermissionsResetResponse::copy(CPermissionsResetResponse &from)
{
	m_basedn.copy(from.m_basedn);
	m_rtype.copy(from.m_rtype);
	m_rname.copy(from.m_rname);
	m_rtitle.copy(from.m_rtitle);
	m_prefix.copy(from.m_prefix);
	m_retcode.copy(from.m_retcode);
	m_retmsg.copy(from.m_retmsg);
}


void CPermissionsResetResponse::copy(IConstPermissionsResetResponse &ifrom)
{
	setBasedn(ifrom.getBasedn());
	setRtype(ifrom.getRtype());
	setRname(ifrom.getRname());
	setRtitle(ifrom.getRtitle());
	setPrefix(ifrom.getPrefix());
	setRetcode(ifrom.getRetcode());
	setRetmsg(ifrom.getRetmsg());
}


void CPermissionsResetResponse::getAttributes(IProperties &attributes)
{
}


void CPermissionsResetResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
		m_basedn.toStr(ctx, buffer, "basedn", "", true, "", "");
		m_rtype.toStr(ctx, buffer, "rtype", "", true, "", "");
		m_rname.toStr(ctx, buffer, "rname", "", true, "", "");
		m_rtitle.toStr(ctx, buffer, "rtitle", "", true, "", "");
		m_prefix.toStr(ctx, buffer, "prefix", "", true, "", "");
		m_retcode.toStr(ctx, buffer, "retcode", "", true, "", "");
		m_retmsg.toStr(ctx, buffer, "retmsg", "", true, "", "");
	}
}


void CPermissionsResetResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CPermissionsResetResponse::serializer(IEspContext* ctx, IConstPermissionsResetResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<PermissionsResetResponse>");
	// field basedn
	{
		const char* s = src.getBasedn();
		if (s && *s)
		{
			buffer.append("<basedn>");
			encodeUtf8XML(s,buffer);
			buffer.append("</basedn>");
		}
	}
	// field rtype
	{
		const char* s = src.getRtype();
		if (s && *s)
		{
			buffer.append("<rtype>");
			encodeUtf8XML(s,buffer);
			buffer.append("</rtype>");
		}
	}
	// field rname
	{
		const char* s = src.getRname();
		if (s && *s)
		{
			buffer.append("<rname>");
			encodeUtf8XML(s,buffer);
			buffer.append("</rname>");
		}
	}
	// field rtitle
	{
		const char* s = src.getRtitle();
		if (s && *s)
		{
			buffer.append("<rtitle>");
			encodeUtf8XML(s,buffer);
			buffer.append("</rtitle>");
		}
	}
	// field prefix
	{
		const char* s = src.getPrefix();
		if (s && *s)
		{
			buffer.append("<prefix>");
			encodeUtf8XML(s,buffer);
			buffer.append("</prefix>");
		}
	}
	// field retcode
	{
		int n = src.getRetcode();
		if (n)
			buffer.appendf("<retcode>%d</retcode>", n);
	}
	// field retmsg
	{
		const char* s = src.getRetmsg();
		if (s && *s)
		{
			buffer.append("<retmsg>");
			encodeUtf8XML(s,buffer);
			buffer.append("</retmsg>");
		}
	}
	if (keepRootTag)
		buffer.append("</PermissionsResetResponse>");
}

bool CPermissionsResetResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
		hasValue |= m_basedn.unmarshall(rpc_request, "basedn", basepath);
		hasValue |= m_rtype.unmarshall(rpc_request, "rtype", basepath);
		hasValue |= m_rname.unmarshall(rpc_request, "rname", basepath);
		hasValue |= m_rtitle.unmarshall(rpc_request, "rtitle", basepath);
		hasValue |= m_prefix.unmarshall(rpc_request, "prefix", basepath);
		hasValue |= m_retcode.unmarshall(rpc_request, "retcode", basepath);
		hasValue |= m_retmsg.unmarshall(rpc_request, "retmsg", basepath);
	}
	return hasValue;
}

bool CPermissionsResetResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_basedn.unmarshall(ctx, soapval, "basedn");
	hasValue |= m_rtype.unmarshall(ctx, soapval, "rtype");
	hasValue |= m_rname.unmarshall(ctx, soapval, "rname");
	hasValue |= m_rtitle.unmarshall(ctx, soapval, "rtitle");
	hasValue |= m_prefix.unmarshall(ctx, soapval, "prefix");
	hasValue |= m_retcode.unmarshall(ctx, soapval, "retcode");
	hasValue |= m_retmsg.unmarshall(ctx, soapval, "retmsg");
	return hasValue;
}

bool CPermissionsResetResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_basedn.unmarshall(ctx, params, attachments, "basedn", basepath);
	hasValue |= m_rtype.unmarshall(ctx, params, attachments, "rtype", basepath);
	hasValue |= m_rname.unmarshall(ctx, params, attachments, "rname", basepath);
	hasValue |= m_rtitle.unmarshall(ctx, params, attachments, "rtitle", basepath);
	hasValue |= m_prefix.unmarshall(ctx, params, attachments, "prefix", basepath);
	hasValue |= m_retcode.unmarshall(ctx, params, attachments, "retcode", basepath);
	hasValue |= m_retmsg.unmarshall(ctx, params, attachments, "retmsg", basepath);
	return hasValue;
}

const char * CPermissionsResetResponse::getBasedn() { return m_basedn.query();}
const char * CPermissionsResetResponse::getRtype() { return m_rtype.query();}
const char * CPermissionsResetResponse::getRname() { return m_rname.query();}
const char * CPermissionsResetResponse::getRtitle() { return m_rtitle.query();}
const char * CPermissionsResetResponse::getPrefix() { return m_prefix.query();}
int CPermissionsResetResponse::getRetcode() { return m_retcode;}
const char * CPermissionsResetResponse::getRetmsg() { return m_retmsg.query();}
void CPermissionsResetResponse::setBasedn(const char * val){ m_basedn.set(val); }
void CPermissionsResetResponse::setRtype(const char * val){ m_rtype.set(val); }
void CPermissionsResetResponse::setRname(const char * val){ m_rname.set(val); }
void CPermissionsResetResponse::setRtitle(const char * val){ m_rtitle.set(val); }
void CPermissionsResetResponse::setPrefix(const char * val){ m_prefix.set(val); }
void CPermissionsResetResponse::setRetcode(int val){ m_retcode=val; }
void CPermissionsResetResponse::setRetmsg(const char * val){ m_retmsg.set(val); }
extern "C"  IEspPermissionsResetResponse *createPermissionsResetResponse(const char *serv){return ((IEspPermissionsResetResponse *)new CPermissionsResetResponse(serv));}
extern "C"  IClientPermissionsResetResponse *createClientPermissionsResetResponse(const char *serv){return ((IClientPermissionsResetResponse *)new CPermissionsResetResponse(serv));}

//=======================================================
// class CClearPermissionsCacheRequest Implementation
//=======================================================

CClearPermissionsCacheRequest::CClearPermissionsCacheRequest(const char *serviceName, IRpcMessageBinding *init)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ClearPermissionsCacheRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CClearPermissionsCacheRequest::CClearPermissionsCacheRequest(const char *serviceName, const char *bc)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ClearPermissionsCacheRequest");
}

CClearPermissionsCacheRequest::CClearPermissionsCacheRequest(const char *serviceName, IRpcMessage* rpcmsg)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ClearPermissionsCacheRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CClearPermissionsCacheRequest::CClearPermissionsCacheRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ClearPermissionsCacheRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CClearPermissionsCacheRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType><xsd:all/></xsd:complexType></xsd:element>\n", msgTypeName);
		}
	}
	return schema;
}

void CClearPermissionsCacheRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CClearPermissionsCacheRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CClearPermissionsCacheRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CClearPermissionsCacheRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CClearPermissionsCacheRequest::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

}


void CClearPermissionsCacheRequest::copy(CClearPermissionsCacheRequest &from)
{
}


void CClearPermissionsCacheRequest::copy(IConstClearPermissionsCacheRequest &ifrom)
{
}


void CClearPermissionsCacheRequest::getAttributes(IProperties &attributes)
{
}


void CClearPermissionsCacheRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
}


void CClearPermissionsCacheRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CClearPermissionsCacheRequest::serializer(IEspContext* ctx, IConstClearPermissionsCacheRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<ClearPermissionsCacheRequest>");
	if (keepRootTag)
		buffer.append("</ClearPermissionsCacheRequest>");
}

bool CClearPermissionsCacheRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	return hasValue;
}

bool CClearPermissionsCacheRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	return hasValue;
}

bool CClearPermissionsCacheRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	return hasValue;
}

extern "C"  IEspClearPermissionsCacheRequest *createClearPermissionsCacheRequest(const char *serv){return ((IEspClearPermissionsCacheRequest *)new CClearPermissionsCacheRequest(serv));}
extern "C"  IClientClearPermissionsCacheRequest *createClientClearPermissionsCacheRequest(const char *serv){return ((IClientClearPermissionsCacheRequest *)new CClearPermissionsCacheRequest(serv));}

//=======================================================
// class CClearPermissionsCacheResponse Implementation
//=======================================================

CClearPermissionsCacheResponse::CClearPermissionsCacheResponse(const char *serviceName, IRpcMessageBinding *init)
	: m_retcode(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ClearPermissionsCacheResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CClearPermissionsCacheResponse::CClearPermissionsCacheResponse(const char *serviceName, const char *bc)
	: m_retcode(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ClearPermissionsCacheResponse");
}

CClearPermissionsCacheResponse::CClearPermissionsCacheResponse(const char *serviceName, IRpcMessage* rpcmsg)
	: m_retcode(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ClearPermissionsCacheResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CClearPermissionsCacheResponse::CClearPermissionsCacheResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_retcode(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ClearPermissionsCacheResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CClearPermissionsCacheResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"retcode\" type=\"xsd:int\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CClearPermissionsCacheResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CClearPermissionsCacheResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CClearPermissionsCacheResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix) extfix.append(prefix).append(".");
		extfix.append("retcode");
	form.appendf("  <tr><td><b>retcode: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CClearPermissionsCacheResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CClearPermissionsCacheResponse::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
		m_retcode.marshall(rpc_resp, "retcode", "", "", "");
	}
}


void CClearPermissionsCacheResponse::copy(CClearPermissionsCacheResponse &from)
{
	m_retcode.copy(from.m_retcode);
}


void CClearPermissionsCacheResponse::copy(IConstClearPermissionsCacheResponse &ifrom)
{
	setRetcode(ifrom.getRetcode());
}


void CClearPermissionsCacheResponse::getAttributes(IProperties &attributes)
{
}


void CClearPermissionsCacheResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
		m_retcode.toStr(ctx, buffer, "retcode", "", true, "", "");
	}
}


void CClearPermissionsCacheResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CClearPermissionsCacheResponse::serializer(IEspContext* ctx, IConstClearPermissionsCacheResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<ClearPermissionsCacheResponse>");
	// field retcode
	{
		int n = src.getRetcode();
		if (n)
			buffer.appendf("<retcode>%d</retcode>", n);
	}
	if (keepRootTag)
		buffer.append("</ClearPermissionsCacheResponse>");
}

bool CClearPermissionsCacheResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
		hasValue |= m_retcode.unmarshall(rpc_request, "retcode", basepath);
	}
	return hasValue;
}

bool CClearPermissionsCacheResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_retcode.unmarshall(ctx, soapval, "retcode");
	return hasValue;
}

bool CClearPermissionsCacheResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_retcode.unmarshall(ctx, params, attachments, "retcode", basepath);
	return hasValue;
}

int CClearPermissionsCacheResponse::getRetcode() { return m_retcode;}
void CClearPermissionsCacheResponse::setRetcode(int val){ m_retcode=val; }
extern "C"  IEspClearPermissionsCacheResponse *createClearPermissionsCacheResponse(const char *serv){return ((IEspClearPermissionsCacheResponse *)new CClearPermissionsCacheResponse(serv));}
extern "C"  IClientClearPermissionsCacheResponse *createClientClearPermissionsCacheResponse(const char *serv){return ((IClientClearPermissionsCacheResponse *)new CClearPermissionsCacheResponse(serv));}

//=======================================================
// class CQueryScopeScansEnabledRequest Implementation
//=======================================================

CQueryScopeScansEnabledRequest::CQueryScopeScansEnabledRequest(const char *serviceName, IRpcMessageBinding *init)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("QueryScopeScansEnabledRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CQueryScopeScansEnabledRequest::CQueryScopeScansEnabledRequest(const char *serviceName, const char *bc)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("QueryScopeScansEnabledRequest");
}

CQueryScopeScansEnabledRequest::CQueryScopeScansEnabledRequest(const char *serviceName, IRpcMessage* rpcmsg)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("QueryScopeScansEnabledRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CQueryScopeScansEnabledRequest::CQueryScopeScansEnabledRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("QueryScopeScansEnabledRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CQueryScopeScansEnabledRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType><xsd:all/></xsd:complexType></xsd:element>\n", msgTypeName);
		}
	}
	return schema;
}

void CQueryScopeScansEnabledRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CQueryScopeScansEnabledRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CQueryScopeScansEnabledRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CQueryScopeScansEnabledRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CQueryScopeScansEnabledRequest::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

}


void CQueryScopeScansEnabledRequest::copy(CQueryScopeScansEnabledRequest &from)
{
}


void CQueryScopeScansEnabledRequest::copy(IConstQueryScopeScansEnabledRequest &ifrom)
{
}


void CQueryScopeScansEnabledRequest::getAttributes(IProperties &attributes)
{
}


void CQueryScopeScansEnabledRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
}


void CQueryScopeScansEnabledRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CQueryScopeScansEnabledRequest::serializer(IEspContext* ctx, IConstQueryScopeScansEnabledRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<QueryScopeScansEnabledRequest>");
	if (keepRootTag)
		buffer.append("</QueryScopeScansEnabledRequest>");
}

bool CQueryScopeScansEnabledRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	return hasValue;
}

bool CQueryScopeScansEnabledRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	return hasValue;
}

bool CQueryScopeScansEnabledRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	return hasValue;
}

extern "C"  IEspQueryScopeScansEnabledRequest *createQueryScopeScansEnabledRequest(const char *serv){return ((IEspQueryScopeScansEnabledRequest *)new CQueryScopeScansEnabledRequest(serv));}
extern "C"  IClientQueryScopeScansEnabledRequest *createClientQueryScopeScansEnabledRequest(const char *serv){return ((IClientQueryScopeScansEnabledRequest *)new CQueryScopeScansEnabledRequest(serv));}

//=======================================================
// class CQueryScopeScansEnabledResponse Implementation
//=======================================================

CQueryScopeScansEnabledResponse::CQueryScopeScansEnabledResponse(const char *serviceName, IRpcMessageBinding *init)
	: m_scopeScansStatus(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("QueryScopeScansEnabledResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CQueryScopeScansEnabledResponse::CQueryScopeScansEnabledResponse(const char *serviceName, const char *bc)
	: m_scopeScansStatus(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("QueryScopeScansEnabledResponse");
}

CQueryScopeScansEnabledResponse::CQueryScopeScansEnabledResponse(const char *serviceName, IRpcMessage* rpcmsg)
	: m_scopeScansStatus(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("QueryScopeScansEnabledResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CQueryScopeScansEnabledResponse::CQueryScopeScansEnabledResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_scopeScansStatus(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("QueryScopeScansEnabledResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CQueryScopeScansEnabledResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		if (!context.suppressed("QueryScopeScansEnabledResponse","scopeScansStatus")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"scopeScansStatus\" type=\"tns:ScopeScanStatusStruct\"/>\n");
		}
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	if (!(flags & 0x10)  || (flags & 0x100))
	{
		if (!context.suppressed("QueryScopeScansEnabledResponse","scopeScansStatus"))
			CScopeScanStatusStruct::getXsdDefinition(context, request, schema, added);
	}
	return schema;
}

void CQueryScopeScansEnabledResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CQueryScopeScansEnabledResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
	info.addMinVersion("QueryScopeScansEnabledResponse","scopeScansStatus",1.08);
	if (!added.getValue("ScopeScanStatusStruct"))
	{
		added.setValue("ScopeScanStatusStruct",1);
		CScopeScanStatusStruct::getMapInfo(info,added);
	}
}

StringBuffer &CQueryScopeScansEnabledResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	if (!context.suppressed("QueryScopeScansEnabledResponse","scopeScansStatus")) {
		extfix.clear();
		if (prefix && *prefix)
			extfix.append(prefix).append(".");
		extfix.append("scopeScansStatus");
		form.append("<tr>").append("<td><b>scopeScansStatus: </b></td><td><hr/>");
		CScopeScanStatusStruct::getHtmlForm(context, request, serv, method, form, false, extfix.str());
		form.append("<hr/></td></tr>");
	}
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CQueryScopeScansEnabledResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CQueryScopeScansEnabledResponse::serialize(IRpcMessage& rpc_resp)
{
	IEspContext* ctx = rpc_resp.queryContext();
	double clientVer= ctx ? ctx->getClientVersion() : -1; /* no context gets everything */
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
		if ((clientVer==-1.0 || clientVer>=1.08))
			m_scopeScansStatus.marshall(rpc_resp, "scopeScansStatus", "", "", "");
	}
}


void CQueryScopeScansEnabledResponse::copy(CQueryScopeScansEnabledResponse &from)
{
	m_scopeScansStatus.copy(from.m_scopeScansStatus);
}


void CQueryScopeScansEnabledResponse::copy(IConstQueryScopeScansEnabledResponse &ifrom)
{
	setScopeScansStatus(ifrom.getScopeScansStatus());
}


void CQueryScopeScansEnabledResponse::getAttributes(IProperties &attributes)
{
}


void CQueryScopeScansEnabledResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
		double clientVer = ctx ? ctx->getClientVersion() : -1;
		if ((clientVer==-1.0 || clientVer>=1.08))
			m_scopeScansStatus.toStr(ctx, buffer, "scopeScansStatus", "", false, "", "");
	}
}


void CQueryScopeScansEnabledResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CQueryScopeScansEnabledResponse::serializer(IEspContext* ctx, IConstQueryScopeScansEnabledResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<QueryScopeScansEnabledResponse>");
	double clientVer = ctx ? ctx->getClientVersion() : -1;
	// field scopeScansStatus
	if ((clientVer==-1.0 || clientVer>=1.08))
	{
		StringBuffer tmp;
		CScopeScanStatusStruct::serializer(ctx,src.getScopeScansStatus(), tmp, false);
		if (tmp.length()>0)
			buffer.appendf("<scopeScansStatus>%s</scopeScansStatus>",tmp.str());
	}
	if (keepRootTag)
		buffer.append("</QueryScopeScansEnabledResponse>");
}

bool CQueryScopeScansEnabledResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
		hasValue |= m_scopeScansStatus.unmarshall(rpc_request, "scopeScansStatus", basepath);
	}
	return hasValue;
}

bool CQueryScopeScansEnabledResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_scopeScansStatus.unmarshall(ctx, soapval, "scopeScansStatus");
	return hasValue;
}

bool CQueryScopeScansEnabledResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_scopeScansStatus.unmarshall(ctx, params, attachments, "scopeScansStatus", basepath);
	return hasValue;
}

IConstScopeScanStatusStruct & CQueryScopeScansEnabledResponse::getScopeScansStatus() { return (IConstScopeScanStatusStruct &) m_scopeScansStatus.getValue();}
IEspScopeScanStatusStruct & CQueryScopeScansEnabledResponse::updateScopeScansStatus(){ return (IEspScopeScanStatusStruct &) m_scopeScansStatus.getValue(); }
void CQueryScopeScansEnabledResponse::setScopeScansStatus(IConstScopeScanStatusStruct &ifrom){ m_scopeScansStatus.copy(ifrom); }
extern "C"  IEspQueryScopeScansEnabledResponse *createQueryScopeScansEnabledResponse(const char *serv){return ((IEspQueryScopeScansEnabledResponse *)new CQueryScopeScansEnabledResponse(serv));}
extern "C"  IClientQueryScopeScansEnabledResponse *createClientQueryScopeScansEnabledResponse(const char *serv){return ((IClientQueryScopeScansEnabledResponse *)new CQueryScopeScansEnabledResponse(serv));}

//=======================================================
// class CEnableScopeScansRequest Implementation
//=======================================================

CEnableScopeScansRequest::CEnableScopeScansRequest(const char *serviceName, IRpcMessageBinding *init)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("EnableScopeScansRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CEnableScopeScansRequest::CEnableScopeScansRequest(const char *serviceName, const char *bc)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("EnableScopeScansRequest");
}

CEnableScopeScansRequest::CEnableScopeScansRequest(const char *serviceName, IRpcMessage* rpcmsg)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("EnableScopeScansRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CEnableScopeScansRequest::CEnableScopeScansRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("EnableScopeScansRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CEnableScopeScansRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType><xsd:all/></xsd:complexType></xsd:element>\n", msgTypeName);
		}
	}
	return schema;
}

void CEnableScopeScansRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CEnableScopeScansRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CEnableScopeScansRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CEnableScopeScansRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CEnableScopeScansRequest::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

}


void CEnableScopeScansRequest::copy(CEnableScopeScansRequest &from)
{
}


void CEnableScopeScansRequest::copy(IConstEnableScopeScansRequest &ifrom)
{
}


void CEnableScopeScansRequest::getAttributes(IProperties &attributes)
{
}


void CEnableScopeScansRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
}


void CEnableScopeScansRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CEnableScopeScansRequest::serializer(IEspContext* ctx, IConstEnableScopeScansRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<EnableScopeScansRequest>");
	if (keepRootTag)
		buffer.append("</EnableScopeScansRequest>");
}

bool CEnableScopeScansRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	return hasValue;
}

bool CEnableScopeScansRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	return hasValue;
}

bool CEnableScopeScansRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	return hasValue;
}

extern "C"  IEspEnableScopeScansRequest *createEnableScopeScansRequest(const char *serv){return ((IEspEnableScopeScansRequest *)new CEnableScopeScansRequest(serv));}
extern "C"  IClientEnableScopeScansRequest *createClientEnableScopeScansRequest(const char *serv){return ((IClientEnableScopeScansRequest *)new CEnableScopeScansRequest(serv));}

//=======================================================
// class CEnableScopeScansResponse Implementation
//=======================================================

CEnableScopeScansResponse::CEnableScopeScansResponse(const char *serviceName, IRpcMessageBinding *init)
	: m_scopeScansStatus(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("EnableScopeScansResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CEnableScopeScansResponse::CEnableScopeScansResponse(const char *serviceName, const char *bc)
	: m_scopeScansStatus(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("EnableScopeScansResponse");
}

CEnableScopeScansResponse::CEnableScopeScansResponse(const char *serviceName, IRpcMessage* rpcmsg)
	: m_scopeScansStatus(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("EnableScopeScansResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CEnableScopeScansResponse::CEnableScopeScansResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_scopeScansStatus(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("EnableScopeScansResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CEnableScopeScansResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		if (!context.suppressed("EnableScopeScansResponse","scopeScansStatus")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"scopeScansStatus\" type=\"tns:ScopeScanStatusStruct\"/>\n");
		}
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	if (!(flags & 0x10)  || (flags & 0x100))
	{
		if (!context.suppressed("EnableScopeScansResponse","scopeScansStatus"))
			CScopeScanStatusStruct::getXsdDefinition(context, request, schema, added);
	}
	return schema;
}

void CEnableScopeScansResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CEnableScopeScansResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
	info.addMinVersion("EnableScopeScansResponse","scopeScansStatus",1.08);
	if (!added.getValue("ScopeScanStatusStruct"))
	{
		added.setValue("ScopeScanStatusStruct",1);
		CScopeScanStatusStruct::getMapInfo(info,added);
	}
}

StringBuffer &CEnableScopeScansResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	if (!context.suppressed("EnableScopeScansResponse","scopeScansStatus")) {
		extfix.clear();
		if (prefix && *prefix)
			extfix.append(prefix).append(".");
		extfix.append("scopeScansStatus");
		form.append("<tr>").append("<td><b>scopeScansStatus: </b></td><td><hr/>");
		CScopeScanStatusStruct::getHtmlForm(context, request, serv, method, form, false, extfix.str());
		form.append("<hr/></td></tr>");
	}
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CEnableScopeScansResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CEnableScopeScansResponse::serialize(IRpcMessage& rpc_resp)
{
	IEspContext* ctx = rpc_resp.queryContext();
	double clientVer= ctx ? ctx->getClientVersion() : -1; /* no context gets everything */
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
		if ((clientVer==-1.0 || clientVer>=1.08))
			m_scopeScansStatus.marshall(rpc_resp, "scopeScansStatus", "", "", "");
	}
}


void CEnableScopeScansResponse::copy(CEnableScopeScansResponse &from)
{
	m_scopeScansStatus.copy(from.m_scopeScansStatus);
}


void CEnableScopeScansResponse::copy(IConstEnableScopeScansResponse &ifrom)
{
	setScopeScansStatus(ifrom.getScopeScansStatus());
}


void CEnableScopeScansResponse::getAttributes(IProperties &attributes)
{
}


void CEnableScopeScansResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
		double clientVer = ctx ? ctx->getClientVersion() : -1;
		if ((clientVer==-1.0 || clientVer>=1.08))
			m_scopeScansStatus.toStr(ctx, buffer, "scopeScansStatus", "", false, "", "");
	}
}


void CEnableScopeScansResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CEnableScopeScansResponse::serializer(IEspContext* ctx, IConstEnableScopeScansResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<EnableScopeScansResponse>");
	double clientVer = ctx ? ctx->getClientVersion() : -1;
	// field scopeScansStatus
	if ((clientVer==-1.0 || clientVer>=1.08))
	{
		StringBuffer tmp;
		CScopeScanStatusStruct::serializer(ctx,src.getScopeScansStatus(), tmp, false);
		if (tmp.length()>0)
			buffer.appendf("<scopeScansStatus>%s</scopeScansStatus>",tmp.str());
	}
	if (keepRootTag)
		buffer.append("</EnableScopeScansResponse>");
}

bool CEnableScopeScansResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
		hasValue |= m_scopeScansStatus.unmarshall(rpc_request, "scopeScansStatus", basepath);
	}
	return hasValue;
}

bool CEnableScopeScansResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_scopeScansStatus.unmarshall(ctx, soapval, "scopeScansStatus");
	return hasValue;
}

bool CEnableScopeScansResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_scopeScansStatus.unmarshall(ctx, params, attachments, "scopeScansStatus", basepath);
	return hasValue;
}

IConstScopeScanStatusStruct & CEnableScopeScansResponse::getScopeScansStatus() { return (IConstScopeScanStatusStruct &) m_scopeScansStatus.getValue();}
IEspScopeScanStatusStruct & CEnableScopeScansResponse::updateScopeScansStatus(){ return (IEspScopeScanStatusStruct &) m_scopeScansStatus.getValue(); }
void CEnableScopeScansResponse::setScopeScansStatus(IConstScopeScanStatusStruct &ifrom){ m_scopeScansStatus.copy(ifrom); }
extern "C"  IEspEnableScopeScansResponse *createEnableScopeScansResponse(const char *serv){return ((IEspEnableScopeScansResponse *)new CEnableScopeScansResponse(serv));}
extern "C"  IClientEnableScopeScansResponse *createClientEnableScopeScansResponse(const char *serv){return ((IClientEnableScopeScansResponse *)new CEnableScopeScansResponse(serv));}

//=======================================================
// class CDisableScopeScansRequest Implementation
//=======================================================

CDisableScopeScansRequest::CDisableScopeScansRequest(const char *serviceName, IRpcMessageBinding *init)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("DisableScopeScansRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CDisableScopeScansRequest::CDisableScopeScansRequest(const char *serviceName, const char *bc)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("DisableScopeScansRequest");
}

CDisableScopeScansRequest::CDisableScopeScansRequest(const char *serviceName, IRpcMessage* rpcmsg)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("DisableScopeScansRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CDisableScopeScansRequest::CDisableScopeScansRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("DisableScopeScansRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CDisableScopeScansRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType><xsd:all/></xsd:complexType></xsd:element>\n", msgTypeName);
		}
	}
	return schema;
}

void CDisableScopeScansRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CDisableScopeScansRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CDisableScopeScansRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CDisableScopeScansRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CDisableScopeScansRequest::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

}


void CDisableScopeScansRequest::copy(CDisableScopeScansRequest &from)
{
}


void CDisableScopeScansRequest::copy(IConstDisableScopeScansRequest &ifrom)
{
}


void CDisableScopeScansRequest::getAttributes(IProperties &attributes)
{
}


void CDisableScopeScansRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
}


void CDisableScopeScansRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CDisableScopeScansRequest::serializer(IEspContext* ctx, IConstDisableScopeScansRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<DisableScopeScansRequest>");
	if (keepRootTag)
		buffer.append("</DisableScopeScansRequest>");
}

bool CDisableScopeScansRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	return hasValue;
}

bool CDisableScopeScansRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	return hasValue;
}

bool CDisableScopeScansRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	return hasValue;
}

extern "C"  IEspDisableScopeScansRequest *createDisableScopeScansRequest(const char *serv){return ((IEspDisableScopeScansRequest *)new CDisableScopeScansRequest(serv));}
extern "C"  IClientDisableScopeScansRequest *createClientDisableScopeScansRequest(const char *serv){return ((IClientDisableScopeScansRequest *)new CDisableScopeScansRequest(serv));}

//=======================================================
// class CDisableScopeScansResponse Implementation
//=======================================================

CDisableScopeScansResponse::CDisableScopeScansResponse(const char *serviceName, IRpcMessageBinding *init)
	: m_scopeScansStatus(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("DisableScopeScansResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CDisableScopeScansResponse::CDisableScopeScansResponse(const char *serviceName, const char *bc)
	: m_scopeScansStatus(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("DisableScopeScansResponse");
}

CDisableScopeScansResponse::CDisableScopeScansResponse(const char *serviceName, IRpcMessage* rpcmsg)
	: m_scopeScansStatus(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("DisableScopeScansResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CDisableScopeScansResponse::CDisableScopeScansResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_scopeScansStatus(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("DisableScopeScansResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CDisableScopeScansResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		if (!context.suppressed("DisableScopeScansResponse","scopeScansStatus")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"scopeScansStatus\" type=\"tns:ScopeScanStatusStruct\"/>\n");
		}
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	if (!(flags & 0x10)  || (flags & 0x100))
	{
		if (!context.suppressed("DisableScopeScansResponse","scopeScansStatus"))
			CScopeScanStatusStruct::getXsdDefinition(context, request, schema, added);
	}
	return schema;
}

void CDisableScopeScansResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CDisableScopeScansResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
	info.addMinVersion("DisableScopeScansResponse","scopeScansStatus",1.08);
	if (!added.getValue("ScopeScanStatusStruct"))
	{
		added.setValue("ScopeScanStatusStruct",1);
		CScopeScanStatusStruct::getMapInfo(info,added);
	}
}

StringBuffer &CDisableScopeScansResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	if (!context.suppressed("DisableScopeScansResponse","scopeScansStatus")) {
		extfix.clear();
		if (prefix && *prefix)
			extfix.append(prefix).append(".");
		extfix.append("scopeScansStatus");
		form.append("<tr>").append("<td><b>scopeScansStatus: </b></td><td><hr/>");
		CScopeScanStatusStruct::getHtmlForm(context, request, serv, method, form, false, extfix.str());
		form.append("<hr/></td></tr>");
	}
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CDisableScopeScansResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CDisableScopeScansResponse::serialize(IRpcMessage& rpc_resp)
{
	IEspContext* ctx = rpc_resp.queryContext();
	double clientVer= ctx ? ctx->getClientVersion() : -1; /* no context gets everything */
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
		if ((clientVer==-1.0 || clientVer>=1.08))
			m_scopeScansStatus.marshall(rpc_resp, "scopeScansStatus", "", "", "");
	}
}


void CDisableScopeScansResponse::copy(CDisableScopeScansResponse &from)
{
	m_scopeScansStatus.copy(from.m_scopeScansStatus);
}


void CDisableScopeScansResponse::copy(IConstDisableScopeScansResponse &ifrom)
{
	setScopeScansStatus(ifrom.getScopeScansStatus());
}


void CDisableScopeScansResponse::getAttributes(IProperties &attributes)
{
}


void CDisableScopeScansResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
		double clientVer = ctx ? ctx->getClientVersion() : -1;
		if ((clientVer==-1.0 || clientVer>=1.08))
			m_scopeScansStatus.toStr(ctx, buffer, "scopeScansStatus", "", false, "", "");
	}
}


void CDisableScopeScansResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CDisableScopeScansResponse::serializer(IEspContext* ctx, IConstDisableScopeScansResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<DisableScopeScansResponse>");
	double clientVer = ctx ? ctx->getClientVersion() : -1;
	// field scopeScansStatus
	if ((clientVer==-1.0 || clientVer>=1.08))
	{
		StringBuffer tmp;
		CScopeScanStatusStruct::serializer(ctx,src.getScopeScansStatus(), tmp, false);
		if (tmp.length()>0)
			buffer.appendf("<scopeScansStatus>%s</scopeScansStatus>",tmp.str());
	}
	if (keepRootTag)
		buffer.append("</DisableScopeScansResponse>");
}

bool CDisableScopeScansResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
		hasValue |= m_scopeScansStatus.unmarshall(rpc_request, "scopeScansStatus", basepath);
	}
	return hasValue;
}

bool CDisableScopeScansResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_scopeScansStatus.unmarshall(ctx, soapval, "scopeScansStatus");
	return hasValue;
}

bool CDisableScopeScansResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_scopeScansStatus.unmarshall(ctx, params, attachments, "scopeScansStatus", basepath);
	return hasValue;
}

IConstScopeScanStatusStruct & CDisableScopeScansResponse::getScopeScansStatus() { return (IConstScopeScanStatusStruct &) m_scopeScansStatus.getValue();}
IEspScopeScanStatusStruct & CDisableScopeScansResponse::updateScopeScansStatus(){ return (IEspScopeScanStatusStruct &) m_scopeScansStatus.getValue(); }
void CDisableScopeScansResponse::setScopeScansStatus(IConstScopeScanStatusStruct &ifrom){ m_scopeScansStatus.copy(ifrom); }
extern "C"  IEspDisableScopeScansResponse *createDisableScopeScansResponse(const char *serv){return ((IEspDisableScopeScansResponse *)new CDisableScopeScansResponse(serv));}
extern "C"  IClientDisableScopeScansResponse *createClientDisableScopeScansResponse(const char *serv){return ((IClientDisableScopeScansResponse *)new CDisableScopeScansResponse(serv));}

//=======================================================
// class CPermissionActionRequest Implementation
//=======================================================

CPermissionActionRequest::CPermissionActionRequest(const char *serviceName, IRpcMessageBinding *init)
	: m_basedn(nilIgnore),m_rtype(nilIgnore),m_rname(nilIgnore),m_rtitle(nilIgnore),m_prefix(nilIgnore),m_action(nilIgnore),m_account_name(nilIgnore),m_account_type(nilIgnore),m_allow_access(nilIgnore),m_allow_read(nilIgnore),m_allow_write(nilIgnore),m_allow_full(nilIgnore),m_deny_access(nilIgnore),m_deny_read(nilIgnore),m_deny_write(nilIgnore),m_deny_full(nilIgnore),m_user(nilIgnore),m_group(nilIgnore),m_BasednName(nilIgnore),m_ResourceName(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("PermissionActionRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CPermissionActionRequest::CPermissionActionRequest(const char *serviceName, const char *bc)
	: m_basedn(nilIgnore),m_rtype(nilIgnore),m_rname(nilIgnore),m_rtitle(nilIgnore),m_prefix(nilIgnore),m_action(nilIgnore),m_account_name(nilIgnore),m_account_type(nilIgnore),m_allow_access(nilIgnore),m_allow_read(nilIgnore),m_allow_write(nilIgnore),m_allow_full(nilIgnore),m_deny_access(nilIgnore),m_deny_read(nilIgnore),m_deny_write(nilIgnore),m_deny_full(nilIgnore),m_user(nilIgnore),m_group(nilIgnore),m_BasednName(nilIgnore),m_ResourceName(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("PermissionActionRequest");
}

CPermissionActionRequest::CPermissionActionRequest(const char *serviceName, IRpcMessage* rpcmsg)
	: m_basedn(nilIgnore),m_rtype(nilIgnore),m_rname(nilIgnore),m_rtitle(nilIgnore),m_prefix(nilIgnore),m_action(nilIgnore),m_account_name(nilIgnore),m_account_type(nilIgnore),m_allow_access(nilIgnore),m_allow_read(nilIgnore),m_allow_write(nilIgnore),m_allow_full(nilIgnore),m_deny_access(nilIgnore),m_deny_read(nilIgnore),m_deny_write(nilIgnore),m_deny_full(nilIgnore),m_user(nilIgnore),m_group(nilIgnore),m_BasednName(nilIgnore),m_ResourceName(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("PermissionActionRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CPermissionActionRequest::CPermissionActionRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_basedn(nilIgnore),m_rtype(nilIgnore),m_rname(nilIgnore),m_rtitle(nilIgnore),m_prefix(nilIgnore),m_action(nilIgnore),m_account_name(nilIgnore),m_account_type(nilIgnore),m_allow_access(nilIgnore),m_allow_read(nilIgnore),m_allow_write(nilIgnore),m_allow_full(nilIgnore),m_deny_access(nilIgnore),m_deny_read(nilIgnore),m_deny_write(nilIgnore),m_deny_full(nilIgnore),m_user(nilIgnore),m_group(nilIgnore),m_BasednName(nilIgnore),m_ResourceName(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("PermissionActionRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CPermissionActionRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"basedn\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"rtype\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"rname\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"rtitle\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"prefix\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"action\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"account_name\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"account_type\" type=\"xsd:int\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"allow_access\" type=\"xsd:boolean\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"allow_read\" type=\"xsd:boolean\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"allow_write\" type=\"xsd:boolean\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"allow_full\" type=\"xsd:boolean\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"deny_access\" type=\"xsd:boolean\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"deny_read\" type=\"xsd:boolean\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"deny_write\" type=\"xsd:boolean\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"deny_full\" type=\"xsd:boolean\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"user\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"group\" type=\"xsd:string\"/>\n");
		if (!context.suppressed("PermissionActionRequest","BasednName")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"BasednName\" type=\"xsd:string\"/>\n");
		}
		if (!context.suppressed("PermissionActionRequest","ResourceName")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"ResourceName\" type=\"xsd:string\"/>\n");
		}
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CPermissionActionRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CPermissionActionRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
	info.addMinVersion("PermissionActionRequest","BasednName",1.01);
	info.addMinVersion("PermissionActionRequest","ResourceName",1.01);
}

StringBuffer &CPermissionActionRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("basedn");
	form.appendf("  <tr><td><b>basedn: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("rtype");
	form.appendf("  <tr><td><b>rtype: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("rname");
	form.appendf("  <tr><td><b>rname: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("rtitle");
	form.appendf("  <tr><td><b>rtitle: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("prefix");
	form.appendf("  <tr><td><b>prefix: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("action");
	form.appendf("  <tr><td><b>action: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("account_name");
	form.appendf("  <tr><td><b>account_name: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix) extfix.append(prefix).append(".");
		extfix.append("account_type");
	form.appendf("  <tr><td><b>account_type: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("allow_access");
	
	form.appendf("  <tr><td><b>allow_access? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("allow_read");
	
	form.appendf("  <tr><td><b>allow_read? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("allow_write");
	
	form.appendf("  <tr><td><b>allow_write? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("allow_full");
	
	form.appendf("  <tr><td><b>allow_full? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("deny_access");
	
	form.appendf("  <tr><td><b>deny_access? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("deny_read");
	
	form.appendf("  <tr><td><b>deny_read? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("deny_write");
	
	form.appendf("  <tr><td><b>deny_write? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("deny_full");
	
	form.appendf("  <tr><td><b>deny_full? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("user");
	form.appendf("  <tr><td><b>user: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("group");
	form.appendf("  <tr><td><b>group: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (!context.suppressed("PermissionActionRequest","BasednName")) {
		extfix.clear();
		if (prefix && *prefix)
			extfix.append(prefix).append(".");
		extfix.append("BasednName");
		form.appendf("  <tr><td><b>BasednName: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
		form.append("</td></tr>\n");
	}
	if (!context.suppressed("PermissionActionRequest","ResourceName")) {
		extfix.clear();
		if (prefix && *prefix)
			extfix.append(prefix).append(".");
		extfix.append("ResourceName");
		form.appendf("  <tr><td><b>ResourceName: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
		form.append("</td></tr>\n");
	}
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CPermissionActionRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CPermissionActionRequest::serialize(IRpcMessage& rpc_resp)
{
	IEspContext* ctx = rpc_resp.queryContext();
	double clientVer= ctx ? ctx->getClientVersion() : -1; /* no context gets everything */
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_basedn.marshall(rpc_resp, "basedn", "", "", "");
	m_rtype.marshall(rpc_resp, "rtype", "", "", "");
	m_rname.marshall(rpc_resp, "rname", "", "", "");
	m_rtitle.marshall(rpc_resp, "rtitle", "", "", "");
	m_prefix.marshall(rpc_resp, "prefix", "", "", "");
	m_action.marshall(rpc_resp, "action", "", "", "");
	m_account_name.marshall(rpc_resp, "account_name", "", "", "");
	m_account_type.marshall(rpc_resp, "account_type", "", "", "");
	m_allow_access.marshall(rpc_resp, "allow_access", "", "", "");
	m_allow_read.marshall(rpc_resp, "allow_read", "", "", "");
	m_allow_write.marshall(rpc_resp, "allow_write", "", "", "");
	m_allow_full.marshall(rpc_resp, "allow_full", "", "", "");
	m_deny_access.marshall(rpc_resp, "deny_access", "", "", "");
	m_deny_read.marshall(rpc_resp, "deny_read", "", "", "");
	m_deny_write.marshall(rpc_resp, "deny_write", "", "", "");
	m_deny_full.marshall(rpc_resp, "deny_full", "", "", "");
	m_user.marshall(rpc_resp, "user", "", "", "");
	m_group.marshall(rpc_resp, "group", "", "", "");
	if ((clientVer==-1.0 || clientVer>=1.01))
		m_BasednName.marshall(rpc_resp, "BasednName", "", "", "");
	if ((clientVer==-1.0 || clientVer>=1.01))
		m_ResourceName.marshall(rpc_resp, "ResourceName", "", "", "");
}


void CPermissionActionRequest::copy(CPermissionActionRequest &from)
{
	m_basedn.copy(from.m_basedn);
	m_rtype.copy(from.m_rtype);
	m_rname.copy(from.m_rname);
	m_rtitle.copy(from.m_rtitle);
	m_prefix.copy(from.m_prefix);
	m_action.copy(from.m_action);
	m_account_name.copy(from.m_account_name);
	m_account_type.copy(from.m_account_type);
	m_allow_access.copy(from.m_allow_access);
	m_allow_read.copy(from.m_allow_read);
	m_allow_write.copy(from.m_allow_write);
	m_allow_full.copy(from.m_allow_full);
	m_deny_access.copy(from.m_deny_access);
	m_deny_read.copy(from.m_deny_read);
	m_deny_write.copy(from.m_deny_write);
	m_deny_full.copy(from.m_deny_full);
	m_user.copy(from.m_user);
	m_group.copy(from.m_group);
	m_BasednName.copy(from.m_BasednName);
	m_ResourceName.copy(from.m_ResourceName);
}


void CPermissionActionRequest::copy(IConstPermissionActionRequest &ifrom)
{
	setBasedn(ifrom.getBasedn());
	setRtype(ifrom.getRtype());
	setRname(ifrom.getRname());
	setRtitle(ifrom.getRtitle());
	setPrefix(ifrom.getPrefix());
	setAction(ifrom.getAction());
	setAccount_name(ifrom.getAccount_name());
	setAccount_type(ifrom.getAccount_type());
	setAllow_access(ifrom.getAllow_access());
	setAllow_read(ifrom.getAllow_read());
	setAllow_write(ifrom.getAllow_write());
	setAllow_full(ifrom.getAllow_full());
	setDeny_access(ifrom.getDeny_access());
	setDeny_read(ifrom.getDeny_read());
	setDeny_write(ifrom.getDeny_write());
	setDeny_full(ifrom.getDeny_full());
	setUser(ifrom.getUser());
	setGroup(ifrom.getGroup());
	setBasednName(ifrom.getBasednName());
	setResourceName(ifrom.getResourceName());
}


void CPermissionActionRequest::getAttributes(IProperties &attributes)
{
}


void CPermissionActionRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	double clientVer = ctx ? ctx->getClientVersion() : -1;
	m_basedn.toStr(ctx, buffer, "basedn", "", true, "", "");
	m_rtype.toStr(ctx, buffer, "rtype", "", true, "", "");
	m_rname.toStr(ctx, buffer, "rname", "", true, "", "");
	m_rtitle.toStr(ctx, buffer, "rtitle", "", true, "", "");
	m_prefix.toStr(ctx, buffer, "prefix", "", true, "", "");
	m_action.toStr(ctx, buffer, "action", "", true, "", "");
	m_account_name.toStr(ctx, buffer, "account_name", "", true, "", "");
	m_account_type.toStr(ctx, buffer, "account_type", "", true, "", "");
	m_allow_access.toStr(ctx, buffer, "allow_access", "", true, "", "");
	m_allow_read.toStr(ctx, buffer, "allow_read", "", true, "", "");
	m_allow_write.toStr(ctx, buffer, "allow_write", "", true, "", "");
	m_allow_full.toStr(ctx, buffer, "allow_full", "", true, "", "");
	m_deny_access.toStr(ctx, buffer, "deny_access", "", true, "", "");
	m_deny_read.toStr(ctx, buffer, "deny_read", "", true, "", "");
	m_deny_write.toStr(ctx, buffer, "deny_write", "", true, "", "");
	m_deny_full.toStr(ctx, buffer, "deny_full", "", true, "", "");
	m_user.toStr(ctx, buffer, "user", "", true, "", "");
	m_group.toStr(ctx, buffer, "group", "", true, "", "");
	if ((clientVer==-1.0 || clientVer>=1.01))
		m_BasednName.toStr(ctx, buffer, "BasednName", "", true, "", "");
	if ((clientVer==-1.0 || clientVer>=1.01))
		m_ResourceName.toStr(ctx, buffer, "ResourceName", "", true, "", "");
}


void CPermissionActionRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CPermissionActionRequest::serializer(IEspContext* ctx, IConstPermissionActionRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<PermissionActionRequest>");
	double clientVer = ctx ? ctx->getClientVersion() : -1;
	// field basedn
	{
		const char* s = src.getBasedn();
		if (s && *s)
		{
			buffer.append("<basedn>");
			encodeUtf8XML(s,buffer);
			buffer.append("</basedn>");
		}
	}
	// field rtype
	{
		const char* s = src.getRtype();
		if (s && *s)
		{
			buffer.append("<rtype>");
			encodeUtf8XML(s,buffer);
			buffer.append("</rtype>");
		}
	}
	// field rname
	{
		const char* s = src.getRname();
		if (s && *s)
		{
			buffer.append("<rname>");
			encodeUtf8XML(s,buffer);
			buffer.append("</rname>");
		}
	}
	// field rtitle
	{
		const char* s = src.getRtitle();
		if (s && *s)
		{
			buffer.append("<rtitle>");
			encodeUtf8XML(s,buffer);
			buffer.append("</rtitle>");
		}
	}
	// field prefix
	{
		const char* s = src.getPrefix();
		if (s && *s)
		{
			buffer.append("<prefix>");
			encodeUtf8XML(s,buffer);
			buffer.append("</prefix>");
		}
	}
	// field action
	{
		const char* s = src.getAction();
		if (s && *s)
		{
			buffer.append("<action>");
			encodeUtf8XML(s,buffer);
			buffer.append("</action>");
		}
	}
	// field account_name
	{
		const char* s = src.getAccount_name();
		if (s && *s)
		{
			buffer.append("<account_name>");
			encodeUtf8XML(s,buffer);
			buffer.append("</account_name>");
		}
	}
	// field account_type
	{
		int n = src.getAccount_type();
		if (n)
			buffer.appendf("<account_type>%d</account_type>", n);
	}
	// field allow_access
	{
		bool b = src.getAllow_access();
		if (b)
			buffer.appendf("<allow_access>1</allow_access>");
	}
	// field allow_read
	{
		bool b = src.getAllow_read();
		if (b)
			buffer.appendf("<allow_read>1</allow_read>");
	}
	// field allow_write
	{
		bool b = src.getAllow_write();
		if (b)
			buffer.appendf("<allow_write>1</allow_write>");
	}
	// field allow_full
	{
		bool b = src.getAllow_full();
		if (b)
			buffer.appendf("<allow_full>1</allow_full>");
	}
	// field deny_access
	{
		bool b = src.getDeny_access();
		if (b)
			buffer.appendf("<deny_access>1</deny_access>");
	}
	// field deny_read
	{
		bool b = src.getDeny_read();
		if (b)
			buffer.appendf("<deny_read>1</deny_read>");
	}
	// field deny_write
	{
		bool b = src.getDeny_write();
		if (b)
			buffer.appendf("<deny_write>1</deny_write>");
	}
	// field deny_full
	{
		bool b = src.getDeny_full();
		if (b)
			buffer.appendf("<deny_full>1</deny_full>");
	}
	// field user
	{
		const char* s = src.getUser();
		if (s && *s)
		{
			buffer.append("<user>");
			encodeUtf8XML(s,buffer);
			buffer.append("</user>");
		}
	}
	// field group
	{
		const char* s = src.getGroup();
		if (s && *s)
		{
			buffer.append("<group>");
			encodeUtf8XML(s,buffer);
			buffer.append("</group>");
		}
	}
	// field BasednName
	if ((clientVer==-1.0 || clientVer>=1.01))
	{
		const char* s = src.getBasednName();
		if (s && *s)
		{
			buffer.append("<BasednName>");
			encodeUtf8XML(s,buffer);
			buffer.append("</BasednName>");
		}
	}
	// field ResourceName
	if ((clientVer==-1.0 || clientVer>=1.01))
	{
		const char* s = src.getResourceName();
		if (s && *s)
		{
			buffer.append("<ResourceName>");
			encodeUtf8XML(s,buffer);
			buffer.append("</ResourceName>");
		}
	}
	if (keepRootTag)
		buffer.append("</PermissionActionRequest>");
}

bool CPermissionActionRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_basedn.unmarshall(rpc_request, "basedn", basepath);
	hasValue |= m_rtype.unmarshall(rpc_request, "rtype", basepath);
	hasValue |= m_rname.unmarshall(rpc_request, "rname", basepath);
	hasValue |= m_rtitle.unmarshall(rpc_request, "rtitle", basepath);
	hasValue |= m_prefix.unmarshall(rpc_request, "prefix", basepath);
	hasValue |= m_action.unmarshall(rpc_request, "action", basepath);
	hasValue |= m_account_name.unmarshall(rpc_request, "account_name", basepath);
	hasValue |= m_account_type.unmarshall(rpc_request, "account_type", basepath);
	hasValue |= m_allow_access.unmarshall(rpc_request, "allow_access", basepath);
	hasValue |= m_allow_read.unmarshall(rpc_request, "allow_read", basepath);
	hasValue |= m_allow_write.unmarshall(rpc_request, "allow_write", basepath);
	hasValue |= m_allow_full.unmarshall(rpc_request, "allow_full", basepath);
	hasValue |= m_deny_access.unmarshall(rpc_request, "deny_access", basepath);
	hasValue |= m_deny_read.unmarshall(rpc_request, "deny_read", basepath);
	hasValue |= m_deny_write.unmarshall(rpc_request, "deny_write", basepath);
	hasValue |= m_deny_full.unmarshall(rpc_request, "deny_full", basepath);
	hasValue |= m_user.unmarshall(rpc_request, "user", basepath);
	hasValue |= m_group.unmarshall(rpc_request, "group", basepath);
	hasValue |= m_BasednName.unmarshall(rpc_request, "BasednName", basepath);
	hasValue |= m_ResourceName.unmarshall(rpc_request, "ResourceName", basepath);
	return hasValue;
}

bool CPermissionActionRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_basedn.unmarshall(ctx, soapval, "basedn");
	hasValue |= m_rtype.unmarshall(ctx, soapval, "rtype");
	hasValue |= m_rname.unmarshall(ctx, soapval, "rname");
	hasValue |= m_rtitle.unmarshall(ctx, soapval, "rtitle");
	hasValue |= m_prefix.unmarshall(ctx, soapval, "prefix");
	hasValue |= m_action.unmarshall(ctx, soapval, "action");
	hasValue |= m_account_name.unmarshall(ctx, soapval, "account_name");
	hasValue |= m_account_type.unmarshall(ctx, soapval, "account_type");
	hasValue |= m_allow_access.unmarshall(ctx, soapval, "allow_access");
	hasValue |= m_allow_read.unmarshall(ctx, soapval, "allow_read");
	hasValue |= m_allow_write.unmarshall(ctx, soapval, "allow_write");
	hasValue |= m_allow_full.unmarshall(ctx, soapval, "allow_full");
	hasValue |= m_deny_access.unmarshall(ctx, soapval, "deny_access");
	hasValue |= m_deny_read.unmarshall(ctx, soapval, "deny_read");
	hasValue |= m_deny_write.unmarshall(ctx, soapval, "deny_write");
	hasValue |= m_deny_full.unmarshall(ctx, soapval, "deny_full");
	hasValue |= m_user.unmarshall(ctx, soapval, "user");
	hasValue |= m_group.unmarshall(ctx, soapval, "group");
	hasValue |= m_BasednName.unmarshall(ctx, soapval, "BasednName");
	hasValue |= m_ResourceName.unmarshall(ctx, soapval, "ResourceName");
	return hasValue;
}

bool CPermissionActionRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_basedn.unmarshall(ctx, params, attachments, "basedn", basepath);
	hasValue |= m_rtype.unmarshall(ctx, params, attachments, "rtype", basepath);
	hasValue |= m_rname.unmarshall(ctx, params, attachments, "rname", basepath);
	hasValue |= m_rtitle.unmarshall(ctx, params, attachments, "rtitle", basepath);
	hasValue |= m_prefix.unmarshall(ctx, params, attachments, "prefix", basepath);
	hasValue |= m_action.unmarshall(ctx, params, attachments, "action", basepath);
	hasValue |= m_account_name.unmarshall(ctx, params, attachments, "account_name", basepath);
	hasValue |= m_account_type.unmarshall(ctx, params, attachments, "account_type", basepath);
	hasValue |= m_allow_access.unmarshall(ctx, params, attachments, "allow_access", basepath);
	hasValue |= m_allow_read.unmarshall(ctx, params, attachments, "allow_read", basepath);
	hasValue |= m_allow_write.unmarshall(ctx, params, attachments, "allow_write", basepath);
	hasValue |= m_allow_full.unmarshall(ctx, params, attachments, "allow_full", basepath);
	hasValue |= m_deny_access.unmarshall(ctx, params, attachments, "deny_access", basepath);
	hasValue |= m_deny_read.unmarshall(ctx, params, attachments, "deny_read", basepath);
	hasValue |= m_deny_write.unmarshall(ctx, params, attachments, "deny_write", basepath);
	hasValue |= m_deny_full.unmarshall(ctx, params, attachments, "deny_full", basepath);
	hasValue |= m_user.unmarshall(ctx, params, attachments, "user", basepath);
	hasValue |= m_group.unmarshall(ctx, params, attachments, "group", basepath);
	hasValue |= m_BasednName.unmarshall(ctx, params, attachments, "BasednName", basepath);
	hasValue |= m_ResourceName.unmarshall(ctx, params, attachments, "ResourceName", basepath);
	return hasValue;
}

const char * CPermissionActionRequest::getBasedn() { return m_basedn.query();}
const char * CPermissionActionRequest::getRtype() { return m_rtype.query();}
const char * CPermissionActionRequest::getRname() { return m_rname.query();}
const char * CPermissionActionRequest::getRtitle() { return m_rtitle.query();}
const char * CPermissionActionRequest::getPrefix() { return m_prefix.query();}
const char * CPermissionActionRequest::getAction() { return m_action.query();}
const char * CPermissionActionRequest::getAccount_name() { return m_account_name.query();}
int CPermissionActionRequest::getAccount_type() { return m_account_type;}
bool CPermissionActionRequest::getAllow_access() { return m_allow_access;}
bool CPermissionActionRequest::getAllow_read() { return m_allow_read;}
bool CPermissionActionRequest::getAllow_write() { return m_allow_write;}
bool CPermissionActionRequest::getAllow_full() { return m_allow_full;}
bool CPermissionActionRequest::getDeny_access() { return m_deny_access;}
bool CPermissionActionRequest::getDeny_read() { return m_deny_read;}
bool CPermissionActionRequest::getDeny_write() { return m_deny_write;}
bool CPermissionActionRequest::getDeny_full() { return m_deny_full;}
const char * CPermissionActionRequest::getUser() { return m_user.query();}
const char * CPermissionActionRequest::getGroup() { return m_group.query();}
const char * CPermissionActionRequest::getBasednName() { return m_BasednName.query();}
const char * CPermissionActionRequest::getResourceName() { return m_ResourceName.query();}
void CPermissionActionRequest::setBasedn(const char * val){ m_basedn.set(val); }
void CPermissionActionRequest::setRtype(const char * val){ m_rtype.set(val); }
void CPermissionActionRequest::setRname(const char * val){ m_rname.set(val); }
void CPermissionActionRequest::setRtitle(const char * val){ m_rtitle.set(val); }
void CPermissionActionRequest::setPrefix(const char * val){ m_prefix.set(val); }
void CPermissionActionRequest::setAction(const char * val){ m_action.set(val); }
void CPermissionActionRequest::setAccount_name(const char * val){ m_account_name.set(val); }
void CPermissionActionRequest::setAccount_type(int val){ m_account_type=val; }
void CPermissionActionRequest::setAllow_access(bool val){ m_allow_access=val; }
void CPermissionActionRequest::setAllow_read(bool val){ m_allow_read=val; }
void CPermissionActionRequest::setAllow_write(bool val){ m_allow_write=val; }
void CPermissionActionRequest::setAllow_full(bool val){ m_allow_full=val; }
void CPermissionActionRequest::setDeny_access(bool val){ m_deny_access=val; }
void CPermissionActionRequest::setDeny_read(bool val){ m_deny_read=val; }
void CPermissionActionRequest::setDeny_write(bool val){ m_deny_write=val; }
void CPermissionActionRequest::setDeny_full(bool val){ m_deny_full=val; }
void CPermissionActionRequest::setUser(const char * val){ m_user.set(val); }
void CPermissionActionRequest::setGroup(const char * val){ m_group.set(val); }
void CPermissionActionRequest::setBasednName(const char * val){ m_BasednName.set(val); }
void CPermissionActionRequest::setResourceName(const char * val){ m_ResourceName.set(val); }
extern "C"  IEspPermissionActionRequest *createPermissionActionRequest(const char *serv){return ((IEspPermissionActionRequest *)new CPermissionActionRequest(serv));}
extern "C"  IClientPermissionActionRequest *createClientPermissionActionRequest(const char *serv){return ((IClientPermissionActionRequest *)new CPermissionActionRequest(serv));}

//=======================================================
// class CPermissionActionResponse Implementation
//=======================================================

CPermissionActionResponse::CPermissionActionResponse(const char *serviceName, IRpcMessageBinding *init)
	: m_basedn(nilIgnore),m_rtype(nilIgnore),m_rname(nilIgnore),m_rtitle(nilIgnore),m_prefix(nilIgnore),m_AccountName(nilIgnore),m_IsGroup(nilIgnore),m_retcode(nilIgnore),m_retmsg(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("PermissionActionResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CPermissionActionResponse::CPermissionActionResponse(const char *serviceName, const char *bc)
	: m_basedn(nilIgnore),m_rtype(nilIgnore),m_rname(nilIgnore),m_rtitle(nilIgnore),m_prefix(nilIgnore),m_AccountName(nilIgnore),m_IsGroup(nilIgnore),m_retcode(nilIgnore),m_retmsg(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("PermissionActionResponse");
}

CPermissionActionResponse::CPermissionActionResponse(const char *serviceName, IRpcMessage* rpcmsg)
	: m_basedn(nilIgnore),m_rtype(nilIgnore),m_rname(nilIgnore),m_rtitle(nilIgnore),m_prefix(nilIgnore),m_AccountName(nilIgnore),m_IsGroup(nilIgnore),m_retcode(nilIgnore),m_retmsg(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("PermissionActionResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CPermissionActionResponse::CPermissionActionResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_basedn(nilIgnore),m_rtype(nilIgnore),m_rname(nilIgnore),m_rtitle(nilIgnore),m_prefix(nilIgnore),m_AccountName(nilIgnore),m_IsGroup(nilIgnore),m_retcode(nilIgnore),m_retmsg(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("PermissionActionResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CPermissionActionResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"basedn\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"rtype\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"rname\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"rtitle\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"prefix\" type=\"xsd:string\"/>\n");
		if (!context.suppressed("PermissionActionResponse","AccountName")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"AccountName\" type=\"xsd:string\"/>\n");
		}
		if (!context.suppressed("PermissionActionResponse","IsGroup")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"IsGroup\" type=\"xsd:boolean\"/>\n");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"retcode\" type=\"xsd:int\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"retmsg\" type=\"xsd:string\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CPermissionActionResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CPermissionActionResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
	info.addMinVersion("PermissionActionResponse","AccountName",1.01);
	info.addMinVersion("PermissionActionResponse","IsGroup",1.01);
}

StringBuffer &CPermissionActionResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("basedn");
	form.appendf("  <tr><td><b>basedn: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("rtype");
	form.appendf("  <tr><td><b>rtype: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("rname");
	form.appendf("  <tr><td><b>rname: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("rtitle");
	form.appendf("  <tr><td><b>rtitle: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("prefix");
	form.appendf("  <tr><td><b>prefix: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (!context.suppressed("PermissionActionResponse","AccountName")) {
		extfix.clear();
		if (prefix && *prefix)
			extfix.append(prefix).append(".");
		extfix.append("AccountName");
		form.appendf("  <tr><td><b>AccountName: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
		form.append("</td></tr>\n");
	}
	if (!context.suppressed("PermissionActionResponse","IsGroup")) {
		extfix.clear();
		if (prefix && *prefix)
			extfix.append(prefix).append(".");
		extfix.append("IsGroup");
		
	form.appendf("  <tr><td><b>IsGroup? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	}
	extfix.clear();
	if (prefix && *prefix) extfix.append(prefix).append(".");
		extfix.append("retcode");
	form.appendf("  <tr><td><b>retcode: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("retmsg");
	form.appendf("  <tr><td><b>retmsg: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CPermissionActionResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CPermissionActionResponse::serialize(IRpcMessage& rpc_resp)
{
	IEspContext* ctx = rpc_resp.queryContext();
	double clientVer= ctx ? ctx->getClientVersion() : -1; /* no context gets everything */
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
		m_basedn.marshall(rpc_resp, "basedn", "", "", "");
		m_rtype.marshall(rpc_resp, "rtype", "", "", "");
		m_rname.marshall(rpc_resp, "rname", "", "", "");
		m_rtitle.marshall(rpc_resp, "rtitle", "", "", "");
		m_prefix.marshall(rpc_resp, "prefix", "", "", "");
		if ((clientVer==-1.0 || clientVer>=1.01))
			m_AccountName.marshall(rpc_resp, "AccountName", "", "", "");
		if ((clientVer==-1.0 || clientVer>=1.01))
			m_IsGroup.marshall(rpc_resp, "IsGroup", "", "", "");
		m_retcode.marshall(rpc_resp, "retcode", "", "", "");
		m_retmsg.marshall(rpc_resp, "retmsg", "", "", "");
	}
}


void CPermissionActionResponse::copy(CPermissionActionResponse &from)
{
	m_basedn.copy(from.m_basedn);
	m_rtype.copy(from.m_rtype);
	m_rname.copy(from.m_rname);
	m_rtitle.copy(from.m_rtitle);
	m_prefix.copy(from.m_prefix);
	m_AccountName.copy(from.m_AccountName);
	m_IsGroup.copy(from.m_IsGroup);
	m_retcode.copy(from.m_retcode);
	m_retmsg.copy(from.m_retmsg);
}


void CPermissionActionResponse::copy(IConstPermissionActionResponse &ifrom)
{
	setBasedn(ifrom.getBasedn());
	setRtype(ifrom.getRtype());
	setRname(ifrom.getRname());
	setRtitle(ifrom.getRtitle());
	setPrefix(ifrom.getPrefix());
	setAccountName(ifrom.getAccountName());
	setIsGroup(ifrom.getIsGroup());
	setRetcode(ifrom.getRetcode());
	setRetmsg(ifrom.getRetmsg());
}


void CPermissionActionResponse::getAttributes(IProperties &attributes)
{
}


void CPermissionActionResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
		double clientVer = ctx ? ctx->getClientVersion() : -1;
		m_basedn.toStr(ctx, buffer, "basedn", "", true, "", "");
		m_rtype.toStr(ctx, buffer, "rtype", "", true, "", "");
		m_rname.toStr(ctx, buffer, "rname", "", true, "", "");
		m_rtitle.toStr(ctx, buffer, "rtitle", "", true, "", "");
		m_prefix.toStr(ctx, buffer, "prefix", "", true, "", "");
		if ((clientVer==-1.0 || clientVer>=1.01))
			m_AccountName.toStr(ctx, buffer, "AccountName", "", true, "", "");
		if ((clientVer==-1.0 || clientVer>=1.01))
			m_IsGroup.toStr(ctx, buffer, "IsGroup", "", true, "", "");
		m_retcode.toStr(ctx, buffer, "retcode", "", true, "", "");
		m_retmsg.toStr(ctx, buffer, "retmsg", "", true, "", "");
	}
}


void CPermissionActionResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CPermissionActionResponse::serializer(IEspContext* ctx, IConstPermissionActionResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<PermissionActionResponse>");
	double clientVer = ctx ? ctx->getClientVersion() : -1;
	// field basedn
	{
		const char* s = src.getBasedn();
		if (s && *s)
		{
			buffer.append("<basedn>");
			encodeUtf8XML(s,buffer);
			buffer.append("</basedn>");
		}
	}
	// field rtype
	{
		const char* s = src.getRtype();
		if (s && *s)
		{
			buffer.append("<rtype>");
			encodeUtf8XML(s,buffer);
			buffer.append("</rtype>");
		}
	}
	// field rname
	{
		const char* s = src.getRname();
		if (s && *s)
		{
			buffer.append("<rname>");
			encodeUtf8XML(s,buffer);
			buffer.append("</rname>");
		}
	}
	// field rtitle
	{
		const char* s = src.getRtitle();
		if (s && *s)
		{
			buffer.append("<rtitle>");
			encodeUtf8XML(s,buffer);
			buffer.append("</rtitle>");
		}
	}
	// field prefix
	{
		const char* s = src.getPrefix();
		if (s && *s)
		{
			buffer.append("<prefix>");
			encodeUtf8XML(s,buffer);
			buffer.append("</prefix>");
		}
	}
	// field AccountName
	if ((clientVer==-1.0 || clientVer>=1.01))
	{
		const char* s = src.getAccountName();
		if (s && *s)
		{
			buffer.append("<AccountName>");
			encodeUtf8XML(s,buffer);
			buffer.append("</AccountName>");
		}
	}
	// field IsGroup
	if ((clientVer==-1.0 || clientVer>=1.01))
	{
		bool b = src.getIsGroup();
		if (b)
			buffer.appendf("<IsGroup>1</IsGroup>");
	}
	// field retcode
	{
		int n = src.getRetcode();
		if (n)
			buffer.appendf("<retcode>%d</retcode>", n);
	}
	// field retmsg
	{
		const char* s = src.getRetmsg();
		if (s && *s)
		{
			buffer.append("<retmsg>");
			encodeUtf8XML(s,buffer);
			buffer.append("</retmsg>");
		}
	}
	if (keepRootTag)
		buffer.append("</PermissionActionResponse>");
}

bool CPermissionActionResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
		hasValue |= m_basedn.unmarshall(rpc_request, "basedn", basepath);
		hasValue |= m_rtype.unmarshall(rpc_request, "rtype", basepath);
		hasValue |= m_rname.unmarshall(rpc_request, "rname", basepath);
		hasValue |= m_rtitle.unmarshall(rpc_request, "rtitle", basepath);
		hasValue |= m_prefix.unmarshall(rpc_request, "prefix", basepath);
		hasValue |= m_AccountName.unmarshall(rpc_request, "AccountName", basepath);
		hasValue |= m_IsGroup.unmarshall(rpc_request, "IsGroup", basepath);
		hasValue |= m_retcode.unmarshall(rpc_request, "retcode", basepath);
		hasValue |= m_retmsg.unmarshall(rpc_request, "retmsg", basepath);
	}
	return hasValue;
}

bool CPermissionActionResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_basedn.unmarshall(ctx, soapval, "basedn");
	hasValue |= m_rtype.unmarshall(ctx, soapval, "rtype");
	hasValue |= m_rname.unmarshall(ctx, soapval, "rname");
	hasValue |= m_rtitle.unmarshall(ctx, soapval, "rtitle");
	hasValue |= m_prefix.unmarshall(ctx, soapval, "prefix");
	hasValue |= m_AccountName.unmarshall(ctx, soapval, "AccountName");
	hasValue |= m_IsGroup.unmarshall(ctx, soapval, "IsGroup");
	hasValue |= m_retcode.unmarshall(ctx, soapval, "retcode");
	hasValue |= m_retmsg.unmarshall(ctx, soapval, "retmsg");
	return hasValue;
}

bool CPermissionActionResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_basedn.unmarshall(ctx, params, attachments, "basedn", basepath);
	hasValue |= m_rtype.unmarshall(ctx, params, attachments, "rtype", basepath);
	hasValue |= m_rname.unmarshall(ctx, params, attachments, "rname", basepath);
	hasValue |= m_rtitle.unmarshall(ctx, params, attachments, "rtitle", basepath);
	hasValue |= m_prefix.unmarshall(ctx, params, attachments, "prefix", basepath);
	hasValue |= m_AccountName.unmarshall(ctx, params, attachments, "AccountName", basepath);
	hasValue |= m_IsGroup.unmarshall(ctx, params, attachments, "IsGroup", basepath);
	hasValue |= m_retcode.unmarshall(ctx, params, attachments, "retcode", basepath);
	hasValue |= m_retmsg.unmarshall(ctx, params, attachments, "retmsg", basepath);
	return hasValue;
}

const char * CPermissionActionResponse::getBasedn() { return m_basedn.query();}
const char * CPermissionActionResponse::getRtype() { return m_rtype.query();}
const char * CPermissionActionResponse::getRname() { return m_rname.query();}
const char * CPermissionActionResponse::getRtitle() { return m_rtitle.query();}
const char * CPermissionActionResponse::getPrefix() { return m_prefix.query();}
const char * CPermissionActionResponse::getAccountName() { return m_AccountName.query();}
bool CPermissionActionResponse::getIsGroup() { return m_IsGroup;}
int CPermissionActionResponse::getRetcode() { return m_retcode;}
const char * CPermissionActionResponse::getRetmsg() { return m_retmsg.query();}
void CPermissionActionResponse::setBasedn(const char * val){ m_basedn.set(val); }
void CPermissionActionResponse::setRtype(const char * val){ m_rtype.set(val); }
void CPermissionActionResponse::setRname(const char * val){ m_rname.set(val); }
void CPermissionActionResponse::setRtitle(const char * val){ m_rtitle.set(val); }
void CPermissionActionResponse::setPrefix(const char * val){ m_prefix.set(val); }
void CPermissionActionResponse::setAccountName(const char * val){ m_AccountName.set(val); }
void CPermissionActionResponse::setIsGroup(bool val){ m_IsGroup=val; }
void CPermissionActionResponse::setRetcode(int val){ m_retcode=val; }
void CPermissionActionResponse::setRetmsg(const char * val){ m_retmsg.set(val); }
extern "C"  IEspPermissionActionResponse *createPermissionActionResponse(const char *serv){return ((IEspPermissionActionResponse *)new CPermissionActionResponse(serv));}
extern "C"  IClientPermissionActionResponse *createClientPermissionActionResponse(const char *serv){return ((IClientPermissionActionResponse *)new CPermissionActionResponse(serv));}

//=======================================================
// class CAccountPermissionsRequest Implementation
//=======================================================

CAccountPermissionsRequest::CAccountPermissionsRequest(const char *serviceName, IRpcMessageBinding *init)
	: m_AccountName(nilIgnore),m_IsGroup(nilIgnore),m_IncludeGroup(0, nilIgnore,false)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("AccountPermissionsRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CAccountPermissionsRequest::CAccountPermissionsRequest(const char *serviceName, const char *bc)
	: m_AccountName(nilIgnore),m_IsGroup(nilIgnore),m_IncludeGroup(0, nilIgnore,false)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("AccountPermissionsRequest");
}

CAccountPermissionsRequest::CAccountPermissionsRequest(const char *serviceName, IRpcMessage* rpcmsg)
	: m_AccountName(nilIgnore),m_IsGroup(nilIgnore),m_IncludeGroup(0, nilIgnore,false)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("AccountPermissionsRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CAccountPermissionsRequest::CAccountPermissionsRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_AccountName(nilIgnore),m_IsGroup(nilIgnore),m_IncludeGroup(0, nilIgnore,false)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("AccountPermissionsRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CAccountPermissionsRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"AccountName\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"IsGroup\" type=\"xsd:boolean\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" default=\"false\" name=\"IncludeGroup\" type=\"xsd:boolean\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CAccountPermissionsRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CAccountPermissionsRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CAccountPermissionsRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("AccountName");
	form.appendf("  <tr><td><b>AccountName: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("IsGroup");
	
	form.appendf("  <tr><td><b>IsGroup? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("IncludeGroup");
	
	form.appendf("  <tr><td><b>IncludeGroup? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CAccountPermissionsRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CAccountPermissionsRequest::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_AccountName.marshall(rpc_resp, "AccountName", "", "", "");
	m_IsGroup.marshall(rpc_resp, "IsGroup", "", "", "");
	m_IncludeGroup.marshall(rpc_resp, "IncludeGroup", "", "", "");
}


void CAccountPermissionsRequest::copy(CAccountPermissionsRequest &from)
{
	m_AccountName.copy(from.m_AccountName);
	m_IsGroup.copy(from.m_IsGroup);
	m_IncludeGroup.copy(from.m_IncludeGroup);
}


void CAccountPermissionsRequest::copy(IConstAccountPermissionsRequest &ifrom)
{
	setAccountName(ifrom.getAccountName());
	setIsGroup(ifrom.getIsGroup());
	setIncludeGroup(ifrom.getIncludeGroup());
}


void CAccountPermissionsRequest::getAttributes(IProperties &attributes)
{
}


void CAccountPermissionsRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_AccountName.toStr(ctx, buffer, "AccountName", "", true, "", "");
	m_IsGroup.toStr(ctx, buffer, "IsGroup", "", true, "", "");
	m_IncludeGroup.toStr(ctx, buffer, "IncludeGroup", "", true, "", "");
}


void CAccountPermissionsRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CAccountPermissionsRequest::serializer(IEspContext* ctx, IConstAccountPermissionsRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<AccountPermissionsRequest>");
	// field AccountName
	{
		const char* s = src.getAccountName();
		if (s && *s)
		{
			buffer.append("<AccountName>");
			encodeUtf8XML(s,buffer);
			buffer.append("</AccountName>");
		}
	}
	// field IsGroup
	{
		bool b = src.getIsGroup();
		if (b)
			buffer.appendf("<IsGroup>1</IsGroup>");
	}
	// field IncludeGroup
	{
		bool b = src.getIncludeGroup();
		if (b)
			buffer.appendf("<IncludeGroup>1</IncludeGroup>");
	}
	if (keepRootTag)
		buffer.append("</AccountPermissionsRequest>");
}

bool CAccountPermissionsRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_AccountName.unmarshall(rpc_request, "AccountName", basepath);
	hasValue |= m_IsGroup.unmarshall(rpc_request, "IsGroup", basepath);
	hasValue |= m_IncludeGroup.unmarshall(rpc_request, "IncludeGroup", basepath);
	return hasValue;
}

bool CAccountPermissionsRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_AccountName.unmarshall(ctx, soapval, "AccountName");
	hasValue |= m_IsGroup.unmarshall(ctx, soapval, "IsGroup");
	hasValue |= m_IncludeGroup.unmarshall(ctx, soapval, "IncludeGroup");
	return hasValue;
}

bool CAccountPermissionsRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_AccountName.unmarshall(ctx, params, attachments, "AccountName", basepath);
	hasValue |= m_IsGroup.unmarshall(ctx, params, attachments, "IsGroup", basepath);
	hasValue |= m_IncludeGroup.unmarshall(ctx, params, attachments, "IncludeGroup", basepath);
	return hasValue;
}

const char * CAccountPermissionsRequest::getAccountName() { return m_AccountName.query();}
bool CAccountPermissionsRequest::getIsGroup() { return m_IsGroup;}
bool CAccountPermissionsRequest::getIncludeGroup() { return m_IncludeGroup;}
void CAccountPermissionsRequest::setAccountName(const char * val){ m_AccountName.set(val); }
void CAccountPermissionsRequest::setIsGroup(bool val){ m_IsGroup=val; }
void CAccountPermissionsRequest::setIncludeGroup(bool val){ m_IncludeGroup=val; }
extern "C"  IEspAccountPermissionsRequest *createAccountPermissionsRequest(const char *serv){return ((IEspAccountPermissionsRequest *)new CAccountPermissionsRequest(serv));}
extern "C"  IClientAccountPermissionsRequest *createClientAccountPermissionsRequest(const char *serv){return ((IClientAccountPermissionsRequest *)new CAccountPermissionsRequest(serv));}

//=======================================================
// class CAccountPermissionsResponse Implementation
//=======================================================

CAccountPermissionsResponse::CAccountPermissionsResponse(const char *serviceName, IRpcMessageBinding *init)
	: m_AccountName(nilIgnore),m_IsGroup(nilIgnore),m_IncludeGroup(nilIgnore),m_BasednNames(nilIgnore),m_Permissions(nilIgnore),m_GroupPermissions(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("AccountPermissionsResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CAccountPermissionsResponse::CAccountPermissionsResponse(const char *serviceName, const char *bc)
	: m_AccountName(nilIgnore),m_IsGroup(nilIgnore),m_IncludeGroup(nilIgnore),m_BasednNames(nilIgnore),m_Permissions(nilIgnore),m_GroupPermissions(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("AccountPermissionsResponse");
}

CAccountPermissionsResponse::CAccountPermissionsResponse(const char *serviceName, IRpcMessage* rpcmsg)
	: m_AccountName(nilIgnore),m_IsGroup(nilIgnore),m_IncludeGroup(nilIgnore),m_BasednNames(nilIgnore),m_Permissions(nilIgnore),m_GroupPermissions(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("AccountPermissionsResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CAccountPermissionsResponse::CAccountPermissionsResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_AccountName(nilIgnore),m_IsGroup(nilIgnore),m_IncludeGroup(nilIgnore),m_BasednNames(nilIgnore),m_Permissions(nilIgnore),m_GroupPermissions(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("AccountPermissionsResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CAccountPermissionsResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"AccountName\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"IsGroup\" type=\"xsd:boolean\"/>\n");
		if (!context.suppressed("AccountPermissionsResponse","IncludeGroup")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"IncludeGroup\" type=\"xsd:boolean\"/>\n");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"BasednNames\" type=\"tns:EspStringArray\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Permissions\">\n");
		schema.append("<xsd:complexType><xsd:sequence>\n");
		schema.append("<xsd:element minOccurs=\"0\" maxOccurs=\"unbounded\" name=\"Permission\" type=\"tns:AccountPermission\"/>");
		schema.append("</xsd:sequence></xsd:complexType>");
		schema.append("</xsd:element>");
		if (!context.suppressed("AccountPermissionsResponse","GroupPermissions")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"GroupPermissions\">\n");
			schema.append("<xsd:complexType><xsd:sequence>\n");
			schema.append("<xsd:element minOccurs=\"0\" maxOccurs=\"unbounded\" name=\"GroupPermission\" type=\"tns:GroupAccountPermission\"/>");
			schema.append("</xsd:sequence></xsd:complexType>");
			schema.append("</xsd:element>");
		}
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	if (!(flags & 0x10)  || (flags & 0x100))
	{
		CAccountPermission::getXsdDefinition(context, request, schema, added);
		if (!context.suppressed("AccountPermissionsResponse","GroupPermissions"))
			CGroupAccountPermission::getXsdDefinition(context, request, schema, added);
	}
	if (added.getValue("EspStringArray")==NULL) {
		addEspNativeArray(schema,"string","EspStringArray");
		added.setValue("EspStringArray",1);
	}
	return schema;
}

void CAccountPermissionsResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CAccountPermissionsResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
	info.addMinVersion("AccountPermissionsResponse","IncludeGroup",1.03);
	info.addMinVersion("AccountPermissionsResponse","GroupPermissions",1.03);
	if (!added.getValue("AccountPermission"))
	{
		added.setValue("AccountPermission",1);
		CAccountPermission::getMapInfo(info,added);
	}
	if (!added.getValue("GroupAccountPermission"))
	{
		added.setValue("GroupAccountPermission",1);
		CGroupAccountPermission::getMapInfo(info,added);
	}
}

StringBuffer &CAccountPermissionsResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("AccountName");
	form.appendf("  <tr><td><b>AccountName: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("IsGroup");
	
	form.appendf("  <tr><td><b>IsGroup? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	if (!context.suppressed("AccountPermissionsResponse","IncludeGroup")) {
		extfix.clear();
		if (prefix && *prefix)
			extfix.append(prefix).append(".");
		extfix.append("IncludeGroup");
		
	form.appendf("  <tr><td><b>IncludeGroup? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	}
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("BasednNames");
	form.appendf("<tr><td><b>BasednNames: </b></td><td>");
	form.appendf("<textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea>", extfix.str());
	form.append("</td></tr>");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Permissions");
	form.appendf("<tr><td><b>Permissions: </b></td><td>");
	form.appendf("<table><tr><td><textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea></td>", extfix.str());
	form.append("</tr></table>");
	form.append("</td></tr>");
	if (!context.suppressed("AccountPermissionsResponse","GroupPermissions")) {
		extfix.clear();
		if (prefix && *prefix)
			extfix.append(prefix).append(".");
		extfix.append("GroupPermissions");
		form.appendf("<tr><td><b>GroupPermissions: </b></td><td>");
		form.appendf("<table><tr><td><textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea></td>", extfix.str());
		form.append("</tr></table>");
		form.append("</td></tr>");
	}
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CAccountPermissionsResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CAccountPermissionsResponse::serialize(IRpcMessage& rpc_resp)
{
	IEspContext* ctx = rpc_resp.queryContext();
	double clientVer= ctx ? ctx->getClientVersion() : -1; /* no context gets everything */
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
		m_AccountName.marshall(rpc_resp, "AccountName", "", "", "");
		m_IsGroup.marshall(rpc_resp, "IsGroup", "", "", "");
		if ((clientVer==-1.0 || clientVer>=1.03))
			m_IncludeGroup.marshall(rpc_resp, "IncludeGroup", "", "", "");
		m_BasednNames.marshall(rpc_resp, "BasednNames", "Item");
		m_Permissions.marshall(rpc_resp, "Permissions", "Permission");
		if ((clientVer==-1.0 || clientVer>=1.03))
			m_GroupPermissions.marshall(rpc_resp, "GroupPermissions", "GroupPermission");
	}
}


void CAccountPermissionsResponse::copy(CAccountPermissionsResponse &from)
{
	m_AccountName.copy(from.m_AccountName);
	m_IsGroup.copy(from.m_IsGroup);
	m_IncludeGroup.copy(from.m_IncludeGroup);
	m_BasednNames.copy(from.m_BasednNames);
	m_Permissions.copy(from.m_Permissions);
	m_GroupPermissions.copy(from.m_GroupPermissions);
}


void CAccountPermissionsResponse::copy(IConstAccountPermissionsResponse &ifrom)
{
	setAccountName(ifrom.getAccountName());
	setIsGroup(ifrom.getIsGroup());
	setIncludeGroup(ifrom.getIncludeGroup());
	setBasednNames(ifrom.getBasednNames());
	setPermissions(ifrom.getPermissions());
	setGroupPermissions(ifrom.getGroupPermissions());
}


void CAccountPermissionsResponse::getAttributes(IProperties &attributes)
{
}


void CAccountPermissionsResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
		double clientVer = ctx ? ctx->getClientVersion() : -1;
		m_AccountName.toStr(ctx, buffer, "AccountName", "", true, "", "");
		m_IsGroup.toStr(ctx, buffer, "IsGroup", "", true, "", "");
		if ((clientVer==-1.0 || clientVer>=1.03))
			m_IncludeGroup.toStr(ctx, buffer, "IncludeGroup", "", true, "", "");
		m_BasednNames.toStr(ctx, buffer, "BasednNames", "Item");
		m_Permissions.toStr(ctx, buffer, "Permissions", "Permission");
		if ((clientVer==-1.0 || clientVer>=1.03))
			m_GroupPermissions.toStr(ctx, buffer, "GroupPermissions", "GroupPermission");
	}
}


void CAccountPermissionsResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CAccountPermissionsResponse::serializer(IEspContext* ctx, IConstAccountPermissionsResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<AccountPermissionsResponse>");
	double clientVer = ctx ? ctx->getClientVersion() : -1;
	// field AccountName
	{
		const char* s = src.getAccountName();
		if (s && *s)
		{
			buffer.append("<AccountName>");
			encodeUtf8XML(s,buffer);
			buffer.append("</AccountName>");
		}
	}
	// field IsGroup
	{
		bool b = src.getIsGroup();
		if (b)
			buffer.appendf("<IsGroup>1</IsGroup>");
	}
	// field IncludeGroup
	if ((clientVer==-1.0 || clientVer>=1.03))
	{
		bool b = src.getIncludeGroup();
		if (b)
			buffer.appendf("<IncludeGroup>1</IncludeGroup>");
	}
	// field BasednNames
	{
		StringArray& v = src.getBasednNames();
		if (v.length()>0)
			buffer.append("<BasednNames>");
		for (size32_t i=0;i<v.length();i++)
			buffer.appendf("<Item>%s</Item>",v.item(i));
		if (v.length()>0)
			buffer.append("</BasednNames>");
	}
	// field Permissions
	{
		IArrayOf<IConstAccountPermission>& v = src.getPermissions();
		int size = v.length();
		if (size>0)
			buffer.append("<Permissions>");
		for (int i=0;i<size;i++)
		{
			buffer.append("<Permission>");
			CAccountPermission::serializer(ctx,v.item(i),buffer,false);
			buffer.append("</Permission>");
		}
		if (size>0)
			buffer.append("</Permissions>");
	}
	// field GroupPermissions
	if ((clientVer==-1.0 || clientVer>=1.03))
	{
		IArrayOf<IConstGroupAccountPermission>& v = src.getGroupPermissions();
		int size = v.length();
		if (size>0)
			buffer.append("<GroupPermissions>");
		for (int i=0;i<size;i++)
		{
			buffer.append("<GroupPermission>");
			CGroupAccountPermission::serializer(ctx,v.item(i),buffer,false);
			buffer.append("</GroupPermission>");
		}
		if (size>0)
			buffer.append("</GroupPermissions>");
	}
	if (keepRootTag)
		buffer.append("</AccountPermissionsResponse>");
}

bool CAccountPermissionsResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
		hasValue |= m_AccountName.unmarshall(rpc_request, "AccountName", basepath);
		hasValue |= m_IsGroup.unmarshall(rpc_request, "IsGroup", basepath);
		hasValue |= m_IncludeGroup.unmarshall(rpc_request, "IncludeGroup", basepath);
		hasValue |= m_BasednNames.unmarshall(rpc_request, "BasednNames", basepath);
		hasValue |= m_Permissions.unmarshall(rpc_request, "Permissions", basepath);
		hasValue |= m_GroupPermissions.unmarshall(rpc_request, "GroupPermissions", basepath);
	}
	return hasValue;
}

bool CAccountPermissionsResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_AccountName.unmarshall(ctx, soapval, "AccountName");
	hasValue |= m_IsGroup.unmarshall(ctx, soapval, "IsGroup");
	hasValue |= m_IncludeGroup.unmarshall(ctx, soapval, "IncludeGroup");
	hasValue |= m_BasednNames.unmarshall(ctx, soapval, "BasednNames");
	hasValue |= m_Permissions.unmarshall(ctx, soapval, "Permissions");
	hasValue |= m_GroupPermissions.unmarshall(ctx, soapval, "GroupPermissions");
	return hasValue;
}

bool CAccountPermissionsResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_AccountName.unmarshall(ctx, params, attachments, "AccountName", basepath);
	hasValue |= m_IsGroup.unmarshall(ctx, params, attachments, "IsGroup", basepath);
	hasValue |= m_IncludeGroup.unmarshall(ctx, params, attachments, "IncludeGroup", basepath);
	hasValue |= m_BasednNames.unmarshall(ctx, params, attachments, "BasednNames", basepath);
	hasValue |= m_Permissions.unmarshall(ctx, params, attachments, "Permissions", basepath);
	hasValue |= m_GroupPermissions.unmarshall(ctx, params, attachments, "GroupPermissions", basepath);
	return hasValue;
}

const char * CAccountPermissionsResponse::getAccountName() { return m_AccountName.query();}
bool CAccountPermissionsResponse::getIsGroup() { return m_IsGroup;}
bool CAccountPermissionsResponse::getIncludeGroup() { return m_IncludeGroup;}
StringArray & CAccountPermissionsResponse::getBasednNames() { return (StringArray &) m_BasednNames; }
IArrayOf<IConstAccountPermission> & CAccountPermissionsResponse::getPermissions() { return (IArrayOf<IConstAccountPermission> &) m_Permissions; }
IArrayOf<IConstGroupAccountPermission> & CAccountPermissionsResponse::getGroupPermissions() { return (IArrayOf<IConstGroupAccountPermission> &) m_GroupPermissions; }
void CAccountPermissionsResponse::setAccountName(const char * val){ m_AccountName.set(val); }
void CAccountPermissionsResponse::setIsGroup(bool val){ m_IsGroup=val; }
void CAccountPermissionsResponse::setIncludeGroup(bool val){ m_IncludeGroup=val; }
void CAccountPermissionsResponse::setBasednNames(StringArray &val){ m_BasednNames->kill();  CloneArray(m_BasednNames.getValue(), val); }
void CAccountPermissionsResponse::setPermissions(IArrayOf<IEspAccountPermission> &val)
{
	m_Permissions->kill();
	IArrayOf<IConstAccountPermission> &target = m_Permissions.getValue();
	ForEachItemIn(idx, val)
	{
		IEspAccountPermission &item = (val).item(idx);
		item.Link();
		target.append(item);
	}
}
void CAccountPermissionsResponse::setPermissions(IArrayOf<IConstAccountPermission> &val)
{
	m_Permissions->kill();
	IArrayOf<IConstAccountPermission> &target = m_Permissions.getValue();
	ForEachItemIn(idx, val)
	{
		IConstAccountPermission &item = val.item(idx);
		item.Link();
		target.append(item);
	}
}
void CAccountPermissionsResponse::setGroupPermissions(IArrayOf<IEspGroupAccountPermission> &val)
{
	m_GroupPermissions->kill();
	IArrayOf<IConstGroupAccountPermission> &target = m_GroupPermissions.getValue();
	ForEachItemIn(idx, val)
	{
		IEspGroupAccountPermission &item = (val).item(idx);
		item.Link();
		target.append(item);
	}
}
void CAccountPermissionsResponse::setGroupPermissions(IArrayOf<IConstGroupAccountPermission> &val)
{
	m_GroupPermissions->kill();
	IArrayOf<IConstGroupAccountPermission> &target = m_GroupPermissions.getValue();
	ForEachItemIn(idx, val)
	{
		IConstGroupAccountPermission &item = val.item(idx);
		item.Link();
		target.append(item);
	}
}
extern "C"  IEspAccountPermissionsResponse *createAccountPermissionsResponse(const char *serv){return ((IEspAccountPermissionsResponse *)new CAccountPermissionsResponse(serv));}
extern "C"  IClientAccountPermissionsResponse *createClientAccountPermissionsResponse(const char *serv){return ((IClientAccountPermissionsResponse *)new CAccountPermissionsResponse(serv));}

//=======================================================
// class CFilePermissionRequest Implementation
//=======================================================

CFilePermissionRequest::CFilePermissionRequest(const char *serviceName, IRpcMessageBinding *init)
	: m_FileName(nilRemove),m_UserName(nilRemove),m_GroupName(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("FilePermissionRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CFilePermissionRequest::CFilePermissionRequest(const char *serviceName, const char *bc)
	: m_FileName(nilRemove),m_UserName(nilRemove),m_GroupName(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("FilePermissionRequest");
}

CFilePermissionRequest::CFilePermissionRequest(const char *serviceName, IRpcMessage* rpcmsg)
	: m_FileName(nilRemove),m_UserName(nilRemove),m_GroupName(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("FilePermissionRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CFilePermissionRequest::CFilePermissionRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_FileName(nilRemove),m_UserName(nilRemove),m_GroupName(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("FilePermissionRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CFilePermissionRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"FileName\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"UserName\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"GroupName\" type=\"xsd:string\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CFilePermissionRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CFilePermissionRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CFilePermissionRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("FileName");
	form.appendf("  <tr><td><b>FileName: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("UserName");
	form.appendf("  <tr><td><b>UserName: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("GroupName");
	form.appendf("  <tr><td><b>GroupName: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CFilePermissionRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CFilePermissionRequest::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_FileName.marshall(rpc_resp, "FileName", "", "", "");
	m_UserName.marshall(rpc_resp, "UserName", "", "", "");
	m_GroupName.marshall(rpc_resp, "GroupName", "", "", "");
}


void CFilePermissionRequest::copy(CFilePermissionRequest &from)
{
	m_FileName.copy(from.m_FileName);
	m_UserName.copy(from.m_UserName);
	m_GroupName.copy(from.m_GroupName);
}


void CFilePermissionRequest::copy(IConstFilePermissionRequest &ifrom)
{
	setFileName(ifrom.getFileName());
	setUserName(ifrom.getUserName());
	setGroupName(ifrom.getGroupName());
}


void CFilePermissionRequest::getAttributes(IProperties &attributes)
{
}


void CFilePermissionRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_FileName.toStr(ctx, buffer, "FileName", "", true, "", "");
	m_UserName.toStr(ctx, buffer, "UserName", "", true, "", "");
	m_GroupName.toStr(ctx, buffer, "GroupName", "", true, "", "");
}


void CFilePermissionRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CFilePermissionRequest::serializer(IEspContext* ctx, IConstFilePermissionRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<FilePermissionRequest>");
	// field FileName
	{
		const char* s = src.getFileName();
		if (s && *s)
		{
			buffer.append("<FileName>");
			encodeUtf8XML(s,buffer);
			buffer.append("</FileName>");
		}
	}
	// field UserName
	{
		const char* s = src.getUserName();
		if (s && *s)
		{
			buffer.append("<UserName>");
			encodeUtf8XML(s,buffer);
			buffer.append("</UserName>");
		}
	}
	// field GroupName
	{
		const char* s = src.getGroupName();
		if (s && *s)
		{
			buffer.append("<GroupName>");
			encodeUtf8XML(s,buffer);
			buffer.append("</GroupName>");
		}
	}
	if (keepRootTag)
		buffer.append("</FilePermissionRequest>");
}

bool CFilePermissionRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_FileName.unmarshall(rpc_request, "FileName", basepath);
	hasValue |= m_UserName.unmarshall(rpc_request, "UserName", basepath);
	hasValue |= m_GroupName.unmarshall(rpc_request, "GroupName", basepath);
	return hasValue;
}

bool CFilePermissionRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_FileName.unmarshall(ctx, soapval, "FileName");
	hasValue |= m_UserName.unmarshall(ctx, soapval, "UserName");
	hasValue |= m_GroupName.unmarshall(ctx, soapval, "GroupName");
	return hasValue;
}

bool CFilePermissionRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_FileName.unmarshall(ctx, params, attachments, "FileName", basepath);
	hasValue |= m_UserName.unmarshall(ctx, params, attachments, "UserName", basepath);
	hasValue |= m_GroupName.unmarshall(ctx, params, attachments, "GroupName", basepath);
	return hasValue;
}

const char * CFilePermissionRequest::getFileName() { return m_FileName.query();}
const char * CFilePermissionRequest::getUserName() { return m_UserName.query();}
const char * CFilePermissionRequest::getGroupName() { return m_GroupName.query();}
void CFilePermissionRequest::setFileName(const char * val){ m_FileName.set(val); }
void CFilePermissionRequest::setUserName(const char * val){ m_UserName.set(val); }
void CFilePermissionRequest::setGroupName(const char * val){ m_GroupName.set(val); }
extern "C"  IEspFilePermissionRequest *createFilePermissionRequest(const char *serv){return ((IEspFilePermissionRequest *)new CFilePermissionRequest(serv));}
extern "C"  IClientFilePermissionRequest *createClientFilePermissionRequest(const char *serv){return ((IClientFilePermissionRequest *)new CFilePermissionRequest(serv));}

//=======================================================
// class CFilePermissionResponse Implementation
//=======================================================

CFilePermissionResponse::CFilePermissionResponse(const char *serviceName, IRpcMessageBinding *init)
	: m_NoSecMngr(0, nilRemove,false),m_FileName(nilRemove),m_UserName(nilRemove),m_GroupName(nilRemove),m_toomany(nilRemove),m_Users(nilRemove),m_Groups(nilRemove),m_UserPermission(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("FilePermissionResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CFilePermissionResponse::CFilePermissionResponse(const char *serviceName, const char *bc)
	: m_NoSecMngr(0, nilRemove,false),m_FileName(nilRemove),m_UserName(nilRemove),m_GroupName(nilRemove),m_toomany(nilRemove),m_Users(nilRemove),m_Groups(nilRemove),m_UserPermission(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("FilePermissionResponse");
}

CFilePermissionResponse::CFilePermissionResponse(const char *serviceName, IRpcMessage* rpcmsg)
	: m_NoSecMngr(0, nilRemove,false),m_FileName(nilRemove),m_UserName(nilRemove),m_GroupName(nilRemove),m_toomany(nilRemove),m_Users(nilRemove),m_Groups(nilRemove),m_UserPermission(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("FilePermissionResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CFilePermissionResponse::CFilePermissionResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_NoSecMngr(0, nilRemove,false),m_FileName(nilRemove),m_UserName(nilRemove),m_GroupName(nilRemove),m_toomany(nilRemove),m_Users(nilRemove),m_Groups(nilRemove),m_UserPermission(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("FilePermissionResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CFilePermissionResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		if (!context.suppressed("FilePermissionResponse","NoSecMngr")) {
			schema.append("<xsd:element minOccurs=\"0\" default=\"false\" name=\"NoSecMngr\" type=\"xsd:boolean\"/>\n");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"FileName\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"UserName\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"GroupName\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"toomany\" type=\"xsd:boolean\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Users\">\n");
		schema.append("<xsd:complexType><xsd:sequence>\n");
		schema.append("<xsd:element minOccurs=\"0\" maxOccurs=\"unbounded\" name=\"User\" type=\"tns:UserInfo\"/>");
		schema.append("</xsd:sequence></xsd:complexType>");
		schema.append("</xsd:element>");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Groups\">\n");
		schema.append("<xsd:complexType><xsd:sequence>\n");
		schema.append("<xsd:element minOccurs=\"0\" maxOccurs=\"unbounded\" name=\"Group\" type=\"tns:GroupInfo\"/>");
		schema.append("</xsd:sequence></xsd:complexType>");
		schema.append("</xsd:element>");
		schema.append("<xsd:element minOccurs=\"0\" name=\"UserPermission\" type=\"xsd:string\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	if (!(flags & 0x10)  || (flags & 0x100))
	{
		CUserInfo::getXsdDefinition(context, request, schema, added);
		CGroupInfo::getXsdDefinition(context, request, schema, added);
	}
	return schema;
}

void CFilePermissionResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CFilePermissionResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
	info.addMinVersion("FilePermissionResponse","NoSecMngr",1.04);
	if (!added.getValue("GroupInfo"))
	{
		added.setValue("GroupInfo",1);
		CGroupInfo::getMapInfo(info,added);
	}
	if (!added.getValue("UserInfo"))
	{
		added.setValue("UserInfo",1);
		CUserInfo::getMapInfo(info,added);
	}
}

StringBuffer &CFilePermissionResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	if (!context.suppressed("FilePermissionResponse","NoSecMngr")) {
		extfix.clear();
		if (prefix && *prefix)
			extfix.append(prefix).append(".");
		extfix.append("NoSecMngr");
		
	form.appendf("  <tr><td><b>NoSecMngr? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	}
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("FileName");
	form.appendf("  <tr><td><b>FileName: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("UserName");
	form.appendf("  <tr><td><b>UserName: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("GroupName");
	form.appendf("  <tr><td><b>GroupName: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("toomany");
	
	form.appendf("  <tr><td><b>toomany? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Users");
	form.appendf("<tr><td><b>Users: </b></td><td>");
	form.appendf("<table><tr><td><textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea></td>", extfix.str());
	form.append("</tr></table>");
	form.append("</td></tr>");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Groups");
	form.appendf("<tr><td><b>Groups: </b></td><td>");
	form.appendf("<table><tr><td><textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea></td>", extfix.str());
	form.append("</tr></table>");
	form.append("</td></tr>");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("UserPermission");
	form.appendf("  <tr><td><b>UserPermission: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CFilePermissionResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CFilePermissionResponse::serialize(IRpcMessage& rpc_resp)
{
	IEspContext* ctx = rpc_resp.queryContext();
	double clientVer= ctx ? ctx->getClientVersion() : -1; /* no context gets everything */
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
		if ((clientVer==-1.0 || clientVer>=1.04))
			m_NoSecMngr.marshall(rpc_resp, "NoSecMngr", "", "", "");
		m_FileName.marshall(rpc_resp, "FileName", "", "", "");
		m_UserName.marshall(rpc_resp, "UserName", "", "", "");
		m_GroupName.marshall(rpc_resp, "GroupName", "", "", "");
		m_toomany.marshall(rpc_resp, "toomany", "", "", "");
		m_Users.marshall(rpc_resp, "Users", "User");
		m_Groups.marshall(rpc_resp, "Groups", "Group");
		m_UserPermission.marshall(rpc_resp, "UserPermission", "", "", "");
	}
}


void CFilePermissionResponse::copy(CFilePermissionResponse &from)
{
	m_NoSecMngr.copy(from.m_NoSecMngr);
	m_FileName.copy(from.m_FileName);
	m_UserName.copy(from.m_UserName);
	m_GroupName.copy(from.m_GroupName);
	m_toomany.copy(from.m_toomany);
	m_Users.copy(from.m_Users);
	m_Groups.copy(from.m_Groups);
	m_UserPermission.copy(from.m_UserPermission);
}


void CFilePermissionResponse::copy(IConstFilePermissionResponse &ifrom)
{
	setNoSecMngr(ifrom.getNoSecMngr());
	setFileName(ifrom.getFileName());
	setUserName(ifrom.getUserName());
	setGroupName(ifrom.getGroupName());
	setToomany(ifrom.getToomany());
	setUsers(ifrom.getUsers());
	setGroups(ifrom.getGroups());
	setUserPermission(ifrom.getUserPermission());
}


void CFilePermissionResponse::getAttributes(IProperties &attributes)
{
}


void CFilePermissionResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
		double clientVer = ctx ? ctx->getClientVersion() : -1;
		if ((clientVer==-1.0 || clientVer>=1.04))
			m_NoSecMngr.toStr(ctx, buffer, "NoSecMngr", "", true, "", "");
		m_FileName.toStr(ctx, buffer, "FileName", "", true, "", "");
		m_UserName.toStr(ctx, buffer, "UserName", "", true, "", "");
		m_GroupName.toStr(ctx, buffer, "GroupName", "", true, "", "");
		m_toomany.toStr(ctx, buffer, "toomany", "", true, "", "");
		m_Users.toStr(ctx, buffer, "Users", "User");
		m_Groups.toStr(ctx, buffer, "Groups", "Group");
		m_UserPermission.toStr(ctx, buffer, "UserPermission", "", true, "", "");
	}
}


void CFilePermissionResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CFilePermissionResponse::serializer(IEspContext* ctx, IConstFilePermissionResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<FilePermissionResponse>");
	double clientVer = ctx ? ctx->getClientVersion() : -1;
	// field NoSecMngr
	if ((clientVer==-1.0 || clientVer>=1.04))
	{
		bool b = src.getNoSecMngr();
		if (b)
			buffer.appendf("<NoSecMngr>1</NoSecMngr>");
	}
	// field FileName
	{
		const char* s = src.getFileName();
		if (s && *s)
		{
			buffer.append("<FileName>");
			encodeUtf8XML(s,buffer);
			buffer.append("</FileName>");
		}
	}
	// field UserName
	{
		const char* s = src.getUserName();
		if (s && *s)
		{
			buffer.append("<UserName>");
			encodeUtf8XML(s,buffer);
			buffer.append("</UserName>");
		}
	}
	// field GroupName
	{
		const char* s = src.getGroupName();
		if (s && *s)
		{
			buffer.append("<GroupName>");
			encodeUtf8XML(s,buffer);
			buffer.append("</GroupName>");
		}
	}
	// field toomany
	{
		bool b = src.getToomany();
		if (b)
			buffer.appendf("<toomany>1</toomany>");
	}
	// field Users
	{
		IArrayOf<IConstUserInfo>& v = src.getUsers();
		int size = v.length();
		if (size>0)
			buffer.append("<Users>");
		for (int i=0;i<size;i++)
		{
			buffer.append("<User>");
			CUserInfo::serializer(ctx,v.item(i),buffer,false);
			buffer.append("</User>");
		}
		if (size>0)
			buffer.append("</Users>");
	}
	// field Groups
	{
		IArrayOf<IConstGroupInfo>& v = src.getGroups();
		int size = v.length();
		if (size>0)
			buffer.append("<Groups>");
		for (int i=0;i<size;i++)
		{
			buffer.append("<Group>");
			CGroupInfo::serializer(ctx,v.item(i),buffer,false);
			buffer.append("</Group>");
		}
		if (size>0)
			buffer.append("</Groups>");
	}
	// field UserPermission
	{
		const char* s = src.getUserPermission();
		if (s && *s)
		{
			buffer.append("<UserPermission>");
			encodeUtf8XML(s,buffer);
			buffer.append("</UserPermission>");
		}
	}
	if (keepRootTag)
		buffer.append("</FilePermissionResponse>");
}

bool CFilePermissionResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
		hasValue |= m_NoSecMngr.unmarshall(rpc_request, "NoSecMngr", basepath);
		hasValue |= m_FileName.unmarshall(rpc_request, "FileName", basepath);
		hasValue |= m_UserName.unmarshall(rpc_request, "UserName", basepath);
		hasValue |= m_GroupName.unmarshall(rpc_request, "GroupName", basepath);
		hasValue |= m_toomany.unmarshall(rpc_request, "toomany", basepath);
		hasValue |= m_Users.unmarshall(rpc_request, "Users", basepath);
		hasValue |= m_Groups.unmarshall(rpc_request, "Groups", basepath);
		hasValue |= m_UserPermission.unmarshall(rpc_request, "UserPermission", basepath);
	}
	return hasValue;
}

bool CFilePermissionResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_NoSecMngr.unmarshall(ctx, soapval, "NoSecMngr");
	hasValue |= m_FileName.unmarshall(ctx, soapval, "FileName");
	hasValue |= m_UserName.unmarshall(ctx, soapval, "UserName");
	hasValue |= m_GroupName.unmarshall(ctx, soapval, "GroupName");
	hasValue |= m_toomany.unmarshall(ctx, soapval, "toomany");
	hasValue |= m_Users.unmarshall(ctx, soapval, "Users");
	hasValue |= m_Groups.unmarshall(ctx, soapval, "Groups");
	hasValue |= m_UserPermission.unmarshall(ctx, soapval, "UserPermission");
	return hasValue;
}

bool CFilePermissionResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_NoSecMngr.unmarshall(ctx, params, attachments, "NoSecMngr", basepath);
	hasValue |= m_FileName.unmarshall(ctx, params, attachments, "FileName", basepath);
	hasValue |= m_UserName.unmarshall(ctx, params, attachments, "UserName", basepath);
	hasValue |= m_GroupName.unmarshall(ctx, params, attachments, "GroupName", basepath);
	hasValue |= m_toomany.unmarshall(ctx, params, attachments, "toomany", basepath);
	hasValue |= m_Users.unmarshall(ctx, params, attachments, "Users", basepath);
	hasValue |= m_Groups.unmarshall(ctx, params, attachments, "Groups", basepath);
	hasValue |= m_UserPermission.unmarshall(ctx, params, attachments, "UserPermission", basepath);
	return hasValue;
}

bool CFilePermissionResponse::getNoSecMngr_isNull(){return m_NoSecMngr.is_nil();}
bool CFilePermissionResponse::getNoSecMngr() { return m_NoSecMngr;}
const char * CFilePermissionResponse::getFileName() { return m_FileName.query();}
const char * CFilePermissionResponse::getUserName() { return m_UserName.query();}
const char * CFilePermissionResponse::getGroupName() { return m_GroupName.query();}
bool CFilePermissionResponse::getToomany_isNull(){return m_toomany.is_nil();}
bool CFilePermissionResponse::getToomany() { return m_toomany;}
IArrayOf<IConstUserInfo> & CFilePermissionResponse::getUsers() { return (IArrayOf<IConstUserInfo> &) m_Users; }
IArrayOf<IConstGroupInfo> & CFilePermissionResponse::getGroups() { return (IArrayOf<IConstGroupInfo> &) m_Groups; }
const char * CFilePermissionResponse::getUserPermission() { return m_UserPermission.query();}
void CFilePermissionResponse::setNoSecMngr_null(){ m_NoSecMngr.Nil(); }void CFilePermissionResponse::setNoSecMngr(bool val){ m_NoSecMngr=val; }
void CFilePermissionResponse::setFileName(const char * val){ m_FileName.set(val); }
void CFilePermissionResponse::setUserName(const char * val){ m_UserName.set(val); }
void CFilePermissionResponse::setGroupName(const char * val){ m_GroupName.set(val); }
void CFilePermissionResponse::setToomany_null(){ m_toomany.Nil(); }void CFilePermissionResponse::setToomany(bool val){ m_toomany=val; }
void CFilePermissionResponse::setUsers(IArrayOf<IEspUserInfo> &val)
{
	m_Users->kill();
	IArrayOf<IConstUserInfo> &target = m_Users.getValue();
	ForEachItemIn(idx, val)
	{
		IEspUserInfo &item = (val).item(idx);
		item.Link();
		target.append(item);
	}
}
void CFilePermissionResponse::setUsers(IArrayOf<IConstUserInfo> &val)
{
	m_Users->kill();
	IArrayOf<IConstUserInfo> &target = m_Users.getValue();
	ForEachItemIn(idx, val)
	{
		IConstUserInfo &item = val.item(idx);
		item.Link();
		target.append(item);
	}
}
void CFilePermissionResponse::setGroups(IArrayOf<IEspGroupInfo> &val)
{
	m_Groups->kill();
	IArrayOf<IConstGroupInfo> &target = m_Groups.getValue();
	ForEachItemIn(idx, val)
	{
		IEspGroupInfo &item = (val).item(idx);
		item.Link();
		target.append(item);
	}
}
void CFilePermissionResponse::setGroups(IArrayOf<IConstGroupInfo> &val)
{
	m_Groups->kill();
	IArrayOf<IConstGroupInfo> &target = m_Groups.getValue();
	ForEachItemIn(idx, val)
	{
		IConstGroupInfo &item = val.item(idx);
		item.Link();
		target.append(item);
	}
}
void CFilePermissionResponse::setUserPermission(const char * val){ m_UserPermission.set(val); }
extern "C"  IEspFilePermissionResponse *createFilePermissionResponse(const char *serv){return ((IEspFilePermissionResponse *)new CFilePermissionResponse(serv));}
extern "C"  IClientFilePermissionResponse *createClientFilePermissionResponse(const char *serv){return ((IClientFilePermissionResponse *)new CFilePermissionResponse(serv));}

//=======================================================
// class CUserAccountExportRequest Implementation
//=======================================================

CUserAccountExportRequest::CUserAccountExportRequest(const char *serviceName, IRpcMessageBinding *init)
	: m_usernames(nilRemove),m_groupnames(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("UserAccountExportRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CUserAccountExportRequest::CUserAccountExportRequest(const char *serviceName, const char *bc)
	: m_usernames(nilRemove),m_groupnames(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("UserAccountExportRequest");
}

CUserAccountExportRequest::CUserAccountExportRequest(const char *serviceName, IRpcMessage* rpcmsg)
	: m_usernames(nilRemove),m_groupnames(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("UserAccountExportRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CUserAccountExportRequest::CUserAccountExportRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_usernames(nilRemove),m_groupnames(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("UserAccountExportRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CUserAccountExportRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"usernames\" type=\"tns:EspStringArray\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"groupnames\" type=\"tns:EspStringArray\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	if (added.getValue("EspStringArray")==NULL) {
		addEspNativeArray(schema,"string","EspStringArray");
		added.setValue("EspStringArray",1);
	}
	return schema;
}

void CUserAccountExportRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CUserAccountExportRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CUserAccountExportRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("usernames");
	form.appendf("<tr><td><b>usernames: </b></td><td>");
	form.appendf("<textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea>", extfix.str());
	form.append("</td></tr>");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("groupnames");
	form.appendf("<tr><td><b>groupnames: </b></td><td>");
	form.appendf("<textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea>", extfix.str());
	form.append("</td></tr>");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CUserAccountExportRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CUserAccountExportRequest::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_usernames.marshall(rpc_resp, "usernames", "Item");
	m_groupnames.marshall(rpc_resp, "groupnames", "Item");
}


void CUserAccountExportRequest::copy(CUserAccountExportRequest &from)
{
	m_usernames.copy(from.m_usernames);
	m_groupnames.copy(from.m_groupnames);
}


void CUserAccountExportRequest::copy(IConstUserAccountExportRequest &ifrom)
{
	setUsernames(ifrom.getUsernames());
	setGroupnames(ifrom.getGroupnames());
}


void CUserAccountExportRequest::getAttributes(IProperties &attributes)
{
}


void CUserAccountExportRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_usernames.toStr(ctx, buffer, "usernames", "Item");
	m_groupnames.toStr(ctx, buffer, "groupnames", "Item");
}


void CUserAccountExportRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CUserAccountExportRequest::serializer(IEspContext* ctx, IConstUserAccountExportRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<UserAccountExportRequest>");
	// field usernames
	{
		StringArray& v = src.getUsernames();
		if (v.length()>0)
			buffer.append("<usernames>");
		for (size32_t i=0;i<v.length();i++)
			buffer.appendf("<Item>%s</Item>",v.item(i));
		if (v.length()>0)
			buffer.append("</usernames>");
	}
	// field groupnames
	{
		StringArray& v = src.getGroupnames();
		if (v.length()>0)
			buffer.append("<groupnames>");
		for (size32_t i=0;i<v.length();i++)
			buffer.appendf("<Item>%s</Item>",v.item(i));
		if (v.length()>0)
			buffer.append("</groupnames>");
	}
	if (keepRootTag)
		buffer.append("</UserAccountExportRequest>");
}

bool CUserAccountExportRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_usernames.unmarshall(rpc_request, "usernames", basepath);
	hasValue |= m_groupnames.unmarshall(rpc_request, "groupnames", basepath);
	return hasValue;
}

bool CUserAccountExportRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_usernames.unmarshall(ctx, soapval, "usernames");
	hasValue |= m_groupnames.unmarshall(ctx, soapval, "groupnames");
	return hasValue;
}

bool CUserAccountExportRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_usernames.unmarshall(ctx, params, attachments, "usernames", basepath);
	hasValue |= m_groupnames.unmarshall(ctx, params, attachments, "groupnames", basepath);
	return hasValue;
}

StringArray & CUserAccountExportRequest::getUsernames() { return (StringArray &) m_usernames; }
StringArray & CUserAccountExportRequest::getGroupnames() { return (StringArray &) m_groupnames; }
void CUserAccountExportRequest::setUsernames(StringArray &val){ m_usernames->kill();  CloneArray(m_usernames.getValue(), val); }
void CUserAccountExportRequest::setGroupnames(StringArray &val){ m_groupnames->kill();  CloneArray(m_groupnames.getValue(), val); }
extern "C"  IEspUserAccountExportRequest *createUserAccountExportRequest(const char *serv){return ((IEspUserAccountExportRequest *)new CUserAccountExportRequest(serv));}
extern "C"  IClientUserAccountExportRequest *createClientUserAccountExportRequest(const char *serv){return ((IClientUserAccountExportRequest *)new CUserAccountExportRequest(serv));}

//=======================================================
// class CUserAccountExportResponse Implementation
//=======================================================

CUserAccountExportResponse::CUserAccountExportResponse(const char *serviceName, IRpcMessageBinding *init)
	: m_Result(nilRemove),m_Result_mimetype("application/octet-stream")
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("UserAccountExportResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CUserAccountExportResponse::CUserAccountExportResponse(const char *serviceName, const char *bc)
	: m_Result(nilRemove), m_Result_mimetype("application/octet-stream")
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("UserAccountExportResponse");
}

CUserAccountExportResponse::CUserAccountExportResponse(const char *serviceName, IRpcMessage* rpcmsg)
	: m_Result(nilRemove), m_Result_mimetype("application/octet-stream")
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("UserAccountExportResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CUserAccountExportResponse::CUserAccountExportResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_Result(nilRemove), m_Result_mimetype("application/octet-stream")
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("UserAccountExportResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CUserAccountExportResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Result\" type=\"xsd:base64Binary\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CUserAccountExportResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CUserAccountExportResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CUserAccountExportResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Result");
	form.appendf("  <tr><td><b>Result: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CUserAccountExportResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CUserAccountExportResponse::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
		m_Result.marshall(rpc_resp, "Result", "", "", "");
	}
}


void CUserAccountExportResponse::copy(CUserAccountExportResponse &from)
{
	m_Result.copy(from.m_Result);
}


void CUserAccountExportResponse::copy(IConstUserAccountExportResponse &ifrom)
{
	setResult(ifrom.getResult());
}


void CUserAccountExportResponse::getAttributes(IProperties &attributes)
{
}


void CUserAccountExportResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
		m_Result.toStr(ctx, buffer, "Result", "", true, "", "");
	}
}


void CUserAccountExportResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CUserAccountExportResponse::serializer(IEspContext* ctx, IConstUserAccountExportResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<UserAccountExportResponse>");
	// field Result
	{
		StringBuffer tmp;
		JBASE64_Encode(src.getResult().toByteArray(), src.getResult().length(), tmp);
		if (tmp.length()>0)
			buffer.appendf("<Result>%s</Result>",tmp.str());
	}
	if (keepRootTag)
		buffer.append("</UserAccountExportResponse>");
}

void CUserAccountExportResponse::appendContent(IEspContext* ctx, MemoryBuffer& buffer, StringBuffer &mimetype)
{
	buffer.clear().append(m_Result.getValue());
	mimetype.set(m_Result_mimetype.str());
}

bool CUserAccountExportResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
		hasValue |= m_Result.unmarshall(rpc_request, "Result", basepath);
	}
	return hasValue;
}

bool CUserAccountExportResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Result.unmarshall(ctx, soapval, "Result");
	return hasValue;
}

bool CUserAccountExportResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Result.unmarshall(ctx, params, attachments, "Result", basepath);
	return hasValue;
}

const char *CUserAccountExportResponse::getResult_mimetype(){ return m_Result_mimetype.str(); }
const MemoryBuffer & CUserAccountExportResponse::getResult() { return m_Result.getValue();}
void CUserAccountExportResponse::setResult_mimetype(const char *  val){ m_Result_mimetype.set(val); }
void CUserAccountExportResponse::setResult(const MemoryBuffer & val){ m_Result->clear().append(val); }
extern "C"  IEspUserAccountExportResponse *createUserAccountExportResponse(const char *serv){return ((IEspUserAccountExportResponse *)new CUserAccountExportResponse(serv));}
extern "C"  IClientUserAccountExportResponse *createClientUserAccountExportResponse(const char *serv){return ((IClientUserAccountExportResponse *)new CUserAccountExportResponse(serv));}

//=======================================================
// class Cws_accessPingRequest Implementation
//=======================================================

Cws_accessPingRequest::Cws_accessPingRequest(const char *serviceName, IRpcMessageBinding *init)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ws_accessPingRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

Cws_accessPingRequest::Cws_accessPingRequest(const char *serviceName, const char *bc)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ws_accessPingRequest");
}

Cws_accessPingRequest::Cws_accessPingRequest(const char *serviceName, IRpcMessage* rpcmsg)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ws_accessPingRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

Cws_accessPingRequest::Cws_accessPingRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ws_accessPingRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &Cws_accessPingRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType><xsd:all/></xsd:complexType></xsd:element>\n", msgTypeName);
		}
	}
	return schema;
}

void Cws_accessPingRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void Cws_accessPingRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &Cws_accessPingRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &Cws_accessPingRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void Cws_accessPingRequest::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

}


void Cws_accessPingRequest::copy(Cws_accessPingRequest &from)
{
}


void Cws_accessPingRequest::copy(IConstws_accessPingRequest &ifrom)
{
}


void Cws_accessPingRequest::getAttributes(IProperties &attributes)
{
}


void Cws_accessPingRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
}


void Cws_accessPingRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void Cws_accessPingRequest::serializer(IEspContext* ctx, IConstws_accessPingRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<ws_accessPingRequest>");
	if (keepRootTag)
		buffer.append("</ws_accessPingRequest>");
}

bool Cws_accessPingRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	return hasValue;
}

bool Cws_accessPingRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	return hasValue;
}

bool Cws_accessPingRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	return hasValue;
}

extern "C"  IEspws_accessPingRequest *createws_accessPingRequest(const char *serv){return ((IEspws_accessPingRequest *)new Cws_accessPingRequest(serv));}
extern "C"  IClientws_accessPingRequest *createClientws_accessPingRequest(const char *serv){return ((IClientws_accessPingRequest *)new Cws_accessPingRequest(serv));}

//=======================================================
// class Cws_accessPingResponse Implementation
//=======================================================

Cws_accessPingResponse::Cws_accessPingResponse(const char *serviceName, IRpcMessageBinding *init)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ws_accessPingResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

Cws_accessPingResponse::Cws_accessPingResponse(const char *serviceName, const char *bc)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ws_accessPingResponse");
}

Cws_accessPingResponse::Cws_accessPingResponse(const char *serviceName, IRpcMessage* rpcmsg)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ws_accessPingResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

Cws_accessPingResponse::Cws_accessPingResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ws_accessPingResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &Cws_accessPingResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType><xsd:all/></xsd:complexType></xsd:element>\n", msgTypeName);
		}
	}
	return schema;
}

void Cws_accessPingResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void Cws_accessPingResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &Cws_accessPingResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &Cws_accessPingResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void Cws_accessPingResponse::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
	}
}


void Cws_accessPingResponse::copy(Cws_accessPingResponse &from)
{
}


void Cws_accessPingResponse::copy(IConstws_accessPingResponse &ifrom)
{
}


void Cws_accessPingResponse::getAttributes(IProperties &attributes)
{
}


void Cws_accessPingResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
	}
}


void Cws_accessPingResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void Cws_accessPingResponse::serializer(IEspContext* ctx, IConstws_accessPingResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<ws_accessPingResponse>");
	if (keepRootTag)
		buffer.append("</ws_accessPingResponse>");
}

bool Cws_accessPingResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
	}
	return hasValue;
}

bool Cws_accessPingResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	return hasValue;
}

bool Cws_accessPingResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	return hasValue;
}

extern "C"  IEspws_accessPingResponse *createws_accessPingResponse(const char *serv){return ((IEspws_accessPingResponse *)new Cws_accessPingResponse(serv));}
extern "C"  IClientws_accessPingResponse *createClientws_accessPingResponse(const char *serv){return ((IClientws_accessPingResponse *)new Cws_accessPingResponse(serv));}

//=======================================================
// class Cws_accessSoapBinding Implementation
//=======================================================

Cws_accessSoapBinding::Cws_accessSoapBinding(http_soap_log_level level):CHttpSoapBinding(NULL, NULL, NULL, level)
{
	init_strings();
	setWsdlVersion(1.12);
}

Cws_accessSoapBinding::Cws_accessSoapBinding(IPropertyTree* cfg, const char *bindname, const char *procname, http_soap_log_level level):CHttpSoapBinding(cfg, bindname, procname, level)
{
	init_strings(); 
	setWsdlVersion(1.12);

}

void Cws_accessSoapBinding::init_strings()
{
}

int Cws_accessSoapBinding::processRequest(IRpcMessage* rpc_call, IRpcMessage* rpc_response)
{
	if(rpc_call == NULL || rpc_response == NULL)
		return -1;

	IEspContext *ctx=rpc_call->queryContext();
	DBGLOG("Client version: %g", ctx->getClientVersion());
	StringBuffer serviceName;
	double clientVer=(ctx) ? ctx->getClientVersion() : 0.0;
	qualifyServiceName(*ctx, ctx->queryServiceName(NULL), NULL, serviceName, NULL);
	CRpcCall* thecall = static_cast<CRpcCall *>(rpc_call);
	CRpcResponse* response = static_cast<CRpcResponse*>(rpc_response);
	CHttpRequest* httprequest = thecall->getHttpReq();
	CHttpResponse* httpresponse = response->getHttpResp();

	Owned<IEspws_access> iserv = (IEspws_access*)getService();
	if(iserv == NULL)
	{
		response->set_status(SOAP_SERVER_ERROR);
		response->set_err("Service not available");
		DBGLOG("Service not available");
		return -1;
	}
	if (thecall->get_name() == NULL)
	{
		response->set_status(SOAP_CLIENT_ERROR);
		response->set_err("No service method specified");
		ERRLOG("No service method specified");
		return -1;
	}

	IEspContext& context = *rpc_call->queryContext();

	if(!stricmp(thecall->get_name(), "AccountPermissions")||!stricmp(thecall->get_name(), "AccountPermissionsRequest"))
	{
		Owned<CAccountPermissionsRequest> esp_request = new CAccountPermissionsRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CAccountPermissionsResponse> esp_response = new CAccountPermissionsResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		StringBuffer source;
		source.appendf("ws_access::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "ws_access", "AccountPermissions");
			iserv->onAccountPermissions(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "ws_access", "AccountPermissions");
		response->set_name("AccountPermissionsResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "AddUser")||!stricmp(thecall->get_name(), "AddUserRequest"))
	{
		Owned<CAddUserRequest> esp_request = new CAddUserRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CAddUserResponse> esp_response = new CAddUserResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		StringBuffer source;
		source.appendf("ws_access::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "ws_access", "AddUser");
			iserv->onAddUser(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "ws_access", "AddUser");
		response->set_name("AddUserResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "AddView")||!stricmp(thecall->get_name(), "AddViewRequest"))
	{
		Owned<CAddViewRequest> esp_request = new CAddViewRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CAddViewResponse> esp_response = new CAddViewResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		StringBuffer source;
		source.appendf("ws_access::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			if (clientVer!=-1.0 && clientVer<1.1)
				throw MakeStringException(-1, "Client version is too old, please update your client application.");			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "ws_access", "AddView");
			iserv->onAddView(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "ws_access", "AddView");
		response->set_name("AddViewResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "AddViewColumn")||!stricmp(thecall->get_name(), "AddViewColumnRequest"))
	{
		Owned<CAddViewColumnRequest> esp_request = new CAddViewColumnRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CAddViewColumnResponse> esp_response = new CAddViewColumnResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		StringBuffer source;
		source.appendf("ws_access::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			if (clientVer!=-1.0 && clientVer<1.1)
				throw MakeStringException(-1, "Client version is too old, please update your client application.");			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "ws_access", "AddViewColumn");
			iserv->onAddViewColumn(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "ws_access", "AddViewColumn");
		response->set_name("AddViewColumnResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "AddViewMember")||!stricmp(thecall->get_name(), "AddViewMemberRequest"))
	{
		Owned<CAddViewMemberRequest> esp_request = new CAddViewMemberRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CAddViewMemberResponse> esp_response = new CAddViewMemberResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		StringBuffer source;
		source.appendf("ws_access::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			if (clientVer!=-1.0 && clientVer<1.1)
				throw MakeStringException(-1, "Client version is too old, please update your client application.");			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "ws_access", "AddViewMember");
			iserv->onAddViewMember(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "ws_access", "AddViewMember");
		response->set_name("AddViewMemberResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "ClearPermissionsCache")||!stricmp(thecall->get_name(), "ClearPermissionsCacheRequest"))
	{
		Owned<CClearPermissionsCacheRequest> esp_request = new CClearPermissionsCacheRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CClearPermissionsCacheResponse> esp_response = new CClearPermissionsCacheResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		StringBuffer source;
		source.appendf("ws_access::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "ws_access", "ClearPermissionsCache");
			iserv->onClearPermissionsCache(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "ws_access", "ClearPermissionsCache");
		response->set_name("ClearPermissionsCacheResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "DeleteView")||!stricmp(thecall->get_name(), "DeleteViewRequest"))
	{
		Owned<CDeleteViewRequest> esp_request = new CDeleteViewRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CDeleteViewResponse> esp_response = new CDeleteViewResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		StringBuffer source;
		source.appendf("ws_access::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			if (clientVer!=-1.0 && clientVer<1.1)
				throw MakeStringException(-1, "Client version is too old, please update your client application.");			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "ws_access", "DeleteView");
			iserv->onDeleteView(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "ws_access", "DeleteView");
		response->set_name("DeleteViewResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "DeleteViewColumn")||!stricmp(thecall->get_name(), "DeleteViewColumnRequest"))
	{
		Owned<CDeleteViewColumnRequest> esp_request = new CDeleteViewColumnRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CDeleteViewColumnResponse> esp_response = new CDeleteViewColumnResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		StringBuffer source;
		source.appendf("ws_access::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			if (clientVer!=-1.0 && clientVer<1.1)
				throw MakeStringException(-1, "Client version is too old, please update your client application.");			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "ws_access", "DeleteViewColumn");
			iserv->onDeleteViewColumn(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "ws_access", "DeleteViewColumn");
		response->set_name("DeleteViewColumnResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "DeleteViewMember")||!stricmp(thecall->get_name(), "DeleteViewMemberRequest"))
	{
		Owned<CDeleteViewMemberRequest> esp_request = new CDeleteViewMemberRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CDeleteViewMemberResponse> esp_response = new CDeleteViewMemberResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		StringBuffer source;
		source.appendf("ws_access::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			if (clientVer!=-1.0 && clientVer<1.1)
				throw MakeStringException(-1, "Client version is too old, please update your client application.");			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "ws_access", "DeleteViewMember");
			iserv->onDeleteViewMember(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "ws_access", "DeleteViewMember");
		response->set_name("DeleteViewMemberResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "DisableScopeScans")||!stricmp(thecall->get_name(), "DisableScopeScansRequest"))
	{
		Owned<CDisableScopeScansRequest> esp_request = new CDisableScopeScansRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CDisableScopeScansResponse> esp_response = new CDisableScopeScansResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		StringBuffer source;
		source.appendf("ws_access::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "ws_access", "DisableScopeScans");
			iserv->onDisableScopeScans(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "ws_access", "DisableScopeScans");
		response->set_name("DisableScopeScansResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "EnableScopeScans")||!stricmp(thecall->get_name(), "EnableScopeScansRequest"))
	{
		Owned<CEnableScopeScansRequest> esp_request = new CEnableScopeScansRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CEnableScopeScansResponse> esp_response = new CEnableScopeScansResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		StringBuffer source;
		source.appendf("ws_access::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "ws_access", "EnableScopeScans");
			iserv->onEnableScopeScans(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "ws_access", "EnableScopeScans");
		response->set_name("EnableScopeScansResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "FilePermission")||!stricmp(thecall->get_name(), "FilePermissionRequest"))
	{
		Owned<CFilePermissionRequest> esp_request = new CFilePermissionRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CFilePermissionResponse> esp_response = new CFilePermissionResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		StringBuffer source;
		source.appendf("ws_access::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "ws_access", "FilePermission");
			iserv->onFilePermission(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "ws_access", "FilePermission");
		response->set_name("FilePermissionResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "GroupAction")||!stricmp(thecall->get_name(), "GroupActionRequest"))
	{
		Owned<CGroupActionRequest> esp_request = new CGroupActionRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CGroupActionResponse> esp_response = new CGroupActionResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		StringBuffer source;
		source.appendf("ws_access::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "ws_access", "GroupAction");
			iserv->onGroupAction(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "ws_access", "GroupAction");
		response->set_name("GroupActionResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "GroupAdd")||!stricmp(thecall->get_name(), "GroupAddRequest"))
	{
		Owned<CGroupAddRequest> esp_request = new CGroupAddRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CGroupAddResponse> esp_response = new CGroupAddResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		StringBuffer source;
		source.appendf("ws_access::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "ws_access", "GroupAdd");
			iserv->onGroupAdd(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "ws_access", "GroupAdd");
		response->set_name("GroupAddResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "GroupEdit")||!stricmp(thecall->get_name(), "GroupEditRequest"))
	{
		Owned<CGroupEditRequest> esp_request = new CGroupEditRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CGroupEditResponse> esp_response = new CGroupEditResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		StringBuffer source;
		source.appendf("ws_access::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "ws_access", "GroupEdit");
			iserv->onGroupEdit(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "ws_access", "GroupEdit");
		response->set_name("GroupEditResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "GroupMemberEdit")||!stricmp(thecall->get_name(), "GroupMemberEditRequest"))
	{
		Owned<CGroupMemberEditRequest> esp_request = new CGroupMemberEditRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CGroupMemberEditResponse> esp_response = new CGroupMemberEditResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		StringBuffer source;
		source.appendf("ws_access::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "ws_access", "GroupMemberEdit");
			iserv->onGroupMemberEdit(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "ws_access", "GroupMemberEdit");
		response->set_name("GroupMemberEditResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "GroupMemberEditInput")||!stricmp(thecall->get_name(), "GroupMemberEditInputRequest"))
	{
		Owned<CGroupMemberEditInputRequest> esp_request = new CGroupMemberEditInputRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CGroupMemberEditInputResponse> esp_response = new CGroupMemberEditInputResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		StringBuffer source;
		source.appendf("ws_access::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "ws_access", "GroupMemberEditInput");
			iserv->onGroupMemberEditInput(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "ws_access", "GroupMemberEditInput");
		response->set_name("GroupMemberEditInputResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "GroupMemberQuery")||!stricmp(thecall->get_name(), "GroupMemberQueryRequest"))
	{
		Owned<CGroupMemberQueryRequest> esp_request = new CGroupMemberQueryRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CGroupMemberQueryResponse> esp_response = new CGroupMemberQueryResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		StringBuffer source;
		source.appendf("ws_access::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "ws_access", "GroupMemberQuery");
			iserv->onGroupMemberQuery(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "ws_access", "GroupMemberQuery");
		response->set_name("GroupMemberQueryResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "GroupQuery")||!stricmp(thecall->get_name(), "GroupQueryRequest"))
	{
		Owned<CGroupQueryRequest> esp_request = new CGroupQueryRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CGroupQueryResponse> esp_response = new CGroupQueryResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		StringBuffer source;
		source.appendf("ws_access::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "ws_access", "GroupQuery");
			iserv->onGroupQuery(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "ws_access", "GroupQuery");
		response->set_name("GroupQueryResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "Groups")||!stricmp(thecall->get_name(), "GroupRequest"))
	{
		Owned<CGroupRequest> esp_request = new CGroupRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CGroupResponse> esp_response = new CGroupResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		StringBuffer source;
		source.appendf("ws_access::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "ws_access", "Groups");
			iserv->onGroups(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "ws_access", "Groups");
		response->set_name("GroupResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "PermissionAction")||!stricmp(thecall->get_name(), "PermissionActionRequest"))
	{
		Owned<CPermissionActionRequest> esp_request = new CPermissionActionRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CPermissionActionResponse> esp_response = new CPermissionActionResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		StringBuffer source;
		source.appendf("ws_access::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "ws_access", "PermissionAction");
			iserv->onPermissionAction(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "ws_access", "PermissionAction");
		response->set_name("PermissionActionResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "PermissionAddInput")||!stricmp(thecall->get_name(), "PermissionAddRequest"))
	{
		Owned<CPermissionAddRequest> esp_request = new CPermissionAddRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CPermissionAddResponse> esp_response = new CPermissionAddResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		StringBuffer source;
		source.appendf("ws_access::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "ws_access", "PermissionAddInput");
			iserv->onPermissionAddInput(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "ws_access", "PermissionAddInput");
		response->set_name("PermissionAddResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "Permissions")||!stricmp(thecall->get_name(), "BasednsRequest"))
	{
		Owned<CBasednsRequest> esp_request = new CBasednsRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CBasednsResponse> esp_response = new CBasednsResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		StringBuffer source;
		source.appendf("ws_access::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "ws_access", "Permissions");
			iserv->onPermissions(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "ws_access", "Permissions");
		response->set_name("BasednsResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "PermissionsReset")||!stricmp(thecall->get_name(), "PermissionsResetRequest"))
	{
		Owned<CPermissionsResetRequest> esp_request = new CPermissionsResetRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CPermissionsResetResponse> esp_response = new CPermissionsResetResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		StringBuffer source;
		source.appendf("ws_access::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "ws_access", "PermissionsReset");
			iserv->onPermissionsReset(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "ws_access", "PermissionsReset");
		response->set_name("PermissionsResetResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "PermissionsResetInput")||!stricmp(thecall->get_name(), "PermissionsResetInputRequest"))
	{
		Owned<CPermissionsResetInputRequest> esp_request = new CPermissionsResetInputRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CPermissionsResetInputResponse> esp_response = new CPermissionsResetInputResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		StringBuffer source;
		source.appendf("ws_access::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "ws_access", "PermissionsResetInput");
			iserv->onPermissionsResetInput(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "ws_access", "PermissionsResetInput");
		response->set_name("PermissionsResetInputResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "Ping")||!stricmp(thecall->get_name(), "ws_accessPingRequest"))
	{
		Owned<Cws_accessPingRequest> esp_request = new Cws_accessPingRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<Cws_accessPingResponse> esp_response = new Cws_accessPingResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		StringBuffer source;
		source.appendf("ws_access::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "ws_access", "Ping");
			iserv->onPing(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "ws_access", "Ping");
		response->set_name("ws_accessPingResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "QueryScopeScansEnabled")||!stricmp(thecall->get_name(), "QueryScopeScansEnabledRequest"))
	{
		Owned<CQueryScopeScansEnabledRequest> esp_request = new CQueryScopeScansEnabledRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CQueryScopeScansEnabledResponse> esp_response = new CQueryScopeScansEnabledResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		StringBuffer source;
		source.appendf("ws_access::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "ws_access", "QueryScopeScansEnabled");
			iserv->onQueryScopeScansEnabled(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "ws_access", "QueryScopeScansEnabled");
		response->set_name("QueryScopeScansEnabledResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "QueryUserViewColumns")||!stricmp(thecall->get_name(), "QueryUserViewColumnsRequest"))
	{
		Owned<CQueryUserViewColumnsRequest> esp_request = new CQueryUserViewColumnsRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CQueryUserViewColumnsResponse> esp_response = new CQueryUserViewColumnsResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		StringBuffer source;
		source.appendf("ws_access::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			if (clientVer!=-1.0 && clientVer<1.1)
				throw MakeStringException(-1, "Client version is too old, please update your client application.");			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "ws_access", "QueryUserViewColumns");
			iserv->onQueryUserViewColumns(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "ws_access", "QueryUserViewColumns");
		response->set_name("QueryUserViewColumnsResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "QueryViewColumns")||!stricmp(thecall->get_name(), "QueryViewColumnsRequest"))
	{
		Owned<CQueryViewColumnsRequest> esp_request = new CQueryViewColumnsRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CQueryViewColumnsResponse> esp_response = new CQueryViewColumnsResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		StringBuffer source;
		source.appendf("ws_access::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			if (clientVer!=-1.0 && clientVer<1.1)
				throw MakeStringException(-1, "Client version is too old, please update your client application.");			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "ws_access", "QueryViewColumns");
			iserv->onQueryViewColumns(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "ws_access", "QueryViewColumns");
		response->set_name("QueryViewColumnsResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "QueryViewMembers")||!stricmp(thecall->get_name(), "QueryViewMembersRequest"))
	{
		Owned<CQueryViewMembersRequest> esp_request = new CQueryViewMembersRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CQueryViewMembersResponse> esp_response = new CQueryViewMembersResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		StringBuffer source;
		source.appendf("ws_access::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			if (clientVer!=-1.0 && clientVer<1.1)
				throw MakeStringException(-1, "Client version is too old, please update your client application.");			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "ws_access", "QueryViewMembers");
			iserv->onQueryViewMembers(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "ws_access", "QueryViewMembers");
		response->set_name("QueryViewMembersResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "QueryViews")||!stricmp(thecall->get_name(), "QueryViewsRequest"))
	{
		Owned<CQueryViewsRequest> esp_request = new CQueryViewsRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CQueryViewsResponse> esp_response = new CQueryViewsResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		StringBuffer source;
		source.appendf("ws_access::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			if (clientVer!=-1.0 && clientVer<1.1)
				throw MakeStringException(-1, "Client version is too old, please update your client application.");			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "ws_access", "QueryViews");
			iserv->onQueryViews(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "ws_access", "QueryViews");
		response->set_name("QueryViewsResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "ResourceAdd")||!stricmp(thecall->get_name(), "ResourceAddRequest"))
	{
		Owned<CResourceAddRequest> esp_request = new CResourceAddRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CResourceAddResponse> esp_response = new CResourceAddResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		StringBuffer source;
		source.appendf("ws_access::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "ws_access", "ResourceAdd");
			iserv->onResourceAdd(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "ws_access", "ResourceAdd");
		response->set_name("ResourceAddResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "ResourceAddInput")||!stricmp(thecall->get_name(), "ResourceAddInputRequest"))
	{
		Owned<CResourceAddInputRequest> esp_request = new CResourceAddInputRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CResourceAddInputResponse> esp_response = new CResourceAddInputResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		StringBuffer source;
		source.appendf("ws_access::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "ws_access", "ResourceAddInput");
			iserv->onResourceAddInput(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "ws_access", "ResourceAddInput");
		response->set_name("ResourceAddInputResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "ResourceDelete")||!stricmp(thecall->get_name(), "ResourceDeleteRequest"))
	{
		Owned<CResourceDeleteRequest> esp_request = new CResourceDeleteRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CResourceDeleteResponse> esp_response = new CResourceDeleteResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		StringBuffer source;
		source.appendf("ws_access::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "ws_access", "ResourceDelete");
			iserv->onResourceDelete(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "ws_access", "ResourceDelete");
		response->set_name("ResourceDeleteResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "ResourcePermissionQuery")||!stricmp(thecall->get_name(), "ResourcePermissionQueryRequest"))
	{
		Owned<CResourcePermissionQueryRequest> esp_request = new CResourcePermissionQueryRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CResourcePermissionQueryResponse> esp_response = new CResourcePermissionQueryResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		StringBuffer source;
		source.appendf("ws_access::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			if (clientVer!=-1.0 && clientVer<1.11)
				throw MakeStringException(-1, "Client version is too old, please update your client application.");			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "ws_access", "ResourcePermissionQuery");
			iserv->onResourcePermissionQuery(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "ws_access", "ResourcePermissionQuery");
		response->set_name("ResourcePermissionQueryResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "ResourcePermissions")||!stricmp(thecall->get_name(), "ResourcePermissionsRequest"))
	{
		Owned<CResourcePermissionsRequest> esp_request = new CResourcePermissionsRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CResourcePermissionsResponse> esp_response = new CResourcePermissionsResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		StringBuffer source;
		source.appendf("ws_access::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "ws_access", "ResourcePermissions");
			iserv->onResourcePermissions(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "ws_access", "ResourcePermissions");
		response->set_name("ResourcePermissionsResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "ResourceQuery")||!stricmp(thecall->get_name(), "ResourceQueryRequest"))
	{
		Owned<CResourceQueryRequest> esp_request = new CResourceQueryRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CResourceQueryResponse> esp_response = new CResourceQueryResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		StringBuffer source;
		source.appendf("ws_access::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "ws_access", "ResourceQuery");
			iserv->onResourceQuery(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "ws_access", "ResourceQuery");
		response->set_name("ResourceQueryResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "Resources")||!stricmp(thecall->get_name(), "ResourcesRequest"))
	{
		Owned<CResourcesRequest> esp_request = new CResourcesRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CResourcesResponse> esp_response = new CResourcesResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		StringBuffer source;
		source.appendf("ws_access::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "ws_access", "Resources");
			iserv->onResources(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "ws_access", "Resources");
		response->set_name("ResourcesResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "UserAccountExport")||!stricmp(thecall->get_name(), "UserAccountExportRequest"))
	{
		Owned<CUserAccountExportRequest> esp_request = new CUserAccountExportRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CUserAccountExportResponse> esp_response = new CUserAccountExportResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		StringBuffer source;
		source.appendf("ws_access::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "ws_access", "UserAccountExport");
			iserv->onUserAccountExport(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "ws_access", "UserAccountExport");
		response->set_name("UserAccountExportResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "UserAction")||!stricmp(thecall->get_name(), "UserActionRequest"))
	{
		Owned<CUserActionRequest> esp_request = new CUserActionRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CUserActionResponse> esp_response = new CUserActionResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		StringBuffer source;
		source.appendf("ws_access::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "ws_access", "UserAction");
			iserv->onUserAction(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "ws_access", "UserAction");
		response->set_name("UserActionResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "UserEdit")||!stricmp(thecall->get_name(), "UserEditRequest"))
	{
		Owned<CUserEditRequest> esp_request = new CUserEditRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CUserEditResponse> esp_response = new CUserEditResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		StringBuffer source;
		source.appendf("ws_access::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "ws_access", "UserEdit");
			iserv->onUserEdit(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "ws_access", "UserEdit");
		response->set_name("UserEditResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "UserGroupEdit")||!stricmp(thecall->get_name(), "UserGroupEditRequest"))
	{
		Owned<CUserGroupEditRequest> esp_request = new CUserGroupEditRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CUserGroupEditResponse> esp_response = new CUserGroupEditResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		StringBuffer source;
		source.appendf("ws_access::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "ws_access", "UserGroupEdit");
			iserv->onUserGroupEdit(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "ws_access", "UserGroupEdit");
		response->set_name("UserGroupEditResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "UserGroupEditInput")||!stricmp(thecall->get_name(), "UserGroupEditInputRequest"))
	{
		Owned<CUserGroupEditInputRequest> esp_request = new CUserGroupEditInputRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CUserGroupEditInputResponse> esp_response = new CUserGroupEditInputResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		StringBuffer source;
		source.appendf("ws_access::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "ws_access", "UserGroupEditInput");
			iserv->onUserGroupEditInput(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "ws_access", "UserGroupEditInput");
		response->set_name("UserGroupEditInputResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "UserInfoEdit")||!stricmp(thecall->get_name(), "UserInfoEditRequest"))
	{
		Owned<CUserInfoEditRequest> esp_request = new CUserInfoEditRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CUserInfoEditResponse> esp_response = new CUserInfoEditResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		StringBuffer source;
		source.appendf("ws_access::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "ws_access", "UserInfoEdit");
			iserv->onUserInfoEdit(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "ws_access", "UserInfoEdit");
		response->set_name("UserInfoEditResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "UserInfoEditInput")||!stricmp(thecall->get_name(), "UserInfoEditInputRequest"))
	{
		Owned<CUserInfoEditInputRequest> esp_request = new CUserInfoEditInputRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CUserInfoEditInputResponse> esp_response = new CUserInfoEditInputResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		StringBuffer source;
		source.appendf("ws_access::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "ws_access", "UserInfoEditInput");
			iserv->onUserInfoEditInput(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "ws_access", "UserInfoEditInput");
		response->set_name("UserInfoEditInputResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "UserPosix")||!stricmp(thecall->get_name(), "UserPosixRequest"))
	{
		Owned<CUserPosixRequest> esp_request = new CUserPosixRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CUserPosixResponse> esp_response = new CUserPosixResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		StringBuffer source;
		source.appendf("ws_access::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "ws_access", "UserPosix");
			iserv->onUserPosix(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "ws_access", "UserPosix");
		response->set_name("UserPosixResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "UserPosixInput")||!stricmp(thecall->get_name(), "UserPosixInputRequest"))
	{
		Owned<CUserPosixInputRequest> esp_request = new CUserPosixInputRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CUserPosixInputResponse> esp_response = new CUserPosixInputResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		StringBuffer source;
		source.appendf("ws_access::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "ws_access", "UserPosixInput");
			iserv->onUserPosixInput(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "ws_access", "UserPosixInput");
		response->set_name("UserPosixInputResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "UserQuery")||!stricmp(thecall->get_name(), "UserQueryRequest"))
	{
		Owned<CUserQueryRequest> esp_request = new CUserQueryRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CUserQueryResponse> esp_response = new CUserQueryResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		StringBuffer source;
		source.appendf("ws_access::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "ws_access", "UserQuery");
			iserv->onUserQuery(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "ws_access", "UserQuery");
		response->set_name("UserQueryResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "UserResetPass")||!stricmp(thecall->get_name(), "UserResetPassRequest"))
	{
		Owned<CUserResetPassRequest> esp_request = new CUserResetPassRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CUserResetPassResponse> esp_response = new CUserResetPassResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		StringBuffer source;
		source.appendf("ws_access::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "ws_access", "UserResetPass");
			iserv->onUserResetPass(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "ws_access", "UserResetPass");
		response->set_name("UserResetPassResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "UserResetPassInput")||!stricmp(thecall->get_name(), "UserResetPassInputRequest"))
	{
		Owned<CUserResetPassInputRequest> esp_request = new CUserResetPassInputRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CUserResetPassInputResponse> esp_response = new CUserResetPassInputResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		StringBuffer source;
		source.appendf("ws_access::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "ws_access", "UserResetPassInput");
			iserv->onUserResetPassInput(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "ws_access", "UserResetPassInput");
		response->set_name("UserResetPassInputResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "UserSudoers")||!stricmp(thecall->get_name(), "UserSudoersRequest"))
	{
		Owned<CUserSudoersRequest> esp_request = new CUserSudoersRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CUserSudoersResponse> esp_response = new CUserSudoersResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		StringBuffer source;
		source.appendf("ws_access::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "ws_access", "UserSudoers");
			iserv->onUserSudoers(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "ws_access", "UserSudoers");
		response->set_name("UserSudoersResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "UserSudoersInput")||!stricmp(thecall->get_name(), "UserSudoersInputRequest"))
	{
		Owned<CUserSudoersInputRequest> esp_request = new CUserSudoersInputRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CUserSudoersInputResponse> esp_response = new CUserSudoersInputResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		StringBuffer source;
		source.appendf("ws_access::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "ws_access", "UserSudoersInput");
			iserv->onUserSudoersInput(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "ws_access", "UserSudoersInput");
		response->set_name("UserSudoersInputResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "Users")||!stricmp(thecall->get_name(), "UserRequest"))
	{
		Owned<CUserRequest> esp_request = new CUserRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CUserResponse> esp_response = new CUserResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		StringBuffer source;
		source.appendf("ws_access::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "ws_access", "Users");
			iserv->onUsers(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "ws_access", "Users");
		response->set_name("UserResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	response->set_status(SOAP_CLIENT_ERROR);
	StringBuffer msg, svcName;
	msg.appendf("Method %s not available in service %s",thecall->get_name(),getServiceName(svcName).str());
	ERRLOG("%s", msg.str());
	response->set_err(msg);
	return -1;
}

int Cws_accessSoapBinding::getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &content, const char *service, const char *method, bool mda)
{
	BoolHash added;
	if (context.getClientVersion()<=0)
		context.setClientVersion(1.12);

	DBGLOG("Client version: %g", context.getClientVersion());
	bool fullservice = (!Utils::strcasecmp(service, "ws_access"));
	bool allMethods = (method==NULL || *method==0);
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "AccountPermissions"))) || Utils::strcasecmp(method, "AccountPermissions")==0)
	{
		CAccountPermissionsRequest::getMapInfo(context.queryMapInfo());
		CAccountPermissionsResponse::getMapInfo(context.queryMapInfo());
		CAccountPermissionsRequest::getXsdDefinition(context, request, "AccountPermissionsRequest", content, added);
		CAccountPermissionsResponse::getXsdDefinition(context, request, content, added);
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "AddUser"))) || Utils::strcasecmp(method, "AddUser")==0)
	{
		CAddUserRequest::getMapInfo(context.queryMapInfo());
		CAddUserResponse::getMapInfo(context.queryMapInfo());
		CAddUserRequest::getXsdDefinition(context, request, "AddUserRequest", content, added);
		CAddUserResponse::getXsdDefinition(context, request, content, added);
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "AddView"))) || Utils::strcasecmp(method, "AddView")==0)
	{
		if (context.getClientVersion()>=1.1) {
			CAddViewRequest::getMapInfo(context.queryMapInfo());
			CAddViewResponse::getMapInfo(context.queryMapInfo());
			CAddViewRequest::getXsdDefinition(context, request, "AddViewRequest", content, added);
			CAddViewResponse::getXsdDefinition(context, request, content, added);
		}
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "AddViewColumn"))) || Utils::strcasecmp(method, "AddViewColumn")==0)
	{
		if (context.getClientVersion()>=1.1) {
			CAddViewColumnRequest::getMapInfo(context.queryMapInfo());
			CAddViewColumnResponse::getMapInfo(context.queryMapInfo());
			CAddViewColumnRequest::getXsdDefinition(context, request, "AddViewColumnRequest", content, added);
			CAddViewColumnResponse::getXsdDefinition(context, request, content, added);
		}
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "AddViewMember"))) || Utils::strcasecmp(method, "AddViewMember")==0)
	{
		if (context.getClientVersion()>=1.1) {
			CAddViewMemberRequest::getMapInfo(context.queryMapInfo());
			CAddViewMemberResponse::getMapInfo(context.queryMapInfo());
			CAddViewMemberRequest::getXsdDefinition(context, request, "AddViewMemberRequest", content, added);
			CAddViewMemberResponse::getXsdDefinition(context, request, content, added);
		}
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "ClearPermissionsCache"))) || Utils::strcasecmp(method, "ClearPermissionsCache")==0)
	{
		CClearPermissionsCacheRequest::getMapInfo(context.queryMapInfo());
		CClearPermissionsCacheResponse::getMapInfo(context.queryMapInfo());
		CClearPermissionsCacheRequest::getXsdDefinition(context, request, "ClearPermissionsCacheRequest", content, added);
		CClearPermissionsCacheResponse::getXsdDefinition(context, request, content, added);
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "DeleteView"))) || Utils::strcasecmp(method, "DeleteView")==0)
	{
		if (context.getClientVersion()>=1.1) {
			CDeleteViewRequest::getMapInfo(context.queryMapInfo());
			CDeleteViewResponse::getMapInfo(context.queryMapInfo());
			CDeleteViewRequest::getXsdDefinition(context, request, "DeleteViewRequest", content, added);
			CDeleteViewResponse::getXsdDefinition(context, request, content, added);
		}
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "DeleteViewColumn"))) || Utils::strcasecmp(method, "DeleteViewColumn")==0)
	{
		if (context.getClientVersion()>=1.1) {
			CDeleteViewColumnRequest::getMapInfo(context.queryMapInfo());
			CDeleteViewColumnResponse::getMapInfo(context.queryMapInfo());
			CDeleteViewColumnRequest::getXsdDefinition(context, request, "DeleteViewColumnRequest", content, added);
			CDeleteViewColumnResponse::getXsdDefinition(context, request, content, added);
		}
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "DeleteViewMember"))) || Utils::strcasecmp(method, "DeleteViewMember")==0)
	{
		if (context.getClientVersion()>=1.1) {
			CDeleteViewMemberRequest::getMapInfo(context.queryMapInfo());
			CDeleteViewMemberResponse::getMapInfo(context.queryMapInfo());
			CDeleteViewMemberRequest::getXsdDefinition(context, request, "DeleteViewMemberRequest", content, added);
			CDeleteViewMemberResponse::getXsdDefinition(context, request, content, added);
		}
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "DisableScopeScans"))) || Utils::strcasecmp(method, "DisableScopeScans")==0)
	{
		CDisableScopeScansRequest::getMapInfo(context.queryMapInfo());
		CDisableScopeScansResponse::getMapInfo(context.queryMapInfo());
		CDisableScopeScansRequest::getXsdDefinition(context, request, "DisableScopeScansRequest", content, added);
		CDisableScopeScansResponse::getXsdDefinition(context, request, content, added);
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "EnableScopeScans"))) || Utils::strcasecmp(method, "EnableScopeScans")==0)
	{
		CEnableScopeScansRequest::getMapInfo(context.queryMapInfo());
		CEnableScopeScansResponse::getMapInfo(context.queryMapInfo());
		CEnableScopeScansRequest::getXsdDefinition(context, request, "EnableScopeScansRequest", content, added);
		CEnableScopeScansResponse::getXsdDefinition(context, request, content, added);
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "FilePermission"))) || Utils::strcasecmp(method, "FilePermission")==0)
	{
		CFilePermissionRequest::getMapInfo(context.queryMapInfo());
		CFilePermissionResponse::getMapInfo(context.queryMapInfo());
		CFilePermissionRequest::getXsdDefinition(context, request, "FilePermissionRequest", content, added);
		CFilePermissionResponse::getXsdDefinition(context, request, content, added);
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "GroupAction"))) || Utils::strcasecmp(method, "GroupAction")==0)
	{
		CGroupActionRequest::getMapInfo(context.queryMapInfo());
		CGroupActionResponse::getMapInfo(context.queryMapInfo());
		CGroupActionRequest::getXsdDefinition(context, request, "GroupActionRequest", content, added);
		CGroupActionResponse::getXsdDefinition(context, request, content, added);
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "GroupAdd"))) || Utils::strcasecmp(method, "GroupAdd")==0)
	{
		CGroupAddRequest::getMapInfo(context.queryMapInfo());
		CGroupAddResponse::getMapInfo(context.queryMapInfo());
		CGroupAddRequest::getXsdDefinition(context, request, "GroupAddRequest", content, added);
		CGroupAddResponse::getXsdDefinition(context, request, content, added);
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "GroupEdit"))) || Utils::strcasecmp(method, "GroupEdit")==0)
	{
		CGroupEditRequest::getMapInfo(context.queryMapInfo());
		CGroupEditResponse::getMapInfo(context.queryMapInfo());
		CGroupEditRequest::getXsdDefinition(context, request, "GroupEditRequest", content, added);
		CGroupEditResponse::getXsdDefinition(context, request, content, added);
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "GroupMemberEdit"))) || Utils::strcasecmp(method, "GroupMemberEdit")==0)
	{
		CGroupMemberEditRequest::getMapInfo(context.queryMapInfo());
		CGroupMemberEditResponse::getMapInfo(context.queryMapInfo());
		CGroupMemberEditRequest::getXsdDefinition(context, request, "GroupMemberEditRequest", content, added);
		CGroupMemberEditResponse::getXsdDefinition(context, request, content, added);
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "GroupMemberEditInput"))) || Utils::strcasecmp(method, "GroupMemberEditInput")==0)
	{
		CGroupMemberEditInputRequest::getMapInfo(context.queryMapInfo());
		CGroupMemberEditInputResponse::getMapInfo(context.queryMapInfo());
		CGroupMemberEditInputRequest::getXsdDefinition(context, request, "GroupMemberEditInputRequest", content, added);
		CGroupMemberEditInputResponse::getXsdDefinition(context, request, content, added);
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "GroupMemberQuery"))) || Utils::strcasecmp(method, "GroupMemberQuery")==0)
	{
		CGroupMemberQueryRequest::getMapInfo(context.queryMapInfo());
		CGroupMemberQueryResponse::getMapInfo(context.queryMapInfo());
		CGroupMemberQueryRequest::getXsdDefinition(context, request, "GroupMemberQueryRequest", content, added);
		CGroupMemberQueryResponse::getXsdDefinition(context, request, content, added);
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "GroupQuery"))) || Utils::strcasecmp(method, "GroupQuery")==0)
	{
		CGroupQueryRequest::getMapInfo(context.queryMapInfo());
		CGroupQueryResponse::getMapInfo(context.queryMapInfo());
		CGroupQueryRequest::getXsdDefinition(context, request, "GroupQueryRequest", content, added);
		CGroupQueryResponse::getXsdDefinition(context, request, content, added);
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "Groups"))) || Utils::strcasecmp(method, "Groups")==0)
	{
		CGroupRequest::getMapInfo(context.queryMapInfo());
		CGroupResponse::getMapInfo(context.queryMapInfo());
		CGroupRequest::getXsdDefinition(context, request, "GroupRequest", content, added);
		CGroupResponse::getXsdDefinition(context, request, content, added);
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "PermissionAction"))) || Utils::strcasecmp(method, "PermissionAction")==0)
	{
		CPermissionActionRequest::getMapInfo(context.queryMapInfo());
		CPermissionActionResponse::getMapInfo(context.queryMapInfo());
		CPermissionActionRequest::getXsdDefinition(context, request, "PermissionActionRequest", content, added);
		CPermissionActionResponse::getXsdDefinition(context, request, content, added);
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "PermissionAddInput"))) || Utils::strcasecmp(method, "PermissionAddInput")==0)
	{
		CPermissionAddRequest::getMapInfo(context.queryMapInfo());
		CPermissionAddResponse::getMapInfo(context.queryMapInfo());
		CPermissionAddRequest::getXsdDefinition(context, request, "PermissionAddRequest", content, added);
		CPermissionAddResponse::getXsdDefinition(context, request, content, added);
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "Permissions"))) || Utils::strcasecmp(method, "Permissions")==0)
	{
		CBasednsRequest::getMapInfo(context.queryMapInfo());
		CBasednsResponse::getMapInfo(context.queryMapInfo());
		CBasednsRequest::getXsdDefinition(context, request, "BasednsRequest", content, added);
		CBasednsResponse::getXsdDefinition(context, request, content, added);
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "PermissionsReset"))) || Utils::strcasecmp(method, "PermissionsReset")==0)
	{
		CPermissionsResetRequest::getMapInfo(context.queryMapInfo());
		CPermissionsResetResponse::getMapInfo(context.queryMapInfo());
		CPermissionsResetRequest::getXsdDefinition(context, request, "PermissionsResetRequest", content, added);
		CPermissionsResetResponse::getXsdDefinition(context, request, content, added);
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "PermissionsResetInput"))) || Utils::strcasecmp(method, "PermissionsResetInput")==0)
	{
		CPermissionsResetInputRequest::getMapInfo(context.queryMapInfo());
		CPermissionsResetInputResponse::getMapInfo(context.queryMapInfo());
		CPermissionsResetInputRequest::getXsdDefinition(context, request, "PermissionsResetInputRequest", content, added);
		CPermissionsResetInputResponse::getXsdDefinition(context, request, content, added);
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "Ping"))) || Utils::strcasecmp(method, "Ping")==0)
	{
		Cws_accessPingRequest::getMapInfo(context.queryMapInfo());
		Cws_accessPingResponse::getMapInfo(context.queryMapInfo());
		Cws_accessPingRequest::getXsdDefinition(context, request, "ws_accessPingRequest", content, added);
		Cws_accessPingResponse::getXsdDefinition(context, request, content, added);
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "QueryScopeScansEnabled"))) || Utils::strcasecmp(method, "QueryScopeScansEnabled")==0)
	{
		CQueryScopeScansEnabledRequest::getMapInfo(context.queryMapInfo());
		CQueryScopeScansEnabledResponse::getMapInfo(context.queryMapInfo());
		CQueryScopeScansEnabledRequest::getXsdDefinition(context, request, "QueryScopeScansEnabledRequest", content, added);
		CQueryScopeScansEnabledResponse::getXsdDefinition(context, request, content, added);
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "QueryUserViewColumns"))) || Utils::strcasecmp(method, "QueryUserViewColumns")==0)
	{
		if (context.getClientVersion()>=1.1) {
			CQueryUserViewColumnsRequest::getMapInfo(context.queryMapInfo());
			CQueryUserViewColumnsResponse::getMapInfo(context.queryMapInfo());
			CQueryUserViewColumnsRequest::getXsdDefinition(context, request, "QueryUserViewColumnsRequest", content, added);
			CQueryUserViewColumnsResponse::getXsdDefinition(context, request, content, added);
		}
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "QueryViewColumns"))) || Utils::strcasecmp(method, "QueryViewColumns")==0)
	{
		if (context.getClientVersion()>=1.1) {
			CQueryViewColumnsRequest::getMapInfo(context.queryMapInfo());
			CQueryViewColumnsResponse::getMapInfo(context.queryMapInfo());
			CQueryViewColumnsRequest::getXsdDefinition(context, request, "QueryViewColumnsRequest", content, added);
			CQueryViewColumnsResponse::getXsdDefinition(context, request, content, added);
		}
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "QueryViewMembers"))) || Utils::strcasecmp(method, "QueryViewMembers")==0)
	{
		if (context.getClientVersion()>=1.1) {
			CQueryViewMembersRequest::getMapInfo(context.queryMapInfo());
			CQueryViewMembersResponse::getMapInfo(context.queryMapInfo());
			CQueryViewMembersRequest::getXsdDefinition(context, request, "QueryViewMembersRequest", content, added);
			CQueryViewMembersResponse::getXsdDefinition(context, request, content, added);
		}
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "QueryViews"))) || Utils::strcasecmp(method, "QueryViews")==0)
	{
		if (context.getClientVersion()>=1.1) {
			CQueryViewsRequest::getMapInfo(context.queryMapInfo());
			CQueryViewsResponse::getMapInfo(context.queryMapInfo());
			CQueryViewsRequest::getXsdDefinition(context, request, "QueryViewsRequest", content, added);
			CQueryViewsResponse::getXsdDefinition(context, request, content, added);
		}
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "ResourceAdd"))) || Utils::strcasecmp(method, "ResourceAdd")==0)
	{
		CResourceAddRequest::getMapInfo(context.queryMapInfo());
		CResourceAddResponse::getMapInfo(context.queryMapInfo());
		CResourceAddRequest::getXsdDefinition(context, request, "ResourceAddRequest", content, added);
		CResourceAddResponse::getXsdDefinition(context, request, content, added);
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "ResourceAddInput"))) || Utils::strcasecmp(method, "ResourceAddInput")==0)
	{
		CResourceAddInputRequest::getMapInfo(context.queryMapInfo());
		CResourceAddInputResponse::getMapInfo(context.queryMapInfo());
		CResourceAddInputRequest::getXsdDefinition(context, request, "ResourceAddInputRequest", content, added);
		CResourceAddInputResponse::getXsdDefinition(context, request, content, added);
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "ResourceDelete"))) || Utils::strcasecmp(method, "ResourceDelete")==0)
	{
		CResourceDeleteRequest::getMapInfo(context.queryMapInfo());
		CResourceDeleteResponse::getMapInfo(context.queryMapInfo());
		CResourceDeleteRequest::getXsdDefinition(context, request, "ResourceDeleteRequest", content, added);
		CResourceDeleteResponse::getXsdDefinition(context, request, content, added);
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "ResourcePermissionQuery"))) || Utils::strcasecmp(method, "ResourcePermissionQuery")==0)
	{
		if (context.getClientVersion()>=1.11) {
			CResourcePermissionQueryRequest::getMapInfo(context.queryMapInfo());
			CResourcePermissionQueryResponse::getMapInfo(context.queryMapInfo());
			CResourcePermissionQueryRequest::getXsdDefinition(context, request, "ResourcePermissionQueryRequest", content, added);
			CResourcePermissionQueryResponse::getXsdDefinition(context, request, content, added);
		}
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "ResourcePermissions"))) || Utils::strcasecmp(method, "ResourcePermissions")==0)
	{
		CResourcePermissionsRequest::getMapInfo(context.queryMapInfo());
		CResourcePermissionsResponse::getMapInfo(context.queryMapInfo());
		CResourcePermissionsRequest::getXsdDefinition(context, request, "ResourcePermissionsRequest", content, added);
		CResourcePermissionsResponse::getXsdDefinition(context, request, content, added);
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "ResourceQuery"))) || Utils::strcasecmp(method, "ResourceQuery")==0)
	{
		CResourceQueryRequest::getMapInfo(context.queryMapInfo());
		CResourceQueryResponse::getMapInfo(context.queryMapInfo());
		CResourceQueryRequest::getXsdDefinition(context, request, "ResourceQueryRequest", content, added);
		CResourceQueryResponse::getXsdDefinition(context, request, content, added);
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "Resources"))) || Utils::strcasecmp(method, "Resources")==0)
	{
		CResourcesRequest::getMapInfo(context.queryMapInfo());
		CResourcesResponse::getMapInfo(context.queryMapInfo());
		CResourcesRequest::getXsdDefinition(context, request, "ResourcesRequest", content, added);
		CResourcesResponse::getXsdDefinition(context, request, content, added);
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "UserAccountExport"))) || Utils::strcasecmp(method, "UserAccountExport")==0)
	{
		CUserAccountExportRequest::getMapInfo(context.queryMapInfo());
		CUserAccountExportResponse::getMapInfo(context.queryMapInfo());
		CUserAccountExportRequest::getXsdDefinition(context, request, "UserAccountExportRequest", content, added);
		CUserAccountExportResponse::getXsdDefinition(context, request, content, added);
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "UserAction"))) || Utils::strcasecmp(method, "UserAction")==0)
	{
		CUserActionRequest::getMapInfo(context.queryMapInfo());
		CUserActionResponse::getMapInfo(context.queryMapInfo());
		CUserActionRequest::getXsdDefinition(context, request, "UserActionRequest", content, added);
		CUserActionResponse::getXsdDefinition(context, request, content, added);
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "UserEdit"))) || Utils::strcasecmp(method, "UserEdit")==0)
	{
		CUserEditRequest::getMapInfo(context.queryMapInfo());
		CUserEditResponse::getMapInfo(context.queryMapInfo());
		CUserEditRequest::getXsdDefinition(context, request, "UserEditRequest", content, added);
		CUserEditResponse::getXsdDefinition(context, request, content, added);
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "UserGroupEdit"))) || Utils::strcasecmp(method, "UserGroupEdit")==0)
	{
		CUserGroupEditRequest::getMapInfo(context.queryMapInfo());
		CUserGroupEditResponse::getMapInfo(context.queryMapInfo());
		CUserGroupEditRequest::getXsdDefinition(context, request, "UserGroupEditRequest", content, added);
		CUserGroupEditResponse::getXsdDefinition(context, request, content, added);
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "UserGroupEditInput"))) || Utils::strcasecmp(method, "UserGroupEditInput")==0)
	{
		CUserGroupEditInputRequest::getMapInfo(context.queryMapInfo());
		CUserGroupEditInputResponse::getMapInfo(context.queryMapInfo());
		CUserGroupEditInputRequest::getXsdDefinition(context, request, "UserGroupEditInputRequest", content, added);
		CUserGroupEditInputResponse::getXsdDefinition(context, request, content, added);
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "UserInfoEdit"))) || Utils::strcasecmp(method, "UserInfoEdit")==0)
	{
		CUserInfoEditRequest::getMapInfo(context.queryMapInfo());
		CUserInfoEditResponse::getMapInfo(context.queryMapInfo());
		CUserInfoEditRequest::getXsdDefinition(context, request, "UserInfoEditRequest", content, added);
		CUserInfoEditResponse::getXsdDefinition(context, request, content, added);
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "UserInfoEditInput"))) || Utils::strcasecmp(method, "UserInfoEditInput")==0)
	{
		CUserInfoEditInputRequest::getMapInfo(context.queryMapInfo());
		CUserInfoEditInputResponse::getMapInfo(context.queryMapInfo());
		CUserInfoEditInputRequest::getXsdDefinition(context, request, "UserInfoEditInputRequest", content, added);
		CUserInfoEditInputResponse::getXsdDefinition(context, request, content, added);
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "UserPosix"))) || Utils::strcasecmp(method, "UserPosix")==0)
	{
		CUserPosixRequest::getMapInfo(context.queryMapInfo());
		CUserPosixResponse::getMapInfo(context.queryMapInfo());
		CUserPosixRequest::getXsdDefinition(context, request, "UserPosixRequest", content, added);
		CUserPosixResponse::getXsdDefinition(context, request, content, added);
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "UserPosixInput"))) || Utils::strcasecmp(method, "UserPosixInput")==0)
	{
		CUserPosixInputRequest::getMapInfo(context.queryMapInfo());
		CUserPosixInputResponse::getMapInfo(context.queryMapInfo());
		CUserPosixInputRequest::getXsdDefinition(context, request, "UserPosixInputRequest", content, added);
		CUserPosixInputResponse::getXsdDefinition(context, request, content, added);
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "UserQuery"))) || Utils::strcasecmp(method, "UserQuery")==0)
	{
		CUserQueryRequest::getMapInfo(context.queryMapInfo());
		CUserQueryResponse::getMapInfo(context.queryMapInfo());
		CUserQueryRequest::getXsdDefinition(context, request, "UserQueryRequest", content, added);
		CUserQueryResponse::getXsdDefinition(context, request, content, added);
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "UserResetPass"))) || Utils::strcasecmp(method, "UserResetPass")==0)
	{
		CUserResetPassRequest::getMapInfo(context.queryMapInfo());
		CUserResetPassResponse::getMapInfo(context.queryMapInfo());
		CUserResetPassRequest::getXsdDefinition(context, request, "UserResetPassRequest", content, added);
		CUserResetPassResponse::getXsdDefinition(context, request, content, added);
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "UserResetPassInput"))) || Utils::strcasecmp(method, "UserResetPassInput")==0)
	{
		CUserResetPassInputRequest::getMapInfo(context.queryMapInfo());
		CUserResetPassInputResponse::getMapInfo(context.queryMapInfo());
		CUserResetPassInputRequest::getXsdDefinition(context, request, "UserResetPassInputRequest", content, added);
		CUserResetPassInputResponse::getXsdDefinition(context, request, content, added);
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "UserSudoers"))) || Utils::strcasecmp(method, "UserSudoers")==0)
	{
		CUserSudoersRequest::getMapInfo(context.queryMapInfo());
		CUserSudoersResponse::getMapInfo(context.queryMapInfo());
		CUserSudoersRequest::getXsdDefinition(context, request, "UserSudoersRequest", content, added);
		CUserSudoersResponse::getXsdDefinition(context, request, content, added);
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "UserSudoersInput"))) || Utils::strcasecmp(method, "UserSudoersInput")==0)
	{
		CUserSudoersInputRequest::getMapInfo(context.queryMapInfo());
		CUserSudoersInputResponse::getMapInfo(context.queryMapInfo());
		CUserSudoersInputRequest::getXsdDefinition(context, request, "UserSudoersInputRequest", content, added);
		CUserSudoersInputResponse::getXsdDefinition(context, request, content, added);
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "Users"))) || Utils::strcasecmp(method, "Users")==0)
	{
		CUserRequest::getMapInfo(context.queryMapInfo());
		CUserResponse::getMapInfo(context.queryMapInfo());
		CUserRequest::getXsdDefinition(context, request, "UserRequest", content, added);
		CUserResponse::getXsdDefinition(context, request, content, added);
	}
	return 0;
}

int Cws_accessSoapBinding::getMethodHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &page, bool bIncludeFormTag)
{
	DBGLOG("Client version: %g", context.getClientVersion());
	if (Utils::strcasecmp(method, "AccountPermissions")==0)
	{
		CAccountPermissionsRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "AddUser")==0)
	{
		CAddUserRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "AddView")==0)
	{
		CAddViewRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "AddViewColumn")==0)
	{
		CAddViewColumnRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "AddViewMember")==0)
	{
		CAddViewMemberRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "ClearPermissionsCache")==0)
	{
		CClearPermissionsCacheRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "DeleteView")==0)
	{
		CDeleteViewRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "DeleteViewColumn")==0)
	{
		CDeleteViewColumnRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "DeleteViewMember")==0)
	{
		CDeleteViewMemberRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "DisableScopeScans")==0)
	{
		CDisableScopeScansRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "EnableScopeScans")==0)
	{
		CEnableScopeScansRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "FilePermission")==0)
	{
		CFilePermissionRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "GroupAction")==0)
	{
		CGroupActionRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "GroupAdd")==0)
	{
		CGroupAddRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "GroupEdit")==0)
	{
		CGroupEditRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "GroupMemberEdit")==0)
	{
		CGroupMemberEditRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "GroupMemberEditInput")==0)
	{
		CGroupMemberEditInputRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "GroupMemberQuery")==0)
	{
		CGroupMemberQueryRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "GroupQuery")==0)
	{
		CGroupQueryRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "Groups")==0)
	{
		CGroupRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "PermissionAction")==0)
	{
		CPermissionActionRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "PermissionAddInput")==0)
	{
		CPermissionAddRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "Permissions")==0)
	{
		CBasednsRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "PermissionsReset")==0)
	{
		CPermissionsResetRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "PermissionsResetInput")==0)
	{
		CPermissionsResetInputRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "Ping")==0)
	{
		Cws_accessPingRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "QueryScopeScansEnabled")==0)
	{
		CQueryScopeScansEnabledRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "QueryUserViewColumns")==0)
	{
		CQueryUserViewColumnsRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "QueryViewColumns")==0)
	{
		CQueryViewColumnsRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "QueryViewMembers")==0)
	{
		CQueryViewMembersRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "QueryViews")==0)
	{
		CQueryViewsRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "ResourceAdd")==0)
	{
		CResourceAddRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "ResourceAddInput")==0)
	{
		CResourceAddInputRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "ResourceDelete")==0)
	{
		CResourceDeleteRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "ResourcePermissionQuery")==0)
	{
		CResourcePermissionQueryRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "ResourcePermissions")==0)
	{
		CResourcePermissionsRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "ResourceQuery")==0)
	{
		CResourceQueryRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "Resources")==0)
	{
		CResourcesRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "UserAccountExport")==0)
	{
		CUserAccountExportRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "UserAction")==0)
	{
		CUserActionRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "UserEdit")==0)
	{
		CUserEditRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "UserGroupEdit")==0)
	{
		CUserGroupEditRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "UserGroupEditInput")==0)
	{
		CUserGroupEditInputRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "UserInfoEdit")==0)
	{
		CUserInfoEditRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "UserInfoEditInput")==0)
	{
		CUserInfoEditInputRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "UserPosix")==0)
	{
		CUserPosixRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "UserPosixInput")==0)
	{
		CUserPosixInputRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "UserQuery")==0)
	{
		CUserQueryRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "UserResetPass")==0)
	{
		CUserResetPassRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "UserResetPassInput")==0)
	{
		CUserResetPassInputRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "UserSudoers")==0)
	{
		CUserSudoersRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "UserSudoersInput")==0)
	{
		CUserSudoersInputRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "Users")==0)
	{
		CUserRequest::getHtmlForm(context, request, serv, method, page);
	}
	return 0;
}

int Cws_accessSoapBinding::getQualifiedNames(IEspContext& ctx, MethodInfoArray & methods)
{
	double ver = ctx.getClientVersion();
	if (ver<=0)
		ver = getWsdlVersion();
	const char *servname=ctx.queryServiceName(NULL);
	bool fullservice = (!stricmp(servname, "esp")||!stricmp(servname, "ws_access"));
	if ((fullservice || isMethodInSubService(ctx, servname, "AccountPermissions")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("AccountPermissions", "AccountPermissionsRequest", "AccountPermissionsResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "AddUser")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("AddUser", "AddUserRequest", "AddUserResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "AddView")) && ctx.isMethodAllowed(ver,NULL, NULL, 1.1, -1))
		methods.append(*new CMethodInfo("AddView", "AddViewRequest", "AddViewResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "AddViewColumn")) && ctx.isMethodAllowed(ver,NULL, NULL, 1.1, -1))
		methods.append(*new CMethodInfo("AddViewColumn", "AddViewColumnRequest", "AddViewColumnResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "AddViewMember")) && ctx.isMethodAllowed(ver,NULL, NULL, 1.1, -1))
		methods.append(*new CMethodInfo("AddViewMember", "AddViewMemberRequest", "AddViewMemberResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "ClearPermissionsCache")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("ClearPermissionsCache", "ClearPermissionsCacheRequest", "ClearPermissionsCacheResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "DeleteView")) && ctx.isMethodAllowed(ver,NULL, NULL, 1.1, -1))
		methods.append(*new CMethodInfo("DeleteView", "DeleteViewRequest", "DeleteViewResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "DeleteViewColumn")) && ctx.isMethodAllowed(ver,NULL, NULL, 1.1, -1))
		methods.append(*new CMethodInfo("DeleteViewColumn", "DeleteViewColumnRequest", "DeleteViewColumnResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "DeleteViewMember")) && ctx.isMethodAllowed(ver,NULL, NULL, 1.1, -1))
		methods.append(*new CMethodInfo("DeleteViewMember", "DeleteViewMemberRequest", "DeleteViewMemberResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "DisableScopeScans")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("DisableScopeScans", "DisableScopeScansRequest", "DisableScopeScansResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "EnableScopeScans")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("EnableScopeScans", "EnableScopeScansRequest", "EnableScopeScansResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "FilePermission")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("FilePermission", "FilePermissionRequest", "FilePermissionResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "GroupAction")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("GroupAction", "GroupActionRequest", "GroupActionResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "GroupAdd")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("GroupAdd", "GroupAddRequest", "GroupAddResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "GroupEdit")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("GroupEdit", "GroupEditRequest", "GroupEditResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "GroupMemberEdit")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("GroupMemberEdit", "GroupMemberEditRequest", "GroupMemberEditResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "GroupMemberEditInput")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("GroupMemberEditInput", "GroupMemberEditInputRequest", "GroupMemberEditInputResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "GroupMemberQuery")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("GroupMemberQuery", "GroupMemberQueryRequest", "GroupMemberQueryResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "GroupQuery")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("GroupQuery", "GroupQueryRequest", "GroupQueryResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "Groups")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("Groups", "GroupRequest", "GroupResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "PermissionAction")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("PermissionAction", "PermissionActionRequest", "PermissionActionResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "PermissionAddInput")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("PermissionAddInput", "PermissionAddRequest", "PermissionAddResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "Permissions")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("Permissions", "BasednsRequest", "BasednsResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "PermissionsReset")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("PermissionsReset", "PermissionsResetRequest", "PermissionsResetResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "PermissionsResetInput")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("PermissionsResetInput", "PermissionsResetInputRequest", "PermissionsResetInputResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "Ping")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("Ping", "ws_accessPingRequest", "ws_accessPingResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "QueryScopeScansEnabled")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("QueryScopeScansEnabled", "QueryScopeScansEnabledRequest", "QueryScopeScansEnabledResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "QueryUserViewColumns")) && ctx.isMethodAllowed(ver,NULL, NULL, 1.1, -1))
		methods.append(*new CMethodInfo("QueryUserViewColumns", "QueryUserViewColumnsRequest", "QueryUserViewColumnsResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "QueryViewColumns")) && ctx.isMethodAllowed(ver,NULL, NULL, 1.1, -1))
		methods.append(*new CMethodInfo("QueryViewColumns", "QueryViewColumnsRequest", "QueryViewColumnsResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "QueryViewMembers")) && ctx.isMethodAllowed(ver,NULL, NULL, 1.1, -1))
		methods.append(*new CMethodInfo("QueryViewMembers", "QueryViewMembersRequest", "QueryViewMembersResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "QueryViews")) && ctx.isMethodAllowed(ver,NULL, NULL, 1.1, -1))
		methods.append(*new CMethodInfo("QueryViews", "QueryViewsRequest", "QueryViewsResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "ResourceAdd")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("ResourceAdd", "ResourceAddRequest", "ResourceAddResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "ResourceAddInput")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("ResourceAddInput", "ResourceAddInputRequest", "ResourceAddInputResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "ResourceDelete")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("ResourceDelete", "ResourceDeleteRequest", "ResourceDeleteResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "ResourcePermissionQuery")) && ctx.isMethodAllowed(ver,NULL, NULL, 1.11, -1))
		methods.append(*new CMethodInfo("ResourcePermissionQuery", "ResourcePermissionQueryRequest", "ResourcePermissionQueryResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "ResourcePermissions")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("ResourcePermissions", "ResourcePermissionsRequest", "ResourcePermissionsResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "ResourceQuery")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("ResourceQuery", "ResourceQueryRequest", "ResourceQueryResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "Resources")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("Resources", "ResourcesRequest", "ResourcesResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "UserAccountExport")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("UserAccountExport", "UserAccountExportRequest", "UserAccountExportResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "UserAction")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("UserAction", "UserActionRequest", "UserActionResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "UserEdit")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("UserEdit", "UserEditRequest", "UserEditResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "UserGroupEdit")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("UserGroupEdit", "UserGroupEditRequest", "UserGroupEditResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "UserGroupEditInput")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("UserGroupEditInput", "UserGroupEditInputRequest", "UserGroupEditInputResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "UserInfoEdit")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("UserInfoEdit", "UserInfoEditRequest", "UserInfoEditResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "UserInfoEditInput")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("UserInfoEditInput", "UserInfoEditInputRequest", "UserInfoEditInputResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "UserPosix")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("UserPosix", "UserPosixRequest", "UserPosixResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "UserPosixInput")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("UserPosixInput", "UserPosixInputRequest", "UserPosixInputResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "UserQuery")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("UserQuery", "UserQueryRequest", "UserQueryResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "UserResetPass")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("UserResetPass", "UserResetPassRequest", "UserResetPassResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "UserResetPassInput")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("UserResetPassInput", "UserResetPassInputRequest", "UserResetPassInputResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "UserSudoers")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("UserSudoers", "UserSudoersRequest", "UserSudoersResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "UserSudoersInput")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("UserSudoersInput", "UserSudoersInputRequest", "UserSudoersInputResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "Users")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("Users", "UserRequest", "UserResponse"));
	return methods.ordinality();
}

StringBuffer & Cws_accessSoapBinding::getServiceName(StringBuffer &resp)
{
	resp.append("ws_access");
	return resp;
}

bool Cws_accessSoapBinding::isValidServiceName(IEspContext &context, const char *name)
{
	if (!Utils::strcasecmp(name, "ws_access"))
		return true;
	else
		return (hasSubService(context, name));
}

bool Cws_accessSoapBinding::qualifyMethodName(IEspContext &context, const char *methname, StringBuffer *methQName)
{
	if (!methname || !*methname)
	{
		if (methQName!=NULL)
			methQName->clear();
		return true;
	}
	if (Utils::strcasecmp(methname, "AccountPermissions")==0)
	{
		if (methQName!=NULL)
			methQName->set("AccountPermissions");
		return true;
	}
	if (Utils::strcasecmp(methname, "AddUser")==0)
	{
		if (methQName!=NULL)
			methQName->set("AddUser");
		return true;
	}
	if (Utils::strcasecmp(methname, "AddView")==0)
	{
		if (methQName!=NULL)
			methQName->set("AddView");
		return true;
	}
	if (Utils::strcasecmp(methname, "AddViewColumn")==0)
	{
		if (methQName!=NULL)
			methQName->set("AddViewColumn");
		return true;
	}
	if (Utils::strcasecmp(methname, "AddViewMember")==0)
	{
		if (methQName!=NULL)
			methQName->set("AddViewMember");
		return true;
	}
	if (Utils::strcasecmp(methname, "ClearPermissionsCache")==0)
	{
		if (methQName!=NULL)
			methQName->set("ClearPermissionsCache");
		return true;
	}
	if (Utils::strcasecmp(methname, "DeleteView")==0)
	{
		if (methQName!=NULL)
			methQName->set("DeleteView");
		return true;
	}
	if (Utils::strcasecmp(methname, "DeleteViewColumn")==0)
	{
		if (methQName!=NULL)
			methQName->set("DeleteViewColumn");
		return true;
	}
	if (Utils::strcasecmp(methname, "DeleteViewMember")==0)
	{
		if (methQName!=NULL)
			methQName->set("DeleteViewMember");
		return true;
	}
	if (Utils::strcasecmp(methname, "DisableScopeScans")==0)
	{
		if (methQName!=NULL)
			methQName->set("DisableScopeScans");
		return true;
	}
	if (Utils::strcasecmp(methname, "EnableScopeScans")==0)
	{
		if (methQName!=NULL)
			methQName->set("EnableScopeScans");
		return true;
	}
	if (Utils::strcasecmp(methname, "FilePermission")==0)
	{
		if (methQName!=NULL)
			methQName->set("FilePermission");
		return true;
	}
	if (Utils::strcasecmp(methname, "GroupAction")==0)
	{
		if (methQName!=NULL)
			methQName->set("GroupAction");
		return true;
	}
	if (Utils::strcasecmp(methname, "GroupAdd")==0)
	{
		if (methQName!=NULL)
			methQName->set("GroupAdd");
		return true;
	}
	if (Utils::strcasecmp(methname, "GroupEdit")==0)
	{
		if (methQName!=NULL)
			methQName->set("GroupEdit");
		return true;
	}
	if (Utils::strcasecmp(methname, "GroupMemberEdit")==0)
	{
		if (methQName!=NULL)
			methQName->set("GroupMemberEdit");
		return true;
	}
	if (Utils::strcasecmp(methname, "GroupMemberEditInput")==0)
	{
		if (methQName!=NULL)
			methQName->set("GroupMemberEditInput");
		return true;
	}
	if (Utils::strcasecmp(methname, "GroupMemberQuery")==0)
	{
		if (methQName!=NULL)
			methQName->set("GroupMemberQuery");
		return true;
	}
	if (Utils::strcasecmp(methname, "GroupQuery")==0)
	{
		if (methQName!=NULL)
			methQName->set("GroupQuery");
		return true;
	}
	if (Utils::strcasecmp(methname, "Groups")==0)
	{
		if (methQName!=NULL)
			methQName->set("Groups");
		return true;
	}
	if (Utils::strcasecmp(methname, "PermissionAction")==0)
	{
		if (methQName!=NULL)
			methQName->set("PermissionAction");
		return true;
	}
	if (Utils::strcasecmp(methname, "PermissionAddInput")==0)
	{
		if (methQName!=NULL)
			methQName->set("PermissionAddInput");
		return true;
	}
	if (Utils::strcasecmp(methname, "Permissions")==0)
	{
		if (methQName!=NULL)
			methQName->set("Permissions");
		return true;
	}
	if (Utils::strcasecmp(methname, "PermissionsReset")==0)
	{
		if (methQName!=NULL)
			methQName->set("PermissionsReset");
		return true;
	}
	if (Utils::strcasecmp(methname, "PermissionsResetInput")==0)
	{
		if (methQName!=NULL)
			methQName->set("PermissionsResetInput");
		return true;
	}
	if (Utils::strcasecmp(methname, "Ping")==0)
	{
		if (methQName!=NULL)
			methQName->set("Ping");
		return true;
	}
	if (Utils::strcasecmp(methname, "QueryScopeScansEnabled")==0)
	{
		if (methQName!=NULL)
			methQName->set("QueryScopeScansEnabled");
		return true;
	}
	if (Utils::strcasecmp(methname, "QueryUserViewColumns")==0)
	{
		if (methQName!=NULL)
			methQName->set("QueryUserViewColumns");
		return true;
	}
	if (Utils::strcasecmp(methname, "QueryViewColumns")==0)
	{
		if (methQName!=NULL)
			methQName->set("QueryViewColumns");
		return true;
	}
	if (Utils::strcasecmp(methname, "QueryViewMembers")==0)
	{
		if (methQName!=NULL)
			methQName->set("QueryViewMembers");
		return true;
	}
	if (Utils::strcasecmp(methname, "QueryViews")==0)
	{
		if (methQName!=NULL)
			methQName->set("QueryViews");
		return true;
	}
	if (Utils::strcasecmp(methname, "ResourceAdd")==0)
	{
		if (methQName!=NULL)
			methQName->set("ResourceAdd");
		return true;
	}
	if (Utils::strcasecmp(methname, "ResourceAddInput")==0)
	{
		if (methQName!=NULL)
			methQName->set("ResourceAddInput");
		return true;
	}
	if (Utils::strcasecmp(methname, "ResourceDelete")==0)
	{
		if (methQName!=NULL)
			methQName->set("ResourceDelete");
		return true;
	}
	if (Utils::strcasecmp(methname, "ResourcePermissionQuery")==0)
	{
		if (methQName!=NULL)
			methQName->set("ResourcePermissionQuery");
		return true;
	}
	if (Utils::strcasecmp(methname, "ResourcePermissions")==0)
	{
		if (methQName!=NULL)
			methQName->set("ResourcePermissions");
		return true;
	}
	if (Utils::strcasecmp(methname, "ResourceQuery")==0)
	{
		if (methQName!=NULL)
			methQName->set("ResourceQuery");
		return true;
	}
	if (Utils::strcasecmp(methname, "Resources")==0)
	{
		if (methQName!=NULL)
			methQName->set("Resources");
		return true;
	}
	if (Utils::strcasecmp(methname, "UserAccountExport")==0)
	{
		if (methQName!=NULL)
			methQName->set("UserAccountExport");
		return true;
	}
	if (Utils::strcasecmp(methname, "UserAction")==0)
	{
		if (methQName!=NULL)
			methQName->set("UserAction");
		return true;
	}
	if (Utils::strcasecmp(methname, "UserEdit")==0)
	{
		if (methQName!=NULL)
			methQName->set("UserEdit");
		return true;
	}
	if (Utils::strcasecmp(methname, "UserGroupEdit")==0)
	{
		if (methQName!=NULL)
			methQName->set("UserGroupEdit");
		return true;
	}
	if (Utils::strcasecmp(methname, "UserGroupEditInput")==0)
	{
		if (methQName!=NULL)
			methQName->set("UserGroupEditInput");
		return true;
	}
	if (Utils::strcasecmp(methname, "UserInfoEdit")==0)
	{
		if (methQName!=NULL)
			methQName->set("UserInfoEdit");
		return true;
	}
	if (Utils::strcasecmp(methname, "UserInfoEditInput")==0)
	{
		if (methQName!=NULL)
			methQName->set("UserInfoEditInput");
		return true;
	}
	if (Utils::strcasecmp(methname, "UserPosix")==0)
	{
		if (methQName!=NULL)
			methQName->set("UserPosix");
		return true;
	}
	if (Utils::strcasecmp(methname, "UserPosixInput")==0)
	{
		if (methQName!=NULL)
			methQName->set("UserPosixInput");
		return true;
	}
	if (Utils::strcasecmp(methname, "UserQuery")==0)
	{
		if (methQName!=NULL)
			methQName->set("UserQuery");
		return true;
	}
	if (Utils::strcasecmp(methname, "UserResetPass")==0)
	{
		if (methQName!=NULL)
			methQName->set("UserResetPass");
		return true;
	}
	if (Utils::strcasecmp(methname, "UserResetPassInput")==0)
	{
		if (methQName!=NULL)
			methQName->set("UserResetPassInput");
		return true;
	}
	if (Utils::strcasecmp(methname, "UserSudoers")==0)
	{
		if (methQName!=NULL)
			methQName->set("UserSudoers");
		return true;
	}
	if (Utils::strcasecmp(methname, "UserSudoersInput")==0)
	{
		if (methQName!=NULL)
			methQName->set("UserSudoersInput");
		return true;
	}
	if (Utils::strcasecmp(methname, "Users")==0)
	{
		if (methQName!=NULL)
			methQName->set("Users");
		return true;
	}
	return false;
}

bool Cws_accessSoapBinding::qualifyServiceName(IEspContext &context, const char *servname, const char *methname, StringBuffer &servQName, StringBuffer *methQName)
{
	servQName.clear();
	if (!Utils::strcasecmp(servname, "ws_access"))
	{
		servQName.append("ws_access");
		return qualifyMethodName(context, methname, methQName);
	}
	return qualifySubServiceName(context, servname, methname, servQName, methQName);
}

int Cws_accessSoapBinding::onGetFile(IEspContext &context, CHttpRequest* request, CHttpResponse* response, const char *pathex)
{
	if(request == NULL || response == NULL)
		return -1;
	StringBuffer mimetype;
	MemoryBuffer content;

	StringBuffer filepath;
	getBaseFilePath(filepath);
	if (strchr("\\/", filepath.charAt(filepath.length()-1))==NULL)
		filepath.append("/");
	filepath.append(pathex);
	response->httpContentFromFile(filepath.str());
	response->send();
	return 0;
}

int Cws_accessSoapBinding::onGetForm(IEspContext &context, CHttpRequest* request, CHttpResponse* response, const char *service, const char *method)
{
	if (context.getClientVersion()<=0)
		context.setClientVersion(1.12);

	if (!stricmp("AccountPermissions", method)) {
		CAccountPermissionsRequest::getMapInfo(context.queryMapInfo());
		CAccountPermissionsResponse::getMapInfo(context.queryMapInfo());
	}
	if (!stricmp("AddUser", method)) {
		CAddUserRequest::getMapInfo(context.queryMapInfo());
		CAddUserResponse::getMapInfo(context.queryMapInfo());
	}
	if (!stricmp("AddView", method)) {
		CAddViewRequest::getMapInfo(context.queryMapInfo());
		CAddViewResponse::getMapInfo(context.queryMapInfo());
	}
	if (!stricmp("AddViewColumn", method)) {
		CAddViewColumnRequest::getMapInfo(context.queryMapInfo());
		CAddViewColumnResponse::getMapInfo(context.queryMapInfo());
	}
	if (!stricmp("AddViewMember", method)) {
		CAddViewMemberRequest::getMapInfo(context.queryMapInfo());
		CAddViewMemberResponse::getMapInfo(context.queryMapInfo());
	}
	if (!stricmp("ClearPermissionsCache", method)) {
		CClearPermissionsCacheRequest::getMapInfo(context.queryMapInfo());
		CClearPermissionsCacheResponse::getMapInfo(context.queryMapInfo());
	}
	if (!stricmp("DeleteView", method)) {
		CDeleteViewRequest::getMapInfo(context.queryMapInfo());
		CDeleteViewResponse::getMapInfo(context.queryMapInfo());
	}
	if (!stricmp("DeleteViewColumn", method)) {
		CDeleteViewColumnRequest::getMapInfo(context.queryMapInfo());
		CDeleteViewColumnResponse::getMapInfo(context.queryMapInfo());
	}
	if (!stricmp("DeleteViewMember", method)) {
		CDeleteViewMemberRequest::getMapInfo(context.queryMapInfo());
		CDeleteViewMemberResponse::getMapInfo(context.queryMapInfo());
	}
	if (!stricmp("DisableScopeScans", method)) {
		CDisableScopeScansRequest::getMapInfo(context.queryMapInfo());
		CDisableScopeScansResponse::getMapInfo(context.queryMapInfo());
	}
	if (!stricmp("EnableScopeScans", method)) {
		CEnableScopeScansRequest::getMapInfo(context.queryMapInfo());
		CEnableScopeScansResponse::getMapInfo(context.queryMapInfo());
	}
	if (!stricmp("FilePermission", method)) {
		CFilePermissionRequest::getMapInfo(context.queryMapInfo());
		CFilePermissionResponse::getMapInfo(context.queryMapInfo());
	}
	if (!stricmp("GroupAction", method)) {
		CGroupActionRequest::getMapInfo(context.queryMapInfo());
		CGroupActionResponse::getMapInfo(context.queryMapInfo());
	}
	if (!stricmp("GroupAdd", method)) {
		CGroupAddRequest::getMapInfo(context.queryMapInfo());
		CGroupAddResponse::getMapInfo(context.queryMapInfo());
	}
	if (!stricmp("GroupEdit", method)) {
		CGroupEditRequest::getMapInfo(context.queryMapInfo());
		CGroupEditResponse::getMapInfo(context.queryMapInfo());
	}
	if (!stricmp("GroupMemberEdit", method)) {
		CGroupMemberEditRequest::getMapInfo(context.queryMapInfo());
		CGroupMemberEditResponse::getMapInfo(context.queryMapInfo());
	}
	if (!stricmp("GroupMemberEditInput", method)) {
		CGroupMemberEditInputRequest::getMapInfo(context.queryMapInfo());
		CGroupMemberEditInputResponse::getMapInfo(context.queryMapInfo());
	}
	if (!stricmp("GroupMemberQuery", method)) {
		CGroupMemberQueryRequest::getMapInfo(context.queryMapInfo());
		CGroupMemberQueryResponse::getMapInfo(context.queryMapInfo());
	}
	if (!stricmp("GroupQuery", method)) {
		CGroupQueryRequest::getMapInfo(context.queryMapInfo());
		CGroupQueryResponse::getMapInfo(context.queryMapInfo());
	}
	if (!stricmp("Groups", method)) {
		CGroupRequest::getMapInfo(context.queryMapInfo());
		CGroupResponse::getMapInfo(context.queryMapInfo());
	}
	if (!stricmp("PermissionAction", method)) {
		CPermissionActionRequest::getMapInfo(context.queryMapInfo());
		CPermissionActionResponse::getMapInfo(context.queryMapInfo());
	}
	if (!stricmp("PermissionAddInput", method)) {
		CPermissionAddRequest::getMapInfo(context.queryMapInfo());
		CPermissionAddResponse::getMapInfo(context.queryMapInfo());
	}
	if (!stricmp("Permissions", method)) {
		CBasednsRequest::getMapInfo(context.queryMapInfo());
		CBasednsResponse::getMapInfo(context.queryMapInfo());
	}
	if (!stricmp("PermissionsReset", method)) {
		CPermissionsResetRequest::getMapInfo(context.queryMapInfo());
		CPermissionsResetResponse::getMapInfo(context.queryMapInfo());
	}
	if (!stricmp("PermissionsResetInput", method)) {
		CPermissionsResetInputRequest::getMapInfo(context.queryMapInfo());
		CPermissionsResetInputResponse::getMapInfo(context.queryMapInfo());
	}
	if (!stricmp("Ping", method)) {
		Cws_accessPingRequest::getMapInfo(context.queryMapInfo());
		Cws_accessPingResponse::getMapInfo(context.queryMapInfo());
	}
	if (!stricmp("QueryScopeScansEnabled", method)) {
		CQueryScopeScansEnabledRequest::getMapInfo(context.queryMapInfo());
		CQueryScopeScansEnabledResponse::getMapInfo(context.queryMapInfo());
	}
	if (!stricmp("QueryUserViewColumns", method)) {
		CQueryUserViewColumnsRequest::getMapInfo(context.queryMapInfo());
		CQueryUserViewColumnsResponse::getMapInfo(context.queryMapInfo());
	}
	if (!stricmp("QueryViewColumns", method)) {
		CQueryViewColumnsRequest::getMapInfo(context.queryMapInfo());
		CQueryViewColumnsResponse::getMapInfo(context.queryMapInfo());
	}
	if (!stricmp("QueryViewMembers", method)) {
		CQueryViewMembersRequest::getMapInfo(context.queryMapInfo());
		CQueryViewMembersResponse::getMapInfo(context.queryMapInfo());
	}
	if (!stricmp("QueryViews", method)) {
		CQueryViewsRequest::getMapInfo(context.queryMapInfo());
		CQueryViewsResponse::getMapInfo(context.queryMapInfo());
	}
	if (!stricmp("ResourceAdd", method)) {
		CResourceAddRequest::getMapInfo(context.queryMapInfo());
		CResourceAddResponse::getMapInfo(context.queryMapInfo());
	}
	if (!stricmp("ResourceAddInput", method)) {
		CResourceAddInputRequest::getMapInfo(context.queryMapInfo());
		CResourceAddInputResponse::getMapInfo(context.queryMapInfo());
	}
	if (!stricmp("ResourceDelete", method)) {
		CResourceDeleteRequest::getMapInfo(context.queryMapInfo());
		CResourceDeleteResponse::getMapInfo(context.queryMapInfo());
	}
	if (!stricmp("ResourcePermissionQuery", method)) {
		CResourcePermissionQueryRequest::getMapInfo(context.queryMapInfo());
		CResourcePermissionQueryResponse::getMapInfo(context.queryMapInfo());
	}
	if (!stricmp("ResourcePermissions", method)) {
		CResourcePermissionsRequest::getMapInfo(context.queryMapInfo());
		CResourcePermissionsResponse::getMapInfo(context.queryMapInfo());
	}
	if (!stricmp("ResourceQuery", method)) {
		CResourceQueryRequest::getMapInfo(context.queryMapInfo());
		CResourceQueryResponse::getMapInfo(context.queryMapInfo());
	}
	if (!stricmp("Resources", method)) {
		CResourcesRequest::getMapInfo(context.queryMapInfo());
		CResourcesResponse::getMapInfo(context.queryMapInfo());
	}
	if (!stricmp("UserAccountExport", method)) {
		CUserAccountExportRequest::getMapInfo(context.queryMapInfo());
		CUserAccountExportResponse::getMapInfo(context.queryMapInfo());
	}
	if (!stricmp("UserAction", method)) {
		CUserActionRequest::getMapInfo(context.queryMapInfo());
		CUserActionResponse::getMapInfo(context.queryMapInfo());
	}
	if (!stricmp("UserEdit", method)) {
		CUserEditRequest::getMapInfo(context.queryMapInfo());
		CUserEditResponse::getMapInfo(context.queryMapInfo());
	}
	if (!stricmp("UserGroupEdit", method)) {
		CUserGroupEditRequest::getMapInfo(context.queryMapInfo());
		CUserGroupEditResponse::getMapInfo(context.queryMapInfo());
	}
	if (!stricmp("UserGroupEditInput", method)) {
		CUserGroupEditInputRequest::getMapInfo(context.queryMapInfo());
		CUserGroupEditInputResponse::getMapInfo(context.queryMapInfo());
	}
	if (!stricmp("UserInfoEdit", method)) {
		CUserInfoEditRequest::getMapInfo(context.queryMapInfo());
		CUserInfoEditResponse::getMapInfo(context.queryMapInfo());
	}
	if (!stricmp("UserInfoEditInput", method)) {
		CUserInfoEditInputRequest::getMapInfo(context.queryMapInfo());
		CUserInfoEditInputResponse::getMapInfo(context.queryMapInfo());
	}
	if (!stricmp("UserPosix", method)) {
		CUserPosixRequest::getMapInfo(context.queryMapInfo());
		CUserPosixResponse::getMapInfo(context.queryMapInfo());
	}
	if (!stricmp("UserPosixInput", method)) {
		CUserPosixInputRequest::getMapInfo(context.queryMapInfo());
		CUserPosixInputResponse::getMapInfo(context.queryMapInfo());
	}
	if (!stricmp("UserQuery", method)) {
		CUserQueryRequest::getMapInfo(context.queryMapInfo());
		CUserQueryResponse::getMapInfo(context.queryMapInfo());
	}
	if (!stricmp("UserResetPass", method)) {
		CUserResetPassRequest::getMapInfo(context.queryMapInfo());
		CUserResetPassResponse::getMapInfo(context.queryMapInfo());
	}
	if (!stricmp("UserResetPassInput", method)) {
		CUserResetPassInputRequest::getMapInfo(context.queryMapInfo());
		CUserResetPassInputResponse::getMapInfo(context.queryMapInfo());
	}
	if (!stricmp("UserSudoers", method)) {
		CUserSudoersRequest::getMapInfo(context.queryMapInfo());
		CUserSudoersResponse::getMapInfo(context.queryMapInfo());
	}
	if (!stricmp("UserSudoersInput", method)) {
		CUserSudoersInputRequest::getMapInfo(context.queryMapInfo());
		CUserSudoersInputResponse::getMapInfo(context.queryMapInfo());
	}
	if (!stricmp("Users", method)) {
		CUserRequest::getMapInfo(context.queryMapInfo());
		CUserResponse::getMapInfo(context.queryMapInfo());
	}

	return EspHttpBinding::onGetForm(context, request, response, service, method);
}
int Cws_accessSoapBinding::onGetXForm(IEspContext &context, CHttpRequest* request, CHttpResponse* response, const char *service, const char *method)
{
	return EspHttpBinding::onGetXForm(context, request, response, service, method);
}

int Cws_accessSoapBinding::onGetService(IEspContext &context, CHttpRequest* request, CHttpResponse* response, const char *service, const char *method, const char *pathex)
{
	if(request == NULL || response == NULL)
		return -1;
	return onGetQuery(context, request, response, service, method);
}

 IRpcRequestBinding *Cws_accessSoapBinding::createReqBinding(IEspContext &context, IHttpMessage *ireq, const char *service, const char *method)
{
	CHttpRequest *request=static_cast<CHttpRequest*>(ireq);
	IProperties *props = (request) ? request->queryParameters() : NULL;

	if (!stricmp(method, "AccountPermissions") || !stricmp(method, "AccountPermissionsRequest"))
		return new CAccountPermissionsRequest(&context, "ws_access", props, NULL);
	if (!stricmp(method, "AddUser") || !stricmp(method, "AddUserRequest"))
		return new CAddUserRequest(&context, "ws_access", props, NULL);
	if (!stricmp(method, "AddView") || !stricmp(method, "AddViewRequest"))
		return new CAddViewRequest(&context, "ws_access", props, NULL);
	if (!stricmp(method, "AddViewColumn") || !stricmp(method, "AddViewColumnRequest"))
		return new CAddViewColumnRequest(&context, "ws_access", props, NULL);
	if (!stricmp(method, "AddViewMember") || !stricmp(method, "AddViewMemberRequest"))
		return new CAddViewMemberRequest(&context, "ws_access", props, NULL);
	if (!stricmp(method, "ClearPermissionsCache") || !stricmp(method, "ClearPermissionsCacheRequest"))
		return new CClearPermissionsCacheRequest(&context, "ws_access", props, NULL);
	if (!stricmp(method, "DeleteView") || !stricmp(method, "DeleteViewRequest"))
		return new CDeleteViewRequest(&context, "ws_access", props, NULL);
	if (!stricmp(method, "DeleteViewColumn") || !stricmp(method, "DeleteViewColumnRequest"))
		return new CDeleteViewColumnRequest(&context, "ws_access", props, NULL);
	if (!stricmp(method, "DeleteViewMember") || !stricmp(method, "DeleteViewMemberRequest"))
		return new CDeleteViewMemberRequest(&context, "ws_access", props, NULL);
	if (!stricmp(method, "DisableScopeScans") || !stricmp(method, "DisableScopeScansRequest"))
		return new CDisableScopeScansRequest(&context, "ws_access", props, NULL);
	if (!stricmp(method, "EnableScopeScans") || !stricmp(method, "EnableScopeScansRequest"))
		return new CEnableScopeScansRequest(&context, "ws_access", props, NULL);
	if (!stricmp(method, "FilePermission") || !stricmp(method, "FilePermissionRequest"))
		return new CFilePermissionRequest(&context, "ws_access", props, NULL);
	if (!stricmp(method, "GroupAction") || !stricmp(method, "GroupActionRequest"))
		return new CGroupActionRequest(&context, "ws_access", props, NULL);
	if (!stricmp(method, "GroupAdd") || !stricmp(method, "GroupAddRequest"))
		return new CGroupAddRequest(&context, "ws_access", props, NULL);
	if (!stricmp(method, "GroupEdit") || !stricmp(method, "GroupEditRequest"))
		return new CGroupEditRequest(&context, "ws_access", props, NULL);
	if (!stricmp(method, "GroupMemberEdit") || !stricmp(method, "GroupMemberEditRequest"))
		return new CGroupMemberEditRequest(&context, "ws_access", props, NULL);
	if (!stricmp(method, "GroupMemberEditInput") || !stricmp(method, "GroupMemberEditInputRequest"))
		return new CGroupMemberEditInputRequest(&context, "ws_access", props, NULL);
	if (!stricmp(method, "GroupMemberQuery") || !stricmp(method, "GroupMemberQueryRequest"))
		return new CGroupMemberQueryRequest(&context, "ws_access", props, NULL);
	if (!stricmp(method, "GroupQuery") || !stricmp(method, "GroupQueryRequest"))
		return new CGroupQueryRequest(&context, "ws_access", props, NULL);
	if (!stricmp(method, "Groups") || !stricmp(method, "GroupRequest"))
		return new CGroupRequest(&context, "ws_access", props, NULL);
	if (!stricmp(method, "PermissionAction") || !stricmp(method, "PermissionActionRequest"))
		return new CPermissionActionRequest(&context, "ws_access", props, NULL);
	if (!stricmp(method, "PermissionAddInput") || !stricmp(method, "PermissionAddRequest"))
		return new CPermissionAddRequest(&context, "ws_access", props, NULL);
	if (!stricmp(method, "Permissions") || !stricmp(method, "BasednsRequest"))
		return new CBasednsRequest(&context, "ws_access", props, NULL);
	if (!stricmp(method, "PermissionsReset") || !stricmp(method, "PermissionsResetRequest"))
		return new CPermissionsResetRequest(&context, "ws_access", props, NULL);
	if (!stricmp(method, "PermissionsResetInput") || !stricmp(method, "PermissionsResetInputRequest"))
		return new CPermissionsResetInputRequest(&context, "ws_access", props, NULL);
	if (!stricmp(method, "Ping") || !stricmp(method, "ws_accessPingRequest"))
		return new Cws_accessPingRequest(&context, "ws_access", props, NULL);
	if (!stricmp(method, "QueryScopeScansEnabled") || !stricmp(method, "QueryScopeScansEnabledRequest"))
		return new CQueryScopeScansEnabledRequest(&context, "ws_access", props, NULL);
	if (!stricmp(method, "QueryUserViewColumns") || !stricmp(method, "QueryUserViewColumnsRequest"))
		return new CQueryUserViewColumnsRequest(&context, "ws_access", props, NULL);
	if (!stricmp(method, "QueryViewColumns") || !stricmp(method, "QueryViewColumnsRequest"))
		return new CQueryViewColumnsRequest(&context, "ws_access", props, NULL);
	if (!stricmp(method, "QueryViewMembers") || !stricmp(method, "QueryViewMembersRequest"))
		return new CQueryViewMembersRequest(&context, "ws_access", props, NULL);
	if (!stricmp(method, "QueryViews") || !stricmp(method, "QueryViewsRequest"))
		return new CQueryViewsRequest(&context, "ws_access", props, NULL);
	if (!stricmp(method, "ResourceAdd") || !stricmp(method, "ResourceAddRequest"))
		return new CResourceAddRequest(&context, "ws_access", props, NULL);
	if (!stricmp(method, "ResourceAddInput") || !stricmp(method, "ResourceAddInputRequest"))
		return new CResourceAddInputRequest(&context, "ws_access", props, NULL);
	if (!stricmp(method, "ResourceDelete") || !stricmp(method, "ResourceDeleteRequest"))
		return new CResourceDeleteRequest(&context, "ws_access", props, NULL);
	if (!stricmp(method, "ResourcePermissionQuery") || !stricmp(method, "ResourcePermissionQueryRequest"))
		return new CResourcePermissionQueryRequest(&context, "ws_access", props, NULL);
	if (!stricmp(method, "ResourcePermissions") || !stricmp(method, "ResourcePermissionsRequest"))
		return new CResourcePermissionsRequest(&context, "ws_access", props, NULL);
	if (!stricmp(method, "ResourceQuery") || !stricmp(method, "ResourceQueryRequest"))
		return new CResourceQueryRequest(&context, "ws_access", props, NULL);
	if (!stricmp(method, "Resources") || !stricmp(method, "ResourcesRequest"))
		return new CResourcesRequest(&context, "ws_access", props, NULL);
	if (!stricmp(method, "UserAccountExport") || !stricmp(method, "UserAccountExportRequest"))
		return new CUserAccountExportRequest(&context, "ws_access", props, NULL);
	if (!stricmp(method, "UserAction") || !stricmp(method, "UserActionRequest"))
		return new CUserActionRequest(&context, "ws_access", props, NULL);
	if (!stricmp(method, "UserEdit") || !stricmp(method, "UserEditRequest"))
		return new CUserEditRequest(&context, "ws_access", props, NULL);
	if (!stricmp(method, "UserGroupEdit") || !stricmp(method, "UserGroupEditRequest"))
		return new CUserGroupEditRequest(&context, "ws_access", props, NULL);
	if (!stricmp(method, "UserGroupEditInput") || !stricmp(method, "UserGroupEditInputRequest"))
		return new CUserGroupEditInputRequest(&context, "ws_access", props, NULL);
	if (!stricmp(method, "UserInfoEdit") || !stricmp(method, "UserInfoEditRequest"))
		return new CUserInfoEditRequest(&context, "ws_access", props, NULL);
	if (!stricmp(method, "UserInfoEditInput") || !stricmp(method, "UserInfoEditInputRequest"))
		return new CUserInfoEditInputRequest(&context, "ws_access", props, NULL);
	if (!stricmp(method, "UserPosix") || !stricmp(method, "UserPosixRequest"))
		return new CUserPosixRequest(&context, "ws_access", props, NULL);
	if (!stricmp(method, "UserPosixInput") || !stricmp(method, "UserPosixInputRequest"))
		return new CUserPosixInputRequest(&context, "ws_access", props, NULL);
	if (!stricmp(method, "UserQuery") || !stricmp(method, "UserQueryRequest"))
		return new CUserQueryRequest(&context, "ws_access", props, NULL);
	if (!stricmp(method, "UserResetPass") || !stricmp(method, "UserResetPassRequest"))
		return new CUserResetPassRequest(&context, "ws_access", props, NULL);
	if (!stricmp(method, "UserResetPassInput") || !stricmp(method, "UserResetPassInputRequest"))
		return new CUserResetPassInputRequest(&context, "ws_access", props, NULL);
	if (!stricmp(method, "UserSudoers") || !stricmp(method, "UserSudoersRequest"))
		return new CUserSudoersRequest(&context, "ws_access", props, NULL);
	if (!stricmp(method, "UserSudoersInput") || !stricmp(method, "UserSudoersInputRequest"))
		return new CUserSudoersInputRequest(&context, "ws_access", props, NULL);
	if (!stricmp(method, "Users") || !stricmp(method, "UserRequest"))
		return new CUserRequest(&context, "ws_access", props, NULL);
	return NULL;
}

int Cws_accessSoapBinding::onGetInstantQuery(IEspContext &context, CHttpRequest* request, CHttpResponse* response, const char *service, const char *method)
{
	if (context.getClientVersion()<=0)
		context.setClientVersion(1.12);

	if(request == NULL || response == NULL)
		return -1;
	StringBuffer respStr;
	Owned<IEspws_access> iserv = (IEspws_access*)getService();
	if(iserv == NULL)
	{
		respStr.append("Service not available");
		response->setContent(respStr.str());
		response->setContentType("text/html");
		response->send();
	}
	else
	{
		Owned<CSoapResponseBinding> esp_response;
		StringBuffer source;
		IEspContext& context = *request->queryContext();
		if(!stricmp(method, "AccountPermissions")||!stricmp(method, "AccountPermissionsRequest"))
		{
			Owned<CAccountPermissionsRequest> esp_request = new CAccountPermissionsRequest(&context, "ws_access", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			Owned<CAccountPermissionsResponse> esp_response = new CAccountPermissionsResponse("ws_access");
			StringBuffer source;
			source.appendf("ws_access::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				iserv->onAccountPermissions(*request->queryContext(), *esp_request.get(), *esp_response.get());
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "ws_access", "AccountPermissions", StringBuffer(getCFD()).append("./smc_xslt/exceptions.xslt").str()))
				return 0;
			if (canRedirect(*request) && esp_response->getRedirectUrl() && *esp_response->getRedirectUrl())
			{
				response->redirect(*request, esp_response->getRedirectUrl());
			}
			else
			{
				IProperties *props=request->queryParameters();
				if (skipXslt(context))
				{
					MemoryBuffer content;
					StringBuffer mimetype;
					esp_response->appendContent(&context,content, mimetype);
					onBeforeSendResponse(context,request,content,service,method);
					response->setContent(content.length(), content.toByteArray());
					response->setContentType(mimetype.str());
				}
				else
				{
					StringBuffer xml;
					StringBuffer sResponse;
					if (request->supportClientXslt())
						xml.appendf("<?xml version=\"1.0\" encoding=\"UTF-8\"?><?xml-stylesheet type=\"text/xsl\" href=\"%s\"?>", "/esp/xslt/access_accountpermissions.xslt");
					esp_response->serializeStruct(&context, xml, NULL);

					if (request->supportClientXslt()){
						xml.swapWith(sResponse);
						response->setContentType("text/xml");
					}else{
					xslTransform(xml.str(), "/esp/xslt/access_accountpermissions.xslt", sResponse.clear(), context.queryXslParameters());
					response->setContentType("text/html");
					}
					response->setContent(sResponse.str());
				}
				response->send();
			}
			return 0;
		}
		if(!stricmp(method, "AddUser")||!stricmp(method, "AddUserRequest"))
		{
			Owned<CAddUserRequest> esp_request = new CAddUserRequest(&context, "ws_access", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			Owned<CAddUserResponse> esp_response = new CAddUserResponse("ws_access");
			StringBuffer source;
			source.appendf("ws_access::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				iserv->onAddUser(*request->queryContext(), *esp_request.get(), *esp_response.get());
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "ws_access", "AddUser", StringBuffer(getCFD()).append("./smc_xslt/exceptions.xslt").str()))
				return 0;
			if (canRedirect(*request) && esp_response->getRedirectUrl() && *esp_response->getRedirectUrl())
			{
				response->redirect(*request, esp_response->getRedirectUrl());
			}
			else
			{
				IProperties *props=request->queryParameters();
				if (skipXslt(context))
				{
					MemoryBuffer content;
					StringBuffer mimetype;
					esp_response->appendContent(&context,content, mimetype);
					onBeforeSendResponse(context,request,content,service,method);
					response->setContent(content.length(), content.toByteArray());
					response->setContentType(mimetype.str());
				}
				else
				{
					StringBuffer xml;
					StringBuffer sResponse;
					if (request->supportClientXslt())
						xml.appendf("<?xml version=\"1.0\" encoding=\"UTF-8\"?><?xml-stylesheet type=\"text/xsl\" href=\"%s\"?>", "/esp/xslt/access_adduser.xslt");
					esp_response->serializeStruct(&context, xml, NULL);

					if (request->supportClientXslt()){
						xml.swapWith(sResponse);
						response->setContentType("text/xml");
					}else{
					xslTransform(xml.str(), "/esp/xslt/access_adduser.xslt", sResponse.clear(), context.queryXslParameters());
					response->setContentType("text/html");
					}
					response->setContent(sResponse.str());
				}
				response->send();
			}
			return 0;
		}
		if(!stricmp(method, "AddView")||!stricmp(method, "AddViewRequest"))
		{
			Owned<CAddViewRequest> esp_request = new CAddViewRequest(&context, "ws_access", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			CAddViewResponse* resp = new CAddViewResponse("ws_access");
			esp_response.setown(resp);
			MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
			source.setf("ws_access::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				if(accessmap.ordinality()>0)
					onFeaturesAuthorize(context, accessmap, "ws_access", "AddView");
				iserv->onAddView(context, *esp_request.get(), *resp);
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "ws_access", "AddView", StringBuffer(getCFD()).append("./smc_xslt/exceptions.xslt").str()))
				return 0;
		}
		if(!stricmp(method, "AddViewColumn")||!stricmp(method, "AddViewColumnRequest"))
		{
			Owned<CAddViewColumnRequest> esp_request = new CAddViewColumnRequest(&context, "ws_access", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			CAddViewColumnResponse* resp = new CAddViewColumnResponse("ws_access");
			esp_response.setown(resp);
			MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
			source.setf("ws_access::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				if(accessmap.ordinality()>0)
					onFeaturesAuthorize(context, accessmap, "ws_access", "AddViewColumn");
				iserv->onAddViewColumn(context, *esp_request.get(), *resp);
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "ws_access", "AddViewColumn", StringBuffer(getCFD()).append("./smc_xslt/exceptions.xslt").str()))
				return 0;
		}
		if(!stricmp(method, "AddViewMember")||!stricmp(method, "AddViewMemberRequest"))
		{
			Owned<CAddViewMemberRequest> esp_request = new CAddViewMemberRequest(&context, "ws_access", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			CAddViewMemberResponse* resp = new CAddViewMemberResponse("ws_access");
			esp_response.setown(resp);
			MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
			source.setf("ws_access::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				if(accessmap.ordinality()>0)
					onFeaturesAuthorize(context, accessmap, "ws_access", "AddViewMember");
				iserv->onAddViewMember(context, *esp_request.get(), *resp);
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "ws_access", "AddViewMember", StringBuffer(getCFD()).append("./smc_xslt/exceptions.xslt").str()))
				return 0;
		}
		if(!stricmp(method, "ClearPermissionsCache")||!stricmp(method, "ClearPermissionsCacheRequest"))
		{
			Owned<CClearPermissionsCacheRequest> esp_request = new CClearPermissionsCacheRequest(&context, "ws_access", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			Owned<CClearPermissionsCacheResponse> esp_response = new CClearPermissionsCacheResponse("ws_access");
			StringBuffer source;
			source.appendf("ws_access::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				iserv->onClearPermissionsCache(*request->queryContext(), *esp_request.get(), *esp_response.get());
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "ws_access", "ClearPermissionsCache", StringBuffer(getCFD()).append("./smc_xslt/exceptions.xslt").str()))
				return 0;
			if (canRedirect(*request) && esp_response->getRedirectUrl() && *esp_response->getRedirectUrl())
			{
				response->redirect(*request, esp_response->getRedirectUrl());
			}
			else
			{
				IProperties *props=request->queryParameters();
				if (skipXslt(context))
				{
					MemoryBuffer content;
					StringBuffer mimetype;
					esp_response->appendContent(&context,content, mimetype);
					onBeforeSendResponse(context,request,content,service,method);
					response->setContent(content.length(), content.toByteArray());
					response->setContentType(mimetype.str());
				}
				else
				{
					StringBuffer xml;
					StringBuffer sResponse;
					if (request->supportClientXslt())
						xml.appendf("<?xml version=\"1.0\" encoding=\"UTF-8\"?><?xml-stylesheet type=\"text/xsl\" href=\"%s\"?>", "/esp/xslt/access_clearpermissionscache.xslt");
					esp_response->serializeStruct(&context, xml, NULL);

					if (request->supportClientXslt()){
						xml.swapWith(sResponse);
						response->setContentType("text/xml");
					}else{
					xslTransform(xml.str(), "/esp/xslt/access_clearpermissionscache.xslt", sResponse.clear(), context.queryXslParameters());
					response->setContentType("text/html");
					}
					response->setContent(sResponse.str());
				}
				response->send();
			}
			return 0;
		}
		if(!stricmp(method, "DeleteView")||!stricmp(method, "DeleteViewRequest"))
		{
			Owned<CDeleteViewRequest> esp_request = new CDeleteViewRequest(&context, "ws_access", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			CDeleteViewResponse* resp = new CDeleteViewResponse("ws_access");
			esp_response.setown(resp);
			MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
			source.setf("ws_access::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				if(accessmap.ordinality()>0)
					onFeaturesAuthorize(context, accessmap, "ws_access", "DeleteView");
				iserv->onDeleteView(context, *esp_request.get(), *resp);
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "ws_access", "DeleteView", StringBuffer(getCFD()).append("./smc_xslt/exceptions.xslt").str()))
				return 0;
		}
		if(!stricmp(method, "DeleteViewColumn")||!stricmp(method, "DeleteViewColumnRequest"))
		{
			Owned<CDeleteViewColumnRequest> esp_request = new CDeleteViewColumnRequest(&context, "ws_access", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			CDeleteViewColumnResponse* resp = new CDeleteViewColumnResponse("ws_access");
			esp_response.setown(resp);
			MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
			source.setf("ws_access::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				if(accessmap.ordinality()>0)
					onFeaturesAuthorize(context, accessmap, "ws_access", "DeleteViewColumn");
				iserv->onDeleteViewColumn(context, *esp_request.get(), *resp);
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "ws_access", "DeleteViewColumn", StringBuffer(getCFD()).append("./smc_xslt/exceptions.xslt").str()))
				return 0;
		}
		if(!stricmp(method, "DeleteViewMember")||!stricmp(method, "DeleteViewMemberRequest"))
		{
			Owned<CDeleteViewMemberRequest> esp_request = new CDeleteViewMemberRequest(&context, "ws_access", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			CDeleteViewMemberResponse* resp = new CDeleteViewMemberResponse("ws_access");
			esp_response.setown(resp);
			MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
			source.setf("ws_access::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				if(accessmap.ordinality()>0)
					onFeaturesAuthorize(context, accessmap, "ws_access", "DeleteViewMember");
				iserv->onDeleteViewMember(context, *esp_request.get(), *resp);
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "ws_access", "DeleteViewMember", StringBuffer(getCFD()).append("./smc_xslt/exceptions.xslt").str()))
				return 0;
		}
		if(!stricmp(method, "DisableScopeScans")||!stricmp(method, "DisableScopeScansRequest"))
		{
			Owned<CDisableScopeScansRequest> esp_request = new CDisableScopeScansRequest(&context, "ws_access", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			Owned<CDisableScopeScansResponse> esp_response = new CDisableScopeScansResponse("ws_access");
			StringBuffer source;
			source.appendf("ws_access::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				iserv->onDisableScopeScans(*request->queryContext(), *esp_request.get(), *esp_response.get());
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "ws_access", "DisableScopeScans", StringBuffer(getCFD()).append("./smc_xslt/exceptions.xslt").str()))
				return 0;
			if (canRedirect(*request) && esp_response->getRedirectUrl() && *esp_response->getRedirectUrl())
			{
				response->redirect(*request, esp_response->getRedirectUrl());
			}
			else
			{
				IProperties *props=request->queryParameters();
				if (skipXslt(context))
				{
					MemoryBuffer content;
					StringBuffer mimetype;
					esp_response->appendContent(&context,content, mimetype);
					onBeforeSendResponse(context,request,content,service,method);
					response->setContent(content.length(), content.toByteArray());
					response->setContentType(mimetype.str());
				}
				else
				{
					StringBuffer xml;
					StringBuffer sResponse;
					if (request->supportClientXslt())
						xml.appendf("<?xml version=\"1.0\" encoding=\"UTF-8\"?><?xml-stylesheet type=\"text/xsl\" href=\"%s\"?>", "/esp/xslt/access_disablescopescans.xslt");
					esp_response->serializeStruct(&context, xml, NULL);

					if (request->supportClientXslt()){
						xml.swapWith(sResponse);
						response->setContentType("text/xml");
					}else{
					xslTransform(xml.str(), "/esp/xslt/access_disablescopescans.xslt", sResponse.clear(), context.queryXslParameters());
					response->setContentType("text/html");
					}
					response->setContent(sResponse.str());
				}
				response->send();
			}
			return 0;
		}
		if(!stricmp(method, "EnableScopeScans")||!stricmp(method, "EnableScopeScansRequest"))
		{
			Owned<CEnableScopeScansRequest> esp_request = new CEnableScopeScansRequest(&context, "ws_access", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			Owned<CEnableScopeScansResponse> esp_response = new CEnableScopeScansResponse("ws_access");
			StringBuffer source;
			source.appendf("ws_access::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				iserv->onEnableScopeScans(*request->queryContext(), *esp_request.get(), *esp_response.get());
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "ws_access", "EnableScopeScans", StringBuffer(getCFD()).append("./smc_xslt/exceptions.xslt").str()))
				return 0;
			if (canRedirect(*request) && esp_response->getRedirectUrl() && *esp_response->getRedirectUrl())
			{
				response->redirect(*request, esp_response->getRedirectUrl());
			}
			else
			{
				IProperties *props=request->queryParameters();
				if (skipXslt(context))
				{
					MemoryBuffer content;
					StringBuffer mimetype;
					esp_response->appendContent(&context,content, mimetype);
					onBeforeSendResponse(context,request,content,service,method);
					response->setContent(content.length(), content.toByteArray());
					response->setContentType(mimetype.str());
				}
				else
				{
					StringBuffer xml;
					StringBuffer sResponse;
					if (request->supportClientXslt())
						xml.appendf("<?xml version=\"1.0\" encoding=\"UTF-8\"?><?xml-stylesheet type=\"text/xsl\" href=\"%s\"?>", "/esp/xslt/access_enablescopescans.xslt");
					esp_response->serializeStruct(&context, xml, NULL);

					if (request->supportClientXslt()){
						xml.swapWith(sResponse);
						response->setContentType("text/xml");
					}else{
					xslTransform(xml.str(), "/esp/xslt/access_enablescopescans.xslt", sResponse.clear(), context.queryXslParameters());
					response->setContentType("text/html");
					}
					response->setContent(sResponse.str());
				}
				response->send();
			}
			return 0;
		}
		if(!stricmp(method, "FilePermission")||!stricmp(method, "FilePermissionRequest"))
		{
			Owned<CFilePermissionRequest> esp_request = new CFilePermissionRequest(&context, "ws_access", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			Owned<CFilePermissionResponse> esp_response = new CFilePermissionResponse("ws_access");
			StringBuffer source;
			source.appendf("ws_access::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				iserv->onFilePermission(*request->queryContext(), *esp_request.get(), *esp_response.get());
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "ws_access", "FilePermission", StringBuffer(getCFD()).append("./smc_xslt/exceptions.xslt").str()))
				return 0;
			if (canRedirect(*request) && esp_response->getRedirectUrl() && *esp_response->getRedirectUrl())
			{
				response->redirect(*request, esp_response->getRedirectUrl());
			}
			else
			{
				IProperties *props=request->queryParameters();
				if (skipXslt(context))
				{
					MemoryBuffer content;
					StringBuffer mimetype;
					esp_response->appendContent(&context,content, mimetype);
					onBeforeSendResponse(context,request,content,service,method);
					response->setContent(content.length(), content.toByteArray());
					response->setContentType(mimetype.str());
				}
				else
				{
					StringBuffer xml;
					StringBuffer sResponse;
					if (request->supportClientXslt())
						xml.appendf("<?xml version=\"1.0\" encoding=\"UTF-8\"?><?xml-stylesheet type=\"text/xsl\" href=\"%s\"?>", "/esp/xslt/access_filepermission.xslt");
					esp_response->serializeStruct(&context, xml, NULL);

					if (request->supportClientXslt()){
						xml.swapWith(sResponse);
						response->setContentType("text/xml");
					}else{
					xslTransform(xml.str(), "/esp/xslt/access_filepermission.xslt", sResponse.clear(), context.queryXslParameters());
					response->setContentType("text/html");
					}
					response->setContent(sResponse.str());
				}
				response->send();
			}
			return 0;
		}
		if(!stricmp(method, "GroupAction")||!stricmp(method, "GroupActionRequest"))
		{
			Owned<CGroupActionRequest> esp_request = new CGroupActionRequest(&context, "ws_access", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			Owned<CGroupActionResponse> esp_response = new CGroupActionResponse("ws_access");
			StringBuffer source;
			source.appendf("ws_access::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				iserv->onGroupAction(*request->queryContext(), *esp_request.get(), *esp_response.get());
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "ws_access", "GroupAction", StringBuffer(getCFD()).append("./smc_xslt/exceptions.xslt").str()))
				return 0;
			if (canRedirect(*request) && esp_response->getRedirectUrl() && *esp_response->getRedirectUrl())
			{
				response->redirect(*request, esp_response->getRedirectUrl());
			}
			else
			{
				IProperties *props=request->queryParameters();
				if (skipXslt(context))
				{
					MemoryBuffer content;
					StringBuffer mimetype;
					esp_response->appendContent(&context,content, mimetype);
					onBeforeSendResponse(context,request,content,service,method);
					response->setContent(content.length(), content.toByteArray());
					response->setContentType(mimetype.str());
				}
				else
				{
					StringBuffer xml;
					StringBuffer sResponse;
					if (request->supportClientXslt())
						xml.appendf("<?xml version=\"1.0\" encoding=\"UTF-8\"?><?xml-stylesheet type=\"text/xsl\" href=\"%s\"?>", "/esp/xslt/access_groupdelete.xslt");
					esp_response->serializeStruct(&context, xml, NULL);

					if (request->supportClientXslt()){
						xml.swapWith(sResponse);
						response->setContentType("text/xml");
					}else{
					xslTransform(xml.str(), "/esp/xslt/access_groupdelete.xslt", sResponse.clear(), context.queryXslParameters());
					response->setContentType("text/html");
					}
					response->setContent(sResponse.str());
				}
				response->send();
			}
			return 0;
		}
		if(!stricmp(method, "GroupAdd")||!stricmp(method, "GroupAddRequest"))
		{
			Owned<CGroupAddRequest> esp_request = new CGroupAddRequest(&context, "ws_access", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			Owned<CGroupAddResponse> esp_response = new CGroupAddResponse("ws_access");
			StringBuffer source;
			source.appendf("ws_access::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				iserv->onGroupAdd(*request->queryContext(), *esp_request.get(), *esp_response.get());
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "ws_access", "GroupAdd", StringBuffer(getCFD()).append("./smc_xslt/exceptions.xslt").str()))
				return 0;
			if (canRedirect(*request) && esp_response->getRedirectUrl() && *esp_response->getRedirectUrl())
			{
				response->redirect(*request, esp_response->getRedirectUrl());
			}
			else
			{
				IProperties *props=request->queryParameters();
				if (skipXslt(context))
				{
					MemoryBuffer content;
					StringBuffer mimetype;
					esp_response->appendContent(&context,content, mimetype);
					onBeforeSendResponse(context,request,content,service,method);
					response->setContent(content.length(), content.toByteArray());
					response->setContentType(mimetype.str());
				}
				else
				{
					StringBuffer xml;
					StringBuffer sResponse;
					if (request->supportClientXslt())
						xml.appendf("<?xml version=\"1.0\" encoding=\"UTF-8\"?><?xml-stylesheet type=\"text/xsl\" href=\"%s\"?>", "/esp/xslt/access_groupadd.xslt");
					esp_response->serializeStruct(&context, xml, NULL);

					if (request->supportClientXslt()){
						xml.swapWith(sResponse);
						response->setContentType("text/xml");
					}else{
					xslTransform(xml.str(), "/esp/xslt/access_groupadd.xslt", sResponse.clear(), context.queryXslParameters());
					response->setContentType("text/html");
					}
					response->setContent(sResponse.str());
				}
				response->send();
			}
			return 0;
		}
		if(!stricmp(method, "GroupEdit")||!stricmp(method, "GroupEditRequest"))
		{
			Owned<CGroupEditRequest> esp_request = new CGroupEditRequest(&context, "ws_access", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			Owned<CGroupEditResponse> esp_response = new CGroupEditResponse("ws_access");
			StringBuffer source;
			source.appendf("ws_access::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				iserv->onGroupEdit(*request->queryContext(), *esp_request.get(), *esp_response.get());
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "ws_access", "GroupEdit", StringBuffer(getCFD()).append("./smc_xslt/exceptions.xslt").str()))
				return 0;
			if (canRedirect(*request) && esp_response->getRedirectUrl() && *esp_response->getRedirectUrl())
			{
				response->redirect(*request, esp_response->getRedirectUrl());
			}
			else
			{
				IProperties *props=request->queryParameters();
				if (skipXslt(context))
				{
					MemoryBuffer content;
					StringBuffer mimetype;
					esp_response->appendContent(&context,content, mimetype);
					onBeforeSendResponse(context,request,content,service,method);
					response->setContent(content.length(), content.toByteArray());
					response->setContentType(mimetype.str());
				}
				else
				{
					StringBuffer xml;
					StringBuffer sResponse;
					if (request->supportClientXslt())
						xml.appendf("<?xml version=\"1.0\" encoding=\"UTF-8\"?><?xml-stylesheet type=\"text/xsl\" href=\"%s\"?>", "/esp/xslt/access_groupedit.xslt");
					esp_response->serializeStruct(&context, xml, NULL);

					if (request->supportClientXslt()){
						xml.swapWith(sResponse);
						response->setContentType("text/xml");
					}else{
					xslTransform(xml.str(), "/esp/xslt/access_groupedit.xslt", sResponse.clear(), context.queryXslParameters());
					response->setContentType("text/html");
					}
					response->setContent(sResponse.str());
				}
				response->send();
			}
			return 0;
		}
		if(!stricmp(method, "GroupMemberEdit")||!stricmp(method, "GroupMemberEditRequest"))
		{
			Owned<CGroupMemberEditRequest> esp_request = new CGroupMemberEditRequest(&context, "ws_access", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			Owned<CGroupMemberEditResponse> esp_response = new CGroupMemberEditResponse("ws_access");
			StringBuffer source;
			source.appendf("ws_access::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				iserv->onGroupMemberEdit(*request->queryContext(), *esp_request.get(), *esp_response.get());
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "ws_access", "GroupMemberEdit", StringBuffer(getCFD()).append("./smc_xslt/exceptions.xslt").str()))
				return 0;
			if (canRedirect(*request) && esp_response->getRedirectUrl() && *esp_response->getRedirectUrl())
			{
				response->redirect(*request, esp_response->getRedirectUrl());
			}
			else
			{
				IProperties *props=request->queryParameters();
				if (skipXslt(context))
				{
					MemoryBuffer content;
					StringBuffer mimetype;
					esp_response->appendContent(&context,content, mimetype);
					onBeforeSendResponse(context,request,content,service,method);
					response->setContent(content.length(), content.toByteArray());
					response->setContentType(mimetype.str());
				}
				else
				{
					StringBuffer xml;
					StringBuffer sResponse;
					if (request->supportClientXslt())
						xml.appendf("<?xml version=\"1.0\" encoding=\"UTF-8\"?><?xml-stylesheet type=\"text/xsl\" href=\"%s\"?>", "/esp/xslt/access_groupmemberedit.xslt");
					esp_response->serializeStruct(&context, xml, NULL);

					if (request->supportClientXslt()){
						xml.swapWith(sResponse);
						response->setContentType("text/xml");
					}else{
					xslTransform(xml.str(), "/esp/xslt/access_groupmemberedit.xslt", sResponse.clear(), context.queryXslParameters());
					response->setContentType("text/html");
					}
					response->setContent(sResponse.str());
				}
				response->send();
			}
			return 0;
		}
		if(!stricmp(method, "GroupMemberEditInput")||!stricmp(method, "GroupMemberEditInputRequest"))
		{
			Owned<CGroupMemberEditInputRequest> esp_request = new CGroupMemberEditInputRequest(&context, "ws_access", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			Owned<CGroupMemberEditInputResponse> esp_response = new CGroupMemberEditInputResponse("ws_access");
			StringBuffer source;
			source.appendf("ws_access::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				iserv->onGroupMemberEditInput(*request->queryContext(), *esp_request.get(), *esp_response.get());
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "ws_access", "GroupMemberEditInput", StringBuffer(getCFD()).append("./smc_xslt/exceptions.xslt").str()))
				return 0;
			if (canRedirect(*request) && esp_response->getRedirectUrl() && *esp_response->getRedirectUrl())
			{
				response->redirect(*request, esp_response->getRedirectUrl());
			}
			else
			{
				IProperties *props=request->queryParameters();
				if (skipXslt(context))
				{
					MemoryBuffer content;
					StringBuffer mimetype;
					esp_response->appendContent(&context,content, mimetype);
					onBeforeSendResponse(context,request,content,service,method);
					response->setContent(content.length(), content.toByteArray());
					response->setContentType(mimetype.str());
				}
				else
				{
					StringBuffer xml;
					StringBuffer sResponse;
					if (request->supportClientXslt())
						xml.appendf("<?xml version=\"1.0\" encoding=\"UTF-8\"?><?xml-stylesheet type=\"text/xsl\" href=\"%s\"?>", "/esp/xslt/access_groupmembereditinput.xslt");
					esp_response->serializeStruct(&context, xml, NULL);

					if (request->supportClientXslt()){
						xml.swapWith(sResponse);
						response->setContentType("text/xml");
					}else{
					xslTransform(xml.str(), "/esp/xslt/access_groupmembereditinput.xslt", sResponse.clear(), context.queryXslParameters());
					response->setContentType("text/html");
					}
					response->setContent(sResponse.str());
				}
				response->send();
			}
			return 0;
		}
		if(!stricmp(method, "GroupMemberQuery")||!stricmp(method, "GroupMemberQueryRequest"))
		{
			Owned<CGroupMemberQueryRequest> esp_request = new CGroupMemberQueryRequest(&context, "ws_access", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			CGroupMemberQueryResponse* resp = new CGroupMemberQueryResponse("ws_access");
			esp_response.setown(resp);
			MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
			source.setf("ws_access::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				if(accessmap.ordinality()>0)
					onFeaturesAuthorize(context, accessmap, "ws_access", "GroupMemberQuery");
				iserv->onGroupMemberQuery(context, *esp_request.get(), *resp);
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "ws_access", "GroupMemberQuery", StringBuffer(getCFD()).append("./smc_xslt/exceptions.xslt").str()))
				return 0;
		}
		if(!stricmp(method, "GroupQuery")||!stricmp(method, "GroupQueryRequest"))
		{
			Owned<CGroupQueryRequest> esp_request = new CGroupQueryRequest(&context, "ws_access", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			CGroupQueryResponse* resp = new CGroupQueryResponse("ws_access");
			esp_response.setown(resp);
			MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
			source.setf("ws_access::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				if(accessmap.ordinality()>0)
					onFeaturesAuthorize(context, accessmap, "ws_access", "GroupQuery");
				iserv->onGroupQuery(context, *esp_request.get(), *resp);
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "ws_access", "GroupQuery", StringBuffer(getCFD()).append("./smc_xslt/exceptions.xslt").str()))
				return 0;
		}
		if(!stricmp(method, "Groups")||!stricmp(method, "GroupRequest"))
		{
			Owned<CGroupRequest> esp_request = new CGroupRequest(&context, "ws_access", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			Owned<CGroupResponse> esp_response = new CGroupResponse("ws_access");
			StringBuffer source;
			source.appendf("ws_access::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				iserv->onGroups(*request->queryContext(), *esp_request.get(), *esp_response.get());
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "ws_access", "Groups", StringBuffer(getCFD()).append("./smc_xslt/exceptions.xslt").str()))
				return 0;
			if (canRedirect(*request) && esp_response->getRedirectUrl() && *esp_response->getRedirectUrl())
			{
				response->redirect(*request, esp_response->getRedirectUrl());
			}
			else
			{
				IProperties *props=request->queryParameters();
				if (skipXslt(context))
				{
					MemoryBuffer content;
					StringBuffer mimetype;
					esp_response->appendContent(&context,content, mimetype);
					onBeforeSendResponse(context,request,content,service,method);
					response->setContent(content.length(), content.toByteArray());
					response->setContentType(mimetype.str());
				}
				else
				{
					StringBuffer xml;
					StringBuffer sResponse;
					if (request->supportClientXslt())
						xml.appendf("<?xml version=\"1.0\" encoding=\"UTF-8\"?><?xml-stylesheet type=\"text/xsl\" href=\"%s\"?>", "/esp/xslt/access_groups.xslt");
					esp_response->serializeStruct(&context, xml, NULL);

					if (request->supportClientXslt()){
						xml.swapWith(sResponse);
						response->setContentType("text/xml");
					}else{
					xslTransform(xml.str(), "/esp/xslt/access_groups.xslt", sResponse.clear(), context.queryXslParameters());
					response->setContentType("text/html");
					}
					response->setContent(sResponse.str());
				}
				response->send();
			}
			return 0;
		}
		if(!stricmp(method, "PermissionAction")||!stricmp(method, "PermissionActionRequest"))
		{
			Owned<CPermissionActionRequest> esp_request = new CPermissionActionRequest(&context, "ws_access", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			Owned<CPermissionActionResponse> esp_response = new CPermissionActionResponse("ws_access");
			StringBuffer source;
			source.appendf("ws_access::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				iserv->onPermissionAction(*request->queryContext(), *esp_request.get(), *esp_response.get());
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "ws_access", "PermissionAction", StringBuffer(getCFD()).append("./smc_xslt/exceptions.xslt").str()))
				return 0;
			if (canRedirect(*request) && esp_response->getRedirectUrl() && *esp_response->getRedirectUrl())
			{
				response->redirect(*request, esp_response->getRedirectUrl());
			}
			else
			{
				IProperties *props=request->queryParameters();
				if (skipXslt(context))
				{
					MemoryBuffer content;
					StringBuffer mimetype;
					esp_response->appendContent(&context,content, mimetype);
					onBeforeSendResponse(context,request,content,service,method);
					response->setContent(content.length(), content.toByteArray());
					response->setContentType(mimetype.str());
				}
				else
				{
					StringBuffer xml;
					StringBuffer sResponse;
					if (request->supportClientXslt())
						xml.appendf("<?xml version=\"1.0\" encoding=\"UTF-8\"?><?xml-stylesheet type=\"text/xsl\" href=\"%s\"?>", "/esp/xslt/access_permissionchange.xslt");
					esp_response->serializeStruct(&context, xml, NULL);

					if (request->supportClientXslt()){
						xml.swapWith(sResponse);
						response->setContentType("text/xml");
					}else{
					xslTransform(xml.str(), "/esp/xslt/access_permissionchange.xslt", sResponse.clear(), context.queryXslParameters());
					response->setContentType("text/html");
					}
					response->setContent(sResponse.str());
				}
				response->send();
			}
			return 0;
		}
		if(!stricmp(method, "PermissionAddInput")||!stricmp(method, "PermissionAddRequest"))
		{
			Owned<CPermissionAddRequest> esp_request = new CPermissionAddRequest(&context, "ws_access", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			Owned<CPermissionAddResponse> esp_response = new CPermissionAddResponse("ws_access");
			StringBuffer source;
			source.appendf("ws_access::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				iserv->onPermissionAddInput(*request->queryContext(), *esp_request.get(), *esp_response.get());
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "ws_access", "PermissionAddInput", StringBuffer(getCFD()).append("./smc_xslt/exceptions.xslt").str()))
				return 0;
			if (canRedirect(*request) && esp_response->getRedirectUrl() && *esp_response->getRedirectUrl())
			{
				response->redirect(*request, esp_response->getRedirectUrl());
			}
			else
			{
				IProperties *props=request->queryParameters();
				if (skipXslt(context))
				{
					MemoryBuffer content;
					StringBuffer mimetype;
					esp_response->appendContent(&context,content, mimetype);
					onBeforeSendResponse(context,request,content,service,method);
					response->setContent(content.length(), content.toByteArray());
					response->setContentType(mimetype.str());
				}
				else
				{
					StringBuffer xml;
					StringBuffer sResponse;
					if (request->supportClientXslt())
						xml.appendf("<?xml version=\"1.0\" encoding=\"UTF-8\"?><?xml-stylesheet type=\"text/xsl\" href=\"%s\"?>", "/esp/xslt/access_permissionaddinput.xslt");
					esp_response->serializeStruct(&context, xml, NULL);

					if (request->supportClientXslt()){
						xml.swapWith(sResponse);
						response->setContentType("text/xml");
					}else{
					xslTransform(xml.str(), "/esp/xslt/access_permissionaddinput.xslt", sResponse.clear(), context.queryXslParameters());
					response->setContentType("text/html");
					}
					response->setContent(sResponse.str());
				}
				response->send();
			}
			return 0;
		}
		if(!stricmp(method, "Permissions")||!stricmp(method, "BasednsRequest"))
		{
			Owned<CBasednsRequest> esp_request = new CBasednsRequest(&context, "ws_access", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			Owned<CBasednsResponse> esp_response = new CBasednsResponse("ws_access");
			StringBuffer source;
			source.appendf("ws_access::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				iserv->onPermissions(*request->queryContext(), *esp_request.get(), *esp_response.get());
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "ws_access", "Permissions", StringBuffer(getCFD()).append("./smc_xslt/exceptions.xslt").str()))
				return 0;
			if (canRedirect(*request) && esp_response->getRedirectUrl() && *esp_response->getRedirectUrl())
			{
				response->redirect(*request, esp_response->getRedirectUrl());
			}
			else
			{
				IProperties *props=request->queryParameters();
				if (skipXslt(context))
				{
					MemoryBuffer content;
					StringBuffer mimetype;
					esp_response->appendContent(&context,content, mimetype);
					onBeforeSendResponse(context,request,content,service,method);
					response->setContent(content.length(), content.toByteArray());
					response->setContentType(mimetype.str());
				}
				else
				{
					StringBuffer xml;
					StringBuffer sResponse;
					if (request->supportClientXslt())
						xml.appendf("<?xml version=\"1.0\" encoding=\"UTF-8\"?><?xml-stylesheet type=\"text/xsl\" href=\"%s\"?>", "/esp/xslt/access_basedns.xslt");
					esp_response->serializeStruct(&context, xml, NULL);

					if (request->supportClientXslt()){
						xml.swapWith(sResponse);
						response->setContentType("text/xml");
					}else{
					xslTransform(xml.str(), "/esp/xslt/access_basedns.xslt", sResponse.clear(), context.queryXslParameters());
					response->setContentType("text/html");
					}
					response->setContent(sResponse.str());
				}
				response->send();
			}
			return 0;
		}
		if(!stricmp(method, "PermissionsReset")||!stricmp(method, "PermissionsResetRequest"))
		{
			Owned<CPermissionsResetRequest> esp_request = new CPermissionsResetRequest(&context, "ws_access", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			Owned<CPermissionsResetResponse> esp_response = new CPermissionsResetResponse("ws_access");
			StringBuffer source;
			source.appendf("ws_access::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				iserv->onPermissionsReset(*request->queryContext(), *esp_request.get(), *esp_response.get());
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "ws_access", "PermissionsReset", StringBuffer(getCFD()).append("./smc_xslt/exceptions.xslt").str()))
				return 0;
			if (canRedirect(*request) && esp_response->getRedirectUrl() && *esp_response->getRedirectUrl())
			{
				response->redirect(*request, esp_response->getRedirectUrl());
			}
			else
			{
				IProperties *props=request->queryParameters();
				if (skipXslt(context))
				{
					MemoryBuffer content;
					StringBuffer mimetype;
					esp_response->appendContent(&context,content, mimetype);
					onBeforeSendResponse(context,request,content,service,method);
					response->setContent(content.length(), content.toByteArray());
					response->setContentType(mimetype.str());
				}
				else
				{
					StringBuffer xml;
					StringBuffer sResponse;
					if (request->supportClientXslt())
						xml.appendf("<?xml version=\"1.0\" encoding=\"UTF-8\"?><?xml-stylesheet type=\"text/xsl\" href=\"%s\"?>", "/esp/xslt/access_permissionsreset.xslt");
					esp_response->serializeStruct(&context, xml, NULL);

					if (request->supportClientXslt()){
						xml.swapWith(sResponse);
						response->setContentType("text/xml");
					}else{
					xslTransform(xml.str(), "/esp/xslt/access_permissionsreset.xslt", sResponse.clear(), context.queryXslParameters());
					response->setContentType("text/html");
					}
					response->setContent(sResponse.str());
				}
				response->send();
			}
			return 0;
		}
		if(!stricmp(method, "PermissionsResetInput")||!stricmp(method, "PermissionsResetInputRequest"))
		{
			Owned<CPermissionsResetInputRequest> esp_request = new CPermissionsResetInputRequest(&context, "ws_access", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			Owned<CPermissionsResetInputResponse> esp_response = new CPermissionsResetInputResponse("ws_access");
			StringBuffer source;
			source.appendf("ws_access::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				iserv->onPermissionsResetInput(*request->queryContext(), *esp_request.get(), *esp_response.get());
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "ws_access", "PermissionsResetInput", StringBuffer(getCFD()).append("./smc_xslt/exceptions.xslt").str()))
				return 0;
			if (canRedirect(*request) && esp_response->getRedirectUrl() && *esp_response->getRedirectUrl())
			{
				response->redirect(*request, esp_response->getRedirectUrl());
			}
			else
			{
				IProperties *props=request->queryParameters();
				if (skipXslt(context))
				{
					MemoryBuffer content;
					StringBuffer mimetype;
					esp_response->appendContent(&context,content, mimetype);
					onBeforeSendResponse(context,request,content,service,method);
					response->setContent(content.length(), content.toByteArray());
					response->setContentType(mimetype.str());
				}
				else
				{
					StringBuffer xml;
					StringBuffer sResponse;
					if (request->supportClientXslt())
						xml.appendf("<?xml version=\"1.0\" encoding=\"UTF-8\"?><?xml-stylesheet type=\"text/xsl\" href=\"%s\"?>", "/esp/xslt/access_permissionresetinput.xslt");
					esp_response->serializeStruct(&context, xml, NULL);

					if (request->supportClientXslt()){
						xml.swapWith(sResponse);
						response->setContentType("text/xml");
					}else{
					xslTransform(xml.str(), "/esp/xslt/access_permissionresetinput.xslt", sResponse.clear(), context.queryXslParameters());
					response->setContentType("text/html");
					}
					response->setContent(sResponse.str());
				}
				response->send();
			}
			return 0;
		}
		if(!stricmp(method, "Ping")||!stricmp(method, "ws_accessPingRequest"))
		{
			Owned<Cws_accessPingRequest> esp_request = new Cws_accessPingRequest(&context, "ws_access", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			Cws_accessPingResponse* resp = new Cws_accessPingResponse("ws_access");
			esp_response.setown(resp);
			MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
			source.setf("ws_access::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				if(accessmap.ordinality()>0)
					onFeaturesAuthorize(context, accessmap, "ws_access", "Ping");
				iserv->onPing(context, *esp_request.get(), *resp);
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "ws_access", "Ping", StringBuffer(getCFD()).append("./smc_xslt/exceptions.xslt").str()))
				return 0;
		}
		if(!stricmp(method, "QueryScopeScansEnabled")||!stricmp(method, "QueryScopeScansEnabledRequest"))
		{
			Owned<CQueryScopeScansEnabledRequest> esp_request = new CQueryScopeScansEnabledRequest(&context, "ws_access", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			CQueryScopeScansEnabledResponse* resp = new CQueryScopeScansEnabledResponse("ws_access");
			esp_response.setown(resp);
			MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
			source.setf("ws_access::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				if(accessmap.ordinality()>0)
					onFeaturesAuthorize(context, accessmap, "ws_access", "QueryScopeScansEnabled");
				iserv->onQueryScopeScansEnabled(context, *esp_request.get(), *resp);
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "ws_access", "QueryScopeScansEnabled", StringBuffer(getCFD()).append("./smc_xslt/exceptions.xslt").str()))
				return 0;
		}
		if(!stricmp(method, "QueryUserViewColumns")||!stricmp(method, "QueryUserViewColumnsRequest"))
		{
			Owned<CQueryUserViewColumnsRequest> esp_request = new CQueryUserViewColumnsRequest(&context, "ws_access", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			CQueryUserViewColumnsResponse* resp = new CQueryUserViewColumnsResponse("ws_access");
			esp_response.setown(resp);
			MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
			source.setf("ws_access::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				if(accessmap.ordinality()>0)
					onFeaturesAuthorize(context, accessmap, "ws_access", "QueryUserViewColumns");
				iserv->onQueryUserViewColumns(context, *esp_request.get(), *resp);
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "ws_access", "QueryUserViewColumns", StringBuffer(getCFD()).append("./smc_xslt/exceptions.xslt").str()))
				return 0;
		}
		if(!stricmp(method, "QueryViewColumns")||!stricmp(method, "QueryViewColumnsRequest"))
		{
			Owned<CQueryViewColumnsRequest> esp_request = new CQueryViewColumnsRequest(&context, "ws_access", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			CQueryViewColumnsResponse* resp = new CQueryViewColumnsResponse("ws_access");
			esp_response.setown(resp);
			MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
			source.setf("ws_access::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				if(accessmap.ordinality()>0)
					onFeaturesAuthorize(context, accessmap, "ws_access", "QueryViewColumns");
				iserv->onQueryViewColumns(context, *esp_request.get(), *resp);
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "ws_access", "QueryViewColumns", StringBuffer(getCFD()).append("./smc_xslt/exceptions.xslt").str()))
				return 0;
		}
		if(!stricmp(method, "QueryViewMembers")||!stricmp(method, "QueryViewMembersRequest"))
		{
			Owned<CQueryViewMembersRequest> esp_request = new CQueryViewMembersRequest(&context, "ws_access", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			CQueryViewMembersResponse* resp = new CQueryViewMembersResponse("ws_access");
			esp_response.setown(resp);
			MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
			source.setf("ws_access::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				if(accessmap.ordinality()>0)
					onFeaturesAuthorize(context, accessmap, "ws_access", "QueryViewMembers");
				iserv->onQueryViewMembers(context, *esp_request.get(), *resp);
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "ws_access", "QueryViewMembers", StringBuffer(getCFD()).append("./smc_xslt/exceptions.xslt").str()))
				return 0;
		}
		if(!stricmp(method, "QueryViews")||!stricmp(method, "QueryViewsRequest"))
		{
			Owned<CQueryViewsRequest> esp_request = new CQueryViewsRequest(&context, "ws_access", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			CQueryViewsResponse* resp = new CQueryViewsResponse("ws_access");
			esp_response.setown(resp);
			MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
			source.setf("ws_access::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				if(accessmap.ordinality()>0)
					onFeaturesAuthorize(context, accessmap, "ws_access", "QueryViews");
				iserv->onQueryViews(context, *esp_request.get(), *resp);
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "ws_access", "QueryViews", StringBuffer(getCFD()).append("./smc_xslt/exceptions.xslt").str()))
				return 0;
		}
		if(!stricmp(method, "ResourceAdd")||!stricmp(method, "ResourceAddRequest"))
		{
			Owned<CResourceAddRequest> esp_request = new CResourceAddRequest(&context, "ws_access", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			Owned<CResourceAddResponse> esp_response = new CResourceAddResponse("ws_access");
			StringBuffer source;
			source.appendf("ws_access::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				iserv->onResourceAdd(*request->queryContext(), *esp_request.get(), *esp_response.get());
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "ws_access", "ResourceAdd", StringBuffer(getCFD()).append("./smc_xslt/exceptions.xslt").str()))
				return 0;
			if (canRedirect(*request) && esp_response->getRedirectUrl() && *esp_response->getRedirectUrl())
			{
				response->redirect(*request, esp_response->getRedirectUrl());
			}
			else
			{
				IProperties *props=request->queryParameters();
				if (skipXslt(context))
				{
					MemoryBuffer content;
					StringBuffer mimetype;
					esp_response->appendContent(&context,content, mimetype);
					onBeforeSendResponse(context,request,content,service,method);
					response->setContent(content.length(), content.toByteArray());
					response->setContentType(mimetype.str());
				}
				else
				{
					StringBuffer xml;
					StringBuffer sResponse;
					if (request->supportClientXslt())
						xml.appendf("<?xml version=\"1.0\" encoding=\"UTF-8\"?><?xml-stylesheet type=\"text/xsl\" href=\"%s\"?>", "/esp/xslt/access_resourceadd.xslt");
					esp_response->serializeStruct(&context, xml, NULL);

					if (request->supportClientXslt()){
						xml.swapWith(sResponse);
						response->setContentType("text/xml");
					}else{
					xslTransform(xml.str(), "/esp/xslt/access_resourceadd.xslt", sResponse.clear(), context.queryXslParameters());
					response->setContentType("text/html");
					}
					response->setContent(sResponse.str());
				}
				response->send();
			}
			return 0;
		}
		if(!stricmp(method, "ResourceAddInput")||!stricmp(method, "ResourceAddInputRequest"))
		{
			Owned<CResourceAddInputRequest> esp_request = new CResourceAddInputRequest(&context, "ws_access", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			Owned<CResourceAddInputResponse> esp_response = new CResourceAddInputResponse("ws_access");
			StringBuffer source;
			source.appendf("ws_access::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				iserv->onResourceAddInput(*request->queryContext(), *esp_request.get(), *esp_response.get());
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "ws_access", "ResourceAddInput", StringBuffer(getCFD()).append("./smc_xslt/exceptions.xslt").str()))
				return 0;
			if (canRedirect(*request) && esp_response->getRedirectUrl() && *esp_response->getRedirectUrl())
			{
				response->redirect(*request, esp_response->getRedirectUrl());
			}
			else
			{
				IProperties *props=request->queryParameters();
				if (skipXslt(context))
				{
					MemoryBuffer content;
					StringBuffer mimetype;
					esp_response->appendContent(&context,content, mimetype);
					onBeforeSendResponse(context,request,content,service,method);
					response->setContent(content.length(), content.toByteArray());
					response->setContentType(mimetype.str());
				}
				else
				{
					StringBuffer xml;
					StringBuffer sResponse;
					if (request->supportClientXslt())
						xml.appendf("<?xml version=\"1.0\" encoding=\"UTF-8\"?><?xml-stylesheet type=\"text/xsl\" href=\"%s\"?>", "/esp/xslt/access_resourceaddinput.xslt");
					esp_response->serializeStruct(&context, xml, NULL);

					if (request->supportClientXslt()){
						xml.swapWith(sResponse);
						response->setContentType("text/xml");
					}else{
					xslTransform(xml.str(), "/esp/xslt/access_resourceaddinput.xslt", sResponse.clear(), context.queryXslParameters());
					response->setContentType("text/html");
					}
					response->setContent(sResponse.str());
				}
				response->send();
			}
			return 0;
		}
		if(!stricmp(method, "ResourceDelete")||!stricmp(method, "ResourceDeleteRequest"))
		{
			Owned<CResourceDeleteRequest> esp_request = new CResourceDeleteRequest(&context, "ws_access", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			Owned<CResourceDeleteResponse> esp_response = new CResourceDeleteResponse("ws_access");
			StringBuffer source;
			source.appendf("ws_access::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				iserv->onResourceDelete(*request->queryContext(), *esp_request.get(), *esp_response.get());
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "ws_access", "ResourceDelete", StringBuffer(getCFD()).append("./smc_xslt/exceptions.xslt").str()))
				return 0;
			if (canRedirect(*request) && esp_response->getRedirectUrl() && *esp_response->getRedirectUrl())
			{
				response->redirect(*request, esp_response->getRedirectUrl());
			}
			else
			{
				IProperties *props=request->queryParameters();
				if (skipXslt(context))
				{
					MemoryBuffer content;
					StringBuffer mimetype;
					esp_response->appendContent(&context,content, mimetype);
					onBeforeSendResponse(context,request,content,service,method);
					response->setContent(content.length(), content.toByteArray());
					response->setContentType(mimetype.str());
				}
				else
				{
					StringBuffer xml;
					StringBuffer sResponse;
					if (request->supportClientXslt())
						xml.appendf("<?xml version=\"1.0\" encoding=\"UTF-8\"?><?xml-stylesheet type=\"text/xsl\" href=\"%s\"?>", "/esp/xslt/access_resourcedelete.xslt");
					esp_response->serializeStruct(&context, xml, NULL);

					if (request->supportClientXslt()){
						xml.swapWith(sResponse);
						response->setContentType("text/xml");
					}else{
					xslTransform(xml.str(), "/esp/xslt/access_resourcedelete.xslt", sResponse.clear(), context.queryXslParameters());
					response->setContentType("text/html");
					}
					response->setContent(sResponse.str());
				}
				response->send();
			}
			return 0;
		}
		if(!stricmp(method, "ResourcePermissionQuery")||!stricmp(method, "ResourcePermissionQueryRequest"))
		{
			Owned<CResourcePermissionQueryRequest> esp_request = new CResourcePermissionQueryRequest(&context, "ws_access", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			CResourcePermissionQueryResponse* resp = new CResourcePermissionQueryResponse("ws_access");
			esp_response.setown(resp);
			MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
			source.setf("ws_access::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				if(accessmap.ordinality()>0)
					onFeaturesAuthorize(context, accessmap, "ws_access", "ResourcePermissionQuery");
				iserv->onResourcePermissionQuery(context, *esp_request.get(), *resp);
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "ws_access", "ResourcePermissionQuery", StringBuffer(getCFD()).append("./smc_xslt/exceptions.xslt").str()))
				return 0;
		}
		if(!stricmp(method, "ResourcePermissions")||!stricmp(method, "ResourcePermissionsRequest"))
		{
			Owned<CResourcePermissionsRequest> esp_request = new CResourcePermissionsRequest(&context, "ws_access", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			Owned<CResourcePermissionsResponse> esp_response = new CResourcePermissionsResponse("ws_access");
			StringBuffer source;
			source.appendf("ws_access::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				iserv->onResourcePermissions(*request->queryContext(), *esp_request.get(), *esp_response.get());
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "ws_access", "ResourcePermissions", StringBuffer(getCFD()).append("./smc_xslt/exceptions.xslt").str()))
				return 0;
			if (canRedirect(*request) && esp_response->getRedirectUrl() && *esp_response->getRedirectUrl())
			{
				response->redirect(*request, esp_response->getRedirectUrl());
			}
			else
			{
				IProperties *props=request->queryParameters();
				if (skipXslt(context))
				{
					MemoryBuffer content;
					StringBuffer mimetype;
					esp_response->appendContent(&context,content, mimetype);
					onBeforeSendResponse(context,request,content,service,method);
					response->setContent(content.length(), content.toByteArray());
					response->setContentType(mimetype.str());
				}
				else
				{
					StringBuffer xml;
					StringBuffer sResponse;
					if (request->supportClientXslt())
						xml.appendf("<?xml version=\"1.0\" encoding=\"UTF-8\"?><?xml-stylesheet type=\"text/xsl\" href=\"%s\"?>", "/esp/xslt/access_permissions.xslt");
					esp_response->serializeStruct(&context, xml, NULL);

					if (request->supportClientXslt()){
						xml.swapWith(sResponse);
						response->setContentType("text/xml");
					}else{
					xslTransform(xml.str(), "/esp/xslt/access_permissions.xslt", sResponse.clear(), context.queryXslParameters());
					response->setContentType("text/html");
					}
					response->setContent(sResponse.str());
				}
				response->send();
			}
			return 0;
		}
		if(!stricmp(method, "ResourceQuery")||!stricmp(method, "ResourceQueryRequest"))
		{
			Owned<CResourceQueryRequest> esp_request = new CResourceQueryRequest(&context, "ws_access", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			CResourceQueryResponse* resp = new CResourceQueryResponse("ws_access");
			esp_response.setown(resp);
			MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
			source.setf("ws_access::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				if(accessmap.ordinality()>0)
					onFeaturesAuthorize(context, accessmap, "ws_access", "ResourceQuery");
				iserv->onResourceQuery(context, *esp_request.get(), *resp);
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "ws_access", "ResourceQuery", StringBuffer(getCFD()).append("./smc_xslt/exceptions.xslt").str()))
				return 0;
		}
		if(!stricmp(method, "Resources")||!stricmp(method, "ResourcesRequest"))
		{
			Owned<CResourcesRequest> esp_request = new CResourcesRequest(&context, "ws_access", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			Owned<CResourcesResponse> esp_response = new CResourcesResponse("ws_access");
			StringBuffer source;
			source.appendf("ws_access::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				iserv->onResources(*request->queryContext(), *esp_request.get(), *esp_response.get());
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "ws_access", "Resources", StringBuffer(getCFD()).append("./smc_xslt/exceptions.xslt").str()))
				return 0;
			if (canRedirect(*request) && esp_response->getRedirectUrl() && *esp_response->getRedirectUrl())
			{
				response->redirect(*request, esp_response->getRedirectUrl());
			}
			else
			{
				IProperties *props=request->queryParameters();
				if (skipXslt(context))
				{
					MemoryBuffer content;
					StringBuffer mimetype;
					esp_response->appendContent(&context,content, mimetype);
					onBeforeSendResponse(context,request,content,service,method);
					response->setContent(content.length(), content.toByteArray());
					response->setContentType(mimetype.str());
				}
				else
				{
					StringBuffer xml;
					StringBuffer sResponse;
					if (request->supportClientXslt())
						xml.appendf("<?xml version=\"1.0\" encoding=\"UTF-8\"?><?xml-stylesheet type=\"text/xsl\" href=\"%s\"?>", "/esp/xslt/access_resources.xslt");
					esp_response->serializeStruct(&context, xml, NULL);

					if (request->supportClientXslt()){
						xml.swapWith(sResponse);
						response->setContentType("text/xml");
					}else{
					xslTransform(xml.str(), "/esp/xslt/access_resources.xslt", sResponse.clear(), context.queryXslParameters());
					response->setContentType("text/html");
					}
					response->setContent(sResponse.str());
				}
				response->send();
			}
			return 0;
		}
		if(!stricmp(method, "UserAccountExport")||!stricmp(method, "UserAccountExportRequest"))
		{
			Owned<CUserAccountExportRequest> esp_request = new CUserAccountExportRequest(&context, "ws_access", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			CUserAccountExportResponse* resp = new CUserAccountExportResponse("ws_access");
			esp_response.setown(resp);
			MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
			source.setf("ws_access::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				if(accessmap.ordinality()>0)
					onFeaturesAuthorize(context, accessmap, "ws_access", "UserAccountExport");
				iserv->onUserAccountExport(context, *esp_request.get(), *resp);
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "ws_access", "UserAccountExport", StringBuffer(getCFD()).append("./smc_xslt/exceptions.xslt").str()))
				return 0;
		}
		if(!stricmp(method, "UserAction")||!stricmp(method, "UserActionRequest"))
		{
			Owned<CUserActionRequest> esp_request = new CUserActionRequest(&context, "ws_access", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			Owned<CUserActionResponse> esp_response = new CUserActionResponse("ws_access");
			StringBuffer source;
			source.appendf("ws_access::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				iserv->onUserAction(*request->queryContext(), *esp_request.get(), *esp_response.get());
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "ws_access", "UserAction", StringBuffer(getCFD()).append("./smc_xslt/exceptions.xslt").str()))
				return 0;
			if (canRedirect(*request) && esp_response->getRedirectUrl() && *esp_response->getRedirectUrl())
			{
				response->redirect(*request, esp_response->getRedirectUrl());
			}
			else
			{
				IProperties *props=request->queryParameters();
				if (skipXslt(context))
				{
					MemoryBuffer content;
					StringBuffer mimetype;
					esp_response->appendContent(&context,content, mimetype);
					onBeforeSendResponse(context,request,content,service,method);
					response->setContent(content.length(), content.toByteArray());
					response->setContentType(mimetype.str());
				}
				else
				{
					StringBuffer xml;
					StringBuffer sResponse;
					if (request->supportClientXslt())
						xml.appendf("<?xml version=\"1.0\" encoding=\"UTF-8\"?><?xml-stylesheet type=\"text/xsl\" href=\"%s\"?>", "/esp/xslt/access_useraction.xslt");
					esp_response->serializeStruct(&context, xml, NULL);

					if (request->supportClientXslt()){
						xml.swapWith(sResponse);
						response->setContentType("text/xml");
					}else{
					xslTransform(xml.str(), "/esp/xslt/access_useraction.xslt", sResponse.clear(), context.queryXslParameters());
					response->setContentType("text/html");
					}
					response->setContent(sResponse.str());
				}
				response->send();
			}
			return 0;
		}
		if(!stricmp(method, "UserEdit")||!stricmp(method, "UserEditRequest"))
		{
			Owned<CUserEditRequest> esp_request = new CUserEditRequest(&context, "ws_access", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			Owned<CUserEditResponse> esp_response = new CUserEditResponse("ws_access");
			StringBuffer source;
			source.appendf("ws_access::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				iserv->onUserEdit(*request->queryContext(), *esp_request.get(), *esp_response.get());
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "ws_access", "UserEdit", StringBuffer(getCFD()).append("./smc_xslt/exceptions.xslt").str()))
				return 0;
			if (canRedirect(*request) && esp_response->getRedirectUrl() && *esp_response->getRedirectUrl())
			{
				response->redirect(*request, esp_response->getRedirectUrl());
			}
			else
			{
				IProperties *props=request->queryParameters();
				if (skipXslt(context))
				{
					MemoryBuffer content;
					StringBuffer mimetype;
					esp_response->appendContent(&context,content, mimetype);
					onBeforeSendResponse(context,request,content,service,method);
					response->setContent(content.length(), content.toByteArray());
					response->setContentType(mimetype.str());
				}
				else
				{
					StringBuffer xml;
					StringBuffer sResponse;
					if (request->supportClientXslt())
						xml.appendf("<?xml version=\"1.0\" encoding=\"UTF-8\"?><?xml-stylesheet type=\"text/xsl\" href=\"%s\"?>", "/esp/xslt/access_useredit.xslt");
					esp_response->serializeStruct(&context, xml, NULL);

					if (request->supportClientXslt()){
						xml.swapWith(sResponse);
						response->setContentType("text/xml");
					}else{
					xslTransform(xml.str(), "/esp/xslt/access_useredit.xslt", sResponse.clear(), context.queryXslParameters());
					response->setContentType("text/html");
					}
					response->setContent(sResponse.str());
				}
				response->send();
			}
			return 0;
		}
		if(!stricmp(method, "UserGroupEdit")||!stricmp(method, "UserGroupEditRequest"))
		{
			Owned<CUserGroupEditRequest> esp_request = new CUserGroupEditRequest(&context, "ws_access", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			Owned<CUserGroupEditResponse> esp_response = new CUserGroupEditResponse("ws_access");
			StringBuffer source;
			source.appendf("ws_access::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				iserv->onUserGroupEdit(*request->queryContext(), *esp_request.get(), *esp_response.get());
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "ws_access", "UserGroupEdit", StringBuffer(getCFD()).append("./smc_xslt/exceptions.xslt").str()))
				return 0;
			if (canRedirect(*request) && esp_response->getRedirectUrl() && *esp_response->getRedirectUrl())
			{
				response->redirect(*request, esp_response->getRedirectUrl());
			}
			else
			{
				IProperties *props=request->queryParameters();
				if (skipXslt(context))
				{
					MemoryBuffer content;
					StringBuffer mimetype;
					esp_response->appendContent(&context,content, mimetype);
					onBeforeSendResponse(context,request,content,service,method);
					response->setContent(content.length(), content.toByteArray());
					response->setContentType(mimetype.str());
				}
				else
				{
					StringBuffer xml;
					StringBuffer sResponse;
					if (request->supportClientXslt())
						xml.appendf("<?xml version=\"1.0\" encoding=\"UTF-8\"?><?xml-stylesheet type=\"text/xsl\" href=\"%s\"?>", "/esp/xslt/access_usergroupedit.xslt");
					esp_response->serializeStruct(&context, xml, NULL);

					if (request->supportClientXslt()){
						xml.swapWith(sResponse);
						response->setContentType("text/xml");
					}else{
					xslTransform(xml.str(), "/esp/xslt/access_usergroupedit.xslt", sResponse.clear(), context.queryXslParameters());
					response->setContentType("text/html");
					}
					response->setContent(sResponse.str());
				}
				response->send();
			}
			return 0;
		}
		if(!stricmp(method, "UserGroupEditInput")||!stricmp(method, "UserGroupEditInputRequest"))
		{
			Owned<CUserGroupEditInputRequest> esp_request = new CUserGroupEditInputRequest(&context, "ws_access", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			Owned<CUserGroupEditInputResponse> esp_response = new CUserGroupEditInputResponse("ws_access");
			StringBuffer source;
			source.appendf("ws_access::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				iserv->onUserGroupEditInput(*request->queryContext(), *esp_request.get(), *esp_response.get());
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "ws_access", "UserGroupEditInput", StringBuffer(getCFD()).append("./smc_xslt/exceptions.xslt").str()))
				return 0;
			if (canRedirect(*request) && esp_response->getRedirectUrl() && *esp_response->getRedirectUrl())
			{
				response->redirect(*request, esp_response->getRedirectUrl());
			}
			else
			{
				IProperties *props=request->queryParameters();
				if (skipXslt(context))
				{
					MemoryBuffer content;
					StringBuffer mimetype;
					esp_response->appendContent(&context,content, mimetype);
					onBeforeSendResponse(context,request,content,service,method);
					response->setContent(content.length(), content.toByteArray());
					response->setContentType(mimetype.str());
				}
				else
				{
					StringBuffer xml;
					StringBuffer sResponse;
					if (request->supportClientXslt())
						xml.appendf("<?xml version=\"1.0\" encoding=\"UTF-8\"?><?xml-stylesheet type=\"text/xsl\" href=\"%s\"?>", "/esp/xslt/access_usergroupeditinput.xslt");
					esp_response->serializeStruct(&context, xml, NULL);

					if (request->supportClientXslt()){
						xml.swapWith(sResponse);
						response->setContentType("text/xml");
					}else{
					xslTransform(xml.str(), "/esp/xslt/access_usergroupeditinput.xslt", sResponse.clear(), context.queryXslParameters());
					response->setContentType("text/html");
					}
					response->setContent(sResponse.str());
				}
				response->send();
			}
			return 0;
		}
		if(!stricmp(method, "UserInfoEdit")||!stricmp(method, "UserInfoEditRequest"))
		{
			Owned<CUserInfoEditRequest> esp_request = new CUserInfoEditRequest(&context, "ws_access", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			Owned<CUserInfoEditResponse> esp_response = new CUserInfoEditResponse("ws_access");
			StringBuffer source;
			source.appendf("ws_access::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				iserv->onUserInfoEdit(*request->queryContext(), *esp_request.get(), *esp_response.get());
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "ws_access", "UserInfoEdit", StringBuffer(getCFD()).append("./smc_xslt/exceptions.xslt").str()))
				return 0;
			if (canRedirect(*request) && esp_response->getRedirectUrl() && *esp_response->getRedirectUrl())
			{
				response->redirect(*request, esp_response->getRedirectUrl());
			}
			else
			{
				IProperties *props=request->queryParameters();
				if (skipXslt(context))
				{
					MemoryBuffer content;
					StringBuffer mimetype;
					esp_response->appendContent(&context,content, mimetype);
					onBeforeSendResponse(context,request,content,service,method);
					response->setContent(content.length(), content.toByteArray());
					response->setContentType(mimetype.str());
				}
				else
				{
					StringBuffer xml;
					StringBuffer sResponse;
					if (request->supportClientXslt())
						xml.appendf("<?xml version=\"1.0\" encoding=\"UTF-8\"?><?xml-stylesheet type=\"text/xsl\" href=\"%s\"?>", "/esp/xslt/access_userinfoedit.xslt");
					esp_response->serializeStruct(&context, xml, NULL);

					if (request->supportClientXslt()){
						xml.swapWith(sResponse);
						response->setContentType("text/xml");
					}else{
					xslTransform(xml.str(), "/esp/xslt/access_userinfoedit.xslt", sResponse.clear(), context.queryXslParameters());
					response->setContentType("text/html");
					}
					response->setContent(sResponse.str());
				}
				response->send();
			}
			return 0;
		}
		if(!stricmp(method, "UserInfoEditInput")||!stricmp(method, "UserInfoEditInputRequest"))
		{
			Owned<CUserInfoEditInputRequest> esp_request = new CUserInfoEditInputRequest(&context, "ws_access", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			Owned<CUserInfoEditInputResponse> esp_response = new CUserInfoEditInputResponse("ws_access");
			StringBuffer source;
			source.appendf("ws_access::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				iserv->onUserInfoEditInput(*request->queryContext(), *esp_request.get(), *esp_response.get());
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "ws_access", "UserInfoEditInput", StringBuffer(getCFD()).append("./smc_xslt/exceptions.xslt").str()))
				return 0;
			if (canRedirect(*request) && esp_response->getRedirectUrl() && *esp_response->getRedirectUrl())
			{
				response->redirect(*request, esp_response->getRedirectUrl());
			}
			else
			{
				IProperties *props=request->queryParameters();
				if (skipXslt(context))
				{
					MemoryBuffer content;
					StringBuffer mimetype;
					esp_response->appendContent(&context,content, mimetype);
					onBeforeSendResponse(context,request,content,service,method);
					response->setContent(content.length(), content.toByteArray());
					response->setContentType(mimetype.str());
				}
				else
				{
					StringBuffer xml;
					StringBuffer sResponse;
					if (request->supportClientXslt())
						xml.appendf("<?xml version=\"1.0\" encoding=\"UTF-8\"?><?xml-stylesheet type=\"text/xsl\" href=\"%s\"?>", "/esp/xslt/access_userinfoeditinput.xslt");
					esp_response->serializeStruct(&context, xml, NULL);

					if (request->supportClientXslt()){
						xml.swapWith(sResponse);
						response->setContentType("text/xml");
					}else{
					xslTransform(xml.str(), "/esp/xslt/access_userinfoeditinput.xslt", sResponse.clear(), context.queryXslParameters());
					response->setContentType("text/html");
					}
					response->setContent(sResponse.str());
				}
				response->send();
			}
			return 0;
		}
		if(!stricmp(method, "UserPosix")||!stricmp(method, "UserPosixRequest"))
		{
			Owned<CUserPosixRequest> esp_request = new CUserPosixRequest(&context, "ws_access", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			Owned<CUserPosixResponse> esp_response = new CUserPosixResponse("ws_access");
			StringBuffer source;
			source.appendf("ws_access::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				iserv->onUserPosix(*request->queryContext(), *esp_request.get(), *esp_response.get());
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "ws_access", "UserPosix", StringBuffer(getCFD()).append("./smc_xslt/exceptions.xslt").str()))
				return 0;
			if (canRedirect(*request) && esp_response->getRedirectUrl() && *esp_response->getRedirectUrl())
			{
				response->redirect(*request, esp_response->getRedirectUrl());
			}
			else
			{
				IProperties *props=request->queryParameters();
				if (skipXslt(context))
				{
					MemoryBuffer content;
					StringBuffer mimetype;
					esp_response->appendContent(&context,content, mimetype);
					onBeforeSendResponse(context,request,content,service,method);
					response->setContent(content.length(), content.toByteArray());
					response->setContentType(mimetype.str());
				}
				else
				{
					StringBuffer xml;
					StringBuffer sResponse;
					if (request->supportClientXslt())
						xml.appendf("<?xml version=\"1.0\" encoding=\"UTF-8\"?><?xml-stylesheet type=\"text/xsl\" href=\"%s\"?>", "/esp/xslt/access_posix.xslt");
					esp_response->serializeStruct(&context, xml, NULL);

					if (request->supportClientXslt()){
						xml.swapWith(sResponse);
						response->setContentType("text/xml");
					}else{
					xslTransform(xml.str(), "/esp/xslt/access_posix.xslt", sResponse.clear(), context.queryXslParameters());
					response->setContentType("text/html");
					}
					response->setContent(sResponse.str());
				}
				response->send();
			}
			return 0;
		}
		if(!stricmp(method, "UserPosixInput")||!stricmp(method, "UserPosixInputRequest"))
		{
			Owned<CUserPosixInputRequest> esp_request = new CUserPosixInputRequest(&context, "ws_access", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			Owned<CUserPosixInputResponse> esp_response = new CUserPosixInputResponse("ws_access");
			StringBuffer source;
			source.appendf("ws_access::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				iserv->onUserPosixInput(*request->queryContext(), *esp_request.get(), *esp_response.get());
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "ws_access", "UserPosixInput", StringBuffer(getCFD()).append("./smc_xslt/exceptions.xslt").str()))
				return 0;
			if (canRedirect(*request) && esp_response->getRedirectUrl() && *esp_response->getRedirectUrl())
			{
				response->redirect(*request, esp_response->getRedirectUrl());
			}
			else
			{
				IProperties *props=request->queryParameters();
				if (skipXslt(context))
				{
					MemoryBuffer content;
					StringBuffer mimetype;
					esp_response->appendContent(&context,content, mimetype);
					onBeforeSendResponse(context,request,content,service,method);
					response->setContent(content.length(), content.toByteArray());
					response->setContentType(mimetype.str());
				}
				else
				{
					StringBuffer xml;
					StringBuffer sResponse;
					if (request->supportClientXslt())
						xml.appendf("<?xml version=\"1.0\" encoding=\"UTF-8\"?><?xml-stylesheet type=\"text/xsl\" href=\"%s\"?>", "/esp/xslt/access_posixinput.xslt");
					esp_response->serializeStruct(&context, xml, NULL);

					if (request->supportClientXslt()){
						xml.swapWith(sResponse);
						response->setContentType("text/xml");
					}else{
					xslTransform(xml.str(), "/esp/xslt/access_posixinput.xslt", sResponse.clear(), context.queryXslParameters());
					response->setContentType("text/html");
					}
					response->setContent(sResponse.str());
				}
				response->send();
			}
			return 0;
		}
		if(!stricmp(method, "UserQuery")||!stricmp(method, "UserQueryRequest"))
		{
			Owned<CUserQueryRequest> esp_request = new CUserQueryRequest(&context, "ws_access", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			CUserQueryResponse* resp = new CUserQueryResponse("ws_access");
			esp_response.setown(resp);
			MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
			source.setf("ws_access::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				if(accessmap.ordinality()>0)
					onFeaturesAuthorize(context, accessmap, "ws_access", "UserQuery");
				iserv->onUserQuery(context, *esp_request.get(), *resp);
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "ws_access", "UserQuery", StringBuffer(getCFD()).append("./smc_xslt/exceptions.xslt").str()))
				return 0;
		}
		if(!stricmp(method, "UserResetPass")||!stricmp(method, "UserResetPassRequest"))
		{
			Owned<CUserResetPassRequest> esp_request = new CUserResetPassRequest(&context, "ws_access", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			Owned<CUserResetPassResponse> esp_response = new CUserResetPassResponse("ws_access");
			StringBuffer source;
			source.appendf("ws_access::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				iserv->onUserResetPass(*request->queryContext(), *esp_request.get(), *esp_response.get());
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "ws_access", "UserResetPass", StringBuffer(getCFD()).append("./smc_xslt/exceptions.xslt").str()))
				return 0;
			if (canRedirect(*request) && esp_response->getRedirectUrl() && *esp_response->getRedirectUrl())
			{
				response->redirect(*request, esp_response->getRedirectUrl());
			}
			else
			{
				IProperties *props=request->queryParameters();
				if (skipXslt(context))
				{
					MemoryBuffer content;
					StringBuffer mimetype;
					esp_response->appendContent(&context,content, mimetype);
					onBeforeSendResponse(context,request,content,service,method);
					response->setContent(content.length(), content.toByteArray());
					response->setContentType(mimetype.str());
				}
				else
				{
					StringBuffer xml;
					StringBuffer sResponse;
					if (request->supportClientXslt())
						xml.appendf("<?xml version=\"1.0\" encoding=\"UTF-8\"?><?xml-stylesheet type=\"text/xsl\" href=\"%s\"?>", "/esp/xslt/access_resetpass.xslt");
					esp_response->serializeStruct(&context, xml, NULL);

					if (request->supportClientXslt()){
						xml.swapWith(sResponse);
						response->setContentType("text/xml");
					}else{
					xslTransform(xml.str(), "/esp/xslt/access_resetpass.xslt", sResponse.clear(), context.queryXslParameters());
					response->setContentType("text/html");
					}
					response->setContent(sResponse.str());
				}
				response->send();
			}
			return 0;
		}
		if(!stricmp(method, "UserResetPassInput")||!stricmp(method, "UserResetPassInputRequest"))
		{
			Owned<CUserResetPassInputRequest> esp_request = new CUserResetPassInputRequest(&context, "ws_access", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			Owned<CUserResetPassInputResponse> esp_response = new CUserResetPassInputResponse("ws_access");
			StringBuffer source;
			source.appendf("ws_access::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				iserv->onUserResetPassInput(*request->queryContext(), *esp_request.get(), *esp_response.get());
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "ws_access", "UserResetPassInput", StringBuffer(getCFD()).append("./smc_xslt/exceptions.xslt").str()))
				return 0;
			if (canRedirect(*request) && esp_response->getRedirectUrl() && *esp_response->getRedirectUrl())
			{
				response->redirect(*request, esp_response->getRedirectUrl());
			}
			else
			{
				IProperties *props=request->queryParameters();
				if (skipXslt(context))
				{
					MemoryBuffer content;
					StringBuffer mimetype;
					esp_response->appendContent(&context,content, mimetype);
					onBeforeSendResponse(context,request,content,service,method);
					response->setContent(content.length(), content.toByteArray());
					response->setContentType(mimetype.str());
				}
				else
				{
					StringBuffer xml;
					StringBuffer sResponse;
					if (request->supportClientXslt())
						xml.appendf("<?xml version=\"1.0\" encoding=\"UTF-8\"?><?xml-stylesheet type=\"text/xsl\" href=\"%s\"?>", "/esp/xslt/access_resetpassinput.xslt");
					esp_response->serializeStruct(&context, xml, NULL);

					if (request->supportClientXslt()){
						xml.swapWith(sResponse);
						response->setContentType("text/xml");
					}else{
					xslTransform(xml.str(), "/esp/xslt/access_resetpassinput.xslt", sResponse.clear(), context.queryXslParameters());
					response->setContentType("text/html");
					}
					response->setContent(sResponse.str());
				}
				response->send();
			}
			return 0;
		}
		if(!stricmp(method, "UserSudoers")||!stricmp(method, "UserSudoersRequest"))
		{
			Owned<CUserSudoersRequest> esp_request = new CUserSudoersRequest(&context, "ws_access", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			Owned<CUserSudoersResponse> esp_response = new CUserSudoersResponse("ws_access");
			StringBuffer source;
			source.appendf("ws_access::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				iserv->onUserSudoers(*request->queryContext(), *esp_request.get(), *esp_response.get());
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "ws_access", "UserSudoers", StringBuffer(getCFD()).append("./smc_xslt/exceptions.xslt").str()))
				return 0;
			if (canRedirect(*request) && esp_response->getRedirectUrl() && *esp_response->getRedirectUrl())
			{
				response->redirect(*request, esp_response->getRedirectUrl());
			}
			else
			{
				IProperties *props=request->queryParameters();
				if (skipXslt(context))
				{
					MemoryBuffer content;
					StringBuffer mimetype;
					esp_response->appendContent(&context,content, mimetype);
					onBeforeSendResponse(context,request,content,service,method);
					response->setContent(content.length(), content.toByteArray());
					response->setContentType(mimetype.str());
				}
				else
				{
					StringBuffer xml;
					StringBuffer sResponse;
					if (request->supportClientXslt())
						xml.appendf("<?xml version=\"1.0\" encoding=\"UTF-8\"?><?xml-stylesheet type=\"text/xsl\" href=\"%s\"?>", "/esp/xslt/access_sudoers.xslt");
					esp_response->serializeStruct(&context, xml, NULL);

					if (request->supportClientXslt()){
						xml.swapWith(sResponse);
						response->setContentType("text/xml");
					}else{
					xslTransform(xml.str(), "/esp/xslt/access_sudoers.xslt", sResponse.clear(), context.queryXslParameters());
					response->setContentType("text/html");
					}
					response->setContent(sResponse.str());
				}
				response->send();
			}
			return 0;
		}
		if(!stricmp(method, "UserSudoersInput")||!stricmp(method, "UserSudoersInputRequest"))
		{
			Owned<CUserSudoersInputRequest> esp_request = new CUserSudoersInputRequest(&context, "ws_access", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			Owned<CUserSudoersInputResponse> esp_response = new CUserSudoersInputResponse("ws_access");
			StringBuffer source;
			source.appendf("ws_access::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				iserv->onUserSudoersInput(*request->queryContext(), *esp_request.get(), *esp_response.get());
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "ws_access", "UserSudoersInput", StringBuffer(getCFD()).append("./smc_xslt/exceptions.xslt").str()))
				return 0;
			if (canRedirect(*request) && esp_response->getRedirectUrl() && *esp_response->getRedirectUrl())
			{
				response->redirect(*request, esp_response->getRedirectUrl());
			}
			else
			{
				IProperties *props=request->queryParameters();
				if (skipXslt(context))
				{
					MemoryBuffer content;
					StringBuffer mimetype;
					esp_response->appendContent(&context,content, mimetype);
					onBeforeSendResponse(context,request,content,service,method);
					response->setContent(content.length(), content.toByteArray());
					response->setContentType(mimetype.str());
				}
				else
				{
					StringBuffer xml;
					StringBuffer sResponse;
					if (request->supportClientXslt())
						xml.appendf("<?xml version=\"1.0\" encoding=\"UTF-8\"?><?xml-stylesheet type=\"text/xsl\" href=\"%s\"?>", "/esp/xslt/access_sudoersinput.xslt");
					esp_response->serializeStruct(&context, xml, NULL);

					if (request->supportClientXslt()){
						xml.swapWith(sResponse);
						response->setContentType("text/xml");
					}else{
					xslTransform(xml.str(), "/esp/xslt/access_sudoersinput.xslt", sResponse.clear(), context.queryXslParameters());
					response->setContentType("text/html");
					}
					response->setContent(sResponse.str());
				}
				response->send();
			}
			return 0;
		}
		if(!stricmp(method, "Users")||!stricmp(method, "UserRequest"))
		{
			Owned<CUserRequest> esp_request = new CUserRequest(&context, "ws_access", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			Owned<CUserResponse> esp_response = new CUserResponse("ws_access");
			StringBuffer source;
			source.appendf("ws_access::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				iserv->onUsers(*request->queryContext(), *esp_request.get(), *esp_response.get());
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "ws_access", "Users", StringBuffer(getCFD()).append("./smc_xslt/exceptions.xslt").str()))
				return 0;
			if (canRedirect(*request) && esp_response->getRedirectUrl() && *esp_response->getRedirectUrl())
			{
				response->redirect(*request, esp_response->getRedirectUrl());
			}
			else
			{
				IProperties *props=request->queryParameters();
				if (skipXslt(context))
				{
					MemoryBuffer content;
					StringBuffer mimetype;
					esp_response->appendContent(&context,content, mimetype);
					onBeforeSendResponse(context,request,content,service,method);
					response->setContent(content.length(), content.toByteArray());
					response->setContentType(mimetype.str());
				}
				else
				{
					StringBuffer xml;
					StringBuffer sResponse;
					if (request->supportClientXslt())
						xml.appendf("<?xml version=\"1.0\" encoding=\"UTF-8\"?><?xml-stylesheet type=\"text/xsl\" href=\"%s\"?>", "/esp/xslt/access_users.xslt");
					esp_response->serializeStruct(&context, xml, NULL);

					if (request->supportClientXslt()){
						xml.swapWith(sResponse);
						response->setContentType("text/xml");
					}else{
					xslTransform(xml.str(), "/esp/xslt/access_users.xslt", sResponse.clear(), context.queryXslParameters());
					response->setContentType("text/html");
					}
					response->setContent(sResponse.str());
				}
				response->send();
			}
			return 0;
		}

		if (esp_response.get())
		{
			if (canRedirect(*request) && esp_response->getRedirectUrl() && *esp_response->getRedirectUrl())
				response->redirect(*request, esp_response->getRedirectUrl());
			else
			{
				MemoryBuffer content;
				StringBuffer mimetype;
				esp_response->appendContent(&context,content, mimetype);
				onBeforeSendResponse(context,request,content,service,method);
				response->setContent(content.length(), content.toByteArray());
				response->setContentType(mimetype.str());
				response->send();
			}
			return 0;
		}
	}
	return onGetNotFound(context, request,  response, service);
}





//=======================================================
// client util methods
//=======================================================

//------ method AccountPermissions ---------

IClientAccountPermissionsRequest * CClientws_access::createAccountPermissionsRequest()
{
	CAccountPermissionsRequest* request = new CAccountPermissionsRequest("ws_access");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientAccountPermissionsResponse * CClientws_access::AccountPermissions(IClientAccountPermissionsRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CAccountPermissionsRequest* esprequest = static_cast<CAccountPermissionsRequest*>(request);
	CAccountPermissionsResponse* espresponse = new CAccountPermissionsResponse("ws_access");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientws_access::async_AccountPermissions(IClientAccountPermissionsRequest *request, IClientws_accessEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CAccountPermissionsRequest* esprequest = static_cast<CAccountPermissionsRequest*>(request);
	esprequest->setMethod("AccountPermissions");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientws_access::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientAccountPermissionsResponse *CClientws_access::AccountPermissionsFn(const char * AccountName_, bool IsGroup_, bool IncludeGroup_)
{
	Owned<IClientAccountPermissionsRequest> req =  createAccountPermissionsRequest();
	req->setAccountName(AccountName_);
	req->setIsGroup(IsGroup_);
	req->setIncludeGroup(IncludeGroup_);
	return AccountPermissions(req.get());
}

//------ method AddUser ---------

IClientAddUserRequest * CClientws_access::createAddUserRequest()
{
	CAddUserRequest* request = new CAddUserRequest("ws_access");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientAddUserResponse * CClientws_access::AddUser(IClientAddUserRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CAddUserRequest* esprequest = static_cast<CAddUserRequest*>(request);
	CAddUserResponse* espresponse = new CAddUserResponse("ws_access");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientws_access::async_AddUser(IClientAddUserRequest *request, IClientws_accessEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CAddUserRequest* esprequest = static_cast<CAddUserRequest*>(request);
	esprequest->setMethod("AddUser");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientws_access::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientAddUserResponse *CClientws_access::AddUserFn(const char * username_, const char * firstname_, const char * lastname_, const char * password1_, const char * password2_, const char * employeeID_)
{
	Owned<IClientAddUserRequest> req =  createAddUserRequest();
	req->setUsername(username_);
	req->setFirstname(firstname_);
	req->setLastname(lastname_);
	req->setPassword1(password1_);
	req->setPassword2(password2_);
	req->setEmployeeID(employeeID_);
	return AddUser(req.get());
}

//------ method AddView ---------

IClientAddViewRequest * CClientws_access::createAddViewRequest()
{
	CAddViewRequest* request = new CAddViewRequest("ws_access");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientAddViewResponse * CClientws_access::AddView(IClientAddViewRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CAddViewRequest* esprequest = static_cast<CAddViewRequest*>(request);
	CAddViewResponse* espresponse = new CAddViewResponse("ws_access");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientws_access::async_AddView(IClientAddViewRequest *request, IClientws_accessEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CAddViewRequest* esprequest = static_cast<CAddViewRequest*>(request);
	esprequest->setMethod("AddView");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientws_access::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientAddViewResponse *CClientws_access::AddViewFn(const char * viewname_, const char * description_)
{
	Owned<IClientAddViewRequest> req =  createAddViewRequest();
	req->setViewname(viewname_);
	req->setDescription(description_);
	return AddView(req.get());
}

//------ method AddViewColumn ---------

IClientAddViewColumnRequest * CClientws_access::createAddViewColumnRequest()
{
	CAddViewColumnRequest* request = new CAddViewColumnRequest("ws_access");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientAddViewColumnResponse * CClientws_access::AddViewColumn(IClientAddViewColumnRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CAddViewColumnRequest* esprequest = static_cast<CAddViewColumnRequest*>(request);
	CAddViewColumnResponse* espresponse = new CAddViewColumnResponse("ws_access");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientws_access::async_AddViewColumn(IClientAddViewColumnRequest *request, IClientws_accessEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CAddViewColumnRequest* esprequest = static_cast<CAddViewColumnRequest*>(request);
	esprequest->setMethod("AddViewColumn");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientws_access::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientAddViewColumnResponse *CClientws_access::AddViewColumnFn(const char * viewname_, const char * filename_, const char * columnname_)
{
	Owned<IClientAddViewColumnRequest> req =  createAddViewColumnRequest();
	req->setViewname(viewname_);
	req->setFilename(filename_);
	req->setColumnname(columnname_);
	return AddViewColumn(req.get());
}

//------ method AddViewMember ---------

IClientAddViewMemberRequest * CClientws_access::createAddViewMemberRequest()
{
	CAddViewMemberRequest* request = new CAddViewMemberRequest("ws_access");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientAddViewMemberResponse * CClientws_access::AddViewMember(IClientAddViewMemberRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CAddViewMemberRequest* esprequest = static_cast<CAddViewMemberRequest*>(request);
	CAddViewMemberResponse* espresponse = new CAddViewMemberResponse("ws_access");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientws_access::async_AddViewMember(IClientAddViewMemberRequest *request, IClientws_accessEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CAddViewMemberRequest* esprequest = static_cast<CAddViewMemberRequest*>(request);
	esprequest->setMethod("AddViewMember");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientws_access::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientAddViewMemberResponse *CClientws_access::AddViewMemberFn(const char * viewname_, const char * membername_, CViewMemberType membertype_)
{
	Owned<IClientAddViewMemberRequest> req =  createAddViewMemberRequest();
	req->setViewname(viewname_);
	req->setMembername(membername_);
	req->setMembertype(membertype_);
	return AddViewMember(req.get());
}

//------ method ClearPermissionsCache ---------

IClientClearPermissionsCacheRequest * CClientws_access::createClearPermissionsCacheRequest()
{
	CClearPermissionsCacheRequest* request = new CClearPermissionsCacheRequest("ws_access");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientClearPermissionsCacheResponse * CClientws_access::ClearPermissionsCache(IClientClearPermissionsCacheRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CClearPermissionsCacheRequest* esprequest = static_cast<CClearPermissionsCacheRequest*>(request);
	CClearPermissionsCacheResponse* espresponse = new CClearPermissionsCacheResponse("ws_access");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientws_access::async_ClearPermissionsCache(IClientClearPermissionsCacheRequest *request, IClientws_accessEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CClearPermissionsCacheRequest* esprequest = static_cast<CClearPermissionsCacheRequest*>(request);
	esprequest->setMethod("ClearPermissionsCache");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientws_access::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientClearPermissionsCacheResponse *CClientws_access::ClearPermissionsCacheFn()
{
	Owned<IClientClearPermissionsCacheRequest> req =  createClearPermissionsCacheRequest();
	return ClearPermissionsCache(req.get());
}

//------ method DeleteView ---------

IClientDeleteViewRequest * CClientws_access::createDeleteViewRequest()
{
	CDeleteViewRequest* request = new CDeleteViewRequest("ws_access");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientDeleteViewResponse * CClientws_access::DeleteView(IClientDeleteViewRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CDeleteViewRequest* esprequest = static_cast<CDeleteViewRequest*>(request);
	CDeleteViewResponse* espresponse = new CDeleteViewResponse("ws_access");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientws_access::async_DeleteView(IClientDeleteViewRequest *request, IClientws_accessEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CDeleteViewRequest* esprequest = static_cast<CDeleteViewRequest*>(request);
	esprequest->setMethod("DeleteView");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientws_access::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientDeleteViewResponse *CClientws_access::DeleteViewFn(const char * viewname_)
{
	Owned<IClientDeleteViewRequest> req =  createDeleteViewRequest();
	req->setViewname(viewname_);
	return DeleteView(req.get());
}

//------ method DeleteViewColumn ---------

IClientDeleteViewColumnRequest * CClientws_access::createDeleteViewColumnRequest()
{
	CDeleteViewColumnRequest* request = new CDeleteViewColumnRequest("ws_access");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientDeleteViewColumnResponse * CClientws_access::DeleteViewColumn(IClientDeleteViewColumnRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CDeleteViewColumnRequest* esprequest = static_cast<CDeleteViewColumnRequest*>(request);
	CDeleteViewColumnResponse* espresponse = new CDeleteViewColumnResponse("ws_access");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientws_access::async_DeleteViewColumn(IClientDeleteViewColumnRequest *request, IClientws_accessEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CDeleteViewColumnRequest* esprequest = static_cast<CDeleteViewColumnRequest*>(request);
	esprequest->setMethod("DeleteViewColumn");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientws_access::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientDeleteViewColumnResponse *CClientws_access::DeleteViewColumnFn(const char * viewname_, const char * filename_, const char * columnname_)
{
	Owned<IClientDeleteViewColumnRequest> req =  createDeleteViewColumnRequest();
	req->setViewname(viewname_);
	req->setFilename(filename_);
	req->setColumnname(columnname_);
	return DeleteViewColumn(req.get());
}

//------ method DeleteViewMember ---------

IClientDeleteViewMemberRequest * CClientws_access::createDeleteViewMemberRequest()
{
	CDeleteViewMemberRequest* request = new CDeleteViewMemberRequest("ws_access");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientDeleteViewMemberResponse * CClientws_access::DeleteViewMember(IClientDeleteViewMemberRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CDeleteViewMemberRequest* esprequest = static_cast<CDeleteViewMemberRequest*>(request);
	CDeleteViewMemberResponse* espresponse = new CDeleteViewMemberResponse("ws_access");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientws_access::async_DeleteViewMember(IClientDeleteViewMemberRequest *request, IClientws_accessEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CDeleteViewMemberRequest* esprequest = static_cast<CDeleteViewMemberRequest*>(request);
	esprequest->setMethod("DeleteViewMember");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientws_access::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientDeleteViewMemberResponse *CClientws_access::DeleteViewMemberFn(const char * viewname_, const char * membername_, CViewMemberType membertype_)
{
	Owned<IClientDeleteViewMemberRequest> req =  createDeleteViewMemberRequest();
	req->setViewname(viewname_);
	req->setMembername(membername_);
	req->setMembertype(membertype_);
	return DeleteViewMember(req.get());
}

//------ method DisableScopeScans ---------

IClientDisableScopeScansRequest * CClientws_access::createDisableScopeScansRequest()
{
	CDisableScopeScansRequest* request = new CDisableScopeScansRequest("ws_access");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientDisableScopeScansResponse * CClientws_access::DisableScopeScans(IClientDisableScopeScansRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CDisableScopeScansRequest* esprequest = static_cast<CDisableScopeScansRequest*>(request);
	CDisableScopeScansResponse* espresponse = new CDisableScopeScansResponse("ws_access");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientws_access::async_DisableScopeScans(IClientDisableScopeScansRequest *request, IClientws_accessEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CDisableScopeScansRequest* esprequest = static_cast<CDisableScopeScansRequest*>(request);
	esprequest->setMethod("DisableScopeScans");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientws_access::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientDisableScopeScansResponse *CClientws_access::DisableScopeScansFn()
{
	Owned<IClientDisableScopeScansRequest> req =  createDisableScopeScansRequest();
	return DisableScopeScans(req.get());
}

//------ method EnableScopeScans ---------

IClientEnableScopeScansRequest * CClientws_access::createEnableScopeScansRequest()
{
	CEnableScopeScansRequest* request = new CEnableScopeScansRequest("ws_access");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientEnableScopeScansResponse * CClientws_access::EnableScopeScans(IClientEnableScopeScansRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CEnableScopeScansRequest* esprequest = static_cast<CEnableScopeScansRequest*>(request);
	CEnableScopeScansResponse* espresponse = new CEnableScopeScansResponse("ws_access");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientws_access::async_EnableScopeScans(IClientEnableScopeScansRequest *request, IClientws_accessEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CEnableScopeScansRequest* esprequest = static_cast<CEnableScopeScansRequest*>(request);
	esprequest->setMethod("EnableScopeScans");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientws_access::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientEnableScopeScansResponse *CClientws_access::EnableScopeScansFn()
{
	Owned<IClientEnableScopeScansRequest> req =  createEnableScopeScansRequest();
	return EnableScopeScans(req.get());
}

//------ method FilePermission ---------

IClientFilePermissionRequest * CClientws_access::createFilePermissionRequest()
{
	CFilePermissionRequest* request = new CFilePermissionRequest("ws_access");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientFilePermissionResponse * CClientws_access::FilePermission(IClientFilePermissionRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CFilePermissionRequest* esprequest = static_cast<CFilePermissionRequest*>(request);
	CFilePermissionResponse* espresponse = new CFilePermissionResponse("ws_access");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientws_access::async_FilePermission(IClientFilePermissionRequest *request, IClientws_accessEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CFilePermissionRequest* esprequest = static_cast<CFilePermissionRequest*>(request);
	esprequest->setMethod("FilePermission");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientws_access::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientFilePermissionResponse *CClientws_access::FilePermissionFn(const char * FileName_, const char * UserName_, const char * GroupName_)
{
	Owned<IClientFilePermissionRequest> req =  createFilePermissionRequest();
	req->setFileName(FileName_);
	req->setUserName(UserName_);
	req->setGroupName(GroupName_);
	return FilePermission(req.get());
}

//------ method GroupAction ---------

IClientGroupActionRequest * CClientws_access::createGroupActionRequest()
{
	CGroupActionRequest* request = new CGroupActionRequest("ws_access");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientGroupActionResponse * CClientws_access::GroupAction(IClientGroupActionRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CGroupActionRequest* esprequest = static_cast<CGroupActionRequest*>(request);
	CGroupActionResponse* espresponse = new CGroupActionResponse("ws_access");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientws_access::async_GroupAction(IClientGroupActionRequest *request, IClientws_accessEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CGroupActionRequest* esprequest = static_cast<CGroupActionRequest*>(request);
	esprequest->setMethod("GroupAction");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientws_access::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientGroupActionResponse *CClientws_access::GroupActionFn(StringArray &groupnames_, const char * ActionType_, bool DeletePermission_)
{
	Owned<IClientGroupActionRequest> req =  createGroupActionRequest();
	req->setGroupnames(groupnames_);
	req->setActionType(ActionType_);
	req->setDeletePermission(DeletePermission_);
	return GroupAction(req.get());
}

//------ method GroupAdd ---------

IClientGroupAddRequest * CClientws_access::createGroupAddRequest()
{
	CGroupAddRequest* request = new CGroupAddRequest("ws_access");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientGroupAddResponse * CClientws_access::GroupAdd(IClientGroupAddRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CGroupAddRequest* esprequest = static_cast<CGroupAddRequest*>(request);
	CGroupAddResponse* espresponse = new CGroupAddResponse("ws_access");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientws_access::async_GroupAdd(IClientGroupAddRequest *request, IClientws_accessEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CGroupAddRequest* esprequest = static_cast<CGroupAddRequest*>(request);
	esprequest->setMethod("GroupAdd");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientws_access::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientGroupAddResponse *CClientws_access::GroupAddFn(const char * groupname_, const char * groupOwner_, const char * groupDesc_)
{
	Owned<IClientGroupAddRequest> req =  createGroupAddRequest();
	req->setGroupname(groupname_);
	req->setGroupOwner(groupOwner_);
	req->setGroupDesc(groupDesc_);
	return GroupAdd(req.get());
}

//------ method GroupEdit ---------

IClientGroupEditRequest * CClientws_access::createGroupEditRequest()
{
	CGroupEditRequest* request = new CGroupEditRequest("ws_access");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientGroupEditResponse * CClientws_access::GroupEdit(IClientGroupEditRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CGroupEditRequest* esprequest = static_cast<CGroupEditRequest*>(request);
	CGroupEditResponse* espresponse = new CGroupEditResponse("ws_access");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientws_access::async_GroupEdit(IClientGroupEditRequest *request, IClientws_accessEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CGroupEditRequest* esprequest = static_cast<CGroupEditRequest*>(request);
	esprequest->setMethod("GroupEdit");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientws_access::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientGroupEditResponse *CClientws_access::GroupEditFn(const char * groupname_)
{
	Owned<IClientGroupEditRequest> req =  createGroupEditRequest();
	req->setGroupname(groupname_);
	return GroupEdit(req.get());
}

//------ method GroupMemberEdit ---------

IClientGroupMemberEditRequest * CClientws_access::createGroupMemberEditRequest()
{
	CGroupMemberEditRequest* request = new CGroupMemberEditRequest("ws_access");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientGroupMemberEditResponse * CClientws_access::GroupMemberEdit(IClientGroupMemberEditRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CGroupMemberEditRequest* esprequest = static_cast<CGroupMemberEditRequest*>(request);
	CGroupMemberEditResponse* espresponse = new CGroupMemberEditResponse("ws_access");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientws_access::async_GroupMemberEdit(IClientGroupMemberEditRequest *request, IClientws_accessEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CGroupMemberEditRequest* esprequest = static_cast<CGroupMemberEditRequest*>(request);
	esprequest->setMethod("GroupMemberEdit");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientws_access::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientGroupMemberEditResponse *CClientws_access::GroupMemberEditFn(const char * groupname_, const char * action_, StringArray &usernames_)
{
	Owned<IClientGroupMemberEditRequest> req =  createGroupMemberEditRequest();
	req->setGroupname(groupname_);
	req->setAction(action_);
	req->setUsernames(usernames_);
	return GroupMemberEdit(req.get());
}

//------ method GroupMemberEditInput ---------

IClientGroupMemberEditInputRequest * CClientws_access::createGroupMemberEditInputRequest()
{
	CGroupMemberEditInputRequest* request = new CGroupMemberEditInputRequest("ws_access");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientGroupMemberEditInputResponse * CClientws_access::GroupMemberEditInput(IClientGroupMemberEditInputRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CGroupMemberEditInputRequest* esprequest = static_cast<CGroupMemberEditInputRequest*>(request);
	CGroupMemberEditInputResponse* espresponse = new CGroupMemberEditInputResponse("ws_access");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientws_access::async_GroupMemberEditInput(IClientGroupMemberEditInputRequest *request, IClientws_accessEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CGroupMemberEditInputRequest* esprequest = static_cast<CGroupMemberEditInputRequest*>(request);
	esprequest->setMethod("GroupMemberEditInput");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientws_access::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientGroupMemberEditInputResponse *CClientws_access::GroupMemberEditInputFn(const char * searchinput_, const char * groupname_)
{
	Owned<IClientGroupMemberEditInputRequest> req =  createGroupMemberEditInputRequest();
	req->setSearchinput(searchinput_);
	req->setGroupname(groupname_);
	return GroupMemberEditInput(req.get());
}

//------ method GroupMemberQuery ---------

IClientGroupMemberQueryRequest * CClientws_access::createGroupMemberQueryRequest()
{
	CGroupMemberQueryRequest* request = new CGroupMemberQueryRequest("ws_access");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientGroupMemberQueryResponse * CClientws_access::GroupMemberQuery(IClientGroupMemberQueryRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CGroupMemberQueryRequest* esprequest = static_cast<CGroupMemberQueryRequest*>(request);
	CGroupMemberQueryResponse* espresponse = new CGroupMemberQueryResponse("ws_access");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientws_access::async_GroupMemberQuery(IClientGroupMemberQueryRequest *request, IClientws_accessEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CGroupMemberQueryRequest* esprequest = static_cast<CGroupMemberQueryRequest*>(request);
	esprequest->setMethod("GroupMemberQuery");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientws_access::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientGroupMemberQueryResponse *CClientws_access::GroupMemberQueryFn(const char * GroupName_, unsigned int PageSize_, __int64 PageStartFrom_, CUserSortBy SortBy_, bool Descending_, __int64 CacheHint_)
{
	Owned<IClientGroupMemberQueryRequest> req =  createGroupMemberQueryRequest();
	req->setGroupName(GroupName_);
	req->setPageSize(PageSize_);
	req->setPageStartFrom(PageStartFrom_);
	req->setSortBy(SortBy_);
	req->setDescending(Descending_);
	req->setCacheHint(CacheHint_);
	return GroupMemberQuery(req.get());
}

//------ method GroupQuery ---------

IClientGroupQueryRequest * CClientws_access::createGroupQueryRequest()
{
	CGroupQueryRequest* request = new CGroupQueryRequest("ws_access");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientGroupQueryResponse * CClientws_access::GroupQuery(IClientGroupQueryRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CGroupQueryRequest* esprequest = static_cast<CGroupQueryRequest*>(request);
	CGroupQueryResponse* espresponse = new CGroupQueryResponse("ws_access");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientws_access::async_GroupQuery(IClientGroupQueryRequest *request, IClientws_accessEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CGroupQueryRequest* esprequest = static_cast<CGroupQueryRequest*>(request);
	esprequest->setMethod("GroupQuery");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientws_access::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientGroupQueryResponse *CClientws_access::GroupQueryFn(unsigned int PageSize_, __int64 PageStartFrom_, CGroupSortBy SortBy_, bool Descending_, __int64 CacheHint_)
{
	Owned<IClientGroupQueryRequest> req =  createGroupQueryRequest();
	req->setPageSize(PageSize_);
	req->setPageStartFrom(PageStartFrom_);
	req->setSortBy(SortBy_);
	req->setDescending(Descending_);
	req->setCacheHint(CacheHint_);
	return GroupQuery(req.get());
}

//------ method Groups ---------

IClientGroupRequest * CClientws_access::createGroupsRequest()
{
	CGroupRequest* request = new CGroupRequest("ws_access");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientGroupResponse * CClientws_access::Groups(IClientGroupRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CGroupRequest* esprequest = static_cast<CGroupRequest*>(request);
	CGroupResponse* espresponse = new CGroupResponse("ws_access");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientws_access::async_Groups(IClientGroupRequest *request, IClientws_accessEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CGroupRequest* esprequest = static_cast<CGroupRequest*>(request);
	esprequest->setMethod("Groups");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientws_access::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientGroupResponse *CClientws_access::GroupsFn()
{
	Owned<IClientGroupRequest> req =  createGroupsRequest();
	return Groups(req.get());
}

//------ method PermissionAction ---------

IClientPermissionActionRequest * CClientws_access::createPermissionActionRequest()
{
	CPermissionActionRequest* request = new CPermissionActionRequest("ws_access");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientPermissionActionResponse * CClientws_access::PermissionAction(IClientPermissionActionRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CPermissionActionRequest* esprequest = static_cast<CPermissionActionRequest*>(request);
	CPermissionActionResponse* espresponse = new CPermissionActionResponse("ws_access");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientws_access::async_PermissionAction(IClientPermissionActionRequest *request, IClientws_accessEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CPermissionActionRequest* esprequest = static_cast<CPermissionActionRequest*>(request);
	esprequest->setMethod("PermissionAction");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientws_access::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientPermissionActionResponse *CClientws_access::PermissionActionFn(const char * basedn_, const char * rtype_, const char * rname_, const char * rtitle_, const char * prefix_, const char * action_, const char * account_name_, int account_type_, bool allow_access_, bool allow_read_, bool allow_write_, bool allow_full_, bool deny_access_, bool deny_read_, bool deny_write_, bool deny_full_, const char * user_, const char * group_, const char * BasednName_, const char * ResourceName_)
{
	Owned<IClientPermissionActionRequest> req =  createPermissionActionRequest();
	req->setBasedn(basedn_);
	req->setRtype(rtype_);
	req->setRname(rname_);
	req->setRtitle(rtitle_);
	req->setPrefix(prefix_);
	req->setAction(action_);
	req->setAccount_name(account_name_);
	req->setAccount_type(account_type_);
	req->setAllow_access(allow_access_);
	req->setAllow_read(allow_read_);
	req->setAllow_write(allow_write_);
	req->setAllow_full(allow_full_);
	req->setDeny_access(deny_access_);
	req->setDeny_read(deny_read_);
	req->setDeny_write(deny_write_);
	req->setDeny_full(deny_full_);
	req->setUser(user_);
	req->setGroup(group_);
	req->setBasednName(BasednName_);
	req->setResourceName(ResourceName_);
	return PermissionAction(req.get());
}

//------ method PermissionAddInput ---------

IClientPermissionAddRequest * CClientws_access::createPermissionAddInputRequest()
{
	CPermissionAddRequest* request = new CPermissionAddRequest("ws_access");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientPermissionAddResponse * CClientws_access::PermissionAddInput(IClientPermissionAddRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CPermissionAddRequest* esprequest = static_cast<CPermissionAddRequest*>(request);
	CPermissionAddResponse* espresponse = new CPermissionAddResponse("ws_access");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientws_access::async_PermissionAddInput(IClientPermissionAddRequest *request, IClientws_accessEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CPermissionAddRequest* esprequest = static_cast<CPermissionAddRequest*>(request);
	esprequest->setMethod("PermissionAddInput");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientws_access::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientPermissionAddResponse *CClientws_access::PermissionAddInputFn(const char * basedn_, const char * rtype_, const char * rtitle_, const char * rname_, const char * prefix_, const char * BasednName_, const char * AccountName_, int AccountType_)
{
	Owned<IClientPermissionAddRequest> req =  createPermissionAddInputRequest();
	req->setBasedn(basedn_);
	req->setRtype(rtype_);
	req->setRtitle(rtitle_);
	req->setRname(rname_);
	req->setPrefix(prefix_);
	req->setBasednName(BasednName_);
	req->setAccountName(AccountName_);
	req->setAccountType(AccountType_);
	return PermissionAddInput(req.get());
}

//------ method Permissions ---------

IClientBasednsRequest * CClientws_access::createPermissionsRequest()
{
	CBasednsRequest* request = new CBasednsRequest("ws_access");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientBasednsResponse * CClientws_access::Permissions(IClientBasednsRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CBasednsRequest* esprequest = static_cast<CBasednsRequest*>(request);
	CBasednsResponse* espresponse = new CBasednsResponse("ws_access");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientws_access::async_Permissions(IClientBasednsRequest *request, IClientws_accessEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CBasednsRequest* esprequest = static_cast<CBasednsRequest*>(request);
	esprequest->setMethod("Permissions");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientws_access::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientBasednsResponse *CClientws_access::PermissionsFn()
{
	Owned<IClientBasednsRequest> req =  createPermissionsRequest();
	return Permissions(req.get());
}

//------ method PermissionsReset ---------

IClientPermissionsResetRequest * CClientws_access::createPermissionsResetRequest()
{
	CPermissionsResetRequest* request = new CPermissionsResetRequest("ws_access");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientPermissionsResetResponse * CClientws_access::PermissionsReset(IClientPermissionsResetRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CPermissionsResetRequest* esprequest = static_cast<CPermissionsResetRequest*>(request);
	CPermissionsResetResponse* espresponse = new CPermissionsResetResponse("ws_access");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientws_access::async_PermissionsReset(IClientPermissionsResetRequest *request, IClientws_accessEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CPermissionsResetRequest* esprequest = static_cast<CPermissionsResetRequest*>(request);
	esprequest->setMethod("PermissionsReset");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientws_access::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientPermissionsResetResponse *CClientws_access::PermissionsResetFn(const char * basedn_, const char * rtype_, const char * rname_, const char * rtitle_, const char * prefix_, StringArray &names_, bool allow_access_, bool allow_read_, bool allow_write_, bool allow_full_, bool deny_access_, bool deny_read_, bool deny_write_, bool deny_full_, const char * userarray_, const char * grouparray_)
{
	Owned<IClientPermissionsResetRequest> req =  createPermissionsResetRequest();
	req->setBasedn(basedn_);
	req->setRtype(rtype_);
	req->setRname(rname_);
	req->setRtitle(rtitle_);
	req->setPrefix(prefix_);
	req->setNames(names_);
	req->setAllow_access(allow_access_);
	req->setAllow_read(allow_read_);
	req->setAllow_write(allow_write_);
	req->setAllow_full(allow_full_);
	req->setDeny_access(deny_access_);
	req->setDeny_read(deny_read_);
	req->setDeny_write(deny_write_);
	req->setDeny_full(deny_full_);
	req->setUserarray(userarray_);
	req->setGrouparray(grouparray_);
	return PermissionsReset(req.get());
}

//------ method PermissionsResetInput ---------

IClientPermissionsResetInputRequest * CClientws_access::createPermissionsResetInputRequest()
{
	CPermissionsResetInputRequest* request = new CPermissionsResetInputRequest("ws_access");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientPermissionsResetInputResponse * CClientws_access::PermissionsResetInput(IClientPermissionsResetInputRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CPermissionsResetInputRequest* esprequest = static_cast<CPermissionsResetInputRequest*>(request);
	CPermissionsResetInputResponse* espresponse = new CPermissionsResetInputResponse("ws_access");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientws_access::async_PermissionsResetInput(IClientPermissionsResetInputRequest *request, IClientws_accessEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CPermissionsResetInputRequest* esprequest = static_cast<CPermissionsResetInputRequest*>(request);
	esprequest->setMethod("PermissionsResetInput");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientws_access::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientPermissionsResetInputResponse *CClientws_access::PermissionsResetInputFn(const char * basedn_, const char * rtype_, const char * rtitle_, const char * rname_, const char * prefix_, StringArray &names_)
{
	Owned<IClientPermissionsResetInputRequest> req =  createPermissionsResetInputRequest();
	req->setBasedn(basedn_);
	req->setRtype(rtype_);
	req->setRtitle(rtitle_);
	req->setRname(rname_);
	req->setPrefix(prefix_);
	req->setNames(names_);
	return PermissionsResetInput(req.get());
}

//------ method Ping ---------

IClientws_accessPingRequest * CClientws_access::createPingRequest()
{
	Cws_accessPingRequest* request = new Cws_accessPingRequest("ws_access");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientws_accessPingResponse * CClientws_access::Ping(IClientws_accessPingRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	Cws_accessPingRequest* esprequest = static_cast<Cws_accessPingRequest*>(request);
	Cws_accessPingResponse* espresponse = new Cws_accessPingResponse("ws_access");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientws_access::async_Ping(IClientws_accessPingRequest *request, IClientws_accessEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	Cws_accessPingRequest* esprequest = static_cast<Cws_accessPingRequest*>(request);
	esprequest->setMethod("Ping");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientws_access::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientws_accessPingResponse *CClientws_access::PingFn()
{
	Owned<IClientws_accessPingRequest> req =  createPingRequest();
	return Ping(req.get());
}

//------ method QueryScopeScansEnabled ---------

IClientQueryScopeScansEnabledRequest * CClientws_access::createQueryScopeScansEnabledRequest()
{
	CQueryScopeScansEnabledRequest* request = new CQueryScopeScansEnabledRequest("ws_access");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientQueryScopeScansEnabledResponse * CClientws_access::QueryScopeScansEnabled(IClientQueryScopeScansEnabledRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CQueryScopeScansEnabledRequest* esprequest = static_cast<CQueryScopeScansEnabledRequest*>(request);
	CQueryScopeScansEnabledResponse* espresponse = new CQueryScopeScansEnabledResponse("ws_access");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientws_access::async_QueryScopeScansEnabled(IClientQueryScopeScansEnabledRequest *request, IClientws_accessEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CQueryScopeScansEnabledRequest* esprequest = static_cast<CQueryScopeScansEnabledRequest*>(request);
	esprequest->setMethod("QueryScopeScansEnabled");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientws_access::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientQueryScopeScansEnabledResponse *CClientws_access::QueryScopeScansEnabledFn()
{
	Owned<IClientQueryScopeScansEnabledRequest> req =  createQueryScopeScansEnabledRequest();
	return QueryScopeScansEnabled(req.get());
}

//------ method QueryUserViewColumns ---------

IClientQueryUserViewColumnsRequest * CClientws_access::createQueryUserViewColumnsRequest()
{
	CQueryUserViewColumnsRequest* request = new CQueryUserViewColumnsRequest("ws_access");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientQueryUserViewColumnsResponse * CClientws_access::QueryUserViewColumns(IClientQueryUserViewColumnsRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CQueryUserViewColumnsRequest* esprequest = static_cast<CQueryUserViewColumnsRequest*>(request);
	CQueryUserViewColumnsResponse* espresponse = new CQueryUserViewColumnsResponse("ws_access");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientws_access::async_QueryUserViewColumns(IClientQueryUserViewColumnsRequest *request, IClientws_accessEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CQueryUserViewColumnsRequest* esprequest = static_cast<CQueryUserViewColumnsRequest*>(request);
	esprequest->setMethod("QueryUserViewColumns");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientws_access::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientQueryUserViewColumnsResponse *CClientws_access::QueryUserViewColumnsFn(const char * username_)
{
	Owned<IClientQueryUserViewColumnsRequest> req =  createQueryUserViewColumnsRequest();
	req->setUsername(username_);
	return QueryUserViewColumns(req.get());
}

//------ method QueryViewColumns ---------

IClientQueryViewColumnsRequest * CClientws_access::createQueryViewColumnsRequest()
{
	CQueryViewColumnsRequest* request = new CQueryViewColumnsRequest("ws_access");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientQueryViewColumnsResponse * CClientws_access::QueryViewColumns(IClientQueryViewColumnsRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CQueryViewColumnsRequest* esprequest = static_cast<CQueryViewColumnsRequest*>(request);
	CQueryViewColumnsResponse* espresponse = new CQueryViewColumnsResponse("ws_access");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientws_access::async_QueryViewColumns(IClientQueryViewColumnsRequest *request, IClientws_accessEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CQueryViewColumnsRequest* esprequest = static_cast<CQueryViewColumnsRequest*>(request);
	esprequest->setMethod("QueryViewColumns");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientws_access::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientQueryViewColumnsResponse *CClientws_access::QueryViewColumnsFn(const char * viewname_)
{
	Owned<IClientQueryViewColumnsRequest> req =  createQueryViewColumnsRequest();
	req->setViewname(viewname_);
	return QueryViewColumns(req.get());
}

//------ method QueryViewMembers ---------

IClientQueryViewMembersRequest * CClientws_access::createQueryViewMembersRequest()
{
	CQueryViewMembersRequest* request = new CQueryViewMembersRequest("ws_access");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientQueryViewMembersResponse * CClientws_access::QueryViewMembers(IClientQueryViewMembersRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CQueryViewMembersRequest* esprequest = static_cast<CQueryViewMembersRequest*>(request);
	CQueryViewMembersResponse* espresponse = new CQueryViewMembersResponse("ws_access");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientws_access::async_QueryViewMembers(IClientQueryViewMembersRequest *request, IClientws_accessEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CQueryViewMembersRequest* esprequest = static_cast<CQueryViewMembersRequest*>(request);
	esprequest->setMethod("QueryViewMembers");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientws_access::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientQueryViewMembersResponse *CClientws_access::QueryViewMembersFn(const char * viewname_)
{
	Owned<IClientQueryViewMembersRequest> req =  createQueryViewMembersRequest();
	req->setViewname(viewname_);
	return QueryViewMembers(req.get());
}

//------ method QueryViews ---------

IClientQueryViewsRequest * CClientws_access::createQueryViewsRequest()
{
	CQueryViewsRequest* request = new CQueryViewsRequest("ws_access");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientQueryViewsResponse * CClientws_access::QueryViews(IClientQueryViewsRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CQueryViewsRequest* esprequest = static_cast<CQueryViewsRequest*>(request);
	CQueryViewsResponse* espresponse = new CQueryViewsResponse("ws_access");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientws_access::async_QueryViews(IClientQueryViewsRequest *request, IClientws_accessEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CQueryViewsRequest* esprequest = static_cast<CQueryViewsRequest*>(request);
	esprequest->setMethod("QueryViews");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientws_access::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientQueryViewsResponse *CClientws_access::QueryViewsFn()
{
	Owned<IClientQueryViewsRequest> req =  createQueryViewsRequest();
	return QueryViews(req.get());
}

//------ method ResourceAdd ---------

IClientResourceAddRequest * CClientws_access::createResourceAddRequest()
{
	CResourceAddRequest* request = new CResourceAddRequest("ws_access");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientResourceAddResponse * CClientws_access::ResourceAdd(IClientResourceAddRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CResourceAddRequest* esprequest = static_cast<CResourceAddRequest*>(request);
	CResourceAddResponse* espresponse = new CResourceAddResponse("ws_access");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientws_access::async_ResourceAdd(IClientResourceAddRequest *request, IClientws_accessEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CResourceAddRequest* esprequest = static_cast<CResourceAddRequest*>(request);
	esprequest->setMethod("ResourceAdd");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientws_access::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientResourceAddResponse *CClientws_access::ResourceAddFn(const char * basedn_, const char * rtype_, const char * rtitle_, const char * name_, const char * description_, const char * prefix_)
{
	Owned<IClientResourceAddRequest> req =  createResourceAddRequest();
	req->setBasedn(basedn_);
	req->setRtype(rtype_);
	req->setRtitle(rtitle_);
	req->setName(name_);
	req->setDescription(description_);
	req->setPrefix(prefix_);
	return ResourceAdd(req.get());
}

//------ method ResourceAddInput ---------

IClientResourceAddInputRequest * CClientws_access::createResourceAddInputRequest()
{
	CResourceAddInputRequest* request = new CResourceAddInputRequest("ws_access");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientResourceAddInputResponse * CClientws_access::ResourceAddInput(IClientResourceAddInputRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CResourceAddInputRequest* esprequest = static_cast<CResourceAddInputRequest*>(request);
	CResourceAddInputResponse* espresponse = new CResourceAddInputResponse("ws_access");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientws_access::async_ResourceAddInput(IClientResourceAddInputRequest *request, IClientws_accessEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CResourceAddInputRequest* esprequest = static_cast<CResourceAddInputRequest*>(request);
	esprequest->setMethod("ResourceAddInput");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientws_access::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientResourceAddInputResponse *CClientws_access::ResourceAddInputFn(const char * basedn_, const char * rtype_, const char * rtitle_, const char * prefix_)
{
	Owned<IClientResourceAddInputRequest> req =  createResourceAddInputRequest();
	req->setBasedn(basedn_);
	req->setRtype(rtype_);
	req->setRtitle(rtitle_);
	req->setPrefix(prefix_);
	return ResourceAddInput(req.get());
}

//------ method ResourceDelete ---------

IClientResourceDeleteRequest * CClientws_access::createResourceDeleteRequest()
{
	CResourceDeleteRequest* request = new CResourceDeleteRequest("ws_access");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientResourceDeleteResponse * CClientws_access::ResourceDelete(IClientResourceDeleteRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CResourceDeleteRequest* esprequest = static_cast<CResourceDeleteRequest*>(request);
	CResourceDeleteResponse* espresponse = new CResourceDeleteResponse("ws_access");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientws_access::async_ResourceDelete(IClientResourceDeleteRequest *request, IClientws_accessEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CResourceDeleteRequest* esprequest = static_cast<CResourceDeleteRequest*>(request);
	esprequest->setMethod("ResourceDelete");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientws_access::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientResourceDeleteResponse *CClientws_access::ResourceDeleteFn(const char * basedn_, const char * rtype_, const char * rtitle_, const char * prefix_, StringArray &names_, int DoUpdate_)
{
	Owned<IClientResourceDeleteRequest> req =  createResourceDeleteRequest();
	req->setBasedn(basedn_);
	req->setRtype(rtype_);
	req->setRtitle(rtitle_);
	req->setPrefix(prefix_);
	req->setNames(names_);
	req->setDoUpdate(DoUpdate_);
	return ResourceDelete(req.get());
}

//------ method ResourcePermissionQuery ---------

IClientResourcePermissionQueryRequest * CClientws_access::createResourcePermissionQueryRequest()
{
	CResourcePermissionQueryRequest* request = new CResourcePermissionQueryRequest("ws_access");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientResourcePermissionQueryResponse * CClientws_access::ResourcePermissionQuery(IClientResourcePermissionQueryRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CResourcePermissionQueryRequest* esprequest = static_cast<CResourcePermissionQueryRequest*>(request);
	CResourcePermissionQueryResponse* espresponse = new CResourcePermissionQueryResponse("ws_access");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientws_access::async_ResourcePermissionQuery(IClientResourcePermissionQueryRequest *request, IClientws_accessEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CResourcePermissionQueryRequest* esprequest = static_cast<CResourcePermissionQueryRequest*>(request);
	esprequest->setMethod("ResourcePermissionQuery");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientws_access::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientResourcePermissionQueryResponse *CClientws_access::ResourcePermissionQueryFn(const char * basedn_, const char * rtype_, const char * rtitle_, const char * prefix_, const char * Name_, CAccountTypeReq AccountType_, unsigned int PageSize_, __int64 PageStartFrom_, CResourcePermissionSortBy SortBy_, bool Descending_, __int64 CacheHint_)
{
	Owned<IClientResourcePermissionQueryRequest> req =  createResourcePermissionQueryRequest();
	req->setBasedn(basedn_);
	req->setRtype(rtype_);
	req->setRtitle(rtitle_);
	req->setPrefix(prefix_);
	req->setName(Name_);
	req->setAccountType(AccountType_);
	req->setPageSize(PageSize_);
	req->setPageStartFrom(PageStartFrom_);
	req->setSortBy(SortBy_);
	req->setDescending(Descending_);
	req->setCacheHint(CacheHint_);
	return ResourcePermissionQuery(req.get());
}

//------ method ResourcePermissions ---------

IClientResourcePermissionsRequest * CClientws_access::createResourcePermissionsRequest()
{
	CResourcePermissionsRequest* request = new CResourcePermissionsRequest("ws_access");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientResourcePermissionsResponse * CClientws_access::ResourcePermissions(IClientResourcePermissionsRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CResourcePermissionsRequest* esprequest = static_cast<CResourcePermissionsRequest*>(request);
	CResourcePermissionsResponse* espresponse = new CResourcePermissionsResponse("ws_access");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientws_access::async_ResourcePermissions(IClientResourcePermissionsRequest *request, IClientws_accessEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CResourcePermissionsRequest* esprequest = static_cast<CResourcePermissionsRequest*>(request);
	esprequest->setMethod("ResourcePermissions");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientws_access::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientResourcePermissionsResponse *CClientws_access::ResourcePermissionsFn(const char * basedn_, const char * rtype_, const char * name_, const char * rtitle_, const char * prefix_)
{
	Owned<IClientResourcePermissionsRequest> req =  createResourcePermissionsRequest();
	req->setBasedn(basedn_);
	req->setRtype(rtype_);
	req->setName(name_);
	req->setRtitle(rtitle_);
	req->setPrefix(prefix_);
	return ResourcePermissions(req.get());
}

//------ method ResourceQuery ---------

IClientResourceQueryRequest * CClientws_access::createResourceQueryRequest()
{
	CResourceQueryRequest* request = new CResourceQueryRequest("ws_access");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientResourceQueryResponse * CClientws_access::ResourceQuery(IClientResourceQueryRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CResourceQueryRequest* esprequest = static_cast<CResourceQueryRequest*>(request);
	CResourceQueryResponse* espresponse = new CResourceQueryResponse("ws_access");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientws_access::async_ResourceQuery(IClientResourceQueryRequest *request, IClientws_accessEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CResourceQueryRequest* esprequest = static_cast<CResourceQueryRequest*>(request);
	esprequest->setMethod("ResourceQuery");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientws_access::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientResourceQueryResponse *CClientws_access::ResourceQueryFn(const char * basedn_, const char * rtype_, const char * rtitle_, const char * prefix_, const char * Name_, unsigned int PageSize_, __int64 PageStartFrom_, CResourceSortBy SortBy_, bool Descending_, __int64 CacheHint_)
{
	Owned<IClientResourceQueryRequest> req =  createResourceQueryRequest();
	req->setBasedn(basedn_);
	req->setRtype(rtype_);
	req->setRtitle(rtitle_);
	req->setPrefix(prefix_);
	req->setName(Name_);
	req->setPageSize(PageSize_);
	req->setPageStartFrom(PageStartFrom_);
	req->setSortBy(SortBy_);
	req->setDescending(Descending_);
	req->setCacheHint(CacheHint_);
	return ResourceQuery(req.get());
}

//------ method Resources ---------

IClientResourcesRequest * CClientws_access::createResourcesRequest()
{
	CResourcesRequest* request = new CResourcesRequest("ws_access");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientResourcesResponse * CClientws_access::Resources(IClientResourcesRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CResourcesRequest* esprequest = static_cast<CResourcesRequest*>(request);
	CResourcesResponse* espresponse = new CResourcesResponse("ws_access");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientws_access::async_Resources(IClientResourcesRequest *request, IClientws_accessEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CResourcesRequest* esprequest = static_cast<CResourcesRequest*>(request);
	esprequest->setMethod("Resources");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientws_access::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientResourcesResponse *CClientws_access::ResourcesFn(const char * basedn_, const char * rtype_, const char * rtitle_, const char * templatename_, const char * prefix_, const char * searchinput_)
{
	Owned<IClientResourcesRequest> req =  createResourcesRequest();
	req->setBasedn(basedn_);
	req->setRtype(rtype_);
	req->setRtitle(rtitle_);
	req->setTemplatename(templatename_);
	req->setPrefix(prefix_);
	req->setSearchinput(searchinput_);
	return Resources(req.get());
}

//------ method UserAccountExport ---------

IClientUserAccountExportRequest * CClientws_access::createUserAccountExportRequest()
{
	CUserAccountExportRequest* request = new CUserAccountExportRequest("ws_access");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientUserAccountExportResponse * CClientws_access::UserAccountExport(IClientUserAccountExportRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CUserAccountExportRequest* esprequest = static_cast<CUserAccountExportRequest*>(request);
	CUserAccountExportResponse* espresponse = new CUserAccountExportResponse("ws_access");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientws_access::async_UserAccountExport(IClientUserAccountExportRequest *request, IClientws_accessEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CUserAccountExportRequest* esprequest = static_cast<CUserAccountExportRequest*>(request);
	esprequest->setMethod("UserAccountExport");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientws_access::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientUserAccountExportResponse *CClientws_access::UserAccountExportFn(StringArray &usernames_, StringArray &groupnames_)
{
	Owned<IClientUserAccountExportRequest> req =  createUserAccountExportRequest();
	req->setUsernames(usernames_);
	req->setGroupnames(groupnames_);
	return UserAccountExport(req.get());
}

//------ method UserAction ---------

IClientUserActionRequest * CClientws_access::createUserActionRequest()
{
	CUserActionRequest* request = new CUserActionRequest("ws_access");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientUserActionResponse * CClientws_access::UserAction(IClientUserActionRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CUserActionRequest* esprequest = static_cast<CUserActionRequest*>(request);
	CUserActionResponse* espresponse = new CUserActionResponse("ws_access");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientws_access::async_UserAction(IClientUserActionRequest *request, IClientws_accessEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CUserActionRequest* esprequest = static_cast<CUserActionRequest*>(request);
	esprequest->setMethod("UserAction");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientws_access::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientUserActionResponse *CClientws_access::UserActionFn(const char * action_, const char * ActionType_, StringArray &usernames_)
{
	Owned<IClientUserActionRequest> req =  createUserActionRequest();
	req->setAction(action_);
	req->setActionType(ActionType_);
	req->setUsernames(usernames_);
	return UserAction(req.get());
}

//------ method UserEdit ---------

IClientUserEditRequest * CClientws_access::createUserEditRequest()
{
	CUserEditRequest* request = new CUserEditRequest("ws_access");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientUserEditResponse * CClientws_access::UserEdit(IClientUserEditRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CUserEditRequest* esprequest = static_cast<CUserEditRequest*>(request);
	CUserEditResponse* espresponse = new CUserEditResponse("ws_access");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientws_access::async_UserEdit(IClientUserEditRequest *request, IClientws_accessEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CUserEditRequest* esprequest = static_cast<CUserEditRequest*>(request);
	esprequest->setMethod("UserEdit");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientws_access::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientUserEditResponse *CClientws_access::UserEditFn(const char * username_)
{
	Owned<IClientUserEditRequest> req =  createUserEditRequest();
	req->setUsername(username_);
	return UserEdit(req.get());
}

//------ method UserGroupEdit ---------

IClientUserGroupEditRequest * CClientws_access::createUserGroupEditRequest()
{
	CUserGroupEditRequest* request = new CUserGroupEditRequest("ws_access");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientUserGroupEditResponse * CClientws_access::UserGroupEdit(IClientUserGroupEditRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CUserGroupEditRequest* esprequest = static_cast<CUserGroupEditRequest*>(request);
	CUserGroupEditResponse* espresponse = new CUserGroupEditResponse("ws_access");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientws_access::async_UserGroupEdit(IClientUserGroupEditRequest *request, IClientws_accessEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CUserGroupEditRequest* esprequest = static_cast<CUserGroupEditRequest*>(request);
	esprequest->setMethod("UserGroupEdit");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientws_access::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientUserGroupEditResponse *CClientws_access::UserGroupEditFn(const char * username_, const char * action_, StringArray &groupnames_)
{
	Owned<IClientUserGroupEditRequest> req =  createUserGroupEditRequest();
	req->setUsername(username_);
	req->setAction(action_);
	req->setGroupnames(groupnames_);
	return UserGroupEdit(req.get());
}

//------ method UserGroupEditInput ---------

IClientUserGroupEditInputRequest * CClientws_access::createUserGroupEditInputRequest()
{
	CUserGroupEditInputRequest* request = new CUserGroupEditInputRequest("ws_access");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientUserGroupEditInputResponse * CClientws_access::UserGroupEditInput(IClientUserGroupEditInputRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CUserGroupEditInputRequest* esprequest = static_cast<CUserGroupEditInputRequest*>(request);
	CUserGroupEditInputResponse* espresponse = new CUserGroupEditInputResponse("ws_access");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientws_access::async_UserGroupEditInput(IClientUserGroupEditInputRequest *request, IClientws_accessEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CUserGroupEditInputRequest* esprequest = static_cast<CUserGroupEditInputRequest*>(request);
	esprequest->setMethod("UserGroupEditInput");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientws_access::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientUserGroupEditInputResponse *CClientws_access::UserGroupEditInputFn(const char * username_)
{
	Owned<IClientUserGroupEditInputRequest> req =  createUserGroupEditInputRequest();
	req->setUsername(username_);
	return UserGroupEditInput(req.get());
}

//------ method UserInfoEdit ---------

IClientUserInfoEditRequest * CClientws_access::createUserInfoEditRequest()
{
	CUserInfoEditRequest* request = new CUserInfoEditRequest("ws_access");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientUserInfoEditResponse * CClientws_access::UserInfoEdit(IClientUserInfoEditRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CUserInfoEditRequest* esprequest = static_cast<CUserInfoEditRequest*>(request);
	CUserInfoEditResponse* espresponse = new CUserInfoEditResponse("ws_access");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientws_access::async_UserInfoEdit(IClientUserInfoEditRequest *request, IClientws_accessEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CUserInfoEditRequest* esprequest = static_cast<CUserInfoEditRequest*>(request);
	esprequest->setMethod("UserInfoEdit");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientws_access::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientUserInfoEditResponse *CClientws_access::UserInfoEditFn(const char * username_, const char * firstname_, const char * lastname_, const char * employeeID_)
{
	Owned<IClientUserInfoEditRequest> req =  createUserInfoEditRequest();
	req->setUsername(username_);
	req->setFirstname(firstname_);
	req->setLastname(lastname_);
	req->setEmployeeID(employeeID_);
	return UserInfoEdit(req.get());
}

//------ method UserInfoEditInput ---------

IClientUserInfoEditInputRequest * CClientws_access::createUserInfoEditInputRequest()
{
	CUserInfoEditInputRequest* request = new CUserInfoEditInputRequest("ws_access");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientUserInfoEditInputResponse * CClientws_access::UserInfoEditInput(IClientUserInfoEditInputRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CUserInfoEditInputRequest* esprequest = static_cast<CUserInfoEditInputRequest*>(request);
	CUserInfoEditInputResponse* espresponse = new CUserInfoEditInputResponse("ws_access");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientws_access::async_UserInfoEditInput(IClientUserInfoEditInputRequest *request, IClientws_accessEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CUserInfoEditInputRequest* esprequest = static_cast<CUserInfoEditInputRequest*>(request);
	esprequest->setMethod("UserInfoEditInput");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientws_access::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientUserInfoEditInputResponse *CClientws_access::UserInfoEditInputFn(const char * username_)
{
	Owned<IClientUserInfoEditInputRequest> req =  createUserInfoEditInputRequest();
	req->setUsername(username_);
	return UserInfoEditInput(req.get());
}

//------ method UserPosix ---------

IClientUserPosixRequest * CClientws_access::createUserPosixRequest()
{
	CUserPosixRequest* request = new CUserPosixRequest("ws_access");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientUserPosixResponse * CClientws_access::UserPosix(IClientUserPosixRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CUserPosixRequest* esprequest = static_cast<CUserPosixRequest*>(request);
	CUserPosixResponse* espresponse = new CUserPosixResponse("ws_access");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientws_access::async_UserPosix(IClientUserPosixRequest *request, IClientws_accessEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CUserPosixRequest* esprequest = static_cast<CUserPosixRequest*>(request);
	esprequest->setMethod("UserPosix");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientws_access::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientUserPosixResponse *CClientws_access::UserPosixFn(const char * username_, bool posixenabled_, const char * gidnumber_, const char * uidnumber_, const char * homedirectory_, const char * loginshell_)
{
	Owned<IClientUserPosixRequest> req =  createUserPosixRequest();
	req->setUsername(username_);
	req->setPosixenabled(posixenabled_);
	req->setGidnumber(gidnumber_);
	req->setUidnumber(uidnumber_);
	req->setHomedirectory(homedirectory_);
	req->setLoginshell(loginshell_);
	return UserPosix(req.get());
}

//------ method UserPosixInput ---------

IClientUserPosixInputRequest * CClientws_access::createUserPosixInputRequest()
{
	CUserPosixInputRequest* request = new CUserPosixInputRequest("ws_access");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientUserPosixInputResponse * CClientws_access::UserPosixInput(IClientUserPosixInputRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CUserPosixInputRequest* esprequest = static_cast<CUserPosixInputRequest*>(request);
	CUserPosixInputResponse* espresponse = new CUserPosixInputResponse("ws_access");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientws_access::async_UserPosixInput(IClientUserPosixInputRequest *request, IClientws_accessEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CUserPosixInputRequest* esprequest = static_cast<CUserPosixInputRequest*>(request);
	esprequest->setMethod("UserPosixInput");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientws_access::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientUserPosixInputResponse *CClientws_access::UserPosixInputFn(const char * username_)
{
	Owned<IClientUserPosixInputRequest> req =  createUserPosixInputRequest();
	req->setUsername(username_);
	return UserPosixInput(req.get());
}

//------ method UserQuery ---------

IClientUserQueryRequest * CClientws_access::createUserQueryRequest()
{
	CUserQueryRequest* request = new CUserQueryRequest("ws_access");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientUserQueryResponse * CClientws_access::UserQuery(IClientUserQueryRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CUserQueryRequest* esprequest = static_cast<CUserQueryRequest*>(request);
	CUserQueryResponse* espresponse = new CUserQueryResponse("ws_access");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientws_access::async_UserQuery(IClientUserQueryRequest *request, IClientws_accessEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CUserQueryRequest* esprequest = static_cast<CUserQueryRequest*>(request);
	esprequest->setMethod("UserQuery");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientws_access::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientUserQueryResponse *CClientws_access::UserQueryFn(const char * Name_, unsigned int PageSize_, __int64 PageStartFrom_, CUserSortBy SortBy_, bool Descending_, __int64 CacheHint_)
{
	Owned<IClientUserQueryRequest> req =  createUserQueryRequest();
	req->setName(Name_);
	req->setPageSize(PageSize_);
	req->setPageStartFrom(PageStartFrom_);
	req->setSortBy(SortBy_);
	req->setDescending(Descending_);
	req->setCacheHint(CacheHint_);
	return UserQuery(req.get());
}

//------ method UserResetPass ---------

IClientUserResetPassRequest * CClientws_access::createUserResetPassRequest()
{
	CUserResetPassRequest* request = new CUserResetPassRequest("ws_access");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientUserResetPassResponse * CClientws_access::UserResetPass(IClientUserResetPassRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CUserResetPassRequest* esprequest = static_cast<CUserResetPassRequest*>(request);
	CUserResetPassResponse* espresponse = new CUserResetPassResponse("ws_access");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientws_access::async_UserResetPass(IClientUserResetPassRequest *request, IClientws_accessEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CUserResetPassRequest* esprequest = static_cast<CUserResetPassRequest*>(request);
	esprequest->setMethod("UserResetPass");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientws_access::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientUserResetPassResponse *CClientws_access::UserResetPassFn(const char * username_, const char * newPassword_, const char * newPasswordRetype_)
{
	Owned<IClientUserResetPassRequest> req =  createUserResetPassRequest();
	req->setUsername(username_);
	req->setNewPassword(newPassword_);
	req->setNewPasswordRetype(newPasswordRetype_);
	return UserResetPass(req.get());
}

//------ method UserResetPassInput ---------

IClientUserResetPassInputRequest * CClientws_access::createUserResetPassInputRequest()
{
	CUserResetPassInputRequest* request = new CUserResetPassInputRequest("ws_access");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientUserResetPassInputResponse * CClientws_access::UserResetPassInput(IClientUserResetPassInputRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CUserResetPassInputRequest* esprequest = static_cast<CUserResetPassInputRequest*>(request);
	CUserResetPassInputResponse* espresponse = new CUserResetPassInputResponse("ws_access");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientws_access::async_UserResetPassInput(IClientUserResetPassInputRequest *request, IClientws_accessEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CUserResetPassInputRequest* esprequest = static_cast<CUserResetPassInputRequest*>(request);
	esprequest->setMethod("UserResetPassInput");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientws_access::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientUserResetPassInputResponse *CClientws_access::UserResetPassInputFn(const char * username_)
{
	Owned<IClientUserResetPassInputRequest> req =  createUserResetPassInputRequest();
	req->setUsername(username_);
	return UserResetPassInput(req.get());
}

//------ method UserSudoers ---------

IClientUserSudoersRequest * CClientws_access::createUserSudoersRequest()
{
	CUserSudoersRequest* request = new CUserSudoersRequest("ws_access");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientUserSudoersResponse * CClientws_access::UserSudoers(IClientUserSudoersRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CUserSudoersRequest* esprequest = static_cast<CUserSudoersRequest*>(request);
	CUserSudoersResponse* espresponse = new CUserSudoersResponse("ws_access");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientws_access::async_UserSudoers(IClientUserSudoersRequest *request, IClientws_accessEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CUserSudoersRequest* esprequest = static_cast<CUserSudoersRequest*>(request);
	esprequest->setMethod("UserSudoers");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientws_access::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientUserSudoersResponse *CClientws_access::UserSudoersFn(const char * username_, const char * action_, const char * sudoHost_, const char * sudoCommand_, const char * sudoOption_)
{
	Owned<IClientUserSudoersRequest> req =  createUserSudoersRequest();
	req->setUsername(username_);
	req->setAction(action_);
	req->setSudoHost(sudoHost_);
	req->setSudoCommand(sudoCommand_);
	req->setSudoOption(sudoOption_);
	return UserSudoers(req.get());
}

//------ method UserSudoersInput ---------

IClientUserSudoersInputRequest * CClientws_access::createUserSudoersInputRequest()
{
	CUserSudoersInputRequest* request = new CUserSudoersInputRequest("ws_access");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientUserSudoersInputResponse * CClientws_access::UserSudoersInput(IClientUserSudoersInputRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CUserSudoersInputRequest* esprequest = static_cast<CUserSudoersInputRequest*>(request);
	CUserSudoersInputResponse* espresponse = new CUserSudoersInputResponse("ws_access");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientws_access::async_UserSudoersInput(IClientUserSudoersInputRequest *request, IClientws_accessEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CUserSudoersInputRequest* esprequest = static_cast<CUserSudoersInputRequest*>(request);
	esprequest->setMethod("UserSudoersInput");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientws_access::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientUserSudoersInputResponse *CClientws_access::UserSudoersInputFn(const char * username_)
{
	Owned<IClientUserSudoersInputRequest> req =  createUserSudoersInputRequest();
	req->setUsername(username_);
	return UserSudoersInput(req.get());
}

//------ method Users ---------

IClientUserRequest * CClientws_access::createUsersRequest()
{
	CUserRequest* request = new CUserRequest("ws_access");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientUserResponse * CClientws_access::Users(IClientUserRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CUserRequest* esprequest = static_cast<CUserRequest*>(request);
	CUserResponse* espresponse = new CUserResponse("ws_access");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientws_access::async_Users(IClientUserRequest *request, IClientws_accessEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CUserRequest* esprequest = static_cast<CUserRequest*>(request);
	esprequest->setMethod("Users");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientws_access::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientUserResponse *CClientws_access::UsersFn(const char * searchinput_)
{
	Owned<IClientUserRequest> req =  createUsersRequest();
	req->setSearchinput(searchinput_);
	return Users(req.get());
}

int CClientws_access::transferThunkEvent(void *data)
{
	IRpcResponseBinding *response = (IRpcResponseBinding *)data;
	if (response!=NULL)
	{
		IClientws_accessEvents *eventSink = (IClientws_accessEvents *)response->getEventSink();
		response->lock();

		if (stricmp(response->getMethod(), "AccountPermissions")==0)
		{
			IClientAccountPermissionsResponse* icresp = dynamic_cast<IClientAccountPermissionsResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onAccountPermissionsComplete(icresp, response->queryState());
				else
					eventSink->onAccountPermissionsError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "AddUser")==0)
		{
			IClientAddUserResponse* icresp = dynamic_cast<IClientAddUserResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onAddUserComplete(icresp, response->queryState());
				else
					eventSink->onAddUserError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "AddView")==0)
		{
			IClientAddViewResponse* icresp = dynamic_cast<IClientAddViewResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onAddViewComplete(icresp, response->queryState());
				else
					eventSink->onAddViewError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "AddViewColumn")==0)
		{
			IClientAddViewColumnResponse* icresp = dynamic_cast<IClientAddViewColumnResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onAddViewColumnComplete(icresp, response->queryState());
				else
					eventSink->onAddViewColumnError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "AddViewMember")==0)
		{
			IClientAddViewMemberResponse* icresp = dynamic_cast<IClientAddViewMemberResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onAddViewMemberComplete(icresp, response->queryState());
				else
					eventSink->onAddViewMemberError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "ClearPermissionsCache")==0)
		{
			IClientClearPermissionsCacheResponse* icresp = dynamic_cast<IClientClearPermissionsCacheResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onClearPermissionsCacheComplete(icresp, response->queryState());
				else
					eventSink->onClearPermissionsCacheError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "DeleteView")==0)
		{
			IClientDeleteViewResponse* icresp = dynamic_cast<IClientDeleteViewResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onDeleteViewComplete(icresp, response->queryState());
				else
					eventSink->onDeleteViewError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "DeleteViewColumn")==0)
		{
			IClientDeleteViewColumnResponse* icresp = dynamic_cast<IClientDeleteViewColumnResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onDeleteViewColumnComplete(icresp, response->queryState());
				else
					eventSink->onDeleteViewColumnError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "DeleteViewMember")==0)
		{
			IClientDeleteViewMemberResponse* icresp = dynamic_cast<IClientDeleteViewMemberResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onDeleteViewMemberComplete(icresp, response->queryState());
				else
					eventSink->onDeleteViewMemberError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "DisableScopeScans")==0)
		{
			IClientDisableScopeScansResponse* icresp = dynamic_cast<IClientDisableScopeScansResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onDisableScopeScansComplete(icresp, response->queryState());
				else
					eventSink->onDisableScopeScansError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "EnableScopeScans")==0)
		{
			IClientEnableScopeScansResponse* icresp = dynamic_cast<IClientEnableScopeScansResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onEnableScopeScansComplete(icresp, response->queryState());
				else
					eventSink->onEnableScopeScansError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "FilePermission")==0)
		{
			IClientFilePermissionResponse* icresp = dynamic_cast<IClientFilePermissionResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onFilePermissionComplete(icresp, response->queryState());
				else
					eventSink->onFilePermissionError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "GroupAction")==0)
		{
			IClientGroupActionResponse* icresp = dynamic_cast<IClientGroupActionResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onGroupActionComplete(icresp, response->queryState());
				else
					eventSink->onGroupActionError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "GroupAdd")==0)
		{
			IClientGroupAddResponse* icresp = dynamic_cast<IClientGroupAddResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onGroupAddComplete(icresp, response->queryState());
				else
					eventSink->onGroupAddError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "GroupEdit")==0)
		{
			IClientGroupEditResponse* icresp = dynamic_cast<IClientGroupEditResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onGroupEditComplete(icresp, response->queryState());
				else
					eventSink->onGroupEditError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "GroupMemberEdit")==0)
		{
			IClientGroupMemberEditResponse* icresp = dynamic_cast<IClientGroupMemberEditResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onGroupMemberEditComplete(icresp, response->queryState());
				else
					eventSink->onGroupMemberEditError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "GroupMemberEditInput")==0)
		{
			IClientGroupMemberEditInputResponse* icresp = dynamic_cast<IClientGroupMemberEditInputResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onGroupMemberEditInputComplete(icresp, response->queryState());
				else
					eventSink->onGroupMemberEditInputError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "GroupMemberQuery")==0)
		{
			IClientGroupMemberQueryResponse* icresp = dynamic_cast<IClientGroupMemberQueryResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onGroupMemberQueryComplete(icresp, response->queryState());
				else
					eventSink->onGroupMemberQueryError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "GroupQuery")==0)
		{
			IClientGroupQueryResponse* icresp = dynamic_cast<IClientGroupQueryResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onGroupQueryComplete(icresp, response->queryState());
				else
					eventSink->onGroupQueryError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "Groups")==0)
		{
			IClientGroupResponse* icresp = dynamic_cast<IClientGroupResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onGroupsComplete(icresp, response->queryState());
				else
					eventSink->onGroupsError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "PermissionAction")==0)
		{
			IClientPermissionActionResponse* icresp = dynamic_cast<IClientPermissionActionResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onPermissionActionComplete(icresp, response->queryState());
				else
					eventSink->onPermissionActionError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "PermissionAddInput")==0)
		{
			IClientPermissionAddResponse* icresp = dynamic_cast<IClientPermissionAddResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onPermissionAddInputComplete(icresp, response->queryState());
				else
					eventSink->onPermissionAddInputError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "Permissions")==0)
		{
			IClientBasednsResponse* icresp = dynamic_cast<IClientBasednsResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onPermissionsComplete(icresp, response->queryState());
				else
					eventSink->onPermissionsError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "PermissionsReset")==0)
		{
			IClientPermissionsResetResponse* icresp = dynamic_cast<IClientPermissionsResetResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onPermissionsResetComplete(icresp, response->queryState());
				else
					eventSink->onPermissionsResetError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "PermissionsResetInput")==0)
		{
			IClientPermissionsResetInputResponse* icresp = dynamic_cast<IClientPermissionsResetInputResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onPermissionsResetInputComplete(icresp, response->queryState());
				else
					eventSink->onPermissionsResetInputError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "Ping")==0)
		{
			IClientws_accessPingResponse* icresp = dynamic_cast<IClientws_accessPingResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onPingComplete(icresp, response->queryState());
				else
					eventSink->onPingError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "QueryScopeScansEnabled")==0)
		{
			IClientQueryScopeScansEnabledResponse* icresp = dynamic_cast<IClientQueryScopeScansEnabledResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onQueryScopeScansEnabledComplete(icresp, response->queryState());
				else
					eventSink->onQueryScopeScansEnabledError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "QueryUserViewColumns")==0)
		{
			IClientQueryUserViewColumnsResponse* icresp = dynamic_cast<IClientQueryUserViewColumnsResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onQueryUserViewColumnsComplete(icresp, response->queryState());
				else
					eventSink->onQueryUserViewColumnsError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "QueryViewColumns")==0)
		{
			IClientQueryViewColumnsResponse* icresp = dynamic_cast<IClientQueryViewColumnsResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onQueryViewColumnsComplete(icresp, response->queryState());
				else
					eventSink->onQueryViewColumnsError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "QueryViewMembers")==0)
		{
			IClientQueryViewMembersResponse* icresp = dynamic_cast<IClientQueryViewMembersResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onQueryViewMembersComplete(icresp, response->queryState());
				else
					eventSink->onQueryViewMembersError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "QueryViews")==0)
		{
			IClientQueryViewsResponse* icresp = dynamic_cast<IClientQueryViewsResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onQueryViewsComplete(icresp, response->queryState());
				else
					eventSink->onQueryViewsError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "ResourceAdd")==0)
		{
			IClientResourceAddResponse* icresp = dynamic_cast<IClientResourceAddResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onResourceAddComplete(icresp, response->queryState());
				else
					eventSink->onResourceAddError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "ResourceAddInput")==0)
		{
			IClientResourceAddInputResponse* icresp = dynamic_cast<IClientResourceAddInputResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onResourceAddInputComplete(icresp, response->queryState());
				else
					eventSink->onResourceAddInputError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "ResourceDelete")==0)
		{
			IClientResourceDeleteResponse* icresp = dynamic_cast<IClientResourceDeleteResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onResourceDeleteComplete(icresp, response->queryState());
				else
					eventSink->onResourceDeleteError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "ResourcePermissionQuery")==0)
		{
			IClientResourcePermissionQueryResponse* icresp = dynamic_cast<IClientResourcePermissionQueryResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onResourcePermissionQueryComplete(icresp, response->queryState());
				else
					eventSink->onResourcePermissionQueryError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "ResourcePermissions")==0)
		{
			IClientResourcePermissionsResponse* icresp = dynamic_cast<IClientResourcePermissionsResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onResourcePermissionsComplete(icresp, response->queryState());
				else
					eventSink->onResourcePermissionsError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "ResourceQuery")==0)
		{
			IClientResourceQueryResponse* icresp = dynamic_cast<IClientResourceQueryResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onResourceQueryComplete(icresp, response->queryState());
				else
					eventSink->onResourceQueryError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "Resources")==0)
		{
			IClientResourcesResponse* icresp = dynamic_cast<IClientResourcesResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onResourcesComplete(icresp, response->queryState());
				else
					eventSink->onResourcesError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "UserAccountExport")==0)
		{
			IClientUserAccountExportResponse* icresp = dynamic_cast<IClientUserAccountExportResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onUserAccountExportComplete(icresp, response->queryState());
				else
					eventSink->onUserAccountExportError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "UserAction")==0)
		{
			IClientUserActionResponse* icresp = dynamic_cast<IClientUserActionResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onUserActionComplete(icresp, response->queryState());
				else
					eventSink->onUserActionError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "UserEdit")==0)
		{
			IClientUserEditResponse* icresp = dynamic_cast<IClientUserEditResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onUserEditComplete(icresp, response->queryState());
				else
					eventSink->onUserEditError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "UserGroupEdit")==0)
		{
			IClientUserGroupEditResponse* icresp = dynamic_cast<IClientUserGroupEditResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onUserGroupEditComplete(icresp, response->queryState());
				else
					eventSink->onUserGroupEditError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "UserGroupEditInput")==0)
		{
			IClientUserGroupEditInputResponse* icresp = dynamic_cast<IClientUserGroupEditInputResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onUserGroupEditInputComplete(icresp, response->queryState());
				else
					eventSink->onUserGroupEditInputError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "UserInfoEdit")==0)
		{
			IClientUserInfoEditResponse* icresp = dynamic_cast<IClientUserInfoEditResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onUserInfoEditComplete(icresp, response->queryState());
				else
					eventSink->onUserInfoEditError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "UserInfoEditInput")==0)
		{
			IClientUserInfoEditInputResponse* icresp = dynamic_cast<IClientUserInfoEditInputResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onUserInfoEditInputComplete(icresp, response->queryState());
				else
					eventSink->onUserInfoEditInputError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "UserPosix")==0)
		{
			IClientUserPosixResponse* icresp = dynamic_cast<IClientUserPosixResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onUserPosixComplete(icresp, response->queryState());
				else
					eventSink->onUserPosixError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "UserPosixInput")==0)
		{
			IClientUserPosixInputResponse* icresp = dynamic_cast<IClientUserPosixInputResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onUserPosixInputComplete(icresp, response->queryState());
				else
					eventSink->onUserPosixInputError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "UserQuery")==0)
		{
			IClientUserQueryResponse* icresp = dynamic_cast<IClientUserQueryResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onUserQueryComplete(icresp, response->queryState());
				else
					eventSink->onUserQueryError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "UserResetPass")==0)
		{
			IClientUserResetPassResponse* icresp = dynamic_cast<IClientUserResetPassResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onUserResetPassComplete(icresp, response->queryState());
				else
					eventSink->onUserResetPassError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "UserResetPassInput")==0)
		{
			IClientUserResetPassInputResponse* icresp = dynamic_cast<IClientUserResetPassInputResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onUserResetPassInputComplete(icresp, response->queryState());
				else
					eventSink->onUserResetPassInputError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "UserSudoers")==0)
		{
			IClientUserSudoersResponse* icresp = dynamic_cast<IClientUserSudoersResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onUserSudoersComplete(icresp, response->queryState());
				else
					eventSink->onUserSudoersError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "UserSudoersInput")==0)
		{
			IClientUserSudoersInputResponse* icresp = dynamic_cast<IClientUserSudoersInputResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onUserSudoersInputComplete(icresp, response->queryState());
				else
					eventSink->onUserSudoersInputError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "Users")==0)
		{
			IClientUserResponse* icresp = dynamic_cast<IClientUserResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onUsersComplete(icresp, response->queryState());
				else
					eventSink->onUsersError(icresp,response->queryState());
			}
		}
		response->unlock();
	}
	return 0;
}

static IRpcResponseBinding* createws_accessResponseObject(IRpcRequestBinding *request)
{
	const char* method = request->getMethod();
	if (stricmp(method, "AccountPermissions")==0)
		return new CAccountPermissionsResponse("ws_access", request);
	if (stricmp(method, "AddUser")==0)
		return new CAddUserResponse("ws_access", request);
	if (stricmp(method, "AddView")==0)
		return new CAddViewResponse("ws_access", request);
	if (stricmp(method, "AddViewColumn")==0)
		return new CAddViewColumnResponse("ws_access", request);
	if (stricmp(method, "AddViewMember")==0)
		return new CAddViewMemberResponse("ws_access", request);
	if (stricmp(method, "ClearPermissionsCache")==0)
		return new CClearPermissionsCacheResponse("ws_access", request);
	if (stricmp(method, "DeleteView")==0)
		return new CDeleteViewResponse("ws_access", request);
	if (stricmp(method, "DeleteViewColumn")==0)
		return new CDeleteViewColumnResponse("ws_access", request);
	if (stricmp(method, "DeleteViewMember")==0)
		return new CDeleteViewMemberResponse("ws_access", request);
	if (stricmp(method, "DisableScopeScans")==0)
		return new CDisableScopeScansResponse("ws_access", request);
	if (stricmp(method, "EnableScopeScans")==0)
		return new CEnableScopeScansResponse("ws_access", request);
	if (stricmp(method, "FilePermission")==0)
		return new CFilePermissionResponse("ws_access", request);
	if (stricmp(method, "GroupAction")==0)
		return new CGroupActionResponse("ws_access", request);
	if (stricmp(method, "GroupAdd")==0)
		return new CGroupAddResponse("ws_access", request);
	if (stricmp(method, "GroupEdit")==0)
		return new CGroupEditResponse("ws_access", request);
	if (stricmp(method, "GroupMemberEdit")==0)
		return new CGroupMemberEditResponse("ws_access", request);
	if (stricmp(method, "GroupMemberEditInput")==0)
		return new CGroupMemberEditInputResponse("ws_access", request);
	if (stricmp(method, "GroupMemberQuery")==0)
		return new CGroupMemberQueryResponse("ws_access", request);
	if (stricmp(method, "GroupQuery")==0)
		return new CGroupQueryResponse("ws_access", request);
	if (stricmp(method, "Groups")==0)
		return new CGroupResponse("ws_access", request);
	if (stricmp(method, "PermissionAction")==0)
		return new CPermissionActionResponse("ws_access", request);
	if (stricmp(method, "PermissionAddInput")==0)
		return new CPermissionAddResponse("ws_access", request);
	if (stricmp(method, "Permissions")==0)
		return new CBasednsResponse("ws_access", request);
	if (stricmp(method, "PermissionsReset")==0)
		return new CPermissionsResetResponse("ws_access", request);
	if (stricmp(method, "PermissionsResetInput")==0)
		return new CPermissionsResetInputResponse("ws_access", request);
	if (stricmp(method, "Ping")==0)
		return new Cws_accessPingResponse("ws_access", request);
	if (stricmp(method, "QueryScopeScansEnabled")==0)
		return new CQueryScopeScansEnabledResponse("ws_access", request);
	if (stricmp(method, "QueryUserViewColumns")==0)
		return new CQueryUserViewColumnsResponse("ws_access", request);
	if (stricmp(method, "QueryViewColumns")==0)
		return new CQueryViewColumnsResponse("ws_access", request);
	if (stricmp(method, "QueryViewMembers")==0)
		return new CQueryViewMembersResponse("ws_access", request);
	if (stricmp(method, "QueryViews")==0)
		return new CQueryViewsResponse("ws_access", request);
	if (stricmp(method, "ResourceAdd")==0)
		return new CResourceAddResponse("ws_access", request);
	if (stricmp(method, "ResourceAddInput")==0)
		return new CResourceAddInputResponse("ws_access", request);
	if (stricmp(method, "ResourceDelete")==0)
		return new CResourceDeleteResponse("ws_access", request);
	if (stricmp(method, "ResourcePermissionQuery")==0)
		return new CResourcePermissionQueryResponse("ws_access", request);
	if (stricmp(method, "ResourcePermissions")==0)
		return new CResourcePermissionsResponse("ws_access", request);
	if (stricmp(method, "ResourceQuery")==0)
		return new CResourceQueryResponse("ws_access", request);
	if (stricmp(method, "Resources")==0)
		return new CResourcesResponse("ws_access", request);
	if (stricmp(method, "UserAccountExport")==0)
		return new CUserAccountExportResponse("ws_access", request);
	if (stricmp(method, "UserAction")==0)
		return new CUserActionResponse("ws_access", request);
	if (stricmp(method, "UserEdit")==0)
		return new CUserEditResponse("ws_access", request);
	if (stricmp(method, "UserGroupEdit")==0)
		return new CUserGroupEditResponse("ws_access", request);
	if (stricmp(method, "UserGroupEditInput")==0)
		return new CUserGroupEditInputResponse("ws_access", request);
	if (stricmp(method, "UserInfoEdit")==0)
		return new CUserInfoEditResponse("ws_access", request);
	if (stricmp(method, "UserInfoEditInput")==0)
		return new CUserInfoEditInputResponse("ws_access", request);
	if (stricmp(method, "UserPosix")==0)
		return new CUserPosixResponse("ws_access", request);
	if (stricmp(method, "UserPosixInput")==0)
		return new CUserPosixInputResponse("ws_access", request);
	if (stricmp(method, "UserQuery")==0)
		return new CUserQueryResponse("ws_access", request);
	if (stricmp(method, "UserResetPass")==0)
		return new CUserResetPassResponse("ws_access", request);
	if (stricmp(method, "UserResetPassInput")==0)
		return new CUserResetPassInputResponse("ws_access", request);
	if (stricmp(method, "UserSudoers")==0)
		return new CUserSudoersResponse("ws_access", request);
	if (stricmp(method, "UserSudoersInput")==0)
		return new CUserSudoersInputResponse("ws_access", request);
	if (stricmp(method, "Users")==0)
		return new CUserResponse("ws_access", request);
	return NULL;
}

#ifdef _WIN32
void CClientws_access::espWorkerThread(void* data)
#else
void *CClientws_access::espWorkerThread(void *data)
#endif
{
	IRpcRequestBinding *request = (IRpcRequestBinding *) data;

	if (request != NULL)
	{
		request->lock();
		IRpcResponseBinding *response=createws_accessResponseObject(request);
		if (response!=NULL)
		{
			try{
				request->post(*response);
			}
			catch(IException* ex){
				StringBuffer errorStr;
				ex->errorMessage(errorStr);
				ERRLOG("CClientws_access::espWorkerThread(%s)--Exception caught while posting async request: %s", request->getMethod(), errorStr.str());
				ex->Release();
			}
			catch(...){
				ERRLOG("Unknown exception caught while posting async request");
			}
		}
#ifdef USE_CLIENT_THREAD
		ThunkToClientThread(request->getThunkHandle(), transferThunkEvent, (void *)response);
#else
		transferThunkEvent((void *)response);
#endif
		request->unlock();
		if(request->queryState()!=NULL)
			request->queryState()->Release();

		if(response!=NULL)
			response->Release();

		request->Release();
	}
#if defined(_WIN32)
#else
	return (void *) 0 ;
#endif
}



extern "C" IClientws_access * createws_accessClient() {  return new CClientws_access(); }


#endif //ws_access_ESPGEN_INCLUDED
