// *** Source file generated by HIDL Version 1.3 from ws_store.ecm ***
// *** Not to be hand edited (changes will be lost on re-generation) ***

#ifndef ws_store_ESPGEN_INCLUDED
#define ws_store_ESPGEN_INCLUDED

#include "ws_store_esp.ipp"

#ifdef _WIN32
#include "edwin.h"
#include <process.h>
#endif



//=======================================================
// class CKVPair Implementation
//=======================================================

CKVPair::CKVPair(const char *serviceName, IRpcMessageBinding *init)
	: m_Key(nilIgnore),m_Value(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("KVPair");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CKVPair::CKVPair(const char *serviceName, const char *bc)
	: m_Key(nilIgnore),m_Value(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("KVPair");
}

StringBuffer &CKVPair::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:complexType name=\"%s\">\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Key\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Value\" type=\"xsd:string\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType>\n");
		}
	}
	return schema;
}

void CKVPair::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CKVPair::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CKVPair::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Key");
	form.appendf("  <tr><td><b>Key: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Value");
	form.appendf("  <tr><td><b>Value: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CKVPair::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CKVPair::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_Key.marshall(rpc_resp, "Key", "", "", "");
	m_Value.marshall(rpc_resp, "Value", "", "", "");
}


void CKVPair::copy(CKVPair &from)
{
	m_Key.copy(from.m_Key);
	m_Value.copy(from.m_Value);
}


void CKVPair::copy(IConstKVPair &ifrom)
{
	setKey(ifrom.getKey());
	setValue(ifrom.getValue());
}


void CKVPair::getAttributes(IProperties &attributes)
{
}


void CKVPair::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_Key.toStr(ctx, buffer, "Key", "", true, "", "");
	m_Value.toStr(ctx, buffer, "Value", "", true, "", "");
}


void CKVPair::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CKVPair::serializer(IEspContext* ctx, IConstKVPair &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<KVPair>");
	// field Key
	{
		const char* s = src.getKey();
		if (s && *s)
		{
			buffer.append("<Key>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Key>");
		}
	}
	// field Value
	{
		const char* s = src.getValue();
		if (s && *s)
		{
			buffer.append("<Value>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Value>");
		}
	}
	if (keepRootTag)
		buffer.append("</KVPair>");
}

bool CKVPair::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_Key.unmarshall(rpc_request, "Key", basepath);
	hasValue |= m_Value.unmarshall(rpc_request, "Value", basepath);
	return hasValue;
}

bool CKVPair::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Key.unmarshall(ctx, soapval, "Key");
	hasValue |= m_Value.unmarshall(ctx, soapval, "Value");
	return hasValue;
}

bool CKVPair::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Key.unmarshall(ctx, params, attachments, "Key", basepath);
	hasValue |= m_Value.unmarshall(ctx, params, attachments, "Value", basepath);
	return hasValue;
}

const char * CKVPair::getKey() { return m_Key.query();}
const char * CKVPair::getValue() { return m_Value.query();}
void CKVPair::setKey(const char * val){ m_Key.set(val); }
void CKVPair::setValue(const char * val){ m_Value.set(val); }
extern "C"  IEspKVPair *createKVPair(const char *serv, const char *msgname){return ((IEspKVPair *)new CKVPair(serv /*, msgname*/));}
extern "C"  IClientKVPair *createClientKVPair(const char *serv, const char *msgname){return ((IClientKVPair *)new CKVPair(serv /*, msgname*/));}

//=======================================================
// class CNamespaceSet Implementation
//=======================================================

CNamespaceSet::CNamespaceSet(const char *serviceName, IRpcMessageBinding *init)
	: m_Namespace(nilIgnore),m_Entries(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("NamespaceSet");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CNamespaceSet::CNamespaceSet(const char *serviceName, const char *bc)
	: m_Namespace(nilIgnore),m_Entries(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("NamespaceSet");
}

StringBuffer &CNamespaceSet::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:complexType name=\"%s\">\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Namespace\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Entries\">\n");
		schema.append("<xsd:complexType><xsd:sequence>\n");
		schema.append("<xsd:element minOccurs=\"0\" maxOccurs=\"unbounded\" name=\"Entry\" type=\"tns:KVPair\"/>");
		schema.append("</xsd:sequence></xsd:complexType>");
		schema.append("</xsd:element>");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType>\n");
		}
	}
	if (!(flags & 0x10)  || (flags & 0x100))
	{
		CKVPair::getXsdDefinition(context, request, schema, added);
	}
	return schema;
}

void CNamespaceSet::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CNamespaceSet::getMapInfo(IMapInfo& info, BoolHash& added)
{
	if (!added.getValue("KVPair"))
	{
		added.setValue("KVPair",1);
		CKVPair::getMapInfo(info,added);
	}
}

StringBuffer &CNamespaceSet::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Namespace");
	form.appendf("  <tr><td><b>Namespace: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Entries");
	form.appendf("<tr><td><b>Entries: </b></td><td>");
	form.appendf("<table><tr><td><textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea></td>", extfix.str());
	form.append("</tr></table>");
	form.append("</td></tr>");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CNamespaceSet::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CNamespaceSet::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_Namespace.marshall(rpc_resp, "Namespace", "", "", "");
	m_Entries.marshall(rpc_resp, "Entries", "Entry");
}


void CNamespaceSet::copy(CNamespaceSet &from)
{
	m_Namespace.copy(from.m_Namespace);
	m_Entries.copy(from.m_Entries);
}


void CNamespaceSet::copy(IConstNamespaceSet &ifrom)
{
	setNamespace(ifrom.getNamespace());
	setEntries(ifrom.getEntries());
}


void CNamespaceSet::getAttributes(IProperties &attributes)
{
}


void CNamespaceSet::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_Namespace.toStr(ctx, buffer, "Namespace", "", true, "", "");
	m_Entries.toStr(ctx, buffer, "Entries", "Entry");
}


void CNamespaceSet::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CNamespaceSet::serializer(IEspContext* ctx, IConstNamespaceSet &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<NamespaceSet>");
	// field Namespace
	{
		const char* s = src.getNamespace();
		if (s && *s)
		{
			buffer.append("<Namespace>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Namespace>");
		}
	}
	// field Entries
	{
		IArrayOf<IConstKVPair>& v = src.getEntries();
		int size = v.length();
		if (size>0)
			buffer.append("<Entries>");
		for (int i=0;i<size;i++)
		{
			buffer.append("<Entry>");
			CKVPair::serializer(ctx,v.item(i),buffer,false);
			buffer.append("</Entry>");
		}
		if (size>0)
			buffer.append("</Entries>");
	}
	if (keepRootTag)
		buffer.append("</NamespaceSet>");
}

bool CNamespaceSet::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_Namespace.unmarshall(rpc_request, "Namespace", basepath);
	hasValue |= m_Entries.unmarshall(rpc_request, "Entries", basepath);
	return hasValue;
}

bool CNamespaceSet::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Namespace.unmarshall(ctx, soapval, "Namespace");
	hasValue |= m_Entries.unmarshall(ctx, soapval, "Entries");
	return hasValue;
}

bool CNamespaceSet::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Namespace.unmarshall(ctx, params, attachments, "Namespace", basepath);
	hasValue |= m_Entries.unmarshall(ctx, params, attachments, "Entries", basepath);
	return hasValue;
}

const char * CNamespaceSet::getNamespace() { return m_Namespace.query();}
IArrayOf<IConstKVPair> & CNamespaceSet::getEntries() { return (IArrayOf<IConstKVPair> &) m_Entries; }
void CNamespaceSet::setNamespace(const char * val){ m_Namespace.set(val); }
void CNamespaceSet::setEntries(IArrayOf<IEspKVPair> &val)
{
	m_Entries->kill();
	IArrayOf<IConstKVPair> &target = m_Entries.getValue();
	ForEachItemIn(idx, val)
	{
		IEspKVPair &item = (val).item(idx);
		item.Link();
		target.append(item);
	}
}
void CNamespaceSet::setEntries(IArrayOf<IConstKVPair> &val)
{
	m_Entries->kill();
	IArrayOf<IConstKVPair> &target = m_Entries.getValue();
	ForEachItemIn(idx, val)
	{
		IConstKVPair &item = val.item(idx);
		item.Link();
		target.append(item);
	}
}
extern "C"  IEspNamespaceSet *createNamespaceSet(const char *serv, const char *msgname){return ((IEspNamespaceSet *)new CNamespaceSet(serv /*, msgname*/));}
extern "C"  IClientNamespaceSet *createClientNamespaceSet(const char *serv, const char *msgname){return ((IClientNamespaceSet *)new CNamespaceSet(serv /*, msgname*/));}

//=======================================================
// class CListKeysRequest Implementation
//=======================================================

CListKeysRequest::CListKeysRequest(const char *serviceName, IRpcMessageBinding *init)
	: m_StoreName(nilIgnore),m_Namespace(nilIgnore),m_UserSpecific(0, nilIgnore,false)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ListKeysRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CListKeysRequest::CListKeysRequest(const char *serviceName, const char *bc)
	: m_StoreName(nilIgnore),m_Namespace(nilIgnore),m_UserSpecific(0, nilIgnore,false)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ListKeysRequest");
}

CListKeysRequest::CListKeysRequest(const char *serviceName, IRpcMessage* rpcmsg)
	: m_StoreName(nilIgnore),m_Namespace(nilIgnore),m_UserSpecific(0, nilIgnore,false)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ListKeysRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CListKeysRequest::CListKeysRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_StoreName(nilIgnore),m_Namespace(nilIgnore),m_UserSpecific(0, nilIgnore,false)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ListKeysRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CListKeysRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"StoreName\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Namespace\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" default=\"false\" name=\"UserSpecific\" type=\"xsd:boolean\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CListKeysRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CListKeysRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CListKeysRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("StoreName");
	form.appendf("  <tr><td><b>StoreName: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Namespace");
	form.appendf("  <tr><td><b>Namespace: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("UserSpecific");
	
	form.appendf("  <tr><td><b>UserSpecific? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CListKeysRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CListKeysRequest::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_StoreName.marshall(rpc_resp, "StoreName", "", "", "");
	m_Namespace.marshall(rpc_resp, "Namespace", "", "", "");
	m_UserSpecific.marshall(rpc_resp, "UserSpecific", "", "", "");
}


void CListKeysRequest::copy(CListKeysRequest &from)
{
	m_StoreName.copy(from.m_StoreName);
	m_Namespace.copy(from.m_Namespace);
	m_UserSpecific.copy(from.m_UserSpecific);
}


void CListKeysRequest::copy(IConstListKeysRequest &ifrom)
{
	setStoreName(ifrom.getStoreName());
	setNamespace(ifrom.getNamespace());
	setUserSpecific(ifrom.getUserSpecific());
}


void CListKeysRequest::getAttributes(IProperties &attributes)
{
}


void CListKeysRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_StoreName.toStr(ctx, buffer, "StoreName", "", true, "", "");
	m_Namespace.toStr(ctx, buffer, "Namespace", "", true, "", "");
	m_UserSpecific.toStr(ctx, buffer, "UserSpecific", "", true, "", "");
}


void CListKeysRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CListKeysRequest::serializer(IEspContext* ctx, IConstListKeysRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<ListKeysRequest>");
	// field StoreName
	{
		const char* s = src.getStoreName();
		if (s && *s)
		{
			buffer.append("<StoreName>");
			encodeUtf8XML(s,buffer);
			buffer.append("</StoreName>");
		}
	}
	// field Namespace
	{
		const char* s = src.getNamespace();
		if (s && *s)
		{
			buffer.append("<Namespace>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Namespace>");
		}
	}
	// field UserSpecific
	{
		bool b = src.getUserSpecific();
		if (b)
			buffer.appendf("<UserSpecific>1</UserSpecific>");
	}
	if (keepRootTag)
		buffer.append("</ListKeysRequest>");
}

bool CListKeysRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_StoreName.unmarshall(rpc_request, "StoreName", basepath);
	hasValue |= m_Namespace.unmarshall(rpc_request, "Namespace", basepath);
	hasValue |= m_UserSpecific.unmarshall(rpc_request, "UserSpecific", basepath);
	return hasValue;
}

bool CListKeysRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_StoreName.unmarshall(ctx, soapval, "StoreName");
	hasValue |= m_Namespace.unmarshall(ctx, soapval, "Namespace");
	hasValue |= m_UserSpecific.unmarshall(ctx, soapval, "UserSpecific");
	return hasValue;
}

bool CListKeysRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_StoreName.unmarshall(ctx, params, attachments, "StoreName", basepath);
	hasValue |= m_Namespace.unmarshall(ctx, params, attachments, "Namespace", basepath);
	hasValue |= m_UserSpecific.unmarshall(ctx, params, attachments, "UserSpecific", basepath);
	return hasValue;
}

const char * CListKeysRequest::getStoreName() { return m_StoreName.query();}
const char * CListKeysRequest::getNamespace() { return m_Namespace.query();}
bool CListKeysRequest::getUserSpecific() { return m_UserSpecific;}
void CListKeysRequest::setStoreName(const char * val){ m_StoreName.set(val); }
void CListKeysRequest::setNamespace(const char * val){ m_Namespace.set(val); }
void CListKeysRequest::setUserSpecific(bool val){ m_UserSpecific=val; }
extern "C"  IEspListKeysRequest *createListKeysRequest(const char *serv){return ((IEspListKeysRequest *)new CListKeysRequest(serv));}
extern "C"  IClientListKeysRequest *createClientListKeysRequest(const char *serv){return ((IClientListKeysRequest *)new CListKeysRequest(serv));}

//=======================================================
// class CListKeysResponse Implementation
//=======================================================

CListKeysResponse::CListKeysResponse(const char *serviceName, IRpcMessageBinding *init)
	: m_StoreName(nilIgnore),m_Namespace(nilIgnore),m_KeySet(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ListKeysResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CListKeysResponse::CListKeysResponse(const char *serviceName, const char *bc)
	: m_StoreName(nilIgnore),m_Namespace(nilIgnore),m_KeySet(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ListKeysResponse");
}

CListKeysResponse::CListKeysResponse(const char *serviceName, IRpcMessage* rpcmsg)
	: m_StoreName(nilIgnore),m_Namespace(nilIgnore),m_KeySet(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ListKeysResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CListKeysResponse::CListKeysResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_StoreName(nilIgnore),m_Namespace(nilIgnore),m_KeySet(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ListKeysResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CListKeysResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		schema.append("<xsd:element name=\"Exceptions\" type=\"tns:ArrayOfEspException\" minOccurs=\"0\" maxOccurs=\"1\"/>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"StoreName\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Namespace\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"KeySet\">");
		schema.append("<xsd:complexType><xsd:sequence>");
		schema.append("<xsd:element name=\"Key\" type=\"xsd:string\" minOccurs=\"0\" maxOccurs=\"unbounded\"/>\n");
		schema.append("</xsd:sequence></xsd:complexType>\n");
		schema.append("</xsd:element>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CListKeysResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CListKeysResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CListKeysResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("StoreName");
	form.appendf("  <tr><td><b>StoreName: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Namespace");
	form.appendf("  <tr><td><b>Namespace: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("KeySet");
	form.appendf("<tr><td><b>KeySet: </b></td><td>");
	form.appendf("<textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea>", extfix.str());
	form.append("</td></tr>");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CListKeysResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CListKeysResponse::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
		m_StoreName.marshall(rpc_resp, "StoreName", "", "", "");
		m_Namespace.marshall(rpc_resp, "Namespace", "", "", "");
		m_KeySet.marshall(rpc_resp, "KeySet", "Key");
	}
}


void CListKeysResponse::copy(CListKeysResponse &from)
{
	m_StoreName.copy(from.m_StoreName);
	m_Namespace.copy(from.m_Namespace);
	m_KeySet.copy(from.m_KeySet);
}


void CListKeysResponse::copy(IConstListKeysResponse &ifrom)
{
	setStoreName(ifrom.getStoreName());
	setNamespace(ifrom.getNamespace());
	setKeySet(ifrom.getKeySet());
}


void CListKeysResponse::getAttributes(IProperties &attributes)
{
}


void CListKeysResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
		m_StoreName.toStr(ctx, buffer, "StoreName", "", true, "", "");
		m_Namespace.toStr(ctx, buffer, "Namespace", "", true, "", "");
		m_KeySet.toStr(ctx, buffer, "KeySet", "Key");
	}
}


void CListKeysResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CListKeysResponse::serializer(IEspContext* ctx, IConstListKeysResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<ListKeysResponse>");
	// field StoreName
	{
		const char* s = src.getStoreName();
		if (s && *s)
		{
			buffer.append("<StoreName>");
			encodeUtf8XML(s,buffer);
			buffer.append("</StoreName>");
		}
	}
	// field Namespace
	{
		const char* s = src.getNamespace();
		if (s && *s)
		{
			buffer.append("<Namespace>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Namespace>");
		}
	}
	// field KeySet
	{
		StringArray& v = src.getKeySet();
		if (v.length()>0)
			buffer.append("<KeySet>");
		for (size32_t i=0;i<v.length();i++)
			buffer.appendf("<Key>%s</Key>",v.item(i));
		if (v.length()>0)
			buffer.append("</KeySet>");
	}
	if (keepRootTag)
		buffer.append("</ListKeysResponse>");
}

bool CListKeysResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
		hasValue |= m_StoreName.unmarshall(rpc_request, "StoreName", basepath);
		hasValue |= m_Namespace.unmarshall(rpc_request, "Namespace", basepath);
		hasValue |= m_KeySet.unmarshall(rpc_request, "KeySet", basepath);
	}
	return hasValue;
}

bool CListKeysResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_StoreName.unmarshall(ctx, soapval, "StoreName");
	hasValue |= m_Namespace.unmarshall(ctx, soapval, "Namespace");
	hasValue |= m_KeySet.unmarshall(ctx, soapval, "KeySet");
	return hasValue;
}

bool CListKeysResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_StoreName.unmarshall(ctx, params, attachments, "StoreName", basepath);
	hasValue |= m_Namespace.unmarshall(ctx, params, attachments, "Namespace", basepath);
	hasValue |= m_KeySet.unmarshall(ctx, params, attachments, "KeySet", basepath);
	return hasValue;
}

const char * CListKeysResponse::getStoreName() { return m_StoreName.query();}
const char * CListKeysResponse::getNamespace() { return m_Namespace.query();}
StringArray & CListKeysResponse::getKeySet() { return (StringArray &) m_KeySet; }
void CListKeysResponse::setStoreName(const char * val){ m_StoreName.set(val); }
void CListKeysResponse::setNamespace(const char * val){ m_Namespace.set(val); }
void CListKeysResponse::setKeySet(StringArray &val){ m_KeySet->kill();  CloneArray(m_KeySet.getValue(), val); }
extern "C"  IEspListKeysResponse *createListKeysResponse(const char *serv){return ((IEspListKeysResponse *)new CListKeysResponse(serv));}
extern "C"  IClientListKeysResponse *createClientListKeysResponse(const char *serv){return ((IClientListKeysResponse *)new CListKeysResponse(serv));}

//=======================================================
// class CListNamespacesRequest Implementation
//=======================================================

CListNamespacesRequest::CListNamespacesRequest(const char *serviceName, IRpcMessageBinding *init)
	: m_StoreName(nilIgnore),m_UserSpecific(0, nilIgnore,false)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ListNamespacesRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CListNamespacesRequest::CListNamespacesRequest(const char *serviceName, const char *bc)
	: m_StoreName(nilIgnore),m_UserSpecific(0, nilIgnore,false)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ListNamespacesRequest");
}

CListNamespacesRequest::CListNamespacesRequest(const char *serviceName, IRpcMessage* rpcmsg)
	: m_StoreName(nilIgnore),m_UserSpecific(0, nilIgnore,false)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ListNamespacesRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CListNamespacesRequest::CListNamespacesRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_StoreName(nilIgnore),m_UserSpecific(0, nilIgnore,false)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ListNamespacesRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CListNamespacesRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"StoreName\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" default=\"false\" name=\"UserSpecific\" type=\"xsd:boolean\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CListNamespacesRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CListNamespacesRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CListNamespacesRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("StoreName");
	form.appendf("  <tr><td><b>StoreName: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("UserSpecific");
	
	form.appendf("  <tr><td><b>UserSpecific? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CListNamespacesRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CListNamespacesRequest::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_StoreName.marshall(rpc_resp, "StoreName", "", "", "");
	m_UserSpecific.marshall(rpc_resp, "UserSpecific", "", "", "");
}


void CListNamespacesRequest::copy(CListNamespacesRequest &from)
{
	m_StoreName.copy(from.m_StoreName);
	m_UserSpecific.copy(from.m_UserSpecific);
}


void CListNamespacesRequest::copy(IConstListNamespacesRequest &ifrom)
{
	setStoreName(ifrom.getStoreName());
	setUserSpecific(ifrom.getUserSpecific());
}


void CListNamespacesRequest::getAttributes(IProperties &attributes)
{
}


void CListNamespacesRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_StoreName.toStr(ctx, buffer, "StoreName", "", true, "", "");
	m_UserSpecific.toStr(ctx, buffer, "UserSpecific", "", true, "", "");
}


void CListNamespacesRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CListNamespacesRequest::serializer(IEspContext* ctx, IConstListNamespacesRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<ListNamespacesRequest>");
	// field StoreName
	{
		const char* s = src.getStoreName();
		if (s && *s)
		{
			buffer.append("<StoreName>");
			encodeUtf8XML(s,buffer);
			buffer.append("</StoreName>");
		}
	}
	// field UserSpecific
	{
		bool b = src.getUserSpecific();
		if (b)
			buffer.appendf("<UserSpecific>1</UserSpecific>");
	}
	if (keepRootTag)
		buffer.append("</ListNamespacesRequest>");
}

bool CListNamespacesRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_StoreName.unmarshall(rpc_request, "StoreName", basepath);
	hasValue |= m_UserSpecific.unmarshall(rpc_request, "UserSpecific", basepath);
	return hasValue;
}

bool CListNamespacesRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_StoreName.unmarshall(ctx, soapval, "StoreName");
	hasValue |= m_UserSpecific.unmarshall(ctx, soapval, "UserSpecific");
	return hasValue;
}

bool CListNamespacesRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_StoreName.unmarshall(ctx, params, attachments, "StoreName", basepath);
	hasValue |= m_UserSpecific.unmarshall(ctx, params, attachments, "UserSpecific", basepath);
	return hasValue;
}

const char * CListNamespacesRequest::getStoreName() { return m_StoreName.query();}
bool CListNamespacesRequest::getUserSpecific() { return m_UserSpecific;}
void CListNamespacesRequest::setStoreName(const char * val){ m_StoreName.set(val); }
void CListNamespacesRequest::setUserSpecific(bool val){ m_UserSpecific=val; }
extern "C"  IEspListNamespacesRequest *createListNamespacesRequest(const char *serv){return ((IEspListNamespacesRequest *)new CListNamespacesRequest(serv));}
extern "C"  IClientListNamespacesRequest *createClientListNamespacesRequest(const char *serv){return ((IClientListNamespacesRequest *)new CListNamespacesRequest(serv));}

//=======================================================
// class CListNamespacesResponse Implementation
//=======================================================

CListNamespacesResponse::CListNamespacesResponse(const char *serviceName, IRpcMessageBinding *init)
	: m_StoreName(nilIgnore),m_Namespaces(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ListNamespacesResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CListNamespacesResponse::CListNamespacesResponse(const char *serviceName, const char *bc)
	: m_StoreName(nilIgnore),m_Namespaces(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ListNamespacesResponse");
}

CListNamespacesResponse::CListNamespacesResponse(const char *serviceName, IRpcMessage* rpcmsg)
	: m_StoreName(nilIgnore),m_Namespaces(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ListNamespacesResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CListNamespacesResponse::CListNamespacesResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_StoreName(nilIgnore),m_Namespaces(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ListNamespacesResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CListNamespacesResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		schema.append("<xsd:element name=\"Exceptions\" type=\"tns:ArrayOfEspException\" minOccurs=\"0\" maxOccurs=\"1\"/>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"StoreName\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Namespaces\">");
		schema.append("<xsd:complexType><xsd:sequence>");
		schema.append("<xsd:element name=\"Namespace\" type=\"xsd:string\" minOccurs=\"0\" maxOccurs=\"unbounded\"/>\n");
		schema.append("</xsd:sequence></xsd:complexType>\n");
		schema.append("</xsd:element>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CListNamespacesResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CListNamespacesResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CListNamespacesResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("StoreName");
	form.appendf("  <tr><td><b>StoreName: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Namespaces");
	form.appendf("<tr><td><b>Namespaces: </b></td><td>");
	form.appendf("<textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea>", extfix.str());
	form.append("</td></tr>");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CListNamespacesResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CListNamespacesResponse::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
		m_StoreName.marshall(rpc_resp, "StoreName", "", "", "");
		m_Namespaces.marshall(rpc_resp, "Namespaces", "Namespace");
	}
}


void CListNamespacesResponse::copy(CListNamespacesResponse &from)
{
	m_StoreName.copy(from.m_StoreName);
	m_Namespaces.copy(from.m_Namespaces);
}


void CListNamespacesResponse::copy(IConstListNamespacesResponse &ifrom)
{
	setStoreName(ifrom.getStoreName());
	setNamespaces(ifrom.getNamespaces());
}


void CListNamespacesResponse::getAttributes(IProperties &attributes)
{
}


void CListNamespacesResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
		m_StoreName.toStr(ctx, buffer, "StoreName", "", true, "", "");
		m_Namespaces.toStr(ctx, buffer, "Namespaces", "Namespace");
	}
}


void CListNamespacesResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CListNamespacesResponse::serializer(IEspContext* ctx, IConstListNamespacesResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<ListNamespacesResponse>");
	// field StoreName
	{
		const char* s = src.getStoreName();
		if (s && *s)
		{
			buffer.append("<StoreName>");
			encodeUtf8XML(s,buffer);
			buffer.append("</StoreName>");
		}
	}
	// field Namespaces
	{
		StringArray& v = src.getNamespaces();
		if (v.length()>0)
			buffer.append("<Namespaces>");
		for (size32_t i=0;i<v.length();i++)
			buffer.appendf("<Namespace>%s</Namespace>",v.item(i));
		if (v.length()>0)
			buffer.append("</Namespaces>");
	}
	if (keepRootTag)
		buffer.append("</ListNamespacesResponse>");
}

bool CListNamespacesResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
		hasValue |= m_StoreName.unmarshall(rpc_request, "StoreName", basepath);
		hasValue |= m_Namespaces.unmarshall(rpc_request, "Namespaces", basepath);
	}
	return hasValue;
}

bool CListNamespacesResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_StoreName.unmarshall(ctx, soapval, "StoreName");
	hasValue |= m_Namespaces.unmarshall(ctx, soapval, "Namespaces");
	return hasValue;
}

bool CListNamespacesResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_StoreName.unmarshall(ctx, params, attachments, "StoreName", basepath);
	hasValue |= m_Namespaces.unmarshall(ctx, params, attachments, "Namespaces", basepath);
	return hasValue;
}

const char * CListNamespacesResponse::getStoreName() { return m_StoreName.query();}
StringArray & CListNamespacesResponse::getNamespaces() { return (StringArray &) m_Namespaces; }
void CListNamespacesResponse::setStoreName(const char * val){ m_StoreName.set(val); }
void CListNamespacesResponse::setNamespaces(StringArray &val){ m_Namespaces->kill();  CloneArray(m_Namespaces.getValue(), val); }
extern "C"  IEspListNamespacesResponse *createListNamespacesResponse(const char *serv){return ((IEspListNamespacesResponse *)new CListNamespacesResponse(serv));}
extern "C"  IClientListNamespacesResponse *createClientListNamespacesResponse(const char *serv){return ((IClientListNamespacesResponse *)new CListNamespacesResponse(serv));}

//=======================================================
// class CDeleteNamespaceRequest Implementation
//=======================================================

CDeleteNamespaceRequest::CDeleteNamespaceRequest(const char *serviceName, IRpcMessageBinding *init)
	: m_StoreName(nilIgnore),m_Namespace(nilIgnore),m_UserSpecific(0, nilIgnore,false),m_TargetUser(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("DeleteNamespaceRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CDeleteNamespaceRequest::CDeleteNamespaceRequest(const char *serviceName, const char *bc)
	: m_StoreName(nilIgnore),m_Namespace(nilIgnore),m_UserSpecific(0, nilIgnore,false),m_TargetUser(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("DeleteNamespaceRequest");
}

CDeleteNamespaceRequest::CDeleteNamespaceRequest(const char *serviceName, IRpcMessage* rpcmsg)
	: m_StoreName(nilIgnore),m_Namespace(nilIgnore),m_UserSpecific(0, nilIgnore,false),m_TargetUser(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("DeleteNamespaceRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CDeleteNamespaceRequest::CDeleteNamespaceRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_StoreName(nilIgnore),m_Namespace(nilIgnore),m_UserSpecific(0, nilIgnore,false),m_TargetUser(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("DeleteNamespaceRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CDeleteNamespaceRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"StoreName\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Namespace\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" default=\"false\" name=\"UserSpecific\" type=\"xsd:boolean\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"TargetUser\" type=\"xsd:string\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CDeleteNamespaceRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CDeleteNamespaceRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CDeleteNamespaceRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("StoreName");
	form.appendf("  <tr><td><b>StoreName: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Namespace");
	form.appendf("  <tr><td><b>Namespace: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("UserSpecific");
	
	form.appendf("  <tr><td><b>UserSpecific? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("TargetUser");
	form.appendf("  <tr><td><b>TargetUser: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CDeleteNamespaceRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CDeleteNamespaceRequest::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_StoreName.marshall(rpc_resp, "StoreName", "", "", "");
	m_Namespace.marshall(rpc_resp, "Namespace", "", "", "");
	m_UserSpecific.marshall(rpc_resp, "UserSpecific", "", "", "");
	m_TargetUser.marshall(rpc_resp, "TargetUser", "", "", "");
}


void CDeleteNamespaceRequest::copy(CDeleteNamespaceRequest &from)
{
	m_StoreName.copy(from.m_StoreName);
	m_Namespace.copy(from.m_Namespace);
	m_UserSpecific.copy(from.m_UserSpecific);
	m_TargetUser.copy(from.m_TargetUser);
}


void CDeleteNamespaceRequest::copy(IConstDeleteNamespaceRequest &ifrom)
{
	setStoreName(ifrom.getStoreName());
	setNamespace(ifrom.getNamespace());
	setUserSpecific(ifrom.getUserSpecific());
	setTargetUser(ifrom.getTargetUser());
}


void CDeleteNamespaceRequest::getAttributes(IProperties &attributes)
{
}


void CDeleteNamespaceRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_StoreName.toStr(ctx, buffer, "StoreName", "", true, "", "");
	m_Namespace.toStr(ctx, buffer, "Namespace", "", true, "", "");
	m_UserSpecific.toStr(ctx, buffer, "UserSpecific", "", true, "", "");
	m_TargetUser.toStr(ctx, buffer, "TargetUser", "", true, "", "");
}


void CDeleteNamespaceRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CDeleteNamespaceRequest::serializer(IEspContext* ctx, IConstDeleteNamespaceRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<DeleteNamespaceRequest>");
	// field StoreName
	{
		const char* s = src.getStoreName();
		if (s && *s)
		{
			buffer.append("<StoreName>");
			encodeUtf8XML(s,buffer);
			buffer.append("</StoreName>");
		}
	}
	// field Namespace
	{
		const char* s = src.getNamespace();
		if (s && *s)
		{
			buffer.append("<Namespace>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Namespace>");
		}
	}
	// field UserSpecific
	{
		bool b = src.getUserSpecific();
		if (b)
			buffer.appendf("<UserSpecific>1</UserSpecific>");
	}
	// field TargetUser
	{
		const char* s = src.getTargetUser();
		if (s && *s)
		{
			buffer.append("<TargetUser>");
			encodeUtf8XML(s,buffer);
			buffer.append("</TargetUser>");
		}
	}
	if (keepRootTag)
		buffer.append("</DeleteNamespaceRequest>");
}

bool CDeleteNamespaceRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_StoreName.unmarshall(rpc_request, "StoreName", basepath);
	hasValue |= m_Namespace.unmarshall(rpc_request, "Namespace", basepath);
	hasValue |= m_UserSpecific.unmarshall(rpc_request, "UserSpecific", basepath);
	hasValue |= m_TargetUser.unmarshall(rpc_request, "TargetUser", basepath);
	return hasValue;
}

bool CDeleteNamespaceRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_StoreName.unmarshall(ctx, soapval, "StoreName");
	hasValue |= m_Namespace.unmarshall(ctx, soapval, "Namespace");
	hasValue |= m_UserSpecific.unmarshall(ctx, soapval, "UserSpecific");
	hasValue |= m_TargetUser.unmarshall(ctx, soapval, "TargetUser");
	return hasValue;
}

bool CDeleteNamespaceRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_StoreName.unmarshall(ctx, params, attachments, "StoreName", basepath);
	hasValue |= m_Namespace.unmarshall(ctx, params, attachments, "Namespace", basepath);
	hasValue |= m_UserSpecific.unmarshall(ctx, params, attachments, "UserSpecific", basepath);
	hasValue |= m_TargetUser.unmarshall(ctx, params, attachments, "TargetUser", basepath);
	return hasValue;
}

const char * CDeleteNamespaceRequest::getStoreName() { return m_StoreName.query();}
const char * CDeleteNamespaceRequest::getNamespace() { return m_Namespace.query();}
bool CDeleteNamespaceRequest::getUserSpecific() { return m_UserSpecific;}
const char * CDeleteNamespaceRequest::getTargetUser() { return m_TargetUser.query();}
void CDeleteNamespaceRequest::setStoreName(const char * val){ m_StoreName.set(val); }
void CDeleteNamespaceRequest::setNamespace(const char * val){ m_Namespace.set(val); }
void CDeleteNamespaceRequest::setUserSpecific(bool val){ m_UserSpecific=val; }
void CDeleteNamespaceRequest::setTargetUser(const char * val){ m_TargetUser.set(val); }
extern "C"  IEspDeleteNamespaceRequest *createDeleteNamespaceRequest(const char *serv){return ((IEspDeleteNamespaceRequest *)new CDeleteNamespaceRequest(serv));}
extern "C"  IClientDeleteNamespaceRequest *createClientDeleteNamespaceRequest(const char *serv){return ((IClientDeleteNamespaceRequest *)new CDeleteNamespaceRequest(serv));}

//=======================================================
// class CDeleteNamespaceResponse Implementation
//=======================================================

CDeleteNamespaceResponse::CDeleteNamespaceResponse(const char *serviceName, IRpcMessageBinding *init)
	: m_Success(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("DeleteNamespaceResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CDeleteNamespaceResponse::CDeleteNamespaceResponse(const char *serviceName, const char *bc)
	: m_Success(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("DeleteNamespaceResponse");
}

CDeleteNamespaceResponse::CDeleteNamespaceResponse(const char *serviceName, IRpcMessage* rpcmsg)
	: m_Success(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("DeleteNamespaceResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CDeleteNamespaceResponse::CDeleteNamespaceResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_Success(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("DeleteNamespaceResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CDeleteNamespaceResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		schema.append("<xsd:element name=\"Exceptions\" type=\"tns:ArrayOfEspException\" minOccurs=\"0\" maxOccurs=\"1\"/>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Success\" type=\"xsd:boolean\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CDeleteNamespaceResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CDeleteNamespaceResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CDeleteNamespaceResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Success");
	
	form.appendf("  <tr><td><b>Success? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CDeleteNamespaceResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CDeleteNamespaceResponse::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
		m_Success.marshall(rpc_resp, "Success", "", "", "");
	}
}


void CDeleteNamespaceResponse::copy(CDeleteNamespaceResponse &from)
{
	m_Success.copy(from.m_Success);
}


void CDeleteNamespaceResponse::copy(IConstDeleteNamespaceResponse &ifrom)
{
	setSuccess(ifrom.getSuccess());
}


void CDeleteNamespaceResponse::getAttributes(IProperties &attributes)
{
}


void CDeleteNamespaceResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
		m_Success.toStr(ctx, buffer, "Success", "", true, "", "");
	}
}


void CDeleteNamespaceResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CDeleteNamespaceResponse::serializer(IEspContext* ctx, IConstDeleteNamespaceResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<DeleteNamespaceResponse>");
	// field Success
	{
		bool b = src.getSuccess();
		if (b)
			buffer.appendf("<Success>1</Success>");
	}
	if (keepRootTag)
		buffer.append("</DeleteNamespaceResponse>");
}

bool CDeleteNamespaceResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
		hasValue |= m_Success.unmarshall(rpc_request, "Success", basepath);
	}
	return hasValue;
}

bool CDeleteNamespaceResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Success.unmarshall(ctx, soapval, "Success");
	return hasValue;
}

bool CDeleteNamespaceResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Success.unmarshall(ctx, params, attachments, "Success", basepath);
	return hasValue;
}

bool CDeleteNamespaceResponse::getSuccess() { return m_Success;}
void CDeleteNamespaceResponse::setSuccess(bool val){ m_Success=val; }
extern "C"  IEspDeleteNamespaceResponse *createDeleteNamespaceResponse(const char *serv){return ((IEspDeleteNamespaceResponse *)new CDeleteNamespaceResponse(serv));}
extern "C"  IClientDeleteNamespaceResponse *createClientDeleteNamespaceResponse(const char *serv){return ((IClientDeleteNamespaceResponse *)new CDeleteNamespaceResponse(serv));}

//=======================================================
// class CDeleteRequest Implementation
//=======================================================

CDeleteRequest::CDeleteRequest(const char *serviceName, IRpcMessageBinding *init)
	: m_StoreName(nilIgnore),m_Namespace(nilIgnore),m_Key(nilIgnore),m_UserSpecific(0, nilIgnore,false),m_TargetUser(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("DeleteRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CDeleteRequest::CDeleteRequest(const char *serviceName, const char *bc)
	: m_StoreName(nilIgnore),m_Namespace(nilIgnore),m_Key(nilIgnore),m_UserSpecific(0, nilIgnore,false),m_TargetUser(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("DeleteRequest");
}

CDeleteRequest::CDeleteRequest(const char *serviceName, IRpcMessage* rpcmsg)
	: m_StoreName(nilIgnore),m_Namespace(nilIgnore),m_Key(nilIgnore),m_UserSpecific(0, nilIgnore,false),m_TargetUser(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("DeleteRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CDeleteRequest::CDeleteRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_StoreName(nilIgnore),m_Namespace(nilIgnore),m_Key(nilIgnore),m_UserSpecific(0, nilIgnore,false),m_TargetUser(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("DeleteRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CDeleteRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"StoreName\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Namespace\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Key\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" default=\"false\" name=\"UserSpecific\" type=\"xsd:boolean\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"TargetUser\" type=\"xsd:string\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CDeleteRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CDeleteRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CDeleteRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("StoreName");
	form.appendf("  <tr><td><b>StoreName: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Namespace");
	form.appendf("  <tr><td><b>Namespace: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Key");
	form.appendf("  <tr><td><b>Key: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("UserSpecific");
	
	form.appendf("  <tr><td><b>UserSpecific? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("TargetUser");
	form.appendf("  <tr><td><b>TargetUser: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CDeleteRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CDeleteRequest::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_StoreName.marshall(rpc_resp, "StoreName", "", "", "");
	m_Namespace.marshall(rpc_resp, "Namespace", "", "", "");
	m_Key.marshall(rpc_resp, "Key", "", "", "");
	m_UserSpecific.marshall(rpc_resp, "UserSpecific", "", "", "");
	m_TargetUser.marshall(rpc_resp, "TargetUser", "", "", "");
}


void CDeleteRequest::copy(CDeleteRequest &from)
{
	m_StoreName.copy(from.m_StoreName);
	m_Namespace.copy(from.m_Namespace);
	m_Key.copy(from.m_Key);
	m_UserSpecific.copy(from.m_UserSpecific);
	m_TargetUser.copy(from.m_TargetUser);
}


void CDeleteRequest::copy(IConstDeleteRequest &ifrom)
{
	setStoreName(ifrom.getStoreName());
	setNamespace(ifrom.getNamespace());
	setKey(ifrom.getKey());
	setUserSpecific(ifrom.getUserSpecific());
	setTargetUser(ifrom.getTargetUser());
}


void CDeleteRequest::getAttributes(IProperties &attributes)
{
}


void CDeleteRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_StoreName.toStr(ctx, buffer, "StoreName", "", true, "", "");
	m_Namespace.toStr(ctx, buffer, "Namespace", "", true, "", "");
	m_Key.toStr(ctx, buffer, "Key", "", true, "", "");
	m_UserSpecific.toStr(ctx, buffer, "UserSpecific", "", true, "", "");
	m_TargetUser.toStr(ctx, buffer, "TargetUser", "", true, "", "");
}


void CDeleteRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CDeleteRequest::serializer(IEspContext* ctx, IConstDeleteRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<DeleteRequest>");
	// field StoreName
	{
		const char* s = src.getStoreName();
		if (s && *s)
		{
			buffer.append("<StoreName>");
			encodeUtf8XML(s,buffer);
			buffer.append("</StoreName>");
		}
	}
	// field Namespace
	{
		const char* s = src.getNamespace();
		if (s && *s)
		{
			buffer.append("<Namespace>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Namespace>");
		}
	}
	// field Key
	{
		const char* s = src.getKey();
		if (s && *s)
		{
			buffer.append("<Key>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Key>");
		}
	}
	// field UserSpecific
	{
		bool b = src.getUserSpecific();
		if (b)
			buffer.appendf("<UserSpecific>1</UserSpecific>");
	}
	// field TargetUser
	{
		const char* s = src.getTargetUser();
		if (s && *s)
		{
			buffer.append("<TargetUser>");
			encodeUtf8XML(s,buffer);
			buffer.append("</TargetUser>");
		}
	}
	if (keepRootTag)
		buffer.append("</DeleteRequest>");
}

bool CDeleteRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_StoreName.unmarshall(rpc_request, "StoreName", basepath);
	hasValue |= m_Namespace.unmarshall(rpc_request, "Namespace", basepath);
	hasValue |= m_Key.unmarshall(rpc_request, "Key", basepath);
	hasValue |= m_UserSpecific.unmarshall(rpc_request, "UserSpecific", basepath);
	hasValue |= m_TargetUser.unmarshall(rpc_request, "TargetUser", basepath);
	return hasValue;
}

bool CDeleteRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_StoreName.unmarshall(ctx, soapval, "StoreName");
	hasValue |= m_Namespace.unmarshall(ctx, soapval, "Namespace");
	hasValue |= m_Key.unmarshall(ctx, soapval, "Key");
	hasValue |= m_UserSpecific.unmarshall(ctx, soapval, "UserSpecific");
	hasValue |= m_TargetUser.unmarshall(ctx, soapval, "TargetUser");
	return hasValue;
}

bool CDeleteRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_StoreName.unmarshall(ctx, params, attachments, "StoreName", basepath);
	hasValue |= m_Namespace.unmarshall(ctx, params, attachments, "Namespace", basepath);
	hasValue |= m_Key.unmarshall(ctx, params, attachments, "Key", basepath);
	hasValue |= m_UserSpecific.unmarshall(ctx, params, attachments, "UserSpecific", basepath);
	hasValue |= m_TargetUser.unmarshall(ctx, params, attachments, "TargetUser", basepath);
	return hasValue;
}

const char * CDeleteRequest::getStoreName() { return m_StoreName.query();}
const char * CDeleteRequest::getNamespace() { return m_Namespace.query();}
const char * CDeleteRequest::getKey() { return m_Key.query();}
bool CDeleteRequest::getUserSpecific() { return m_UserSpecific;}
const char * CDeleteRequest::getTargetUser() { return m_TargetUser.query();}
void CDeleteRequest::setStoreName(const char * val){ m_StoreName.set(val); }
void CDeleteRequest::setNamespace(const char * val){ m_Namespace.set(val); }
void CDeleteRequest::setKey(const char * val){ m_Key.set(val); }
void CDeleteRequest::setUserSpecific(bool val){ m_UserSpecific=val; }
void CDeleteRequest::setTargetUser(const char * val){ m_TargetUser.set(val); }
extern "C"  IEspDeleteRequest *createDeleteRequest(const char *serv){return ((IEspDeleteRequest *)new CDeleteRequest(serv));}
extern "C"  IClientDeleteRequest *createClientDeleteRequest(const char *serv){return ((IClientDeleteRequest *)new CDeleteRequest(serv));}

//=======================================================
// class CDeleteResponse Implementation
//=======================================================

CDeleteResponse::CDeleteResponse(const char *serviceName, IRpcMessageBinding *init)
	: m_Success(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("DeleteResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CDeleteResponse::CDeleteResponse(const char *serviceName, const char *bc)
	: m_Success(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("DeleteResponse");
}

CDeleteResponse::CDeleteResponse(const char *serviceName, IRpcMessage* rpcmsg)
	: m_Success(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("DeleteResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CDeleteResponse::CDeleteResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_Success(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("DeleteResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CDeleteResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		schema.append("<xsd:element name=\"Exceptions\" type=\"tns:ArrayOfEspException\" minOccurs=\"0\" maxOccurs=\"1\"/>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Success\" type=\"xsd:boolean\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CDeleteResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CDeleteResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CDeleteResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Success");
	
	form.appendf("  <tr><td><b>Success? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CDeleteResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CDeleteResponse::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
		m_Success.marshall(rpc_resp, "Success", "", "", "");
	}
}


void CDeleteResponse::copy(CDeleteResponse &from)
{
	m_Success.copy(from.m_Success);
}


void CDeleteResponse::copy(IConstDeleteResponse &ifrom)
{
	setSuccess(ifrom.getSuccess());
}


void CDeleteResponse::getAttributes(IProperties &attributes)
{
}


void CDeleteResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
		m_Success.toStr(ctx, buffer, "Success", "", true, "", "");
	}
}


void CDeleteResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CDeleteResponse::serializer(IEspContext* ctx, IConstDeleteResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<DeleteResponse>");
	// field Success
	{
		bool b = src.getSuccess();
		if (b)
			buffer.appendf("<Success>1</Success>");
	}
	if (keepRootTag)
		buffer.append("</DeleteResponse>");
}

bool CDeleteResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
		hasValue |= m_Success.unmarshall(rpc_request, "Success", basepath);
	}
	return hasValue;
}

bool CDeleteResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Success.unmarshall(ctx, soapval, "Success");
	return hasValue;
}

bool CDeleteResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Success.unmarshall(ctx, params, attachments, "Success", basepath);
	return hasValue;
}

bool CDeleteResponse::getSuccess() { return m_Success;}
void CDeleteResponse::setSuccess(bool val){ m_Success=val; }
extern "C"  IEspDeleteResponse *createDeleteResponse(const char *serv){return ((IEspDeleteResponse *)new CDeleteResponse(serv));}
extern "C"  IClientDeleteResponse *createClientDeleteResponse(const char *serv){return ((IClientDeleteResponse *)new CDeleteResponse(serv));}

//=======================================================
// class CFetchRequest Implementation
//=======================================================

CFetchRequest::CFetchRequest(const char *serviceName, IRpcMessageBinding *init)
	: m_StoreName(nilIgnore),m_Namespace(nilIgnore),m_Key(nilIgnore),m_UserSpecific(0, nilIgnore,false)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("FetchRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CFetchRequest::CFetchRequest(const char *serviceName, const char *bc)
	: m_StoreName(nilIgnore),m_Namespace(nilIgnore),m_Key(nilIgnore),m_UserSpecific(0, nilIgnore,false)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("FetchRequest");
}

CFetchRequest::CFetchRequest(const char *serviceName, IRpcMessage* rpcmsg)
	: m_StoreName(nilIgnore),m_Namespace(nilIgnore),m_Key(nilIgnore),m_UserSpecific(0, nilIgnore,false)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("FetchRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CFetchRequest::CFetchRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_StoreName(nilIgnore),m_Namespace(nilIgnore),m_Key(nilIgnore),m_UserSpecific(0, nilIgnore,false)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("FetchRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CFetchRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"StoreName\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Namespace\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Key\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" default=\"false\" name=\"UserSpecific\" type=\"xsd:boolean\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CFetchRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CFetchRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CFetchRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("StoreName");
	form.appendf("  <tr><td><b>StoreName: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Namespace");
	form.appendf("  <tr><td><b>Namespace: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Key");
	form.appendf("  <tr><td><b>Key: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("UserSpecific");
	
	form.appendf("  <tr><td><b>UserSpecific? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CFetchRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CFetchRequest::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_StoreName.marshall(rpc_resp, "StoreName", "", "", "");
	m_Namespace.marshall(rpc_resp, "Namespace", "", "", "");
	m_Key.marshall(rpc_resp, "Key", "", "", "");
	m_UserSpecific.marshall(rpc_resp, "UserSpecific", "", "", "");
}


void CFetchRequest::copy(CFetchRequest &from)
{
	m_StoreName.copy(from.m_StoreName);
	m_Namespace.copy(from.m_Namespace);
	m_Key.copy(from.m_Key);
	m_UserSpecific.copy(from.m_UserSpecific);
}


void CFetchRequest::copy(IConstFetchRequest &ifrom)
{
	setStoreName(ifrom.getStoreName());
	setNamespace(ifrom.getNamespace());
	setKey(ifrom.getKey());
	setUserSpecific(ifrom.getUserSpecific());
}


void CFetchRequest::getAttributes(IProperties &attributes)
{
}


void CFetchRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_StoreName.toStr(ctx, buffer, "StoreName", "", true, "", "");
	m_Namespace.toStr(ctx, buffer, "Namespace", "", true, "", "");
	m_Key.toStr(ctx, buffer, "Key", "", true, "", "");
	m_UserSpecific.toStr(ctx, buffer, "UserSpecific", "", true, "", "");
}


void CFetchRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CFetchRequest::serializer(IEspContext* ctx, IConstFetchRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<FetchRequest>");
	// field StoreName
	{
		const char* s = src.getStoreName();
		if (s && *s)
		{
			buffer.append("<StoreName>");
			encodeUtf8XML(s,buffer);
			buffer.append("</StoreName>");
		}
	}
	// field Namespace
	{
		const char* s = src.getNamespace();
		if (s && *s)
		{
			buffer.append("<Namespace>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Namespace>");
		}
	}
	// field Key
	{
		const char* s = src.getKey();
		if (s && *s)
		{
			buffer.append("<Key>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Key>");
		}
	}
	// field UserSpecific
	{
		bool b = src.getUserSpecific();
		if (b)
			buffer.appendf("<UserSpecific>1</UserSpecific>");
	}
	if (keepRootTag)
		buffer.append("</FetchRequest>");
}

bool CFetchRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_StoreName.unmarshall(rpc_request, "StoreName", basepath);
	hasValue |= m_Namespace.unmarshall(rpc_request, "Namespace", basepath);
	hasValue |= m_Key.unmarshall(rpc_request, "Key", basepath);
	hasValue |= m_UserSpecific.unmarshall(rpc_request, "UserSpecific", basepath);
	return hasValue;
}

bool CFetchRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_StoreName.unmarshall(ctx, soapval, "StoreName");
	hasValue |= m_Namespace.unmarshall(ctx, soapval, "Namespace");
	hasValue |= m_Key.unmarshall(ctx, soapval, "Key");
	hasValue |= m_UserSpecific.unmarshall(ctx, soapval, "UserSpecific");
	return hasValue;
}

bool CFetchRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_StoreName.unmarshall(ctx, params, attachments, "StoreName", basepath);
	hasValue |= m_Namespace.unmarshall(ctx, params, attachments, "Namespace", basepath);
	hasValue |= m_Key.unmarshall(ctx, params, attachments, "Key", basepath);
	hasValue |= m_UserSpecific.unmarshall(ctx, params, attachments, "UserSpecific", basepath);
	return hasValue;
}

const char * CFetchRequest::getStoreName() { return m_StoreName.query();}
const char * CFetchRequest::getNamespace() { return m_Namespace.query();}
const char * CFetchRequest::getKey() { return m_Key.query();}
bool CFetchRequest::getUserSpecific() { return m_UserSpecific;}
void CFetchRequest::setStoreName(const char * val){ m_StoreName.set(val); }
void CFetchRequest::setNamespace(const char * val){ m_Namespace.set(val); }
void CFetchRequest::setKey(const char * val){ m_Key.set(val); }
void CFetchRequest::setUserSpecific(bool val){ m_UserSpecific=val; }
extern "C"  IEspFetchRequest *createFetchRequest(const char *serv){return ((IEspFetchRequest *)new CFetchRequest(serv));}
extern "C"  IClientFetchRequest *createClientFetchRequest(const char *serv){return ((IClientFetchRequest *)new CFetchRequest(serv));}

//=======================================================
// class CFetchResponse Implementation
//=======================================================

CFetchResponse::CFetchResponse(const char *serviceName, IRpcMessageBinding *init)
	: m_Value(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("FetchResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CFetchResponse::CFetchResponse(const char *serviceName, const char *bc)
	: m_Value(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("FetchResponse");
}

CFetchResponse::CFetchResponse(const char *serviceName, IRpcMessage* rpcmsg)
	: m_Value(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("FetchResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CFetchResponse::CFetchResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_Value(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("FetchResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CFetchResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		schema.append("<xsd:element name=\"Exceptions\" type=\"tns:ArrayOfEspException\" minOccurs=\"0\" maxOccurs=\"1\"/>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Value\" type=\"xsd:string\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CFetchResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CFetchResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CFetchResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Value");
	form.appendf("  <tr><td><b>Value: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CFetchResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CFetchResponse::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
		m_Value.marshall(rpc_resp, "Value", "", "", "");
	}
}


void CFetchResponse::copy(CFetchResponse &from)
{
	m_Value.copy(from.m_Value);
}


void CFetchResponse::copy(IConstFetchResponse &ifrom)
{
	setValue(ifrom.getValue());
}


void CFetchResponse::getAttributes(IProperties &attributes)
{
}


void CFetchResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
		m_Value.toStr(ctx, buffer, "Value", "", true, "", "");
	}
}


void CFetchResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CFetchResponse::serializer(IEspContext* ctx, IConstFetchResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<FetchResponse>");
	// field Value
	{
		const char* s = src.getValue();
		if (s && *s)
		{
			buffer.append("<Value>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Value>");
		}
	}
	if (keepRootTag)
		buffer.append("</FetchResponse>");
}

bool CFetchResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
		hasValue |= m_Value.unmarshall(rpc_request, "Value", basepath);
	}
	return hasValue;
}

bool CFetchResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Value.unmarshall(ctx, soapval, "Value");
	return hasValue;
}

bool CFetchResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Value.unmarshall(ctx, params, attachments, "Value", basepath);
	return hasValue;
}

const char * CFetchResponse::getValue() { return m_Value.query();}
void CFetchResponse::setValue(const char * val){ m_Value.set(val); }
extern "C"  IEspFetchResponse *createFetchResponse(const char *serv){return ((IEspFetchResponse *)new CFetchResponse(serv));}
extern "C"  IClientFetchResponse *createClientFetchResponse(const char *serv){return ((IClientFetchResponse *)new CFetchResponse(serv));}

//=======================================================
// class CFetchAllRequest Implementation
//=======================================================

CFetchAllRequest::CFetchAllRequest(const char *serviceName, IRpcMessageBinding *init)
	: m_StoreName(nilIgnore),m_Namespace(nilIgnore),m_UserSpecific(0, nilIgnore,false)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("FetchAllRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CFetchAllRequest::CFetchAllRequest(const char *serviceName, const char *bc)
	: m_StoreName(nilIgnore),m_Namespace(nilIgnore),m_UserSpecific(0, nilIgnore,false)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("FetchAllRequest");
}

CFetchAllRequest::CFetchAllRequest(const char *serviceName, IRpcMessage* rpcmsg)
	: m_StoreName(nilIgnore),m_Namespace(nilIgnore),m_UserSpecific(0, nilIgnore,false)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("FetchAllRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CFetchAllRequest::CFetchAllRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_StoreName(nilIgnore),m_Namespace(nilIgnore),m_UserSpecific(0, nilIgnore,false)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("FetchAllRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CFetchAllRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"StoreName\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Namespace\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" default=\"false\" name=\"UserSpecific\" type=\"xsd:boolean\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CFetchAllRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CFetchAllRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CFetchAllRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("StoreName");
	form.appendf("  <tr><td><b>StoreName: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Namespace");
	form.appendf("  <tr><td><b>Namespace: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("UserSpecific");
	
	form.appendf("  <tr><td><b>UserSpecific? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CFetchAllRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CFetchAllRequest::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_StoreName.marshall(rpc_resp, "StoreName", "", "", "");
	m_Namespace.marshall(rpc_resp, "Namespace", "", "", "");
	m_UserSpecific.marshall(rpc_resp, "UserSpecific", "", "", "");
}


void CFetchAllRequest::copy(CFetchAllRequest &from)
{
	m_StoreName.copy(from.m_StoreName);
	m_Namespace.copy(from.m_Namespace);
	m_UserSpecific.copy(from.m_UserSpecific);
}


void CFetchAllRequest::copy(IConstFetchAllRequest &ifrom)
{
	setStoreName(ifrom.getStoreName());
	setNamespace(ifrom.getNamespace());
	setUserSpecific(ifrom.getUserSpecific());
}


void CFetchAllRequest::getAttributes(IProperties &attributes)
{
}


void CFetchAllRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_StoreName.toStr(ctx, buffer, "StoreName", "", true, "", "");
	m_Namespace.toStr(ctx, buffer, "Namespace", "", true, "", "");
	m_UserSpecific.toStr(ctx, buffer, "UserSpecific", "", true, "", "");
}


void CFetchAllRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CFetchAllRequest::serializer(IEspContext* ctx, IConstFetchAllRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<FetchAllRequest>");
	// field StoreName
	{
		const char* s = src.getStoreName();
		if (s && *s)
		{
			buffer.append("<StoreName>");
			encodeUtf8XML(s,buffer);
			buffer.append("</StoreName>");
		}
	}
	// field Namespace
	{
		const char* s = src.getNamespace();
		if (s && *s)
		{
			buffer.append("<Namespace>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Namespace>");
		}
	}
	// field UserSpecific
	{
		bool b = src.getUserSpecific();
		if (b)
			buffer.appendf("<UserSpecific>1</UserSpecific>");
	}
	if (keepRootTag)
		buffer.append("</FetchAllRequest>");
}

bool CFetchAllRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_StoreName.unmarshall(rpc_request, "StoreName", basepath);
	hasValue |= m_Namespace.unmarshall(rpc_request, "Namespace", basepath);
	hasValue |= m_UserSpecific.unmarshall(rpc_request, "UserSpecific", basepath);
	return hasValue;
}

bool CFetchAllRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_StoreName.unmarshall(ctx, soapval, "StoreName");
	hasValue |= m_Namespace.unmarshall(ctx, soapval, "Namespace");
	hasValue |= m_UserSpecific.unmarshall(ctx, soapval, "UserSpecific");
	return hasValue;
}

bool CFetchAllRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_StoreName.unmarshall(ctx, params, attachments, "StoreName", basepath);
	hasValue |= m_Namespace.unmarshall(ctx, params, attachments, "Namespace", basepath);
	hasValue |= m_UserSpecific.unmarshall(ctx, params, attachments, "UserSpecific", basepath);
	return hasValue;
}

const char * CFetchAllRequest::getStoreName() { return m_StoreName.query();}
const char * CFetchAllRequest::getNamespace() { return m_Namespace.query();}
bool CFetchAllRequest::getUserSpecific() { return m_UserSpecific;}
void CFetchAllRequest::setStoreName(const char * val){ m_StoreName.set(val); }
void CFetchAllRequest::setNamespace(const char * val){ m_Namespace.set(val); }
void CFetchAllRequest::setUserSpecific(bool val){ m_UserSpecific=val; }
extern "C"  IEspFetchAllRequest *createFetchAllRequest(const char *serv){return ((IEspFetchAllRequest *)new CFetchAllRequest(serv));}
extern "C"  IClientFetchAllRequest *createClientFetchAllRequest(const char *serv){return ((IClientFetchAllRequest *)new CFetchAllRequest(serv));}

//=======================================================
// class CFetchKeyMDRequest Implementation
//=======================================================

CFetchKeyMDRequest::CFetchKeyMDRequest(const char *serviceName, IRpcMessageBinding *init)
	: m_StoreName(nilIgnore),m_Namespace(nilIgnore),m_Key(nilIgnore),m_UserSpecific(0, nilIgnore,false)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("FetchKeyMDRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CFetchKeyMDRequest::CFetchKeyMDRequest(const char *serviceName, const char *bc)
	: m_StoreName(nilIgnore),m_Namespace(nilIgnore),m_Key(nilIgnore),m_UserSpecific(0, nilIgnore,false)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("FetchKeyMDRequest");
}

CFetchKeyMDRequest::CFetchKeyMDRequest(const char *serviceName, IRpcMessage* rpcmsg)
	: m_StoreName(nilIgnore),m_Namespace(nilIgnore),m_Key(nilIgnore),m_UserSpecific(0, nilIgnore,false)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("FetchKeyMDRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CFetchKeyMDRequest::CFetchKeyMDRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_StoreName(nilIgnore),m_Namespace(nilIgnore),m_Key(nilIgnore),m_UserSpecific(0, nilIgnore,false)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("FetchKeyMDRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CFetchKeyMDRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"StoreName\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Namespace\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Key\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" default=\"false\" name=\"UserSpecific\" type=\"xsd:boolean\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CFetchKeyMDRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CFetchKeyMDRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CFetchKeyMDRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("StoreName");
	form.appendf("  <tr><td><b>StoreName: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Namespace");
	form.appendf("  <tr><td><b>Namespace: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Key");
	form.appendf("  <tr><td><b>Key: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("UserSpecific");
	
	form.appendf("  <tr><td><b>UserSpecific? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CFetchKeyMDRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CFetchKeyMDRequest::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_StoreName.marshall(rpc_resp, "StoreName", "", "", "");
	m_Namespace.marshall(rpc_resp, "Namespace", "", "", "");
	m_Key.marshall(rpc_resp, "Key", "", "", "");
	m_UserSpecific.marshall(rpc_resp, "UserSpecific", "", "", "");
}


void CFetchKeyMDRequest::copy(CFetchKeyMDRequest &from)
{
	m_StoreName.copy(from.m_StoreName);
	m_Namespace.copy(from.m_Namespace);
	m_Key.copy(from.m_Key);
	m_UserSpecific.copy(from.m_UserSpecific);
}


void CFetchKeyMDRequest::copy(IConstFetchKeyMDRequest &ifrom)
{
	setStoreName(ifrom.getStoreName());
	setNamespace(ifrom.getNamespace());
	setKey(ifrom.getKey());
	setUserSpecific(ifrom.getUserSpecific());
}


void CFetchKeyMDRequest::getAttributes(IProperties &attributes)
{
}


void CFetchKeyMDRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_StoreName.toStr(ctx, buffer, "StoreName", "", true, "", "");
	m_Namespace.toStr(ctx, buffer, "Namespace", "", true, "", "");
	m_Key.toStr(ctx, buffer, "Key", "", true, "", "");
	m_UserSpecific.toStr(ctx, buffer, "UserSpecific", "", true, "", "");
}


void CFetchKeyMDRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CFetchKeyMDRequest::serializer(IEspContext* ctx, IConstFetchKeyMDRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<FetchKeyMDRequest>");
	// field StoreName
	{
		const char* s = src.getStoreName();
		if (s && *s)
		{
			buffer.append("<StoreName>");
			encodeUtf8XML(s,buffer);
			buffer.append("</StoreName>");
		}
	}
	// field Namespace
	{
		const char* s = src.getNamespace();
		if (s && *s)
		{
			buffer.append("<Namespace>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Namespace>");
		}
	}
	// field Key
	{
		const char* s = src.getKey();
		if (s && *s)
		{
			buffer.append("<Key>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Key>");
		}
	}
	// field UserSpecific
	{
		bool b = src.getUserSpecific();
		if (b)
			buffer.appendf("<UserSpecific>1</UserSpecific>");
	}
	if (keepRootTag)
		buffer.append("</FetchKeyMDRequest>");
}

bool CFetchKeyMDRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_StoreName.unmarshall(rpc_request, "StoreName", basepath);
	hasValue |= m_Namespace.unmarshall(rpc_request, "Namespace", basepath);
	hasValue |= m_Key.unmarshall(rpc_request, "Key", basepath);
	hasValue |= m_UserSpecific.unmarshall(rpc_request, "UserSpecific", basepath);
	return hasValue;
}

bool CFetchKeyMDRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_StoreName.unmarshall(ctx, soapval, "StoreName");
	hasValue |= m_Namespace.unmarshall(ctx, soapval, "Namespace");
	hasValue |= m_Key.unmarshall(ctx, soapval, "Key");
	hasValue |= m_UserSpecific.unmarshall(ctx, soapval, "UserSpecific");
	return hasValue;
}

bool CFetchKeyMDRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_StoreName.unmarshall(ctx, params, attachments, "StoreName", basepath);
	hasValue |= m_Namespace.unmarshall(ctx, params, attachments, "Namespace", basepath);
	hasValue |= m_Key.unmarshall(ctx, params, attachments, "Key", basepath);
	hasValue |= m_UserSpecific.unmarshall(ctx, params, attachments, "UserSpecific", basepath);
	return hasValue;
}

const char * CFetchKeyMDRequest::getStoreName() { return m_StoreName.query();}
const char * CFetchKeyMDRequest::getNamespace() { return m_Namespace.query();}
const char * CFetchKeyMDRequest::getKey() { return m_Key.query();}
bool CFetchKeyMDRequest::getUserSpecific() { return m_UserSpecific;}
void CFetchKeyMDRequest::setStoreName(const char * val){ m_StoreName.set(val); }
void CFetchKeyMDRequest::setNamespace(const char * val){ m_Namespace.set(val); }
void CFetchKeyMDRequest::setKey(const char * val){ m_Key.set(val); }
void CFetchKeyMDRequest::setUserSpecific(bool val){ m_UserSpecific=val; }
extern "C"  IEspFetchKeyMDRequest *createFetchKeyMDRequest(const char *serv){return ((IEspFetchKeyMDRequest *)new CFetchKeyMDRequest(serv));}
extern "C"  IClientFetchKeyMDRequest *createClientFetchKeyMDRequest(const char *serv){return ((IClientFetchKeyMDRequest *)new CFetchKeyMDRequest(serv));}

//=======================================================
// class CFetchKeyMDResponse Implementation
//=======================================================

CFetchKeyMDResponse::CFetchKeyMDResponse(const char *serviceName, IRpcMessageBinding *init)
	: m_StoreName(nilIgnore),m_Namespace(nilIgnore),m_Key(nilIgnore),m_Pairs(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("FetchKeyMDResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CFetchKeyMDResponse::CFetchKeyMDResponse(const char *serviceName, const char *bc)
	: m_StoreName(nilIgnore),m_Namespace(nilIgnore),m_Key(nilIgnore),m_Pairs(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("FetchKeyMDResponse");
}

CFetchKeyMDResponse::CFetchKeyMDResponse(const char *serviceName, IRpcMessage* rpcmsg)
	: m_StoreName(nilIgnore),m_Namespace(nilIgnore),m_Key(nilIgnore),m_Pairs(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("FetchKeyMDResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CFetchKeyMDResponse::CFetchKeyMDResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_StoreName(nilIgnore),m_Namespace(nilIgnore),m_Key(nilIgnore),m_Pairs(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("FetchKeyMDResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CFetchKeyMDResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		schema.append("<xsd:element name=\"Exceptions\" type=\"tns:ArrayOfEspException\" minOccurs=\"0\" maxOccurs=\"1\"/>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"StoreName\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Namespace\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Key\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Pairs\">\n");
		schema.append("<xsd:complexType><xsd:sequence>\n");
		schema.append("<xsd:element minOccurs=\"0\" maxOccurs=\"unbounded\" name=\"Pair\" type=\"tns:KVPair\"/>");
		schema.append("</xsd:sequence></xsd:complexType>");
		schema.append("</xsd:element>");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	if (!(flags & 0x10)  || (flags & 0x100))
	{
		CKVPair::getXsdDefinition(context, request, schema, added);
	}
	return schema;
}

void CFetchKeyMDResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CFetchKeyMDResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
	if (!added.getValue("KVPair"))
	{
		added.setValue("KVPair",1);
		CKVPair::getMapInfo(info,added);
	}
}

StringBuffer &CFetchKeyMDResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("StoreName");
	form.appendf("  <tr><td><b>StoreName: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Namespace");
	form.appendf("  <tr><td><b>Namespace: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Key");
	form.appendf("  <tr><td><b>Key: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Pairs");
	form.appendf("<tr><td><b>Pairs: </b></td><td>");
	form.appendf("<table><tr><td><textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea></td>", extfix.str());
	form.append("</tr></table>");
	form.append("</td></tr>");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CFetchKeyMDResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CFetchKeyMDResponse::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
		m_StoreName.marshall(rpc_resp, "StoreName", "", "", "");
		m_Namespace.marshall(rpc_resp, "Namespace", "", "", "");
		m_Key.marshall(rpc_resp, "Key", "", "", "");
		m_Pairs.marshall(rpc_resp, "Pairs", "Pair");
	}
}


void CFetchKeyMDResponse::copy(CFetchKeyMDResponse &from)
{
	m_StoreName.copy(from.m_StoreName);
	m_Namespace.copy(from.m_Namespace);
	m_Key.copy(from.m_Key);
	m_Pairs.copy(from.m_Pairs);
}


void CFetchKeyMDResponse::copy(IConstFetchKeyMDResponse &ifrom)
{
	setStoreName(ifrom.getStoreName());
	setNamespace(ifrom.getNamespace());
	setKey(ifrom.getKey());
	setPairs(ifrom.getPairs());
}


void CFetchKeyMDResponse::getAttributes(IProperties &attributes)
{
}


void CFetchKeyMDResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
		m_StoreName.toStr(ctx, buffer, "StoreName", "", true, "", "");
		m_Namespace.toStr(ctx, buffer, "Namespace", "", true, "", "");
		m_Key.toStr(ctx, buffer, "Key", "", true, "", "");
		m_Pairs.toStr(ctx, buffer, "Pairs", "Pair");
	}
}


void CFetchKeyMDResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CFetchKeyMDResponse::serializer(IEspContext* ctx, IConstFetchKeyMDResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<FetchKeyMDResponse>");
	// field StoreName
	{
		const char* s = src.getStoreName();
		if (s && *s)
		{
			buffer.append("<StoreName>");
			encodeUtf8XML(s,buffer);
			buffer.append("</StoreName>");
		}
	}
	// field Namespace
	{
		const char* s = src.getNamespace();
		if (s && *s)
		{
			buffer.append("<Namespace>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Namespace>");
		}
	}
	// field Key
	{
		const char* s = src.getKey();
		if (s && *s)
		{
			buffer.append("<Key>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Key>");
		}
	}
	// field Pairs
	{
		IArrayOf<IConstKVPair>& v = src.getPairs();
		int size = v.length();
		if (size>0)
			buffer.append("<Pairs>");
		for (int i=0;i<size;i++)
		{
			buffer.append("<Pair>");
			CKVPair::serializer(ctx,v.item(i),buffer,false);
			buffer.append("</Pair>");
		}
		if (size>0)
			buffer.append("</Pairs>");
	}
	if (keepRootTag)
		buffer.append("</FetchKeyMDResponse>");
}

bool CFetchKeyMDResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
		hasValue |= m_StoreName.unmarshall(rpc_request, "StoreName", basepath);
		hasValue |= m_Namespace.unmarshall(rpc_request, "Namespace", basepath);
		hasValue |= m_Key.unmarshall(rpc_request, "Key", basepath);
		hasValue |= m_Pairs.unmarshall(rpc_request, "Pairs", basepath);
	}
	return hasValue;
}

bool CFetchKeyMDResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_StoreName.unmarshall(ctx, soapval, "StoreName");
	hasValue |= m_Namespace.unmarshall(ctx, soapval, "Namespace");
	hasValue |= m_Key.unmarshall(ctx, soapval, "Key");
	hasValue |= m_Pairs.unmarshall(ctx, soapval, "Pairs");
	return hasValue;
}

bool CFetchKeyMDResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_StoreName.unmarshall(ctx, params, attachments, "StoreName", basepath);
	hasValue |= m_Namespace.unmarshall(ctx, params, attachments, "Namespace", basepath);
	hasValue |= m_Key.unmarshall(ctx, params, attachments, "Key", basepath);
	hasValue |= m_Pairs.unmarshall(ctx, params, attachments, "Pairs", basepath);
	return hasValue;
}

const char * CFetchKeyMDResponse::getStoreName() { return m_StoreName.query();}
const char * CFetchKeyMDResponse::getNamespace() { return m_Namespace.query();}
const char * CFetchKeyMDResponse::getKey() { return m_Key.query();}
IArrayOf<IConstKVPair> & CFetchKeyMDResponse::getPairs() { return (IArrayOf<IConstKVPair> &) m_Pairs; }
void CFetchKeyMDResponse::setStoreName(const char * val){ m_StoreName.set(val); }
void CFetchKeyMDResponse::setNamespace(const char * val){ m_Namespace.set(val); }
void CFetchKeyMDResponse::setKey(const char * val){ m_Key.set(val); }
void CFetchKeyMDResponse::setPairs(IArrayOf<IEspKVPair> &val)
{
	m_Pairs->kill();
	IArrayOf<IConstKVPair> &target = m_Pairs.getValue();
	ForEachItemIn(idx, val)
	{
		IEspKVPair &item = (val).item(idx);
		item.Link();
		target.append(item);
	}
}
void CFetchKeyMDResponse::setPairs(IArrayOf<IConstKVPair> &val)
{
	m_Pairs->kill();
	IArrayOf<IConstKVPair> &target = m_Pairs.getValue();
	ForEachItemIn(idx, val)
	{
		IConstKVPair &item = val.item(idx);
		item.Link();
		target.append(item);
	}
}
extern "C"  IEspFetchKeyMDResponse *createFetchKeyMDResponse(const char *serv){return ((IEspFetchKeyMDResponse *)new CFetchKeyMDResponse(serv));}
extern "C"  IClientFetchKeyMDResponse *createClientFetchKeyMDResponse(const char *serv){return ((IClientFetchKeyMDResponse *)new CFetchKeyMDResponse(serv));}

//=======================================================
// class CFetchAllResponse Implementation
//=======================================================

CFetchAllResponse::CFetchAllResponse(const char *serviceName, IRpcMessageBinding *init)
	: m_Namespace(nilIgnore),m_Pairs(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("FetchAllResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CFetchAllResponse::CFetchAllResponse(const char *serviceName, const char *bc)
	: m_Namespace(nilIgnore),m_Pairs(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("FetchAllResponse");
}

CFetchAllResponse::CFetchAllResponse(const char *serviceName, IRpcMessage* rpcmsg)
	: m_Namespace(nilIgnore),m_Pairs(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("FetchAllResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CFetchAllResponse::CFetchAllResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_Namespace(nilIgnore),m_Pairs(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("FetchAllResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CFetchAllResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		schema.append("<xsd:element name=\"Exceptions\" type=\"tns:ArrayOfEspException\" minOccurs=\"0\" maxOccurs=\"1\"/>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Namespace\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Pairs\">\n");
		schema.append("<xsd:complexType><xsd:sequence>\n");
		schema.append("<xsd:element minOccurs=\"0\" maxOccurs=\"unbounded\" name=\"Pair\" type=\"tns:KVPair\"/>");
		schema.append("</xsd:sequence></xsd:complexType>");
		schema.append("</xsd:element>");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	if (!(flags & 0x10)  || (flags & 0x100))
	{
		CKVPair::getXsdDefinition(context, request, schema, added);
	}
	return schema;
}

void CFetchAllResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CFetchAllResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
	if (!added.getValue("KVPair"))
	{
		added.setValue("KVPair",1);
		CKVPair::getMapInfo(info,added);
	}
}

StringBuffer &CFetchAllResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Namespace");
	form.appendf("  <tr><td><b>Namespace: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Pairs");
	form.appendf("<tr><td><b>Pairs: </b></td><td>");
	form.appendf("<table><tr><td><textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea></td>", extfix.str());
	form.append("</tr></table>");
	form.append("</td></tr>");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CFetchAllResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CFetchAllResponse::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
		m_Namespace.marshall(rpc_resp, "Namespace", "", "", "");
		m_Pairs.marshall(rpc_resp, "Pairs", "Pair");
	}
}


void CFetchAllResponse::copy(CFetchAllResponse &from)
{
	m_Namespace.copy(from.m_Namespace);
	m_Pairs.copy(from.m_Pairs);
}


void CFetchAllResponse::copy(IConstFetchAllResponse &ifrom)
{
	setNamespace(ifrom.getNamespace());
	setPairs(ifrom.getPairs());
}


void CFetchAllResponse::getAttributes(IProperties &attributes)
{
}


void CFetchAllResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
		m_Namespace.toStr(ctx, buffer, "Namespace", "", true, "", "");
		m_Pairs.toStr(ctx, buffer, "Pairs", "Pair");
	}
}


void CFetchAllResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CFetchAllResponse::serializer(IEspContext* ctx, IConstFetchAllResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<FetchAllResponse>");
	// field Namespace
	{
		const char* s = src.getNamespace();
		if (s && *s)
		{
			buffer.append("<Namespace>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Namespace>");
		}
	}
	// field Pairs
	{
		IArrayOf<IConstKVPair>& v = src.getPairs();
		int size = v.length();
		if (size>0)
			buffer.append("<Pairs>");
		for (int i=0;i<size;i++)
		{
			buffer.append("<Pair>");
			CKVPair::serializer(ctx,v.item(i),buffer,false);
			buffer.append("</Pair>");
		}
		if (size>0)
			buffer.append("</Pairs>");
	}
	if (keepRootTag)
		buffer.append("</FetchAllResponse>");
}

bool CFetchAllResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
		hasValue |= m_Namespace.unmarshall(rpc_request, "Namespace", basepath);
		hasValue |= m_Pairs.unmarshall(rpc_request, "Pairs", basepath);
	}
	return hasValue;
}

bool CFetchAllResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Namespace.unmarshall(ctx, soapval, "Namespace");
	hasValue |= m_Pairs.unmarshall(ctx, soapval, "Pairs");
	return hasValue;
}

bool CFetchAllResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Namespace.unmarshall(ctx, params, attachments, "Namespace", basepath);
	hasValue |= m_Pairs.unmarshall(ctx, params, attachments, "Pairs", basepath);
	return hasValue;
}

const char * CFetchAllResponse::getNamespace() { return m_Namespace.query();}
IArrayOf<IConstKVPair> & CFetchAllResponse::getPairs() { return (IArrayOf<IConstKVPair> &) m_Pairs; }
void CFetchAllResponse::setNamespace(const char * val){ m_Namespace.set(val); }
void CFetchAllResponse::setPairs(IArrayOf<IEspKVPair> &val)
{
	m_Pairs->kill();
	IArrayOf<IConstKVPair> &target = m_Pairs.getValue();
	ForEachItemIn(idx, val)
	{
		IEspKVPair &item = (val).item(idx);
		item.Link();
		target.append(item);
	}
}
void CFetchAllResponse::setPairs(IArrayOf<IConstKVPair> &val)
{
	m_Pairs->kill();
	IArrayOf<IConstKVPair> &target = m_Pairs.getValue();
	ForEachItemIn(idx, val)
	{
		IConstKVPair &item = val.item(idx);
		item.Link();
		target.append(item);
	}
}
extern "C"  IEspFetchAllResponse *createFetchAllResponse(const char *serv){return ((IEspFetchAllResponse *)new CFetchAllResponse(serv));}
extern "C"  IClientFetchAllResponse *createClientFetchAllResponse(const char *serv){return ((IClientFetchAllResponse *)new CFetchAllResponse(serv));}

//=======================================================
// class CSetRequest Implementation
//=======================================================

CSetRequest::CSetRequest(const char *serviceName, IRpcMessageBinding *init)
	: m_StoreName(nilIgnore),m_Namespace(nilIgnore),m_Key(nilIgnore),m_Value(nilIgnore),m_UserSpecific(0, nilIgnore,false)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("SetRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CSetRequest::CSetRequest(const char *serviceName, const char *bc)
	: m_StoreName(nilIgnore),m_Namespace(nilIgnore),m_Key(nilIgnore),m_Value(nilIgnore),m_UserSpecific(0, nilIgnore,false)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("SetRequest");
}

CSetRequest::CSetRequest(const char *serviceName, IRpcMessage* rpcmsg)
	: m_StoreName(nilIgnore),m_Namespace(nilIgnore),m_Key(nilIgnore),m_Value(nilIgnore),m_UserSpecific(0, nilIgnore,false)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("SetRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CSetRequest::CSetRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_StoreName(nilIgnore),m_Namespace(nilIgnore),m_Key(nilIgnore),m_Value(nilIgnore),m_UserSpecific(0, nilIgnore,false)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("SetRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CSetRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"StoreName\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Namespace\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Key\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Value\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" default=\"false\" name=\"UserSpecific\" type=\"xsd:boolean\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CSetRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CSetRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CSetRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("StoreName");
	form.appendf("  <tr><td><b>StoreName: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Namespace");
	form.appendf("  <tr><td><b>Namespace: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Key");
	form.appendf("  <tr><td><b>Key: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Value");
	form.appendf("  <tr><td><b>Value: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("UserSpecific");
	
	form.appendf("  <tr><td><b>UserSpecific? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CSetRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CSetRequest::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_StoreName.marshall(rpc_resp, "StoreName", "", "", "");
	m_Namespace.marshall(rpc_resp, "Namespace", "", "", "");
	m_Key.marshall(rpc_resp, "Key", "", "", "");
	m_Value.marshall(rpc_resp, "Value", "", "", "");
	m_UserSpecific.marshall(rpc_resp, "UserSpecific", "", "", "");
}


void CSetRequest::copy(CSetRequest &from)
{
	m_StoreName.copy(from.m_StoreName);
	m_Namespace.copy(from.m_Namespace);
	m_Key.copy(from.m_Key);
	m_Value.copy(from.m_Value);
	m_UserSpecific.copy(from.m_UserSpecific);
}


void CSetRequest::copy(IConstSetRequest &ifrom)
{
	setStoreName(ifrom.getStoreName());
	setNamespace(ifrom.getNamespace());
	setKey(ifrom.getKey());
	setValue(ifrom.getValue());
	setUserSpecific(ifrom.getUserSpecific());
}


void CSetRequest::getAttributes(IProperties &attributes)
{
}


void CSetRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_StoreName.toStr(ctx, buffer, "StoreName", "", true, "", "");
	m_Namespace.toStr(ctx, buffer, "Namespace", "", true, "", "");
	m_Key.toStr(ctx, buffer, "Key", "", true, "", "");
	m_Value.toStr(ctx, buffer, "Value", "", true, "", "");
	m_UserSpecific.toStr(ctx, buffer, "UserSpecific", "", true, "", "");
}


void CSetRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CSetRequest::serializer(IEspContext* ctx, IConstSetRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<SetRequest>");
	// field StoreName
	{
		const char* s = src.getStoreName();
		if (s && *s)
		{
			buffer.append("<StoreName>");
			encodeUtf8XML(s,buffer);
			buffer.append("</StoreName>");
		}
	}
	// field Namespace
	{
		const char* s = src.getNamespace();
		if (s && *s)
		{
			buffer.append("<Namespace>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Namespace>");
		}
	}
	// field Key
	{
		const char* s = src.getKey();
		if (s && *s)
		{
			buffer.append("<Key>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Key>");
		}
	}
	// field Value
	{
		const char* s = src.getValue();
		if (s && *s)
		{
			buffer.append("<Value>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Value>");
		}
	}
	// field UserSpecific
	{
		bool b = src.getUserSpecific();
		if (b)
			buffer.appendf("<UserSpecific>1</UserSpecific>");
	}
	if (keepRootTag)
		buffer.append("</SetRequest>");
}

bool CSetRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_StoreName.unmarshall(rpc_request, "StoreName", basepath);
	hasValue |= m_Namespace.unmarshall(rpc_request, "Namespace", basepath);
	hasValue |= m_Key.unmarshall(rpc_request, "Key", basepath);
	hasValue |= m_Value.unmarshall(rpc_request, "Value", basepath);
	hasValue |= m_UserSpecific.unmarshall(rpc_request, "UserSpecific", basepath);
	return hasValue;
}

bool CSetRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_StoreName.unmarshall(ctx, soapval, "StoreName");
	hasValue |= m_Namespace.unmarshall(ctx, soapval, "Namespace");
	hasValue |= m_Key.unmarshall(ctx, soapval, "Key");
	hasValue |= m_Value.unmarshall(ctx, soapval, "Value");
	hasValue |= m_UserSpecific.unmarshall(ctx, soapval, "UserSpecific");
	return hasValue;
}

bool CSetRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_StoreName.unmarshall(ctx, params, attachments, "StoreName", basepath);
	hasValue |= m_Namespace.unmarshall(ctx, params, attachments, "Namespace", basepath);
	hasValue |= m_Key.unmarshall(ctx, params, attachments, "Key", basepath);
	hasValue |= m_Value.unmarshall(ctx, params, attachments, "Value", basepath);
	hasValue |= m_UserSpecific.unmarshall(ctx, params, attachments, "UserSpecific", basepath);
	return hasValue;
}

const char * CSetRequest::getStoreName() { return m_StoreName.query();}
const char * CSetRequest::getNamespace() { return m_Namespace.query();}
const char * CSetRequest::getKey() { return m_Key.query();}
const char * CSetRequest::getValue() { return m_Value.query();}
bool CSetRequest::getUserSpecific() { return m_UserSpecific;}
void CSetRequest::setStoreName(const char * val){ m_StoreName.set(val); }
void CSetRequest::setNamespace(const char * val){ m_Namespace.set(val); }
void CSetRequest::setKey(const char * val){ m_Key.set(val); }
void CSetRequest::setValue(const char * val){ m_Value.set(val); }
void CSetRequest::setUserSpecific(bool val){ m_UserSpecific=val; }
extern "C"  IEspSetRequest *createSetRequest(const char *serv){return ((IEspSetRequest *)new CSetRequest(serv));}
extern "C"  IClientSetRequest *createClientSetRequest(const char *serv){return ((IClientSetRequest *)new CSetRequest(serv));}

//=======================================================
// class CSetResponse Implementation
//=======================================================

CSetResponse::CSetResponse(const char *serviceName, IRpcMessageBinding *init)
	: m_Success(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("SetResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CSetResponse::CSetResponse(const char *serviceName, const char *bc)
	: m_Success(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("SetResponse");
}

CSetResponse::CSetResponse(const char *serviceName, IRpcMessage* rpcmsg)
	: m_Success(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("SetResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CSetResponse::CSetResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_Success(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("SetResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CSetResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		schema.append("<xsd:element name=\"Exceptions\" type=\"tns:ArrayOfEspException\" minOccurs=\"0\" maxOccurs=\"1\"/>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Success\" type=\"xsd:boolean\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CSetResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CSetResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CSetResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Success");
	
	form.appendf("  <tr><td><b>Success? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CSetResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CSetResponse::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
		m_Success.marshall(rpc_resp, "Success", "", "", "");
	}
}


void CSetResponse::copy(CSetResponse &from)
{
	m_Success.copy(from.m_Success);
}


void CSetResponse::copy(IConstSetResponse &ifrom)
{
	setSuccess(ifrom.getSuccess());
}


void CSetResponse::getAttributes(IProperties &attributes)
{
}


void CSetResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
		m_Success.toStr(ctx, buffer, "Success", "", true, "", "");
	}
}


void CSetResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CSetResponse::serializer(IEspContext* ctx, IConstSetResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<SetResponse>");
	// field Success
	{
		bool b = src.getSuccess();
		if (b)
			buffer.appendf("<Success>1</Success>");
	}
	if (keepRootTag)
		buffer.append("</SetResponse>");
}

bool CSetResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
		hasValue |= m_Success.unmarshall(rpc_request, "Success", basepath);
	}
	return hasValue;
}

bool CSetResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Success.unmarshall(ctx, soapval, "Success");
	return hasValue;
}

bool CSetResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Success.unmarshall(ctx, params, attachments, "Success", basepath);
	return hasValue;
}

bool CSetResponse::getSuccess() { return m_Success;}
void CSetResponse::setSuccess(bool val){ m_Success=val; }
extern "C"  IEspSetResponse *createSetResponse(const char *serv){return ((IEspSetResponse *)new CSetResponse(serv));}
extern "C"  IClientSetResponse *createClientSetResponse(const char *serv){return ((IClientSetResponse *)new CSetResponse(serv));}

//=======================================================
// class CCreateStoreRequest Implementation
//=======================================================

CCreateStoreRequest::CCreateStoreRequest(const char *serviceName, IRpcMessageBinding *init)
	: m_Name(nilIgnore),m_Type(nilIgnore),m_Description(nilIgnore),m_UserSpecific(0, nilIgnore,false)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("CreateStoreRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CCreateStoreRequest::CCreateStoreRequest(const char *serviceName, const char *bc)
	: m_Name(nilIgnore),m_Type(nilIgnore),m_Description(nilIgnore),m_UserSpecific(0, nilIgnore,false)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("CreateStoreRequest");
}

CCreateStoreRequest::CCreateStoreRequest(const char *serviceName, IRpcMessage* rpcmsg)
	: m_Name(nilIgnore),m_Type(nilIgnore),m_Description(nilIgnore),m_UserSpecific(0, nilIgnore,false)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("CreateStoreRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CCreateStoreRequest::CCreateStoreRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_Name(nilIgnore),m_Type(nilIgnore),m_Description(nilIgnore),m_UserSpecific(0, nilIgnore,false)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("CreateStoreRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CCreateStoreRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Name\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Type\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Description\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" default=\"false\" name=\"UserSpecific\" type=\"xsd:boolean\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CCreateStoreRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CCreateStoreRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CCreateStoreRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Name");
	form.appendf("  <tr><td><b>Name: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Type");
	form.appendf("  <tr><td><b>Type: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Description");
	form.appendf("  <tr><td><b>Description: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("UserSpecific");
	
	form.appendf("  <tr><td><b>UserSpecific? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CCreateStoreRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CCreateStoreRequest::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_Name.marshall(rpc_resp, "Name", "", "", "");
	m_Type.marshall(rpc_resp, "Type", "", "", "");
	m_Description.marshall(rpc_resp, "Description", "", "", "");
	m_UserSpecific.marshall(rpc_resp, "UserSpecific", "", "", "");
}


void CCreateStoreRequest::copy(CCreateStoreRequest &from)
{
	m_Name.copy(from.m_Name);
	m_Type.copy(from.m_Type);
	m_Description.copy(from.m_Description);
	m_UserSpecific.copy(from.m_UserSpecific);
}


void CCreateStoreRequest::copy(IConstCreateStoreRequest &ifrom)
{
	setName(ifrom.getName());
	setType(ifrom.getType());
	setDescription(ifrom.getDescription());
	setUserSpecific(ifrom.getUserSpecific());
}


void CCreateStoreRequest::getAttributes(IProperties &attributes)
{
}


void CCreateStoreRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_Name.toStr(ctx, buffer, "Name", "", true, "", "");
	m_Type.toStr(ctx, buffer, "Type", "", true, "", "");
	m_Description.toStr(ctx, buffer, "Description", "", true, "", "");
	m_UserSpecific.toStr(ctx, buffer, "UserSpecific", "", true, "", "");
}


void CCreateStoreRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CCreateStoreRequest::serializer(IEspContext* ctx, IConstCreateStoreRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<CreateStoreRequest>");
	// field Name
	{
		const char* s = src.getName();
		if (s && *s)
		{
			buffer.append("<Name>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Name>");
		}
	}
	// field Type
	{
		const char* s = src.getType();
		if (s && *s)
		{
			buffer.append("<Type>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Type>");
		}
	}
	// field Description
	{
		const char* s = src.getDescription();
		if (s && *s)
		{
			buffer.append("<Description>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Description>");
		}
	}
	// field UserSpecific
	{
		bool b = src.getUserSpecific();
		if (b)
			buffer.appendf("<UserSpecific>1</UserSpecific>");
	}
	if (keepRootTag)
		buffer.append("</CreateStoreRequest>");
}

bool CCreateStoreRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_Name.unmarshall(rpc_request, "Name", basepath);
	hasValue |= m_Type.unmarshall(rpc_request, "Type", basepath);
	hasValue |= m_Description.unmarshall(rpc_request, "Description", basepath);
	hasValue |= m_UserSpecific.unmarshall(rpc_request, "UserSpecific", basepath);
	return hasValue;
}

bool CCreateStoreRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Name.unmarshall(ctx, soapval, "Name");
	hasValue |= m_Type.unmarshall(ctx, soapval, "Type");
	hasValue |= m_Description.unmarshall(ctx, soapval, "Description");
	hasValue |= m_UserSpecific.unmarshall(ctx, soapval, "UserSpecific");
	return hasValue;
}

bool CCreateStoreRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Name.unmarshall(ctx, params, attachments, "Name", basepath);
	hasValue |= m_Type.unmarshall(ctx, params, attachments, "Type", basepath);
	hasValue |= m_Description.unmarshall(ctx, params, attachments, "Description", basepath);
	hasValue |= m_UserSpecific.unmarshall(ctx, params, attachments, "UserSpecific", basepath);
	return hasValue;
}

const char * CCreateStoreRequest::getName() { return m_Name.query();}
const char * CCreateStoreRequest::getType() { return m_Type.query();}
const char * CCreateStoreRequest::getDescription() { return m_Description.query();}
bool CCreateStoreRequest::getUserSpecific() { return m_UserSpecific;}
void CCreateStoreRequest::setName(const char * val){ m_Name.set(val); }
void CCreateStoreRequest::setType(const char * val){ m_Type.set(val); }
void CCreateStoreRequest::setDescription(const char * val){ m_Description.set(val); }
void CCreateStoreRequest::setUserSpecific(bool val){ m_UserSpecific=val; }
extern "C"  IEspCreateStoreRequest *createCreateStoreRequest(const char *serv){return ((IEspCreateStoreRequest *)new CCreateStoreRequest(serv));}
extern "C"  IClientCreateStoreRequest *createClientCreateStoreRequest(const char *serv){return ((IClientCreateStoreRequest *)new CCreateStoreRequest(serv));}

//=======================================================
// class CCreateStoreResponse Implementation
//=======================================================

CCreateStoreResponse::CCreateStoreResponse(const char *serviceName, IRpcMessageBinding *init)
	: m_Name(nilIgnore),m_Type(nilIgnore),m_Description(nilIgnore),m_Owner(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("CreateStoreResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CCreateStoreResponse::CCreateStoreResponse(const char *serviceName, const char *bc)
	: m_Name(nilIgnore),m_Type(nilIgnore),m_Description(nilIgnore),m_Owner(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("CreateStoreResponse");
}

CCreateStoreResponse::CCreateStoreResponse(const char *serviceName, IRpcMessage* rpcmsg)
	: m_Name(nilIgnore),m_Type(nilIgnore),m_Description(nilIgnore),m_Owner(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("CreateStoreResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CCreateStoreResponse::CCreateStoreResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_Name(nilIgnore),m_Type(nilIgnore),m_Description(nilIgnore),m_Owner(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("CreateStoreResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CCreateStoreResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		schema.append("<xsd:element name=\"Exceptions\" type=\"tns:ArrayOfEspException\" minOccurs=\"0\" maxOccurs=\"1\"/>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Name\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Type\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Description\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Owner\" type=\"xsd:string\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CCreateStoreResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CCreateStoreResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CCreateStoreResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Name");
	form.appendf("  <tr><td><b>Name: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Type");
	form.appendf("  <tr><td><b>Type: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Description");
	form.appendf("  <tr><td><b>Description: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Owner");
	form.appendf("  <tr><td><b>Owner: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CCreateStoreResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CCreateStoreResponse::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
		m_Name.marshall(rpc_resp, "Name", "", "", "");
		m_Type.marshall(rpc_resp, "Type", "", "", "");
		m_Description.marshall(rpc_resp, "Description", "", "", "");
		m_Owner.marshall(rpc_resp, "Owner", "", "", "");
	}
}


void CCreateStoreResponse::copy(CCreateStoreResponse &from)
{
	m_Name.copy(from.m_Name);
	m_Type.copy(from.m_Type);
	m_Description.copy(from.m_Description);
	m_Owner.copy(from.m_Owner);
}


void CCreateStoreResponse::copy(IConstCreateStoreResponse &ifrom)
{
	setName(ifrom.getName());
	setType(ifrom.getType());
	setDescription(ifrom.getDescription());
	setOwner(ifrom.getOwner());
}


void CCreateStoreResponse::getAttributes(IProperties &attributes)
{
}


void CCreateStoreResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
		m_Name.toStr(ctx, buffer, "Name", "", true, "", "");
		m_Type.toStr(ctx, buffer, "Type", "", true, "", "");
		m_Description.toStr(ctx, buffer, "Description", "", true, "", "");
		m_Owner.toStr(ctx, buffer, "Owner", "", true, "", "");
	}
}


void CCreateStoreResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CCreateStoreResponse::serializer(IEspContext* ctx, IConstCreateStoreResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<CreateStoreResponse>");
	// field Name
	{
		const char* s = src.getName();
		if (s && *s)
		{
			buffer.append("<Name>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Name>");
		}
	}
	// field Type
	{
		const char* s = src.getType();
		if (s && *s)
		{
			buffer.append("<Type>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Type>");
		}
	}
	// field Description
	{
		const char* s = src.getDescription();
		if (s && *s)
		{
			buffer.append("<Description>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Description>");
		}
	}
	// field Owner
	{
		const char* s = src.getOwner();
		if (s && *s)
		{
			buffer.append("<Owner>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Owner>");
		}
	}
	if (keepRootTag)
		buffer.append("</CreateStoreResponse>");
}

bool CCreateStoreResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
		hasValue |= m_Name.unmarshall(rpc_request, "Name", basepath);
		hasValue |= m_Type.unmarshall(rpc_request, "Type", basepath);
		hasValue |= m_Description.unmarshall(rpc_request, "Description", basepath);
		hasValue |= m_Owner.unmarshall(rpc_request, "Owner", basepath);
	}
	return hasValue;
}

bool CCreateStoreResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Name.unmarshall(ctx, soapval, "Name");
	hasValue |= m_Type.unmarshall(ctx, soapval, "Type");
	hasValue |= m_Description.unmarshall(ctx, soapval, "Description");
	hasValue |= m_Owner.unmarshall(ctx, soapval, "Owner");
	return hasValue;
}

bool CCreateStoreResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Name.unmarshall(ctx, params, attachments, "Name", basepath);
	hasValue |= m_Type.unmarshall(ctx, params, attachments, "Type", basepath);
	hasValue |= m_Description.unmarshall(ctx, params, attachments, "Description", basepath);
	hasValue |= m_Owner.unmarshall(ctx, params, attachments, "Owner", basepath);
	return hasValue;
}

const char * CCreateStoreResponse::getName() { return m_Name.query();}
const char * CCreateStoreResponse::getType() { return m_Type.query();}
const char * CCreateStoreResponse::getDescription() { return m_Description.query();}
const char * CCreateStoreResponse::getOwner() { return m_Owner.query();}
void CCreateStoreResponse::setName(const char * val){ m_Name.set(val); }
void CCreateStoreResponse::setType(const char * val){ m_Type.set(val); }
void CCreateStoreResponse::setDescription(const char * val){ m_Description.set(val); }
void CCreateStoreResponse::setOwner(const char * val){ m_Owner.set(val); }
extern "C"  IEspCreateStoreResponse *createCreateStoreResponse(const char *serv){return ((IEspCreateStoreResponse *)new CCreateStoreResponse(serv));}
extern "C"  IClientCreateStoreResponse *createClientCreateStoreResponse(const char *serv){return ((IClientCreateStoreResponse *)new CCreateStoreResponse(serv));}

//=======================================================
// class CwsstorePingRequest Implementation
//=======================================================

CwsstorePingRequest::CwsstorePingRequest(const char *serviceName, IRpcMessageBinding *init)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("wsstorePingRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CwsstorePingRequest::CwsstorePingRequest(const char *serviceName, const char *bc)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("wsstorePingRequest");
}

CwsstorePingRequest::CwsstorePingRequest(const char *serviceName, IRpcMessage* rpcmsg)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("wsstorePingRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CwsstorePingRequest::CwsstorePingRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("wsstorePingRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CwsstorePingRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType><xsd:all/></xsd:complexType></xsd:element>\n", msgTypeName);
		}
	}
	return schema;
}

void CwsstorePingRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CwsstorePingRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CwsstorePingRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CwsstorePingRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CwsstorePingRequest::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

}


void CwsstorePingRequest::copy(CwsstorePingRequest &from)
{
}


void CwsstorePingRequest::copy(IConstwsstorePingRequest &ifrom)
{
}


void CwsstorePingRequest::getAttributes(IProperties &attributes)
{
}


void CwsstorePingRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
}


void CwsstorePingRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CwsstorePingRequest::serializer(IEspContext* ctx, IConstwsstorePingRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<wsstorePingRequest>");
	if (keepRootTag)
		buffer.append("</wsstorePingRequest>");
}

bool CwsstorePingRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	return hasValue;
}

bool CwsstorePingRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	return hasValue;
}

bool CwsstorePingRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	return hasValue;
}

extern "C"  IEspwsstorePingRequest *createwsstorePingRequest(const char *serv){return ((IEspwsstorePingRequest *)new CwsstorePingRequest(serv));}
extern "C"  IClientwsstorePingRequest *createClientwsstorePingRequest(const char *serv){return ((IClientwsstorePingRequest *)new CwsstorePingRequest(serv));}

//=======================================================
// class CwsstorePingResponse Implementation
//=======================================================

CwsstorePingResponse::CwsstorePingResponse(const char *serviceName, IRpcMessageBinding *init)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("wsstorePingResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CwsstorePingResponse::CwsstorePingResponse(const char *serviceName, const char *bc)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("wsstorePingResponse");
}

CwsstorePingResponse::CwsstorePingResponse(const char *serviceName, IRpcMessage* rpcmsg)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("wsstorePingResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CwsstorePingResponse::CwsstorePingResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("wsstorePingResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CwsstorePingResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType><xsd:all/></xsd:complexType></xsd:element>\n", msgTypeName);
		}
	}
	return schema;
}

void CwsstorePingResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CwsstorePingResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CwsstorePingResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CwsstorePingResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CwsstorePingResponse::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
	}
}


void CwsstorePingResponse::copy(CwsstorePingResponse &from)
{
}


void CwsstorePingResponse::copy(IConstwsstorePingResponse &ifrom)
{
}


void CwsstorePingResponse::getAttributes(IProperties &attributes)
{
}


void CwsstorePingResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
	}
}


void CwsstorePingResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CwsstorePingResponse::serializer(IEspContext* ctx, IConstwsstorePingResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<wsstorePingResponse>");
	if (keepRootTag)
		buffer.append("</wsstorePingResponse>");
}

bool CwsstorePingResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
	}
	return hasValue;
}

bool CwsstorePingResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	return hasValue;
}

bool CwsstorePingResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	return hasValue;
}

extern "C"  IEspwsstorePingResponse *createwsstorePingResponse(const char *serv){return ((IEspwsstorePingResponse *)new CwsstorePingResponse(serv));}
extern "C"  IClientwsstorePingResponse *createClientwsstorePingResponse(const char *serv){return ((IClientwsstorePingResponse *)new CwsstorePingResponse(serv));}

//=======================================================
// class CwsstoreSoapBinding Implementation
//=======================================================

CwsstoreSoapBinding::CwsstoreSoapBinding(http_soap_log_level level):CHttpSoapBinding(NULL, NULL, NULL, level)
{
	init_strings();
	setWsdlVersion(1);
}

CwsstoreSoapBinding::CwsstoreSoapBinding(IPropertyTree* cfg, const char *bindname, const char *procname, http_soap_log_level level):CHttpSoapBinding(cfg, bindname, procname, level)
{
	init_strings(); 
	setWsdlVersion(1);

}

void CwsstoreSoapBinding::init_strings()
{
}

int CwsstoreSoapBinding::processRequest(IRpcMessage* rpc_call, IRpcMessage* rpc_response)
{
	if(rpc_call == NULL || rpc_response == NULL)
		return -1;

	IEspContext *ctx=rpc_call->queryContext();
	DBGLOG("Client version: %g", ctx->getClientVersion());
	StringBuffer serviceName;
	double clientVer=(ctx) ? ctx->getClientVersion() : 0.0;
	qualifyServiceName(*ctx, ctx->queryServiceName(NULL), NULL, serviceName, NULL);
	CRpcCall* thecall = static_cast<CRpcCall *>(rpc_call);
	CRpcResponse* response = static_cast<CRpcResponse*>(rpc_response);
	CHttpRequest* httprequest = thecall->getHttpReq();
	CHttpResponse* httpresponse = response->getHttpResp();

	Owned<IEspwsstore> iserv = (IEspwsstore*)getService();
	if(iserv == NULL)
	{
		response->set_status(SOAP_SERVER_ERROR);
		response->set_err("Service not available");
		DBGLOG("Service not available");
		return -1;
	}
	if (thecall->get_name() == NULL)
	{
		response->set_status(SOAP_CLIENT_ERROR);
		response->set_err("No service method specified");
		ERRLOG("No service method specified");
		return -1;
	}

	IEspContext& context = *rpc_call->queryContext();

	if(!stricmp(thecall->get_name(), "CreateStore")||!stricmp(thecall->get_name(), "CreateStoreRequest"))
	{
		Owned<CCreateStoreRequest> esp_request = new CCreateStoreRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CCreateStoreResponse> esp_response = new CCreateStoreResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;
		accessmap.setValue("WsStoreAccess", SecAccess_Read);
		accessmap.setValue("WsStoreAccess", SecAccess_Full);
		StringBuffer source;
		source.appendf("wsstore::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "wsstore", "CreateStore");
			iserv->onCreateStore(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "wsstore", "CreateStore");
		response->set_name("CreateStoreResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "Delete")||!stricmp(thecall->get_name(), "DeleteRequest"))
	{
		Owned<CDeleteRequest> esp_request = new CDeleteRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CDeleteResponse> esp_response = new CDeleteResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;
		accessmap.setValue("WsStoreAccess", SecAccess_Read);
		accessmap.setValue("WsStoreAccess", SecAccess_Full);
		StringBuffer source;
		source.appendf("wsstore::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "wsstore", "Delete");
			iserv->onDelete(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "wsstore", "Delete");
		response->set_name("DeleteResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "DeleteNamespace")||!stricmp(thecall->get_name(), "DeleteNamespaceRequest"))
	{
		Owned<CDeleteNamespaceRequest> esp_request = new CDeleteNamespaceRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CDeleteNamespaceResponse> esp_response = new CDeleteNamespaceResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;
		accessmap.setValue("WsStoreAccess", SecAccess_Read);
		accessmap.setValue("WsStoreAccess", SecAccess_Full);
		StringBuffer source;
		source.appendf("wsstore::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "wsstore", "DeleteNamespace");
			iserv->onDeleteNamespace(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "wsstore", "DeleteNamespace");
		response->set_name("DeleteNamespaceResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "Fetch")||!stricmp(thecall->get_name(), "FetchRequest"))
	{
		Owned<CFetchRequest> esp_request = new CFetchRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CFetchResponse> esp_response = new CFetchResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;
		accessmap.setValue("WsStoreAccess", SecAccess_Read);
		accessmap.setValue("WsStoreAccess", SecAccess_Read);
		StringBuffer source;
		source.appendf("wsstore::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "wsstore", "Fetch");
			iserv->onFetch(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "wsstore", "Fetch");
		response->set_name("FetchResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "FetchAll")||!stricmp(thecall->get_name(), "FetchAllRequest"))
	{
		Owned<CFetchAllRequest> esp_request = new CFetchAllRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CFetchAllResponse> esp_response = new CFetchAllResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;
		accessmap.setValue("WsStoreAccess", SecAccess_Read);
		accessmap.setValue("WsStoreAccess", SecAccess_Read);
		StringBuffer source;
		source.appendf("wsstore::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "wsstore", "FetchAll");
			iserv->onFetchAll(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "wsstore", "FetchAll");
		response->set_name("FetchAllResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "FetchKeyMetadata")||!stricmp(thecall->get_name(), "FetchKeyMDRequest"))
	{
		Owned<CFetchKeyMDRequest> esp_request = new CFetchKeyMDRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CFetchKeyMDResponse> esp_response = new CFetchKeyMDResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;
		accessmap.setValue("WsStoreAccess", SecAccess_Read);
		accessmap.setValue("WsStoreAccess", SecAccess_Full);
		StringBuffer source;
		source.appendf("wsstore::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "wsstore", "FetchKeyMetadata");
			iserv->onFetchKeyMetadata(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "wsstore", "FetchKeyMetadata");
		response->set_name("FetchKeyMDResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "ListKeys")||!stricmp(thecall->get_name(), "ListKeysRequest"))
	{
		Owned<CListKeysRequest> esp_request = new CListKeysRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CListKeysResponse> esp_response = new CListKeysResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;
		accessmap.setValue("WsStoreAccess", SecAccess_Read);
		accessmap.setValue("WsStoreAccess", SecAccess_Read);
		StringBuffer source;
		source.appendf("wsstore::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "wsstore", "ListKeys");
			iserv->onListKeys(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "wsstore", "ListKeys");
		response->set_name("ListKeysResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "ListNamespaces")||!stricmp(thecall->get_name(), "ListNamespacesRequest"))
	{
		Owned<CListNamespacesRequest> esp_request = new CListNamespacesRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CListNamespacesResponse> esp_response = new CListNamespacesResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;
		accessmap.setValue("WsStoreAccess", SecAccess_Read);
		accessmap.setValue("WsStoreAccess", SecAccess_Read);
		StringBuffer source;
		source.appendf("wsstore::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "wsstore", "ListNamespaces");
			iserv->onListNamespaces(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "wsstore", "ListNamespaces");
		response->set_name("ListNamespacesResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "Ping")||!stricmp(thecall->get_name(), "wsstorePingRequest"))
	{
		Owned<CwsstorePingRequest> esp_request = new CwsstorePingRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CwsstorePingResponse> esp_response = new CwsstorePingResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;
		accessmap.setValue("WsStoreAccess", SecAccess_Read);
		StringBuffer source;
		source.appendf("wsstore::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "wsstore", "Ping");
			iserv->onPing(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "wsstore", "Ping");
		response->set_name("wsstorePingResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "Set")||!stricmp(thecall->get_name(), "SetRequest"))
	{
		Owned<CSetRequest> esp_request = new CSetRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CSetResponse> esp_response = new CSetResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;
		accessmap.setValue("WsStoreAccess", SecAccess_Read);
		accessmap.setValue("WsStoreAccess", SecAccess_Write);
		StringBuffer source;
		source.appendf("wsstore::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "wsstore", "Set");
			iserv->onSet(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "wsstore", "Set");
		response->set_name("SetResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	response->set_status(SOAP_CLIENT_ERROR);
	StringBuffer msg, svcName;
	msg.appendf("Method %s not available in service %s",thecall->get_name(),getServiceName(svcName).str());
	ERRLOG("%s", msg.str());
	response->set_err(msg);
	return -1;
}

int CwsstoreSoapBinding::getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &content, const char *service, const char *method, bool mda)
{
	BoolHash added;
	if (context.getClientVersion()<=0)
		context.setClientVersion(1);

	DBGLOG("Client version: %g", context.getClientVersion());
	bool fullservice = (!Utils::strcasecmp(service, "wsstore"));
	bool allMethods = (method==NULL || *method==0);
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "CreateStore"))) || Utils::strcasecmp(method, "CreateStore")==0)
	{
		CCreateStoreRequest::getMapInfo(context.queryMapInfo());
		CCreateStoreResponse::getMapInfo(context.queryMapInfo());
		CCreateStoreRequest::getXsdDefinition(context, request, "CreateStoreRequest", content, added);
		CCreateStoreResponse::getXsdDefinition(context, request, content, added);
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "Delete"))) || Utils::strcasecmp(method, "Delete")==0)
	{
		CDeleteRequest::getMapInfo(context.queryMapInfo());
		CDeleteResponse::getMapInfo(context.queryMapInfo());
		CDeleteRequest::getXsdDefinition(context, request, "DeleteRequest", content, added);
		CDeleteResponse::getXsdDefinition(context, request, content, added);
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "DeleteNamespace"))) || Utils::strcasecmp(method, "DeleteNamespace")==0)
	{
		CDeleteNamespaceRequest::getMapInfo(context.queryMapInfo());
		CDeleteNamespaceResponse::getMapInfo(context.queryMapInfo());
		CDeleteNamespaceRequest::getXsdDefinition(context, request, "DeleteNamespaceRequest", content, added);
		CDeleteNamespaceResponse::getXsdDefinition(context, request, content, added);
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "Fetch"))) || Utils::strcasecmp(method, "Fetch")==0)
	{
		CFetchRequest::getMapInfo(context.queryMapInfo());
		CFetchResponse::getMapInfo(context.queryMapInfo());
		CFetchRequest::getXsdDefinition(context, request, "FetchRequest", content, added);
		CFetchResponse::getXsdDefinition(context, request, content, added);
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "FetchAll"))) || Utils::strcasecmp(method, "FetchAll")==0)
	{
		CFetchAllRequest::getMapInfo(context.queryMapInfo());
		CFetchAllResponse::getMapInfo(context.queryMapInfo());
		CFetchAllRequest::getXsdDefinition(context, request, "FetchAllRequest", content, added);
		CFetchAllResponse::getXsdDefinition(context, request, content, added);
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "FetchKeyMetadata"))) || Utils::strcasecmp(method, "FetchKeyMetadata")==0)
	{
		CFetchKeyMDRequest::getMapInfo(context.queryMapInfo());
		CFetchKeyMDResponse::getMapInfo(context.queryMapInfo());
		CFetchKeyMDRequest::getXsdDefinition(context, request, "FetchKeyMDRequest", content, added);
		CFetchKeyMDResponse::getXsdDefinition(context, request, content, added);
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "ListKeys"))) || Utils::strcasecmp(method, "ListKeys")==0)
	{
		CListKeysRequest::getMapInfo(context.queryMapInfo());
		CListKeysResponse::getMapInfo(context.queryMapInfo());
		CListKeysRequest::getXsdDefinition(context, request, "ListKeysRequest", content, added);
		CListKeysResponse::getXsdDefinition(context, request, content, added);
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "ListNamespaces"))) || Utils::strcasecmp(method, "ListNamespaces")==0)
	{
		CListNamespacesRequest::getMapInfo(context.queryMapInfo());
		CListNamespacesResponse::getMapInfo(context.queryMapInfo());
		CListNamespacesRequest::getXsdDefinition(context, request, "ListNamespacesRequest", content, added);
		CListNamespacesResponse::getXsdDefinition(context, request, content, added);
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "Ping"))) || Utils::strcasecmp(method, "Ping")==0)
	{
		CwsstorePingRequest::getMapInfo(context.queryMapInfo());
		CwsstorePingResponse::getMapInfo(context.queryMapInfo());
		CwsstorePingRequest::getXsdDefinition(context, request, "wsstorePingRequest", content, added);
		CwsstorePingResponse::getXsdDefinition(context, request, content, added);
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "Set"))) || Utils::strcasecmp(method, "Set")==0)
	{
		CSetRequest::getMapInfo(context.queryMapInfo());
		CSetResponse::getMapInfo(context.queryMapInfo());
		CSetRequest::getXsdDefinition(context, request, "SetRequest", content, added);
		CSetResponse::getXsdDefinition(context, request, content, added);
	}
	return 0;
}

int CwsstoreSoapBinding::getMethodHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &page, bool bIncludeFormTag)
{
	DBGLOG("Client version: %g", context.getClientVersion());
	if (Utils::strcasecmp(method, "CreateStore")==0)
	{
		CCreateStoreRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "Delete")==0)
	{
		CDeleteRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "DeleteNamespace")==0)
	{
		CDeleteNamespaceRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "Fetch")==0)
	{
		CFetchRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "FetchAll")==0)
	{
		CFetchAllRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "FetchKeyMetadata")==0)
	{
		CFetchKeyMDRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "ListKeys")==0)
	{
		CListKeysRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "ListNamespaces")==0)
	{
		CListNamespacesRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "Ping")==0)
	{
		CwsstorePingRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "Set")==0)
	{
		CSetRequest::getHtmlForm(context, request, serv, method, page);
	}
	return 0;
}

int CwsstoreSoapBinding::getQualifiedNames(IEspContext& ctx, MethodInfoArray & methods)
{
	double ver = ctx.getClientVersion();
	if (ver<=0)
		ver = getWsdlVersion();
	const char *servname=ctx.queryServiceName(NULL);
	bool fullservice = (!stricmp(servname, "esp")||!stricmp(servname, "wsstore"));
	if ((fullservice || isMethodInSubService(ctx, servname, "CreateStore")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("CreateStore", "CreateStoreRequest", "CreateStoreResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "Delete")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("Delete", "DeleteRequest", "DeleteResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "DeleteNamespace")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("DeleteNamespace", "DeleteNamespaceRequest", "DeleteNamespaceResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "Fetch")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("Fetch", "FetchRequest", "FetchResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "FetchAll")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("FetchAll", "FetchAllRequest", "FetchAllResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "FetchKeyMetadata")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("FetchKeyMetadata", "FetchKeyMDRequest", "FetchKeyMDResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "ListKeys")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("ListKeys", "ListKeysRequest", "ListKeysResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "ListNamespaces")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("ListNamespaces", "ListNamespacesRequest", "ListNamespacesResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "Ping")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("Ping", "wsstorePingRequest", "wsstorePingResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "Set")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("Set", "SetRequest", "SetResponse"));
	return methods.ordinality();
}

StringBuffer & CwsstoreSoapBinding::getServiceName(StringBuffer &resp)
{
	resp.append("wsstore");
	return resp;
}

bool CwsstoreSoapBinding::isValidServiceName(IEspContext &context, const char *name)
{
	if (!Utils::strcasecmp(name, "wsstore"))
		return true;
	else
		return (hasSubService(context, name));
}

bool CwsstoreSoapBinding::qualifyMethodName(IEspContext &context, const char *methname, StringBuffer *methQName)
{
	if (!methname || !*methname)
	{
		if (methQName!=NULL)
			methQName->clear();
		return true;
	}
	if (Utils::strcasecmp(methname, "CreateStore")==0)
	{
		if (methQName!=NULL)
			methQName->set("CreateStore");
		return true;
	}
	if (Utils::strcasecmp(methname, "Delete")==0)
	{
		if (methQName!=NULL)
			methQName->set("Delete");
		return true;
	}
	if (Utils::strcasecmp(methname, "DeleteNamespace")==0)
	{
		if (methQName!=NULL)
			methQName->set("DeleteNamespace");
		return true;
	}
	if (Utils::strcasecmp(methname, "Fetch")==0)
	{
		if (methQName!=NULL)
			methQName->set("Fetch");
		return true;
	}
	if (Utils::strcasecmp(methname, "FetchAll")==0)
	{
		if (methQName!=NULL)
			methQName->set("FetchAll");
		return true;
	}
	if (Utils::strcasecmp(methname, "FetchKeyMetadata")==0)
	{
		if (methQName!=NULL)
			methQName->set("FetchKeyMetadata");
		return true;
	}
	if (Utils::strcasecmp(methname, "ListKeys")==0)
	{
		if (methQName!=NULL)
			methQName->set("ListKeys");
		return true;
	}
	if (Utils::strcasecmp(methname, "ListNamespaces")==0)
	{
		if (methQName!=NULL)
			methQName->set("ListNamespaces");
		return true;
	}
	if (Utils::strcasecmp(methname, "Ping")==0)
	{
		if (methQName!=NULL)
			methQName->set("Ping");
		return true;
	}
	if (Utils::strcasecmp(methname, "Set")==0)
	{
		if (methQName!=NULL)
			methQName->set("Set");
		return true;
	}
	return false;
}

bool CwsstoreSoapBinding::qualifyServiceName(IEspContext &context, const char *servname, const char *methname, StringBuffer &servQName, StringBuffer *methQName)
{
	servQName.clear();
	if (!Utils::strcasecmp(servname, "wsstore"))
	{
		servQName.append("wsstore");
		return qualifyMethodName(context, methname, methQName);
	}
	return qualifySubServiceName(context, servname, methname, servQName, methQName);
}

int CwsstoreSoapBinding::onGetFile(IEspContext &context, CHttpRequest* request, CHttpResponse* response, const char *pathex)
{
	if(request == NULL || response == NULL)
		return -1;
	StringBuffer mimetype;
	MemoryBuffer content;

	StringBuffer filepath;
	getBaseFilePath(filepath);
	if (strchr("\\/", filepath.charAt(filepath.length()-1))==NULL)
		filepath.append("/");
	filepath.append(pathex);
	response->httpContentFromFile(filepath.str());
	response->send();
	return 0;
}

int CwsstoreSoapBinding::onGetForm(IEspContext &context, CHttpRequest* request, CHttpResponse* response, const char *service, const char *method)
{
	if (context.getClientVersion()<=0)
		context.setClientVersion(1);

	if (!stricmp("CreateStore", method)) {
		CCreateStoreRequest::getMapInfo(context.queryMapInfo());
		CCreateStoreResponse::getMapInfo(context.queryMapInfo());
	}
	if (!stricmp("Delete", method)) {
		CDeleteRequest::getMapInfo(context.queryMapInfo());
		CDeleteResponse::getMapInfo(context.queryMapInfo());
	}
	if (!stricmp("DeleteNamespace", method)) {
		CDeleteNamespaceRequest::getMapInfo(context.queryMapInfo());
		CDeleteNamespaceResponse::getMapInfo(context.queryMapInfo());
	}
	if (!stricmp("Fetch", method)) {
		CFetchRequest::getMapInfo(context.queryMapInfo());
		CFetchResponse::getMapInfo(context.queryMapInfo());
	}
	if (!stricmp("FetchAll", method)) {
		CFetchAllRequest::getMapInfo(context.queryMapInfo());
		CFetchAllResponse::getMapInfo(context.queryMapInfo());
	}
	if (!stricmp("FetchKeyMetadata", method)) {
		CFetchKeyMDRequest::getMapInfo(context.queryMapInfo());
		CFetchKeyMDResponse::getMapInfo(context.queryMapInfo());
	}
	if (!stricmp("ListKeys", method)) {
		CListKeysRequest::getMapInfo(context.queryMapInfo());
		CListKeysResponse::getMapInfo(context.queryMapInfo());
	}
	if (!stricmp("ListNamespaces", method)) {
		CListNamespacesRequest::getMapInfo(context.queryMapInfo());
		CListNamespacesResponse::getMapInfo(context.queryMapInfo());
	}
	if (!stricmp("Ping", method)) {
		CwsstorePingRequest::getMapInfo(context.queryMapInfo());
		CwsstorePingResponse::getMapInfo(context.queryMapInfo());
	}
	if (!stricmp("Set", method)) {
		CSetRequest::getMapInfo(context.queryMapInfo());
		CSetResponse::getMapInfo(context.queryMapInfo());
	}

	return EspHttpBinding::onGetForm(context, request, response, service, method);
}
int CwsstoreSoapBinding::onGetXForm(IEspContext &context, CHttpRequest* request, CHttpResponse* response, const char *service, const char *method)
{
	return EspHttpBinding::onGetXForm(context, request, response, service, method);
}

int CwsstoreSoapBinding::onGetService(IEspContext &context, CHttpRequest* request, CHttpResponse* response, const char *service, const char *method, const char *pathex)
{
	if(request == NULL || response == NULL)
		return -1;
	return onGetQuery(context, request, response, service, method);
}

 IRpcRequestBinding *CwsstoreSoapBinding::createReqBinding(IEspContext &context, IHttpMessage *ireq, const char *service, const char *method)
{
	CHttpRequest *request=static_cast<CHttpRequest*>(ireq);
	IProperties *props = (request) ? request->queryParameters() : NULL;

	if (!stricmp(method, "CreateStore") || !stricmp(method, "CreateStoreRequest"))
		return new CCreateStoreRequest(&context, "wsstore", props, NULL);
	if (!stricmp(method, "Delete") || !stricmp(method, "DeleteRequest"))
		return new CDeleteRequest(&context, "wsstore", props, NULL);
	if (!stricmp(method, "DeleteNamespace") || !stricmp(method, "DeleteNamespaceRequest"))
		return new CDeleteNamespaceRequest(&context, "wsstore", props, NULL);
	if (!stricmp(method, "Fetch") || !stricmp(method, "FetchRequest"))
		return new CFetchRequest(&context, "wsstore", props, NULL);
	if (!stricmp(method, "FetchAll") || !stricmp(method, "FetchAllRequest"))
		return new CFetchAllRequest(&context, "wsstore", props, NULL);
	if (!stricmp(method, "FetchKeyMetadata") || !stricmp(method, "FetchKeyMDRequest"))
		return new CFetchKeyMDRequest(&context, "wsstore", props, NULL);
	if (!stricmp(method, "ListKeys") || !stricmp(method, "ListKeysRequest"))
		return new CListKeysRequest(&context, "wsstore", props, NULL);
	if (!stricmp(method, "ListNamespaces") || !stricmp(method, "ListNamespacesRequest"))
		return new CListNamespacesRequest(&context, "wsstore", props, NULL);
	if (!stricmp(method, "Ping") || !stricmp(method, "wsstorePingRequest"))
		return new CwsstorePingRequest(&context, "wsstore", props, NULL);
	if (!stricmp(method, "Set") || !stricmp(method, "SetRequest"))
		return new CSetRequest(&context, "wsstore", props, NULL);
	return NULL;
}

int CwsstoreSoapBinding::onGetInstantQuery(IEspContext &context, CHttpRequest* request, CHttpResponse* response, const char *service, const char *method)
{
	if (context.getClientVersion()<=0)
		context.setClientVersion(1);

	if(request == NULL || response == NULL)
		return -1;
	StringBuffer respStr;
	Owned<IEspwsstore> iserv = (IEspwsstore*)getService();
	if(iserv == NULL)
	{
		respStr.append("Service not available");
		response->setContent(respStr.str());
		response->setContentType("text/html");
		response->send();
	}
	else
	{
		Owned<CSoapResponseBinding> esp_response;
		StringBuffer source;
		IEspContext& context = *request->queryContext();
		if(!stricmp(method, "CreateStore")||!stricmp(method, "CreateStoreRequest"))
		{
			Owned<CCreateStoreRequest> esp_request = new CCreateStoreRequest(&context, "wsstore", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			CCreateStoreResponse* resp = new CCreateStoreResponse("wsstore");
			esp_response.setown(resp);
			MapStringTo<SecAccessFlags> accessmap;
			accessmap.setValue("WsStoreAccess", SecAccess_Read);
			accessmap.setValue("WsStoreAccess", SecAccess_Full);
			source.setf("wsstore::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				if(accessmap.ordinality()>0)
					onFeaturesAuthorize(context, accessmap, "wsstore", "CreateStore");
				iserv->onCreateStore(context, *esp_request.get(), *resp);
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "wsstore", "CreateStore", StringBuffer(getCFD()).append("./smc_xslt/exceptions.xslt").str()))
				return 0;
		}
		if(!stricmp(method, "Delete")||!stricmp(method, "DeleteRequest"))
		{
			Owned<CDeleteRequest> esp_request = new CDeleteRequest(&context, "wsstore", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			CDeleteResponse* resp = new CDeleteResponse("wsstore");
			esp_response.setown(resp);
			MapStringTo<SecAccessFlags> accessmap;
			accessmap.setValue("WsStoreAccess", SecAccess_Read);
			accessmap.setValue("WsStoreAccess", SecAccess_Full);
			source.setf("wsstore::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				if(accessmap.ordinality()>0)
					onFeaturesAuthorize(context, accessmap, "wsstore", "Delete");
				iserv->onDelete(context, *esp_request.get(), *resp);
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "wsstore", "Delete", StringBuffer(getCFD()).append("./smc_xslt/exceptions.xslt").str()))
				return 0;
		}
		if(!stricmp(method, "DeleteNamespace")||!stricmp(method, "DeleteNamespaceRequest"))
		{
			Owned<CDeleteNamespaceRequest> esp_request = new CDeleteNamespaceRequest(&context, "wsstore", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			CDeleteNamespaceResponse* resp = new CDeleteNamespaceResponse("wsstore");
			esp_response.setown(resp);
			MapStringTo<SecAccessFlags> accessmap;
			accessmap.setValue("WsStoreAccess", SecAccess_Read);
			accessmap.setValue("WsStoreAccess", SecAccess_Full);
			source.setf("wsstore::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				if(accessmap.ordinality()>0)
					onFeaturesAuthorize(context, accessmap, "wsstore", "DeleteNamespace");
				iserv->onDeleteNamespace(context, *esp_request.get(), *resp);
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "wsstore", "DeleteNamespace", StringBuffer(getCFD()).append("./smc_xslt/exceptions.xslt").str()))
				return 0;
		}
		if(!stricmp(method, "Fetch")||!stricmp(method, "FetchRequest"))
		{
			Owned<CFetchRequest> esp_request = new CFetchRequest(&context, "wsstore", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			CFetchResponse* resp = new CFetchResponse("wsstore");
			esp_response.setown(resp);
			MapStringTo<SecAccessFlags> accessmap;
			accessmap.setValue("WsStoreAccess", SecAccess_Read);
			accessmap.setValue("WsStoreAccess", SecAccess_Read);
			source.setf("wsstore::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				if(accessmap.ordinality()>0)
					onFeaturesAuthorize(context, accessmap, "wsstore", "Fetch");
				iserv->onFetch(context, *esp_request.get(), *resp);
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "wsstore", "Fetch", StringBuffer(getCFD()).append("./smc_xslt/exceptions.xslt").str()))
				return 0;
		}
		if(!stricmp(method, "FetchAll")||!stricmp(method, "FetchAllRequest"))
		{
			Owned<CFetchAllRequest> esp_request = new CFetchAllRequest(&context, "wsstore", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			CFetchAllResponse* resp = new CFetchAllResponse("wsstore");
			esp_response.setown(resp);
			MapStringTo<SecAccessFlags> accessmap;
			accessmap.setValue("WsStoreAccess", SecAccess_Read);
			accessmap.setValue("WsStoreAccess", SecAccess_Read);
			source.setf("wsstore::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				if(accessmap.ordinality()>0)
					onFeaturesAuthorize(context, accessmap, "wsstore", "FetchAll");
				iserv->onFetchAll(context, *esp_request.get(), *resp);
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "wsstore", "FetchAll", StringBuffer(getCFD()).append("./smc_xslt/exceptions.xslt").str()))
				return 0;
		}
		if(!stricmp(method, "FetchKeyMetadata")||!stricmp(method, "FetchKeyMDRequest"))
		{
			Owned<CFetchKeyMDRequest> esp_request = new CFetchKeyMDRequest(&context, "wsstore", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			CFetchKeyMDResponse* resp = new CFetchKeyMDResponse("wsstore");
			esp_response.setown(resp);
			MapStringTo<SecAccessFlags> accessmap;
			accessmap.setValue("WsStoreAccess", SecAccess_Read);
			accessmap.setValue("WsStoreAccess", SecAccess_Full);
			source.setf("wsstore::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				if(accessmap.ordinality()>0)
					onFeaturesAuthorize(context, accessmap, "wsstore", "FetchKeyMetadata");
				iserv->onFetchKeyMetadata(context, *esp_request.get(), *resp);
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "wsstore", "FetchKeyMetadata", StringBuffer(getCFD()).append("./smc_xslt/exceptions.xslt").str()))
				return 0;
		}
		if(!stricmp(method, "ListKeys")||!stricmp(method, "ListKeysRequest"))
		{
			Owned<CListKeysRequest> esp_request = new CListKeysRequest(&context, "wsstore", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			CListKeysResponse* resp = new CListKeysResponse("wsstore");
			esp_response.setown(resp);
			MapStringTo<SecAccessFlags> accessmap;
			accessmap.setValue("WsStoreAccess", SecAccess_Read);
			accessmap.setValue("WsStoreAccess", SecAccess_Read);
			source.setf("wsstore::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				if(accessmap.ordinality()>0)
					onFeaturesAuthorize(context, accessmap, "wsstore", "ListKeys");
				iserv->onListKeys(context, *esp_request.get(), *resp);
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "wsstore", "ListKeys", StringBuffer(getCFD()).append("./smc_xslt/exceptions.xslt").str()))
				return 0;
		}
		if(!stricmp(method, "ListNamespaces")||!stricmp(method, "ListNamespacesRequest"))
		{
			Owned<CListNamespacesRequest> esp_request = new CListNamespacesRequest(&context, "wsstore", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			CListNamespacesResponse* resp = new CListNamespacesResponse("wsstore");
			esp_response.setown(resp);
			MapStringTo<SecAccessFlags> accessmap;
			accessmap.setValue("WsStoreAccess", SecAccess_Read);
			accessmap.setValue("WsStoreAccess", SecAccess_Read);
			source.setf("wsstore::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				if(accessmap.ordinality()>0)
					onFeaturesAuthorize(context, accessmap, "wsstore", "ListNamespaces");
				iserv->onListNamespaces(context, *esp_request.get(), *resp);
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "wsstore", "ListNamespaces", StringBuffer(getCFD()).append("./smc_xslt/exceptions.xslt").str()))
				return 0;
		}
		if(!stricmp(method, "Ping")||!stricmp(method, "wsstorePingRequest"))
		{
			Owned<CwsstorePingRequest> esp_request = new CwsstorePingRequest(&context, "wsstore", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			CwsstorePingResponse* resp = new CwsstorePingResponse("wsstore");
			esp_response.setown(resp);
			MapStringTo<SecAccessFlags> accessmap;
			accessmap.setValue("WsStoreAccess", SecAccess_Read);
			source.setf("wsstore::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				if(accessmap.ordinality()>0)
					onFeaturesAuthorize(context, accessmap, "wsstore", "Ping");
				iserv->onPing(context, *esp_request.get(), *resp);
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "wsstore", "Ping", StringBuffer(getCFD()).append("./smc_xslt/exceptions.xslt").str()))
				return 0;
		}
		if(!stricmp(method, "Set")||!stricmp(method, "SetRequest"))
		{
			Owned<CSetRequest> esp_request = new CSetRequest(&context, "wsstore", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			CSetResponse* resp = new CSetResponse("wsstore");
			esp_response.setown(resp);
			MapStringTo<SecAccessFlags> accessmap;
			accessmap.setValue("WsStoreAccess", SecAccess_Read);
			accessmap.setValue("WsStoreAccess", SecAccess_Write);
			source.setf("wsstore::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				if(accessmap.ordinality()>0)
					onFeaturesAuthorize(context, accessmap, "wsstore", "Set");
				iserv->onSet(context, *esp_request.get(), *resp);
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "wsstore", "Set", StringBuffer(getCFD()).append("./smc_xslt/exceptions.xslt").str()))
				return 0;
		}

		if (esp_response.get())
		{
			if (canRedirect(*request) && esp_response->getRedirectUrl() && *esp_response->getRedirectUrl())
				response->redirect(*request, esp_response->getRedirectUrl());
			else
			{
				MemoryBuffer content;
				StringBuffer mimetype;
				esp_response->appendContent(&context,content, mimetype);
				onBeforeSendResponse(context,request,content,service,method);
				response->setContent(content.length(), content.toByteArray());
				response->setContentType(mimetype.str());
				response->send();
			}
			return 0;
		}
	}
	return onGetNotFound(context, request,  response, service);
}





//=======================================================
// client util methods
//=======================================================

//------ method CreateStore ---------

IClientCreateStoreRequest * CClientwsstore::createCreateStoreRequest()
{
	CCreateStoreRequest* request = new CCreateStoreRequest("wsstore");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientCreateStoreResponse * CClientwsstore::CreateStore(IClientCreateStoreRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CCreateStoreRequest* esprequest = static_cast<CCreateStoreRequest*>(request);
	CCreateStoreResponse* espresponse = new CCreateStoreResponse("wsstore");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientwsstore::async_CreateStore(IClientCreateStoreRequest *request, IClientwsstoreEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CCreateStoreRequest* esprequest = static_cast<CCreateStoreRequest*>(request);
	esprequest->setMethod("CreateStore");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientwsstore::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientCreateStoreResponse *CClientwsstore::CreateStoreFn(const char * Name_, const char * Type_, const char * Description_, bool UserSpecific_)
{
	Owned<IClientCreateStoreRequest> req =  createCreateStoreRequest();
	req->setName(Name_);
	req->setType(Type_);
	req->setDescription(Description_);
	req->setUserSpecific(UserSpecific_);
	return CreateStore(req.get());
}

//------ method Delete ---------

IClientDeleteRequest * CClientwsstore::createDeleteRequest()
{
	CDeleteRequest* request = new CDeleteRequest("wsstore");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientDeleteResponse * CClientwsstore::Delete(IClientDeleteRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CDeleteRequest* esprequest = static_cast<CDeleteRequest*>(request);
	CDeleteResponse* espresponse = new CDeleteResponse("wsstore");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientwsstore::async_Delete(IClientDeleteRequest *request, IClientwsstoreEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CDeleteRequest* esprequest = static_cast<CDeleteRequest*>(request);
	esprequest->setMethod("Delete");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientwsstore::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientDeleteResponse *CClientwsstore::DeleteFn(const char * StoreName_, const char * Namespace_, const char * Key_, bool UserSpecific_, const char * TargetUser_)
{
	Owned<IClientDeleteRequest> req =  createDeleteRequest();
	req->setStoreName(StoreName_);
	req->setNamespace(Namespace_);
	req->setKey(Key_);
	req->setUserSpecific(UserSpecific_);
	req->setTargetUser(TargetUser_);
	return Delete(req.get());
}

//------ method DeleteNamespace ---------

IClientDeleteNamespaceRequest * CClientwsstore::createDeleteNamespaceRequest()
{
	CDeleteNamespaceRequest* request = new CDeleteNamespaceRequest("wsstore");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientDeleteNamespaceResponse * CClientwsstore::DeleteNamespace(IClientDeleteNamespaceRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CDeleteNamespaceRequest* esprequest = static_cast<CDeleteNamespaceRequest*>(request);
	CDeleteNamespaceResponse* espresponse = new CDeleteNamespaceResponse("wsstore");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientwsstore::async_DeleteNamespace(IClientDeleteNamespaceRequest *request, IClientwsstoreEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CDeleteNamespaceRequest* esprequest = static_cast<CDeleteNamespaceRequest*>(request);
	esprequest->setMethod("DeleteNamespace");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientwsstore::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientDeleteNamespaceResponse *CClientwsstore::DeleteNamespaceFn(const char * StoreName_, const char * Namespace_, bool UserSpecific_, const char * TargetUser_)
{
	Owned<IClientDeleteNamespaceRequest> req =  createDeleteNamespaceRequest();
	req->setStoreName(StoreName_);
	req->setNamespace(Namespace_);
	req->setUserSpecific(UserSpecific_);
	req->setTargetUser(TargetUser_);
	return DeleteNamespace(req.get());
}

//------ method Fetch ---------

IClientFetchRequest * CClientwsstore::createFetchRequest()
{
	CFetchRequest* request = new CFetchRequest("wsstore");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientFetchResponse * CClientwsstore::Fetch(IClientFetchRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CFetchRequest* esprequest = static_cast<CFetchRequest*>(request);
	CFetchResponse* espresponse = new CFetchResponse("wsstore");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientwsstore::async_Fetch(IClientFetchRequest *request, IClientwsstoreEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CFetchRequest* esprequest = static_cast<CFetchRequest*>(request);
	esprequest->setMethod("Fetch");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientwsstore::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientFetchResponse *CClientwsstore::FetchFn(const char * StoreName_, const char * Namespace_, const char * Key_, bool UserSpecific_)
{
	Owned<IClientFetchRequest> req =  createFetchRequest();
	req->setStoreName(StoreName_);
	req->setNamespace(Namespace_);
	req->setKey(Key_);
	req->setUserSpecific(UserSpecific_);
	return Fetch(req.get());
}

//------ method FetchAll ---------

IClientFetchAllRequest * CClientwsstore::createFetchAllRequest()
{
	CFetchAllRequest* request = new CFetchAllRequest("wsstore");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientFetchAllResponse * CClientwsstore::FetchAll(IClientFetchAllRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CFetchAllRequest* esprequest = static_cast<CFetchAllRequest*>(request);
	CFetchAllResponse* espresponse = new CFetchAllResponse("wsstore");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientwsstore::async_FetchAll(IClientFetchAllRequest *request, IClientwsstoreEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CFetchAllRequest* esprequest = static_cast<CFetchAllRequest*>(request);
	esprequest->setMethod("FetchAll");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientwsstore::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientFetchAllResponse *CClientwsstore::FetchAllFn(const char * StoreName_, const char * Namespace_, bool UserSpecific_)
{
	Owned<IClientFetchAllRequest> req =  createFetchAllRequest();
	req->setStoreName(StoreName_);
	req->setNamespace(Namespace_);
	req->setUserSpecific(UserSpecific_);
	return FetchAll(req.get());
}

//------ method FetchKeyMetadata ---------

IClientFetchKeyMDRequest * CClientwsstore::createFetchKeyMetadataRequest()
{
	CFetchKeyMDRequest* request = new CFetchKeyMDRequest("wsstore");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientFetchKeyMDResponse * CClientwsstore::FetchKeyMetadata(IClientFetchKeyMDRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CFetchKeyMDRequest* esprequest = static_cast<CFetchKeyMDRequest*>(request);
	CFetchKeyMDResponse* espresponse = new CFetchKeyMDResponse("wsstore");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientwsstore::async_FetchKeyMetadata(IClientFetchKeyMDRequest *request, IClientwsstoreEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CFetchKeyMDRequest* esprequest = static_cast<CFetchKeyMDRequest*>(request);
	esprequest->setMethod("FetchKeyMetadata");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientwsstore::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientFetchKeyMDResponse *CClientwsstore::FetchKeyMetadataFn(const char * StoreName_, const char * Namespace_, const char * Key_, bool UserSpecific_)
{
	Owned<IClientFetchKeyMDRequest> req =  createFetchKeyMetadataRequest();
	req->setStoreName(StoreName_);
	req->setNamespace(Namespace_);
	req->setKey(Key_);
	req->setUserSpecific(UserSpecific_);
	return FetchKeyMetadata(req.get());
}

//------ method ListKeys ---------

IClientListKeysRequest * CClientwsstore::createListKeysRequest()
{
	CListKeysRequest* request = new CListKeysRequest("wsstore");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientListKeysResponse * CClientwsstore::ListKeys(IClientListKeysRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CListKeysRequest* esprequest = static_cast<CListKeysRequest*>(request);
	CListKeysResponse* espresponse = new CListKeysResponse("wsstore");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientwsstore::async_ListKeys(IClientListKeysRequest *request, IClientwsstoreEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CListKeysRequest* esprequest = static_cast<CListKeysRequest*>(request);
	esprequest->setMethod("ListKeys");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientwsstore::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientListKeysResponse *CClientwsstore::ListKeysFn(const char * StoreName_, const char * Namespace_, bool UserSpecific_)
{
	Owned<IClientListKeysRequest> req =  createListKeysRequest();
	req->setStoreName(StoreName_);
	req->setNamespace(Namespace_);
	req->setUserSpecific(UserSpecific_);
	return ListKeys(req.get());
}

//------ method ListNamespaces ---------

IClientListNamespacesRequest * CClientwsstore::createListNamespacesRequest()
{
	CListNamespacesRequest* request = new CListNamespacesRequest("wsstore");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientListNamespacesResponse * CClientwsstore::ListNamespaces(IClientListNamespacesRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CListNamespacesRequest* esprequest = static_cast<CListNamespacesRequest*>(request);
	CListNamespacesResponse* espresponse = new CListNamespacesResponse("wsstore");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientwsstore::async_ListNamespaces(IClientListNamespacesRequest *request, IClientwsstoreEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CListNamespacesRequest* esprequest = static_cast<CListNamespacesRequest*>(request);
	esprequest->setMethod("ListNamespaces");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientwsstore::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientListNamespacesResponse *CClientwsstore::ListNamespacesFn(const char * StoreName_, bool UserSpecific_)
{
	Owned<IClientListNamespacesRequest> req =  createListNamespacesRequest();
	req->setStoreName(StoreName_);
	req->setUserSpecific(UserSpecific_);
	return ListNamespaces(req.get());
}

//------ method Ping ---------

IClientwsstorePingRequest * CClientwsstore::createPingRequest()
{
	CwsstorePingRequest* request = new CwsstorePingRequest("wsstore");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientwsstorePingResponse * CClientwsstore::Ping(IClientwsstorePingRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CwsstorePingRequest* esprequest = static_cast<CwsstorePingRequest*>(request);
	CwsstorePingResponse* espresponse = new CwsstorePingResponse("wsstore");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientwsstore::async_Ping(IClientwsstorePingRequest *request, IClientwsstoreEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CwsstorePingRequest* esprequest = static_cast<CwsstorePingRequest*>(request);
	esprequest->setMethod("Ping");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientwsstore::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientwsstorePingResponse *CClientwsstore::PingFn()
{
	Owned<IClientwsstorePingRequest> req =  createPingRequest();
	return Ping(req.get());
}

//------ method Set ---------

IClientSetRequest * CClientwsstore::createSetRequest()
{
	CSetRequest* request = new CSetRequest("wsstore");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientSetResponse * CClientwsstore::Set(IClientSetRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CSetRequest* esprequest = static_cast<CSetRequest*>(request);
	CSetResponse* espresponse = new CSetResponse("wsstore");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientwsstore::async_Set(IClientSetRequest *request, IClientwsstoreEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CSetRequest* esprequest = static_cast<CSetRequest*>(request);
	esprequest->setMethod("Set");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientwsstore::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientSetResponse *CClientwsstore::SetFn(const char * StoreName_, const char * Namespace_, const char * Key_, const char * Value_, bool UserSpecific_)
{
	Owned<IClientSetRequest> req =  createSetRequest();
	req->setStoreName(StoreName_);
	req->setNamespace(Namespace_);
	req->setKey(Key_);
	req->setValue(Value_);
	req->setUserSpecific(UserSpecific_);
	return Set(req.get());
}

int CClientwsstore::transferThunkEvent(void *data)
{
	IRpcResponseBinding *response = (IRpcResponseBinding *)data;
	if (response!=NULL)
	{
		IClientwsstoreEvents *eventSink = (IClientwsstoreEvents *)response->getEventSink();
		response->lock();

		if (stricmp(response->getMethod(), "CreateStore")==0)
		{
			IClientCreateStoreResponse* icresp = dynamic_cast<IClientCreateStoreResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onCreateStoreComplete(icresp, response->queryState());
				else
					eventSink->onCreateStoreError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "Delete")==0)
		{
			IClientDeleteResponse* icresp = dynamic_cast<IClientDeleteResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onDeleteComplete(icresp, response->queryState());
				else
					eventSink->onDeleteError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "DeleteNamespace")==0)
		{
			IClientDeleteNamespaceResponse* icresp = dynamic_cast<IClientDeleteNamespaceResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onDeleteNamespaceComplete(icresp, response->queryState());
				else
					eventSink->onDeleteNamespaceError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "Fetch")==0)
		{
			IClientFetchResponse* icresp = dynamic_cast<IClientFetchResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onFetchComplete(icresp, response->queryState());
				else
					eventSink->onFetchError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "FetchAll")==0)
		{
			IClientFetchAllResponse* icresp = dynamic_cast<IClientFetchAllResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onFetchAllComplete(icresp, response->queryState());
				else
					eventSink->onFetchAllError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "FetchKeyMetadata")==0)
		{
			IClientFetchKeyMDResponse* icresp = dynamic_cast<IClientFetchKeyMDResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onFetchKeyMetadataComplete(icresp, response->queryState());
				else
					eventSink->onFetchKeyMetadataError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "ListKeys")==0)
		{
			IClientListKeysResponse* icresp = dynamic_cast<IClientListKeysResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onListKeysComplete(icresp, response->queryState());
				else
					eventSink->onListKeysError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "ListNamespaces")==0)
		{
			IClientListNamespacesResponse* icresp = dynamic_cast<IClientListNamespacesResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onListNamespacesComplete(icresp, response->queryState());
				else
					eventSink->onListNamespacesError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "Ping")==0)
		{
			IClientwsstorePingResponse* icresp = dynamic_cast<IClientwsstorePingResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onPingComplete(icresp, response->queryState());
				else
					eventSink->onPingError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "Set")==0)
		{
			IClientSetResponse* icresp = dynamic_cast<IClientSetResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onSetComplete(icresp, response->queryState());
				else
					eventSink->onSetError(icresp,response->queryState());
			}
		}
		response->unlock();
	}
	return 0;
}

static IRpcResponseBinding* createwsstoreResponseObject(IRpcRequestBinding *request)
{
	const char* method = request->getMethod();
	if (stricmp(method, "CreateStore")==0)
		return new CCreateStoreResponse("wsstore", request);
	if (stricmp(method, "Delete")==0)
		return new CDeleteResponse("wsstore", request);
	if (stricmp(method, "DeleteNamespace")==0)
		return new CDeleteNamespaceResponse("wsstore", request);
	if (stricmp(method, "Fetch")==0)
		return new CFetchResponse("wsstore", request);
	if (stricmp(method, "FetchAll")==0)
		return new CFetchAllResponse("wsstore", request);
	if (stricmp(method, "FetchKeyMetadata")==0)
		return new CFetchKeyMDResponse("wsstore", request);
	if (stricmp(method, "ListKeys")==0)
		return new CListKeysResponse("wsstore", request);
	if (stricmp(method, "ListNamespaces")==0)
		return new CListNamespacesResponse("wsstore", request);
	if (stricmp(method, "Ping")==0)
		return new CwsstorePingResponse("wsstore", request);
	if (stricmp(method, "Set")==0)
		return new CSetResponse("wsstore", request);
	return NULL;
}

#ifdef _WIN32
void CClientwsstore::espWorkerThread(void* data)
#else
void *CClientwsstore::espWorkerThread(void *data)
#endif
{
	IRpcRequestBinding *request = (IRpcRequestBinding *) data;

	if (request != NULL)
	{
		request->lock();
		IRpcResponseBinding *response=createwsstoreResponseObject(request);
		if (response!=NULL)
		{
			try{
				request->post(*response);
			}
			catch(IException* ex){
				StringBuffer errorStr;
				ex->errorMessage(errorStr);
				ERRLOG("CClientwsstore::espWorkerThread(%s)--Exception caught while posting async request: %s", request->getMethod(), errorStr.str());
				ex->Release();
			}
			catch(...){
				ERRLOG("Unknown exception caught while posting async request");
			}
		}
#ifdef USE_CLIENT_THREAD
		ThunkToClientThread(request->getThunkHandle(), transferThunkEvent, (void *)response);
#else
		transferThunkEvent((void *)response);
#endif
		request->unlock();
		if(request->queryState()!=NULL)
			request->queryState()->Release();

		if(response!=NULL)
			response->Release();

		request->Release();
	}
#if defined(_WIN32)
#else
	return (void *) 0 ;
#endif
}



extern "C" IClientwsstore * createwsstoreClient() {  return new CClientwsstore(); }


#endif //ws_store_ESPGEN_INCLUDED
