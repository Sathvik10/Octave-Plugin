// *** Source file generated by HIDL Version 1.3 from ws_account.ecm ***
// *** Not to be hand edited (changes will be lost on re-generation) ***

#ifndef ws_account_ESPGEN_INCLUDED
#define ws_account_ESPGEN_INCLUDED

#include "ws_account_esp.ipp"

#ifdef _WIN32
#include "edwin.h"
#include <process.h>
#endif



//=======================================================
// class CUpdateUserInputRequest Implementation
//=======================================================

CUpdateUserInputRequest::CUpdateUserInputRequest(const char *serviceName, IRpcMessageBinding *init)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("UpdateUserInputRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CUpdateUserInputRequest::CUpdateUserInputRequest(const char *serviceName, const char *bc)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("UpdateUserInputRequest");
}

CUpdateUserInputRequest::CUpdateUserInputRequest(const char *serviceName, IRpcMessage* rpcmsg)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("UpdateUserInputRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CUpdateUserInputRequest::CUpdateUserInputRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("UpdateUserInputRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CUpdateUserInputRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType><xsd:all/></xsd:complexType></xsd:element>\n", msgTypeName);
		}
	}
	return schema;
}

void CUpdateUserInputRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CUpdateUserInputRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CUpdateUserInputRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CUpdateUserInputRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CUpdateUserInputRequest::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

}


void CUpdateUserInputRequest::copy(CUpdateUserInputRequest &from)
{
}


void CUpdateUserInputRequest::copy(IConstUpdateUserInputRequest &ifrom)
{
}


void CUpdateUserInputRequest::getAttributes(IProperties &attributes)
{
}


void CUpdateUserInputRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
}


void CUpdateUserInputRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CUpdateUserInputRequest::serializer(IEspContext* ctx, IConstUpdateUserInputRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<UpdateUserInputRequest>");
	if (keepRootTag)
		buffer.append("</UpdateUserInputRequest>");
}

bool CUpdateUserInputRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	return hasValue;
}

bool CUpdateUserInputRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	return hasValue;
}

bool CUpdateUserInputRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	return hasValue;
}

extern "C"  IEspUpdateUserInputRequest *createUpdateUserInputRequest(const char *serv){return ((IEspUpdateUserInputRequest *)new CUpdateUserInputRequest(serv));}
extern "C"  IClientUpdateUserInputRequest *createClientUpdateUserInputRequest(const char *serv){return ((IClientUpdateUserInputRequest *)new CUpdateUserInputRequest(serv));}

//=======================================================
// class CUpdateUserInputResponse Implementation
//=======================================================

CUpdateUserInputResponse::CUpdateUserInputResponse(const char *serviceName, IRpcMessageBinding *init)
	: m_username(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("UpdateUserInputResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CUpdateUserInputResponse::CUpdateUserInputResponse(const char *serviceName, const char *bc)
	: m_username(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("UpdateUserInputResponse");
}

CUpdateUserInputResponse::CUpdateUserInputResponse(const char *serviceName, IRpcMessage* rpcmsg)
	: m_username(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("UpdateUserInputResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CUpdateUserInputResponse::CUpdateUserInputResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_username(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("UpdateUserInputResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CUpdateUserInputResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		schema.append("<xsd:element name=\"Exceptions\" type=\"tns:ArrayOfEspException\" minOccurs=\"0\" maxOccurs=\"1\"/>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"username\" type=\"xsd:string\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CUpdateUserInputResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CUpdateUserInputResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CUpdateUserInputResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("username");
	form.appendf("  <tr><td><b>username: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CUpdateUserInputResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CUpdateUserInputResponse::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
		m_username.marshall(rpc_resp, "username", "", "", "");
	}
}


void CUpdateUserInputResponse::copy(CUpdateUserInputResponse &from)
{
	m_username.copy(from.m_username);
}


void CUpdateUserInputResponse::copy(IConstUpdateUserInputResponse &ifrom)
{
	setUsername(ifrom.getUsername());
}


void CUpdateUserInputResponse::getAttributes(IProperties &attributes)
{
}


void CUpdateUserInputResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
		m_username.toStr(ctx, buffer, "username", "", true, "", "");
	}
}


void CUpdateUserInputResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CUpdateUserInputResponse::serializer(IEspContext* ctx, IConstUpdateUserInputResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<UpdateUserInputResponse>");
	// field username
	{
		const char* s = src.getUsername();
		if (s && *s)
		{
			buffer.append("<username>");
			encodeUtf8XML(s,buffer);
			buffer.append("</username>");
		}
	}
	if (keepRootTag)
		buffer.append("</UpdateUserInputResponse>");
}

bool CUpdateUserInputResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
		hasValue |= m_username.unmarshall(rpc_request, "username", basepath);
	}
	return hasValue;
}

bool CUpdateUserInputResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_username.unmarshall(ctx, soapval, "username");
	return hasValue;
}

bool CUpdateUserInputResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_username.unmarshall(ctx, params, attachments, "username", basepath);
	return hasValue;
}

const char * CUpdateUserInputResponse::getUsername() { return m_username.query();}
void CUpdateUserInputResponse::setUsername(const char * val){ m_username.set(val); }
extern "C"  IEspUpdateUserInputResponse *createUpdateUserInputResponse(const char *serv){return ((IEspUpdateUserInputResponse *)new CUpdateUserInputResponse(serv));}
extern "C"  IClientUpdateUserInputResponse *createClientUpdateUserInputResponse(const char *serv){return ((IClientUpdateUserInputResponse *)new CUpdateUserInputResponse(serv));}

//=======================================================
// class CMyAccountRequest Implementation
//=======================================================

CMyAccountRequest::CMyAccountRequest(const char *serviceName, IRpcMessageBinding *init)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("MyAccountRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CMyAccountRequest::CMyAccountRequest(const char *serviceName, const char *bc)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("MyAccountRequest");
}

CMyAccountRequest::CMyAccountRequest(const char *serviceName, IRpcMessage* rpcmsg)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("MyAccountRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CMyAccountRequest::CMyAccountRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("MyAccountRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CMyAccountRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType><xsd:all/></xsd:complexType></xsd:element>\n", msgTypeName);
		}
	}
	return schema;
}

void CMyAccountRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CMyAccountRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CMyAccountRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CMyAccountRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CMyAccountRequest::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

}


void CMyAccountRequest::copy(CMyAccountRequest &from)
{
}


void CMyAccountRequest::copy(IConstMyAccountRequest &ifrom)
{
}


void CMyAccountRequest::getAttributes(IProperties &attributes)
{
}


void CMyAccountRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
}


void CMyAccountRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CMyAccountRequest::serializer(IEspContext* ctx, IConstMyAccountRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<MyAccountRequest>");
	if (keepRootTag)
		buffer.append("</MyAccountRequest>");
}

bool CMyAccountRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	return hasValue;
}

bool CMyAccountRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	return hasValue;
}

bool CMyAccountRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	return hasValue;
}

extern "C"  IEspMyAccountRequest *createMyAccountRequest(const char *serv){return ((IEspMyAccountRequest *)new CMyAccountRequest(serv));}
extern "C"  IClientMyAccountRequest *createClientMyAccountRequest(const char *serv){return ((IClientMyAccountRequest *)new CMyAccountRequest(serv));}

//=======================================================
// class CMyAccountResponse Implementation
//=======================================================

CMyAccountResponse::CMyAccountResponse(const char *serviceName, IRpcMessageBinding *init)
	: m_username(nilIgnore),m_firstName(nilIgnore),m_lastName(nilIgnore),m_passwordExpiration(nilIgnore),m_passwordDaysRemaining(nilIgnore),m_passwordExpirationWarningDays(nilIgnore),m_employeeID(nilIgnore),m_distinguishedName(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("MyAccountResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CMyAccountResponse::CMyAccountResponse(const char *serviceName, const char *bc)
	: m_username(nilIgnore),m_firstName(nilIgnore),m_lastName(nilIgnore),m_passwordExpiration(nilIgnore),m_passwordDaysRemaining(nilIgnore),m_passwordExpirationWarningDays(nilIgnore),m_employeeID(nilIgnore),m_distinguishedName(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("MyAccountResponse");
}

CMyAccountResponse::CMyAccountResponse(const char *serviceName, IRpcMessage* rpcmsg)
	: m_username(nilIgnore),m_firstName(nilIgnore),m_lastName(nilIgnore),m_passwordExpiration(nilIgnore),m_passwordDaysRemaining(nilIgnore),m_passwordExpirationWarningDays(nilIgnore),m_employeeID(nilIgnore),m_distinguishedName(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("MyAccountResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CMyAccountResponse::CMyAccountResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_username(nilIgnore),m_firstName(nilIgnore),m_lastName(nilIgnore),m_passwordExpiration(nilIgnore),m_passwordDaysRemaining(nilIgnore),m_passwordExpirationWarningDays(nilIgnore),m_employeeID(nilIgnore),m_distinguishedName(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("MyAccountResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CMyAccountResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		schema.append("<xsd:element name=\"Exceptions\" type=\"tns:ArrayOfEspException\" minOccurs=\"0\" maxOccurs=\"1\"/>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"username\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"firstName\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"lastName\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"passwordExpiration\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"passwordDaysRemaining\" type=\"xsd:int\"/>\n");
		if (!context.suppressed("MyAccountResponse","passwordExpirationWarningDays")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"passwordExpirationWarningDays\" type=\"xsd:int\"/>\n");
		}
		if (!context.suppressed("MyAccountResponse","employeeID")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"employeeID\" type=\"xsd:string\"/>\n");
		}
		if (!context.suppressed("MyAccountResponse","distinguishedName")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"distinguishedName\" type=\"xsd:string\"/>\n");
		}
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CMyAccountResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CMyAccountResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
	info.addMinVersion("MyAccountResponse","passwordExpirationWarningDays",1.01);
	info.addMinVersion("MyAccountResponse","employeeID",1.02);
	info.addMinVersion("MyAccountResponse","distinguishedName",1.03);
}

StringBuffer &CMyAccountResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("username");
	form.appendf("  <tr><td><b>username: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("firstName");
	form.appendf("  <tr><td><b>firstName: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("lastName");
	form.appendf("  <tr><td><b>lastName: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("passwordExpiration");
	form.appendf("  <tr><td><b>passwordExpiration: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix) extfix.append(prefix).append(".");
		extfix.append("passwordDaysRemaining");
	form.appendf("  <tr><td><b>passwordDaysRemaining: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
	form.append("</td></tr>\n");
	if (!context.suppressed("MyAccountResponse","passwordExpirationWarningDays")) {
		extfix.clear();
		if (prefix && *prefix) extfix.append(prefix).append(".");
			extfix.append("passwordExpirationWarningDays");
		form.appendf("  <tr><td><b>passwordExpirationWarningDays: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
		form.append("</td></tr>\n");
	}
	if (!context.suppressed("MyAccountResponse","employeeID")) {
		extfix.clear();
		if (prefix && *prefix)
			extfix.append(prefix).append(".");
		extfix.append("employeeID");
		form.appendf("  <tr><td><b>employeeID: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
		form.append("</td></tr>\n");
	}
	if (!context.suppressed("MyAccountResponse","distinguishedName")) {
		extfix.clear();
		if (prefix && *prefix)
			extfix.append(prefix).append(".");
		extfix.append("distinguishedName");
		form.appendf("  <tr><td><b>distinguishedName: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
		form.append("</td></tr>\n");
	}
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CMyAccountResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CMyAccountResponse::serialize(IRpcMessage& rpc_resp)
{
	IEspContext* ctx = rpc_resp.queryContext();
	double clientVer= ctx ? ctx->getClientVersion() : -1; /* no context gets everything */
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
		m_username.marshall(rpc_resp, "username", "", "", "");
		m_firstName.marshall(rpc_resp, "firstName", "", "", "");
		m_lastName.marshall(rpc_resp, "lastName", "", "", "");
		m_passwordExpiration.marshall(rpc_resp, "passwordExpiration", "", "", "");
		m_passwordDaysRemaining.marshall(rpc_resp, "passwordDaysRemaining", "", "", "");
		if ((clientVer==-1.0 || clientVer>=1.01))
			m_passwordExpirationWarningDays.marshall(rpc_resp, "passwordExpirationWarningDays", "", "", "");
		if ((clientVer==-1.0 || clientVer>=1.02))
			m_employeeID.marshall(rpc_resp, "employeeID", "", "", "");
		if ((clientVer==-1.0 || clientVer>=1.03))
			m_distinguishedName.marshall(rpc_resp, "distinguishedName", "", "", "");
	}
}


void CMyAccountResponse::copy(CMyAccountResponse &from)
{
	m_username.copy(from.m_username);
	m_firstName.copy(from.m_firstName);
	m_lastName.copy(from.m_lastName);
	m_passwordExpiration.copy(from.m_passwordExpiration);
	m_passwordDaysRemaining.copy(from.m_passwordDaysRemaining);
	m_passwordExpirationWarningDays.copy(from.m_passwordExpirationWarningDays);
	m_employeeID.copy(from.m_employeeID);
	m_distinguishedName.copy(from.m_distinguishedName);
}


void CMyAccountResponse::copy(IConstMyAccountResponse &ifrom)
{
	setUsername(ifrom.getUsername());
	setFirstName(ifrom.getFirstName());
	setLastName(ifrom.getLastName());
	setPasswordExpiration(ifrom.getPasswordExpiration());
	setPasswordDaysRemaining(ifrom.getPasswordDaysRemaining());
	setPasswordExpirationWarningDays(ifrom.getPasswordExpirationWarningDays());
	setEmployeeID(ifrom.getEmployeeID());
	setDistinguishedName(ifrom.getDistinguishedName());
}


void CMyAccountResponse::getAttributes(IProperties &attributes)
{
}


void CMyAccountResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
		double clientVer = ctx ? ctx->getClientVersion() : -1;
		m_username.toStr(ctx, buffer, "username", "", true, "", "");
		m_firstName.toStr(ctx, buffer, "firstName", "", true, "", "");
		m_lastName.toStr(ctx, buffer, "lastName", "", true, "", "");
		m_passwordExpiration.toStr(ctx, buffer, "passwordExpiration", "", true, "", "");
		m_passwordDaysRemaining.toStr(ctx, buffer, "passwordDaysRemaining", "", true, "", "");
		if ((clientVer==-1.0 || clientVer>=1.01))
			m_passwordExpirationWarningDays.toStr(ctx, buffer, "passwordExpirationWarningDays", "", true, "", "");
		if ((clientVer==-1.0 || clientVer>=1.02))
			m_employeeID.toStr(ctx, buffer, "employeeID", "", true, "", "");
		if ((clientVer==-1.0 || clientVer>=1.03))
			m_distinguishedName.toStr(ctx, buffer, "distinguishedName", "", true, "", "");
	}
}


void CMyAccountResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CMyAccountResponse::serializer(IEspContext* ctx, IConstMyAccountResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<MyAccountResponse>");
	double clientVer = ctx ? ctx->getClientVersion() : -1;
	// field username
	{
		const char* s = src.getUsername();
		if (s && *s)
		{
			buffer.append("<username>");
			encodeUtf8XML(s,buffer);
			buffer.append("</username>");
		}
	}
	// field firstName
	{
		const char* s = src.getFirstName();
		if (s && *s)
		{
			buffer.append("<firstName>");
			encodeUtf8XML(s,buffer);
			buffer.append("</firstName>");
		}
	}
	// field lastName
	{
		const char* s = src.getLastName();
		if (s && *s)
		{
			buffer.append("<lastName>");
			encodeUtf8XML(s,buffer);
			buffer.append("</lastName>");
		}
	}
	// field passwordExpiration
	{
		const char* s = src.getPasswordExpiration();
		if (s && *s)
		{
			buffer.append("<passwordExpiration>");
			encodeUtf8XML(s,buffer);
			buffer.append("</passwordExpiration>");
		}
	}
	// field passwordDaysRemaining
	{
		int n = src.getPasswordDaysRemaining();
		if (n)
			buffer.appendf("<passwordDaysRemaining>%d</passwordDaysRemaining>", n);
	}
	// field passwordExpirationWarningDays
	if ((clientVer==-1.0 || clientVer>=1.01))
	{
		int n = src.getPasswordExpirationWarningDays();
		if (n)
			buffer.appendf("<passwordExpirationWarningDays>%d</passwordExpirationWarningDays>", n);
	}
	// field employeeID
	if ((clientVer==-1.0 || clientVer>=1.02))
	{
		const char* s = src.getEmployeeID();
		if (s && *s)
		{
			buffer.append("<employeeID>");
			encodeUtf8XML(s,buffer);
			buffer.append("</employeeID>");
		}
	}
	// field distinguishedName
	if ((clientVer==-1.0 || clientVer>=1.03))
	{
		const char* s = src.getDistinguishedName();
		if (s && *s)
		{
			buffer.append("<distinguishedName>");
			encodeUtf8XML(s,buffer);
			buffer.append("</distinguishedName>");
		}
	}
	if (keepRootTag)
		buffer.append("</MyAccountResponse>");
}

bool CMyAccountResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
		hasValue |= m_username.unmarshall(rpc_request, "username", basepath);
		hasValue |= m_firstName.unmarshall(rpc_request, "firstName", basepath);
		hasValue |= m_lastName.unmarshall(rpc_request, "lastName", basepath);
		hasValue |= m_passwordExpiration.unmarshall(rpc_request, "passwordExpiration", basepath);
		hasValue |= m_passwordDaysRemaining.unmarshall(rpc_request, "passwordDaysRemaining", basepath);
		hasValue |= m_passwordExpirationWarningDays.unmarshall(rpc_request, "passwordExpirationWarningDays", basepath);
		hasValue |= m_employeeID.unmarshall(rpc_request, "employeeID", basepath);
		hasValue |= m_distinguishedName.unmarshall(rpc_request, "distinguishedName", basepath);
	}
	return hasValue;
}

bool CMyAccountResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_username.unmarshall(ctx, soapval, "username");
	hasValue |= m_firstName.unmarshall(ctx, soapval, "firstName");
	hasValue |= m_lastName.unmarshall(ctx, soapval, "lastName");
	hasValue |= m_passwordExpiration.unmarshall(ctx, soapval, "passwordExpiration");
	hasValue |= m_passwordDaysRemaining.unmarshall(ctx, soapval, "passwordDaysRemaining");
	hasValue |= m_passwordExpirationWarningDays.unmarshall(ctx, soapval, "passwordExpirationWarningDays");
	hasValue |= m_employeeID.unmarshall(ctx, soapval, "employeeID");
	hasValue |= m_distinguishedName.unmarshall(ctx, soapval, "distinguishedName");
	return hasValue;
}

bool CMyAccountResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_username.unmarshall(ctx, params, attachments, "username", basepath);
	hasValue |= m_firstName.unmarshall(ctx, params, attachments, "firstName", basepath);
	hasValue |= m_lastName.unmarshall(ctx, params, attachments, "lastName", basepath);
	hasValue |= m_passwordExpiration.unmarshall(ctx, params, attachments, "passwordExpiration", basepath);
	hasValue |= m_passwordDaysRemaining.unmarshall(ctx, params, attachments, "passwordDaysRemaining", basepath);
	hasValue |= m_passwordExpirationWarningDays.unmarshall(ctx, params, attachments, "passwordExpirationWarningDays", basepath);
	hasValue |= m_employeeID.unmarshall(ctx, params, attachments, "employeeID", basepath);
	hasValue |= m_distinguishedName.unmarshall(ctx, params, attachments, "distinguishedName", basepath);
	return hasValue;
}

const char * CMyAccountResponse::getUsername() { return m_username.query();}
const char * CMyAccountResponse::getFirstName() { return m_firstName.query();}
const char * CMyAccountResponse::getLastName() { return m_lastName.query();}
const char * CMyAccountResponse::getPasswordExpiration() { return m_passwordExpiration.query();}
int CMyAccountResponse::getPasswordDaysRemaining() { return m_passwordDaysRemaining;}
int CMyAccountResponse::getPasswordExpirationWarningDays() { return m_passwordExpirationWarningDays;}
const char * CMyAccountResponse::getEmployeeID() { return m_employeeID.query();}
const char * CMyAccountResponse::getDistinguishedName() { return m_distinguishedName.query();}
void CMyAccountResponse::setUsername(const char * val){ m_username.set(val); }
void CMyAccountResponse::setFirstName(const char * val){ m_firstName.set(val); }
void CMyAccountResponse::setLastName(const char * val){ m_lastName.set(val); }
void CMyAccountResponse::setPasswordExpiration(const char * val){ m_passwordExpiration.set(val); }
void CMyAccountResponse::setPasswordDaysRemaining(int val){ m_passwordDaysRemaining=val; }
void CMyAccountResponse::setPasswordExpirationWarningDays(int val){ m_passwordExpirationWarningDays=val; }
void CMyAccountResponse::setEmployeeID(const char * val){ m_employeeID.set(val); }
void CMyAccountResponse::setDistinguishedName(const char * val){ m_distinguishedName.set(val); }
extern "C"  IEspMyAccountResponse *createMyAccountResponse(const char *serv){return ((IEspMyAccountResponse *)new CMyAccountResponse(serv));}
extern "C"  IClientMyAccountResponse *createClientMyAccountResponse(const char *serv){return ((IClientMyAccountResponse *)new CMyAccountResponse(serv));}

//=======================================================
// class CUpdateUserRequest Implementation
//=======================================================

CUpdateUserRequest::CUpdateUserRequest(const char *serviceName, IRpcMessageBinding *init)
	: m_username(nilIgnore),m_oldpass(nilIgnore),m_newpass1(nilIgnore),m_newpass2(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("UpdateUserRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CUpdateUserRequest::CUpdateUserRequest(const char *serviceName, const char *bc)
	: m_username(nilIgnore),m_oldpass(nilIgnore),m_newpass1(nilIgnore),m_newpass2(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("UpdateUserRequest");
}

CUpdateUserRequest::CUpdateUserRequest(const char *serviceName, IRpcMessage* rpcmsg)
	: m_username(nilIgnore),m_oldpass(nilIgnore),m_newpass1(nilIgnore),m_newpass2(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("UpdateUserRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CUpdateUserRequest::CUpdateUserRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_username(nilIgnore),m_oldpass(nilIgnore),m_newpass1(nilIgnore),m_newpass2(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("UpdateUserRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CUpdateUserRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"username\" type=\"xsd:string\"");
		if (context.queryOptions()&ESPCTX_ALL_ANNOTATION)
			schema.append("> <xsd:annotation><xsd:appinfo><form formCols=\"20\"/></xsd:appinfo></xsd:annotation></xsd:element>\n");
		else
			schema.append("/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"oldpass\" type=\"xsd:string\"");
		if (context.queryOptions()&ESPCTX_ALL_ANNOTATION)
			schema.append("> <xsd:annotation><xsd:appinfo><form formType=\"password\" formCols=\"20\"/></xsd:appinfo></xsd:annotation></xsd:element>\n");
		else
			schema.append("/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"newpass1\" type=\"xsd:string\"");
		if (context.queryOptions()&ESPCTX_ALL_ANNOTATION)
			schema.append("> <xsd:annotation><xsd:appinfo><form formType=\"password\" formCols=\"20\"/></xsd:appinfo></xsd:annotation></xsd:element>\n");
		else
			schema.append("/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"newpass2\" type=\"xsd:string\"");
		if (context.queryOptions()&ESPCTX_ALL_ANNOTATION)
			schema.append("> <xsd:annotation><xsd:appinfo><form formType=\"password\" formCols=\"20\"/></xsd:appinfo></xsd:annotation></xsd:element>\n");
		else
			schema.append("/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CUpdateUserRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CUpdateUserRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CUpdateUserRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("username");
	form.appendf("  <tr><td><b>User Name: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("oldpass");
	form.appendf("  <tr><td><b>Old Password: </b></td><td><input type=\"password\" name=\"%s\" size=\"20\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("newpass1");
	form.appendf("  <tr><td><b>New password: </b></td><td><input type=\"password\" name=\"%s\" size=\"20\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("newpass2");
	form.appendf("  <tr><td><b>Retype new password: </b></td><td><input type=\"password\" name=\"%s\" size=\"20\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CUpdateUserRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CUpdateUserRequest::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_username.marshall(rpc_resp, "username", "", "", "");
	m_oldpass.marshall(rpc_resp, "oldpass", "", "", "");
	m_newpass1.marshall(rpc_resp, "newpass1", "", "", "");
	m_newpass2.marshall(rpc_resp, "newpass2", "", "", "");
}


void CUpdateUserRequest::copy(CUpdateUserRequest &from)
{
	m_username.copy(from.m_username);
	m_oldpass.copy(from.m_oldpass);
	m_newpass1.copy(from.m_newpass1);
	m_newpass2.copy(from.m_newpass2);
}


void CUpdateUserRequest::copy(IConstUpdateUserRequest &ifrom)
{
	setUsername(ifrom.getUsername());
	setOldpass(ifrom.getOldpass());
	setNewpass1(ifrom.getNewpass1());
	setNewpass2(ifrom.getNewpass2());
}


void CUpdateUserRequest::getAttributes(IProperties &attributes)
{
}


void CUpdateUserRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_username.toStr(ctx, buffer, "username", "", true, "", "");
	m_oldpass.toStr(ctx, buffer, "oldpass", "", true, "", "");
	m_newpass1.toStr(ctx, buffer, "newpass1", "", true, "", "");
	m_newpass2.toStr(ctx, buffer, "newpass2", "", true, "", "");
}


void CUpdateUserRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CUpdateUserRequest::serializer(IEspContext* ctx, IConstUpdateUserRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<UpdateUserRequest>");
	// field username
	{
		const char* s = src.getUsername();
		if (s && *s)
		{
			buffer.append("<username>");
			encodeUtf8XML(s,buffer);
			buffer.append("</username>");
		}
	}
	// field oldpass
	{
		const char* s = src.getOldpass();
		if (s && *s)
		{
			buffer.append("<oldpass>");
			encodeUtf8XML(s,buffer);
			buffer.append("</oldpass>");
		}
	}
	// field newpass1
	{
		const char* s = src.getNewpass1();
		if (s && *s)
		{
			buffer.append("<newpass1>");
			encodeUtf8XML(s,buffer);
			buffer.append("</newpass1>");
		}
	}
	// field newpass2
	{
		const char* s = src.getNewpass2();
		if (s && *s)
		{
			buffer.append("<newpass2>");
			encodeUtf8XML(s,buffer);
			buffer.append("</newpass2>");
		}
	}
	if (keepRootTag)
		buffer.append("</UpdateUserRequest>");
}

bool CUpdateUserRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_username.unmarshall(rpc_request, "username", basepath);
	hasValue |= m_oldpass.unmarshall(rpc_request, "oldpass", basepath);
	hasValue |= m_newpass1.unmarshall(rpc_request, "newpass1", basepath);
	hasValue |= m_newpass2.unmarshall(rpc_request, "newpass2", basepath);
	return hasValue;
}

bool CUpdateUserRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_username.unmarshall(ctx, soapval, "username");
	hasValue |= m_oldpass.unmarshall(ctx, soapval, "oldpass");
	hasValue |= m_newpass1.unmarshall(ctx, soapval, "newpass1");
	hasValue |= m_newpass2.unmarshall(ctx, soapval, "newpass2");
	return hasValue;
}

bool CUpdateUserRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_username.unmarshall(ctx, params, attachments, "username", basepath);
	hasValue |= m_oldpass.unmarshall(ctx, params, attachments, "oldpass", basepath);
	hasValue |= m_newpass1.unmarshall(ctx, params, attachments, "newpass1", basepath);
	hasValue |= m_newpass2.unmarshall(ctx, params, attachments, "newpass2", basepath);
	return hasValue;
}

const char * CUpdateUserRequest::getUsername() { return m_username.query();}
const char * CUpdateUserRequest::getOldpass() { return m_oldpass.query();}
const char * CUpdateUserRequest::getNewpass1() { return m_newpass1.query();}
const char * CUpdateUserRequest::getNewpass2() { return m_newpass2.query();}
void CUpdateUserRequest::setUsername(const char * val){ m_username.set(val); }
void CUpdateUserRequest::setOldpass(const char * val){ m_oldpass.set(val); }
void CUpdateUserRequest::setNewpass1(const char * val){ m_newpass1.set(val); }
void CUpdateUserRequest::setNewpass2(const char * val){ m_newpass2.set(val); }
extern "C"  IEspUpdateUserRequest *createUpdateUserRequest(const char *serv){return ((IEspUpdateUserRequest *)new CUpdateUserRequest(serv));}
extern "C"  IClientUpdateUserRequest *createClientUpdateUserRequest(const char *serv){return ((IClientUpdateUserRequest *)new CUpdateUserRequest(serv));}

//=======================================================
// class CUpdateUserResponse Implementation
//=======================================================

CUpdateUserResponse::CUpdateUserResponse(const char *serviceName, IRpcMessageBinding *init)
	: m_retcode(nilIgnore),m_message(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("UpdateUserResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CUpdateUserResponse::CUpdateUserResponse(const char *serviceName, const char *bc)
	: m_retcode(nilIgnore),m_message(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("UpdateUserResponse");
}

CUpdateUserResponse::CUpdateUserResponse(const char *serviceName, IRpcMessage* rpcmsg)
	: m_retcode(nilIgnore),m_message(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("UpdateUserResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CUpdateUserResponse::CUpdateUserResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_retcode(nilIgnore),m_message(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("UpdateUserResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CUpdateUserResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		schema.append("<xsd:element name=\"Exceptions\" type=\"tns:ArrayOfEspException\" minOccurs=\"0\" maxOccurs=\"1\"/>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"retcode\" type=\"xsd:int\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"message\" type=\"xsd:string\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CUpdateUserResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CUpdateUserResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CUpdateUserResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix) extfix.append(prefix).append(".");
		extfix.append("retcode");
	form.appendf("  <tr><td><b>retcode: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("message");
	form.appendf("  <tr><td><b>message: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CUpdateUserResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CUpdateUserResponse::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
		m_retcode.marshall(rpc_resp, "retcode", "", "", "");
		m_message.marshall(rpc_resp, "message", "", "", "");
	}
}


void CUpdateUserResponse::copy(CUpdateUserResponse &from)
{
	m_retcode.copy(from.m_retcode);
	m_message.copy(from.m_message);
}


void CUpdateUserResponse::copy(IConstUpdateUserResponse &ifrom)
{
	setRetcode(ifrom.getRetcode());
	setMessage(ifrom.getMessage());
}


void CUpdateUserResponse::getAttributes(IProperties &attributes)
{
}


void CUpdateUserResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
		m_retcode.toStr(ctx, buffer, "retcode", "", true, "", "");
		m_message.toStr(ctx, buffer, "message", "", true, "", "");
	}
}


void CUpdateUserResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CUpdateUserResponse::serializer(IEspContext* ctx, IConstUpdateUserResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<UpdateUserResponse>");
	// field retcode
	{
		int n = src.getRetcode();
		if (n)
			buffer.appendf("<retcode>%d</retcode>", n);
	}
	// field message
	{
		const char* s = src.getMessage();
		if (s && *s)
		{
			buffer.append("<message>");
			encodeUtf8XML(s,buffer);
			buffer.append("</message>");
		}
	}
	if (keepRootTag)
		buffer.append("</UpdateUserResponse>");
}

bool CUpdateUserResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
		hasValue |= m_retcode.unmarshall(rpc_request, "retcode", basepath);
		hasValue |= m_message.unmarshall(rpc_request, "message", basepath);
	}
	return hasValue;
}

bool CUpdateUserResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_retcode.unmarshall(ctx, soapval, "retcode");
	hasValue |= m_message.unmarshall(ctx, soapval, "message");
	return hasValue;
}

bool CUpdateUserResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_retcode.unmarshall(ctx, params, attachments, "retcode", basepath);
	hasValue |= m_message.unmarshall(ctx, params, attachments, "message", basepath);
	return hasValue;
}

int CUpdateUserResponse::getRetcode() { return m_retcode;}
const char * CUpdateUserResponse::getMessage() { return m_message.query();}
void CUpdateUserResponse::setRetcode(int val){ m_retcode=val; }
void CUpdateUserResponse::setMessage(const char * val){ m_message.set(val); }
extern "C"  IEspUpdateUserResponse *createUpdateUserResponse(const char *serv){return ((IEspUpdateUserResponse *)new CUpdateUserResponse(serv));}
extern "C"  IClientUpdateUserResponse *createClientUpdateUserResponse(const char *serv){return ((IClientUpdateUserResponse *)new CUpdateUserResponse(serv));}

//=======================================================
// class CVerifyUserRequest Implementation
//=======================================================

CVerifyUserRequest::CVerifyUserRequest(const char *serviceName, IRpcMessageBinding *init)
	: m_application(nilIgnore),m_version(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("VerifyUserRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CVerifyUserRequest::CVerifyUserRequest(const char *serviceName, const char *bc)
	: m_application(nilIgnore),m_version(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("VerifyUserRequest");
}

CVerifyUserRequest::CVerifyUserRequest(const char *serviceName, IRpcMessage* rpcmsg)
	: m_application(nilIgnore),m_version(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("VerifyUserRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CVerifyUserRequest::CVerifyUserRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_application(nilIgnore),m_version(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("VerifyUserRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CVerifyUserRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"application\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"version\" type=\"xsd:string\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CVerifyUserRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CVerifyUserRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CVerifyUserRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("application");
	form.appendf("  <tr><td><b>application: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("version");
	form.appendf("  <tr><td><b>version: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CVerifyUserRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CVerifyUserRequest::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_application.marshall(rpc_resp, "application", "", "", "");
	m_version.marshall(rpc_resp, "version", "", "", "");
}


void CVerifyUserRequest::copy(CVerifyUserRequest &from)
{
	m_application.copy(from.m_application);
	m_version.copy(from.m_version);
}


void CVerifyUserRequest::copy(IConstVerifyUserRequest &ifrom)
{
	setApplication(ifrom.getApplication());
	setVersion(ifrom.getVersion());
}


void CVerifyUserRequest::getAttributes(IProperties &attributes)
{
}


void CVerifyUserRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_application.toStr(ctx, buffer, "application", "", true, "", "");
	m_version.toStr(ctx, buffer, "version", "", true, "", "");
}


void CVerifyUserRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CVerifyUserRequest::serializer(IEspContext* ctx, IConstVerifyUserRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<VerifyUserRequest>");
	// field application
	{
		const char* s = src.getApplication();
		if (s && *s)
		{
			buffer.append("<application>");
			encodeUtf8XML(s,buffer);
			buffer.append("</application>");
		}
	}
	// field version
	{
		const char* s = src.getVersion();
		if (s && *s)
		{
			buffer.append("<version>");
			encodeUtf8XML(s,buffer);
			buffer.append("</version>");
		}
	}
	if (keepRootTag)
		buffer.append("</VerifyUserRequest>");
}

bool CVerifyUserRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_application.unmarshall(rpc_request, "application", basepath);
	hasValue |= m_version.unmarshall(rpc_request, "version", basepath);
	return hasValue;
}

bool CVerifyUserRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_application.unmarshall(ctx, soapval, "application");
	hasValue |= m_version.unmarshall(ctx, soapval, "version");
	return hasValue;
}

bool CVerifyUserRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_application.unmarshall(ctx, params, attachments, "application", basepath);
	hasValue |= m_version.unmarshall(ctx, params, attachments, "version", basepath);
	return hasValue;
}

const char * CVerifyUserRequest::getApplication() { return m_application.query();}
const char * CVerifyUserRequest::getVersion() { return m_version.query();}
void CVerifyUserRequest::setApplication(const char * val){ m_application.set(val); }
void CVerifyUserRequest::setVersion(const char * val){ m_version.set(val); }
extern "C"  IEspVerifyUserRequest *createVerifyUserRequest(const char *serv){return ((IEspVerifyUserRequest *)new CVerifyUserRequest(serv));}
extern "C"  IClientVerifyUserRequest *createClientVerifyUserRequest(const char *serv){return ((IClientVerifyUserRequest *)new CVerifyUserRequest(serv));}

//=======================================================
// class CVerifyUserResponse Implementation
//=======================================================

CVerifyUserResponse::CVerifyUserResponse(const char *serviceName, IRpcMessageBinding *init)
	: m_retcode(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("VerifyUserResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CVerifyUserResponse::CVerifyUserResponse(const char *serviceName, const char *bc)
	: m_retcode(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("VerifyUserResponse");
}

CVerifyUserResponse::CVerifyUserResponse(const char *serviceName, IRpcMessage* rpcmsg)
	: m_retcode(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("VerifyUserResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CVerifyUserResponse::CVerifyUserResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_retcode(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("VerifyUserResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CVerifyUserResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		schema.append("<xsd:element name=\"Exceptions\" type=\"tns:ArrayOfEspException\" minOccurs=\"0\" maxOccurs=\"1\"/>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"retcode\" type=\"xsd:int\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CVerifyUserResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CVerifyUserResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CVerifyUserResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix) extfix.append(prefix).append(".");
		extfix.append("retcode");
	form.appendf("  <tr><td><b>retcode: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CVerifyUserResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CVerifyUserResponse::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
		m_retcode.marshall(rpc_resp, "retcode", "", "", "");
	}
}


void CVerifyUserResponse::copy(CVerifyUserResponse &from)
{
	m_retcode.copy(from.m_retcode);
}


void CVerifyUserResponse::copy(IConstVerifyUserResponse &ifrom)
{
	setRetcode(ifrom.getRetcode());
}


void CVerifyUserResponse::getAttributes(IProperties &attributes)
{
}


void CVerifyUserResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
		m_retcode.toStr(ctx, buffer, "retcode", "", true, "", "");
	}
}


void CVerifyUserResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CVerifyUserResponse::serializer(IEspContext* ctx, IConstVerifyUserResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<VerifyUserResponse>");
	// field retcode
	{
		int n = src.getRetcode();
		if (n)
			buffer.appendf("<retcode>%d</retcode>", n);
	}
	if (keepRootTag)
		buffer.append("</VerifyUserResponse>");
}

bool CVerifyUserResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
		hasValue |= m_retcode.unmarshall(rpc_request, "retcode", basepath);
	}
	return hasValue;
}

bool CVerifyUserResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_retcode.unmarshall(ctx, soapval, "retcode");
	return hasValue;
}

bool CVerifyUserResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_retcode.unmarshall(ctx, params, attachments, "retcode", basepath);
	return hasValue;
}

int CVerifyUserResponse::getRetcode() { return m_retcode;}
void CVerifyUserResponse::setRetcode(int val){ m_retcode=val; }
extern "C"  IEspVerifyUserResponse *createVerifyUserResponse(const char *serv){return ((IEspVerifyUserResponse *)new CVerifyUserResponse(serv));}
extern "C"  IClientVerifyUserResponse *createClientVerifyUserResponse(const char *serv){return ((IClientVerifyUserResponse *)new CVerifyUserResponse(serv));}

//=======================================================
// class Cws_accountPingRequest Implementation
//=======================================================

Cws_accountPingRequest::Cws_accountPingRequest(const char *serviceName, IRpcMessageBinding *init)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ws_accountPingRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

Cws_accountPingRequest::Cws_accountPingRequest(const char *serviceName, const char *bc)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ws_accountPingRequest");
}

Cws_accountPingRequest::Cws_accountPingRequest(const char *serviceName, IRpcMessage* rpcmsg)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ws_accountPingRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

Cws_accountPingRequest::Cws_accountPingRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ws_accountPingRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &Cws_accountPingRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType><xsd:all/></xsd:complexType></xsd:element>\n", msgTypeName);
		}
	}
	return schema;
}

void Cws_accountPingRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void Cws_accountPingRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &Cws_accountPingRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &Cws_accountPingRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void Cws_accountPingRequest::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

}


void Cws_accountPingRequest::copy(Cws_accountPingRequest &from)
{
}


void Cws_accountPingRequest::copy(IConstws_accountPingRequest &ifrom)
{
}


void Cws_accountPingRequest::getAttributes(IProperties &attributes)
{
}


void Cws_accountPingRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
}


void Cws_accountPingRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void Cws_accountPingRequest::serializer(IEspContext* ctx, IConstws_accountPingRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<ws_accountPingRequest>");
	if (keepRootTag)
		buffer.append("</ws_accountPingRequest>");
}

bool Cws_accountPingRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	return hasValue;
}

bool Cws_accountPingRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	return hasValue;
}

bool Cws_accountPingRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	return hasValue;
}

extern "C"  IEspws_accountPingRequest *createws_accountPingRequest(const char *serv){return ((IEspws_accountPingRequest *)new Cws_accountPingRequest(serv));}
extern "C"  IClientws_accountPingRequest *createClientws_accountPingRequest(const char *serv){return ((IClientws_accountPingRequest *)new Cws_accountPingRequest(serv));}

//=======================================================
// class Cws_accountPingResponse Implementation
//=======================================================

Cws_accountPingResponse::Cws_accountPingResponse(const char *serviceName, IRpcMessageBinding *init)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ws_accountPingResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

Cws_accountPingResponse::Cws_accountPingResponse(const char *serviceName, const char *bc)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ws_accountPingResponse");
}

Cws_accountPingResponse::Cws_accountPingResponse(const char *serviceName, IRpcMessage* rpcmsg)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ws_accountPingResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

Cws_accountPingResponse::Cws_accountPingResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ws_accountPingResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &Cws_accountPingResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType><xsd:all/></xsd:complexType></xsd:element>\n", msgTypeName);
		}
	}
	return schema;
}

void Cws_accountPingResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void Cws_accountPingResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &Cws_accountPingResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &Cws_accountPingResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void Cws_accountPingResponse::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
	}
}


void Cws_accountPingResponse::copy(Cws_accountPingResponse &from)
{
}


void Cws_accountPingResponse::copy(IConstws_accountPingResponse &ifrom)
{
}


void Cws_accountPingResponse::getAttributes(IProperties &attributes)
{
}


void Cws_accountPingResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
	}
}


void Cws_accountPingResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void Cws_accountPingResponse::serializer(IEspContext* ctx, IConstws_accountPingResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<ws_accountPingResponse>");
	if (keepRootTag)
		buffer.append("</ws_accountPingResponse>");
}

bool Cws_accountPingResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
	}
	return hasValue;
}

bool Cws_accountPingResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	return hasValue;
}

bool Cws_accountPingResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	return hasValue;
}

extern "C"  IEspws_accountPingResponse *createws_accountPingResponse(const char *serv){return ((IEspws_accountPingResponse *)new Cws_accountPingResponse(serv));}
extern "C"  IClientws_accountPingResponse *createClientws_accountPingResponse(const char *serv){return ((IClientws_accountPingResponse *)new Cws_accountPingResponse(serv));}

//=======================================================
// class Cws_accountSoapBinding Implementation
//=======================================================

Cws_accountSoapBinding::Cws_accountSoapBinding(http_soap_log_level level):CHttpSoapBinding(NULL, NULL, NULL, level)
{
	init_strings();
	setWsdlVersion(1.03);
}

Cws_accountSoapBinding::Cws_accountSoapBinding(IPropertyTree* cfg, const char *bindname, const char *procname, http_soap_log_level level):CHttpSoapBinding(cfg, bindname, procname, level)
{
	init_strings(); 
	setWsdlVersion(1.03);

}

void Cws_accountSoapBinding::init_strings()
{
}

int Cws_accountSoapBinding::processRequest(IRpcMessage* rpc_call, IRpcMessage* rpc_response)
{
	if(rpc_call == NULL || rpc_response == NULL)
		return -1;

	IEspContext *ctx=rpc_call->queryContext();
	DBGLOG("Client version: %g", ctx->getClientVersion());
	StringBuffer serviceName;
	double clientVer=(ctx) ? ctx->getClientVersion() : 0.0;
	qualifyServiceName(*ctx, ctx->queryServiceName(NULL), NULL, serviceName, NULL);
	CRpcCall* thecall = static_cast<CRpcCall *>(rpc_call);
	CRpcResponse* response = static_cast<CRpcResponse*>(rpc_response);
	CHttpRequest* httprequest = thecall->getHttpReq();
	CHttpResponse* httpresponse = response->getHttpResp();

	Owned<IEspws_account> iserv = (IEspws_account*)getService();
	if(iserv == NULL)
	{
		response->set_status(SOAP_SERVER_ERROR);
		response->set_err("Service not available");
		DBGLOG("Service not available");
		return -1;
	}
	if (thecall->get_name() == NULL)
	{
		response->set_status(SOAP_CLIENT_ERROR);
		response->set_err("No service method specified");
		ERRLOG("No service method specified");
		return -1;
	}

	IEspContext& context = *rpc_call->queryContext();

	if(!stricmp(thecall->get_name(), "MyAccount")||!stricmp(thecall->get_name(), "MyAccountRequest"))
	{
		Owned<CMyAccountRequest> esp_request = new CMyAccountRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CMyAccountResponse> esp_response = new CMyAccountResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		StringBuffer source;
		source.appendf("ws_account::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "ws_account", "MyAccount");
			iserv->onMyAccount(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "ws_account", "MyAccount");
		response->set_name("MyAccountResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "Ping")||!stricmp(thecall->get_name(), "ws_accountPingRequest"))
	{
		Owned<Cws_accountPingRequest> esp_request = new Cws_accountPingRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<Cws_accountPingResponse> esp_response = new Cws_accountPingResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		StringBuffer source;
		source.appendf("ws_account::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "ws_account", "Ping");
			iserv->onPing(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "ws_account", "Ping");
		response->set_name("ws_accountPingResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "UpdateUser")||!stricmp(thecall->get_name(), "UpdateUserRequest"))
	{
		Owned<CUpdateUserRequest> esp_request = new CUpdateUserRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CUpdateUserResponse> esp_response = new CUpdateUserResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		StringBuffer source;
		source.appendf("ws_account::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "ws_account", "UpdateUser");
			iserv->onUpdateUser(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "ws_account", "UpdateUser");
		response->set_name("UpdateUserResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "UpdateUserInput")||!stricmp(thecall->get_name(), "UpdateUserInputRequest"))
	{
		Owned<CUpdateUserInputRequest> esp_request = new CUpdateUserInputRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CUpdateUserInputResponse> esp_response = new CUpdateUserInputResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		StringBuffer source;
		source.appendf("ws_account::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "ws_account", "UpdateUserInput");
			iserv->onUpdateUserInput(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "ws_account", "UpdateUserInput");
		response->set_name("UpdateUserInputResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "VerifyUser")||!stricmp(thecall->get_name(), "VerifyUserRequest"))
	{
		Owned<CVerifyUserRequest> esp_request = new CVerifyUserRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CVerifyUserResponse> esp_response = new CVerifyUserResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		StringBuffer source;
		source.appendf("ws_account::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "ws_account", "VerifyUser");
			iserv->onVerifyUser(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "ws_account", "VerifyUser");
		response->set_name("VerifyUserResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	response->set_status(SOAP_CLIENT_ERROR);
	StringBuffer msg, svcName;
	msg.appendf("Method %s not available in service %s",thecall->get_name(),getServiceName(svcName).str());
	ERRLOG("%s", msg.str());
	response->set_err(msg);
	return -1;
}

int Cws_accountSoapBinding::getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &content, const char *service, const char *method, bool mda)
{
	BoolHash added;
	if (context.getClientVersion()<=0)
		context.setClientVersion(1.03);

	DBGLOG("Client version: %g", context.getClientVersion());
	bool fullservice = (!Utils::strcasecmp(service, "ws_account"));
	bool allMethods = (method==NULL || *method==0);
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "MyAccount"))) || Utils::strcasecmp(method, "MyAccount")==0)
	{
		CMyAccountRequest::getMapInfo(context.queryMapInfo());
		CMyAccountResponse::getMapInfo(context.queryMapInfo());
		CMyAccountRequest::getXsdDefinition(context, request, "MyAccountRequest", content, added);
		CMyAccountResponse::getXsdDefinition(context, request, content, added);
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "Ping"))) || Utils::strcasecmp(method, "Ping")==0)
	{
		Cws_accountPingRequest::getMapInfo(context.queryMapInfo());
		Cws_accountPingResponse::getMapInfo(context.queryMapInfo());
		Cws_accountPingRequest::getXsdDefinition(context, request, "ws_accountPingRequest", content, added);
		Cws_accountPingResponse::getXsdDefinition(context, request, content, added);
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "UpdateUser"))) || Utils::strcasecmp(method, "UpdateUser")==0)
	{
		CUpdateUserRequest::getMapInfo(context.queryMapInfo());
		CUpdateUserResponse::getMapInfo(context.queryMapInfo());
		CUpdateUserRequest::getXsdDefinition(context, request, "UpdateUserRequest", content, added);
		CUpdateUserResponse::getXsdDefinition(context, request, content, added);
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "UpdateUserInput"))) || Utils::strcasecmp(method, "UpdateUserInput")==0)
	{
		CUpdateUserInputRequest::getMapInfo(context.queryMapInfo());
		CUpdateUserInputResponse::getMapInfo(context.queryMapInfo());
		CUpdateUserInputRequest::getXsdDefinition(context, request, "UpdateUserInputRequest", content, added);
		CUpdateUserInputResponse::getXsdDefinition(context, request, content, added);
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "VerifyUser"))) || Utils::strcasecmp(method, "VerifyUser")==0)
	{
		CVerifyUserRequest::getMapInfo(context.queryMapInfo());
		CVerifyUserResponse::getMapInfo(context.queryMapInfo());
		CVerifyUserRequest::getXsdDefinition(context, request, "VerifyUserRequest", content, added);
		CVerifyUserResponse::getXsdDefinition(context, request, content, added);
	}
	return 0;
}

int Cws_accountSoapBinding::getMethodHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &page, bool bIncludeFormTag)
{
	DBGLOG("Client version: %g", context.getClientVersion());
	if (Utils::strcasecmp(method, "MyAccount")==0)
	{
		CMyAccountRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "Ping")==0)
	{
		Cws_accountPingRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "UpdateUser")==0)
	{
		CUpdateUserRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "UpdateUserInput")==0)
	{
		CUpdateUserInputRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "VerifyUser")==0)
	{
		CVerifyUserRequest::getHtmlForm(context, request, serv, method, page);
	}
	return 0;
}

int Cws_accountSoapBinding::getQualifiedNames(IEspContext& ctx, MethodInfoArray & methods)
{
	double ver = ctx.getClientVersion();
	if (ver<=0)
		ver = getWsdlVersion();
	const char *servname=ctx.queryServiceName(NULL);
	bool fullservice = (!stricmp(servname, "esp")||!stricmp(servname, "ws_account"));
	if ((fullservice || isMethodInSubService(ctx, servname, "MyAccount")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("MyAccount", "MyAccountRequest", "MyAccountResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "Ping")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("Ping", "ws_accountPingRequest", "ws_accountPingResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "UpdateUser")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("UpdateUser", "UpdateUserRequest", "UpdateUserResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "UpdateUserInput")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("UpdateUserInput", "UpdateUserInputRequest", "UpdateUserInputResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "VerifyUser")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("VerifyUser", "VerifyUserRequest", "VerifyUserResponse"));
	return methods.ordinality();
}

StringBuffer & Cws_accountSoapBinding::getServiceName(StringBuffer &resp)
{
	resp.append("ws_account");
	return resp;
}

bool Cws_accountSoapBinding::isValidServiceName(IEspContext &context, const char *name)
{
	if (!Utils::strcasecmp(name, "ws_account"))
		return true;
	else
		return (hasSubService(context, name));
}

bool Cws_accountSoapBinding::qualifyMethodName(IEspContext &context, const char *methname, StringBuffer *methQName)
{
	if (!methname || !*methname)
	{
		if (methQName!=NULL)
			methQName->clear();
		return true;
	}
	if (Utils::strcasecmp(methname, "MyAccount")==0)
	{
		if (methQName!=NULL)
			methQName->set("MyAccount");
		return true;
	}
	if (Utils::strcasecmp(methname, "Ping")==0)
	{
		if (methQName!=NULL)
			methQName->set("Ping");
		return true;
	}
	if (Utils::strcasecmp(methname, "UpdateUser")==0)
	{
		if (methQName!=NULL)
			methQName->set("UpdateUser");
		return true;
	}
	if (Utils::strcasecmp(methname, "UpdateUserInput")==0)
	{
		if (methQName!=NULL)
			methQName->set("UpdateUserInput");
		return true;
	}
	if (Utils::strcasecmp(methname, "VerifyUser")==0)
	{
		if (methQName!=NULL)
			methQName->set("VerifyUser");
		return true;
	}
	return false;
}

bool Cws_accountSoapBinding::qualifyServiceName(IEspContext &context, const char *servname, const char *methname, StringBuffer &servQName, StringBuffer *methQName)
{
	servQName.clear();
	if (!Utils::strcasecmp(servname, "ws_account"))
	{
		servQName.append("ws_account");
		return qualifyMethodName(context, methname, methQName);
	}
	return qualifySubServiceName(context, servname, methname, servQName, methQName);
}

int Cws_accountSoapBinding::onGetFile(IEspContext &context, CHttpRequest* request, CHttpResponse* response, const char *pathex)
{
	if(request == NULL || response == NULL)
		return -1;
	StringBuffer mimetype;
	MemoryBuffer content;

	StringBuffer filepath;
	getBaseFilePath(filepath);
	if (strchr("\\/", filepath.charAt(filepath.length()-1))==NULL)
		filepath.append("/");
	filepath.append(pathex);
	response->httpContentFromFile(filepath.str());
	response->send();
	return 0;
}

int Cws_accountSoapBinding::onGetForm(IEspContext &context, CHttpRequest* request, CHttpResponse* response, const char *service, const char *method)
{
	if (context.getClientVersion()<=0)
		context.setClientVersion(1.03);

	if (!stricmp("MyAccount", method)) {
		CMyAccountRequest::getMapInfo(context.queryMapInfo());
		CMyAccountResponse::getMapInfo(context.queryMapInfo());
	}
	if (!stricmp("Ping", method)) {
		Cws_accountPingRequest::getMapInfo(context.queryMapInfo());
		Cws_accountPingResponse::getMapInfo(context.queryMapInfo());
	}
	if (!stricmp("UpdateUser", method)) {
		CUpdateUserRequest::getMapInfo(context.queryMapInfo());
		CUpdateUserResponse::getMapInfo(context.queryMapInfo());
	}
	if (!stricmp("UpdateUserInput", method)) {
		CUpdateUserInputRequest::getMapInfo(context.queryMapInfo());
		CUpdateUserInputResponse::getMapInfo(context.queryMapInfo());
	}
	if (!stricmp("VerifyUser", method)) {
		CVerifyUserRequest::getMapInfo(context.queryMapInfo());
		CVerifyUserResponse::getMapInfo(context.queryMapInfo());
	}

	return EspHttpBinding::onGetForm(context, request, response, service, method);
}
int Cws_accountSoapBinding::onGetXForm(IEspContext &context, CHttpRequest* request, CHttpResponse* response, const char *service, const char *method)
{
	return EspHttpBinding::onGetXForm(context, request, response, service, method);
}

int Cws_accountSoapBinding::onGetService(IEspContext &context, CHttpRequest* request, CHttpResponse* response, const char *service, const char *method, const char *pathex)
{
	if(request == NULL || response == NULL)
		return -1;
	return onGetQuery(context, request, response, service, method);
}

 IRpcRequestBinding *Cws_accountSoapBinding::createReqBinding(IEspContext &context, IHttpMessage *ireq, const char *service, const char *method)
{
	CHttpRequest *request=static_cast<CHttpRequest*>(ireq);
	IProperties *props = (request) ? request->queryParameters() : NULL;

	if (!stricmp(method, "MyAccount") || !stricmp(method, "MyAccountRequest"))
		return new CMyAccountRequest(&context, "ws_account", props, NULL);
	if (!stricmp(method, "Ping") || !stricmp(method, "ws_accountPingRequest"))
		return new Cws_accountPingRequest(&context, "ws_account", props, NULL);
	if (!stricmp(method, "UpdateUser") || !stricmp(method, "UpdateUserRequest"))
		return new CUpdateUserRequest(&context, "ws_account", props, NULL);
	if (!stricmp(method, "UpdateUserInput") || !stricmp(method, "UpdateUserInputRequest"))
		return new CUpdateUserInputRequest(&context, "ws_account", props, NULL);
	if (!stricmp(method, "VerifyUser") || !stricmp(method, "VerifyUserRequest"))
		return new CVerifyUserRequest(&context, "ws_account", props, NULL);
	return NULL;
}

int Cws_accountSoapBinding::onGetInstantQuery(IEspContext &context, CHttpRequest* request, CHttpResponse* response, const char *service, const char *method)
{
	if (context.getClientVersion()<=0)
		context.setClientVersion(1.03);

	if(request == NULL || response == NULL)
		return -1;
	StringBuffer respStr;
	Owned<IEspws_account> iserv = (IEspws_account*)getService();
	if(iserv == NULL)
	{
		respStr.append("Service not available");
		response->setContent(respStr.str());
		response->setContentType("text/html");
		response->send();
	}
	else
	{
		Owned<CSoapResponseBinding> esp_response;
		StringBuffer source;
		IEspContext& context = *request->queryContext();
		if(!stricmp(method, "MyAccount")||!stricmp(method, "MyAccountRequest"))
		{
			Owned<CMyAccountRequest> esp_request = new CMyAccountRequest(&context, "ws_account", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			Owned<CMyAccountResponse> esp_response = new CMyAccountResponse("ws_account");
			StringBuffer source;
			source.appendf("ws_account::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				iserv->onMyAccount(*request->queryContext(), *esp_request.get(), *esp_response.get());
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "ws_account", "MyAccount", StringBuffer(getCFD()).append("./smc_xslt/exceptions.xslt").str()))
				return 0;
			if (canRedirect(*request) && esp_response->getRedirectUrl() && *esp_response->getRedirectUrl())
			{
				response->redirect(*request, esp_response->getRedirectUrl());
			}
			else
			{
				IProperties *props=request->queryParameters();
				if (skipXslt(context))
				{
					MemoryBuffer content;
					StringBuffer mimetype;
					esp_response->appendContent(&context,content, mimetype);
					onBeforeSendResponse(context,request,content,service,method);
					response->setContent(content.length(), content.toByteArray());
					response->setContentType(mimetype.str());
				}
				else
				{
					StringBuffer xml;
					StringBuffer sResponse;
					if (request->supportClientXslt())
						xml.appendf("<?xml version=\"1.0\" encoding=\"UTF-8\"?><?xml-stylesheet type=\"text/xsl\" href=\"%s\"?>", "/esp/xslt/account_myaccount.xslt");
					esp_response->serializeStruct(&context, xml, NULL);

					if (request->supportClientXslt()){
						xml.swapWith(sResponse);
						response->setContentType("text/xml");
					}else{
					xslTransform(xml.str(), "/esp/xslt/account_myaccount.xslt", sResponse.clear(), context.queryXslParameters());
					response->setContentType("text/html");
					}
					response->setContent(sResponse.str());
				}
				response->send();
			}
			return 0;
		}
		if(!stricmp(method, "Ping")||!stricmp(method, "ws_accountPingRequest"))
		{
			Owned<Cws_accountPingRequest> esp_request = new Cws_accountPingRequest(&context, "ws_account", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			Cws_accountPingResponse* resp = new Cws_accountPingResponse("ws_account");
			esp_response.setown(resp);
			MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
			source.setf("ws_account::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				if(accessmap.ordinality()>0)
					onFeaturesAuthorize(context, accessmap, "ws_account", "Ping");
				iserv->onPing(context, *esp_request.get(), *resp);
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "ws_account", "Ping", StringBuffer(getCFD()).append("./smc_xslt/exceptions.xslt").str()))
				return 0;
		}
		if(!stricmp(method, "UpdateUser")||!stricmp(method, "UpdateUserRequest"))
		{
			Owned<CUpdateUserRequest> esp_request = new CUpdateUserRequest(&context, "ws_account", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			Owned<CUpdateUserResponse> esp_response = new CUpdateUserResponse("ws_account");
			StringBuffer source;
			source.appendf("ws_account::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				iserv->onUpdateUser(*request->queryContext(), *esp_request.get(), *esp_response.get());
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "ws_account", "UpdateUser", StringBuffer(getCFD()).append("./smc_xslt/exceptions.xslt").str()))
				return 0;
			if (canRedirect(*request) && esp_response->getRedirectUrl() && *esp_response->getRedirectUrl())
			{
				response->redirect(*request, esp_response->getRedirectUrl());
			}
			else
			{
				IProperties *props=request->queryParameters();
				if (skipXslt(context))
				{
					MemoryBuffer content;
					StringBuffer mimetype;
					esp_response->appendContent(&context,content, mimetype);
					onBeforeSendResponse(context,request,content,service,method);
					response->setContent(content.length(), content.toByteArray());
					response->setContentType(mimetype.str());
				}
				else
				{
					StringBuffer xml;
					StringBuffer sResponse;
					esp_response->serializeStruct(&context, xml, NULL);

					xslTransform(xml.str(), StringBuffer(getCFD()).append("./smc_xslt/account.xslt").str(), sResponse.clear(), context.queryXslParameters());
					response->setContentType("text/html");
					response->setContent(sResponse.str());
				}
				response->send();
			}
			return 0;
		}
		if(!stricmp(method, "UpdateUserInput")||!stricmp(method, "UpdateUserInputRequest"))
		{
			Owned<CUpdateUserInputRequest> esp_request = new CUpdateUserInputRequest(&context, "ws_account", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			Owned<CUpdateUserInputResponse> esp_response = new CUpdateUserInputResponse("ws_account");
			StringBuffer source;
			source.appendf("ws_account::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				iserv->onUpdateUserInput(*request->queryContext(), *esp_request.get(), *esp_response.get());
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "ws_account", "UpdateUserInput", StringBuffer(getCFD()).append("./smc_xslt/exceptions.xslt").str()))
				return 0;
			if (canRedirect(*request) && esp_response->getRedirectUrl() && *esp_response->getRedirectUrl())
			{
				response->redirect(*request, esp_response->getRedirectUrl());
			}
			else
			{
				IProperties *props=request->queryParameters();
				if (skipXslt(context))
				{
					MemoryBuffer content;
					StringBuffer mimetype;
					esp_response->appendContent(&context,content, mimetype);
					onBeforeSendResponse(context,request,content,service,method);
					response->setContent(content.length(), content.toByteArray());
					response->setContentType(mimetype.str());
				}
				else
				{
					StringBuffer xml;
					StringBuffer sResponse;
					if (request->supportClientXslt())
						xml.appendf("<?xml version=\"1.0\" encoding=\"UTF-8\"?><?xml-stylesheet type=\"text/xsl\" href=\"%s\"?>", "/esp/xslt/account_input.xslt");
					esp_response->serializeStruct(&context, xml, NULL);

					if (request->supportClientXslt()){
						xml.swapWith(sResponse);
						response->setContentType("text/xml");
					}else{
					xslTransform(xml.str(), "/esp/xslt/account_input.xslt", sResponse.clear(), context.queryXslParameters());
					response->setContentType("text/html");
					}
					response->setContent(sResponse.str());
				}
				response->send();
			}
			return 0;
		}
		if(!stricmp(method, "VerifyUser")||!stricmp(method, "VerifyUserRequest"))
		{
			Owned<CVerifyUserRequest> esp_request = new CVerifyUserRequest(&context, "ws_account", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			CVerifyUserResponse* resp = new CVerifyUserResponse("ws_account");
			esp_response.setown(resp);
			MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
			source.setf("ws_account::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				if(accessmap.ordinality()>0)
					onFeaturesAuthorize(context, accessmap, "ws_account", "VerifyUser");
				iserv->onVerifyUser(context, *esp_request.get(), *resp);
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "ws_account", "VerifyUser", StringBuffer(getCFD()).append("./smc_xslt/exceptions.xslt").str()))
				return 0;
		}

		if (esp_response.get())
		{
			if (canRedirect(*request) && esp_response->getRedirectUrl() && *esp_response->getRedirectUrl())
				response->redirect(*request, esp_response->getRedirectUrl());
			else
			{
				MemoryBuffer content;
				StringBuffer mimetype;
				esp_response->appendContent(&context,content, mimetype);
				onBeforeSendResponse(context,request,content,service,method);
				response->setContent(content.length(), content.toByteArray());
				response->setContentType(mimetype.str());
				response->send();
			}
			return 0;
		}
	}
	return onGetNotFound(context, request,  response, service);
}





//=======================================================
// client util methods
//=======================================================

//------ method MyAccount ---------

IClientMyAccountRequest * CClientws_account::createMyAccountRequest()
{
	CMyAccountRequest* request = new CMyAccountRequest("ws_account");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientMyAccountResponse * CClientws_account::MyAccount(IClientMyAccountRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CMyAccountRequest* esprequest = static_cast<CMyAccountRequest*>(request);
	CMyAccountResponse* espresponse = new CMyAccountResponse("ws_account");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientws_account::async_MyAccount(IClientMyAccountRequest *request, IClientws_accountEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CMyAccountRequest* esprequest = static_cast<CMyAccountRequest*>(request);
	esprequest->setMethod("MyAccount");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientws_account::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientMyAccountResponse *CClientws_account::MyAccountFn()
{
	Owned<IClientMyAccountRequest> req =  createMyAccountRequest();
	return MyAccount(req.get());
}

//------ method Ping ---------

IClientws_accountPingRequest * CClientws_account::createPingRequest()
{
	Cws_accountPingRequest* request = new Cws_accountPingRequest("ws_account");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientws_accountPingResponse * CClientws_account::Ping(IClientws_accountPingRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	Cws_accountPingRequest* esprequest = static_cast<Cws_accountPingRequest*>(request);
	Cws_accountPingResponse* espresponse = new Cws_accountPingResponse("ws_account");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientws_account::async_Ping(IClientws_accountPingRequest *request, IClientws_accountEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	Cws_accountPingRequest* esprequest = static_cast<Cws_accountPingRequest*>(request);
	esprequest->setMethod("Ping");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientws_account::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientws_accountPingResponse *CClientws_account::PingFn()
{
	Owned<IClientws_accountPingRequest> req =  createPingRequest();
	return Ping(req.get());
}

//------ method UpdateUser ---------

IClientUpdateUserRequest * CClientws_account::createUpdateUserRequest()
{
	CUpdateUserRequest* request = new CUpdateUserRequest("ws_account");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientUpdateUserResponse * CClientws_account::UpdateUser(IClientUpdateUserRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CUpdateUserRequest* esprequest = static_cast<CUpdateUserRequest*>(request);
	CUpdateUserResponse* espresponse = new CUpdateUserResponse("ws_account");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientws_account::async_UpdateUser(IClientUpdateUserRequest *request, IClientws_accountEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CUpdateUserRequest* esprequest = static_cast<CUpdateUserRequest*>(request);
	esprequest->setMethod("UpdateUser");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientws_account::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientUpdateUserResponse *CClientws_account::UpdateUserFn(const char * username_, const char * oldpass_, const char * newpass1_, const char * newpass2_)
{
	Owned<IClientUpdateUserRequest> req =  createUpdateUserRequest();
	req->setUsername(username_);
	req->setOldpass(oldpass_);
	req->setNewpass1(newpass1_);
	req->setNewpass2(newpass2_);
	return UpdateUser(req.get());
}

//------ method UpdateUserInput ---------

IClientUpdateUserInputRequest * CClientws_account::createUpdateUserInputRequest()
{
	CUpdateUserInputRequest* request = new CUpdateUserInputRequest("ws_account");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientUpdateUserInputResponse * CClientws_account::UpdateUserInput(IClientUpdateUserInputRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CUpdateUserInputRequest* esprequest = static_cast<CUpdateUserInputRequest*>(request);
	CUpdateUserInputResponse* espresponse = new CUpdateUserInputResponse("ws_account");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientws_account::async_UpdateUserInput(IClientUpdateUserInputRequest *request, IClientws_accountEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CUpdateUserInputRequest* esprequest = static_cast<CUpdateUserInputRequest*>(request);
	esprequest->setMethod("UpdateUserInput");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientws_account::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientUpdateUserInputResponse *CClientws_account::UpdateUserInputFn()
{
	Owned<IClientUpdateUserInputRequest> req =  createUpdateUserInputRequest();
	return UpdateUserInput(req.get());
}

//------ method VerifyUser ---------

IClientVerifyUserRequest * CClientws_account::createVerifyUserRequest()
{
	CVerifyUserRequest* request = new CVerifyUserRequest("ws_account");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientVerifyUserResponse * CClientws_account::VerifyUser(IClientVerifyUserRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CVerifyUserRequest* esprequest = static_cast<CVerifyUserRequest*>(request);
	CVerifyUserResponse* espresponse = new CVerifyUserResponse("ws_account");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientws_account::async_VerifyUser(IClientVerifyUserRequest *request, IClientws_accountEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CVerifyUserRequest* esprequest = static_cast<CVerifyUserRequest*>(request);
	esprequest->setMethod("VerifyUser");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientws_account::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientVerifyUserResponse *CClientws_account::VerifyUserFn(const char * application_, const char * version_)
{
	Owned<IClientVerifyUserRequest> req =  createVerifyUserRequest();
	req->setApplication(application_);
	req->setVersion(version_);
	return VerifyUser(req.get());
}

int CClientws_account::transferThunkEvent(void *data)
{
	IRpcResponseBinding *response = (IRpcResponseBinding *)data;
	if (response!=NULL)
	{
		IClientws_accountEvents *eventSink = (IClientws_accountEvents *)response->getEventSink();
		response->lock();

		if (stricmp(response->getMethod(), "MyAccount")==0)
		{
			IClientMyAccountResponse* icresp = dynamic_cast<IClientMyAccountResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onMyAccountComplete(icresp, response->queryState());
				else
					eventSink->onMyAccountError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "Ping")==0)
		{
			IClientws_accountPingResponse* icresp = dynamic_cast<IClientws_accountPingResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onPingComplete(icresp, response->queryState());
				else
					eventSink->onPingError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "UpdateUser")==0)
		{
			IClientUpdateUserResponse* icresp = dynamic_cast<IClientUpdateUserResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onUpdateUserComplete(icresp, response->queryState());
				else
					eventSink->onUpdateUserError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "UpdateUserInput")==0)
		{
			IClientUpdateUserInputResponse* icresp = dynamic_cast<IClientUpdateUserInputResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onUpdateUserInputComplete(icresp, response->queryState());
				else
					eventSink->onUpdateUserInputError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "VerifyUser")==0)
		{
			IClientVerifyUserResponse* icresp = dynamic_cast<IClientVerifyUserResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onVerifyUserComplete(icresp, response->queryState());
				else
					eventSink->onVerifyUserError(icresp,response->queryState());
			}
		}
		response->unlock();
	}
	return 0;
}

static IRpcResponseBinding* createws_accountResponseObject(IRpcRequestBinding *request)
{
	const char* method = request->getMethod();
	if (stricmp(method, "MyAccount")==0)
		return new CMyAccountResponse("ws_account", request);
	if (stricmp(method, "Ping")==0)
		return new Cws_accountPingResponse("ws_account", request);
	if (stricmp(method, "UpdateUser")==0)
		return new CUpdateUserResponse("ws_account", request);
	if (stricmp(method, "UpdateUserInput")==0)
		return new CUpdateUserInputResponse("ws_account", request);
	if (stricmp(method, "VerifyUser")==0)
		return new CVerifyUserResponse("ws_account", request);
	return NULL;
}

#ifdef _WIN32
void CClientws_account::espWorkerThread(void* data)
#else
void *CClientws_account::espWorkerThread(void *data)
#endif
{
	IRpcRequestBinding *request = (IRpcRequestBinding *) data;

	if (request != NULL)
	{
		request->lock();
		IRpcResponseBinding *response=createws_accountResponseObject(request);
		if (response!=NULL)
		{
			try{
				request->post(*response);
			}
			catch(IException* ex){
				StringBuffer errorStr;
				ex->errorMessage(errorStr);
				ERRLOG("CClientws_account::espWorkerThread(%s)--Exception caught while posting async request: %s", request->getMethod(), errorStr.str());
				ex->Release();
			}
			catch(...){
				ERRLOG("Unknown exception caught while posting async request");
			}
		}
#ifdef USE_CLIENT_THREAD
		ThunkToClientThread(request->getThunkHandle(), transferThunkEvent, (void *)response);
#else
		transferThunkEvent((void *)response);
#endif
		request->unlock();
		if(request->queryState()!=NULL)
			request->queryState()->Release();

		if(response!=NULL)
			response->Release();

		request->Release();
	}
#if defined(_WIN32)
#else
	return (void *) 0 ;
#endif
}



extern "C" IClientws_account * createws_accountClient() {  return new CClientws_account(); }


#endif //ws_account_ESPGEN_INCLUDED
