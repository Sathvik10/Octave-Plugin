// *** Source file generated by HIDL Version 1.3 from ws_loggingservice.ecm ***
// *** Not to be hand edited (changes will be lost on re-generation) ***

#ifndef ws_loggingservice_ESPGEN_INCLUDED
#define ws_loggingservice_ESPGEN_INCLUDED

#include "ws_loggingservice_esp.ipp"

#ifdef _WIN32
#include "edwin.h"
#include <process.h>
#endif



//=======================================================
// class CLogItem Implementation
//=======================================================

CLogItem::CLogItem(const char *serviceName, IRpcMessageBinding *init)
	: m_Name(nilIgnore),m_Value(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("LogItem");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CLogItem::CLogItem(const char *serviceName, const char *bc)
	: m_Name(nilIgnore),m_Value(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("LogItem");
}

StringBuffer &CLogItem::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:complexType name=\"%s\">\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Name\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Value\" type=\"xsd:string\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType>\n");
		}
	}
	return schema;
}

void CLogItem::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CLogItem::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CLogItem::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Name");
	form.appendf("  <tr><td><b>Name: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Value");
	form.appendf("  <tr><td><b>Value: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CLogItem::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CLogItem::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_Name.marshall(rpc_resp, "Name", "", "", "");
	m_Value.marshall(rpc_resp, "Value", "", "", "");
}


void CLogItem::copy(CLogItem &from)
{
	m_Name.copy(from.m_Name);
	m_Value.copy(from.m_Value);
}


void CLogItem::copy(IConstLogItem &ifrom)
{
	setName(ifrom.getName());
	setValue(ifrom.getValue());
}


void CLogItem::getAttributes(IProperties &attributes)
{
}


void CLogItem::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_Name.toStr(ctx, buffer, "Name", "", true, "", "");
	m_Value.toStr(ctx, buffer, "Value", "", true, "", "");
}


void CLogItem::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CLogItem::serializer(IEspContext* ctx, IConstLogItem &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<LogItem>");
	// field Name
	{
		const char* s = src.getName();
		if (s && *s)
		{
			buffer.append("<Name>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Name>");
		}
	}
	// field Value
	{
		const char* s = src.getValue();
		if (s && *s)
		{
			buffer.append("<Value>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Value>");
		}
	}
	if (keepRootTag)
		buffer.append("</LogItem>");
}

bool CLogItem::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_Name.unmarshall(rpc_request, "Name", basepath);
	hasValue |= m_Value.unmarshall(rpc_request, "Value", basepath);
	return hasValue;
}

bool CLogItem::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Name.unmarshall(ctx, soapval, "Name");
	hasValue |= m_Value.unmarshall(ctx, soapval, "Value");
	return hasValue;
}

bool CLogItem::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Name.unmarshall(ctx, params, attachments, "Name", basepath);
	hasValue |= m_Value.unmarshall(ctx, params, attachments, "Value", basepath);
	return hasValue;
}

const char * CLogItem::getName() { return m_Name.query();}
const char * CLogItem::getValue() { return m_Value.query();}
void CLogItem::setName(const char * val){ m_Name.set(val); }
void CLogItem::setValue(const char * val){ m_Value.set(val); }
extern "C"  IEspLogItem *createLogItem(const char *serv, const char *msgname){return ((IEspLogItem *)new CLogItem(serv /*, msgname*/));}
extern "C"  IClientLogItem *createClientLogItem(const char *serv, const char *msgname){return ((IClientLogItem *)new CLogItem(serv /*, msgname*/));}

//=======================================================
// class CGetTransactionSeedRequest Implementation
//=======================================================

CGetTransactionSeedRequest::CGetTransactionSeedRequest(const char *serviceName, IRpcMessageBinding *init)
	: m_Application(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetTransactionSeedRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CGetTransactionSeedRequest::CGetTransactionSeedRequest(const char *serviceName, const char *bc)
	: m_Application(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetTransactionSeedRequest");
}

CGetTransactionSeedRequest::CGetTransactionSeedRequest(const char *serviceName, IRpcMessage* rpcmsg)
	: m_Application(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetTransactionSeedRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CGetTransactionSeedRequest::CGetTransactionSeedRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_Application(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetTransactionSeedRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CGetTransactionSeedRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Application\" type=\"xsd:string\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CGetTransactionSeedRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CGetTransactionSeedRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CGetTransactionSeedRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Application");
	form.appendf("  <tr><td><b>Application: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CGetTransactionSeedRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CGetTransactionSeedRequest::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_Application.marshall(rpc_resp, "Application", "", "", "");
}


void CGetTransactionSeedRequest::copy(CGetTransactionSeedRequest &from)
{
	m_Application.copy(from.m_Application);
}


void CGetTransactionSeedRequest::copy(IConstGetTransactionSeedRequest &ifrom)
{
	setApplication(ifrom.getApplication());
}


void CGetTransactionSeedRequest::getAttributes(IProperties &attributes)
{
}


void CGetTransactionSeedRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_Application.toStr(ctx, buffer, "Application", "", true, "", "");
}


void CGetTransactionSeedRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CGetTransactionSeedRequest::serializer(IEspContext* ctx, IConstGetTransactionSeedRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<GetTransactionSeedRequest>");
	// field Application
	{
		const char* s = src.getApplication();
		if (s && *s)
		{
			buffer.append("<Application>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Application>");
		}
	}
	if (keepRootTag)
		buffer.append("</GetTransactionSeedRequest>");
}

bool CGetTransactionSeedRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_Application.unmarshall(rpc_request, "Application", basepath);
	return hasValue;
}

bool CGetTransactionSeedRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Application.unmarshall(ctx, soapval, "Application");
	return hasValue;
}

bool CGetTransactionSeedRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Application.unmarshall(ctx, params, attachments, "Application", basepath);
	return hasValue;
}

const char * CGetTransactionSeedRequest::getApplication() { return m_Application.query();}
void CGetTransactionSeedRequest::setApplication(const char * val){ m_Application.set(val); }
extern "C"  IEspGetTransactionSeedRequest *createGetTransactionSeedRequest(const char *serv){return ((IEspGetTransactionSeedRequest *)new CGetTransactionSeedRequest(serv));}
extern "C"  IClientGetTransactionSeedRequest *createClientGetTransactionSeedRequest(const char *serv){return ((IClientGetTransactionSeedRequest *)new CGetTransactionSeedRequest(serv));}

//=======================================================
// class CLoggingServiceResponse Implementation
//=======================================================

CLoggingServiceResponse::CLoggingServiceResponse(const char *serviceName, IRpcMessageBinding *init)
	: m_StatusCode(nilIgnore),m_StatusMessage(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("LoggingServiceResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CLoggingServiceResponse::CLoggingServiceResponse(const char *serviceName, const char *bc)
	: m_StatusCode(nilIgnore),m_StatusMessage(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("LoggingServiceResponse");
}

CLoggingServiceResponse::CLoggingServiceResponse(const char *serviceName, IRpcMessage* rpcmsg)
	: m_StatusCode(nilIgnore),m_StatusMessage(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("LoggingServiceResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CLoggingServiceResponse::CLoggingServiceResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_StatusCode(nilIgnore),m_StatusMessage(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("LoggingServiceResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CLoggingServiceResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		schema.append("<xsd:element name=\"Exceptions\" type=\"tns:ArrayOfEspException\" minOccurs=\"0\" maxOccurs=\"1\"/>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"StatusCode\" type=\"xsd:int\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"StatusMessage\" type=\"xsd:string\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CLoggingServiceResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CLoggingServiceResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CLoggingServiceResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix) extfix.append(prefix).append(".");
		extfix.append("StatusCode");
	form.appendf("  <tr><td><b>StatusCode: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("StatusMessage");
	form.appendf("  <tr><td><b>StatusMessage: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CLoggingServiceResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CLoggingServiceResponse::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
		m_StatusCode.marshall(rpc_resp, "StatusCode", "", "", "");
		m_StatusMessage.marshall(rpc_resp, "StatusMessage", "", "", "");
	}
}


void CLoggingServiceResponse::copy(CLoggingServiceResponse &from)
{
	m_StatusCode.copy(from.m_StatusCode);
	m_StatusMessage.copy(from.m_StatusMessage);
}


void CLoggingServiceResponse::copy(IConstLoggingServiceResponse &ifrom)
{
	setStatusCode(ifrom.getStatusCode());
	setStatusMessage(ifrom.getStatusMessage());
}


void CLoggingServiceResponse::getAttributes(IProperties &attributes)
{
}


void CLoggingServiceResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
		m_StatusCode.toStr(ctx, buffer, "StatusCode", "", true, "", "");
		m_StatusMessage.toStr(ctx, buffer, "StatusMessage", "", true, "", "");
	}
}


void CLoggingServiceResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CLoggingServiceResponse::serializer(IEspContext* ctx, IConstLoggingServiceResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<LoggingServiceResponse>");
	// field StatusCode
	{
		int n = src.getStatusCode();
		if (n)
			buffer.appendf("<StatusCode>%d</StatusCode>", n);
	}
	// field StatusMessage
	{
		const char* s = src.getStatusMessage();
		if (s && *s)
		{
			buffer.append("<StatusMessage>");
			encodeUtf8XML(s,buffer);
			buffer.append("</StatusMessage>");
		}
	}
	if (keepRootTag)
		buffer.append("</LoggingServiceResponse>");
}

bool CLoggingServiceResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
		hasValue |= m_StatusCode.unmarshall(rpc_request, "StatusCode", basepath);
		hasValue |= m_StatusMessage.unmarshall(rpc_request, "StatusMessage", basepath);
	}
	return hasValue;
}

bool CLoggingServiceResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_StatusCode.unmarshall(ctx, soapval, "StatusCode");
	hasValue |= m_StatusMessage.unmarshall(ctx, soapval, "StatusMessage");
	return hasValue;
}

bool CLoggingServiceResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_StatusCode.unmarshall(ctx, params, attachments, "StatusCode", basepath);
	hasValue |= m_StatusMessage.unmarshall(ctx, params, attachments, "StatusMessage", basepath);
	return hasValue;
}

int CLoggingServiceResponse::getStatusCode() { return m_StatusCode;}
const char * CLoggingServiceResponse::getStatusMessage() { return m_StatusMessage.query();}
void CLoggingServiceResponse::setStatusCode(int val){ m_StatusCode=val; }
void CLoggingServiceResponse::setStatusMessage(const char * val){ m_StatusMessage.set(val); }
extern "C"  IEspLoggingServiceResponse *createLoggingServiceResponse(const char *serv){return ((IEspLoggingServiceResponse *)new CLoggingServiceResponse(serv));}
extern "C"  IClientLoggingServiceResponse *createClientLoggingServiceResponse(const char *serv){return ((IClientLoggingServiceResponse *)new CLoggingServiceResponse(serv));}

//=======================================================
// class CGetTransactionSeedResponse Implementation
//=======================================================

CGetTransactionSeedResponse::CGetTransactionSeedResponse(const char *serviceName, IRpcMessageBinding *init)
	: m_SeedId(nilIgnore),m_StatusCode(nilIgnore),m_StatusMessage(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetTransactionSeedResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CGetTransactionSeedResponse::CGetTransactionSeedResponse(const char *serviceName, const char *bc)
	: m_SeedId(nilIgnore),m_StatusCode(nilIgnore),m_StatusMessage(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetTransactionSeedResponse");
}

CGetTransactionSeedResponse::CGetTransactionSeedResponse(const char *serviceName, IRpcMessage* rpcmsg)
	: m_SeedId(nilIgnore),m_StatusCode(nilIgnore),m_StatusMessage(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetTransactionSeedResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CGetTransactionSeedResponse::CGetTransactionSeedResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_SeedId(nilIgnore),m_StatusCode(nilIgnore),m_StatusMessage(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetTransactionSeedResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CGetTransactionSeedResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		schema.append("<xsd:element name=\"Exceptions\" type=\"tns:ArrayOfEspException\" minOccurs=\"0\" maxOccurs=\"1\"/>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"SeedId\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"StatusCode\" type=\"xsd:int\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"StatusMessage\" type=\"xsd:string\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CGetTransactionSeedResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CGetTransactionSeedResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CGetTransactionSeedResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("SeedId");
	form.appendf("  <tr><td><b>SeedId: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix) extfix.append(prefix).append(".");
		extfix.append("StatusCode");
	form.appendf("  <tr><td><b>StatusCode: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("StatusMessage");
	form.appendf("  <tr><td><b>StatusMessage: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CGetTransactionSeedResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CGetTransactionSeedResponse::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
		m_SeedId.marshall(rpc_resp, "SeedId", "", "", "");
		m_StatusCode.marshall(rpc_resp, "StatusCode", "", "", "");
		m_StatusMessage.marshall(rpc_resp, "StatusMessage", "", "", "");
	}
}


void CGetTransactionSeedResponse::copy(CGetTransactionSeedResponse &from)
{
	m_SeedId.copy(from.m_SeedId);
	m_StatusCode.copy(from.m_StatusCode);
	m_StatusMessage.copy(from.m_StatusMessage);
}


void CGetTransactionSeedResponse::copy(IConstGetTransactionSeedResponse &ifrom)
{
	setSeedId(ifrom.getSeedId());
	setStatusCode(ifrom.getStatusCode());
	setStatusMessage(ifrom.getStatusMessage());
}


void CGetTransactionSeedResponse::getAttributes(IProperties &attributes)
{
}


void CGetTransactionSeedResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
		m_SeedId.toStr(ctx, buffer, "SeedId", "", true, "", "");
		m_StatusCode.toStr(ctx, buffer, "StatusCode", "", true, "", "");
		m_StatusMessage.toStr(ctx, buffer, "StatusMessage", "", true, "", "");
	}
}


void CGetTransactionSeedResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CGetTransactionSeedResponse::serializer(IEspContext* ctx, IConstGetTransactionSeedResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<GetTransactionSeedResponse>");
	// field SeedId
	{
		const char* s = src.getSeedId();
		if (s && *s)
		{
			buffer.append("<SeedId>");
			encodeUtf8XML(s,buffer);
			buffer.append("</SeedId>");
		}
	}
	// field StatusCode
	{
		int n = src.getStatusCode();
		if (n)
			buffer.appendf("<StatusCode>%d</StatusCode>", n);
	}
	// field StatusMessage
	{
		const char* s = src.getStatusMessage();
		if (s && *s)
		{
			buffer.append("<StatusMessage>");
			encodeUtf8XML(s,buffer);
			buffer.append("</StatusMessage>");
		}
	}
	if (keepRootTag)
		buffer.append("</GetTransactionSeedResponse>");
}

bool CGetTransactionSeedResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
		hasValue |= m_SeedId.unmarshall(rpc_request, "SeedId", basepath);
		hasValue |= m_StatusCode.unmarshall(rpc_request, "StatusCode", basepath);
		hasValue |= m_StatusMessage.unmarshall(rpc_request, "StatusMessage", basepath);
	}
	return hasValue;
}

bool CGetTransactionSeedResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_SeedId.unmarshall(ctx, soapval, "SeedId");
	hasValue |= m_StatusCode.unmarshall(ctx, soapval, "StatusCode");
	hasValue |= m_StatusMessage.unmarshall(ctx, soapval, "StatusMessage");
	return hasValue;
}

bool CGetTransactionSeedResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_SeedId.unmarshall(ctx, params, attachments, "SeedId", basepath);
	hasValue |= m_StatusCode.unmarshall(ctx, params, attachments, "StatusCode", basepath);
	hasValue |= m_StatusMessage.unmarshall(ctx, params, attachments, "StatusMessage", basepath);
	return hasValue;
}

const char * CGetTransactionSeedResponse::getSeedId() { return m_SeedId.query();}
int CGetTransactionSeedResponse::getStatusCode() { return m_StatusCode;}
const char * CGetTransactionSeedResponse::getStatusMessage() { return m_StatusMessage.query();}
void CGetTransactionSeedResponse::setSeedId(const char * val){ m_SeedId.set(val); }
void CGetTransactionSeedResponse::setStatusCode(int val){ m_StatusCode=val; }
void CGetTransactionSeedResponse::setStatusMessage(const char * val){ m_StatusMessage.set(val); }
extern "C"  IEspGetTransactionSeedResponse *createGetTransactionSeedResponse(const char *serv){return ((IEspGetTransactionSeedResponse *)new CGetTransactionSeedResponse(serv));}
extern "C"  IClientGetTransactionSeedResponse *createClientGetTransactionSeedResponse(const char *serv){return ((IClientGetTransactionSeedResponse *)new CGetTransactionSeedResponse(serv));}

//=======================================================
// class CUpdateLogRequest Implementation
//=======================================================

CUpdateLogRequest::CUpdateLogRequest(const char *serviceName, IRpcMessageBinding *init)
	: m_Option(nilRemove),m_LogContent(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("UpdateLogRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CUpdateLogRequest::CUpdateLogRequest(const char *serviceName, const char *bc)
	: m_Option(nilRemove),m_LogContent(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("UpdateLogRequest");
}

CUpdateLogRequest::CUpdateLogRequest(const char *serviceName, IRpcMessage* rpcmsg)
	: m_Option(nilRemove),m_LogContent(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("UpdateLogRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CUpdateLogRequest::CUpdateLogRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_Option(nilRemove),m_LogContent(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("UpdateLogRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CUpdateLogRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Option\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"LogContent\" type=\"xsd:string\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CUpdateLogRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CUpdateLogRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CUpdateLogRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Option");
	form.appendf("  <tr><td><b>Option: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("LogContent");
	form.appendf("  <tr><td><b>LogContent: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CUpdateLogRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CUpdateLogRequest::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_Option.marshall(rpc_resp, "Option", "", "", "");
	m_LogContent.marshall(rpc_resp, "LogContent", "", "", "");
}


void CUpdateLogRequest::copy(CUpdateLogRequest &from)
{
	m_Option.copy(from.m_Option);
	m_LogContent.copy(from.m_LogContent);
}


void CUpdateLogRequest::copy(IConstUpdateLogRequest &ifrom)
{
	setOption(ifrom.getOption());
	setLogContent(ifrom.getLogContent());
}


void CUpdateLogRequest::getAttributes(IProperties &attributes)
{
}


void CUpdateLogRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_Option.toStr(ctx, buffer, "Option", "", true, "", "");
	m_LogContent.toStr(ctx, buffer, "LogContent", "", true, "", "");
}


void CUpdateLogRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CUpdateLogRequest::serializer(IEspContext* ctx, IConstUpdateLogRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<UpdateLogRequest>");
	// field Option
	{
		const char* s = src.getOption();
		if (s && *s)
		{
			buffer.append("<Option>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Option>");
		}
	}
	// field LogContent
	{
		const char* s = src.getLogContent();
		if (s && *s)
		{
			buffer.append("<LogContent>");
			encodeUtf8XML(s,buffer);
			buffer.append("</LogContent>");
		}
	}
	if (keepRootTag)
		buffer.append("</UpdateLogRequest>");
}

bool CUpdateLogRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_Option.unmarshall(rpc_request, "Option", basepath);
	hasValue |= m_LogContent.unmarshall(rpc_request, "LogContent", basepath);
	return hasValue;
}

bool CUpdateLogRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Option.unmarshall(ctx, soapval, "Option");
	hasValue |= m_LogContent.unmarshall(ctx, soapval, "LogContent");
	return hasValue;
}

bool CUpdateLogRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Option.unmarshall(ctx, params, attachments, "Option", basepath);
	hasValue |= m_LogContent.unmarshall(ctx, params, attachments, "LogContent", basepath);
	return hasValue;
}

const char * CUpdateLogRequest::getOption() { return m_Option.query();}
const char * CUpdateLogRequest::getLogContent() { return m_LogContent.query();}
void CUpdateLogRequest::setOption(const char * val){ m_Option.set(val); }
void CUpdateLogRequest::setLogContent(const char * val){ m_LogContent.set(val); }
extern "C"  IEspUpdateLogRequest *createUpdateLogRequest(const char *serv){return ((IEspUpdateLogRequest *)new CUpdateLogRequest(serv));}
extern "C"  IClientUpdateLogRequest *createClientUpdateLogRequest(const char *serv){return ((IClientUpdateLogRequest *)new CUpdateLogRequest(serv));}

//=======================================================
// class CUpdateLogResponse Implementation
//=======================================================

CUpdateLogResponse::CUpdateLogResponse(const char *serviceName, IRpcMessageBinding *init)
	: m_Response(nilIgnore),m_StatusCode(nilIgnore),m_StatusMessage(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("UpdateLogResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CUpdateLogResponse::CUpdateLogResponse(const char *serviceName, const char *bc)
	: m_Response(nilIgnore),m_StatusCode(nilIgnore),m_StatusMessage(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("UpdateLogResponse");
}

CUpdateLogResponse::CUpdateLogResponse(const char *serviceName, IRpcMessage* rpcmsg)
	: m_Response(nilIgnore),m_StatusCode(nilIgnore),m_StatusMessage(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("UpdateLogResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CUpdateLogResponse::CUpdateLogResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_Response(nilIgnore),m_StatusCode(nilIgnore),m_StatusMessage(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("UpdateLogResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CUpdateLogResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		schema.append("<xsd:element name=\"Exceptions\" type=\"tns:ArrayOfEspException\" minOccurs=\"0\" maxOccurs=\"1\"/>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Response\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"StatusCode\" type=\"xsd:int\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"StatusMessage\" type=\"xsd:string\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CUpdateLogResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CUpdateLogResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CUpdateLogResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Response");
	form.appendf("  <tr><td><b>Response: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix) extfix.append(prefix).append(".");
		extfix.append("StatusCode");
	form.appendf("  <tr><td><b>StatusCode: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("StatusMessage");
	form.appendf("  <tr><td><b>StatusMessage: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CUpdateLogResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CUpdateLogResponse::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
		m_Response.marshall(rpc_resp, "Response", "", "", "");
		m_StatusCode.marshall(rpc_resp, "StatusCode", "", "", "");
		m_StatusMessage.marshall(rpc_resp, "StatusMessage", "", "", "");
	}
}


void CUpdateLogResponse::copy(CUpdateLogResponse &from)
{
	m_Response.copy(from.m_Response);
	m_StatusCode.copy(from.m_StatusCode);
	m_StatusMessage.copy(from.m_StatusMessage);
}


void CUpdateLogResponse::copy(IConstUpdateLogResponse &ifrom)
{
	setResponse(ifrom.getResponse());
	setStatusCode(ifrom.getStatusCode());
	setStatusMessage(ifrom.getStatusMessage());
}


void CUpdateLogResponse::getAttributes(IProperties &attributes)
{
}


void CUpdateLogResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
		m_Response.toStr(ctx, buffer, "Response", "", true, "", "");
		m_StatusCode.toStr(ctx, buffer, "StatusCode", "", true, "", "");
		m_StatusMessage.toStr(ctx, buffer, "StatusMessage", "", true, "", "");
	}
}


void CUpdateLogResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CUpdateLogResponse::serializer(IEspContext* ctx, IConstUpdateLogResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<UpdateLogResponse>");
	// field Response
	{
		const char* s = src.getResponse();
		if (s && *s)
		{
			buffer.append("<Response>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Response>");
		}
	}
	// field StatusCode
	{
		int n = src.getStatusCode();
		if (n)
			buffer.appendf("<StatusCode>%d</StatusCode>", n);
	}
	// field StatusMessage
	{
		const char* s = src.getStatusMessage();
		if (s && *s)
		{
			buffer.append("<StatusMessage>");
			encodeUtf8XML(s,buffer);
			buffer.append("</StatusMessage>");
		}
	}
	if (keepRootTag)
		buffer.append("</UpdateLogResponse>");
}

bool CUpdateLogResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
		hasValue |= m_Response.unmarshall(rpc_request, "Response", basepath);
		hasValue |= m_StatusCode.unmarshall(rpc_request, "StatusCode", basepath);
		hasValue |= m_StatusMessage.unmarshall(rpc_request, "StatusMessage", basepath);
	}
	return hasValue;
}

bool CUpdateLogResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Response.unmarshall(ctx, soapval, "Response");
	hasValue |= m_StatusCode.unmarshall(ctx, soapval, "StatusCode");
	hasValue |= m_StatusMessage.unmarshall(ctx, soapval, "StatusMessage");
	return hasValue;
}

bool CUpdateLogResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Response.unmarshall(ctx, params, attachments, "Response", basepath);
	hasValue |= m_StatusCode.unmarshall(ctx, params, attachments, "StatusCode", basepath);
	hasValue |= m_StatusMessage.unmarshall(ctx, params, attachments, "StatusMessage", basepath);
	return hasValue;
}

const char * CUpdateLogResponse::getResponse() { return m_Response.query();}
int CUpdateLogResponse::getStatusCode() { return m_StatusCode;}
const char * CUpdateLogResponse::getStatusMessage() { return m_StatusMessage.query();}
void CUpdateLogResponse::setResponse(const char * val){ m_Response.set(val); }
void CUpdateLogResponse::setStatusCode(int val){ m_StatusCode=val; }
void CUpdateLogResponse::setStatusMessage(const char * val){ m_StatusMessage.set(val); }
extern "C"  IEspUpdateLogResponse *createUpdateLogResponse(const char *serv){return ((IEspUpdateLogResponse *)new CUpdateLogResponse(serv));}
extern "C"  IClientUpdateLogResponse *createClientUpdateLogResponse(const char *serv){return ((IClientUpdateLogResponse *)new CUpdateLogResponse(serv));}

//=======================================================
// class CWsLoggingServicePingRequest Implementation
//=======================================================

CWsLoggingServicePingRequest::CWsLoggingServicePingRequest(const char *serviceName, IRpcMessageBinding *init)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("WsLoggingServicePingRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CWsLoggingServicePingRequest::CWsLoggingServicePingRequest(const char *serviceName, const char *bc)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("WsLoggingServicePingRequest");
}

CWsLoggingServicePingRequest::CWsLoggingServicePingRequest(const char *serviceName, IRpcMessage* rpcmsg)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("WsLoggingServicePingRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CWsLoggingServicePingRequest::CWsLoggingServicePingRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("WsLoggingServicePingRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CWsLoggingServicePingRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType><xsd:all/></xsd:complexType></xsd:element>\n", msgTypeName);
		}
	}
	return schema;
}

void CWsLoggingServicePingRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CWsLoggingServicePingRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CWsLoggingServicePingRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CWsLoggingServicePingRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CWsLoggingServicePingRequest::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

}


void CWsLoggingServicePingRequest::copy(CWsLoggingServicePingRequest &from)
{
}


void CWsLoggingServicePingRequest::copy(IConstWsLoggingServicePingRequest &ifrom)
{
}


void CWsLoggingServicePingRequest::getAttributes(IProperties &attributes)
{
}


void CWsLoggingServicePingRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
}


void CWsLoggingServicePingRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CWsLoggingServicePingRequest::serializer(IEspContext* ctx, IConstWsLoggingServicePingRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<WsLoggingServicePingRequest>");
	if (keepRootTag)
		buffer.append("</WsLoggingServicePingRequest>");
}

bool CWsLoggingServicePingRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	return hasValue;
}

bool CWsLoggingServicePingRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	return hasValue;
}

bool CWsLoggingServicePingRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	return hasValue;
}

extern "C"  IEspWsLoggingServicePingRequest *createWsLoggingServicePingRequest(const char *serv){return ((IEspWsLoggingServicePingRequest *)new CWsLoggingServicePingRequest(serv));}
extern "C"  IClientWsLoggingServicePingRequest *createClientWsLoggingServicePingRequest(const char *serv){return ((IClientWsLoggingServicePingRequest *)new CWsLoggingServicePingRequest(serv));}

//=======================================================
// class CWsLoggingServicePingResponse Implementation
//=======================================================

CWsLoggingServicePingResponse::CWsLoggingServicePingResponse(const char *serviceName, IRpcMessageBinding *init)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("WsLoggingServicePingResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CWsLoggingServicePingResponse::CWsLoggingServicePingResponse(const char *serviceName, const char *bc)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("WsLoggingServicePingResponse");
}

CWsLoggingServicePingResponse::CWsLoggingServicePingResponse(const char *serviceName, IRpcMessage* rpcmsg)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("WsLoggingServicePingResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CWsLoggingServicePingResponse::CWsLoggingServicePingResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("WsLoggingServicePingResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CWsLoggingServicePingResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType><xsd:all/></xsd:complexType></xsd:element>\n", msgTypeName);
		}
	}
	return schema;
}

void CWsLoggingServicePingResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CWsLoggingServicePingResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CWsLoggingServicePingResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CWsLoggingServicePingResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CWsLoggingServicePingResponse::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
	}
}


void CWsLoggingServicePingResponse::copy(CWsLoggingServicePingResponse &from)
{
}


void CWsLoggingServicePingResponse::copy(IConstWsLoggingServicePingResponse &ifrom)
{
}


void CWsLoggingServicePingResponse::getAttributes(IProperties &attributes)
{
}


void CWsLoggingServicePingResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
	}
}


void CWsLoggingServicePingResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CWsLoggingServicePingResponse::serializer(IEspContext* ctx, IConstWsLoggingServicePingResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<WsLoggingServicePingResponse>");
	if (keepRootTag)
		buffer.append("</WsLoggingServicePingResponse>");
}

bool CWsLoggingServicePingResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
	}
	return hasValue;
}

bool CWsLoggingServicePingResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	return hasValue;
}

bool CWsLoggingServicePingResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	return hasValue;
}

extern "C"  IEspWsLoggingServicePingResponse *createWsLoggingServicePingResponse(const char *serv){return ((IEspWsLoggingServicePingResponse *)new CWsLoggingServicePingResponse(serv));}
extern "C"  IClientWsLoggingServicePingResponse *createClientWsLoggingServicePingResponse(const char *serv){return ((IClientWsLoggingServicePingResponse *)new CWsLoggingServicePingResponse(serv));}

//=======================================================
// class CWsLoggingServiceSoapBinding Implementation
//=======================================================

CWsLoggingServiceSoapBinding::CWsLoggingServiceSoapBinding(http_soap_log_level level):CHttpSoapBinding(NULL, NULL, NULL, level)
{
	init_strings();
	setWsdlVersion(1);
}

CWsLoggingServiceSoapBinding::CWsLoggingServiceSoapBinding(IPropertyTree* cfg, const char *bindname, const char *procname, http_soap_log_level level):CHttpSoapBinding(cfg, bindname, procname, level)
{
	init_strings(); 
	setWsdlVersion(1);

}

void CWsLoggingServiceSoapBinding::init_strings()
{
}

int CWsLoggingServiceSoapBinding::processRequest(IRpcMessage* rpc_call, IRpcMessage* rpc_response)
{
	if(rpc_call == NULL || rpc_response == NULL)
		return -1;

	IEspContext *ctx=rpc_call->queryContext();
	DBGLOG("Client version: %g", ctx->getClientVersion());
	StringBuffer serviceName;
	double clientVer=(ctx) ? ctx->getClientVersion() : 0.0;
	qualifyServiceName(*ctx, ctx->queryServiceName(NULL), NULL, serviceName, NULL);
	CRpcCall* thecall = static_cast<CRpcCall *>(rpc_call);
	CRpcResponse* response = static_cast<CRpcResponse*>(rpc_response);
	CHttpRequest* httprequest = thecall->getHttpReq();
	CHttpResponse* httpresponse = response->getHttpResp();

	Owned<IEspWsLoggingService> iserv = (IEspWsLoggingService*)getService();
	if(iserv == NULL)
	{
		response->set_status(SOAP_SERVER_ERROR);
		response->set_err("Service not available");
		DBGLOG("Service not available");
		return -1;
	}
	if (thecall->get_name() == NULL)
	{
		response->set_status(SOAP_CLIENT_ERROR);
		response->set_err("No service method specified");
		ERRLOG("No service method specified");
		return -1;
	}

	IEspContext& context = *rpc_call->queryContext();

	if(!stricmp(thecall->get_name(), "GetTransactionSeed")||!stricmp(thecall->get_name(), "GetTransactionSeedRequest"))
	{
		Owned<CGetTransactionSeedRequest> esp_request = new CGetTransactionSeedRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CGetTransactionSeedResponse> esp_response = new CGetTransactionSeedResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		if( accessmap.ordinality() > 0 )
			onFeaturesAuthorize(context, accessmap, "WsLoggingService", "GetTransactionSeed");
		iserv->onGetTransactionSeed(*rpc_call->queryContext(), *esp_request, *esp_response);
		response->set_status(SOAP_OK);
		response->set_name("GetTransactionSeedResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "Ping")||!stricmp(thecall->get_name(), "WsLoggingServicePingRequest"))
	{
		Owned<CWsLoggingServicePingRequest> esp_request = new CWsLoggingServicePingRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CWsLoggingServicePingResponse> esp_response = new CWsLoggingServicePingResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		if( accessmap.ordinality() > 0 )
			onFeaturesAuthorize(context, accessmap, "WsLoggingService", "Ping");
		iserv->onPing(*rpc_call->queryContext(), *esp_request, *esp_response);
		response->set_status(SOAP_OK);
		response->set_name("WsLoggingServicePingResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "UpdateLog")||!stricmp(thecall->get_name(), "UpdateLogRequest"))
	{
		Owned<CUpdateLogRequest> esp_request = new CUpdateLogRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CUpdateLogResponse> esp_response = new CUpdateLogResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		if( accessmap.ordinality() > 0 )
			onFeaturesAuthorize(context, accessmap, "WsLoggingService", "UpdateLog");
		iserv->onUpdateLog(*rpc_call->queryContext(), *esp_request, *esp_response);
		response->set_status(SOAP_OK);
		response->set_name("UpdateLogResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	response->set_status(SOAP_CLIENT_ERROR);
	StringBuffer msg, svcName;
	msg.appendf("Method %s not available in service %s",thecall->get_name(),getServiceName(svcName).str());
	ERRLOG("%s", msg.str());
	response->set_err(msg);
	return -1;
}

int CWsLoggingServiceSoapBinding::getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &content, const char *service, const char *method, bool mda)
{
	BoolHash added;
	if (context.getClientVersion()<=0)
		context.setClientVersion(1);

	DBGLOG("Client version: %g", context.getClientVersion());
	bool fullservice = (!Utils::strcasecmp(service, "WsLoggingService"));
	bool allMethods = (method==NULL || *method==0);
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "GetTransactionSeed"))) || Utils::strcasecmp(method, "GetTransactionSeed")==0)
	{
		CGetTransactionSeedRequest::getMapInfo(context.queryMapInfo());
		CGetTransactionSeedResponse::getMapInfo(context.queryMapInfo());
		CGetTransactionSeedRequest::getXsdDefinition(context, request, "GetTransactionSeed", content, added);
		CGetTransactionSeedResponse::getXsdDefinition(context, request, content, added);
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "Ping"))) || Utils::strcasecmp(method, "Ping")==0)
	{
		CWsLoggingServicePingRequest::getMapInfo(context.queryMapInfo());
		CWsLoggingServicePingResponse::getMapInfo(context.queryMapInfo());
		CWsLoggingServicePingRequest::getXsdDefinition(context, request, "Ping", content, added);
		CWsLoggingServicePingResponse::getXsdDefinition(context, request, content, added);
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "UpdateLog"))) || Utils::strcasecmp(method, "UpdateLog")==0)
	{
		CUpdateLogRequest::getMapInfo(context.queryMapInfo());
		CUpdateLogResponse::getMapInfo(context.queryMapInfo());
		CUpdateLogRequest::getXsdDefinition(context, request, "UpdateLog", content, added);
		CUpdateLogResponse::getXsdDefinition(context, request, content, added);
	}
	return 0;
}

int CWsLoggingServiceSoapBinding::getMethodHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &page, bool bIncludeFormTag)
{
	DBGLOG("Client version: %g", context.getClientVersion());
	if (Utils::strcasecmp(method, "GetTransactionSeed")==0)
	{
		CGetTransactionSeedRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "Ping")==0)
	{
		CWsLoggingServicePingRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "UpdateLog")==0)
	{
		CUpdateLogRequest::getHtmlForm(context, request, serv, method, page);
	}
	return 0;
}

int CWsLoggingServiceSoapBinding::getQualifiedNames(IEspContext& ctx, MethodInfoArray & methods)
{
	double ver = ctx.getClientVersion();
	if (ver<=0)
		ver = getWsdlVersion();
	const char *servname=ctx.queryServiceName(NULL);
	bool fullservice = (!stricmp(servname, "esp")||!stricmp(servname, "WsLoggingService"));
	if ((fullservice || isMethodInSubService(ctx, servname, "GetTransactionSeed")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("GetTransactionSeed", "GetTransactionSeed", "GetTransactionSeedResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "Ping")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("Ping", "Ping", "WsLoggingServicePingResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "UpdateLog")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("UpdateLog", "UpdateLog", "UpdateLogResponse"));
	return methods.ordinality();
}

StringBuffer & CWsLoggingServiceSoapBinding::getServiceName(StringBuffer &resp)
{
	resp.append("WsLoggingService");
	return resp;
}

bool CWsLoggingServiceSoapBinding::isValidServiceName(IEspContext &context, const char *name)
{
	if (!Utils::strcasecmp(name, "WsLoggingService"))
		return true;
	else
		return (hasSubService(context, name));
}

bool CWsLoggingServiceSoapBinding::qualifyMethodName(IEspContext &context, const char *methname, StringBuffer *methQName)
{
	if (!methname || !*methname)
	{
		if (methQName!=NULL)
			methQName->clear();
		return true;
	}
	if (Utils::strcasecmp(methname, "GetTransactionSeed")==0)
	{
		if (methQName!=NULL)
			methQName->set("GetTransactionSeed");
		return true;
	}
	if (Utils::strcasecmp(methname, "Ping")==0)
	{
		if (methQName!=NULL)
			methQName->set("Ping");
		return true;
	}
	if (Utils::strcasecmp(methname, "UpdateLog")==0)
	{
		if (methQName!=NULL)
			methQName->set("UpdateLog");
		return true;
	}
	return false;
}

bool CWsLoggingServiceSoapBinding::qualifyServiceName(IEspContext &context, const char *servname, const char *methname, StringBuffer &servQName, StringBuffer *methQName)
{
	servQName.clear();
	if (!Utils::strcasecmp(servname, "WsLoggingService"))
	{
		servQName.append("WsLoggingService");
		return qualifyMethodName(context, methname, methQName);
	}
	return qualifySubServiceName(context, servname, methname, servQName, methQName);
}

int CWsLoggingServiceSoapBinding::onGetFile(IEspContext &context, CHttpRequest* request, CHttpResponse* response, const char *pathex)
{
	if(request == NULL || response == NULL)
		return -1;
	StringBuffer mimetype;
	MemoryBuffer content;

	StringBuffer filepath;
	getBaseFilePath(filepath);
	if (strchr("\\/", filepath.charAt(filepath.length()-1))==NULL)
		filepath.append("/");
	filepath.append(pathex);
	response->httpContentFromFile(filepath.str());
	response->send();
	return 0;
}

int CWsLoggingServiceSoapBinding::onGetForm(IEspContext &context, CHttpRequest* request, CHttpResponse* response, const char *service, const char *method)
{
	return onGetNotFound(context, request, response, service);
}
int CWsLoggingServiceSoapBinding::onGetXForm(IEspContext &context, CHttpRequest* request, CHttpResponse* response, const char *service, const char *method)
{
	return EspHttpBinding::onGetXForm(context, request, response, service, method);
}

int CWsLoggingServiceSoapBinding::onGetService(IEspContext &context, CHttpRequest* request, CHttpResponse* response, const char *service, const char *method, const char *pathex)
{
	if(request == NULL || response == NULL)
		return -1;
	return onGetQuery(context, request, response, service, method);
}

 IRpcRequestBinding *CWsLoggingServiceSoapBinding::createReqBinding(IEspContext &context, IHttpMessage *ireq, const char *service, const char *method)
{
	CHttpRequest *request=static_cast<CHttpRequest*>(ireq);
	IProperties *props = (request) ? request->queryParameters() : NULL;

	if (!stricmp(method, "GetTransactionSeed") || !stricmp(method, "GetTransactionSeedRequest"))
		return new CGetTransactionSeedRequest(&context, "WsLoggingService", props, NULL);
	if (!stricmp(method, "Ping") || !stricmp(method, "WsLoggingServicePingRequest"))
		return new CWsLoggingServicePingRequest(&context, "WsLoggingService", props, NULL);
	if (!stricmp(method, "UpdateLog") || !stricmp(method, "UpdateLogRequest"))
		return new CUpdateLogRequest(&context, "WsLoggingService", props, NULL);
	return NULL;
}

int CWsLoggingServiceSoapBinding::onGetInstantQuery(IEspContext &context, CHttpRequest* request, CHttpResponse* response, const char *service, const char *method)
{
	if (context.getClientVersion()<=0)
		context.setClientVersion(1);

	if(request == NULL || response == NULL)
		return -1;
	StringBuffer respStr;
	Owned<IEspWsLoggingService> iserv = (IEspWsLoggingService*)getService();
	if(iserv == NULL)
	{
		respStr.append("Service not available");
		response->setContent(respStr.str());
		response->setContentType("text/html");
		response->send();
	}
	else
	{
		Owned<CSoapResponseBinding> esp_response;
		StringBuffer source;
		IEspContext& context = *request->queryContext();
		if(!stricmp(method, "GetTransactionSeed")||!stricmp(method, "GetTransactionSeedRequest"))
		{
			Owned<CGetTransactionSeedRequest> esp_request = new CGetTransactionSeedRequest(&context, "WsLoggingService", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			CGetTransactionSeedResponse* resp = new CGetTransactionSeedResponse("WsLoggingService");
			esp_response.setown(resp);
			MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
			if(accessmap.ordinality()>0)
				onFeaturesAuthorize(context, accessmap, "WsLoggingService", "GetTransactionSeed");
			iserv->onGetTransactionSeed(*request->queryContext(), *esp_request.get(), *resp);
		}
		if(!stricmp(method, "Ping")||!stricmp(method, "WsLoggingServicePingRequest"))
		{
			Owned<CWsLoggingServicePingRequest> esp_request = new CWsLoggingServicePingRequest(&context, "WsLoggingService", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			CWsLoggingServicePingResponse* resp = new CWsLoggingServicePingResponse("WsLoggingService");
			esp_response.setown(resp);
			MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
			if(accessmap.ordinality()>0)
				onFeaturesAuthorize(context, accessmap, "WsLoggingService", "Ping");
			iserv->onPing(*request->queryContext(), *esp_request.get(), *resp);
		}
		if(!stricmp(method, "UpdateLog")||!stricmp(method, "UpdateLogRequest"))
		{
			Owned<CUpdateLogRequest> esp_request = new CUpdateLogRequest(&context, "WsLoggingService", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			CUpdateLogResponse* resp = new CUpdateLogResponse("WsLoggingService");
			esp_response.setown(resp);
			MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
			if(accessmap.ordinality()>0)
				onFeaturesAuthorize(context, accessmap, "WsLoggingService", "UpdateLog");
			iserv->onUpdateLog(*request->queryContext(), *esp_request.get(), *resp);
		}

		if (esp_response.get())
		{
			if (canRedirect(*request) && esp_response->getRedirectUrl() && *esp_response->getRedirectUrl())
				response->redirect(*request, esp_response->getRedirectUrl());
			else
			{
				MemoryBuffer content;
				StringBuffer mimetype;
				esp_response->appendContent(&context,content, mimetype);
				onBeforeSendResponse(context,request,content,service,method);
				response->setContent(content.length(), content.toByteArray());
				response->setContentType(mimetype.str());
				response->send();
			}
			return 0;
		}
	}
	return onGetNotFound(context, request,  response, service);
}





//=======================================================
// client util methods
//=======================================================

//------ method GetTransactionSeed ---------

IClientGetTransactionSeedRequest * CClientWsLoggingService::createGetTransactionSeedRequest()
{
	CGetTransactionSeedRequest* request = new CGetTransactionSeedRequest("WsLoggingService");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	request->setMsgName("GetTransactionSeed");
	return request;
}

IClientGetTransactionSeedResponse * CClientWsLoggingService::GetTransactionSeed(IClientGetTransactionSeedRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CGetTransactionSeedRequest* esprequest = static_cast<CGetTransactionSeedRequest*>(request);
	CGetTransactionSeedResponse* espresponse = new CGetTransactionSeedResponse("WsLoggingService");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientWsLoggingService::async_GetTransactionSeed(IClientGetTransactionSeedRequest *request, IClientWsLoggingServiceEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CGetTransactionSeedRequest* esprequest = static_cast<CGetTransactionSeedRequest*>(request);
	esprequest->setMethod("GetTransactionSeed");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientWsLoggingService::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientGetTransactionSeedResponse *CClientWsLoggingService::GetTransactionSeedFn(const char * Application_)
{
	Owned<IClientGetTransactionSeedRequest> req =  createGetTransactionSeedRequest();
	req->setApplication(Application_);
	return GetTransactionSeed(req.get());
}

//------ method Ping ---------

IClientWsLoggingServicePingRequest * CClientWsLoggingService::createPingRequest()
{
	CWsLoggingServicePingRequest* request = new CWsLoggingServicePingRequest("WsLoggingService");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	request->setMsgName("Ping");
	return request;
}

IClientWsLoggingServicePingResponse * CClientWsLoggingService::Ping(IClientWsLoggingServicePingRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CWsLoggingServicePingRequest* esprequest = static_cast<CWsLoggingServicePingRequest*>(request);
	CWsLoggingServicePingResponse* espresponse = new CWsLoggingServicePingResponse("WsLoggingService");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientWsLoggingService::async_Ping(IClientWsLoggingServicePingRequest *request, IClientWsLoggingServiceEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CWsLoggingServicePingRequest* esprequest = static_cast<CWsLoggingServicePingRequest*>(request);
	esprequest->setMethod("Ping");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientWsLoggingService::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientWsLoggingServicePingResponse *CClientWsLoggingService::PingFn()
{
	Owned<IClientWsLoggingServicePingRequest> req =  createPingRequest();
	return Ping(req.get());
}

//------ method UpdateLog ---------

IClientUpdateLogRequest * CClientWsLoggingService::createUpdateLogRequest()
{
	CUpdateLogRequest* request = new CUpdateLogRequest("WsLoggingService");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	request->setMsgName("UpdateLog");
	return request;
}

IClientUpdateLogResponse * CClientWsLoggingService::UpdateLog(IClientUpdateLogRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CUpdateLogRequest* esprequest = static_cast<CUpdateLogRequest*>(request);
	CUpdateLogResponse* espresponse = new CUpdateLogResponse("WsLoggingService");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientWsLoggingService::async_UpdateLog(IClientUpdateLogRequest *request, IClientWsLoggingServiceEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CUpdateLogRequest* esprequest = static_cast<CUpdateLogRequest*>(request);
	esprequest->setMethod("UpdateLog");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientWsLoggingService::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientUpdateLogResponse *CClientWsLoggingService::UpdateLogFn(const char * Option_, const char * LogContent_)
{
	Owned<IClientUpdateLogRequest> req =  createUpdateLogRequest();
	req->setOption(Option_);
	req->setLogContent(LogContent_);
	return UpdateLog(req.get());
}

int CClientWsLoggingService::transferThunkEvent(void *data)
{
	IRpcResponseBinding *response = (IRpcResponseBinding *)data;
	if (response!=NULL)
	{
		IClientWsLoggingServiceEvents *eventSink = (IClientWsLoggingServiceEvents *)response->getEventSink();
		response->lock();

		if (stricmp(response->getMethod(), "GetTransactionSeed")==0)
		{
			IClientGetTransactionSeedResponse* icresp = dynamic_cast<IClientGetTransactionSeedResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onGetTransactionSeedComplete(icresp, response->queryState());
				else
					eventSink->onGetTransactionSeedError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "Ping")==0)
		{
			IClientWsLoggingServicePingResponse* icresp = dynamic_cast<IClientWsLoggingServicePingResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onPingComplete(icresp, response->queryState());
				else
					eventSink->onPingError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "UpdateLog")==0)
		{
			IClientUpdateLogResponse* icresp = dynamic_cast<IClientUpdateLogResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onUpdateLogComplete(icresp, response->queryState());
				else
					eventSink->onUpdateLogError(icresp,response->queryState());
			}
		}
		response->unlock();
	}
	return 0;
}

static IRpcResponseBinding* createWsLoggingServiceResponseObject(IRpcRequestBinding *request)
{
	const char* method = request->getMethod();
	if (stricmp(method, "GetTransactionSeed")==0)
		return new CGetTransactionSeedResponse("WsLoggingService", request);
	if (stricmp(method, "Ping")==0)
		return new CWsLoggingServicePingResponse("WsLoggingService", request);
	if (stricmp(method, "UpdateLog")==0)
		return new CUpdateLogResponse("WsLoggingService", request);
	return NULL;
}

#ifdef _WIN32
void CClientWsLoggingService::espWorkerThread(void* data)
#else
void *CClientWsLoggingService::espWorkerThread(void *data)
#endif
{
	IRpcRequestBinding *request = (IRpcRequestBinding *) data;

	if (request != NULL)
	{
		request->lock();
		IRpcResponseBinding *response=createWsLoggingServiceResponseObject(request);
		if (response!=NULL)
		{
			try{
				request->post(*response);
			}
			catch(IException* ex){
				StringBuffer errorStr;
				ex->errorMessage(errorStr);
				ERRLOG("CClientWsLoggingService::espWorkerThread(%s)--Exception caught while posting async request: %s", request->getMethod(), errorStr.str());
				ex->Release();
			}
			catch(...){
				ERRLOG("Unknown exception caught while posting async request");
			}
		}
#ifdef USE_CLIENT_THREAD
		ThunkToClientThread(request->getThunkHandle(), transferThunkEvent, (void *)response);
#else
		transferThunkEvent((void *)response);
#endif
		request->unlock();
		if(request->queryState()!=NULL)
			request->queryState()->Release();

		if(response!=NULL)
			response->Release();

		request->Release();
	}
#if defined(_WIN32)
#else
	return (void *) 0 ;
#endif
}



extern "C" IClientWsLoggingService * createWsLoggingServiceClient() {  return new CClientWsLoggingService(); }


#endif //ws_loggingservice_ESPGEN_INCLUDED
