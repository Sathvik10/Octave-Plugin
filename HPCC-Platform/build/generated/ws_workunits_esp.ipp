// *** Source file generated by HIDL Version 1.3 from ws_workunits.ecm ***
// *** Not to be hand edited (changes will be lost on re-generation) ***

#ifndef ws_workunits_EX_ESPGEN_INCLUDED
#define ws_workunits_EX_ESPGEN_INCLUDED

#pragma warning( disable : 4786)

//JLib
#include "jliball.hpp"

//SCM Interfaces
#include "esp.hpp"
#include "soapesp.hpp"
#include "ws_workunits.hpp"
//ESP Bindings
#include "SOAP/Platform/soapmessage.hpp"
#include "SOAP/Platform/soapmacro.hpp"
#include "SOAP/Platform/soapservice.hpp"
#include "SOAP/Platform/soapparam.hpp"
#include "SOAP/client/soapclient.hpp"


namespace ws_workunits
{

class CXECLWUActions : public SoapEnumParamNew<CECLWUActions>
{
public:
	CXECLWUActions(nilBehavior nilB) : SoapEnumParamNew<CECLWUActions>(nilB)
	{ doInit(); }
	CXECLWUActions(CECLWUActions defvalue_) : SoapEnumParamNew<CECLWUActions>(defvalue_)
	{ doInit(); }
	CXECLWUActions(const char* defvalue_) : SoapEnumParamNew<CECLWUActions>()
	{ doInit(); setDefaultValue(defvalue_); }
	static  void getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash &added)
	{ getSharedInstance().getXsdDefinitionInternal(context,request,schema,added); }
	static void getMapInfo(IMapInfo& info, BoolHash& added) { getSharedInstance().getMapInfo_(info,added); }

	static const char* stringOf(CECLWUActions val) { return getSharedInstance().toString(val); }

	static CECLWUActions enumOf(const char* s) { return getSharedInstance().toEnum(s); }

static const char *queryXsdElementName() { return "ECLWUActions"; }
private:
	static CXECLWUActions& getSharedInstance() { static CXECLWUActions instance(nilIgnore); return instance; }
	void getMapInfo_(IMapInfo& info, BoolHash& added) {  }
	void getXsdDefinitionInternal(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash &added)
	{ getXsdDefinition_(context,request,schema,added,NULL); }
	void doInit()
	{
		static const char* inits[] = {"Abort","Delete","Deschedule","Reschedule","Pause","PauseNow","Protect","Unprotect","Restore","Resume","SetToFailed",NULL};
		init("ECLWUActions","string",inits);
	}
};

class CXEclDefinitionActions : public SoapEnumParamNew<CEclDefinitionActions>
{
public:
	CXEclDefinitionActions(nilBehavior nilB) : SoapEnumParamNew<CEclDefinitionActions>(nilB)
	{ doInit(); }
	CXEclDefinitionActions(CEclDefinitionActions defvalue_) : SoapEnumParamNew<CEclDefinitionActions>(defvalue_)
	{ doInit(); }
	CXEclDefinitionActions(const char* defvalue_) : SoapEnumParamNew<CEclDefinitionActions>()
	{ doInit(); setDefaultValue(defvalue_); }
	static  void getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash &added)
	{ getSharedInstance().getXsdDefinitionInternal(context,request,schema,added); }
	static void getMapInfo(IMapInfo& info, BoolHash& added) { getSharedInstance().getMapInfo_(info,added); }

	static const char* stringOf(CEclDefinitionActions val) { return getSharedInstance().toString(val); }

	static CEclDefinitionActions enumOf(const char* s) { return getSharedInstance().toEnum(s); }

static const char *queryXsdElementName() { return "EclDefinitionActions"; }
private:
	static CXEclDefinitionActions& getSharedInstance() { static CXEclDefinitionActions instance(nilIgnore); return instance; }
	void getMapInfo_(IMapInfo& info, BoolHash& added) {  }
	void getXsdDefinitionInternal(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash &added)
	{ getXsdDefinition_(context,request,schema,added,NULL); }
	void doInit()
	{
		static const char* inits[] = {"SyntaxCheck","Deploy","Publish",NULL};
		init("EclDefinitionActions","string",inits);
	}
};

class CECLException : public CSoapComplexType,
   implements IEspECLException,
   implements IClientECLException
{
protected:
	SoapStringParam m_Source;
	SoapStringParam m_Severity;
	SoapParam<int> m_Code;
	SoapStringParam m_Message;
	SoapStringParam m_FileName;
	SoapParam<int> m_LineNo;
	SoapParam<int> m_Column;
	SoapParam<int> m_Activity;
	SoapStringParam m_Scope;
	SoapParam<int> m_Priority;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CECLException(const char *serviceName, const char *bcompat);

	CECLException(const char *serviceName, IRpcMessageBinding *init=NULL);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "ECLException";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CECLException &from);

	void copy(IConstECLException &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstECLException &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	const char * getSource();
	const char * getSeverity();
bool getCode_isNull();
	int getCode();
	const char * getMessage();
	const char * getFileName();
bool getLineNo_isNull();
	int getLineNo();
bool getColumn_isNull();
	int getColumn();
bool getActivity_isNull();
	int getActivity();
	const char * getScope();
bool getPriority_isNull();
	int getPriority();
	void setSource(const char * val);
	void setSeverity(const char * val);
	void setCode_null();
	void setCode(int val);
	void setMessage(const char * val);
	void setFileName(const char * val);
	void setLineNo_null();
	void setLineNo(int val);
	void setColumn_null();
	void setColumn(int val);
	void setActivity_null();
	void setActivity(int val);
	void setScope(const char * val);
	void setPriority_null();
	void setPriority(int val);
};

class CECLSchemaItem : public CSoapComplexType,
   implements IEspECLSchemaItem,
   implements IClientECLSchemaItem
{
protected:
	SoapStringParam m_ColumnName;
	SoapStringParam m_ColumnType;
	SoapParam<int> m_ColumnTypeCode;
	SoapParam<bool> m_isConditional;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CECLSchemaItem(const char *serviceName, const char *bcompat);

	CECLSchemaItem(const char *serviceName, IRpcMessageBinding *init=NULL);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "ECLSchemaItem";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CECLSchemaItem &from);

	void copy(IConstECLSchemaItem &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstECLSchemaItem &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	const char * getColumnName();
	const char * getColumnType();
bool getColumnTypeCode_isNull();
	int getColumnTypeCode();
bool getIsConditional_isNull();
	bool getIsConditional();
	void setColumnName(const char * val);
	void setColumnType(const char * val);
	void setColumnTypeCode_null();
	void setColumnTypeCode(int val);
	void setIsConditional_null();
	void setIsConditional(bool val);
};

class CECLResult : public CSoapComplexType,
   implements IEspECLResult,
   implements IClientECLResult
{
protected:
	SoapStringParam m_Name;
	SoapParam<int> m_Sequence;
	SoapStringParam m_Value;
	SoapStringParam m_Link;
	SoapStringParam m_FileName;
	SoapParam<bool> m_IsSupplied;
	SoapParam<bool> m_ShowFileContent;
	SoapParam<__int64> m_Total;
	SoapStructArrayParam<IConstECLSchemaItem, CECLSchemaItem> m_ECLSchemas;
	SoapStringParam m_XmlSchema;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CECLResult(const char *serviceName, const char *bcompat);

	CECLResult(const char *serviceName, IRpcMessageBinding *init=NULL);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "ECLResult";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CECLResult &from);

	void copy(IConstECLResult &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstECLResult &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	const char * getName();
bool getSequence_isNull();
	int getSequence();
	const char * getValue();
	const char * getLink();
	const char * getFileName();
bool getIsSupplied_isNull();
	bool getIsSupplied();
bool getShowFileContent_isNull();
	bool getShowFileContent();
bool getTotal_isNull();
	__int64 getTotal();
	IArrayOf<IConstECLSchemaItem> & getECLSchemas();
	const char * getXmlSchema();
	void setName(const char * val);
	void setSequence_null();
	void setSequence(int val);
	void setValue(const char * val);
	void setLink(const char * val);
	void setFileName(const char * val);
	void setIsSupplied_null();
	void setIsSupplied(bool val);
	void setShowFileContent_null();
	void setShowFileContent(bool val);
	void setTotal_null();
	void setTotal(__int64 val);
	void setECLSchemas(IArrayOf<IEspECLSchemaItem> &val);
 void setECLSchemas(IArrayOf<IConstECLSchemaItem> &val);
	void setXmlSchema(const char * val);
};

class CECLTimingData : public CSoapComplexType,
   implements IEspECLTimingData,
   implements IClientECLTimingData
{
protected:
	SoapStringParam m_Name;
	SoapParam<int> m_GraphNum;
	SoapParam<int> m_SubGraphNum;
	SoapParam<int> m_GID;
	SoapParam<int> m_Min;
	SoapParam<int> m_MS;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CECLTimingData(const char *serviceName, const char *bcompat);

	CECLTimingData(const char *serviceName, IRpcMessageBinding *init=NULL);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "ECLTimingData";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CECLTimingData &from);

	void copy(IConstECLTimingData &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstECLTimingData &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	const char * getName();
bool getGraphNum_isNull();
	int getGraphNum();
bool getSubGraphNum_isNull();
	int getSubGraphNum();
bool getGID_isNull();
	int getGID();
bool getMin_isNull();
	int getMin();
bool getMS_isNull();
	int getMS();
	void setName(const char * val);
	void setGraphNum_null();
	void setGraphNum(int val);
	void setSubGraphNum_null();
	void setSubGraphNum(int val);
	void setGID_null();
	void setGID(int val);
	void setMin_null();
	void setMin(int val);
	void setMS_null();
	void setMS(int val);
};

class CECLGraph : public CSoapComplexType,
   implements IEspECLGraph,
   implements IClientECLGraph
{
protected:
	SoapStringParam m_Name;
	SoapStringParam m_Label;
	SoapStringParam m_Type;
	SoapParam<bool> m_Running;
	SoapParam<bool> m_Complete;
	SoapParam<bool> m_Failed;
	SoapParam<__int64> m_RunningId;
	SoapStringParam m_WhenStarted;
	SoapStringParam m_WhenFinished;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CECLGraph(const char *serviceName, const char *bcompat);

	CECLGraph(const char *serviceName, IRpcMessageBinding *init=NULL);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "ECLGraph";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CECLGraph &from);

	void copy(IConstECLGraph &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstECLGraph &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	const char * getName();
	const char * getLabel();
	const char * getType();
bool getRunning_isNull();
	bool getRunning();
bool getComplete_isNull();
	bool getComplete();
bool getFailed_isNull();
	bool getFailed();
bool getRunningId_isNull();
	__int64 getRunningId();
	const char * getWhenStarted();
	const char * getWhenFinished();
	void setName(const char * val);
	void setLabel(const char * val);
	void setType(const char * val);
	void setRunning_null();
	void setRunning(bool val);
	void setComplete_null();
	void setComplete(bool val);
	void setFailed_null();
	void setFailed(bool val);
	void setRunningId_null();
	void setRunningId(__int64 val);
	void setWhenStarted(const char * val);
	void setWhenFinished(const char * val);
};

class CECLGraphEx : public CSoapComplexType,
   implements IEspECLGraphEx,
   implements IClientECLGraphEx
{
protected:
	SoapStringParam m_Name;
	SoapStringParam m_Label;
	SoapStringParam m_Type;
	SoapStringParam m_Graph;
	SoapParam<bool> m_Running;
	SoapParam<__int64> m_RunningId;
	SoapParam<bool> m_Complete;
	SoapParam<bool> m_Failed;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CECLGraphEx(const char *serviceName, const char *bcompat);

	CECLGraphEx(const char *serviceName, IRpcMessageBinding *init=NULL);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "ECLGraphEx";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CECLGraphEx &from);

	void copy(IConstECLGraphEx &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstECLGraphEx &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	const char * getName();
	const char * getLabel();
	const char * getType();
	const char * getGraph();
bool getRunning_isNull();
	bool getRunning();
bool getRunningId_isNull();
	__int64 getRunningId();
bool getComplete_isNull();
	bool getComplete();
bool getFailed_isNull();
	bool getFailed();
	void setName(const char * val);
	void setLabel(const char * val);
	void setType(const char * val);
	void setGraph(const char * val);
	void setRunning_null();
	void setRunning(bool val);
	void setRunningId_null();
	void setRunningId(__int64 val);
	void setComplete_null();
	void setComplete(bool val);
	void setFailed_null();
	void setFailed(bool val);
};

class CECLSourceFile : public CSoapComplexType,
   implements IEspECLSourceFile,
   implements IClientECLSourceFile
{
protected:
	SoapStringParam m_FileCluster;
	SoapStringParam m_Name;
	SoapParam<bool> m_IsSuperFile;
	SoapParam<int> m_Subs;
	SoapParam<int> m_Count;
	SoapStructArrayParam<IConstECLSourceFile, CECLSourceFile> m_ECLSourceFiles;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CECLSourceFile(const char *serviceName, const char *bcompat);

	CECLSourceFile(const char *serviceName, IRpcMessageBinding *init=NULL);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "ECLSourceFile";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CECLSourceFile &from);

	void copy(IConstECLSourceFile &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstECLSourceFile &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	const char * getFileCluster();
	const char * getName();
bool getIsSuperFile_isNull();
	bool getIsSuperFile();
bool getSubs_isNull();
	int getSubs();
bool getCount_isNull();
	int getCount();
	IArrayOf<IConstECLSourceFile> & getECLSourceFiles();
	void setFileCluster(const char * val);
	void setName(const char * val);
	void setIsSuperFile_null();
	void setIsSuperFile(bool val);
	void setSubs_null();
	void setSubs(int val);
	void setCount_null();
	void setCount(int val);
	void setECLSourceFiles(IArrayOf<IEspECLSourceFile> &val);
 void setECLSourceFiles(IArrayOf<IConstECLSourceFile> &val);
};

class CECLTimer : public CSoapComplexType,
   implements IEspECLTimer,
   implements IClientECLTimer
{
protected:
	SoapStringParam m_Name;
	SoapStringParam m_Value;
	SoapParam<int> m_count;
	SoapStringParam m_GraphName;
	SoapParam<int> m_SubGraphId;
	SoapParam<__int64> m_Timestamp;
	SoapStringParam m_When;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CECLTimer(const char *serviceName, const char *bcompat);

	CECLTimer(const char *serviceName, IRpcMessageBinding *init=NULL);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "ECLTimer";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CECLTimer &from);

	void copy(IConstECLTimer &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstECLTimer &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	const char * getName();
	const char * getValue();
bool getCount_isNull();
	int getCount();
	const char * getGraphName();
bool getSubGraphId_isNull();
	int getSubGraphId();
bool getTimestamp_isNull();
	__int64 getTimestamp();
	const char * getWhen();
	void setName(const char * val);
	void setValue(const char * val);
	void setCount_null();
	void setCount(int val);
	void setGraphName(const char * val);
	void setSubGraphId_null();
	void setSubGraphId(int val);
	void setTimestamp_null();
	void setTimestamp(__int64 val);
	void setWhen(const char * val);
};

class CECLHelpFile : public CSoapComplexType,
   implements IEspECLHelpFile,
   implements IClientECLHelpFile
{
protected:
	SoapStringParam m_Name;
	SoapStringParam m_Type;
	SoapStringParam m_IPAddress;
	SoapStringParam m_Description;
	SoapParam<__int64> m_FileSize;
	SoapParam<unsigned int> m_PID;
	SoapParam<unsigned int> m_minActivityId;
	SoapParam<unsigned int> m_maxActivityId;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CECLHelpFile(const char *serviceName, const char *bcompat);

	CECLHelpFile(const char *serviceName, IRpcMessageBinding *init=NULL);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "ECLHelpFile";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CECLHelpFile &from);

	void copy(IConstECLHelpFile &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstECLHelpFile &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	const char * getName();
	const char * getType();
	const char * getIPAddress();
	const char * getDescription();
bool getFileSize_isNull();
	__int64 getFileSize();
bool getPID_isNull();
	unsigned int getPID();
bool getMinActivityId_isNull();
	unsigned int getMinActivityId();
bool getMaxActivityId_isNull();
	unsigned int getMaxActivityId();
	void setName(const char * val);
	void setType(const char * val);
	void setIPAddress(const char * val);
	void setDescription(const char * val);
	void setFileSize_null();
	void setFileSize(__int64 val);
	void setPID_null();
	void setPID(unsigned int val);
	void setMinActivityId_null();
	void setMinActivityId(unsigned int val);
	void setMaxActivityId_null();
	void setMaxActivityId(unsigned int val);
};

class CECLQuery : public CSoapComplexType,
   implements IEspECLQuery,
   implements IClientECLQuery
{
protected:
	SoapStringParam m_Text;
	SoapStringParam m_Cpp;
	SoapStringParam m_ResTxt;
	SoapStringParam m_Dll;
	SoapStringParam m_ThorLog;
	SoapStringParam m_QueryMainDefinition;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CECLQuery(const char *serviceName, const char *bcompat);

	CECLQuery(const char *serviceName, IRpcMessageBinding *init=NULL);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "ECLQuery";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CECLQuery &from);

	void copy(IConstECLQuery &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstECLQuery &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	const char * getText();
	const char * getCpp();
	const char * getResTxt();
	const char * getDll();
	const char * getThorLog();
	const char * getQueryMainDefinition();
	void setText(const char * val);
	void setCpp(const char * val);
	void setResTxt(const char * val);
	void setDll(const char * val);
	void setThorLog(const char * val);
	void setQueryMainDefinition(const char * val);
};

class CQuerySummaryStats : public CSoapComplexType,
   implements IEspQuerySummaryStats,
   implements IClientQuerySummaryStats
{
protected:
	SoapStringParam m_Endpoint;
	SoapStringParam m_Status;
	SoapStringParam m_StartTime;
	SoapStringParam m_EndTime;
	SoapParam<int> m_CountTotal;
	SoapParam<int> m_CountFailed;
	SoapParam<int> m_AverageSlavesReplyLen;
	SoapParam<__int64> m_AverageBytesOut;
	SoapParam<__int64> m_SizeAvgPeakMemory;
	SoapParam<__int64> m_TimeAvgTotalExecuteMinutes;
	SoapParam<__int64> m_TimeMinTotalExecuteMinutes;
	SoapParam<__int64> m_TimeMaxTotalExecuteMinutes;
	SoapParam<__int64> m_Percentile97;
	SoapParam<bool> m_Percentile97Estimate;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CQuerySummaryStats(const char *serviceName, const char *bcompat);

	CQuerySummaryStats(const char *serviceName, IRpcMessageBinding *init=NULL);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "QuerySummaryStats";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CQuerySummaryStats &from);

	void copy(IConstQuerySummaryStats &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstQuerySummaryStats &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	const char * getEndpoint();
	const char * getStatus();
	const char * getStartTime();
	const char * getEndTime();
bool getCountTotal_isNull();
	int getCountTotal();
bool getCountFailed_isNull();
	int getCountFailed();
bool getAverageSlavesReplyLen_isNull();
	int getAverageSlavesReplyLen();
bool getAverageBytesOut_isNull();
	__int64 getAverageBytesOut();
bool getSizeAvgPeakMemory_isNull();
	__int64 getSizeAvgPeakMemory();
bool getTimeAvgTotalExecuteMinutes_isNull();
	__int64 getTimeAvgTotalExecuteMinutes();
bool getTimeMinTotalExecuteMinutes_isNull();
	__int64 getTimeMinTotalExecuteMinutes();
bool getTimeMaxTotalExecuteMinutes_isNull();
	__int64 getTimeMaxTotalExecuteMinutes();
bool getPercentile97_isNull();
	__int64 getPercentile97();
bool getPercentile97Estimate_isNull();
	bool getPercentile97Estimate();
	void setEndpoint(const char * val);
	void setStatus(const char * val);
	void setStartTime(const char * val);
	void setEndTime(const char * val);
	void setCountTotal_null();
	void setCountTotal(int val);
	void setCountFailed_null();
	void setCountFailed(int val);
	void setAverageSlavesReplyLen_null();
	void setAverageSlavesReplyLen(int val);
	void setAverageBytesOut_null();
	void setAverageBytesOut(__int64 val);
	void setSizeAvgPeakMemory_null();
	void setSizeAvgPeakMemory(__int64 val);
	void setTimeAvgTotalExecuteMinutes_null();
	void setTimeAvgTotalExecuteMinutes(__int64 val);
	void setTimeMinTotalExecuteMinutes_null();
	void setTimeMinTotalExecuteMinutes(__int64 val);
	void setTimeMaxTotalExecuteMinutes_null();
	void setTimeMaxTotalExecuteMinutes(__int64 val);
	void setPercentile97_null();
	void setPercentile97(__int64 val);
	void setPercentile97Estimate_null();
	void setPercentile97Estimate(bool val);
};

class CDebugValue : public CSoapComplexType,
   implements IEspDebugValue,
   implements IClientDebugValue
{
protected:
	SoapStringParam m_Name;
	SoapStringParam m_Value;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CDebugValue(const char *serviceName, const char *bcompat);

	CDebugValue(const char *serviceName, IRpcMessageBinding *init=NULL);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "DebugValue";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CDebugValue &from);

	void copy(IConstDebugValue &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstDebugValue &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	const char * getName();
	const char * getValue();
	void setName(const char * val);
	void setValue(const char * val);
};

class CWUActionResult : public CSoapComplexType,
   implements IEspWUActionResult,
   implements IClientWUActionResult
{
protected:
	SoapStringParam m_Wuid;
	SoapStringParam m_Action;
	SoapStringParam m_Result;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CWUActionResult(const char *serviceName, const char *bcompat);

	CWUActionResult(const char *serviceName, IRpcMessageBinding *init=NULL);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "WUActionResult";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CWUActionResult &from);

	void copy(IConstWUActionResult &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstWUActionResult &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	const char * getWuid();
	const char * getAction();
	const char * getResult();
	void setWuid(const char * val);
	void setAction(const char * val);
	void setResult(const char * val);
};

class CApplicationValue : public CSoapComplexType,
   implements IEspApplicationValue,
   implements IClientApplicationValue
{
protected:
	SoapStringParam m_Application;
	SoapStringParam m_Name;
	SoapStringParam m_Value;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CApplicationValue(const char *serviceName, const char *bcompat);

	CApplicationValue(const char *serviceName, IRpcMessageBinding *init=NULL);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "ApplicationValue";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CApplicationValue &from);

	void copy(IConstApplicationValue &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstApplicationValue &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	const char * getApplication();
	const char * getName();
	const char * getValue();
	void setApplication(const char * val);
	void setName(const char * val);
	void setValue(const char * val);
};

class CECLWorkflow : public CSoapComplexType,
   implements IEspECLWorkflow,
   implements IClientECLWorkflow
{
protected:
	SoapStringParam m_WFID;
	SoapStringParam m_EventName;
	SoapStringParam m_EventText;
	SoapParam<int> m_Count;
	SoapParam<int> m_CountRemaining;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CECLWorkflow(const char *serviceName, const char *bcompat);

	CECLWorkflow(const char *serviceName, IRpcMessageBinding *init=NULL);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "ECLWorkflow";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CECLWorkflow &from);

	void copy(IConstECLWorkflow &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstECLWorkflow &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	const char * getWFID();
	const char * getEventName();
	const char * getEventText();
bool getCount_isNull();
	int getCount();
bool getCountRemaining_isNull();
	int getCountRemaining();
	void setWFID(const char * val);
	void setEventName(const char * val);
	void setEventText(const char * val);
	void setCount_null();
	void setCount(int val);
	void setCountRemaining_null();
	void setCountRemaining(int val);
};

class CThorLogInfo : public CSoapComplexType,
   implements IEspThorLogInfo,
   implements IClientThorLogInfo
{
protected:
	SoapStringParam m_ProcessName;
	SoapStringParam m_ClusterGroup;
	SoapStringParam m_LogDate;
	SoapParam<int> m_NumberSlaves;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CThorLogInfo(const char *serviceName, const char *bcompat);

	CThorLogInfo(const char *serviceName, IRpcMessageBinding *init=NULL);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "ThorLogInfo";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CThorLogInfo &from);

	void copy(IConstThorLogInfo &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstThorLogInfo &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	const char * getProcessName();
	const char * getClusterGroup();
	const char * getLogDate();
bool getNumberSlaves_isNull();
	int getNumberSlaves();
	void setProcessName(const char * val);
	void setClusterGroup(const char * val);
	void setLogDate(const char * val);
	void setNumberSlaves_null();
	void setNumberSlaves(int val);
};

class CECLWorkunitLW : public CSoapComplexType,
   implements IEspECLWorkunitLW,
   implements IClientECLWorkunitLW
{
protected:
	SoapStringParam m_Wuid;
	SoapStringParam m_Owner;
	SoapStringParam m_JobName;
	SoapStringParam m_WuScope;
	SoapStringParam m_ClusterName;
	SoapParam<int> m_State;
	SoapStringParam m_StateDesc;
	SoapParam<int> m_Action;
	SoapStringParam m_ActionDesc;
	SoapParam<int> m_Priority;
	SoapStringParam m_PriorityDesc;
	SoapParam<int> m_PriorityLevel;
	SoapParam<bool> m_IsProtected;
	SoapStringParam m_DateTimeScheduled;
	SoapParam<unsigned int> m_TotalClusterTime;
	SoapStructArrayParam<IConstApplicationValue, CApplicationValue> m_ApplicationValues;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CECLWorkunitLW(const char *serviceName, const char *bcompat);

	CECLWorkunitLW(const char *serviceName, IRpcMessageBinding *init=NULL);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "ECLWorkunitLW";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CECLWorkunitLW &from);

	void copy(IConstECLWorkunitLW &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstECLWorkunitLW &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	const char * getWuid();
	const char * getOwner();
	const char * getJobName();
	const char * getWuScope();
	const char * getClusterName();
bool getState_isNull();
	int getState();
	const char * getStateDesc();
bool getAction_isNull();
	int getAction();
	const char * getActionDesc();
bool getPriority_isNull();
	int getPriority();
	const char * getPriorityDesc();
bool getPriorityLevel_isNull();
	int getPriorityLevel();
bool getIsProtected_isNull();
	bool getIsProtected();
	const char * getDateTimeScheduled();
bool getTotalClusterTime_isNull();
	unsigned int getTotalClusterTime();
	IArrayOf<IConstApplicationValue> & getApplicationValues();
	void setWuid(const char * val);
	void setOwner(const char * val);
	void setJobName(const char * val);
	void setWuScope(const char * val);
	void setClusterName(const char * val);
	void setState_null();
	void setState(int val);
	void setStateDesc(const char * val);
	void setAction_null();
	void setAction(int val);
	void setActionDesc(const char * val);
	void setPriority_null();
	void setPriority(int val);
	void setPriorityDesc(const char * val);
	void setPriorityLevel_null();
	void setPriorityLevel(int val);
	void setIsProtected_null();
	void setIsProtected(bool val);
	void setDateTimeScheduled(const char * val);
	void setTotalClusterTime_null();
	void setTotalClusterTime(unsigned int val);
	void setApplicationValues(IArrayOf<IEspApplicationValue> &val);
 void setApplicationValues(IArrayOf<IConstApplicationValue> &val);
};

class CECLWorkunit : public CSoapComplexType,
   implements IEspECLWorkunit,
   implements IClientECLWorkunit
{
protected:
	SoapStringParam m_Wuid;
	SoapStringParam m_Owner;
	SoapStringParam m_Cluster;
	SoapStringParam m_RoxieCluster;
	SoapStringParam m_Jobname;
	SoapStringParam m_Queue;
	SoapParam<int> m_StateID;
	SoapStringParam m_State;
	SoapStringParam m_StateEx;
	SoapStringParam m_Description;
	SoapParam<bool> m_Protected;
	SoapParam<bool> m_Active;
	SoapParam<int> m_Action;
	SoapStringParam m_ActionEx;
	SoapStringParam m_DateTimeScheduled;
	SoapParam<int> m_PriorityClass;
	SoapParam<int> m_PriorityLevel;
	SoapStringParam m_Scope;
	SoapStringParam m_Snapshot;
	SoapParam<int> m_ResultLimit;
	SoapParam<bool> m_Archived;
	SoapParam<bool> m_IsPausing;
	SoapParam<bool> m_ThorLCR;
	SoapParam<int> m_EventSchedule;
	SoapParam<bool> m_HaveSubGraphTimings;
	SoapStringParam m_TotalThorTime;
	SoapStringParam m_TotalClusterTime;
	SoapStringParam m_AbortBy;
	SoapStringParam m_AbortTime;
	SoapStruct<CECLQuery, IConstECLQuery> m_Query;
	SoapStructArrayParam<IConstECLHelpFile, CECLHelpFile> m_Helpers;
	SoapStructArrayParam<IConstECLException, CECLException> m_Exceptions;
	SoapStructArrayParam<IConstECLGraph, CECLGraph> m_Graphs;
	SoapStructArrayParam<IConstECLSourceFile, CECLSourceFile> m_SourceFiles;
	SoapStructArrayParam<IConstECLResult, CECLResult> m_Results;
	SoapStructArrayParam<IConstECLResult, CECLResult> m_Variables;
	SoapStructArrayParam<IConstECLTimer, CECLTimer> m_Timers;
	SoapStructArrayParam<IConstDebugValue, CDebugValue> m_DebugValues;
	SoapStructArrayParam<IConstApplicationValue, CApplicationValue> m_ApplicationValues;
	SoapStructArrayParam<IConstECLWorkflow, CECLWorkflow> m_Workflows;
	SoapStructArrayParam<IConstECLTimingData, CECLTimingData> m_TimingData;
	SoapStringArray m_AllowedClusters;
	SoapParam<int> m_ErrorCount;
	SoapParam<int> m_WarningCount;
	SoapParam<int> m_InfoCount;
	SoapParam<int> m_AlertCount;
	SoapParam<int> m_GraphCount;
	SoapParam<int> m_SourceFileCount;
	SoapParam<int> m_ResultCount;
	SoapParam<int> m_VariableCount;
	SoapParam<int> m_TimerCount;
	SoapParam<bool> m_HasDebugValue;
	SoapParam<int> m_ApplicationValueCount;
	SoapStringParam m_XmlParams;
	SoapParam<int> m_AccessFlag;
	SoapParam<int> m_ClusterFlag;
	SoapStringParam m_HelpersDesc;
	SoapStringParam m_GraphsDesc;
	SoapStringParam m_SourceFilesDesc;
	SoapStringParam m_ResultsDesc;
	SoapStringParam m_VariablesDesc;
	SoapStringParam m_TimersDesc;
	SoapStringParam m_DebugValuesDesc;
	SoapStringParam m_ApplicationValuesDesc;
	SoapStringParam m_WorkflowsDesc;
	SoapParam<bool> m_HasArchiveQuery;
	SoapStructArrayParam<IConstThorLogInfo, CThorLogInfo> m_ThorLogList;
	SoapStringArray m_ResourceURLs;
	SoapParam<int> m_ResultViewCount;
	SoapParam<int> m_ResourceURLCount;
	SoapParam<int> m_DebugValueCount;
	SoapParam<int> m_WorkflowCount;
	SoapParam<int> m_HelpersCount;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CECLWorkunit(const char *serviceName, const char *bcompat);

	CECLWorkunit(const char *serviceName, IRpcMessageBinding *init=NULL);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "ECLWorkunit";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CECLWorkunit &from);

	void copy(IConstECLWorkunit &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstECLWorkunit &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	const char * getWuid();
	const char * getOwner();
	const char * getCluster();
	const char * getRoxieCluster();
	const char * getJobname();
	const char * getQueue();
bool getStateID_isNull();
	int getStateID();
	const char * getState();
	const char * getStateEx();
	const char * getDescription();
bool getProtected_isNull();
	bool getProtected();
bool getActive_isNull();
	bool getActive();
bool getAction_isNull();
	int getAction();
	const char * getActionEx();
	const char * getDateTimeScheduled();
bool getPriorityClass_isNull();
	int getPriorityClass();
bool getPriorityLevel_isNull();
	int getPriorityLevel();
	const char * getScope();
	const char * getSnapshot();
bool getResultLimit_isNull();
	int getResultLimit();
bool getArchived_isNull();
	bool getArchived();
bool getIsPausing_isNull();
	bool getIsPausing();
bool getThorLCR_isNull();
	bool getThorLCR();
bool getEventSchedule_isNull();
	int getEventSchedule();
bool getHaveSubGraphTimings_isNull();
	bool getHaveSubGraphTimings();
	const char * getTotalThorTime();
	const char * getTotalClusterTime();
	const char * getAbortBy();
	const char * getAbortTime();
	IConstECLQuery & getQuery();
	IArrayOf<IConstECLHelpFile> & getHelpers();
	IArrayOf<IConstECLException> & getExceptions();
	IArrayOf<IConstECLGraph> & getGraphs();
	IArrayOf<IConstECLSourceFile> & getSourceFiles();
	IArrayOf<IConstECLResult> & getResults();
	IArrayOf<IConstECLResult> & getVariables();
	IArrayOf<IConstECLTimer> & getTimers();
	IArrayOf<IConstDebugValue> & getDebugValues();
	IArrayOf<IConstApplicationValue> & getApplicationValues();
	IArrayOf<IConstECLWorkflow> & getWorkflows();
	IArrayOf<IConstECLTimingData> & getTimingData();
	StringArray & getAllowedClusters();
bool getErrorCount_isNull();
	int getErrorCount();
bool getWarningCount_isNull();
	int getWarningCount();
bool getInfoCount_isNull();
	int getInfoCount();
bool getAlertCount_isNull();
	int getAlertCount();
bool getGraphCount_isNull();
	int getGraphCount();
bool getSourceFileCount_isNull();
	int getSourceFileCount();
bool getResultCount_isNull();
	int getResultCount();
bool getVariableCount_isNull();
	int getVariableCount();
bool getTimerCount_isNull();
	int getTimerCount();
bool getHasDebugValue_isNull();
	bool getHasDebugValue();
bool getApplicationValueCount_isNull();
	int getApplicationValueCount();
	const char * getXmlParams();
bool getAccessFlag_isNull();
	int getAccessFlag();
bool getClusterFlag_isNull();
	int getClusterFlag();
	const char * getHelpersDesc();
	const char * getGraphsDesc();
	const char * getSourceFilesDesc();
	const char * getResultsDesc();
	const char * getVariablesDesc();
	const char * getTimersDesc();
	const char * getDebugValuesDesc();
	const char * getApplicationValuesDesc();
	const char * getWorkflowsDesc();
bool getHasArchiveQuery_isNull();
	bool getHasArchiveQuery();
	IArrayOf<IConstThorLogInfo> & getThorLogList();
	StringArray & getResourceURLs();
bool getResultViewCount_isNull();
	int getResultViewCount();
bool getResourceURLCount_isNull();
	int getResourceURLCount();
bool getDebugValueCount_isNull();
	int getDebugValueCount();
bool getWorkflowCount_isNull();
	int getWorkflowCount();
bool getHelpersCount_isNull();
	int getHelpersCount();
	void setWuid(const char * val);
	void setOwner(const char * val);
	void setCluster(const char * val);
	void setRoxieCluster(const char * val);
	void setJobname(const char * val);
	void setQueue(const char * val);
	void setStateID_null();
	void setStateID(int val);
	void setState(const char * val);
	void setStateEx(const char * val);
	void setDescription(const char * val);
	void setProtected_null();
	void setProtected(bool val);
	void setActive_null();
	void setActive(bool val);
	void setAction_null();
	void setAction(int val);
	void setActionEx(const char * val);
	void setDateTimeScheduled(const char * val);
	void setPriorityClass_null();
	void setPriorityClass(int val);
	void setPriorityLevel_null();
	void setPriorityLevel(int val);
	void setScope(const char * val);
	void setSnapshot(const char * val);
	void setResultLimit_null();
	void setResultLimit(int val);
	void setArchived_null();
	void setArchived(bool val);
	void setIsPausing_null();
	void setIsPausing(bool val);
	void setThorLCR_null();
	void setThorLCR(bool val);
	void setEventSchedule_null();
	void setEventSchedule(int val);
	void setHaveSubGraphTimings_null();
	void setHaveSubGraphTimings(bool val);
	void setTotalThorTime(const char * val);
	void setTotalClusterTime(const char * val);
	void setAbortBy(const char * val);
	void setAbortTime(const char * val);
	IEspECLQuery & updateQuery();
	void setQuery(IConstECLQuery &ifrom);
	void setHelpers(IArrayOf<IEspECLHelpFile> &val);
 void setHelpers(IArrayOf<IConstECLHelpFile> &val);
	void setExceptions(IArrayOf<IEspECLException> &val);
 void setExceptions(IArrayOf<IConstECLException> &val);
	void setGraphs(IArrayOf<IEspECLGraph> &val);
 void setGraphs(IArrayOf<IConstECLGraph> &val);
	void setSourceFiles(IArrayOf<IEspECLSourceFile> &val);
 void setSourceFiles(IArrayOf<IConstECLSourceFile> &val);
	void setResults(IArrayOf<IEspECLResult> &val);
 void setResults(IArrayOf<IConstECLResult> &val);
	void setVariables(IArrayOf<IEspECLResult> &val);
 void setVariables(IArrayOf<IConstECLResult> &val);
	void setTimers(IArrayOf<IEspECLTimer> &val);
 void setTimers(IArrayOf<IConstECLTimer> &val);
	void setDebugValues(IArrayOf<IEspDebugValue> &val);
 void setDebugValues(IArrayOf<IConstDebugValue> &val);
	void setApplicationValues(IArrayOf<IEspApplicationValue> &val);
 void setApplicationValues(IArrayOf<IConstApplicationValue> &val);
	void setWorkflows(IArrayOf<IEspECLWorkflow> &val);
 void setWorkflows(IArrayOf<IConstECLWorkflow> &val);
	void setTimingData(IArrayOf<IEspECLTimingData> &val);
 void setTimingData(IArrayOf<IConstECLTimingData> &val);
	void setAllowedClusters(StringArray &val);
	void setErrorCount_null();
	void setErrorCount(int val);
	void setWarningCount_null();
	void setWarningCount(int val);
	void setInfoCount_null();
	void setInfoCount(int val);
	void setAlertCount_null();
	void setAlertCount(int val);
	void setGraphCount_null();
	void setGraphCount(int val);
	void setSourceFileCount_null();
	void setSourceFileCount(int val);
	void setResultCount_null();
	void setResultCount(int val);
	void setVariableCount_null();
	void setVariableCount(int val);
	void setTimerCount_null();
	void setTimerCount(int val);
	void setHasDebugValue_null();
	void setHasDebugValue(bool val);
	void setApplicationValueCount_null();
	void setApplicationValueCount(int val);
	void setXmlParams(const char * val);
	void setAccessFlag_null();
	void setAccessFlag(int val);
	void setClusterFlag_null();
	void setClusterFlag(int val);
	void setHelpersDesc(const char * val);
	void setGraphsDesc(const char * val);
	void setSourceFilesDesc(const char * val);
	void setResultsDesc(const char * val);
	void setVariablesDesc(const char * val);
	void setTimersDesc(const char * val);
	void setDebugValuesDesc(const char * val);
	void setApplicationValuesDesc(const char * val);
	void setWorkflowsDesc(const char * val);
	void setHasArchiveQuery_null();
	void setHasArchiveQuery(bool val);
	void setThorLogList(IArrayOf<IEspThorLogInfo> &val);
 void setThorLogList(IArrayOf<IConstThorLogInfo> &val);
	void setResourceURLs(StringArray &val);
	void setResultViewCount_null();
	void setResultViewCount(int val);
	void setResourceURLCount_null();
	void setResourceURLCount(int val);
	void setDebugValueCount_null();
	void setDebugValueCount(int val);
	void setWorkflowCount_null();
	void setWorkflowCount(int val);
	void setHelpersCount_null();
	void setHelpersCount(int val);
};

class CWUECLAttribute : public CSoapComplexType,
   implements IEspWUECLAttribute,
   implements IClientWUECLAttribute
{
protected:
	SoapStringParam m_ModuleName;
	SoapStringParam m_AttributeName;
	SoapParam<bool> m_IsLocked;
	SoapParam<bool> m_IsCheckedOut;
	SoapParam<bool> m_IsSandbox;
	SoapParam<bool> m_IsOrphaned;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CWUECLAttribute(const char *serviceName, const char *bcompat);

	CWUECLAttribute(const char *serviceName, IRpcMessageBinding *init=NULL);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "WUECLAttribute";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CWUECLAttribute &from);

	void copy(IConstWUECLAttribute &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstWUECLAttribute &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	const char * getModuleName();
	const char * getAttributeName();
bool getIsLocked_isNull();
	bool getIsLocked();
bool getIsCheckedOut_isNull();
	bool getIsCheckedOut();
bool getIsSandbox_isNull();
	bool getIsSandbox();
bool getIsOrphaned_isNull();
	bool getIsOrphaned();
	void setModuleName(const char * val);
	void setAttributeName(const char * val);
	void setIsLocked_null();
	void setIsLocked(bool val);
	void setIsCheckedOut_null();
	void setIsCheckedOut(bool val);
	void setIsSandbox_null();
	void setIsSandbox(bool val);
	void setIsOrphaned_null();
	void setIsOrphaned(bool val);
};

class CNetworkNode : public CSoapComplexType,
   implements IEspNetworkNode,
   implements IClientNetworkNode
{
protected:
	SoapParam<int> m_Category;
	SoapStringParam m_id;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CNetworkNode(const char *serviceName, const char *bcompat);

	CNetworkNode(const char *serviceName, IRpcMessageBinding *init=NULL);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "NetworkNode";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CNetworkNode &from);

	void copy(IConstNetworkNode &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstNetworkNode &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	int getCategory();
	const char * getId();
	void setCategory(int val);
	void setId(const char * val);
};

class CClusterEndpoint : public CSoapComplexType,
   implements IEspClusterEndpoint,
   implements IClientClusterEndpoint
{
protected:
	SoapStringParam m_URL;
	SoapStringParam m_Status;
	SoapParam<int> m_NumQueryFileToCopy;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CClusterEndpoint(const char *serviceName, const char *bcompat);

	CClusterEndpoint(const char *serviceName, IRpcMessageBinding *init=NULL);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "ClusterEndpoint";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CClusterEndpoint &from);

	void copy(IConstClusterEndpoint &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstClusterEndpoint &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	const char * getURL();
	const char * getStatus();
bool getNumQueryFileToCopy_isNull();
	int getNumQueryFileToCopy();
	void setURL(const char * val);
	void setStatus(const char * val);
	void setNumQueryFileToCopy_null();
	void setNumQueryFileToCopy(int val);
};

class CLogicalFileUpload : public CSoapComplexType,
   implements IEspLogicalFileUpload,
   implements IClientLogicalFileUpload
{
protected:
	SoapParam<int> m_Type;
	SoapStringParam m_Source;
	SoapStringParam m_Destination;
	SoapStringParam m_EventTag;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CLogicalFileUpload(const char *serviceName, const char *bcompat);

	CLogicalFileUpload(const char *serviceName, IRpcMessageBinding *init=NULL);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "LogicalFileUpload";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CLogicalFileUpload &from);

	void copy(IConstLogicalFileUpload &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstLogicalFileUpload &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	int getType();
	const char * getSource();
	const char * getDestination();
	const char * getEventTag();
	void setType(int val);
	void setSource(const char * val);
	void setDestination(const char * val);
	void setEventTag(const char * val);
};

class CECLJob : public CSoapComplexType,
   implements IEspECLJob,
   implements IClientECLJob
{
protected:
	SoapStringParam m_Wuid;
	SoapStringParam m_Graph;
	SoapStringParam m_State;
	SoapStringParam m_StartedDate;
	SoapStringParam m_FinishedDate;
	SoapStringParam m_Cluster;
	SoapStringParam m_GraphNum;
	SoapStringParam m_SubGraphNum;
	SoapStringParam m_NumOfRuns;
	SoapParam<int> m_Duration;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CECLJob(const char *serviceName, const char *bcompat);

	CECLJob(const char *serviceName, IRpcMessageBinding *init=NULL);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "ECLJob";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CECLJob &from);

	void copy(IConstECLJob &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstECLJob &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	const char * getWuid();
	const char * getGraph();
	const char * getState();
	const char * getStartedDate();
	const char * getFinishedDate();
	const char * getCluster();
	const char * getGraphNum();
	const char * getSubGraphNum();
	const char * getNumOfRuns();
bool getDuration_isNull();
	int getDuration();
	void setWuid(const char * val);
	void setGraph(const char * val);
	void setState(const char * val);
	void setStartedDate(const char * val);
	void setFinishedDate(const char * val);
	void setCluster(const char * val);
	void setGraphNum(const char * val);
	void setSubGraphNum(const char * val);
	void setNumOfRuns(const char * val);
	void setDuration_null();
	void setDuration(int val);
};

class CThorQueue : public CSoapComplexType,
   implements IEspThorQueue,
   implements IClientThorQueue
{
protected:
	SoapStringParam m_DT;
	SoapStringParam m_RunningWUs;
	SoapStringParam m_QueuedWUs;
	SoapStringParam m_WaitingThors;
	SoapStringParam m_ConnectedThors;
	SoapStringParam m_IdledThors;
	SoapStringParam m_RunningWU1;
	SoapStringParam m_RunningWU2;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CThorQueue(const char *serviceName, const char *bcompat);

	CThorQueue(const char *serviceName, IRpcMessageBinding *init=NULL);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "ThorQueue";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CThorQueue &from);

	void copy(IConstThorQueue &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstThorQueue &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	const char * getDT();
	const char * getRunningWUs();
	const char * getQueuedWUs();
	const char * getWaitingThors();
	const char * getConnectedThors();
	const char * getIdledThors();
	const char * getRunningWU1();
	const char * getRunningWU2();
	void setDT(const char * val);
	void setRunningWUs(const char * val);
	void setQueuedWUs(const char * val);
	void setWaitingThors(const char * val);
	void setConnectedThors(const char * val);
	void setIdledThors(const char * val);
	void setRunningWU1(const char * val);
	void setRunningWU2(const char * val);
};

class CResubmittedWU : public CSoapComplexType,
   implements IEspResubmittedWU,
   implements IClientResubmittedWU
{
protected:
	SoapStringParam m_WUID;
	SoapStringParam m_ParentWUID;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CResubmittedWU(const char *serviceName, const char *bcompat);

	CResubmittedWU(const char *serviceName, IRpcMessageBinding *init=NULL);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "ResubmittedWU";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CResubmittedWU &from);

	void copy(IConstResubmittedWU &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstResubmittedWU &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	const char * getWUID();
	const char * getParentWUID();
	void setWUID(const char * val);
	void setParentWUID(const char * val);
};

class CXWUFileType : public SoapEnumParamNew<CWUFileType>
{
public:
	CXWUFileType(nilBehavior nilB) : SoapEnumParamNew<CWUFileType>(nilB)
	{ doInit(); }
	CXWUFileType(CWUFileType defvalue_) : SoapEnumParamNew<CWUFileType>(defvalue_)
	{ doInit(); }
	CXWUFileType(const char* defvalue_) : SoapEnumParamNew<CWUFileType>()
	{ doInit(); setDefaultValue(defvalue_); }
	static  void getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash &added)
	{ getSharedInstance().getXsdDefinitionInternal(context,request,schema,added); }
	static void getMapInfo(IMapInfo& info, BoolHash& added) { getSharedInstance().getMapInfo_(info,added); }

	static const char* stringOf(CWUFileType val) { return getSharedInstance().toString(val); }

	static CWUFileType enumOf(const char* s) { return getSharedInstance().toEnum(s); }

static const char *queryXsdElementName() { return "WUFileType"; }
private:
	static CXWUFileType& getSharedInstance() { static CXWUFileType instance(nilIgnore); return instance; }
	void getMapInfo_(IMapInfo& info, BoolHash& added) {  }
	void getXsdDefinitionInternal(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash &added)
	{ getXsdDefinition_(context,request,schema,added,NULL); }
	void doInit()
	{
		static const char* inits[] = {"XML","cpp","dll","res","log","WUECL","ThorLog","ThorSlaveLog","EclAgentLog","ArchiveQuery",NULL};
		init("WUFileType","string",inits);
	}
};

class CWUFileOption : public CSoapComplexType,
   implements IEspWUFileOption,
   implements IClientWUFileOption
{
protected:
	CXWUFileType m_FileType;
	SoapStringParam m_Name;
	SoapStringParam m_IPAddress;
	SoapStringParam m_Description;
	SoapStringParam m_Process;
	SoapStringParam m_LogDate;
	SoapStringParam m_ClusterGroup;
	SoapStringParam m_PlainText;
	SoapParam<int> m_SlaveNumber;
	SoapParam<__int64> m_SizeLimit;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CWUFileOption(const char *serviceName, const char *bcompat);

	CWUFileOption(const char *serviceName, IRpcMessageBinding *init=NULL);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "WUFileOption";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CWUFileOption &from);

	void copy(IConstWUFileOption &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstWUFileOption &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	CWUFileType getFileType();
	const char* getFileTypeAsString();
	const char * getName();
	const char * getIPAddress();
	const char * getDescription();
	const char * getProcess();
	const char * getLogDate();
	const char * getClusterGroup();
	const char * getPlainText();
	int getSlaveNumber();
	__int64 getSizeLimit();
	void setFileType(CWUFileType val);
void setFileType(const char* val);
	void setName(const char * val);
	void setIPAddress(const char * val);
	void setDescription(const char * val);
	void setProcess(const char * val);
	void setLogDate(const char * val);
	void setClusterGroup(const char * val);
	void setPlainText(const char * val);
	void setSlaveNumber(int val);
	void setSizeLimit(__int64 val);
};

class CXWUFileDownloadOption : public SoapEnumParamNew<CWUFileDownloadOption>
{
public:
	CXWUFileDownloadOption(nilBehavior nilB) : SoapEnumParamNew<CWUFileDownloadOption>(nilB)
	{ doInit(); }
	CXWUFileDownloadOption(CWUFileDownloadOption defvalue_) : SoapEnumParamNew<CWUFileDownloadOption>(defvalue_)
	{ doInit(); }
	CXWUFileDownloadOption(const char* defvalue_) : SoapEnumParamNew<CWUFileDownloadOption>()
	{ doInit(); setDefaultValue(defvalue_); }
	static  void getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash &added)
	{ getSharedInstance().getXsdDefinitionInternal(context,request,schema,added); }
	static void getMapInfo(IMapInfo& info, BoolHash& added) { getSharedInstance().getMapInfo_(info,added); }

	static const char* stringOf(CWUFileDownloadOption val) { return getSharedInstance().toString(val); }

	static CWUFileDownloadOption enumOf(const char* s) { return getSharedInstance().toEnum(s); }

static const char *queryXsdElementName() { return "WUFileDownloadOption"; }
private:
	static CXWUFileDownloadOption& getSharedInstance() { static CXWUFileDownloadOption instance(nilIgnore); return instance; }
	void getMapInfo_(IMapInfo& info, BoolHash& added) {  }
	void getXsdDefinitionInternal(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash &added)
	{
		const char* descriptions [] = {"OriginalText","Attachment","ZIP","GZIP",};
		getXsdDefinition_(context,request,schema,added,descriptions);
	}
	void doInit()
	{
		static const char* inits[] = {"0","1","2","3",NULL};
		init("WUFileDownloadOption","int",inits);
	}
};

class CWUCreateRequest : public CSoapRequestBinding,
   implements IEspWUCreateRequest,
   implements IClientWUCreateRequest
{
protected:

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CWUCreateRequest(const char *serviceName, const char *bcompat);

	CWUCreateRequest(const char *serviceName, IRpcMessageBinding *init=NULL);
	CWUCreateRequest(const char *serviceName, IRpcMessage* rpcmsg);
	CWUCreateRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	IEspClientRpcSettings &rpc(){return *static_cast<IEspClientRpcSettings*>(this);}


	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "WUCreateRequest";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CWUCreateRequest &from);

	void copy(IConstWUCreateRequest &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstWUCreateRequest &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

};

class CWUCreateResponse : public CSoapResponseBinding,
   implements IEspWUCreateResponse,
   implements IClientWUCreateResponse
{
protected:
	SoapStruct<CECLWorkunit, IConstECLWorkunit> m_Workunit;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CWUCreateResponse(const char *serviceName, const char *bcompat);

	CWUCreateResponse(const char *serviceName, IRpcMessageBinding *init=NULL);
	CWUCreateResponse(const char *serviceName, IRpcMessage* rpcmsg);
	CWUCreateResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "WUCreateResponse";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CWUCreateResponse &from);

	void copy(IConstWUCreateResponse &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstWUCreateResponse &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	virtual void setRedirectUrl(const char *url)
	{ CSoapResponseBinding::setRedirectUrl(url); }

	virtual const IMultiException& getExceptions()
	{ return CSoapResponseBinding::getExceptions(); }

	virtual int queryClientStatus()
	{ return CSoapResponseBinding::getRpcState(); }

	virtual void noteException(IException& e)
	{  CSoapResponseBinding::noteException(e); }

	IConstECLWorkunit & getWorkunit();
	IEspECLWorkunit & updateWorkunit();
	void setWorkunit(IConstECLWorkunit &ifrom);
};

class CWUDeployWorkunitRequest : public CSoapRequestBinding,
   implements IEspWUDeployWorkunitRequest,
   implements IClientWUDeployWorkunitRequest
{
protected:
	SoapStringParam m_Cluster;
	SoapStringParam m_Name;
	SoapParam<int> m_Wait;
	SoapStringParam m_ObjType;
	SoapStringParam m_FileName;
	SoapParamBinary m_Object;
	SoapParam<int> m_ResultLimit;
	SoapStringParam m_QueryMainDefinition;
	SoapStringParam m_Snapshot;
	SoapStructArrayParam<IConstNamedValue, CNamedValue> m_DebugValues;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CWUDeployWorkunitRequest(const char *serviceName, const char *bcompat);

	CWUDeployWorkunitRequest(const char *serviceName, IRpcMessageBinding *init=NULL);
	CWUDeployWorkunitRequest(const char *serviceName, IRpcMessage* rpcmsg);
	CWUDeployWorkunitRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	IEspClientRpcSettings &rpc(){return *static_cast<IEspClientRpcSettings*>(this);}


	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "WUDeployWorkunitRequest";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CWUDeployWorkunitRequest &from);

	void copy(IConstWUDeployWorkunitRequest &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstWUDeployWorkunitRequest &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	const char * getCluster();
	const char * getName();
bool getWait_isNull();
	int getWait();
	const char * getObjType();
	const char * getFileName();
	const MemoryBuffer & getObject();
bool getResultLimit_isNull();
	int getResultLimit();
	const char * getQueryMainDefinition();
	const char * getSnapshot();
	IArrayOf<IConstNamedValue> & getDebugValues();
	void setCluster(const char * val);
	void setName(const char * val);
	void setWait_null();
	void setWait(int val);
	void setObjType(const char * val);
	void setFileName(const char * val);
	void setObject(const MemoryBuffer & val);
	void setResultLimit_null();
	void setResultLimit(int val);
	void setQueryMainDefinition(const char * val);
	void setSnapshot(const char * val);
	void setDebugValues(IArrayOf<IEspNamedValue> &val);
 void setDebugValues(IArrayOf<IConstNamedValue> &val);
};

class CWUDeployWorkunitResponse : public CSoapResponseBinding,
   implements IEspWUDeployWorkunitResponse,
   implements IClientWUDeployWorkunitResponse
{
protected:
	SoapStruct<CECLWorkunit, IConstECLWorkunit> m_Workunit;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CWUDeployWorkunitResponse(const char *serviceName, const char *bcompat);

	CWUDeployWorkunitResponse(const char *serviceName, IRpcMessageBinding *init=NULL);
	CWUDeployWorkunitResponse(const char *serviceName, IRpcMessage* rpcmsg);
	CWUDeployWorkunitResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "WUDeployWorkunitResponse";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CWUDeployWorkunitResponse &from);

	void copy(IConstWUDeployWorkunitResponse &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstWUDeployWorkunitResponse &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	virtual void setRedirectUrl(const char *url)
	{ CSoapResponseBinding::setRedirectUrl(url); }

	virtual const IMultiException& getExceptions()
	{ return CSoapResponseBinding::getExceptions(); }

	virtual int queryClientStatus()
	{ return CSoapResponseBinding::getRpcState(); }

	virtual void noteException(IException& e)
	{  CSoapResponseBinding::noteException(e); }

	IConstECLWorkunit & getWorkunit();
	IEspECLWorkunit & updateWorkunit();
	void setWorkunit(IConstECLWorkunit &ifrom);
};

class CWUQueryRequest : public CSoapRequestBinding,
   implements IEspWUQueryRequest,
   implements IClientWUQueryRequest
{
protected:
	SoapStringParam m_Wuid;
	SoapStringParam m_Type;
	SoapStringParam m_Cluster;
	SoapStringParam m_RoxieCluster;
	SoapStringParam m_Owner;
	SoapStringParam m_State;
	SoapStringParam m_StartDate;
	SoapStringParam m_EndDate;
	SoapStringParam m_ECL;
	SoapStringParam m_Jobname;
	SoapStringParam m_LogicalFile;
	SoapStringParam m_LogicalFileSearchType;
	SoapStringParam m_ApplicationName;
	SoapStringParam m_ApplicationKey;
	SoapStringParam m_ApplicationData;
	SoapStructArrayParam<IConstApplicationValue, CApplicationValue> m_ApplicationValues;
	SoapStringParam m_BeforeWU;
	SoapStringParam m_AfterWU;
	SoapStringParam m_After;
	SoapStringParam m_Before;
	SoapParam<int> m_Count;
	SoapParam<__int64> m_PageSize;
	SoapParam<__int64> m_PageStartFrom;
	SoapParam<__int64> m_PageEndAt;
	SoapParam<int> m_LastNDays;
	SoapStringParam m_Sortby;
	SoapParam<bool> m_Descending;
	SoapParam<__int64> m_CacheHint;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CWUQueryRequest(const char *serviceName, const char *bcompat);

	CWUQueryRequest(const char *serviceName, IRpcMessageBinding *init=NULL);
	CWUQueryRequest(const char *serviceName, IRpcMessage* rpcmsg);
	CWUQueryRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	IEspClientRpcSettings &rpc(){return *static_cast<IEspClientRpcSettings*>(this);}


	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "WUQueryRequest";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CWUQueryRequest &from);

	void copy(IConstWUQueryRequest &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstWUQueryRequest &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	const char * getWuid();
	const char * getType();
	const char * getCluster();
	const char * getRoxieCluster();
	const char * getOwner();
	const char * getState();
	const char * getStartDate();
	const char * getEndDate();
	const char * getECL();
	const char * getJobname();
	const char * getLogicalFile();
	const char * getLogicalFileSearchType();
	const char * getApplicationName();
	const char * getApplicationKey();
	const char * getApplicationData();
	IArrayOf<IConstApplicationValue> & getApplicationValues();
	const char * getBeforeWU();
	const char * getAfterWU();
	const char * getAfter();
	const char * getBefore();
bool getCount_isNull();
	int getCount();
bool getPageSize_isNull();
	__int64 getPageSize();
bool getPageStartFrom_isNull();
	__int64 getPageStartFrom();
bool getPageEndAt_isNull();
	__int64 getPageEndAt();
bool getLastNDays_isNull();
	int getLastNDays();
	const char * getSortby();
bool getDescending_isNull();
	bool getDescending();
bool getCacheHint_isNull();
	__int64 getCacheHint();
	void setWuid(const char * val);
	void setType(const char * val);
	void setCluster(const char * val);
	void setRoxieCluster(const char * val);
	void setOwner(const char * val);
	void setState(const char * val);
	void setStartDate(const char * val);
	void setEndDate(const char * val);
	void setECL(const char * val);
	void setJobname(const char * val);
	void setLogicalFile(const char * val);
	void setLogicalFileSearchType(const char * val);
	void setApplicationName(const char * val);
	void setApplicationKey(const char * val);
	void setApplicationData(const char * val);
	void setApplicationValues(IArrayOf<IEspApplicationValue> &val);
 void setApplicationValues(IArrayOf<IConstApplicationValue> &val);
	void setBeforeWU(const char * val);
	void setAfterWU(const char * val);
	void setAfter(const char * val);
	void setBefore(const char * val);
	void setCount_null();
	void setCount(int val);
	void setPageSize_null();
	void setPageSize(__int64 val);
	void setPageStartFrom_null();
	void setPageStartFrom(__int64 val);
	void setPageEndAt_null();
	void setPageEndAt(__int64 val);
	void setLastNDays_null();
	void setLastNDays(int val);
	void setSortby(const char * val);
	void setDescending_null();
	void setDescending(bool val);
	void setCacheHint_null();
	void setCacheHint(__int64 val);
};

class CWUQueryResponse : public CSoapResponseBinding,
   implements IEspWUQueryResponse,
   implements IClientWUQueryResponse
{
protected:
	SoapStringParam m_Type;
	SoapStringParam m_Cluster;
	SoapStringParam m_RoxieCluster;
	SoapStringParam m_Owner;
	SoapStringParam m_State;
	SoapStringParam m_StartDate;
	SoapStringParam m_EndDate;
	SoapStringParam m_ECL;
	SoapStringParam m_Jobname;
	SoapStringParam m_LogicalFile;
	SoapStringParam m_LogicalFileSearchType;
	SoapStringParam m_Current;
	SoapStringParam m_Next;
	SoapParam<int> m_Count;
	SoapParam<__int64> m_PageSize;
	SoapParam<__int64> m_PrevPage;
	SoapParam<__int64> m_NextPage;
	SoapParam<__int64> m_LastPage;
	SoapParam<int> m_NumWUs;
	SoapParam<bool> m_First;
	SoapParam<__int64> m_PageStartFrom;
	SoapParam<__int64> m_PageEndAt;
	SoapParam<int> m_LastNDays;
	SoapStringParam m_Sortby;
	SoapParam<bool> m_Descending;
	SoapStringParam m_BasicQuery;
	SoapStringParam m_Filters;
	SoapParam<__int64> m_CacheHint;
	SoapStructArrayParam<IConstECLWorkunit, CECLWorkunit> m_Workunits;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CWUQueryResponse(const char *serviceName, const char *bcompat);

	CWUQueryResponse(const char *serviceName, IRpcMessageBinding *init=NULL);
	CWUQueryResponse(const char *serviceName, IRpcMessage* rpcmsg);
	CWUQueryResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "WUQueryResponse";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CWUQueryResponse &from);

	void copy(IConstWUQueryResponse &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstWUQueryResponse &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	virtual void setRedirectUrl(const char *url)
	{ CSoapResponseBinding::setRedirectUrl(url); }

	virtual const IMultiException& getExceptions()
	{ return CSoapResponseBinding::getExceptions(); }

	virtual int queryClientStatus()
	{ return CSoapResponseBinding::getRpcState(); }

	virtual void noteException(IException& e)
	{  CSoapResponseBinding::noteException(e); }

	const char * getType();
	const char * getCluster();
	const char * getRoxieCluster();
	const char * getOwner();
	const char * getState();
	const char * getStartDate();
	const char * getEndDate();
	const char * getECL();
	const char * getJobname();
	const char * getLogicalFile();
	const char * getLogicalFileSearchType();
	const char * getCurrent();
	const char * getNext();
bool getCount_isNull();
	int getCount();
bool getPageSize_isNull();
	__int64 getPageSize();
bool getPrevPage_isNull();
	__int64 getPrevPage();
bool getNextPage_isNull();
	__int64 getNextPage();
bool getLastPage_isNull();
	__int64 getLastPage();
bool getNumWUs_isNull();
	int getNumWUs();
bool getFirst_isNull();
	bool getFirst();
bool getPageStartFrom_isNull();
	__int64 getPageStartFrom();
bool getPageEndAt_isNull();
	__int64 getPageEndAt();
bool getLastNDays_isNull();
	int getLastNDays();
	const char * getSortby();
bool getDescending_isNull();
	bool getDescending();
	const char * getBasicQuery();
	const char * getFilters();
bool getCacheHint_isNull();
	__int64 getCacheHint();
	IArrayOf<IConstECLWorkunit> & getWorkunits();
	void setType(const char * val);
	void setCluster(const char * val);
	void setRoxieCluster(const char * val);
	void setOwner(const char * val);
	void setState(const char * val);
	void setStartDate(const char * val);
	void setEndDate(const char * val);
	void setECL(const char * val);
	void setJobname(const char * val);
	void setLogicalFile(const char * val);
	void setLogicalFileSearchType(const char * val);
	void setCurrent(const char * val);
	void setNext(const char * val);
	void setCount_null();
	void setCount(int val);
	void setPageSize_null();
	void setPageSize(__int64 val);
	void setPrevPage_null();
	void setPrevPage(__int64 val);
	void setNextPage_null();
	void setNextPage(__int64 val);
	void setLastPage_null();
	void setLastPage(__int64 val);
	void setNumWUs_null();
	void setNumWUs(int val);
	void setFirst_null();
	void setFirst(bool val);
	void setPageStartFrom_null();
	void setPageStartFrom(__int64 val);
	void setPageEndAt_null();
	void setPageEndAt(__int64 val);
	void setLastNDays_null();
	void setLastNDays(int val);
	void setSortby(const char * val);
	void setDescending_null();
	void setDescending(bool val);
	void setBasicQuery(const char * val);
	void setFilters(const char * val);
	void setCacheHint_null();
	void setCacheHint(__int64 val);
	void setWorkunits(IArrayOf<IEspECLWorkunit> &val);
 void setWorkunits(IArrayOf<IConstECLWorkunit> &val);
};

class CWULightWeightQueryRequest : public CSoapRequestBinding,
   implements IEspWULightWeightQueryRequest,
   implements IClientWULightWeightQueryRequest
{
protected:
	SoapStringParam m_Wuid;
	SoapStringParam m_Type;
	SoapStringParam m_Cluster;
	SoapStringParam m_Owner;
	SoapStringParam m_JobName;
	SoapStringParam m_StartDate;
	SoapStringParam m_EndDate;
	SoapStringParam m_BeforeWU;
	SoapStringParam m_AfterWU;
	SoapStringParam m_State;
	SoapStructArrayParam<IConstApplicationValue, CApplicationValue> m_ApplicationValues;
	SoapParam<__int64> m_PageStartFrom;
	SoapParam<unsigned int> m_PageSize;
	SoapStringParam m_SortBy;
	SoapParam<bool> m_Descending;
	SoapParam<__int64> m_CacheHint;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CWULightWeightQueryRequest(const char *serviceName, const char *bcompat);

	CWULightWeightQueryRequest(const char *serviceName, IRpcMessageBinding *init=NULL);
	CWULightWeightQueryRequest(const char *serviceName, IRpcMessage* rpcmsg);
	CWULightWeightQueryRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	IEspClientRpcSettings &rpc(){return *static_cast<IEspClientRpcSettings*>(this);}


	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "WULightWeightQueryRequest";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CWULightWeightQueryRequest &from);

	void copy(IConstWULightWeightQueryRequest &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstWULightWeightQueryRequest &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	const char * getWuid();
	const char * getType();
	const char * getCluster();
	const char * getOwner();
	const char * getJobName();
	const char * getStartDate();
	const char * getEndDate();
	const char * getBeforeWU();
	const char * getAfterWU();
	const char * getState();
	IArrayOf<IConstApplicationValue> & getApplicationValues();
bool getPageStartFrom_isNull();
	__int64 getPageStartFrom();
bool getPageSize_isNull();
	unsigned int getPageSize();
	const char * getSortBy();
bool getDescending_isNull();
	bool getDescending();
bool getCacheHint_isNull();
	__int64 getCacheHint();
	void setWuid(const char * val);
	void setType(const char * val);
	void setCluster(const char * val);
	void setOwner(const char * val);
	void setJobName(const char * val);
	void setStartDate(const char * val);
	void setEndDate(const char * val);
	void setBeforeWU(const char * val);
	void setAfterWU(const char * val);
	void setState(const char * val);
	void setApplicationValues(IArrayOf<IEspApplicationValue> &val);
 void setApplicationValues(IArrayOf<IConstApplicationValue> &val);
	void setPageStartFrom_null();
	void setPageStartFrom(__int64 val);
	void setPageSize_null();
	void setPageSize(unsigned int val);
	void setSortBy(const char * val);
	void setDescending_null();
	void setDescending(bool val);
	void setCacheHint_null();
	void setCacheHint(__int64 val);
};

class CWULightWeightQueryResponse : public CSoapResponseBinding,
   implements IEspWULightWeightQueryResponse,
   implements IClientWULightWeightQueryResponse
{
protected:
	SoapParam<int> m_NumWUs;
	SoapParam<__int64> m_CacheHint;
	SoapStructArrayParam<IConstECLWorkunitLW, CECLWorkunitLW> m_Workunits;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CWULightWeightQueryResponse(const char *serviceName, const char *bcompat);

	CWULightWeightQueryResponse(const char *serviceName, IRpcMessageBinding *init=NULL);
	CWULightWeightQueryResponse(const char *serviceName, IRpcMessage* rpcmsg);
	CWULightWeightQueryResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "WULightWeightQueryResponse";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CWULightWeightQueryResponse &from);

	void copy(IConstWULightWeightQueryResponse &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstWULightWeightQueryResponse &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	virtual void setRedirectUrl(const char *url)
	{ CSoapResponseBinding::setRedirectUrl(url); }

	virtual const IMultiException& getExceptions()
	{ return CSoapResponseBinding::getExceptions(); }

	virtual int queryClientStatus()
	{ return CSoapResponseBinding::getRpcState(); }

	virtual void noteException(IException& e)
	{  CSoapResponseBinding::noteException(e); }

bool getNumWUs_isNull();
	int getNumWUs();
bool getCacheHint_isNull();
	__int64 getCacheHint();
	IArrayOf<IConstECLWorkunitLW> & getWorkunits();
	void setNumWUs_null();
	void setNumWUs(int val);
	void setCacheHint_null();
	void setCacheHint(__int64 val);
	void setWorkunits(IArrayOf<IEspECLWorkunitLW> &val);
 void setWorkunits(IArrayOf<IConstECLWorkunitLW> &val);
};

class CWUUpdateRequest : public CSoapRequestBinding,
   implements IEspWUUpdateRequest,
   implements IClientWUUpdateRequest
{
protected:
	SoapStringParam m_Wuid;
	SoapParam<int> m_State;
	SoapParam<int> m_StateOrig;
	SoapStringParam m_Jobname;
	SoapStringParam m_JobnameOrig;
	SoapStringParam m_QueryText;
	SoapParam<int> m_Action;
	SoapStringParam m_Description;
	SoapStringParam m_DescriptionOrig;
	SoapParam<bool> m_AddDrilldownFields;
	SoapParam<int> m_ResultLimit;
	SoapParam<bool> m_Protected;
	SoapParam<bool> m_ProtectedOrig;
	SoapParam<int> m_PriorityClass;
	SoapParam<int> m_PriorityLevel;
	SoapStringParam m_Scope;
	SoapStringParam m_ScopeOrig;
	SoapStringParam m_ClusterSelection;
	SoapStringParam m_ClusterOrig;
	SoapStringParam m_XmlParams;
	SoapStringParam m_ThorSlaveIP;
	SoapStringParam m_QueryMainDefinition;
	SoapStructArrayParam<IConstDebugValue, CDebugValue> m_DebugValues;
	SoapStructArrayParam<IConstApplicationValue, CApplicationValue> m_ApplicationValues;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CWUUpdateRequest(const char *serviceName, const char *bcompat);

	CWUUpdateRequest(const char *serviceName, IRpcMessageBinding *init=NULL);
	CWUUpdateRequest(const char *serviceName, IRpcMessage* rpcmsg);
	CWUUpdateRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	IEspClientRpcSettings &rpc(){return *static_cast<IEspClientRpcSettings*>(this);}


	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "WUUpdateRequest";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CWUUpdateRequest &from);

	void copy(IConstWUUpdateRequest &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstWUUpdateRequest &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	const char * getWuid();
bool getState_isNull();
	int getState();
bool getStateOrig_isNull();
	int getStateOrig();
	const char * getJobname();
	const char * getJobnameOrig();
	const char * getQueryText();
bool getAction_isNull();
	int getAction();
	const char * getDescription();
	const char * getDescriptionOrig();
bool getAddDrilldownFields_isNull();
	bool getAddDrilldownFields();
bool getResultLimit_isNull();
	int getResultLimit();
bool getProtected_isNull();
	bool getProtected();
bool getProtectedOrig_isNull();
	bool getProtectedOrig();
bool getPriorityClass_isNull();
	int getPriorityClass();
bool getPriorityLevel_isNull();
	int getPriorityLevel();
	const char * getScope();
	const char * getScopeOrig();
	const char * getClusterSelection();
	const char * getClusterOrig();
	const char * getXmlParams();
	const char * getThorSlaveIP();
	const char * getQueryMainDefinition();
	IArrayOf<IConstDebugValue> & getDebugValues();
	IArrayOf<IConstApplicationValue> & getApplicationValues();
	void setWuid(const char * val);
	void setState_null();
	void setState(int val);
	void setStateOrig_null();
	void setStateOrig(int val);
	void setJobname(const char * val);
	void setJobnameOrig(const char * val);
	void setQueryText(const char * val);
	void setAction_null();
	void setAction(int val);
	void setDescription(const char * val);
	void setDescriptionOrig(const char * val);
	void setAddDrilldownFields_null();
	void setAddDrilldownFields(bool val);
	void setResultLimit_null();
	void setResultLimit(int val);
	void setProtected_null();
	void setProtected(bool val);
	void setProtectedOrig_null();
	void setProtectedOrig(bool val);
	void setPriorityClass_null();
	void setPriorityClass(int val);
	void setPriorityLevel_null();
	void setPriorityLevel(int val);
	void setScope(const char * val);
	void setScopeOrig(const char * val);
	void setClusterSelection(const char * val);
	void setClusterOrig(const char * val);
	void setXmlParams(const char * val);
	void setThorSlaveIP(const char * val);
	void setQueryMainDefinition(const char * val);
	void setDebugValues(IArrayOf<IEspDebugValue> &val);
 void setDebugValues(IArrayOf<IConstDebugValue> &val);
	void setApplicationValues(IArrayOf<IEspApplicationValue> &val);
 void setApplicationValues(IArrayOf<IConstApplicationValue> &val);
};

class CWUUpdateResponse : public CSoapResponseBinding,
   implements IEspWUUpdateResponse,
   implements IClientWUUpdateResponse
{
protected:
	SoapStruct<CECLWorkunit, IConstECLWorkunit> m_Workunit;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CWUUpdateResponse(const char *serviceName, const char *bcompat);

	CWUUpdateResponse(const char *serviceName, IRpcMessageBinding *init=NULL);
	CWUUpdateResponse(const char *serviceName, IRpcMessage* rpcmsg);
	CWUUpdateResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "WUUpdateResponse";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CWUUpdateResponse &from);

	void copy(IConstWUUpdateResponse &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstWUUpdateResponse &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	virtual void setRedirectUrl(const char *url)
	{ CSoapResponseBinding::setRedirectUrl(url); }

	virtual const IMultiException& getExceptions()
	{ return CSoapResponseBinding::getExceptions(); }

	virtual int queryClientStatus()
	{ return CSoapResponseBinding::getRpcState(); }

	virtual void noteException(IException& e)
	{  CSoapResponseBinding::noteException(e); }

	IConstECLWorkunit & getWorkunit();
	IEspECLWorkunit & updateWorkunit();
	void setWorkunit(IConstECLWorkunit &ifrom);
};

class CWUDeleteRequest : public CSoapRequestBinding,
   implements IEspWUDeleteRequest,
   implements IClientWUDeleteRequest
{
protected:
	SoapStringArray m_Wuids;
	SoapParam<int> m_BlockTillFinishTimer;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CWUDeleteRequest(const char *serviceName, const char *bcompat);

	CWUDeleteRequest(const char *serviceName, IRpcMessageBinding *init=NULL);
	CWUDeleteRequest(const char *serviceName, IRpcMessage* rpcmsg);
	CWUDeleteRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	IEspClientRpcSettings &rpc(){return *static_cast<IEspClientRpcSettings*>(this);}


	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "WUDeleteRequest";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CWUDeleteRequest &from);

	void copy(IConstWUDeleteRequest &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstWUDeleteRequest &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	StringArray & getWuids();
	int getBlockTillFinishTimer();
	void setWuids(StringArray &val);
	void setBlockTillFinishTimer(int val);
};

class CWUDeleteResponse : public CSoapResponseBinding,
   implements IEspWUDeleteResponse,
   implements IClientWUDeleteResponse
{
protected:
	SoapStructArrayParam<IConstWUActionResult, CWUActionResult> m_ActionResults;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CWUDeleteResponse(const char *serviceName, const char *bcompat);

	CWUDeleteResponse(const char *serviceName, IRpcMessageBinding *init=NULL);
	CWUDeleteResponse(const char *serviceName, IRpcMessage* rpcmsg);
	CWUDeleteResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "WUDeleteResponse";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CWUDeleteResponse &from);

	void copy(IConstWUDeleteResponse &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstWUDeleteResponse &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	virtual void setRedirectUrl(const char *url)
	{ CSoapResponseBinding::setRedirectUrl(url); }

	virtual const IMultiException& getExceptions()
	{ return CSoapResponseBinding::getExceptions(); }

	virtual int queryClientStatus()
	{ return CSoapResponseBinding::getRpcState(); }

	virtual void noteException(IException& e)
	{  CSoapResponseBinding::noteException(e); }

	IArrayOf<IConstWUActionResult> & getActionResults();
	void setActionResults(IArrayOf<IEspWUActionResult> &val);
 void setActionResults(IArrayOf<IConstWUActionResult> &val);
};

class CWUActionRequest : public CSoapRequestBinding,
   implements IEspWUActionRequest,
   implements IClientWUActionRequest
{
protected:
	SoapStringArray m_Wuids;
	SoapStringParam m_ActionType;
	CXECLWUActions m_WUActionType;
	SoapStringParam m_Cluster;
	SoapStringParam m_Owner;
	SoapStringParam m_State;
	SoapStringParam m_StartDate;
	SoapStringParam m_EndDate;
	SoapStringParam m_ECL;
	SoapStringParam m_Jobname;
	SoapStringParam m_Test;
	SoapStringParam m_CurrentPage;
	SoapStringParam m_PageSize;
	SoapStringParam m_Sortby;
	SoapParam<bool> m_Descending;
	SoapStringParam m_EventServer;
	SoapStringParam m_EventName;
	SoapStringParam m_PageFrom;
	SoapParam<int> m_BlockTillFinishTimer;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CWUActionRequest(const char *serviceName, const char *bcompat);

	CWUActionRequest(const char *serviceName, IRpcMessageBinding *init=NULL);
	CWUActionRequest(const char *serviceName, IRpcMessage* rpcmsg);
	CWUActionRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	IEspClientRpcSettings &rpc(){return *static_cast<IEspClientRpcSettings*>(this);}


	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "WUActionRequest";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CWUActionRequest &from);

	void copy(IConstWUActionRequest &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstWUActionRequest &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	StringArray & getWuids();
	const char * getActionType();
	CECLWUActions getWUActionType();
	const char* getWUActionTypeAsString();
	const char * getCluster();
	const char * getOwner();
	const char * getState();
	const char * getStartDate();
	const char * getEndDate();
	const char * getECL();
	const char * getJobname();
	const char * getTest();
	const char * getCurrentPage();
	const char * getPageSize();
	const char * getSortby();
bool getDescending_isNull();
	bool getDescending();
	const char * getEventServer();
	const char * getEventName();
	const char * getPageFrom();
bool getBlockTillFinishTimer_isNull();
	int getBlockTillFinishTimer();
	void setWuids(StringArray &val);
	void setActionType(const char * val);
	void setWUActionType(CECLWUActions val);
void setWUActionType(const char* val);
	void setCluster(const char * val);
	void setOwner(const char * val);
	void setState(const char * val);
	void setStartDate(const char * val);
	void setEndDate(const char * val);
	void setECL(const char * val);
	void setJobname(const char * val);
	void setTest(const char * val);
	void setCurrentPage(const char * val);
	void setPageSize(const char * val);
	void setSortby(const char * val);
	void setDescending_null();
	void setDescending(bool val);
	void setEventServer(const char * val);
	void setEventName(const char * val);
	void setPageFrom(const char * val);
	void setBlockTillFinishTimer_null();
	void setBlockTillFinishTimer(int val);
};

class CWUActionResponse : public CSoapResponseBinding,
   implements IEspWUActionResponse,
   implements IClientWUActionResponse
{
protected:
	SoapStructArrayParam<IConstWUActionResult, CWUActionResult> m_ActionResults;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CWUActionResponse(const char *serviceName, const char *bcompat);

	CWUActionResponse(const char *serviceName, IRpcMessageBinding *init=NULL);
	CWUActionResponse(const char *serviceName, IRpcMessage* rpcmsg);
	CWUActionResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "WUActionResponse";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CWUActionResponse &from);

	void copy(IConstWUActionResponse &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstWUActionResponse &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	virtual void setRedirectUrl(const char *url)
	{ CSoapResponseBinding::setRedirectUrl(url); }

	virtual const IMultiException& getExceptions()
	{ return CSoapResponseBinding::getExceptions(); }

	virtual int queryClientStatus()
	{ return CSoapResponseBinding::getRpcState(); }

	virtual void noteException(IException& e)
	{  CSoapResponseBinding::noteException(e); }

	IArrayOf<IConstWUActionResult> & getActionResults();
	void setActionResults(IArrayOf<IEspWUActionResult> &val);
 void setActionResults(IArrayOf<IConstWUActionResult> &val);
};

class CWUAbortRequest : public CSoapRequestBinding,
   implements IEspWUAbortRequest,
   implements IClientWUAbortRequest
{
protected:
	SoapStringArray m_Wuids;
	SoapParam<int> m_BlockTillFinishTimer;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CWUAbortRequest(const char *serviceName, const char *bcompat);

	CWUAbortRequest(const char *serviceName, IRpcMessageBinding *init=NULL);
	CWUAbortRequest(const char *serviceName, IRpcMessage* rpcmsg);
	CWUAbortRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	IEspClientRpcSettings &rpc(){return *static_cast<IEspClientRpcSettings*>(this);}


	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "WUAbortRequest";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CWUAbortRequest &from);

	void copy(IConstWUAbortRequest &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstWUAbortRequest &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	StringArray & getWuids();
	int getBlockTillFinishTimer();
	void setWuids(StringArray &val);
	void setBlockTillFinishTimer(int val);
};

class CWUAbortResponse : public CSoapResponseBinding,
   implements IEspWUAbortResponse,
   implements IClientWUAbortResponse
{
protected:
	SoapStructArrayParam<IConstWUActionResult, CWUActionResult> m_ActionResults;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CWUAbortResponse(const char *serviceName, const char *bcompat);

	CWUAbortResponse(const char *serviceName, IRpcMessageBinding *init=NULL);
	CWUAbortResponse(const char *serviceName, IRpcMessage* rpcmsg);
	CWUAbortResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "WUAbortResponse";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CWUAbortResponse &from);

	void copy(IConstWUAbortResponse &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstWUAbortResponse &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	virtual void setRedirectUrl(const char *url)
	{ CSoapResponseBinding::setRedirectUrl(url); }

	virtual const IMultiException& getExceptions()
	{ return CSoapResponseBinding::getExceptions(); }

	virtual int queryClientStatus()
	{ return CSoapResponseBinding::getRpcState(); }

	virtual void noteException(IException& e)
	{  CSoapResponseBinding::noteException(e); }

	IArrayOf<IConstWUActionResult> & getActionResults();
	void setActionResults(IArrayOf<IEspWUActionResult> &val);
 void setActionResults(IArrayOf<IConstWUActionResult> &val);
};

class CWUProtectRequest : public CSoapRequestBinding,
   implements IEspWUProtectRequest,
   implements IClientWUProtectRequest
{
protected:
	SoapStringArray m_Wuids;
	SoapParam<bool> m_Protect;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CWUProtectRequest(const char *serviceName, const char *bcompat);

	CWUProtectRequest(const char *serviceName, IRpcMessageBinding *init=NULL);
	CWUProtectRequest(const char *serviceName, IRpcMessage* rpcmsg);
	CWUProtectRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	IEspClientRpcSettings &rpc(){return *static_cast<IEspClientRpcSettings*>(this);}


	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "WUProtectRequest";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CWUProtectRequest &from);

	void copy(IConstWUProtectRequest &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstWUProtectRequest &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	StringArray & getWuids();
	bool getProtect();
	void setWuids(StringArray &val);
	void setProtect(bool val);
};

class CWUProtectResponse : public CSoapResponseBinding,
   implements IEspWUProtectResponse,
   implements IClientWUProtectResponse
{
protected:
	SoapStructArrayParam<IConstWUActionResult, CWUActionResult> m_ActionResults;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CWUProtectResponse(const char *serviceName, const char *bcompat);

	CWUProtectResponse(const char *serviceName, IRpcMessageBinding *init=NULL);
	CWUProtectResponse(const char *serviceName, IRpcMessage* rpcmsg);
	CWUProtectResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "WUProtectResponse";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CWUProtectResponse &from);

	void copy(IConstWUProtectResponse &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstWUProtectResponse &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	virtual void setRedirectUrl(const char *url)
	{ CSoapResponseBinding::setRedirectUrl(url); }

	virtual const IMultiException& getExceptions()
	{ return CSoapResponseBinding::getExceptions(); }

	virtual int queryClientStatus()
	{ return CSoapResponseBinding::getRpcState(); }

	virtual void noteException(IException& e)
	{  CSoapResponseBinding::noteException(e); }

	IArrayOf<IConstWUActionResult> & getActionResults();
	void setActionResults(IArrayOf<IEspWUActionResult> &val);
 void setActionResults(IArrayOf<IConstWUActionResult> &val);
};

class CWUResubmitRequest : public CSoapRequestBinding,
   implements IEspWUResubmitRequest,
   implements IClientWUResubmitRequest
{
protected:
	SoapStringArray m_Wuids;
	SoapParam<bool> m_Recompile;
	SoapParam<int> m_BlockTillFinishTimer;
	SoapParam<bool> m_ResetWorkflow;
	SoapParam<bool> m_CloneWorkunit;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CWUResubmitRequest(const char *serviceName, const char *bcompat);

	CWUResubmitRequest(const char *serviceName, IRpcMessageBinding *init=NULL);
	CWUResubmitRequest(const char *serviceName, IRpcMessage* rpcmsg);
	CWUResubmitRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	IEspClientRpcSettings &rpc(){return *static_cast<IEspClientRpcSettings*>(this);}


	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "WUResubmitRequest";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CWUResubmitRequest &from);

	void copy(IConstWUResubmitRequest &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstWUResubmitRequest &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	StringArray & getWuids();
	bool getRecompile();
	int getBlockTillFinishTimer();
	bool getResetWorkflow();
	bool getCloneWorkunit();
	void setWuids(StringArray &val);
	void setRecompile(bool val);
	void setBlockTillFinishTimer(int val);
	void setResetWorkflow(bool val);
	void setCloneWorkunit(bool val);
};

class CWUResubmitResponse : public CSoapResponseBinding,
   implements IEspWUResubmitResponse,
   implements IClientWUResubmitResponse
{
protected:
	SoapStructArrayParam<IConstResubmittedWU, CResubmittedWU> m_WUs;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CWUResubmitResponse(const char *serviceName, const char *bcompat);

	CWUResubmitResponse(const char *serviceName, IRpcMessageBinding *init=NULL);
	CWUResubmitResponse(const char *serviceName, IRpcMessage* rpcmsg);
	CWUResubmitResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "WUResubmitResponse";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CWUResubmitResponse &from);

	void copy(IConstWUResubmitResponse &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstWUResubmitResponse &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	virtual void setRedirectUrl(const char *url)
	{ CSoapResponseBinding::setRedirectUrl(url); }

	virtual const IMultiException& getExceptions()
	{ return CSoapResponseBinding::getExceptions(); }

	virtual int queryClientStatus()
	{ return CSoapResponseBinding::getRpcState(); }

	virtual void noteException(IException& e)
	{  CSoapResponseBinding::noteException(e); }

	IArrayOf<IConstResubmittedWU> & getWUs();
	void setWUs(IArrayOf<IEspResubmittedWU> &val);
 void setWUs(IArrayOf<IConstResubmittedWU> &val);
};

class CXWUQueryActivationMode : public SoapEnumParamNew<CWUQueryActivationMode>
{
public:
	CXWUQueryActivationMode(nilBehavior nilB) : SoapEnumParamNew<CWUQueryActivationMode>(nilB)
	{ doInit(); }
	CXWUQueryActivationMode(CWUQueryActivationMode defvalue_) : SoapEnumParamNew<CWUQueryActivationMode>(defvalue_)
	{ doInit(); }
	CXWUQueryActivationMode(const char* defvalue_) : SoapEnumParamNew<CWUQueryActivationMode>()
	{ doInit(); setDefaultValue(defvalue_); }
	static  void getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash &added)
	{ getSharedInstance().getXsdDefinitionInternal(context,request,schema,added); }
	static void getMapInfo(IMapInfo& info, BoolHash& added) { getSharedInstance().getMapInfo_(info,added); }

	static const char* stringOf(CWUQueryActivationMode val) { return getSharedInstance().toString(val); }

	static CWUQueryActivationMode enumOf(const char* s) { return getSharedInstance().toEnum(s); }

static const char *queryXsdElementName() { return "WUQueryActivationMode"; }
private:
	static CXWUQueryActivationMode& getSharedInstance() { static CXWUQueryActivationMode instance(nilIgnore); return instance; }
	void getMapInfo_(IMapInfo& info, BoolHash& added) {  }
	void getXsdDefinitionInternal(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash &added)
	{
		const char* descriptions [] = {"Do not activate query","Activate query","Activate query, suspend previous","Activate query, delete previous",};
		getXsdDefinition_(context,request,schema,added,descriptions);
	}
	void doInit()
	{
		static const char* inits[] = {"0","1","2","3",NULL};
		init("WUQueryActivationMode","int",inits);
	}
};

class CWURecreateQueryRequest : public CSoapRequestBinding,
   implements IEspWURecreateQueryRequest,
   implements IClientWURecreateQueryRequest
{
protected:
	SoapStringParam m_Target;
	SoapStringParam m_QueryId;
	SoapStructArrayParam<IConstNamedValue, CNamedValue> m_DebugValues;
	SoapStringParam m_DestTarget;
	SoapParam<bool> m_Republish;
	CXWUQueryActivationMode m_Activate;
	SoapParam<bool> m_NoReload;
	SoapStringParam m_MemoryLimit;
	SoapParam<unsigned int> m_TimeLimit;
	SoapParam<unsigned int> m_WarnTimeLimit;
	SoapStringParam m_Priority;
	SoapStringParam m_Comment;
	SoapStringParam m_RemoteDali;
	SoapParam<bool> m_DontCopyFiles;
	SoapStringParam m_SourceProcess;
	SoapParam<bool> m_AllowForeignFiles;
	SoapParam<bool> m_UpdateDfs;
	SoapParam<bool> m_UpdateSuperFiles;
	SoapParam<bool> m_UpdateCloneFrom;
	SoapParam<bool> m_AppendCluster;
	SoapParam<bool> m_IncludeFileErrors;
	SoapParam<int> m_Wait;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CWURecreateQueryRequest(const char *serviceName, const char *bcompat);

	CWURecreateQueryRequest(const char *serviceName, IRpcMessageBinding *init=NULL);
	CWURecreateQueryRequest(const char *serviceName, IRpcMessage* rpcmsg);
	CWURecreateQueryRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	IEspClientRpcSettings &rpc(){return *static_cast<IEspClientRpcSettings*>(this);}


	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "WURecreateQueryRequest";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CWURecreateQueryRequest &from);

	void copy(IConstWURecreateQueryRequest &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstWURecreateQueryRequest &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	const char * getTarget();
	const char * getQueryId();
	IArrayOf<IConstNamedValue> & getDebugValues();
	const char * getDestTarget();
bool getRepublish_isNull();
	bool getRepublish();
	CWUQueryActivationMode getActivate();
	const char* getActivateAsString();
bool getNoReload_isNull();
	bool getNoReload();
	const char * getMemoryLimit();
bool getTimeLimit_isNull();
	unsigned int getTimeLimit();
bool getWarnTimeLimit_isNull();
	unsigned int getWarnTimeLimit();
	const char * getPriority();
	const char * getComment();
	const char * getRemoteDali();
bool getDontCopyFiles_isNull();
	bool getDontCopyFiles();
	const char * getSourceProcess();
bool getAllowForeignFiles_isNull();
	bool getAllowForeignFiles();
bool getUpdateDfs_isNull();
	bool getUpdateDfs();
bool getUpdateSuperFiles_isNull();
	bool getUpdateSuperFiles();
bool getUpdateCloneFrom_isNull();
	bool getUpdateCloneFrom();
bool getAppendCluster_isNull();
	bool getAppendCluster();
bool getIncludeFileErrors_isNull();
	bool getIncludeFileErrors();
bool getWait_isNull();
	int getWait();
	void setTarget(const char * val);
	void setQueryId(const char * val);
	void setDebugValues(IArrayOf<IEspNamedValue> &val);
 void setDebugValues(IArrayOf<IConstNamedValue> &val);
	void setDestTarget(const char * val);
	void setRepublish_null();
	void setRepublish(bool val);
	void setActivate(CWUQueryActivationMode val);
void setActivate(const char* val);
	void setNoReload_null();
	void setNoReload(bool val);
	void setMemoryLimit(const char * val);
	void setTimeLimit_null();
	void setTimeLimit(unsigned int val);
	void setWarnTimeLimit_null();
	void setWarnTimeLimit(unsigned int val);
	void setPriority(const char * val);
	void setComment(const char * val);
	void setRemoteDali(const char * val);
	void setDontCopyFiles_null();
	void setDontCopyFiles(bool val);
	void setSourceProcess(const char * val);
	void setAllowForeignFiles_null();
	void setAllowForeignFiles(bool val);
	void setUpdateDfs_null();
	void setUpdateDfs(bool val);
	void setUpdateSuperFiles_null();
	void setUpdateSuperFiles(bool val);
	void setUpdateCloneFrom_null();
	void setUpdateCloneFrom(bool val);
	void setAppendCluster_null();
	void setAppendCluster(bool val);
	void setIncludeFileErrors_null();
	void setIncludeFileErrors(bool val);
	void setWait_null();
	void setWait(int val);
};

class CWURecreateQueryResponse : public CSoapResponseBinding,
   implements IEspWURecreateQueryResponse,
   implements IClientWURecreateQueryResponse
{
protected:
	SoapStringParam m_Wuid;
	SoapStringParam m_QuerySet;
	SoapStringParam m_QueryName;
	SoapStringParam m_QueryId;
	SoapStringParam m_MemoryLimit;
	SoapParam<unsigned int> m_TimeLimit;
	SoapParam<unsigned int> m_WarnTimeLimit;
	SoapStringParam m_Priority;
	SoapStringParam m_Comment;
	SoapParam<bool> m_ReloadFailed;
	SoapParam<bool> m_Suspended;
	SoapStringParam m_ErrorMessage;
	SoapStructArrayParam<IConstLogicalFileError, CLogicalFileError> m_FileErrors;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CWURecreateQueryResponse(const char *serviceName, const char *bcompat);

	CWURecreateQueryResponse(const char *serviceName, IRpcMessageBinding *init=NULL);
	CWURecreateQueryResponse(const char *serviceName, IRpcMessage* rpcmsg);
	CWURecreateQueryResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "WURecreateQueryResponse";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CWURecreateQueryResponse &from);

	void copy(IConstWURecreateQueryResponse &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstWURecreateQueryResponse &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	virtual void setRedirectUrl(const char *url)
	{ CSoapResponseBinding::setRedirectUrl(url); }

	virtual const IMultiException& getExceptions()
	{ return CSoapResponseBinding::getExceptions(); }

	virtual int queryClientStatus()
	{ return CSoapResponseBinding::getRpcState(); }

	virtual void noteException(IException& e)
	{  CSoapResponseBinding::noteException(e); }

	const char * getWuid();
	const char * getQuerySet();
	const char * getQueryName();
	const char * getQueryId();
	const char * getMemoryLimit();
bool getTimeLimit_isNull();
	unsigned int getTimeLimit();
bool getWarnTimeLimit_isNull();
	unsigned int getWarnTimeLimit();
	const char * getPriority();
	const char * getComment();
bool getReloadFailed_isNull();
	bool getReloadFailed();
bool getSuspended_isNull();
	bool getSuspended();
	const char * getErrorMessage();
	IArrayOf<IConstLogicalFileError> & getFileErrors();
	void setWuid(const char * val);
	void setQuerySet(const char * val);
	void setQueryName(const char * val);
	void setQueryId(const char * val);
	void setMemoryLimit(const char * val);
	void setTimeLimit_null();
	void setTimeLimit(unsigned int val);
	void setWarnTimeLimit_null();
	void setWarnTimeLimit(unsigned int val);
	void setPriority(const char * val);
	void setComment(const char * val);
	void setReloadFailed_null();
	void setReloadFailed(bool val);
	void setSuspended_null();
	void setSuspended(bool val);
	void setErrorMessage(const char * val);
	void setFileErrors(IArrayOf<IEspLogicalFileError> &val);
 void setFileErrors(IArrayOf<IConstLogicalFileError> &val);
};

class CXWUExceptionSeverity : public SoapEnumParamNew<CWUExceptionSeverity>
{
public:
	CXWUExceptionSeverity(nilBehavior nilB) : SoapEnumParamNew<CWUExceptionSeverity>(nilB)
	{ doInit(); }
	CXWUExceptionSeverity(CWUExceptionSeverity defvalue_) : SoapEnumParamNew<CWUExceptionSeverity>(defvalue_)
	{ doInit(); }
	CXWUExceptionSeverity(const char* defvalue_) : SoapEnumParamNew<CWUExceptionSeverity>()
	{ doInit(); setDefaultValue(defvalue_); }
	static  void getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash &added)
	{ getSharedInstance().getXsdDefinitionInternal(context,request,schema,added); }
	static void getMapInfo(IMapInfo& info, BoolHash& added) { getSharedInstance().getMapInfo_(info,added); }

	static const char* stringOf(CWUExceptionSeverity val) { return getSharedInstance().toString(val); }

	static CWUExceptionSeverity enumOf(const char* s) { return getSharedInstance().toEnum(s); }

static const char *queryXsdElementName() { return "WUExceptionSeverity"; }
private:
	static CXWUExceptionSeverity& getSharedInstance() { static CXWUExceptionSeverity instance(nilIgnore); return instance; }
	void getMapInfo_(IMapInfo& info, BoolHash& added) {  }
	void getXsdDefinitionInternal(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash &added)
	{ getXsdDefinition_(context,request,schema,added,NULL); }
	void doInit()
	{
		static const char* inits[] = {"info","warning","error","alert",NULL};
		init("WUExceptionSeverity","string",inits);
	}
};

class CWURunRequest : public CSoapRequestBinding,
   implements IEspWURunRequest,
   implements IClientWURunRequest
{
protected:
	SoapStringParam m_QuerySet;
	SoapStringParam m_Query;
	SoapStringParam m_Wuid;
	SoapParam<bool> m_CloneWorkunit;
	SoapStringParam m_Cluster;
	SoapParam<int> m_Wait;
	SoapStringParam m_Input;
	SoapParam<bool> m_NoRootTag;
	SoapStructArrayParam<IConstNamedValue, CNamedValue> m_DebugValues;
	SoapStructArrayParam<IConstNamedValue, CNamedValue> m_Variables;
	SoapStructArrayParam<IConstApplicationValue, CApplicationValue> m_ApplicationValues;
	CXWUExceptionSeverity m_ExceptionSeverity;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CWURunRequest(const char *serviceName, const char *bcompat);

	CWURunRequest(const char *serviceName, IRpcMessageBinding *init=NULL);
	CWURunRequest(const char *serviceName, IRpcMessage* rpcmsg);
	CWURunRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	IEspClientRpcSettings &rpc(){return *static_cast<IEspClientRpcSettings*>(this);}


	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "WURunRequest";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CWURunRequest &from);

	void copy(IConstWURunRequest &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstWURunRequest &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	const char * getQuerySet();
	const char * getQuery();
	const char * getWuid();
	bool getCloneWorkunit();
	const char * getCluster();
	int getWait();
	const char * getInput();
	bool getNoRootTag();
	IArrayOf<IConstNamedValue> & getDebugValues();
	IArrayOf<IConstNamedValue> & getVariables();
	IArrayOf<IConstApplicationValue> & getApplicationValues();
	CWUExceptionSeverity getExceptionSeverity();
	const char* getExceptionSeverityAsString();
	void setQuerySet(const char * val);
	void setQuery(const char * val);
	void setWuid(const char * val);
	void setCloneWorkunit(bool val);
	void setCluster(const char * val);
	void setWait(int val);
	void setInput(const char * val);
	void setNoRootTag(bool val);
	void setDebugValues(IArrayOf<IEspNamedValue> &val);
 void setDebugValues(IArrayOf<IConstNamedValue> &val);
	void setVariables(IArrayOf<IEspNamedValue> &val);
 void setVariables(IArrayOf<IConstNamedValue> &val);
	void setApplicationValues(IArrayOf<IEspApplicationValue> &val);
 void setApplicationValues(IArrayOf<IConstApplicationValue> &val);
	void setExceptionSeverity(CWUExceptionSeverity val);
void setExceptionSeverity(const char* val);
};

class CWURunResponse : public CSoapResponseBinding,
   implements IEspWURunResponse,
   implements IClientWURunResponse
{
protected:
	SoapStringParam m_Wuid;
	SoapStringParam m_State;
	SoapStringParam m_Results;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CWURunResponse(const char *serviceName, const char *bcompat);

	CWURunResponse(const char *serviceName, IRpcMessageBinding *init=NULL);
	CWURunResponse(const char *serviceName, IRpcMessage* rpcmsg);
	CWURunResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "WURunResponse";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CWURunResponse &from);

	void copy(IConstWURunResponse &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstWURunResponse &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	virtual void setRedirectUrl(const char *url)
	{ CSoapResponseBinding::setRedirectUrl(url); }

	virtual const IMultiException& getExceptions()
	{ return CSoapResponseBinding::getExceptions(); }

	virtual int queryClientStatus()
	{ return CSoapResponseBinding::getRpcState(); }

	virtual void noteException(IException& e)
	{  CSoapResponseBinding::noteException(e); }

	const char * getWuid();
	const char * getState();
	const char * getResults();
	void setWuid(const char * val);
	void setState(const char * val);
	void setResults(const char * val);
};

class CWUSubmitRequest : public CSoapRequestBinding,
   implements IEspWUSubmitRequest,
   implements IClientWUSubmitRequest
{
protected:
	SoapStringParam m_Wuid;
	SoapStringParam m_Cluster;
	SoapStringParam m_Queue;
	SoapStringParam m_Snapshot;
	SoapParam<int> m_MaxRunTime;
	SoapParam<int> m_BlockTillFinishTimer;
	SoapParam<bool> m_SyntaxCheck;
	SoapParam<bool> m_NotifyCluster;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CWUSubmitRequest(const char *serviceName, const char *bcompat);

	CWUSubmitRequest(const char *serviceName, IRpcMessageBinding *init=NULL);
	CWUSubmitRequest(const char *serviceName, IRpcMessage* rpcmsg);
	CWUSubmitRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	IEspClientRpcSettings &rpc(){return *static_cast<IEspClientRpcSettings*>(this);}


	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "WUSubmitRequest";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CWUSubmitRequest &from);

	void copy(IConstWUSubmitRequest &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstWUSubmitRequest &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	const char * getWuid();
	const char * getCluster();
	const char * getQueue();
	const char * getSnapshot();
	int getMaxRunTime();
	int getBlockTillFinishTimer();
	bool getSyntaxCheck();
	bool getNotifyCluster();
	void setWuid(const char * val);
	void setCluster(const char * val);
	void setQueue(const char * val);
	void setSnapshot(const char * val);
	void setMaxRunTime(int val);
	void setBlockTillFinishTimer(int val);
	void setSyntaxCheck(bool val);
	void setNotifyCluster(bool val);
};

class CWUSubmitResponse : public CSoapResponseBinding,
   implements IEspWUSubmitResponse,
   implements IClientWUSubmitResponse
{
protected:

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CWUSubmitResponse(const char *serviceName, const char *bcompat);

	CWUSubmitResponse(const char *serviceName, IRpcMessageBinding *init=NULL);
	CWUSubmitResponse(const char *serviceName, IRpcMessage* rpcmsg);
	CWUSubmitResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "WUSubmitResponse";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CWUSubmitResponse &from);

	void copy(IConstWUSubmitResponse &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstWUSubmitResponse &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	virtual void setRedirectUrl(const char *url)
	{ CSoapResponseBinding::setRedirectUrl(url); }

	virtual const IMultiException& getExceptions()
	{ return CSoapResponseBinding::getExceptions(); }

	virtual int queryClientStatus()
	{ return CSoapResponseBinding::getRpcState(); }

	virtual void noteException(IException& e)
	{  CSoapResponseBinding::noteException(e); }

};

class CWUScheduleRequest : public CSoapRequestBinding,
   implements IEspWUScheduleRequest,
   implements IClientWUScheduleRequest
{
protected:
	SoapStringParam m_Wuid;
	SoapStringParam m_Cluster;
	SoapStringParam m_Queue;
	SoapStringParam m_Snapshot;
	SoapStringParam m_When;
	SoapParam<int> m_MaxRunTime;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CWUScheduleRequest(const char *serviceName, const char *bcompat);

	CWUScheduleRequest(const char *serviceName, IRpcMessageBinding *init=NULL);
	CWUScheduleRequest(const char *serviceName, IRpcMessage* rpcmsg);
	CWUScheduleRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	IEspClientRpcSettings &rpc(){return *static_cast<IEspClientRpcSettings*>(this);}


	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "WUScheduleRequest";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CWUScheduleRequest &from);

	void copy(IConstWUScheduleRequest &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstWUScheduleRequest &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	const char * getWuid();
	const char * getCluster();
	const char * getQueue();
	const char * getSnapshot();
	const char * getWhen();
	int getMaxRunTime();
	void setWuid(const char * val);
	void setCluster(const char * val);
	void setQueue(const char * val);
	void setSnapshot(const char * val);
	void setWhen(const char * val);
	void setMaxRunTime(int val);
};

class CWUScheduleResponse : public CSoapResponseBinding,
   implements IEspWUScheduleResponse,
   implements IClientWUScheduleResponse
{
protected:

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CWUScheduleResponse(const char *serviceName, const char *bcompat);

	CWUScheduleResponse(const char *serviceName, IRpcMessageBinding *init=NULL);
	CWUScheduleResponse(const char *serviceName, IRpcMessage* rpcmsg);
	CWUScheduleResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "WUScheduleResponse";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CWUScheduleResponse &from);

	void copy(IConstWUScheduleResponse &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstWUScheduleResponse &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	virtual void setRedirectUrl(const char *url)
	{ CSoapResponseBinding::setRedirectUrl(url); }

	virtual const IMultiException& getExceptions()
	{ return CSoapResponseBinding::getExceptions(); }

	virtual int queryClientStatus()
	{ return CSoapResponseBinding::getRpcState(); }

	virtual void noteException(IException& e)
	{  CSoapResponseBinding::noteException(e); }

};

class CWUPushEventRequest : public CSoapRequestBinding,
   implements IEspWUPushEventRequest,
   implements IClientWUPushEventRequest
{
protected:
	SoapStringParam m_EventName;
	SoapStringParam m_EventText;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CWUPushEventRequest(const char *serviceName, const char *bcompat);

	CWUPushEventRequest(const char *serviceName, IRpcMessageBinding *init=NULL);
	CWUPushEventRequest(const char *serviceName, IRpcMessage* rpcmsg);
	CWUPushEventRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	IEspClientRpcSettings &rpc(){return *static_cast<IEspClientRpcSettings*>(this);}


	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "WUPushEventRequest";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CWUPushEventRequest &from);

	void copy(IConstWUPushEventRequest &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstWUPushEventRequest &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	const char * getEventName();
	const char * getEventText();
	void setEventName(const char * val);
	void setEventText(const char * val);
};

class CWUPushEventResponse : public CSoapResponseBinding,
   implements IEspWUPushEventResponse,
   implements IClientWUPushEventResponse
{
protected:

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CWUPushEventResponse(const char *serviceName, const char *bcompat);

	CWUPushEventResponse(const char *serviceName, IRpcMessageBinding *init=NULL);
	CWUPushEventResponse(const char *serviceName, IRpcMessage* rpcmsg);
	CWUPushEventResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "WUPushEventResponse";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CWUPushEventResponse &from);

	void copy(IConstWUPushEventResponse &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstWUPushEventResponse &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	virtual void setRedirectUrl(const char *url)
	{ CSoapResponseBinding::setRedirectUrl(url); }

	virtual const IMultiException& getExceptions()
	{ return CSoapResponseBinding::getExceptions(); }

	virtual int queryClientStatus()
	{ return CSoapResponseBinding::getRpcState(); }

	virtual void noteException(IException& e)
	{  CSoapResponseBinding::noteException(e); }

};

class CWUInfoRequest : public CSoapRequestBinding,
   implements IEspWUInfoRequest,
   implements IClientWUInfoRequest
{
protected:
	SoapStringParam m_Wuid;
	SoapParam<bool> m_TruncateEclTo64k;
	SoapStringParam m_Type;
	SoapParam<bool> m_IncludeExceptions;
	SoapParam<bool> m_IncludeGraphs;
	SoapParam<bool> m_IncludeSourceFiles;
	SoapParam<bool> m_IncludeResults;
	SoapParam<bool> m_IncludeResultsViewNames;
	SoapParam<bool> m_IncludeVariables;
	SoapParam<bool> m_IncludeTimers;
	SoapParam<bool> m_IncludeDebugValues;
	SoapParam<bool> m_IncludeApplicationValues;
	SoapParam<bool> m_IncludeWorkflows;
	SoapParam<bool> m_IncludeXmlSchemas;
	SoapParam<bool> m_IncludeResourceURLs;
	SoapParam<bool> m_IncludeECL;
	SoapParam<bool> m_IncludeHelpers;
	SoapParam<bool> m_IncludeAllowedClusters;
	SoapParam<bool> m_IncludeTotalClusterTime;
	SoapParam<bool> m_SuppressResultSchemas;
	SoapStringParam m_ThorSlaveIP;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CWUInfoRequest(const char *serviceName, const char *bcompat);

	CWUInfoRequest(const char *serviceName, IRpcMessageBinding *init=NULL);
	CWUInfoRequest(const char *serviceName, IRpcMessage* rpcmsg);
	CWUInfoRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	IEspClientRpcSettings &rpc(){return *static_cast<IEspClientRpcSettings*>(this);}


	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "WUInfoRequest";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CWUInfoRequest &from);

	void copy(IConstWUInfoRequest &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstWUInfoRequest &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	const char * getWuid();
	bool getTruncateEclTo64k();
	const char * getType();
	bool getIncludeExceptions();
	bool getIncludeGraphs();
	bool getIncludeSourceFiles();
	bool getIncludeResults();
	bool getIncludeResultsViewNames();
	bool getIncludeVariables();
	bool getIncludeTimers();
	bool getIncludeDebugValues();
	bool getIncludeApplicationValues();
	bool getIncludeWorkflows();
	bool getIncludeXmlSchemas();
	bool getIncludeResourceURLs();
	bool getIncludeECL();
	bool getIncludeHelpers();
	bool getIncludeAllowedClusters();
	bool getIncludeTotalClusterTime();
	bool getSuppressResultSchemas();
	const char * getThorSlaveIP();
	void setWuid(const char * val);
	void setTruncateEclTo64k(bool val);
	void setType(const char * val);
	void setIncludeExceptions(bool val);
	void setIncludeGraphs(bool val);
	void setIncludeSourceFiles(bool val);
	void setIncludeResults(bool val);
	void setIncludeResultsViewNames(bool val);
	void setIncludeVariables(bool val);
	void setIncludeTimers(bool val);
	void setIncludeDebugValues(bool val);
	void setIncludeApplicationValues(bool val);
	void setIncludeWorkflows(bool val);
	void setIncludeXmlSchemas(bool val);
	void setIncludeResourceURLs(bool val);
	void setIncludeECL(bool val);
	void setIncludeHelpers(bool val);
	void setIncludeAllowedClusters(bool val);
	void setIncludeTotalClusterTime(bool val);
	void setSuppressResultSchemas(bool val);
	void setThorSlaveIP(const char * val);
};

class CWUInfoResponse : public CSoapResponseBinding,
   implements IEspWUInfoResponse,
   implements IClientWUInfoResponse
{
protected:
	SoapStruct<CECLWorkunit, IConstECLWorkunit> m_Workunit;
	SoapParam<int> m_AutoRefresh;
	SoapParam<bool> m_CanCompile;
	SoapStringParam m_ThorSlaveIP;
	SoapStringArray m_ResultViews;
	SoapStringParam m_SecMethod;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CWUInfoResponse(const char *serviceName, const char *bcompat);

	CWUInfoResponse(const char *serviceName, IRpcMessageBinding *init=NULL);
	CWUInfoResponse(const char *serviceName, IRpcMessage* rpcmsg);
	CWUInfoResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "WUInfoResponse";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CWUInfoResponse &from);

	void copy(IConstWUInfoResponse &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstWUInfoResponse &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	virtual void setRedirectUrl(const char *url)
	{ CSoapResponseBinding::setRedirectUrl(url); }

	virtual const IMultiException& getExceptions()
	{ return CSoapResponseBinding::getExceptions(); }

	virtual int queryClientStatus()
	{ return CSoapResponseBinding::getRpcState(); }

	virtual void noteException(IException& e)
	{  CSoapResponseBinding::noteException(e); }

	IConstECLWorkunit & getWorkunit();
	int getAutoRefresh();
	bool getCanCompile();
	const char * getThorSlaveIP();
	StringArray & getResultViews();
	const char * getSecMethod();
	IEspECLWorkunit & updateWorkunit();
	void setWorkunit(IConstECLWorkunit &ifrom);
	void setAutoRefresh(int val);
	void setCanCompile(bool val);
	void setThorSlaveIP(const char * val);
	void setResultViews(StringArray &val);
	void setSecMethod(const char * val);
};

class CWUResultSummaryRequest : public CSoapRequestBinding,
   implements IEspWUResultSummaryRequest,
   implements IClientWUResultSummaryRequest
{
protected:
	SoapStringParam m_Wuid;
	SoapParam<int> m_Sequence;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CWUResultSummaryRequest(const char *serviceName, const char *bcompat);

	CWUResultSummaryRequest(const char *serviceName, IRpcMessageBinding *init=NULL);
	CWUResultSummaryRequest(const char *serviceName, IRpcMessage* rpcmsg);
	CWUResultSummaryRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	IEspClientRpcSettings &rpc(){return *static_cast<IEspClientRpcSettings*>(this);}


	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "WUResultSummaryRequest";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CWUResultSummaryRequest &from);

	void copy(IConstWUResultSummaryRequest &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstWUResultSummaryRequest &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	const char * getWuid();
	int getSequence();
	void setWuid(const char * val);
	void setSequence(int val);
};

class CWUResultSummaryResponse : public CSoapResponseBinding,
   implements IEspWUResultSummaryResponse,
   implements IClientWUResultSummaryResponse
{
protected:
	SoapStringParam m_Wuid;
	SoapParam<int> m_Sequence;
	SoapParam<int> m_Format;
	SoapStruct<CECLResult, IConstECLResult> m_Result;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CWUResultSummaryResponse(const char *serviceName, const char *bcompat);

	CWUResultSummaryResponse(const char *serviceName, IRpcMessageBinding *init=NULL);
	CWUResultSummaryResponse(const char *serviceName, IRpcMessage* rpcmsg);
	CWUResultSummaryResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "WUResultSummaryResponse";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CWUResultSummaryResponse &from);

	void copy(IConstWUResultSummaryResponse &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstWUResultSummaryResponse &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	virtual void setRedirectUrl(const char *url)
	{ CSoapResponseBinding::setRedirectUrl(url); }

	virtual const IMultiException& getExceptions()
	{ return CSoapResponseBinding::getExceptions(); }

	virtual int queryClientStatus()
	{ return CSoapResponseBinding::getRpcState(); }

	virtual void noteException(IException& e)
	{  CSoapResponseBinding::noteException(e); }

	const char * getWuid();
	int getSequence();
	int getFormat();
	IConstECLResult & getResult();
	void setWuid(const char * val);
	void setSequence(int val);
	void setFormat(int val);
	IEspECLResult & updateResult();
	void setResult(IConstECLResult &ifrom);
};

class CWULogFileRequest : public CSoapRequestBinding,
   implements IEspWULogFileRequest,
   implements IClientWULogFileRequest
{
protected:
	SoapStringParam m_Name;
	SoapStringParam m_Wuid;
	SoapStringParam m_Type;
	SoapParam<int> m_Option;
	SoapStringParam m_SlaveIP;
	SoapStringParam m_IPAddress;
	SoapStringParam m_Description;
	SoapStringParam m_QuerySet;
	SoapStringParam m_Query;
	SoapStringParam m_Process;
	SoapStringParam m_ClusterGroup;
	SoapStringParam m_LogDate;
	SoapParam<int> m_SlaveNumber;
	SoapParam<__int64> m_SizeLimit;
	SoapStringParam m_PlainText;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CWULogFileRequest(const char *serviceName, const char *bcompat);

	CWULogFileRequest(const char *serviceName, IRpcMessageBinding *init=NULL);
	CWULogFileRequest(const char *serviceName, IRpcMessage* rpcmsg);
	CWULogFileRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	IEspClientRpcSettings &rpc(){return *static_cast<IEspClientRpcSettings*>(this);}


	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "WULogFileRequest";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CWULogFileRequest &from);

	void copy(IConstWULogFileRequest &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstWULogFileRequest &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	const char * getName();
	const char * getWuid();
	const char * getType();
	int getOption();
	const char * getSlaveIP();
	const char * getIPAddress();
	const char * getDescription();
	const char * getQuerySet();
	const char * getQuery();
	const char * getProcess();
	const char * getClusterGroup();
	const char * getLogDate();
	int getSlaveNumber();
	__int64 getSizeLimit();
	const char * getPlainText();
	void setName(const char * val);
	void setWuid(const char * val);
	void setType(const char * val);
	void setOption(int val);
	void setSlaveIP(const char * val);
	void setIPAddress(const char * val);
	void setDescription(const char * val);
	void setQuerySet(const char * val);
	void setQuery(const char * val);
	void setProcess(const char * val);
	void setClusterGroup(const char * val);
	void setLogDate(const char * val);
	void setSlaveNumber(int val);
	void setSizeLimit(__int64 val);
	void setPlainText(const char * val);
};

class CWULogFileResponse : public CSoapResponseBinding,
   implements IEspWULogFileResponse,
   implements IClientWULogFileResponse
{
protected:
	SoapStringParam m_Wuid;
	SoapStringParam m_QuerySet;
	SoapStringParam m_QueryName;
	SoapStringParam m_QueryId;
	SoapStringParam m_FileName;
	SoapStringParam m_DaliServer;
	SoapParamBinary m_thefile;
	StringBuffer m_thefile_mimetype;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CWULogFileResponse(const char *serviceName, const char *bcompat);

	CWULogFileResponse(const char *serviceName, IRpcMessageBinding *init=NULL);
	CWULogFileResponse(const char *serviceName, IRpcMessage* rpcmsg);
	CWULogFileResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "WULogFileResponse";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return true;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CWULogFileResponse &from);

	void copy(IConstWULogFileResponse &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstWULogFileResponse &ifrom, StringBuffer& buffer, bool keepRootTag=true);

	void appendContent(IEspContext* ctx, MemoryBuffer& buffer, StringBuffer &mimetype);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	virtual void setRedirectUrl(const char *url)
	{ CSoapResponseBinding::setRedirectUrl(url); }

	virtual const IMultiException& getExceptions()
	{ return CSoapResponseBinding::getExceptions(); }

	virtual int queryClientStatus()
	{ return CSoapResponseBinding::getRpcState(); }

	virtual void noteException(IException& e)
	{  CSoapResponseBinding::noteException(e); }

	const char * getWuid();
	const char * getQuerySet();
	const char * getQueryName();
	const char * getQueryId();
	const char * getFileName();
	const char * getDaliServer();
	const char *getThefile_mimetype();
	const MemoryBuffer & getThefile();
	void setWuid(const char * val);
	void setQuerySet(const char * val);
	void setQueryName(const char * val);
	void setQueryId(const char * val);
	void setFileName(const char * val);
	void setDaliServer(const char * val);
	void setThefile_mimetype(const char *  val);
	void setThefile(const MemoryBuffer & val);
};

class CWUDownloadFilesRequest : public CSoapRequestBinding,
   implements IEspWUDownloadFilesRequest,
   implements IClientWUDownloadFilesRequest
{
protected:
	SoapStringParam m_Wuid;
	SoapStringParam m_QuerySet;
	SoapStringParam m_Query;
	CXWUFileDownloadOption m_DownloadOption;
	SoapStructArrayParam<IConstWUFileOption, CWUFileOption> m_WUFileOptions;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CWUDownloadFilesRequest(const char *serviceName, const char *bcompat);

	CWUDownloadFilesRequest(const char *serviceName, IRpcMessageBinding *init=NULL);
	CWUDownloadFilesRequest(const char *serviceName, IRpcMessage* rpcmsg);
	CWUDownloadFilesRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	IEspClientRpcSettings &rpc(){return *static_cast<IEspClientRpcSettings*>(this);}


	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "WUDownloadFilesRequest";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CWUDownloadFilesRequest &from);

	void copy(IConstWUDownloadFilesRequest &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstWUDownloadFilesRequest &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	const char * getWuid();
	const char * getQuerySet();
	const char * getQuery();
	CWUFileDownloadOption getDownloadOption();
	const char* getDownloadOptionAsString();
	IArrayOf<IConstWUFileOption> & getWUFileOptions();
	void setWuid(const char * val);
	void setQuerySet(const char * val);
	void setQuery(const char * val);
	void setDownloadOption(CWUFileDownloadOption val);
void setDownloadOption(const char* val);
	void setWUFileOptions(IArrayOf<IEspWUFileOption> &val);
 void setWUFileOptions(IArrayOf<IConstWUFileOption> &val);
};

class CWUDownloadFilesResponse : public CSoapResponseBinding,
   implements IEspWUDownloadFilesResponse,
   implements IClientWUDownloadFilesResponse
{
protected:
	SoapParamBinary m_thefile;
	StringBuffer m_thefile_mimetype;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CWUDownloadFilesResponse(const char *serviceName, const char *bcompat);

	CWUDownloadFilesResponse(const char *serviceName, IRpcMessageBinding *init=NULL);
	CWUDownloadFilesResponse(const char *serviceName, IRpcMessage* rpcmsg);
	CWUDownloadFilesResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "WUDownloadFilesResponse";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return true;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CWUDownloadFilesResponse &from);

	void copy(IConstWUDownloadFilesResponse &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstWUDownloadFilesResponse &ifrom, StringBuffer& buffer, bool keepRootTag=true);

	void appendContent(IEspContext* ctx, MemoryBuffer& buffer, StringBuffer &mimetype);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	virtual void setRedirectUrl(const char *url)
	{ CSoapResponseBinding::setRedirectUrl(url); }

	virtual const IMultiException& getExceptions()
	{ return CSoapResponseBinding::getExceptions(); }

	virtual int queryClientStatus()
	{ return CSoapResponseBinding::getRpcState(); }

	virtual void noteException(IException& e)
	{  CSoapResponseBinding::noteException(e); }

	const char *getThefile_mimetype();
	const MemoryBuffer & getThefile();
	void setThefile_mimetype(const char *  val);
	void setThefile(const MemoryBuffer & val);
};

class CWUResultBinRequest : public CSoapRequestBinding,
   implements IEspWUResultBinRequest,
   implements IClientWUResultBinRequest
{
protected:
	SoapStringParam m_LogicalName;
	SoapStringParam m_Wuid;
	SoapStringParam m_ResultName;
	SoapParam<int> m_Sequence;
	SoapStringParam m_Format;
	SoapStringParam m_Cluster;
	SoapStructArrayParam<IConstNamedValue, CNamedValue> m_FilterBy;
	SoapParam<__int64> m_Start;
	SoapParam<int> m_Count;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CWUResultBinRequest(const char *serviceName, const char *bcompat);

	CWUResultBinRequest(const char *serviceName, IRpcMessageBinding *init=NULL);
	CWUResultBinRequest(const char *serviceName, IRpcMessage* rpcmsg);
	CWUResultBinRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	IEspClientRpcSettings &rpc(){return *static_cast<IEspClientRpcSettings*>(this);}


	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "WUResultBinRequest";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CWUResultBinRequest &from);

	void copy(IConstWUResultBinRequest &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstWUResultBinRequest &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	const char * getLogicalName();
	const char * getWuid();
	const char * getResultName();
	int getSequence();
	const char * getFormat();
	const char * getCluster();
	IArrayOf<IConstNamedValue> & getFilterBy();
	__int64 getStart();
	int getCount();
	void setLogicalName(const char * val);
	void setWuid(const char * val);
	void setResultName(const char * val);
	void setSequence(int val);
	void setFormat(const char * val);
	void setCluster(const char * val);
	void setFilterBy(IArrayOf<IEspNamedValue> &val);
 void setFilterBy(IArrayOf<IConstNamedValue> &val);
	void setStart(__int64 val);
	void setCount(int val);
};

class CWUResultBinResponse : public CSoapResponseBinding,
   implements IEspWUResultBinResponse,
   implements IClientWUResultBinResponse
{
protected:
	SoapStringParam m_Wuid;
	SoapParam<int> m_Sequence;
	SoapStringParam m_Name;
	SoapParam<__int64> m_Start;
	SoapParam<int> m_Count;
	SoapParam<int> m_Requested;
	SoapParam<__int64> m_Total;
	SoapParamBinary m_Result;
	SoapStringParam m_Format;
	StringBuffer m_Result_mimetype;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CWUResultBinResponse(const char *serviceName, const char *bcompat);

	CWUResultBinResponse(const char *serviceName, IRpcMessageBinding *init=NULL);
	CWUResultBinResponse(const char *serviceName, IRpcMessage* rpcmsg);
	CWUResultBinResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "WUResultBinResponse";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return true;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CWUResultBinResponse &from);

	void copy(IConstWUResultBinResponse &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstWUResultBinResponse &ifrom, StringBuffer& buffer, bool keepRootTag=true);

	void appendContent(IEspContext* ctx, MemoryBuffer& buffer, StringBuffer &mimetype);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	virtual void setRedirectUrl(const char *url)
	{ CSoapResponseBinding::setRedirectUrl(url); }

	virtual const IMultiException& getExceptions()
	{ return CSoapResponseBinding::getExceptions(); }

	virtual int queryClientStatus()
	{ return CSoapResponseBinding::getRpcState(); }

	virtual void noteException(IException& e)
	{  CSoapResponseBinding::noteException(e); }

	const char * getWuid();
	int getSequence();
	const char * getName();
	__int64 getStart();
	int getCount();
	int getRequested();
	__int64 getTotal();
	const char *getResult_mimetype();
	const MemoryBuffer & getResult();
	const char * getFormat();
	void setWuid(const char * val);
	void setSequence(int val);
	void setName(const char * val);
	void setStart(__int64 val);
	void setCount(int val);
	void setRequested(int val);
	void setTotal(__int64 val);
	void setResult_mimetype(const char *  val);
	void setResult(const MemoryBuffer & val);
	void setFormat(const char * val);
};

class CWUResultRequest : public CSoapRequestBinding,
   implements IEspWUResultRequest,
   implements IClientWUResultRequest
{
protected:
	SoapStringParam m_Wuid;
	SoapParam<int> m_Sequence;
	SoapStringParam m_ResultName;
	SoapStringParam m_LogicalName;
	SoapStringParam m_Cluster;
	SoapParam<bool> m_SuppressXmlSchema;
	SoapParam<bool> m_BypassCachedResult;
	SoapStructArrayParam<IConstNamedValue, CNamedValue> m_FilterBy;
	SoapParam<__int64> m_Start;
	SoapParam<int> m_Count;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CWUResultRequest(const char *serviceName, const char *bcompat);

	CWUResultRequest(const char *serviceName, IRpcMessageBinding *init=NULL);
	CWUResultRequest(const char *serviceName, IRpcMessage* rpcmsg);
	CWUResultRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	IEspClientRpcSettings &rpc(){return *static_cast<IEspClientRpcSettings*>(this);}


	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "WUResultRequest";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CWUResultRequest &from);

	void copy(IConstWUResultRequest &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstWUResultRequest &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	const char * getWuid();
	int getSequence();
	const char * getResultName();
	const char * getLogicalName();
	const char * getCluster();
	bool getSuppressXmlSchema();
	bool getBypassCachedResult();
	IArrayOf<IConstNamedValue> & getFilterBy();
	__int64 getStart();
	int getCount();
	void setWuid(const char * val);
	void setSequence(int val);
	void setResultName(const char * val);
	void setLogicalName(const char * val);
	void setCluster(const char * val);
	void setSuppressXmlSchema(bool val);
	void setBypassCachedResult(bool val);
	void setFilterBy(IArrayOf<IEspNamedValue> &val);
 void setFilterBy(IArrayOf<IConstNamedValue> &val);
	void setStart(__int64 val);
	void setCount(int val);
};

class CWUResultResponse : public CSoapResponseBinding,
   implements IEspWUResultResponse,
   implements IClientWUResultResponse
{
protected:
	SoapStringParam m_Wuid;
	SoapParam<int> m_Sequence;
	SoapStringParam m_LogicalName;
	SoapStringParam m_Cluster;
	SoapStringParam m_Name;
	SoapParam<__int64> m_Start;
	SoapParam<int> m_Requested;
	SoapParam<int> m_Count;
	SoapParam<__int64> m_Total;
	SoapStringParam m_Result;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CWUResultResponse(const char *serviceName, const char *bcompat);

	CWUResultResponse(const char *serviceName, IRpcMessageBinding *init=NULL);
	CWUResultResponse(const char *serviceName, IRpcMessage* rpcmsg);
	CWUResultResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "WUResultResponse";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CWUResultResponse &from);

	void copy(IConstWUResultResponse &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstWUResultResponse &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	virtual void setRedirectUrl(const char *url)
	{ CSoapResponseBinding::setRedirectUrl(url); }

	virtual const IMultiException& getExceptions()
	{ return CSoapResponseBinding::getExceptions(); }

	virtual int queryClientStatus()
	{ return CSoapResponseBinding::getRpcState(); }

	virtual void noteException(IException& e)
	{  CSoapResponseBinding::noteException(e); }

	const char * getWuid();
	int getSequence();
	const char * getLogicalName();
	const char * getCluster();
	const char * getName();
	__int64 getStart();
	int getRequested();
	int getCount();
	__int64 getTotal();
	const char * getResult();
	void setWuid(const char * val);
	void setSequence(int val);
	void setLogicalName(const char * val);
	void setCluster(const char * val);
	void setName(const char * val);
	void setStart(__int64 val);
	void setRequested(int val);
	void setCount(int val);
	void setTotal(__int64 val);
	void setResult(const char * val);
};

class CWUFullResultRequest : public CSoapRequestBinding,
   implements IEspWUFullResultRequest,
   implements IClientWUFullResultRequest
{
protected:
	SoapStringParam m_Wuid;
	SoapParam<bool> m_NoRootTag;
	CXWUExceptionSeverity m_ExceptionSeverity;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CWUFullResultRequest(const char *serviceName, const char *bcompat);

	CWUFullResultRequest(const char *serviceName, IRpcMessageBinding *init=NULL);
	CWUFullResultRequest(const char *serviceName, IRpcMessage* rpcmsg);
	CWUFullResultRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	IEspClientRpcSettings &rpc(){return *static_cast<IEspClientRpcSettings*>(this);}


	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "WUFullResultRequest";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CWUFullResultRequest &from);

	void copy(IConstWUFullResultRequest &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstWUFullResultRequest &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	const char * getWuid();
	bool getNoRootTag();
	CWUExceptionSeverity getExceptionSeverity();
	const char* getExceptionSeverityAsString();
	void setWuid(const char * val);
	void setNoRootTag(bool val);
	void setExceptionSeverity(CWUExceptionSeverity val);
void setExceptionSeverity(const char* val);
};

class CWUFullResultResponse : public CSoapResponseBinding,
   implements IEspWUFullResultResponse,
   implements IClientWUFullResultResponse
{
protected:
	SoapStringParam m_Wuid;
	SoapStringParam m_Results;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CWUFullResultResponse(const char *serviceName, const char *bcompat);

	CWUFullResultResponse(const char *serviceName, IRpcMessageBinding *init=NULL);
	CWUFullResultResponse(const char *serviceName, IRpcMessage* rpcmsg);
	CWUFullResultResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "WUFullResultResponse";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CWUFullResultResponse &from);

	void copy(IConstWUFullResultResponse &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstWUFullResultResponse &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	virtual void setRedirectUrl(const char *url)
	{ CSoapResponseBinding::setRedirectUrl(url); }

	virtual const IMultiException& getExceptions()
	{ return CSoapResponseBinding::getExceptions(); }

	virtual int queryClientStatus()
	{ return CSoapResponseBinding::getRpcState(); }

	virtual void noteException(IException& e)
	{  CSoapResponseBinding::noteException(e); }

	const char * getWuid();
	const char * getResults();
	void setWuid(const char * val);
	void setResults(const char * val);
};

class CWUResultViewRequest : public CSoapRequestBinding,
   implements IEspWUResultViewRequest,
   implements IClientWUResultViewRequest
{
protected:
	SoapStringParam m_Wuid;
	SoapStringParam m_ViewName;
	SoapParam<int> m_Sequence;
	SoapStringParam m_ResultName;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CWUResultViewRequest(const char *serviceName, const char *bcompat);

	CWUResultViewRequest(const char *serviceName, IRpcMessageBinding *init=NULL);
	CWUResultViewRequest(const char *serviceName, IRpcMessage* rpcmsg);
	CWUResultViewRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	IEspClientRpcSettings &rpc(){return *static_cast<IEspClientRpcSettings*>(this);}


	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "WUResultViewRequest";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CWUResultViewRequest &from);

	void copy(IConstWUResultViewRequest &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstWUResultViewRequest &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	const char * getWuid();
	const char * getViewName();
	int getSequence();
	const char * getResultName();
	void setWuid(const char * val);
	void setViewName(const char * val);
	void setSequence(int val);
	void setResultName(const char * val);
};

class CWUResultViewResponse : public CSoapResponseBinding,
   implements IEspWUResultViewResponse,
   implements IClientWUResultViewResponse
{
protected:
	SoapStringParam m_Wuid;
	SoapStringParam m_ViewName;
	SoapStringParam m_Result;
	StringBuffer m_Result_mimetype;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CWUResultViewResponse(const char *serviceName, const char *bcompat);

	CWUResultViewResponse(const char *serviceName, IRpcMessageBinding *init=NULL);
	CWUResultViewResponse(const char *serviceName, IRpcMessage* rpcmsg);
	CWUResultViewResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "WUResultViewResponse";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return true;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CWUResultViewResponse &from);

	void copy(IConstWUResultViewResponse &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstWUResultViewResponse &ifrom, StringBuffer& buffer, bool keepRootTag=true);

	void appendContent(IEspContext* ctx, MemoryBuffer& buffer, StringBuffer &mimetype);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	virtual void setRedirectUrl(const char *url)
	{ CSoapResponseBinding::setRedirectUrl(url); }

	virtual const IMultiException& getExceptions()
	{ return CSoapResponseBinding::getExceptions(); }

	virtual int queryClientStatus()
	{ return CSoapResponseBinding::getRpcState(); }

	virtual void noteException(IException& e)
	{  CSoapResponseBinding::noteException(e); }

	const char * getWuid();
	const char * getViewName();
	const char *getResult_mimetype();
	const char * getResult();
	void setWuid(const char * val);
	void setViewName(const char * val);
	void setResult_mimetype(const char *  val);
	void setResult(const char * val);
};

class CWUClusterJobQueueXLSRequest : public CSoapRequestBinding,
   implements IEspWUClusterJobQueueXLSRequest,
   implements IClientWUClusterJobQueueXLSRequest
{
protected:
	SoapStringParam m_Cluster;
	SoapStringParam m_StartDate;
	SoapStringParam m_EndDate;
	SoapStringParam m_ShowType;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CWUClusterJobQueueXLSRequest(const char *serviceName, const char *bcompat);

	CWUClusterJobQueueXLSRequest(const char *serviceName, IRpcMessageBinding *init=NULL);
	CWUClusterJobQueueXLSRequest(const char *serviceName, IRpcMessage* rpcmsg);
	CWUClusterJobQueueXLSRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	IEspClientRpcSettings &rpc(){return *static_cast<IEspClientRpcSettings*>(this);}


	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "WUClusterJobQueueXLSRequest";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CWUClusterJobQueueXLSRequest &from);

	void copy(IConstWUClusterJobQueueXLSRequest &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstWUClusterJobQueueXLSRequest &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	const char * getCluster();
	const char * getStartDate();
	const char * getEndDate();
	const char * getShowType();
	void setCluster(const char * val);
	void setStartDate(const char * val);
	void setEndDate(const char * val);
	void setShowType(const char * val);
};

class CWUClusterJobQueueXLSResponse : public CSoapResponseBinding,
   implements IEspWUClusterJobQueueXLSResponse,
   implements IClientWUClusterJobQueueXLSResponse
{
protected:
	SoapParamBinary m_Result;
	StringBuffer m_Result_mimetype;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CWUClusterJobQueueXLSResponse(const char *serviceName, const char *bcompat);

	CWUClusterJobQueueXLSResponse(const char *serviceName, IRpcMessageBinding *init=NULL);
	CWUClusterJobQueueXLSResponse(const char *serviceName, IRpcMessage* rpcmsg);
	CWUClusterJobQueueXLSResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "WUClusterJobQueueXLSResponse";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return true;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CWUClusterJobQueueXLSResponse &from);

	void copy(IConstWUClusterJobQueueXLSResponse &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstWUClusterJobQueueXLSResponse &ifrom, StringBuffer& buffer, bool keepRootTag=true);

	void appendContent(IEspContext* ctx, MemoryBuffer& buffer, StringBuffer &mimetype);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	virtual void setRedirectUrl(const char *url)
	{ CSoapResponseBinding::setRedirectUrl(url); }

	virtual const IMultiException& getExceptions()
	{ return CSoapResponseBinding::getExceptions(); }

	virtual int queryClientStatus()
	{ return CSoapResponseBinding::getRpcState(); }

	virtual void noteException(IException& e)
	{  CSoapResponseBinding::noteException(e); }

	const char *getResult_mimetype();
	const MemoryBuffer & getResult();
	void setResult_mimetype(const char *  val);
	void setResult(const MemoryBuffer & val);
};

class CWUClusterJobQueueLOGRequest : public CSoapRequestBinding,
   implements IEspWUClusterJobQueueLOGRequest,
   implements IClientWUClusterJobQueueLOGRequest
{
protected:
	SoapStringParam m_Cluster;
	SoapStringParam m_StartDate;
	SoapStringParam m_EndDate;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CWUClusterJobQueueLOGRequest(const char *serviceName, const char *bcompat);

	CWUClusterJobQueueLOGRequest(const char *serviceName, IRpcMessageBinding *init=NULL);
	CWUClusterJobQueueLOGRequest(const char *serviceName, IRpcMessage* rpcmsg);
	CWUClusterJobQueueLOGRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	IEspClientRpcSettings &rpc(){return *static_cast<IEspClientRpcSettings*>(this);}


	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "WUClusterJobQueueLOGRequest";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CWUClusterJobQueueLOGRequest &from);

	void copy(IConstWUClusterJobQueueLOGRequest &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstWUClusterJobQueueLOGRequest &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	const char * getCluster();
	const char * getStartDate();
	const char * getEndDate();
	void setCluster(const char * val);
	void setStartDate(const char * val);
	void setEndDate(const char * val);
};

class CWUClusterJobQueueLOGResponse : public CSoapResponseBinding,
   implements IEspWUClusterJobQueueLOGResponse,
   implements IClientWUClusterJobQueueLOGResponse
{
protected:
	SoapParamBinary m_thefile;
	StringBuffer m_thefile_mimetype;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CWUClusterJobQueueLOGResponse(const char *serviceName, const char *bcompat);

	CWUClusterJobQueueLOGResponse(const char *serviceName, IRpcMessageBinding *init=NULL);
	CWUClusterJobQueueLOGResponse(const char *serviceName, IRpcMessage* rpcmsg);
	CWUClusterJobQueueLOGResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "WUClusterJobQueueLOGResponse";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return true;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CWUClusterJobQueueLOGResponse &from);

	void copy(IConstWUClusterJobQueueLOGResponse &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstWUClusterJobQueueLOGResponse &ifrom, StringBuffer& buffer, bool keepRootTag=true);

	void appendContent(IEspContext* ctx, MemoryBuffer& buffer, StringBuffer &mimetype);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	virtual void setRedirectUrl(const char *url)
	{ CSoapResponseBinding::setRedirectUrl(url); }

	virtual const IMultiException& getExceptions()
	{ return CSoapResponseBinding::getExceptions(); }

	virtual int queryClientStatus()
	{ return CSoapResponseBinding::getRpcState(); }

	virtual void noteException(IException& e)
	{  CSoapResponseBinding::noteException(e); }

	const char *getThefile_mimetype();
	const MemoryBuffer & getThefile();
	void setThefile_mimetype(const char *  val);
	void setThefile(const MemoryBuffer & val);
};

class CWUClusterJobXLSRequest : public CSoapRequestBinding,
   implements IEspWUClusterJobXLSRequest,
   implements IClientWUClusterJobXLSRequest
{
protected:
	SoapStringParam m_Cluster;
	SoapStringParam m_StartDate;
	SoapStringParam m_EndDate;
	SoapParam<bool> m_ShowAll;
	SoapStringParam m_BusinessStartTime;
	SoapStringParam m_BusinessEndTime;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CWUClusterJobXLSRequest(const char *serviceName, const char *bcompat);

	CWUClusterJobXLSRequest(const char *serviceName, IRpcMessageBinding *init=NULL);
	CWUClusterJobXLSRequest(const char *serviceName, IRpcMessage* rpcmsg);
	CWUClusterJobXLSRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	IEspClientRpcSettings &rpc(){return *static_cast<IEspClientRpcSettings*>(this);}


	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "WUClusterJobXLSRequest";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CWUClusterJobXLSRequest &from);

	void copy(IConstWUClusterJobXLSRequest &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstWUClusterJobXLSRequest &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	const char * getCluster();
	const char * getStartDate();
	const char * getEndDate();
	bool getShowAll();
	const char * getBusinessStartTime();
	const char * getBusinessEndTime();
	void setCluster(const char * val);
	void setStartDate(const char * val);
	void setEndDate(const char * val);
	void setShowAll(bool val);
	void setBusinessStartTime(const char * val);
	void setBusinessEndTime(const char * val);
};

class CWUClusterJobXLSResponse : public CSoapResponseBinding,
   implements IEspWUClusterJobXLSResponse,
   implements IClientWUClusterJobXLSResponse
{
protected:
	SoapParamBinary m_Result;
	StringBuffer m_Result_mimetype;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CWUClusterJobXLSResponse(const char *serviceName, const char *bcompat);

	CWUClusterJobXLSResponse(const char *serviceName, IRpcMessageBinding *init=NULL);
	CWUClusterJobXLSResponse(const char *serviceName, IRpcMessage* rpcmsg);
	CWUClusterJobXLSResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "WUClusterJobXLSResponse";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return true;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CWUClusterJobXLSResponse &from);

	void copy(IConstWUClusterJobXLSResponse &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstWUClusterJobXLSResponse &ifrom, StringBuffer& buffer, bool keepRootTag=true);

	void appendContent(IEspContext* ctx, MemoryBuffer& buffer, StringBuffer &mimetype);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	virtual void setRedirectUrl(const char *url)
	{ CSoapResponseBinding::setRedirectUrl(url); }

	virtual const IMultiException& getExceptions()
	{ return CSoapResponseBinding::getExceptions(); }

	virtual int queryClientStatus()
	{ return CSoapResponseBinding::getRpcState(); }

	virtual void noteException(IException& e)
	{  CSoapResponseBinding::noteException(e); }

	const char *getResult_mimetype();
	const MemoryBuffer & getResult();
	void setResult_mimetype(const char *  val);
	void setResult(const MemoryBuffer & val);
};

class CWUClusterJobSummaryXLSRequest : public CSoapRequestBinding,
   implements IEspWUClusterJobSummaryXLSRequest,
   implements IClientWUClusterJobSummaryXLSRequest
{
protected:
	SoapStringParam m_Cluster;
	SoapStringParam m_StartDate;
	SoapStringParam m_EndDate;
	SoapParam<bool> m_ShowAll;
	SoapStringParam m_BusinessStartTime;
	SoapStringParam m_BusinessEndTime;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CWUClusterJobSummaryXLSRequest(const char *serviceName, const char *bcompat);

	CWUClusterJobSummaryXLSRequest(const char *serviceName, IRpcMessageBinding *init=NULL);
	CWUClusterJobSummaryXLSRequest(const char *serviceName, IRpcMessage* rpcmsg);
	CWUClusterJobSummaryXLSRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	IEspClientRpcSettings &rpc(){return *static_cast<IEspClientRpcSettings*>(this);}


	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "WUClusterJobSummaryXLSRequest";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CWUClusterJobSummaryXLSRequest &from);

	void copy(IConstWUClusterJobSummaryXLSRequest &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstWUClusterJobSummaryXLSRequest &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	const char * getCluster();
	const char * getStartDate();
	const char * getEndDate();
	bool getShowAll();
	const char * getBusinessStartTime();
	const char * getBusinessEndTime();
	void setCluster(const char * val);
	void setStartDate(const char * val);
	void setEndDate(const char * val);
	void setShowAll(bool val);
	void setBusinessStartTime(const char * val);
	void setBusinessEndTime(const char * val);
};

class CWUClusterJobSummaryXLSResponse : public CSoapResponseBinding,
   implements IEspWUClusterJobSummaryXLSResponse,
   implements IClientWUClusterJobSummaryXLSResponse
{
protected:
	SoapParamBinary m_Result;
	StringBuffer m_Result_mimetype;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CWUClusterJobSummaryXLSResponse(const char *serviceName, const char *bcompat);

	CWUClusterJobSummaryXLSResponse(const char *serviceName, IRpcMessageBinding *init=NULL);
	CWUClusterJobSummaryXLSResponse(const char *serviceName, IRpcMessage* rpcmsg);
	CWUClusterJobSummaryXLSResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "WUClusterJobSummaryXLSResponse";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return true;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CWUClusterJobSummaryXLSResponse &from);

	void copy(IConstWUClusterJobSummaryXLSResponse &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstWUClusterJobSummaryXLSResponse &ifrom, StringBuffer& buffer, bool keepRootTag=true);

	void appendContent(IEspContext* ctx, MemoryBuffer& buffer, StringBuffer &mimetype);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	virtual void setRedirectUrl(const char *url)
	{ CSoapResponseBinding::setRedirectUrl(url); }

	virtual const IMultiException& getExceptions()
	{ return CSoapResponseBinding::getExceptions(); }

	virtual int queryClientStatus()
	{ return CSoapResponseBinding::getRpcState(); }

	virtual void noteException(IException& e)
	{  CSoapResponseBinding::noteException(e); }

	const char *getResult_mimetype();
	const MemoryBuffer & getResult();
	void setResult_mimetype(const char *  val);
	void setResult(const MemoryBuffer & val);
};

class CWUGetThorJobQueueRequest : public CSoapRequestBinding,
   implements IEspWUGetThorJobQueueRequest,
   implements IClientWUGetThorJobQueueRequest
{
protected:
	SoapStringParam m_Cluster;
	SoapStringParam m_StartDate;
	SoapStringParam m_EndDate;
	SoapParam<unsigned int> m_MaxJobQueueItemsToReturn;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CWUGetThorJobQueueRequest(const char *serviceName, const char *bcompat);

	CWUGetThorJobQueueRequest(const char *serviceName, IRpcMessageBinding *init=NULL);
	CWUGetThorJobQueueRequest(const char *serviceName, IRpcMessage* rpcmsg);
	CWUGetThorJobQueueRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	IEspClientRpcSettings &rpc(){return *static_cast<IEspClientRpcSettings*>(this);}


	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "WUGetThorJobQueueRequest";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CWUGetThorJobQueueRequest &from);

	void copy(IConstWUGetThorJobQueueRequest &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstWUGetThorJobQueueRequest &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	const char * getCluster();
	const char * getStartDate();
	const char * getEndDate();
bool getMaxJobQueueItemsToReturn_isNull();
	unsigned int getMaxJobQueueItemsToReturn();
	void setCluster(const char * val);
	void setStartDate(const char * val);
	void setEndDate(const char * val);
	void setMaxJobQueueItemsToReturn_null();
	void setMaxJobQueueItemsToReturn(unsigned int val);
};

class CWUGetThorJobQueueResponse : public CSoapResponseBinding,
   implements IEspWUGetThorJobQueueResponse,
   implements IClientWUGetThorJobQueueResponse
{
protected:
	SoapParam<int> m_LongestQueue;
	SoapParam<int> m_MaxThorConnected;
	SoapStructArrayParam<IConstThorQueue, CThorQueue> m_QueueList;
	SoapStringParam m_Warning;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CWUGetThorJobQueueResponse(const char *serviceName, const char *bcompat);

	CWUGetThorJobQueueResponse(const char *serviceName, IRpcMessageBinding *init=NULL);
	CWUGetThorJobQueueResponse(const char *serviceName, IRpcMessage* rpcmsg);
	CWUGetThorJobQueueResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "WUGetThorJobQueueResponse";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CWUGetThorJobQueueResponse &from);

	void copy(IConstWUGetThorJobQueueResponse &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstWUGetThorJobQueueResponse &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	virtual void setRedirectUrl(const char *url)
	{ CSoapResponseBinding::setRedirectUrl(url); }

	virtual const IMultiException& getExceptions()
	{ return CSoapResponseBinding::getExceptions(); }

	virtual int queryClientStatus()
	{ return CSoapResponseBinding::getRpcState(); }

	virtual void noteException(IException& e)
	{  CSoapResponseBinding::noteException(e); }

	int getLongestQueue();
	int getMaxThorConnected();
	IArrayOf<IConstThorQueue> & getQueueList();
	const char * getWarning();
	void setLongestQueue(int val);
	void setMaxThorConnected(int val);
	void setQueueList(IArrayOf<IEspThorQueue> &val);
 void setQueueList(IArrayOf<IConstThorQueue> &val);
	void setWarning(const char * val);
};

class CWUGetThorJobListRequest : public CSoapRequestBinding,
   implements IEspWUGetThorJobListRequest,
   implements IClientWUGetThorJobListRequest
{
protected:
	SoapStringParam m_Cluster;
	SoapStringParam m_StartDate;
	SoapStringParam m_EndDate;
	SoapParam<unsigned int> m_MaxJobsToReturn;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CWUGetThorJobListRequest(const char *serviceName, const char *bcompat);

	CWUGetThorJobListRequest(const char *serviceName, IRpcMessageBinding *init=NULL);
	CWUGetThorJobListRequest(const char *serviceName, IRpcMessage* rpcmsg);
	CWUGetThorJobListRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	IEspClientRpcSettings &rpc(){return *static_cast<IEspClientRpcSettings*>(this);}


	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "WUGetThorJobListRequest";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CWUGetThorJobListRequest &from);

	void copy(IConstWUGetThorJobListRequest &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstWUGetThorJobListRequest &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	const char * getCluster();
	const char * getStartDate();
	const char * getEndDate();
bool getMaxJobsToReturn_isNull();
	unsigned int getMaxJobsToReturn();
	void setCluster(const char * val);
	void setStartDate(const char * val);
	void setEndDate(const char * val);
	void setMaxJobsToReturn_null();
	void setMaxJobsToReturn(unsigned int val);
};

class CWUGetThorJobListResponse : public CSoapResponseBinding,
   implements IEspWUGetThorJobListResponse,
   implements IClientWUGetThorJobListResponse
{
protected:
	SoapStructArrayParam<IConstECLJob, CECLJob> m_JobList;
	SoapStructArrayParam<IConstECLJob, CECLJob> m_InProgressJobList;
	SoapStringParam m_Warning;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CWUGetThorJobListResponse(const char *serviceName, const char *bcompat);

	CWUGetThorJobListResponse(const char *serviceName, IRpcMessageBinding *init=NULL);
	CWUGetThorJobListResponse(const char *serviceName, IRpcMessage* rpcmsg);
	CWUGetThorJobListResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "WUGetThorJobListResponse";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CWUGetThorJobListResponse &from);

	void copy(IConstWUGetThorJobListResponse &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstWUGetThorJobListResponse &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	virtual void setRedirectUrl(const char *url)
	{ CSoapResponseBinding::setRedirectUrl(url); }

	virtual const IMultiException& getExceptions()
	{ return CSoapResponseBinding::getExceptions(); }

	virtual int queryClientStatus()
	{ return CSoapResponseBinding::getRpcState(); }

	virtual void noteException(IException& e)
	{  CSoapResponseBinding::noteException(e); }

	IArrayOf<IConstECLJob> & getJobList();
	IArrayOf<IConstECLJob> & getInProgressJobList();
	const char * getWarning();
	void setJobList(IArrayOf<IEspECLJob> &val);
 void setJobList(IArrayOf<IConstECLJob> &val);
	void setInProgressJobList(IArrayOf<IEspECLJob> &val);
 void setInProgressJobList(IArrayOf<IConstECLJob> &val);
	void setWarning(const char * val);
};

class CGVCAjaxGraphRequest : public CSoapRequestBinding,
   implements IEspGVCAjaxGraphRequest,
   implements IClientGVCAjaxGraphRequest
{
protected:
	SoapStringParam m_Name;
	SoapStringParam m_GraphName;
	SoapParam<int> m_SubGraphId;
	SoapParam<bool> m_SubGraphOnly;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CGVCAjaxGraphRequest(const char *serviceName, const char *bcompat);

	CGVCAjaxGraphRequest(const char *serviceName, IRpcMessageBinding *init=NULL);
	CGVCAjaxGraphRequest(const char *serviceName, IRpcMessage* rpcmsg);
	CGVCAjaxGraphRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	IEspClientRpcSettings &rpc(){return *static_cast<IEspClientRpcSettings*>(this);}


	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "GVCAjaxGraphRequest";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CGVCAjaxGraphRequest &from);

	void copy(IConstGVCAjaxGraphRequest &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstGVCAjaxGraphRequest &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	const char * getName();
	const char * getGraphName();
	int getSubGraphId();
	bool getSubGraphOnly();
	void setName(const char * val);
	void setGraphName(const char * val);
	void setSubGraphId(int val);
	void setSubGraphOnly(bool val);
};

class CGVCAjaxGraphResponse : public CSoapResponseBinding,
   implements IEspGVCAjaxGraphResponse,
   implements IClientGVCAjaxGraphResponse
{
protected:
	SoapStringParam m_Name;
	SoapStringParam m_GraphName;
	SoapStringParam m_GraphType;
	SoapParam<int> m_SubGraphId;
	SoapParam<bool> m_SubGraphOnly;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CGVCAjaxGraphResponse(const char *serviceName, const char *bcompat);

	CGVCAjaxGraphResponse(const char *serviceName, IRpcMessageBinding *init=NULL);
	CGVCAjaxGraphResponse(const char *serviceName, IRpcMessage* rpcmsg);
	CGVCAjaxGraphResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "GVCAjaxGraphResponse";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CGVCAjaxGraphResponse &from);

	void copy(IConstGVCAjaxGraphResponse &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstGVCAjaxGraphResponse &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	virtual void setRedirectUrl(const char *url)
	{ CSoapResponseBinding::setRedirectUrl(url); }

	virtual const IMultiException& getExceptions()
	{ return CSoapResponseBinding::getExceptions(); }

	virtual int queryClientStatus()
	{ return CSoapResponseBinding::getRpcState(); }

	virtual void noteException(IException& e)
	{  CSoapResponseBinding::noteException(e); }

	const char * getName();
	const char * getGraphName();
	const char * getGraphType();
	int getSubGraphId();
	bool getSubGraphOnly();
	void setName(const char * val);
	void setGraphName(const char * val);
	void setGraphType(const char * val);
	void setSubGraphId(int val);
	void setSubGraphOnly(bool val);
};

class CWUGraphInfoRequest : public CSoapRequestBinding,
   implements IEspWUGraphInfoRequest,
   implements IClientWUGraphInfoRequest
{
protected:
	SoapStringParam m_Wuid;
	SoapStringParam m_Name;
	SoapStringParam m_GID;
	SoapParam<int> m_BatchWU;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CWUGraphInfoRequest(const char *serviceName, const char *bcompat);

	CWUGraphInfoRequest(const char *serviceName, IRpcMessageBinding *init=NULL);
	CWUGraphInfoRequest(const char *serviceName, IRpcMessage* rpcmsg);
	CWUGraphInfoRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	IEspClientRpcSettings &rpc(){return *static_cast<IEspClientRpcSettings*>(this);}


	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "WUGraphInfoRequest";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CWUGraphInfoRequest &from);

	void copy(IConstWUGraphInfoRequest &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstWUGraphInfoRequest &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	const char * getWuid();
	const char * getName();
	const char * getGID();
bool getBatchWU_isNull();
	int getBatchWU();
	void setWuid(const char * val);
	void setName(const char * val);
	void setGID(const char * val);
	void setBatchWU_null();
	void setBatchWU(int val);
};

class CWUGraphInfoResponse : public CSoapResponseBinding,
   implements IEspWUGraphInfoResponse,
   implements IClientWUGraphInfoResponse
{
protected:
	SoapStringParam m_Wuid;
	SoapStringParam m_Name;
	SoapStringParam m_GID;
	SoapParam<int> m_BatchWU;
	SoapParam<bool> m_Running;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CWUGraphInfoResponse(const char *serviceName, const char *bcompat);

	CWUGraphInfoResponse(const char *serviceName, IRpcMessageBinding *init=NULL);
	CWUGraphInfoResponse(const char *serviceName, IRpcMessage* rpcmsg);
	CWUGraphInfoResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "WUGraphInfoResponse";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CWUGraphInfoResponse &from);

	void copy(IConstWUGraphInfoResponse &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstWUGraphInfoResponse &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	virtual void setRedirectUrl(const char *url)
	{ CSoapResponseBinding::setRedirectUrl(url); }

	virtual const IMultiException& getExceptions()
	{ return CSoapResponseBinding::getExceptions(); }

	virtual int queryClientStatus()
	{ return CSoapResponseBinding::getRpcState(); }

	virtual void noteException(IException& e)
	{  CSoapResponseBinding::noteException(e); }

	const char * getWuid();
	const char * getName();
	const char * getGID();
	int getBatchWU();
	bool getRunning();
	void setWuid(const char * val);
	void setName(const char * val);
	void setGID(const char * val);
	void setBatchWU(int val);
	void setRunning(bool val);
};

class CWUGVCGraphInfoRequest : public CSoapRequestBinding,
   implements IEspWUGVCGraphInfoRequest,
   implements IClientWUGVCGraphInfoRequest
{
protected:
	SoapStringParam m_Wuid;
	SoapStringParam m_Name;
	SoapStringParam m_GID;
	SoapParam<int> m_BatchWU;
	SoapParam<int> m_SubgraphId;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CWUGVCGraphInfoRequest(const char *serviceName, const char *bcompat);

	CWUGVCGraphInfoRequest(const char *serviceName, IRpcMessageBinding *init=NULL);
	CWUGVCGraphInfoRequest(const char *serviceName, IRpcMessage* rpcmsg);
	CWUGVCGraphInfoRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	IEspClientRpcSettings &rpc(){return *static_cast<IEspClientRpcSettings*>(this);}


	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "WUGVCGraphInfoRequest";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CWUGVCGraphInfoRequest &from);

	void copy(IConstWUGVCGraphInfoRequest &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstWUGVCGraphInfoRequest &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	const char * getWuid();
	const char * getName();
	const char * getGID();
bool getBatchWU_isNull();
	int getBatchWU();
bool getSubgraphId_isNull();
	int getSubgraphId();
	void setWuid(const char * val);
	void setName(const char * val);
	void setGID(const char * val);
	void setBatchWU_null();
	void setBatchWU(int val);
	void setSubgraphId_null();
	void setSubgraphId(int val);
};

class CWUGVCGraphInfoResponse : public CSoapResponseBinding,
   implements IEspWUGVCGraphInfoResponse,
   implements IClientWUGVCGraphInfoResponse
{
protected:
	SoapStringParam m_Wuid;
	SoapStringParam m_Name;
	SoapStringParam m_GID;
	SoapParam<bool> m_Running;
	SoapStringParam m_TheGraph;
	SoapParam<int> m_BatchWU;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CWUGVCGraphInfoResponse(const char *serviceName, const char *bcompat);

	CWUGVCGraphInfoResponse(const char *serviceName, IRpcMessageBinding *init=NULL);
	CWUGVCGraphInfoResponse(const char *serviceName, IRpcMessage* rpcmsg);
	CWUGVCGraphInfoResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "WUGVCGraphInfoResponse";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CWUGVCGraphInfoResponse &from);

	void copy(IConstWUGVCGraphInfoResponse &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstWUGVCGraphInfoResponse &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	virtual void setRedirectUrl(const char *url)
	{ CSoapResponseBinding::setRedirectUrl(url); }

	virtual const IMultiException& getExceptions()
	{ return CSoapResponseBinding::getExceptions(); }

	virtual int queryClientStatus()
	{ return CSoapResponseBinding::getRpcState(); }

	virtual void noteException(IException& e)
	{  CSoapResponseBinding::noteException(e); }

	const char * getWuid();
	const char * getName();
	const char * getGID();
	bool getRunning();
	const char * getTheGraph();
	int getBatchWU();
	void setWuid(const char * val);
	void setName(const char * val);
	void setGID(const char * val);
	void setRunning(bool val);
	void setTheGraph(const char * val);
	void setBatchWU(int val);
};

class CWUGraphTimingRequest : public CSoapRequestBinding,
   implements IEspWUGraphTimingRequest,
   implements IClientWUGraphTimingRequest
{
protected:
	SoapStringParam m_Wuid;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CWUGraphTimingRequest(const char *serviceName, const char *bcompat);

	CWUGraphTimingRequest(const char *serviceName, IRpcMessageBinding *init=NULL);
	CWUGraphTimingRequest(const char *serviceName, IRpcMessage* rpcmsg);
	CWUGraphTimingRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	IEspClientRpcSettings &rpc(){return *static_cast<IEspClientRpcSettings*>(this);}


	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "WUGraphTimingRequest";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CWUGraphTimingRequest &from);

	void copy(IConstWUGraphTimingRequest &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstWUGraphTimingRequest &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	const char * getWuid();
	void setWuid(const char * val);
};

class CWUGraphTimingResponse : public CSoapResponseBinding,
   implements IEspWUGraphTimingResponse,
   implements IClientWUGraphTimingResponse
{
protected:
	SoapStruct<CECLWorkunit, IConstECLWorkunit> m_Workunit;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CWUGraphTimingResponse(const char *serviceName, const char *bcompat);

	CWUGraphTimingResponse(const char *serviceName, IRpcMessageBinding *init=NULL);
	CWUGraphTimingResponse(const char *serviceName, IRpcMessage* rpcmsg);
	CWUGraphTimingResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "WUGraphTimingResponse";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CWUGraphTimingResponse &from);

	void copy(IConstWUGraphTimingResponse &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstWUGraphTimingResponse &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	virtual void setRedirectUrl(const char *url)
	{ CSoapResponseBinding::setRedirectUrl(url); }

	virtual const IMultiException& getExceptions()
	{ return CSoapResponseBinding::getExceptions(); }

	virtual int queryClientStatus()
	{ return CSoapResponseBinding::getRpcState(); }

	virtual void noteException(IException& e)
	{  CSoapResponseBinding::noteException(e); }

	IConstECLWorkunit & getWorkunit();
	IEspECLWorkunit & updateWorkunit();
	void setWorkunit(IConstECLWorkunit &ifrom);
};

class CWUGetGraphNameAndTypesRequest : public CSoapRequestBinding,
   implements IEspWUGetGraphNameAndTypesRequest,
   implements IClientWUGetGraphNameAndTypesRequest
{
protected:
	SoapStringParam m_Wuid;
	SoapStringParam m_Type;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CWUGetGraphNameAndTypesRequest(const char *serviceName, const char *bcompat);

	CWUGetGraphNameAndTypesRequest(const char *serviceName, IRpcMessageBinding *init=NULL);
	CWUGetGraphNameAndTypesRequest(const char *serviceName, IRpcMessage* rpcmsg);
	CWUGetGraphNameAndTypesRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	IEspClientRpcSettings &rpc(){return *static_cast<IEspClientRpcSettings*>(this);}


	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "WUGetGraphNameAndTypesRequest";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CWUGetGraphNameAndTypesRequest &from);

	void copy(IConstWUGetGraphNameAndTypesRequest &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstWUGetGraphNameAndTypesRequest &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	const char * getWuid();
	const char * getType();
	void setWuid(const char * val);
	void setType(const char * val);
};

class CWUGetGraphNameAndTypesResponse : public CSoapResponseBinding,
   implements IEspWUGetGraphNameAndTypesResponse,
   implements IClientWUGetGraphNameAndTypesResponse
{
protected:
	SoapStructArrayParam<IConstNameAndType, CNameAndType> m_GraphNameAndTypes;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CWUGetGraphNameAndTypesResponse(const char *serviceName, const char *bcompat);

	CWUGetGraphNameAndTypesResponse(const char *serviceName, IRpcMessageBinding *init=NULL);
	CWUGetGraphNameAndTypesResponse(const char *serviceName, IRpcMessage* rpcmsg);
	CWUGetGraphNameAndTypesResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "WUGetGraphNameAndTypesResponse";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CWUGetGraphNameAndTypesResponse &from);

	void copy(IConstWUGetGraphNameAndTypesResponse &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstWUGetGraphNameAndTypesResponse &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	virtual void setRedirectUrl(const char *url)
	{ CSoapResponseBinding::setRedirectUrl(url); }

	virtual const IMultiException& getExceptions()
	{ return CSoapResponseBinding::getExceptions(); }

	virtual int queryClientStatus()
	{ return CSoapResponseBinding::getRpcState(); }

	virtual void noteException(IException& e)
	{  CSoapResponseBinding::noteException(e); }

	IArrayOf<IConstNameAndType> & getGraphNameAndTypes();
	void setGraphNameAndTypes(IArrayOf<IEspNameAndType> &val);
 void setGraphNameAndTypes(IArrayOf<IConstNameAndType> &val);
};

class CWUProcessGraphRequest : public CSoapRequestBinding,
   implements IEspWUProcessGraphRequest,
   implements IClientWUProcessGraphRequest
{
protected:
	SoapStringParam m_Wuid;
	SoapStringParam m_Name;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CWUProcessGraphRequest(const char *serviceName, const char *bcompat);

	CWUProcessGraphRequest(const char *serviceName, IRpcMessageBinding *init=NULL);
	CWUProcessGraphRequest(const char *serviceName, IRpcMessage* rpcmsg);
	CWUProcessGraphRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	IEspClientRpcSettings &rpc(){return *static_cast<IEspClientRpcSettings*>(this);}


	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "WUProcessGraphRequest";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CWUProcessGraphRequest &from);

	void copy(IConstWUProcessGraphRequest &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstWUProcessGraphRequest &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	const char * getWuid();
	const char * getName();
	void setWuid(const char * val);
	void setName(const char * val);
};

class CWUProcessGraphResponse : public CSoapResponseBinding,
   implements IEspWUProcessGraphResponse,
   implements IClientWUProcessGraphResponse
{
protected:
	SoapStringParam m_theGraph;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CWUProcessGraphResponse(const char *serviceName, const char *bcompat);

	CWUProcessGraphResponse(const char *serviceName, IRpcMessageBinding *init=NULL);
	CWUProcessGraphResponse(const char *serviceName, IRpcMessage* rpcmsg);
	CWUProcessGraphResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "WUProcessGraphResponse";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CWUProcessGraphResponse &from);

	void copy(IConstWUProcessGraphResponse &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstWUProcessGraphResponse &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	virtual void setRedirectUrl(const char *url)
	{ CSoapResponseBinding::setRedirectUrl(url); }

	virtual const IMultiException& getExceptions()
	{ return CSoapResponseBinding::getExceptions(); }

	virtual int queryClientStatus()
	{ return CSoapResponseBinding::getRpcState(); }

	virtual void noteException(IException& e)
	{  CSoapResponseBinding::noteException(e); }

	const char * getTheGraph();
	void setTheGraph(const char * val);
};

class CWUGetGraphRequest : public CSoapRequestBinding,
   implements IEspWUGetGraphRequest,
   implements IClientWUGetGraphRequest
{
protected:
	SoapStringParam m_Wuid;
	SoapStringParam m_GraphName;
	SoapStringParam m_SubGraphId;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CWUGetGraphRequest(const char *serviceName, const char *bcompat);

	CWUGetGraphRequest(const char *serviceName, IRpcMessageBinding *init=NULL);
	CWUGetGraphRequest(const char *serviceName, IRpcMessage* rpcmsg);
	CWUGetGraphRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	IEspClientRpcSettings &rpc(){return *static_cast<IEspClientRpcSettings*>(this);}


	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "WUGetGraphRequest";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CWUGetGraphRequest &from);

	void copy(IConstWUGetGraphRequest &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstWUGetGraphRequest &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	const char * getWuid();
	const char * getGraphName();
	const char * getSubGraphId();
	void setWuid(const char * val);
	void setGraphName(const char * val);
	void setSubGraphId(const char * val);
};

class CWUGetGraphResponse : public CSoapResponseBinding,
   implements IEspWUGetGraphResponse,
   implements IClientWUGetGraphResponse
{
protected:
	SoapStructArrayParam<IConstECLGraphEx, CECLGraphEx> m_Graphs;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CWUGetGraphResponse(const char *serviceName, const char *bcompat);

	CWUGetGraphResponse(const char *serviceName, IRpcMessageBinding *init=NULL);
	CWUGetGraphResponse(const char *serviceName, IRpcMessage* rpcmsg);
	CWUGetGraphResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "WUGetGraphResponse";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CWUGetGraphResponse &from);

	void copy(IConstWUGetGraphResponse &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstWUGetGraphResponse &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	virtual void setRedirectUrl(const char *url)
	{ CSoapResponseBinding::setRedirectUrl(url); }

	virtual const IMultiException& getExceptions()
	{ return CSoapResponseBinding::getExceptions(); }

	virtual int queryClientStatus()
	{ return CSoapResponseBinding::getRpcState(); }

	virtual void noteException(IException& e)
	{  CSoapResponseBinding::noteException(e); }

	IArrayOf<IConstECLGraphEx> & getGraphs();
	void setGraphs(IArrayOf<IEspECLGraphEx> &val);
 void setGraphs(IArrayOf<IConstECLGraphEx> &val);
};

class CWUQueryGetGraphRequest : public CSoapRequestBinding,
   implements IEspWUQueryGetGraphRequest,
   implements IClientWUQueryGetGraphRequest
{
protected:
	SoapStringParam m_Target;
	SoapStringParam m_QueryId;
	SoapStringParam m_GraphName;
	SoapStringParam m_SubGraphId;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CWUQueryGetGraphRequest(const char *serviceName, const char *bcompat);

	CWUQueryGetGraphRequest(const char *serviceName, IRpcMessageBinding *init=NULL);
	CWUQueryGetGraphRequest(const char *serviceName, IRpcMessage* rpcmsg);
	CWUQueryGetGraphRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	IEspClientRpcSettings &rpc(){return *static_cast<IEspClientRpcSettings*>(this);}


	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "WUQueryGetGraphRequest";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CWUQueryGetGraphRequest &from);

	void copy(IConstWUQueryGetGraphRequest &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstWUQueryGetGraphRequest &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	const char * getTarget();
	const char * getQueryId();
	const char * getGraphName();
	const char * getSubGraphId();
	void setTarget(const char * val);
	void setQueryId(const char * val);
	void setGraphName(const char * val);
	void setSubGraphId(const char * val);
};

class CWUQueryGetGraphResponse : public CSoapResponseBinding,
   implements IEspWUQueryGetGraphResponse,
   implements IClientWUQueryGetGraphResponse
{
protected:
	SoapStructArrayParam<IConstECLGraphEx, CECLGraphEx> m_Graphs;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CWUQueryGetGraphResponse(const char *serviceName, const char *bcompat);

	CWUQueryGetGraphResponse(const char *serviceName, IRpcMessageBinding *init=NULL);
	CWUQueryGetGraphResponse(const char *serviceName, IRpcMessage* rpcmsg);
	CWUQueryGetGraphResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "WUQueryGetGraphResponse";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CWUQueryGetGraphResponse &from);

	void copy(IConstWUQueryGetGraphResponse &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstWUQueryGetGraphResponse &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	virtual void setRedirectUrl(const char *url)
	{ CSoapResponseBinding::setRedirectUrl(url); }

	virtual const IMultiException& getExceptions()
	{ return CSoapResponseBinding::getExceptions(); }

	virtual int queryClientStatus()
	{ return CSoapResponseBinding::getRpcState(); }

	virtual void noteException(IException& e)
	{  CSoapResponseBinding::noteException(e); }

	IArrayOf<IConstECLGraphEx> & getGraphs();
	void setGraphs(IArrayOf<IEspECLGraphEx> &val);
 void setGraphs(IArrayOf<IConstECLGraphEx> &val);
};

class CWUQueryGetSummaryStatsRequest : public CSoapRequestBinding,
   implements IEspWUQueryGetSummaryStatsRequest,
   implements IClientWUQueryGetSummaryStatsRequest
{
protected:
	SoapStringParam m_Target;
	SoapStringParam m_QueryId;
	SoapStringParam m_FromTime;
	SoapStringParam m_ToTime;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CWUQueryGetSummaryStatsRequest(const char *serviceName, const char *bcompat);

	CWUQueryGetSummaryStatsRequest(const char *serviceName, IRpcMessageBinding *init=NULL);
	CWUQueryGetSummaryStatsRequest(const char *serviceName, IRpcMessage* rpcmsg);
	CWUQueryGetSummaryStatsRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	IEspClientRpcSettings &rpc(){return *static_cast<IEspClientRpcSettings*>(this);}


	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "WUQueryGetSummaryStatsRequest";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CWUQueryGetSummaryStatsRequest &from);

	void copy(IConstWUQueryGetSummaryStatsRequest &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstWUQueryGetSummaryStatsRequest &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	const char * getTarget();
	const char * getQueryId();
	const char * getFromTime();
	const char * getToTime();
	void setTarget(const char * val);
	void setQueryId(const char * val);
	void setFromTime(const char * val);
	void setToTime(const char * val);
};

class CWUQueryGetSummaryStatsResponse : public CSoapResponseBinding,
   implements IEspWUQueryGetSummaryStatsResponse,
   implements IClientWUQueryGetSummaryStatsResponse
{
protected:
	SoapStructArrayParam<IConstQuerySummaryStats, CQuerySummaryStats> m_StatsList;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CWUQueryGetSummaryStatsResponse(const char *serviceName, const char *bcompat);

	CWUQueryGetSummaryStatsResponse(const char *serviceName, IRpcMessageBinding *init=NULL);
	CWUQueryGetSummaryStatsResponse(const char *serviceName, IRpcMessage* rpcmsg);
	CWUQueryGetSummaryStatsResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "WUQueryGetSummaryStatsResponse";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CWUQueryGetSummaryStatsResponse &from);

	void copy(IConstWUQueryGetSummaryStatsResponse &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstWUQueryGetSummaryStatsResponse &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	virtual void setRedirectUrl(const char *url)
	{ CSoapResponseBinding::setRedirectUrl(url); }

	virtual const IMultiException& getExceptions()
	{ return CSoapResponseBinding::getExceptions(); }

	virtual int queryClientStatus()
	{ return CSoapResponseBinding::getRpcState(); }

	virtual void noteException(IException& e)
	{  CSoapResponseBinding::noteException(e); }

	IArrayOf<IConstQuerySummaryStats> & getStatsList();
	void setStatsList(IArrayOf<IEspQuerySummaryStats> &val);
 void setStatsList(IArrayOf<IConstQuerySummaryStats> &val);
};

class CWUExportRequest : public CSoapRequestBinding,
   implements IEspWUExportRequest,
   implements IClientWUExportRequest
{
protected:
	SoapStringParam m_Cluster;
	SoapStringParam m_Owner;
	SoapStringParam m_State;
	SoapStringParam m_StartDate;
	SoapStringParam m_EndDate;
	SoapStringParam m_ECL;
	SoapStringParam m_Jobname;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CWUExportRequest(const char *serviceName, const char *bcompat);

	CWUExportRequest(const char *serviceName, IRpcMessageBinding *init=NULL);
	CWUExportRequest(const char *serviceName, IRpcMessage* rpcmsg);
	CWUExportRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	IEspClientRpcSettings &rpc(){return *static_cast<IEspClientRpcSettings*>(this);}


	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "WUExportRequest";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CWUExportRequest &from);

	void copy(IConstWUExportRequest &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstWUExportRequest &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	const char * getCluster();
	const char * getOwner();
	const char * getState();
	const char * getStartDate();
	const char * getEndDate();
	const char * getECL();
	const char * getJobname();
	void setCluster(const char * val);
	void setOwner(const char * val);
	void setState(const char * val);
	void setStartDate(const char * val);
	void setEndDate(const char * val);
	void setECL(const char * val);
	void setJobname(const char * val);
};

class CWUExportResponse : public CSoapResponseBinding,
   implements IEspWUExportResponse,
   implements IClientWUExportResponse
{
protected:
	SoapParamBinary m_ExportData;
	StringBuffer m_ExportData_mimetype;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CWUExportResponse(const char *serviceName, const char *bcompat);

	CWUExportResponse(const char *serviceName, IRpcMessageBinding *init=NULL);
	CWUExportResponse(const char *serviceName, IRpcMessage* rpcmsg);
	CWUExportResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "WUExportResponse";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return true;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CWUExportResponse &from);

	void copy(IConstWUExportResponse &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstWUExportResponse &ifrom, StringBuffer& buffer, bool keepRootTag=true);

	void appendContent(IEspContext* ctx, MemoryBuffer& buffer, StringBuffer &mimetype);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	virtual void setRedirectUrl(const char *url)
	{ CSoapResponseBinding::setRedirectUrl(url); }

	virtual const IMultiException& getExceptions()
	{ return CSoapResponseBinding::getExceptions(); }

	virtual int queryClientStatus()
	{ return CSoapResponseBinding::getRpcState(); }

	virtual void noteException(IException& e)
	{  CSoapResponseBinding::noteException(e); }

	const char *getExportData_mimetype();
	const MemoryBuffer & getExportData();
	void setExportData_mimetype(const char *  val);
	void setExportData(const MemoryBuffer & val);
};

class CWUWaitRequest : public CSoapRequestBinding,
   implements IEspWUWaitRequest,
   implements IClientWUWaitRequest
{
protected:
	SoapStringParam m_Wuid;
	SoapParam<int> m_Wait;
	SoapParam<bool> m_ReturnOnWait;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CWUWaitRequest(const char *serviceName, const char *bcompat);

	CWUWaitRequest(const char *serviceName, IRpcMessageBinding *init=NULL);
	CWUWaitRequest(const char *serviceName, IRpcMessage* rpcmsg);
	CWUWaitRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	IEspClientRpcSettings &rpc(){return *static_cast<IEspClientRpcSettings*>(this);}


	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "WUWaitRequest";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CWUWaitRequest &from);

	void copy(IConstWUWaitRequest &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstWUWaitRequest &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	const char * getWuid();
	int getWait();
	bool getReturnOnWait();
	void setWuid(const char * val);
	void setWait(int val);
	void setReturnOnWait(bool val);
};

class CWUWaitResponse : public CSoapResponseBinding,
   implements IEspWUWaitResponse,
   implements IClientWUWaitResponse
{
protected:
	SoapParam<int> m_StateID;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CWUWaitResponse(const char *serviceName, const char *bcompat);

	CWUWaitResponse(const char *serviceName, IRpcMessageBinding *init=NULL);
	CWUWaitResponse(const char *serviceName, IRpcMessage* rpcmsg);
	CWUWaitResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "WUWaitResponse";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CWUWaitResponse &from);

	void copy(IConstWUWaitResponse &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstWUWaitResponse &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	virtual void setRedirectUrl(const char *url)
	{ CSoapResponseBinding::setRedirectUrl(url); }

	virtual const IMultiException& getExceptions()
	{ return CSoapResponseBinding::getExceptions(); }

	virtual int queryClientStatus()
	{ return CSoapResponseBinding::getRpcState(); }

	virtual void noteException(IException& e)
	{  CSoapResponseBinding::noteException(e); }

	int getStateID();
	void setStateID(int val);
};

class CWUSyntaxCheckRequest : public CSoapRequestBinding,
   implements IEspWUSyntaxCheckRequest,
   implements IClientWUSyntaxCheckRequest
{
protected:
	SoapStringParam m_ECL;
	SoapStringParam m_ModuleName;
	SoapStringParam m_AttributeName;
	SoapStringParam m_Queue;
	SoapStringParam m_Cluster;
	SoapStringParam m_Snapshot;
	SoapParam<int> m_TimeToWait;
	SoapStructArrayParam<IConstDebugValue, CDebugValue> m_DebugValues;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CWUSyntaxCheckRequest(const char *serviceName, const char *bcompat);

	CWUSyntaxCheckRequest(const char *serviceName, IRpcMessageBinding *init=NULL);
	CWUSyntaxCheckRequest(const char *serviceName, IRpcMessage* rpcmsg);
	CWUSyntaxCheckRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	IEspClientRpcSettings &rpc(){return *static_cast<IEspClientRpcSettings*>(this);}


	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "WUSyntaxCheckRequest";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CWUSyntaxCheckRequest &from);

	void copy(IConstWUSyntaxCheckRequest &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstWUSyntaxCheckRequest &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	const char * getECL();
	const char * getModuleName();
	const char * getAttributeName();
	const char * getQueue();
	const char * getCluster();
	const char * getSnapshot();
	int getTimeToWait();
	IArrayOf<IConstDebugValue> & getDebugValues();
	void setECL(const char * val);
	void setModuleName(const char * val);
	void setAttributeName(const char * val);
	void setQueue(const char * val);
	void setCluster(const char * val);
	void setSnapshot(const char * val);
	void setTimeToWait(int val);
	void setDebugValues(IArrayOf<IEspDebugValue> &val);
 void setDebugValues(IArrayOf<IConstDebugValue> &val);
};

class CWUSyntaxCheckResponse : public CSoapResponseBinding,
   implements IEspWUSyntaxCheckResponse,
   implements IClientWUSyntaxCheckResponse
{
protected:
	SoapStructArrayParam<IConstECLException, CECLException> m_Errors;
	SoapStringParam m_Message;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CWUSyntaxCheckResponse(const char *serviceName, const char *bcompat);

	CWUSyntaxCheckResponse(const char *serviceName, IRpcMessageBinding *init=NULL);
	CWUSyntaxCheckResponse(const char *serviceName, IRpcMessage* rpcmsg);
	CWUSyntaxCheckResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "WUSyntaxCheckResponse";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CWUSyntaxCheckResponse &from);

	void copy(IConstWUSyntaxCheckResponse &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstWUSyntaxCheckResponse &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	virtual void setRedirectUrl(const char *url)
	{ CSoapResponseBinding::setRedirectUrl(url); }

	virtual const IMultiException& getExceptions()
	{ return CSoapResponseBinding::getExceptions(); }

	virtual int queryClientStatus()
	{ return CSoapResponseBinding::getRpcState(); }

	virtual void noteException(IException& e)
	{  CSoapResponseBinding::noteException(e); }

	IArrayOf<IConstECLException> & getErrors();
	const char * getMessage();
	void setErrors(IArrayOf<IEspECLException> &val);
 void setErrors(IArrayOf<IConstECLException> &val);
	void setMessage(const char * val);
};

class CWUCompileECLRequest : public CSoapRequestBinding,
   implements IEspWUCompileECLRequest,
   implements IClientWUCompileECLRequest
{
protected:
	SoapStringParam m_ECL;
	SoapStringParam m_ModuleName;
	SoapStringParam m_AttributeName;
	SoapStringParam m_Queue;
	SoapStringParam m_Cluster;
	SoapStringParam m_Snapshot;
	SoapParam<bool> m_IncludeDependencies;
	SoapParam<bool> m_IncludeComplexity;
	SoapParam<int> m_TimeToWait;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CWUCompileECLRequest(const char *serviceName, const char *bcompat);

	CWUCompileECLRequest(const char *serviceName, IRpcMessageBinding *init=NULL);
	CWUCompileECLRequest(const char *serviceName, IRpcMessage* rpcmsg);
	CWUCompileECLRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	IEspClientRpcSettings &rpc(){return *static_cast<IEspClientRpcSettings*>(this);}


	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "WUCompileECLRequest";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CWUCompileECLRequest &from);

	void copy(IConstWUCompileECLRequest &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstWUCompileECLRequest &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	const char * getECL();
	const char * getModuleName();
	const char * getAttributeName();
	const char * getQueue();
	const char * getCluster();
	const char * getSnapshot();
	bool getIncludeDependencies();
	bool getIncludeComplexity();
	int getTimeToWait();
	void setECL(const char * val);
	void setModuleName(const char * val);
	void setAttributeName(const char * val);
	void setQueue(const char * val);
	void setCluster(const char * val);
	void setSnapshot(const char * val);
	void setIncludeDependencies(bool val);
	void setIncludeComplexity(bool val);
	void setTimeToWait(int val);
};

class CWUCompileECLResponse : public CSoapResponseBinding,
   implements IEspWUCompileECLResponse,
   implements IClientWUCompileECLResponse
{
protected:
	SoapStringParam m_Complexity;
	SoapStructArrayParam<IConstECLException, CECLException> m_Errors;
	SoapStructArrayParam<IConstWUECLAttribute, CWUECLAttribute> m_Dependencies;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CWUCompileECLResponse(const char *serviceName, const char *bcompat);

	CWUCompileECLResponse(const char *serviceName, IRpcMessageBinding *init=NULL);
	CWUCompileECLResponse(const char *serviceName, IRpcMessage* rpcmsg);
	CWUCompileECLResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "WUCompileECLResponse";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CWUCompileECLResponse &from);

	void copy(IConstWUCompileECLResponse &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstWUCompileECLResponse &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	virtual void setRedirectUrl(const char *url)
	{ CSoapResponseBinding::setRedirectUrl(url); }

	virtual const IMultiException& getExceptions()
	{ return CSoapResponseBinding::getExceptions(); }

	virtual int queryClientStatus()
	{ return CSoapResponseBinding::getRpcState(); }

	virtual void noteException(IException& e)
	{  CSoapResponseBinding::noteException(e); }

	const char * getComplexity();
	IArrayOf<IConstECLException> & getErrors();
	IArrayOf<IConstWUECLAttribute> & getDependencies();
	void setComplexity(const char * val);
	void setErrors(IArrayOf<IEspECLException> &val);
 void setErrors(IArrayOf<IConstECLException> &val);
	void setDependencies(IArrayOf<IEspWUECLAttribute> &val);
 void setDependencies(IArrayOf<IConstWUECLAttribute> &val);
};

class CWUJobListRequest : public CSoapRequestBinding,
   implements IEspWUJobListRequest,
   implements IClientWUJobListRequest
{
protected:
	SoapStringParam m_Cluster;
	SoapStringParam m_Process;
	SoapStringParam m_StartDate;
	SoapStringParam m_EndDate;
	SoapParam<bool> m_ShowAll;
	SoapParam<int> m_BusinessStartHour;
	SoapParam<int> m_BusinessEndHour;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CWUJobListRequest(const char *serviceName, const char *bcompat);

	CWUJobListRequest(const char *serviceName, IRpcMessageBinding *init=NULL);
	CWUJobListRequest(const char *serviceName, IRpcMessage* rpcmsg);
	CWUJobListRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	IEspClientRpcSettings &rpc(){return *static_cast<IEspClientRpcSettings*>(this);}


	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "WUJobListRequest";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CWUJobListRequest &from);

	void copy(IConstWUJobListRequest &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstWUJobListRequest &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	const char * getCluster();
	const char * getProcess();
	const char * getStartDate();
	const char * getEndDate();
	bool getShowAll();
	int getBusinessStartHour();
	int getBusinessEndHour();
	void setCluster(const char * val);
	void setProcess(const char * val);
	void setStartDate(const char * val);
	void setEndDate(const char * val);
	void setShowAll(bool val);
	void setBusinessStartHour(int val);
	void setBusinessEndHour(int val);
};

class CWUJobListResponse : public CSoapResponseBinding,
   implements IEspWUJobListResponse,
   implements IClientWUJobListResponse
{
protected:
	SoapStringParam m_StartDate;
	SoapStringParam m_EndDate;
	SoapStructArrayParam<IConstECLJob, CECLJob> m_Jobs;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CWUJobListResponse(const char *serviceName, const char *bcompat);

	CWUJobListResponse(const char *serviceName, IRpcMessageBinding *init=NULL);
	CWUJobListResponse(const char *serviceName, IRpcMessage* rpcmsg);
	CWUJobListResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "WUJobListResponse";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CWUJobListResponse &from);

	void copy(IConstWUJobListResponse &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstWUJobListResponse &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	virtual void setRedirectUrl(const char *url)
	{ CSoapResponseBinding::setRedirectUrl(url); }

	virtual const IMultiException& getExceptions()
	{ return CSoapResponseBinding::getExceptions(); }

	virtual int queryClientStatus()
	{ return CSoapResponseBinding::getRpcState(); }

	virtual void noteException(IException& e)
	{  CSoapResponseBinding::noteException(e); }

	const char * getStartDate();
	const char * getEndDate();
	IArrayOf<IConstECLJob> & getJobs();
	void setStartDate(const char * val);
	void setEndDate(const char * val);
	void setJobs(IArrayOf<IEspECLJob> &val);
 void setJobs(IArrayOf<IConstECLJob> &val);
};

class CWUShowScheduledRequest : public CSoapRequestBinding,
   implements IEspWUShowScheduledRequest,
   implements IClientWUShowScheduledRequest
{
protected:
	SoapStringParam m_Cluster;
	SoapStringParam m_EventName;
	SoapStringParam m_PushEventName;
	SoapStringParam m_PushEventText;
	SoapStringParam m_State;
	SoapStringParam m_JobName;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CWUShowScheduledRequest(const char *serviceName, const char *bcompat);

	CWUShowScheduledRequest(const char *serviceName, IRpcMessageBinding *init=NULL);
	CWUShowScheduledRequest(const char *serviceName, IRpcMessage* rpcmsg);
	CWUShowScheduledRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	IEspClientRpcSettings &rpc(){return *static_cast<IEspClientRpcSettings*>(this);}


	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "WUShowScheduledRequest";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CWUShowScheduledRequest &from);

	void copy(IConstWUShowScheduledRequest &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstWUShowScheduledRequest &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	const char * getCluster();
	const char * getEventName();
	const char * getPushEventName();
	const char * getPushEventText();
	const char * getState();
	const char * getJobName();
	void setCluster(const char * val);
	void setEventName(const char * val);
	void setPushEventName(const char * val);
	void setPushEventText(const char * val);
	void setState(const char * val);
	void setJobName(const char * val);
};

class CScheduledWU : public CSoapComplexType,
   implements IEspScheduledWU,
   implements IClientScheduledWU
{
protected:
	SoapStringParam m_Wuid;
	SoapStringParam m_Cluster;
	SoapStringParam m_EventName;
	SoapStringParam m_EventText;
	SoapStringParam m_JobName;
	SoapParam<int> m_StateID;
	SoapStringParam m_State;
	SoapStringParam m_Owner;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CScheduledWU(const char *serviceName, const char *bcompat);

	CScheduledWU(const char *serviceName, IRpcMessageBinding *init=NULL);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "ScheduledWU";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CScheduledWU &from);

	void copy(IConstScheduledWU &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstScheduledWU &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	const char * getWuid();
	const char * getCluster();
	const char * getEventName();
	const char * getEventText();
	const char * getJobName();
bool getStateID_isNull();
	int getStateID();
	const char * getState();
	const char * getOwner();
	void setWuid(const char * val);
	void setCluster(const char * val);
	void setEventName(const char * val);
	void setEventText(const char * val);
	void setJobName(const char * val);
	void setStateID_null();
	void setStateID(int val);
	void setState(const char * val);
	void setOwner(const char * val);
};

class CServerInfo : public CSoapComplexType,
   implements IEspServerInfo,
   implements IClientServerInfo
{
protected:
	SoapStringParam m_Name;
	SoapStringParam m_NetAddress;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CServerInfo(const char *serviceName, const char *bcompat);

	CServerInfo(const char *serviceName, IRpcMessageBinding *init=NULL);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "ServerInfo";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CServerInfo &from);

	void copy(IConstServerInfo &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstServerInfo &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	const char * getName();
	const char * getNetAddress();
	void setName(const char * val);
	void setNetAddress(const char * val);
};

class CWUShowScheduledResponse : public CSoapResponseBinding,
   implements IEspWUShowScheduledResponse,
   implements IClientWUShowScheduledResponse
{
protected:
	SoapParam<int> m_ClusterSelected;
	SoapStringParam m_EventName;
	SoapStringParam m_PushEventName;
	SoapStringParam m_PushEventText;
	SoapStringParam m_Query;
	SoapStructArrayParam<IConstServerInfo, CServerInfo> m_Clusters;
	SoapStructArrayParam<IConstScheduledWU, CScheduledWU> m_Workunits;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CWUShowScheduledResponse(const char *serviceName, const char *bcompat);

	CWUShowScheduledResponse(const char *serviceName, IRpcMessageBinding *init=NULL);
	CWUShowScheduledResponse(const char *serviceName, IRpcMessage* rpcmsg);
	CWUShowScheduledResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "WUShowScheduledResponse";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CWUShowScheduledResponse &from);

	void copy(IConstWUShowScheduledResponse &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstWUShowScheduledResponse &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	virtual void setRedirectUrl(const char *url)
	{ CSoapResponseBinding::setRedirectUrl(url); }

	virtual const IMultiException& getExceptions()
	{ return CSoapResponseBinding::getExceptions(); }

	virtual int queryClientStatus()
	{ return CSoapResponseBinding::getRpcState(); }

	virtual void noteException(IException& e)
	{  CSoapResponseBinding::noteException(e); }

bool getClusterSelected_isNull();
	int getClusterSelected();
	const char * getEventName();
	const char * getPushEventName();
	const char * getPushEventText();
	const char * getQuery();
	IArrayOf<IConstServerInfo> & getClusters();
	IArrayOf<IConstScheduledWU> & getWorkunits();
	void setClusterSelected_null();
	void setClusterSelected(int val);
	void setEventName(const char * val);
	void setPushEventName(const char * val);
	void setPushEventText(const char * val);
	void setQuery(const char * val);
	void setClusters(IArrayOf<IEspServerInfo> &val);
 void setClusters(IArrayOf<IConstServerInfo> &val);
	void setWorkunits(IArrayOf<IEspScheduledWU> &val);
 void setWorkunits(IArrayOf<IConstScheduledWU> &val);
};

class CWUGetDependancyTreesRequest : public CSoapRequestBinding,
   implements IEspWUGetDependancyTreesRequest,
   implements IClientWUGetDependancyTreesRequest
{
protected:
	SoapStringParam m_Cluster;
	SoapStringParam m_Queue;
	SoapStringParam m_Snapshot;
	SoapStringParam m_Items;
	SoapStringParam m_TimeoutMilliSec;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CWUGetDependancyTreesRequest(const char *serviceName, const char *bcompat);

	CWUGetDependancyTreesRequest(const char *serviceName, IRpcMessageBinding *init=NULL);
	CWUGetDependancyTreesRequest(const char *serviceName, IRpcMessage* rpcmsg);
	CWUGetDependancyTreesRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	IEspClientRpcSettings &rpc(){return *static_cast<IEspClientRpcSettings*>(this);}


	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "WUGetDependancyTreesRequest";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CWUGetDependancyTreesRequest &from);

	void copy(IConstWUGetDependancyTreesRequest &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstWUGetDependancyTreesRequest &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	const char * getCluster();
	const char * getQueue();
	const char * getSnapshot();
	const char * getItems();
	const char * getTimeoutMilliSec();
	void setCluster(const char * val);
	void setQueue(const char * val);
	void setSnapshot(const char * val);
	void setItems(const char * val);
	void setTimeoutMilliSec(const char * val);
};

class CWUGetDependancyTreesResponse : public CSoapResponseBinding,
   implements IEspWUGetDependancyTreesResponse,
   implements IClientWUGetDependancyTreesResponse
{
protected:
	SoapStructArrayParam<IConstECLException, CECLException> m_Errors;
	SoapParamBinary m_DependancyTrees;
	StringBuffer m_DependancyTrees_mimetype;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CWUGetDependancyTreesResponse(const char *serviceName, const char *bcompat);

	CWUGetDependancyTreesResponse(const char *serviceName, IRpcMessageBinding *init=NULL);
	CWUGetDependancyTreesResponse(const char *serviceName, IRpcMessage* rpcmsg);
	CWUGetDependancyTreesResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "WUGetDependancyTreesResponse";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return true;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CWUGetDependancyTreesResponse &from);

	void copy(IConstWUGetDependancyTreesResponse &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstWUGetDependancyTreesResponse &ifrom, StringBuffer& buffer, bool keepRootTag=true);

	void appendContent(IEspContext* ctx, MemoryBuffer& buffer, StringBuffer &mimetype);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	virtual void setRedirectUrl(const char *url)
	{ CSoapResponseBinding::setRedirectUrl(url); }

	virtual const IMultiException& getExceptions()
	{ return CSoapResponseBinding::getExceptions(); }

	virtual int queryClientStatus()
	{ return CSoapResponseBinding::getRpcState(); }

	virtual void noteException(IException& e)
	{  CSoapResponseBinding::noteException(e); }

	IArrayOf<IConstECLException> & getErrors();
	const char *getDependancyTrees_mimetype();
	const MemoryBuffer & getDependancyTrees();
	void setErrors(IArrayOf<IEspECLException> &val);
 void setErrors(IArrayOf<IConstECLException> &val);
	void setDependancyTrees_mimetype(const char *  val);
	void setDependancyTrees(const MemoryBuffer & val);
};

class CWUListLocalFileRequiredRequest : public CSoapRequestBinding,
   implements IEspWUListLocalFileRequiredRequest,
   implements IClientWUListLocalFileRequiredRequest
{
protected:
	SoapStringParam m_Wuid;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CWUListLocalFileRequiredRequest(const char *serviceName, const char *bcompat);

	CWUListLocalFileRequiredRequest(const char *serviceName, IRpcMessageBinding *init=NULL);
	CWUListLocalFileRequiredRequest(const char *serviceName, IRpcMessage* rpcmsg);
	CWUListLocalFileRequiredRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	IEspClientRpcSettings &rpc(){return *static_cast<IEspClientRpcSettings*>(this);}


	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "WUListLocalFileRequiredRequest";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CWUListLocalFileRequiredRequest &from);

	void copy(IConstWUListLocalFileRequiredRequest &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstWUListLocalFileRequiredRequest &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	const char * getWuid();
	void setWuid(const char * val);
};

class CWUListLocalFileRequiredResponse : public CSoapResponseBinding,
   implements IEspWUListLocalFileRequiredResponse,
   implements IClientWUListLocalFileRequiredResponse
{
protected:
	SoapStructArrayParam<IConstLogicalFileUpload, CLogicalFileUpload> m_LocalFileUploads;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CWUListLocalFileRequiredResponse(const char *serviceName, const char *bcompat);

	CWUListLocalFileRequiredResponse(const char *serviceName, IRpcMessageBinding *init=NULL);
	CWUListLocalFileRequiredResponse(const char *serviceName, IRpcMessage* rpcmsg);
	CWUListLocalFileRequiredResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "WUListLocalFileRequiredResponse";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CWUListLocalFileRequiredResponse &from);

	void copy(IConstWUListLocalFileRequiredResponse &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstWUListLocalFileRequiredResponse &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	virtual void setRedirectUrl(const char *url)
	{ CSoapResponseBinding::setRedirectUrl(url); }

	virtual const IMultiException& getExceptions()
	{ return CSoapResponseBinding::getExceptions(); }

	virtual int queryClientStatus()
	{ return CSoapResponseBinding::getRpcState(); }

	virtual void noteException(IException& e)
	{  CSoapResponseBinding::noteException(e); }

	IArrayOf<IConstLogicalFileUpload> & getLocalFileUploads();
	void setLocalFileUploads(IArrayOf<IEspLogicalFileUpload> &val);
 void setLocalFileUploads(IArrayOf<IConstLogicalFileUpload> &val);
};

class CWUAddLocalFileToWorkunitRequest : public CSoapRequestBinding,
   implements IEspWUAddLocalFileToWorkunitRequest,
   implements IClientWUAddLocalFileToWorkunitRequest
{
protected:
	SoapStringParam m_Wuid;
	SoapStringParam m_Name;
	SoapStringParam m_Val;
	SoapStringParam m_DefVal;
	SoapParam<int> m_Type;
	SoapParam<int> m_Length;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CWUAddLocalFileToWorkunitRequest(const char *serviceName, const char *bcompat);

	CWUAddLocalFileToWorkunitRequest(const char *serviceName, IRpcMessageBinding *init=NULL);
	CWUAddLocalFileToWorkunitRequest(const char *serviceName, IRpcMessage* rpcmsg);
	CWUAddLocalFileToWorkunitRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	IEspClientRpcSettings &rpc(){return *static_cast<IEspClientRpcSettings*>(this);}


	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "WUAddLocalFileToWorkunitRequest";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CWUAddLocalFileToWorkunitRequest &from);

	void copy(IConstWUAddLocalFileToWorkunitRequest &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstWUAddLocalFileToWorkunitRequest &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	const char * getWuid();
	const char * getName();
	const char * getVal();
	const char * getDefVal();
	int getType();
	int getLength();
	void setWuid(const char * val);
	void setName(const char * val);
	void setVal(const char * val);
	void setDefVal(const char * val);
	void setType(int val);
	void setLength(int val);
};

class CWUAddLocalFileToWorkunitResponse : public CSoapResponseBinding,
   implements IEspWUAddLocalFileToWorkunitResponse,
   implements IClientWUAddLocalFileToWorkunitResponse
{
protected:
	SoapStringParam m_Wuid;
	SoapStringParam m_Name;
	SoapStringParam m_Result;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CWUAddLocalFileToWorkunitResponse(const char *serviceName, const char *bcompat);

	CWUAddLocalFileToWorkunitResponse(const char *serviceName, IRpcMessageBinding *init=NULL);
	CWUAddLocalFileToWorkunitResponse(const char *serviceName, IRpcMessage* rpcmsg);
	CWUAddLocalFileToWorkunitResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "WUAddLocalFileToWorkunitResponse";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CWUAddLocalFileToWorkunitResponse &from);

	void copy(IConstWUAddLocalFileToWorkunitResponse &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstWUAddLocalFileToWorkunitResponse &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	virtual void setRedirectUrl(const char *url)
	{ CSoapResponseBinding::setRedirectUrl(url); }

	virtual const IMultiException& getExceptions()
	{ return CSoapResponseBinding::getExceptions(); }

	virtual int queryClientStatus()
	{ return CSoapResponseBinding::getRpcState(); }

	virtual void noteException(IException& e)
	{  CSoapResponseBinding::noteException(e); }

	const char * getWuid();
	const char * getName();
	const char * getResult();
	void setWuid(const char * val);
	void setName(const char * val);
	void setResult(const char * val);
};

class CWUDebugRequest : public CSoapRequestBinding,
   implements IEspWUDebugRequest,
   implements IClientWUDebugRequest
{
protected:
	SoapStringParam m_Wuid;
	SoapStringParam m_Command;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CWUDebugRequest(const char *serviceName, const char *bcompat);

	CWUDebugRequest(const char *serviceName, IRpcMessageBinding *init=NULL);
	CWUDebugRequest(const char *serviceName, IRpcMessage* rpcmsg);
	CWUDebugRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	IEspClientRpcSettings &rpc(){return *static_cast<IEspClientRpcSettings*>(this);}


	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "WUDebugRequest";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CWUDebugRequest &from);

	void copy(IConstWUDebugRequest &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstWUDebugRequest &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	const char * getWuid();
	const char * getCommand();
	void setWuid(const char * val);
	void setCommand(const char * val);
};

class CWUDebugResponse : public CSoapResponseBinding,
   implements IEspWUDebugResponse,
   implements IClientWUDebugResponse
{
protected:
	SoapStringParam m_Result;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CWUDebugResponse(const char *serviceName, const char *bcompat);

	CWUDebugResponse(const char *serviceName, IRpcMessageBinding *init=NULL);
	CWUDebugResponse(const char *serviceName, IRpcMessage* rpcmsg);
	CWUDebugResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "WUDebugResponse";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CWUDebugResponse &from);

	void copy(IConstWUDebugResponse &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstWUDebugResponse &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	virtual void setRedirectUrl(const char *url)
	{ CSoapResponseBinding::setRedirectUrl(url); }

	virtual const IMultiException& getExceptions()
	{ return CSoapResponseBinding::getExceptions(); }

	virtual int queryClientStatus()
	{ return CSoapResponseBinding::getRpcState(); }

	virtual void noteException(IException& e)
	{  CSoapResponseBinding::noteException(e); }

	const char * getResult();
	void setResult(const char * val);
};

class CWUCopyLogicalFilesRequest : public CSoapRequestBinding,
   implements IEspWUCopyLogicalFilesRequest,
   implements IClientWUCopyLogicalFilesRequest
{
protected:
	SoapStringParam m_Wuid;
	SoapStringParam m_Cluster;
	SoapParam<bool> m_CopyLocal;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CWUCopyLogicalFilesRequest(const char *serviceName, const char *bcompat);

	CWUCopyLogicalFilesRequest(const char *serviceName, IRpcMessageBinding *init=NULL);
	CWUCopyLogicalFilesRequest(const char *serviceName, IRpcMessage* rpcmsg);
	CWUCopyLogicalFilesRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	IEspClientRpcSettings &rpc(){return *static_cast<IEspClientRpcSettings*>(this);}


	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "WUCopyLogicalFilesRequest";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CWUCopyLogicalFilesRequest &from);

	void copy(IConstWUCopyLogicalFilesRequest &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstWUCopyLogicalFilesRequest &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	const char * getWuid();
	const char * getCluster();
	bool getCopyLocal();
	void setWuid(const char * val);
	void setCluster(const char * val);
	void setCopyLocal(bool val);
};

class CWULogicalFileCopyInfo : public CSoapComplexType,
   implements IEspWULogicalFileCopyInfo,
   implements IClientWULogicalFileCopyInfo
{
protected:
	SoapParam<bool> m_IsIndex;
	SoapStringParam m_LogicalName;
	SoapStringParam m_DfuCopyWuid;
	SoapStringParam m_DfuCopyError;
	SoapStringArray m_Clusters;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CWULogicalFileCopyInfo(const char *serviceName, const char *bcompat);

	CWULogicalFileCopyInfo(const char *serviceName, IRpcMessageBinding *init=NULL);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "WULogicalFileCopyInfo";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CWULogicalFileCopyInfo &from);

	void copy(IConstWULogicalFileCopyInfo &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstWULogicalFileCopyInfo &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	bool getIsIndex();
	const char * getLogicalName();
	const char * getDfuCopyWuid();
	const char * getDfuCopyError();
	StringArray & getClusters();
	void setIsIndex(bool val);
	void setLogicalName(const char * val);
	void setDfuCopyWuid(const char * val);
	void setDfuCopyError(const char * val);
	void setClusters(StringArray &val);
};

class CWUCopyLogicalClusterFileSections : public CSoapComplexType,
   implements IEspWUCopyLogicalClusterFileSections,
   implements IClientWUCopyLogicalClusterFileSections
{
protected:
	SoapStringParam m_ClusterName;
	SoapStructArrayParam<IConstWULogicalFileCopyInfo, CWULogicalFileCopyInfo> m_OnCluster;
	SoapStructArrayParam<IConstWULogicalFileCopyInfo, CWULogicalFileCopyInfo> m_NotOnCluster;
	SoapStructArrayParam<IConstWULogicalFileCopyInfo, CWULogicalFileCopyInfo> m_Foreign;
	SoapStructArrayParam<IConstWULogicalFileCopyInfo, CWULogicalFileCopyInfo> m_NotFound;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CWUCopyLogicalClusterFileSections(const char *serviceName, const char *bcompat);

	CWUCopyLogicalClusterFileSections(const char *serviceName, IRpcMessageBinding *init=NULL);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "WUCopyLogicalClusterFileSections";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CWUCopyLogicalClusterFileSections &from);

	void copy(IConstWUCopyLogicalClusterFileSections &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstWUCopyLogicalClusterFileSections &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	const char * getClusterName();
	IArrayOf<IConstWULogicalFileCopyInfo> & getOnCluster();
	IArrayOf<IConstWULogicalFileCopyInfo> & getNotOnCluster();
	IArrayOf<IConstWULogicalFileCopyInfo> & getForeign();
	IArrayOf<IConstWULogicalFileCopyInfo> & getNotFound();
	void setClusterName(const char * val);
	void setOnCluster(IArrayOf<IEspWULogicalFileCopyInfo> &val);
 void setOnCluster(IArrayOf<IConstWULogicalFileCopyInfo> &val);
	void setNotOnCluster(IArrayOf<IEspWULogicalFileCopyInfo> &val);
 void setNotOnCluster(IArrayOf<IConstWULogicalFileCopyInfo> &val);
	void setForeign(IArrayOf<IEspWULogicalFileCopyInfo> &val);
 void setForeign(IArrayOf<IConstWULogicalFileCopyInfo> &val);
	void setNotFound(IArrayOf<IEspWULogicalFileCopyInfo> &val);
 void setNotFound(IArrayOf<IConstWULogicalFileCopyInfo> &val);
};

class CWUCopyLogicalFilesResponse : public CSoapResponseBinding,
   implements IEspWUCopyLogicalFilesResponse,
   implements IClientWUCopyLogicalFilesResponse
{
protected:
	SoapStringParam m_Wuid;
	SoapStructArrayParam<IConstWUCopyLogicalClusterFileSections, CWUCopyLogicalClusterFileSections> m_ClusterFiles;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CWUCopyLogicalFilesResponse(const char *serviceName, const char *bcompat);

	CWUCopyLogicalFilesResponse(const char *serviceName, IRpcMessageBinding *init=NULL);
	CWUCopyLogicalFilesResponse(const char *serviceName, IRpcMessage* rpcmsg);
	CWUCopyLogicalFilesResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "WUCopyLogicalFilesResponse";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CWUCopyLogicalFilesResponse &from);

	void copy(IConstWUCopyLogicalFilesResponse &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstWUCopyLogicalFilesResponse &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	virtual void setRedirectUrl(const char *url)
	{ CSoapResponseBinding::setRedirectUrl(url); }

	virtual const IMultiException& getExceptions()
	{ return CSoapResponseBinding::getExceptions(); }

	virtual int queryClientStatus()
	{ return CSoapResponseBinding::getRpcState(); }

	virtual void noteException(IException& e)
	{  CSoapResponseBinding::noteException(e); }

	const char * getWuid();
	IArrayOf<IConstWUCopyLogicalClusterFileSections> & getClusterFiles();
	void setWuid(const char * val);
	void setClusterFiles(IArrayOf<IEspWUCopyLogicalClusterFileSections> &val);
 void setClusterFiles(IArrayOf<IConstWUCopyLogicalClusterFileSections> &val);
};

class CWUPublishWorkunitRequest : public CSoapRequestBinding,
   implements IEspWUPublishWorkunitRequest,
   implements IClientWUPublishWorkunitRequest
{
protected:
	SoapStringParam m_Wuid;
	SoapStringParam m_Cluster;
	SoapStringParam m_JobName;
	SoapParam<int> m_Activate;
	SoapParam<bool> m_NotifyCluster;
	SoapParam<int> m_Wait;
	SoapParam<bool> m_NoReload;
	SoapParam<bool> m_UpdateWorkUnitName;
	SoapStringParam m_memoryLimit;
	SoapParam<unsigned int> m_TimeLimit;
	SoapParam<unsigned int> m_WarnTimeLimit;
	SoapStringParam m_Priority;
	SoapStringParam m_RemoteDali;
	SoapStringParam m_Comment;
	SoapParam<bool> m_DontCopyFiles;
	SoapStringParam m_SourceProcess;
	SoapParam<bool> m_AllowForeignFiles;
	SoapParam<bool> m_UpdateDfs;
	SoapParam<bool> m_UpdateSuperFiles;
	SoapParam<bool> m_UpdateCloneFrom;
	SoapParam<bool> m_AppendCluster;
	SoapParam<bool> m_IncludeFileErrors;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CWUPublishWorkunitRequest(const char *serviceName, const char *bcompat);

	CWUPublishWorkunitRequest(const char *serviceName, IRpcMessageBinding *init=NULL);
	CWUPublishWorkunitRequest(const char *serviceName, IRpcMessage* rpcmsg);
	CWUPublishWorkunitRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	IEspClientRpcSettings &rpc(){return *static_cast<IEspClientRpcSettings*>(this);}


	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "WUPublishWorkunitRequest";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CWUPublishWorkunitRequest &from);

	void copy(IConstWUPublishWorkunitRequest &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstWUPublishWorkunitRequest &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	const char * getWuid();
	const char * getCluster();
	const char * getJobName();
bool getActivate_isNull();
	int getActivate();
bool getNotifyCluster_isNull();
	bool getNotifyCluster();
bool getWait_isNull();
	int getWait();
bool getNoReload_isNull();
	bool getNoReload();
bool getUpdateWorkUnitName_isNull();
	bool getUpdateWorkUnitName();
	const char * getMemoryLimit();
bool getTimeLimit_isNull();
	unsigned int getTimeLimit();
bool getWarnTimeLimit_isNull();
	unsigned int getWarnTimeLimit();
	const char * getPriority();
	const char * getRemoteDali();
	const char * getComment();
bool getDontCopyFiles_isNull();
	bool getDontCopyFiles();
	const char * getSourceProcess();
bool getAllowForeignFiles_isNull();
	bool getAllowForeignFiles();
bool getUpdateDfs_isNull();
	bool getUpdateDfs();
bool getUpdateSuperFiles_isNull();
	bool getUpdateSuperFiles();
bool getUpdateCloneFrom_isNull();
	bool getUpdateCloneFrom();
bool getAppendCluster_isNull();
	bool getAppendCluster();
bool getIncludeFileErrors_isNull();
	bool getIncludeFileErrors();
	void setWuid(const char * val);
	void setCluster(const char * val);
	void setJobName(const char * val);
	void setActivate_null();
	void setActivate(int val);
	void setNotifyCluster_null();
	void setNotifyCluster(bool val);
	void setWait_null();
	void setWait(int val);
	void setNoReload_null();
	void setNoReload(bool val);
	void setUpdateWorkUnitName_null();
	void setUpdateWorkUnitName(bool val);
	void setMemoryLimit(const char * val);
	void setTimeLimit_null();
	void setTimeLimit(unsigned int val);
	void setWarnTimeLimit_null();
	void setWarnTimeLimit(unsigned int val);
	void setPriority(const char * val);
	void setRemoteDali(const char * val);
	void setComment(const char * val);
	void setDontCopyFiles_null();
	void setDontCopyFiles(bool val);
	void setSourceProcess(const char * val);
	void setAllowForeignFiles_null();
	void setAllowForeignFiles(bool val);
	void setUpdateDfs_null();
	void setUpdateDfs(bool val);
	void setUpdateSuperFiles_null();
	void setUpdateSuperFiles(bool val);
	void setUpdateCloneFrom_null();
	void setUpdateCloneFrom(bool val);
	void setAppendCluster_null();
	void setAppendCluster(bool val);
	void setIncludeFileErrors_null();
	void setIncludeFileErrors(bool val);
};

class CWUPublishWorkunitResponse : public CSoapResponseBinding,
   implements IEspWUPublishWorkunitResponse,
   implements IClientWUPublishWorkunitResponse
{
protected:
	SoapStringParam m_Wuid;
	SoapStringParam m_Result;
	SoapStringParam m_QuerySet;
	SoapStringParam m_QueryName;
	SoapStringParam m_QueryId;
	SoapParam<bool> m_ReloadFailed;
	SoapParam<bool> m_Suspended;
	SoapStringParam m_ErrorMessage;
	SoapStructArrayParam<IConstWUCopyLogicalClusterFileSections, CWUCopyLogicalClusterFileSections> m_ClusterFiles;
	SoapStructArrayParam<IConstLogicalFileError, CLogicalFileError> m_FileErrors;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CWUPublishWorkunitResponse(const char *serviceName, const char *bcompat);

	CWUPublishWorkunitResponse(const char *serviceName, IRpcMessageBinding *init=NULL);
	CWUPublishWorkunitResponse(const char *serviceName, IRpcMessage* rpcmsg);
	CWUPublishWorkunitResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "WUPublishWorkunitResponse";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CWUPublishWorkunitResponse &from);

	void copy(IConstWUPublishWorkunitResponse &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstWUPublishWorkunitResponse &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	virtual void setRedirectUrl(const char *url)
	{ CSoapResponseBinding::setRedirectUrl(url); }

	virtual const IMultiException& getExceptions()
	{ return CSoapResponseBinding::getExceptions(); }

	virtual int queryClientStatus()
	{ return CSoapResponseBinding::getRpcState(); }

	virtual void noteException(IException& e)
	{  CSoapResponseBinding::noteException(e); }

	const char * getWuid();
	const char * getResult();
	const char * getQuerySet();
	const char * getQueryName();
	const char * getQueryId();
	bool getReloadFailed();
	bool getSuspended();
	const char * getErrorMessage();
	IArrayOf<IConstWUCopyLogicalClusterFileSections> & getClusterFiles();
	IArrayOf<IConstLogicalFileError> & getFileErrors();
	void setWuid(const char * val);
	void setResult(const char * val);
	void setQuerySet(const char * val);
	void setQueryName(const char * val);
	void setQueryId(const char * val);
	void setReloadFailed(bool val);
	void setSuspended(bool val);
	void setErrorMessage(const char * val);
	void setClusterFiles(IArrayOf<IEspWUCopyLogicalClusterFileSections> &val);
 void setClusterFiles(IArrayOf<IConstWUCopyLogicalClusterFileSections> &val);
	void setFileErrors(IArrayOf<IEspLogicalFileError> &val);
 void setFileErrors(IArrayOf<IConstLogicalFileError> &val);
};

class CWUQueryConfigRequest : public CSoapRequestBinding,
   implements IEspWUQueryConfigRequest,
   implements IClientWUQueryConfigRequest
{
protected:
	SoapStringParam m_Target;
	SoapStringParam m_QueryId;
	SoapParam<int> m_Wait;
	SoapParam<bool> m_NoReload;
	SoapStringParam m_memoryLimit;
	SoapParam<unsigned int> m_TimeLimit;
	SoapParam<unsigned int> m_WarnTimeLimit;
	SoapStringParam m_Priority;
	SoapStringParam m_Comment;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CWUQueryConfigRequest(const char *serviceName, const char *bcompat);

	CWUQueryConfigRequest(const char *serviceName, IRpcMessageBinding *init=NULL);
	CWUQueryConfigRequest(const char *serviceName, IRpcMessage* rpcmsg);
	CWUQueryConfigRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	IEspClientRpcSettings &rpc(){return *static_cast<IEspClientRpcSettings*>(this);}


	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "WUQueryConfigRequest";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CWUQueryConfigRequest &from);

	void copy(IConstWUQueryConfigRequest &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstWUQueryConfigRequest &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	const char * getTarget();
	const char * getQueryId();
bool getWait_isNull();
	int getWait();
bool getNoReload_isNull();
	bool getNoReload();
	const char * getMemoryLimit();
bool getTimeLimit_isNull();
	unsigned int getTimeLimit();
bool getWarnTimeLimit_isNull();
	unsigned int getWarnTimeLimit();
	const char * getPriority();
	const char * getComment();
	void setTarget(const char * val);
	void setQueryId(const char * val);
	void setWait_null();
	void setWait(int val);
	void setNoReload_null();
	void setNoReload(bool val);
	void setMemoryLimit(const char * val);
	void setTimeLimit_null();
	void setTimeLimit(unsigned int val);
	void setWarnTimeLimit_null();
	void setWarnTimeLimit(unsigned int val);
	void setPriority(const char * val);
	void setComment(const char * val);
};

class CWUQueryConfigResult : public CSoapComplexType,
   implements IEspWUQueryConfigResult,
   implements IClientWUQueryConfigResult
{
protected:
	SoapStringParam m_QueryId;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CWUQueryConfigResult(const char *serviceName, const char *bcompat);

	CWUQueryConfigResult(const char *serviceName, IRpcMessageBinding *init=NULL);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "WUQueryConfigResult";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CWUQueryConfigResult &from);

	void copy(IConstWUQueryConfigResult &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstWUQueryConfigResult &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	const char * getQueryId();
	void setQueryId(const char * val);
};

class CWUQueryConfigResponse : public CSoapResponseBinding,
   implements IEspWUQueryConfigResponse,
   implements IClientWUQueryConfigResponse
{
protected:
	SoapParam<bool> m_ReloadFailed;
	SoapStructArrayParam<IConstWUQueryConfigResult, CWUQueryConfigResult> m_Results;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CWUQueryConfigResponse(const char *serviceName, const char *bcompat);

	CWUQueryConfigResponse(const char *serviceName, IRpcMessageBinding *init=NULL);
	CWUQueryConfigResponse(const char *serviceName, IRpcMessage* rpcmsg);
	CWUQueryConfigResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "WUQueryConfigResponse";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CWUQueryConfigResponse &from);

	void copy(IConstWUQueryConfigResponse &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstWUQueryConfigResponse &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	virtual void setRedirectUrl(const char *url)
	{ CSoapResponseBinding::setRedirectUrl(url); }

	virtual const IMultiException& getExceptions()
	{ return CSoapResponseBinding::getExceptions(); }

	virtual int queryClientStatus()
	{ return CSoapResponseBinding::getRpcState(); }

	virtual void noteException(IException& e)
	{  CSoapResponseBinding::noteException(e); }

	bool getReloadFailed();
	IArrayOf<IConstWUQueryConfigResult> & getResults();
	void setReloadFailed(bool val);
	void setResults(IArrayOf<IEspWUQueryConfigResult> &val);
 void setResults(IArrayOf<IConstWUQueryConfigResult> &val);
};

class CQuerySet : public CSoapComplexType,
   implements IEspQuerySet,
   implements IClientQuerySet
{
protected:
	SoapStringParam m_QuerySetName;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CQuerySet(const char *serviceName, const char *bcompat);

	CQuerySet(const char *serviceName, IRpcMessageBinding *init=NULL);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "QuerySet";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CQuerySet &from);

	void copy(IConstQuerySet &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstQuerySet &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	const char * getQuerySetName();
	void setQuerySetName(const char * val);
};

class CWUQuerysetsRequest : public CSoapRequestBinding,
   implements IEspWUQuerysetsRequest,
   implements IClientWUQuerysetsRequest
{
protected:
	SoapParam<bool> m_test;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CWUQuerysetsRequest(const char *serviceName, const char *bcompat);

	CWUQuerysetsRequest(const char *serviceName, IRpcMessageBinding *init=NULL);
	CWUQuerysetsRequest(const char *serviceName, IRpcMessage* rpcmsg);
	CWUQuerysetsRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	IEspClientRpcSettings &rpc(){return *static_cast<IEspClientRpcSettings*>(this);}


	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "WUQuerysetsRequest";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CWUQuerysetsRequest &from);

	void copy(IConstWUQuerysetsRequest &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstWUQuerysetsRequest &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	bool getTest();
	void setTest(bool val);
};

class CWUQuerysetsResponse : public CSoapResponseBinding,
   implements IEspWUQuerysetsResponse,
   implements IClientWUQuerysetsResponse
{
protected:
	SoapStructArrayParam<IConstQuerySet, CQuerySet> m_Querysets;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CWUQuerysetsResponse(const char *serviceName, const char *bcompat);

	CWUQuerysetsResponse(const char *serviceName, IRpcMessageBinding *init=NULL);
	CWUQuerysetsResponse(const char *serviceName, IRpcMessage* rpcmsg);
	CWUQuerysetsResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "WUQuerysetsResponse";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CWUQuerysetsResponse &from);

	void copy(IConstWUQuerysetsResponse &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstWUQuerysetsResponse &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	virtual void setRedirectUrl(const char *url)
	{ CSoapResponseBinding::setRedirectUrl(url); }

	virtual const IMultiException& getExceptions()
	{ return CSoapResponseBinding::getExceptions(); }

	virtual int queryClientStatus()
	{ return CSoapResponseBinding::getRpcState(); }

	virtual void noteException(IException& e)
	{  CSoapResponseBinding::noteException(e); }

	IArrayOf<IConstQuerySet> & getQuerysets();
	void setQuerysets(IArrayOf<IEspQuerySet> &val);
 void setQuerysets(IArrayOf<IConstQuerySet> &val);
};

class CClusterQueryState : public CSoapComplexType,
   implements IEspClusterQueryState,
   implements IClientClusterQueryState
{
protected:
	SoapStringParam m_Cluster;
	SoapStringParam m_State;
	SoapStringParam m_Errors;
	SoapParam<bool> m_MixedNodeStates;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CClusterQueryState(const char *serviceName, const char *bcompat);

	CClusterQueryState(const char *serviceName, IRpcMessageBinding *init=NULL);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "ClusterQueryState";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CClusterQueryState &from);

	void copy(IConstClusterQueryState &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstClusterQueryState &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	const char * getCluster();
	const char * getState();
	const char * getErrors();
	bool getMixedNodeStates();
	void setCluster(const char * val);
	void setState(const char * val);
	void setErrors(const char * val);
	void setMixedNodeStates(bool val);
};

class CQuerySetQuery : public CSoapComplexType,
   implements IEspQuerySetQuery,
   implements IClientQuerySetQuery
{
protected:
	SoapStringParam m_Id;
	SoapStringParam m_Name;
	SoapStringParam m_Wuid;
	SoapStringParam m_Dll;
	SoapParam<bool> m_Suspended;
	SoapStructArrayParam<IConstClusterQueryState, CClusterQueryState> m_Clusters;
	SoapStringParam m_memoryLimit;
	SoapParam<unsigned int> m_timeLimit;
	SoapParam<unsigned int> m_warnTimeLimit;
	SoapStringParam m_priority;
	SoapStringParam m_Comment;
	SoapStringParam m_QuerySetId;
	SoapParam<bool> m_IsLibrary;
	SoapParam<bool> m_Activated;
	SoapStringParam m_PublishedBy;
	SoapStringParam m_snapshot;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CQuerySetQuery(const char *serviceName, const char *bcompat);

	CQuerySetQuery(const char *serviceName, IRpcMessageBinding *init=NULL);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "QuerySetQuery";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CQuerySetQuery &from);

	void copy(IConstQuerySetQuery &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstQuerySetQuery &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	const char * getId();
	const char * getName();
	const char * getWuid();
	const char * getDll();
bool getSuspended_isNull();
	bool getSuspended();
	IArrayOf<IConstClusterQueryState> & getClusters();
	const char * getMemoryLimit();
bool getTimeLimit_isNull();
	unsigned int getTimeLimit();
bool getWarnTimeLimit_isNull();
	unsigned int getWarnTimeLimit();
	const char * getPriority();
	const char * getComment();
	const char * getQuerySetId();
bool getIsLibrary_isNull();
	bool getIsLibrary();
bool getActivated_isNull();
	bool getActivated();
	const char * getPublishedBy();
	const char * getSnapshot();
	void setId(const char * val);
	void setName(const char * val);
	void setWuid(const char * val);
	void setDll(const char * val);
	void setSuspended_null();
	void setSuspended(bool val);
	void setClusters(IArrayOf<IEspClusterQueryState> &val);
 void setClusters(IArrayOf<IConstClusterQueryState> &val);
	void setMemoryLimit(const char * val);
	void setTimeLimit_null();
	void setTimeLimit(unsigned int val);
	void setWarnTimeLimit_null();
	void setWarnTimeLimit(unsigned int val);
	void setPriority(const char * val);
	void setComment(const char * val);
	void setQuerySetId(const char * val);
	void setIsLibrary_null();
	void setIsLibrary(bool val);
	void setActivated_null();
	void setActivated(bool val);
	void setPublishedBy(const char * val);
	void setSnapshot(const char * val);
};

class CQuerySetAlias : public CSoapComplexType,
   implements IEspQuerySetAlias,
   implements IClientQuerySetAlias
{
protected:
	SoapStringParam m_Id;
	SoapStringParam m_Name;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CQuerySetAlias(const char *serviceName, const char *bcompat);

	CQuerySetAlias(const char *serviceName, IRpcMessageBinding *init=NULL);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "QuerySetAlias";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CQuerySetAlias &from);

	void copy(IConstQuerySetAlias &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstQuerySetAlias &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	const char * getId();
	const char * getName();
	void setId(const char * val);
	void setName(const char * val);
};

class CXWUQuerySetFilterType : public SoapEnumParamNew<CWUQuerySetFilterType>
{
public:
	CXWUQuerySetFilterType(nilBehavior nilB) : SoapEnumParamNew<CWUQuerySetFilterType>(nilB)
	{ doInit(); }
	CXWUQuerySetFilterType(CWUQuerySetFilterType defvalue_) : SoapEnumParamNew<CWUQuerySetFilterType>(defvalue_)
	{ doInit(); }
	CXWUQuerySetFilterType(const char* defvalue_) : SoapEnumParamNew<CWUQuerySetFilterType>()
	{ doInit(); setDefaultValue(defvalue_); }
	static  void getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash &added)
	{ getSharedInstance().getXsdDefinitionInternal(context,request,schema,added); }
	static void getMapInfo(IMapInfo& info, BoolHash& added) { getSharedInstance().getMapInfo_(info,added); }

	static const char* stringOf(CWUQuerySetFilterType val) { return getSharedInstance().toString(val); }

	static CWUQuerySetFilterType enumOf(const char* s) { return getSharedInstance().toEnum(s); }

static const char *queryXsdElementName() { return "WUQuerySetFilterType"; }
private:
	static CXWUQuerySetFilterType& getSharedInstance() { static CXWUQuerySetFilterType instance(nilIgnore); return instance; }
	void getMapInfo_(IMapInfo& info, BoolHash& added) {  }
	void getXsdDefinitionInternal(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash &added)
	{ getXsdDefinition_(context,request,schema,added,NULL); }
	void doInit()
	{
		static const char* inits[] = {"All","Id","Name","Alias","Status",NULL};
		init("WUQuerySetFilterType","string",inits);
	}
};

class CWUQuerySetDetailsRequest : public CSoapRequestBinding,
   implements IEspWUQuerySetDetailsRequest,
   implements IClientWUQuerySetDetailsRequest
{
protected:
	SoapStringParam m_QuerySetName;
	SoapStringParam m_Filter;
	SoapStringParam m_ClusterName;
	CXWUQuerySetFilterType m_FilterType;
	SoapParam<bool> m_CheckAllNodes;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CWUQuerySetDetailsRequest(const char *serviceName, const char *bcompat);

	CWUQuerySetDetailsRequest(const char *serviceName, IRpcMessageBinding *init=NULL);
	CWUQuerySetDetailsRequest(const char *serviceName, IRpcMessage* rpcmsg);
	CWUQuerySetDetailsRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	IEspClientRpcSettings &rpc(){return *static_cast<IEspClientRpcSettings*>(this);}


	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "WUQuerySetDetailsRequest";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CWUQuerySetDetailsRequest &from);

	void copy(IConstWUQuerySetDetailsRequest &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstWUQuerySetDetailsRequest &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	const char * getQuerySetName();
	const char * getFilter();
	const char * getClusterName();
	CWUQuerySetFilterType getFilterType();
	const char* getFilterTypeAsString();
	bool getCheckAllNodes();
	void setQuerySetName(const char * val);
	void setFilter(const char * val);
	void setClusterName(const char * val);
	void setFilterType(CWUQuerySetFilterType val);
void setFilterType(const char* val);
	void setCheckAllNodes(bool val);
};

class CWUQuerySetDetailsResponse : public CSoapResponseBinding,
   implements IEspWUQuerySetDetailsResponse,
   implements IClientWUQuerySetDetailsResponse
{
protected:
	SoapStringParam m_QuerySetName;
	SoapStructArrayParam<IConstQuerySetQuery, CQuerySetQuery> m_QuerysetQueries;
	SoapStructArrayParam<IConstQuerySetAlias, CQuerySetAlias> m_QuerysetAliases;
	SoapStringParam m_ClusterName;
	SoapStringParam m_Filter;
	CXWUQuerySetFilterType m_FilterType;
	SoapStringArray m_ClusterNames;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CWUQuerySetDetailsResponse(const char *serviceName, const char *bcompat);

	CWUQuerySetDetailsResponse(const char *serviceName, IRpcMessageBinding *init=NULL);
	CWUQuerySetDetailsResponse(const char *serviceName, IRpcMessage* rpcmsg);
	CWUQuerySetDetailsResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "WUQuerySetDetailsResponse";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CWUQuerySetDetailsResponse &from);

	void copy(IConstWUQuerySetDetailsResponse &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstWUQuerySetDetailsResponse &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	virtual void setRedirectUrl(const char *url)
	{ CSoapResponseBinding::setRedirectUrl(url); }

	virtual const IMultiException& getExceptions()
	{ return CSoapResponseBinding::getExceptions(); }

	virtual int queryClientStatus()
	{ return CSoapResponseBinding::getRpcState(); }

	virtual void noteException(IException& e)
	{  CSoapResponseBinding::noteException(e); }

	const char * getQuerySetName();
	IArrayOf<IConstQuerySetQuery> & getQuerysetQueries();
	IArrayOf<IConstQuerySetAlias> & getQuerysetAliases();
	const char * getClusterName();
	const char * getFilter();
	CWUQuerySetFilterType getFilterType();
	const char* getFilterTypeAsString();
	StringArray & getClusterNames();
	void setQuerySetName(const char * val);
	void setQuerysetQueries(IArrayOf<IEspQuerySetQuery> &val);
 void setQuerysetQueries(IArrayOf<IConstQuerySetQuery> &val);
	void setQuerysetAliases(IArrayOf<IEspQuerySetAlias> &val);
 void setQuerysetAliases(IArrayOf<IConstQuerySetAlias> &val);
	void setClusterName(const char * val);
	void setFilter(const char * val);
	void setFilterType(CWUQuerySetFilterType val);
void setFilterType(const char* val);
	void setClusterNames(StringArray &val);
};

class CWUListQueriesRequest : public CSoapRequestBinding,
   implements IEspWUListQueriesRequest,
   implements IClientWUListQueriesRequest
{
protected:
	SoapStringParam m_QuerySetName;
	SoapStringParam m_ClusterName;
	SoapStringParam m_LibraryName;
	SoapParam<__int64> m_MemoryLimitLow;
	SoapParam<__int64> m_MemoryLimitHigh;
	SoapParam<unsigned int> m_TimeLimitLow;
	SoapParam<unsigned int> m_TimeLimitHigh;
	SoapParam<unsigned int> m_WarnTimeLimitLow;
	SoapParam<unsigned int> m_WarnTimeLimitHigh;
	SoapParam<unsigned int> m_PriorityLow;
	SoapParam<unsigned int> m_PriorityHigh;
	SoapParam<bool> m_Activated;
	SoapParam<bool> m_SuspendedByUser;
	SoapStringParam m_WUID;
	SoapStringParam m_QueryID;
	SoapStringParam m_QueryName;
	SoapStringParam m_PublishedBy;
	SoapParam<unsigned int> m_PageSize;
	SoapParam<unsigned int> m_PageStartFrom;
	SoapStringParam m_Sortby;
	SoapParam<bool> m_Descending;
	SoapParam<__int64> m_CacheHint;
	SoapStringParam m_FileName;
	SoapParam<bool> m_CheckAllNodes;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CWUListQueriesRequest(const char *serviceName, const char *bcompat);

	CWUListQueriesRequest(const char *serviceName, IRpcMessageBinding *init=NULL);
	CWUListQueriesRequest(const char *serviceName, IRpcMessage* rpcmsg);
	CWUListQueriesRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	IEspClientRpcSettings &rpc(){return *static_cast<IEspClientRpcSettings*>(this);}


	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "WUListQueriesRequest";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CWUListQueriesRequest &from);

	void copy(IConstWUListQueriesRequest &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstWUListQueriesRequest &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	const char * getQuerySetName();
	const char * getClusterName();
	const char * getLibraryName();
bool getMemoryLimitLow_isNull();
	__int64 getMemoryLimitLow();
bool getMemoryLimitHigh_isNull();
	__int64 getMemoryLimitHigh();
bool getTimeLimitLow_isNull();
	unsigned int getTimeLimitLow();
bool getTimeLimitHigh_isNull();
	unsigned int getTimeLimitHigh();
bool getWarnTimeLimitLow_isNull();
	unsigned int getWarnTimeLimitLow();
bool getWarnTimeLimitHigh_isNull();
	unsigned int getWarnTimeLimitHigh();
bool getPriorityLow_isNull();
	unsigned int getPriorityLow();
bool getPriorityHigh_isNull();
	unsigned int getPriorityHigh();
bool getActivated_isNull();
	bool getActivated();
bool getSuspendedByUser_isNull();
	bool getSuspendedByUser();
	const char * getWUID();
	const char * getQueryID();
	const char * getQueryName();
	const char * getPublishedBy();
bool getPageSize_isNull();
	unsigned int getPageSize();
bool getPageStartFrom_isNull();
	unsigned int getPageStartFrom();
	const char * getSortby();
bool getDescending_isNull();
	bool getDescending();
bool getCacheHint_isNull();
	__int64 getCacheHint();
	const char * getFileName();
bool getCheckAllNodes_isNull();
	bool getCheckAllNodes();
	void setQuerySetName(const char * val);
	void setClusterName(const char * val);
	void setLibraryName(const char * val);
	void setMemoryLimitLow_null();
	void setMemoryLimitLow(__int64 val);
	void setMemoryLimitHigh_null();
	void setMemoryLimitHigh(__int64 val);
	void setTimeLimitLow_null();
	void setTimeLimitLow(unsigned int val);
	void setTimeLimitHigh_null();
	void setTimeLimitHigh(unsigned int val);
	void setWarnTimeLimitLow_null();
	void setWarnTimeLimitLow(unsigned int val);
	void setWarnTimeLimitHigh_null();
	void setWarnTimeLimitHigh(unsigned int val);
	void setPriorityLow_null();
	void setPriorityLow(unsigned int val);
	void setPriorityHigh_null();
	void setPriorityHigh(unsigned int val);
	void setActivated_null();
	void setActivated(bool val);
	void setSuspendedByUser_null();
	void setSuspendedByUser(bool val);
	void setWUID(const char * val);
	void setQueryID(const char * val);
	void setQueryName(const char * val);
	void setPublishedBy(const char * val);
	void setPageSize_null();
	void setPageSize(unsigned int val);
	void setPageStartFrom_null();
	void setPageStartFrom(unsigned int val);
	void setSortby(const char * val);
	void setDescending_null();
	void setDescending(bool val);
	void setCacheHint_null();
	void setCacheHint(__int64 val);
	void setFileName(const char * val);
	void setCheckAllNodes_null();
	void setCheckAllNodes(bool val);
};

class CWUListQueriesResponse : public CSoapResponseBinding,
   implements IEspWUListQueriesResponse,
   implements IClientWUListQueriesResponse
{
protected:
	SoapParam<int> m_NumberOfQueries;
	SoapParam<__int64> m_CacheHint;
	SoapStructArrayParam<IConstQuerySetQuery, CQuerySetQuery> m_QuerysetQueries;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CWUListQueriesResponse(const char *serviceName, const char *bcompat);

	CWUListQueriesResponse(const char *serviceName, IRpcMessageBinding *init=NULL);
	CWUListQueriesResponse(const char *serviceName, IRpcMessage* rpcmsg);
	CWUListQueriesResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "WUListQueriesResponse";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CWUListQueriesResponse &from);

	void copy(IConstWUListQueriesResponse &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstWUListQueriesResponse &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	virtual void setRedirectUrl(const char *url)
	{ CSoapResponseBinding::setRedirectUrl(url); }

	virtual const IMultiException& getExceptions()
	{ return CSoapResponseBinding::getExceptions(); }

	virtual int queryClientStatus()
	{ return CSoapResponseBinding::getRpcState(); }

	virtual void noteException(IException& e)
	{  CSoapResponseBinding::noteException(e); }

	int getNumberOfQueries();
	__int64 getCacheHint();
	IArrayOf<IConstQuerySetQuery> & getQuerysetQueries();
	void setNumberOfQueries(int val);
	void setCacheHint(__int64 val);
	void setQuerysetQueries(IArrayOf<IEspQuerySetQuery> &val);
 void setQuerysetQueries(IArrayOf<IConstQuerySetQuery> &val);
};

class CWUListQueriesUsingFileRequest : public CSoapRequestBinding,
   implements IEspWUListQueriesUsingFileRequest,
   implements IClientWUListQueriesUsingFileRequest
{
protected:
	SoapStringParam m_Target;
	SoapStringParam m_Process;
	SoapStringParam m_FileName;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CWUListQueriesUsingFileRequest(const char *serviceName, const char *bcompat);

	CWUListQueriesUsingFileRequest(const char *serviceName, IRpcMessageBinding *init=NULL);
	CWUListQueriesUsingFileRequest(const char *serviceName, IRpcMessage* rpcmsg);
	CWUListQueriesUsingFileRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	IEspClientRpcSettings &rpc(){return *static_cast<IEspClientRpcSettings*>(this);}


	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "WUListQueriesUsingFileRequest";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CWUListQueriesUsingFileRequest &from);

	void copy(IConstWUListQueriesUsingFileRequest &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstWUListQueriesUsingFileRequest &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	const char * getTarget();
	const char * getProcess();
	const char * getFileName();
	void setTarget(const char * val);
	void setProcess(const char * val);
	void setFileName(const char * val);
};

class CQueryUsingFile : public CSoapComplexType,
   implements IEspQueryUsingFile,
   implements IClientQueryUsingFile
{
protected:
	SoapStringParam m_Id;
	SoapStringParam m_Package;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CQueryUsingFile(const char *serviceName, const char *bcompat);

	CQueryUsingFile(const char *serviceName, IRpcMessageBinding *init=NULL);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "QueryUsingFile";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CQueryUsingFile &from);

	void copy(IConstQueryUsingFile &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstQueryUsingFile &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	const char * getId();
	const char * getPackage();
	void setId(const char * val);
	void setPackage(const char * val);
};

class CTargetQueriesUsingFile : public CSoapComplexType,
   implements IEspTargetQueriesUsingFile,
   implements IClientTargetQueriesUsingFile
{
protected:
	SoapStringParam m_Target;
	SoapStringParam m_PackageMap;
	SoapStructArrayParam<IConstQueryUsingFile, CQueryUsingFile> m_Queries;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CTargetQueriesUsingFile(const char *serviceName, const char *bcompat);

	CTargetQueriesUsingFile(const char *serviceName, IRpcMessageBinding *init=NULL);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "TargetQueriesUsingFile";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CTargetQueriesUsingFile &from);

	void copy(IConstTargetQueriesUsingFile &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstTargetQueriesUsingFile &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	const char * getTarget();
	const char * getPackageMap();
	IArrayOf<IConstQueryUsingFile> & getQueries();
	void setTarget(const char * val);
	void setPackageMap(const char * val);
	void setQueries(IArrayOf<IEspQueryUsingFile> &val);
 void setQueries(IArrayOf<IConstQueryUsingFile> &val);
};

class CWUListQueriesUsingFileResponse : public CSoapResponseBinding,
   implements IEspWUListQueriesUsingFileResponse,
   implements IClientWUListQueriesUsingFileResponse
{
protected:
	SoapStringParam m_Process;
	SoapStringParam m_FileName;
	SoapStructArrayParam<IConstTargetQueriesUsingFile, CTargetQueriesUsingFile> m_Targets;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CWUListQueriesUsingFileResponse(const char *serviceName, const char *bcompat);

	CWUListQueriesUsingFileResponse(const char *serviceName, IRpcMessageBinding *init=NULL);
	CWUListQueriesUsingFileResponse(const char *serviceName, IRpcMessage* rpcmsg);
	CWUListQueriesUsingFileResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "WUListQueriesUsingFileResponse";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CWUListQueriesUsingFileResponse &from);

	void copy(IConstWUListQueriesUsingFileResponse &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstWUListQueriesUsingFileResponse &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	virtual void setRedirectUrl(const char *url)
	{ CSoapResponseBinding::setRedirectUrl(url); }

	virtual const IMultiException& getExceptions()
	{ return CSoapResponseBinding::getExceptions(); }

	virtual int queryClientStatus()
	{ return CSoapResponseBinding::getRpcState(); }

	virtual void noteException(IException& e)
	{  CSoapResponseBinding::noteException(e); }

	const char * getProcess();
	const char * getFileName();
	IArrayOf<IConstTargetQueriesUsingFile> & getTargets();
	void setProcess(const char * val);
	void setFileName(const char * val);
	void setTargets(IArrayOf<IEspTargetQueriesUsingFile> &val);
 void setTargets(IArrayOf<IConstTargetQueriesUsingFile> &val);
};

class CWUQueryFilesRequest : public CSoapRequestBinding,
   implements IEspWUQueryFilesRequest,
   implements IClientWUQueryFilesRequest
{
protected:
	SoapStringParam m_Target;
	SoapStringParam m_QueryId;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CWUQueryFilesRequest(const char *serviceName, const char *bcompat);

	CWUQueryFilesRequest(const char *serviceName, IRpcMessageBinding *init=NULL);
	CWUQueryFilesRequest(const char *serviceName, IRpcMessage* rpcmsg);
	CWUQueryFilesRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	IEspClientRpcSettings &rpc(){return *static_cast<IEspClientRpcSettings*>(this);}


	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "WUQueryFilesRequest";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CWUQueryFilesRequest &from);

	void copy(IConstWUQueryFilesRequest &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstWUQueryFilesRequest &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	const char * getTarget();
	const char * getQueryId();
	void setTarget(const char * val);
	void setQueryId(const char * val);
};

class CFileUsedByQuery : public CSoapComplexType,
   implements IEspFileUsedByQuery,
   implements IClientFileUsedByQuery
{
protected:
	SoapStringParam m_FileName;
	SoapParam<__int64> m_FileSize;
	SoapParam<unsigned int> m_NumberOfParts;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CFileUsedByQuery(const char *serviceName, const char *bcompat);

	CFileUsedByQuery(const char *serviceName, IRpcMessageBinding *init=NULL);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "FileUsedByQuery";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CFileUsedByQuery &from);

	void copy(IConstFileUsedByQuery &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstFileUsedByQuery &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	const char * getFileName();
bool getFileSize_isNull();
	__int64 getFileSize();
bool getNumberOfParts_isNull();
	unsigned int getNumberOfParts();
	void setFileName(const char * val);
	void setFileSize_null();
	void setFileSize(__int64 val);
	void setNumberOfParts_null();
	void setNumberOfParts(unsigned int val);
};

class CWUQueryFilesResponse : public CSoapResponseBinding,
   implements IEspWUQueryFilesResponse,
   implements IClientWUQueryFilesResponse
{
protected:
	SoapStructArrayParam<IConstFileUsedByQuery, CFileUsedByQuery> m_Files;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CWUQueryFilesResponse(const char *serviceName, const char *bcompat);

	CWUQueryFilesResponse(const char *serviceName, IRpcMessageBinding *init=NULL);
	CWUQueryFilesResponse(const char *serviceName, IRpcMessage* rpcmsg);
	CWUQueryFilesResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "WUQueryFilesResponse";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CWUQueryFilesResponse &from);

	void copy(IConstWUQueryFilesResponse &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstWUQueryFilesResponse &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	virtual void setRedirectUrl(const char *url)
	{ CSoapResponseBinding::setRedirectUrl(url); }

	virtual const IMultiException& getExceptions()
	{ return CSoapResponseBinding::getExceptions(); }

	virtual int queryClientStatus()
	{ return CSoapResponseBinding::getRpcState(); }

	virtual void noteException(IException& e)
	{  CSoapResponseBinding::noteException(e); }

	IArrayOf<IConstFileUsedByQuery> & getFiles();
	void setFiles(IArrayOf<IEspFileUsedByQuery> &val);
 void setFiles(IArrayOf<IConstFileUsedByQuery> &val);
};

class CWUQueryDetailsRequest : public CSoapRequestBinding,
   implements IEspWUQueryDetailsRequest,
   implements IClientWUQueryDetailsRequest
{
protected:
	SoapStringParam m_QueryId;
	SoapStringParam m_QuerySet;
	SoapParam<bool> m_IncludeStateOnClusters;
	SoapParam<bool> m_IncludeSuperFiles;
	SoapParam<bool> m_IncludeWsEclAddresses;
	SoapParam<bool> m_CheckAllNodes;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CWUQueryDetailsRequest(const char *serviceName, const char *bcompat);

	CWUQueryDetailsRequest(const char *serviceName, IRpcMessageBinding *init=NULL);
	CWUQueryDetailsRequest(const char *serviceName, IRpcMessage* rpcmsg);
	CWUQueryDetailsRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	IEspClientRpcSettings &rpc(){return *static_cast<IEspClientRpcSettings*>(this);}


	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "WUQueryDetailsRequest";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CWUQueryDetailsRequest &from);

	void copy(IConstWUQueryDetailsRequest &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstWUQueryDetailsRequest &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	const char * getQueryId();
	const char * getQuerySet();
	bool getIncludeStateOnClusters();
	bool getIncludeSuperFiles();
	bool getIncludeWsEclAddresses();
	bool getCheckAllNodes();
	void setQueryId(const char * val);
	void setQuerySet(const char * val);
	void setIncludeStateOnClusters(bool val);
	void setIncludeSuperFiles(bool val);
	void setIncludeWsEclAddresses(bool val);
	void setCheckAllNodes(bool val);
};

class CQuerySuperFile : public CSoapComplexType,
   implements IEspQuerySuperFile,
   implements IClientQuerySuperFile
{
protected:
	SoapStringParam m_Name;
	SoapStringArray m_SubFiles;
	SoapStructArrayParam<IConstQuerySuperFile, CQuerySuperFile> m_SuperFiles;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CQuerySuperFile(const char *serviceName, const char *bcompat);

	CQuerySuperFile(const char *serviceName, IRpcMessageBinding *init=NULL);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "QuerySuperFile";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CQuerySuperFile &from);

	void copy(IConstQuerySuperFile &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstQuerySuperFile &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	const char * getName();
	StringArray & getSubFiles();
	IArrayOf<IConstQuerySuperFile> & getSuperFiles();
	void setName(const char * val);
	void setSubFiles(StringArray &val);
	void setSuperFiles(IArrayOf<IEspQuerySuperFile> &val);
 void setSuperFiles(IArrayOf<IConstQuerySuperFile> &val);
};

class CWUQueryDetailsResponse : public CSoapResponseBinding,
   implements IEspWUQueryDetailsResponse,
   implements IClientWUQueryDetailsResponse
{
protected:
	SoapStringParam m_QueryId;
	SoapStringParam m_QuerySet;
	SoapStringParam m_QueryName;
	SoapStringParam m_Wuid;
	SoapStringParam m_Dll;
	SoapParam<bool> m_Suspended;
	SoapParam<bool> m_Activated;
	SoapStringParam m_SuspendedBy;
	SoapStructArrayParam<IConstClusterQueryState, CClusterQueryState> m_Clusters;
	SoapStringParam m_PublishedBy;
	SoapStringParam m_Comment;
	SoapStringArray m_LogicalFiles;
	SoapStructArrayParam<IConstQuerySuperFile, CQuerySuperFile> m_SuperFiles;
	SoapParam<bool> m_IsLibrary;
	SoapStringParam m_Priority;
	SoapStringParam m_WUSnapShot;
	SoapStringParam m_CompileTime;
	SoapStringArray m_LibrariesUsed;
	SoapParam<int> m_CountGraphs;
	SoapStringArray m_GraphIds;
	SoapParam<int> m_ResourceURLCount;
	SoapStringArray m_WsEclAddresses;
	SoapStructArrayParam<IConstECLGraph, CECLGraph> m_WUGraphs;
	SoapStructArrayParam<IConstECLTimer, CECLTimer> m_WUTimers;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CWUQueryDetailsResponse(const char *serviceName, const char *bcompat);

	CWUQueryDetailsResponse(const char *serviceName, IRpcMessageBinding *init=NULL);
	CWUQueryDetailsResponse(const char *serviceName, IRpcMessage* rpcmsg);
	CWUQueryDetailsResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "WUQueryDetailsResponse";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CWUQueryDetailsResponse &from);

	void copy(IConstWUQueryDetailsResponse &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstWUQueryDetailsResponse &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	virtual void setRedirectUrl(const char *url)
	{ CSoapResponseBinding::setRedirectUrl(url); }

	virtual const IMultiException& getExceptions()
	{ return CSoapResponseBinding::getExceptions(); }

	virtual int queryClientStatus()
	{ return CSoapResponseBinding::getRpcState(); }

	virtual void noteException(IException& e)
	{  CSoapResponseBinding::noteException(e); }

	const char * getQueryId();
	const char * getQuerySet();
	const char * getQueryName();
	const char * getWuid();
	const char * getDll();
	bool getSuspended();
	bool getActivated();
	const char * getSuspendedBy();
	IArrayOf<IConstClusterQueryState> & getClusters();
	const char * getPublishedBy();
	const char * getComment();
	StringArray & getLogicalFiles();
	IArrayOf<IConstQuerySuperFile> & getSuperFiles();
	bool getIsLibrary();
	const char * getPriority();
	const char * getWUSnapShot();
	const char * getCompileTime();
	StringArray & getLibrariesUsed();
	int getCountGraphs();
	StringArray & getGraphIds();
	int getResourceURLCount();
	StringArray & getWsEclAddresses();
	IArrayOf<IConstECLGraph> & getWUGraphs();
	IArrayOf<IConstECLTimer> & getWUTimers();
	void setQueryId(const char * val);
	void setQuerySet(const char * val);
	void setQueryName(const char * val);
	void setWuid(const char * val);
	void setDll(const char * val);
	void setSuspended(bool val);
	void setActivated(bool val);
	void setSuspendedBy(const char * val);
	void setClusters(IArrayOf<IEspClusterQueryState> &val);
 void setClusters(IArrayOf<IConstClusterQueryState> &val);
	void setPublishedBy(const char * val);
	void setComment(const char * val);
	void setLogicalFiles(StringArray &val);
	void setSuperFiles(IArrayOf<IEspQuerySuperFile> &val);
 void setSuperFiles(IArrayOf<IConstQuerySuperFile> &val);
	void setIsLibrary(bool val);
	void setPriority(const char * val);
	void setWUSnapShot(const char * val);
	void setCompileTime(const char * val);
	void setLibrariesUsed(StringArray &val);
	void setCountGraphs(int val);
	void setGraphIds(StringArray &val);
	void setResourceURLCount(int val);
	void setWsEclAddresses(StringArray &val);
	void setWUGraphs(IArrayOf<IEspECLGraph> &val);
 void setWUGraphs(IArrayOf<IConstECLGraph> &val);
	void setWUTimers(IArrayOf<IEspECLTimer> &val);
 void setWUTimers(IArrayOf<IConstECLTimer> &val);
};

class CWUMultiQuerySetDetailsRequest : public CSoapRequestBinding,
   implements IEspWUMultiQuerySetDetailsRequest,
   implements IClientWUMultiQuerySetDetailsRequest
{
protected:
	SoapStringParam m_ClusterName;
	SoapStringParam m_QuerySetName;
	SoapStringParam m_Filter;
	CXWUQuerySetFilterType m_FilterType;
	SoapParam<bool> m_CheckAllNodes;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CWUMultiQuerySetDetailsRequest(const char *serviceName, const char *bcompat);

	CWUMultiQuerySetDetailsRequest(const char *serviceName, IRpcMessageBinding *init=NULL);
	CWUMultiQuerySetDetailsRequest(const char *serviceName, IRpcMessage* rpcmsg);
	CWUMultiQuerySetDetailsRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	IEspClientRpcSettings &rpc(){return *static_cast<IEspClientRpcSettings*>(this);}


	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "WUMultiQuerySetDetailsRequest";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CWUMultiQuerySetDetailsRequest &from);

	void copy(IConstWUMultiQuerySetDetailsRequest &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstWUMultiQuerySetDetailsRequest &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	const char * getClusterName();
	const char * getQuerySetName();
	const char * getFilter();
	CWUQuerySetFilterType getFilterType();
	const char* getFilterTypeAsString();
	bool getCheckAllNodes();
	void setClusterName(const char * val);
	void setQuerySetName(const char * val);
	void setFilter(const char * val);
	void setFilterType(CWUQuerySetFilterType val);
void setFilterType(const char* val);
	void setCheckAllNodes(bool val);
};

class CWUQuerySetDetail : public CSoapComplexType,
   implements IEspWUQuerySetDetail,
   implements IClientWUQuerySetDetail
{
protected:
	SoapStringParam m_QuerySetName;
	SoapStructArrayParam<IConstQuerySetQuery, CQuerySetQuery> m_Queries;
	SoapStructArrayParam<IConstQuerySetAlias, CQuerySetAlias> m_Aliases;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CWUQuerySetDetail(const char *serviceName, const char *bcompat);

	CWUQuerySetDetail(const char *serviceName, IRpcMessageBinding *init=NULL);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "WUQuerySetDetail";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CWUQuerySetDetail &from);

	void copy(IConstWUQuerySetDetail &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstWUQuerySetDetail &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	const char * getQuerySetName();
	IArrayOf<IConstQuerySetQuery> & getQueries();
	IArrayOf<IConstQuerySetAlias> & getAliases();
	void setQuerySetName(const char * val);
	void setQueries(IArrayOf<IEspQuerySetQuery> &val);
 void setQueries(IArrayOf<IConstQuerySetQuery> &val);
	void setAliases(IArrayOf<IEspQuerySetAlias> &val);
 void setAliases(IArrayOf<IConstQuerySetAlias> &val);
};

class CWUMultiQuerySetDetailsResponse : public CSoapResponseBinding,
   implements IEspWUMultiQuerySetDetailsResponse,
   implements IClientWUMultiQuerySetDetailsResponse
{
protected:
	SoapStringParam m_ClusterName;
	SoapStructArrayParam<IConstWUQuerySetDetail, CWUQuerySetDetail> m_Querysets;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CWUMultiQuerySetDetailsResponse(const char *serviceName, const char *bcompat);

	CWUMultiQuerySetDetailsResponse(const char *serviceName, IRpcMessageBinding *init=NULL);
	CWUMultiQuerySetDetailsResponse(const char *serviceName, IRpcMessage* rpcmsg);
	CWUMultiQuerySetDetailsResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "WUMultiQuerySetDetailsResponse";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CWUMultiQuerySetDetailsResponse &from);

	void copy(IConstWUMultiQuerySetDetailsResponse &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstWUMultiQuerySetDetailsResponse &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	virtual void setRedirectUrl(const char *url)
	{ CSoapResponseBinding::setRedirectUrl(url); }

	virtual const IMultiException& getExceptions()
	{ return CSoapResponseBinding::getExceptions(); }

	virtual int queryClientStatus()
	{ return CSoapResponseBinding::getRpcState(); }

	virtual void noteException(IException& e)
	{  CSoapResponseBinding::noteException(e); }

	const char * getClusterName();
	IArrayOf<IConstWUQuerySetDetail> & getQuerysets();
	void setClusterName(const char * val);
	void setQuerysets(IArrayOf<IEspWUQuerySetDetail> &val);
 void setQuerysets(IArrayOf<IConstWUQuerySetDetail> &val);
};

class CWUQuerysetExportRequest : public CSoapRequestBinding,
   implements IEspWUQuerysetExportRequest,
   implements IClientWUQuerysetExportRequest
{
protected:
	SoapStringParam m_Target;
	SoapParam<bool> m_Compress;
	SoapParam<bool> m_ActiveOnly;
	SoapParam<bool> m_Protect;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CWUQuerysetExportRequest(const char *serviceName, const char *bcompat);

	CWUQuerysetExportRequest(const char *serviceName, IRpcMessageBinding *init=NULL);
	CWUQuerysetExportRequest(const char *serviceName, IRpcMessage* rpcmsg);
	CWUQuerysetExportRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	IEspClientRpcSettings &rpc(){return *static_cast<IEspClientRpcSettings*>(this);}


	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "WUQuerysetExportRequest";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CWUQuerysetExportRequest &from);

	void copy(IConstWUQuerysetExportRequest &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstWUQuerysetExportRequest &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	const char * getTarget();
	bool getCompress();
	bool getActiveOnly();
	bool getProtect();
	void setTarget(const char * val);
	void setCompress(bool val);
	void setActiveOnly(bool val);
	void setProtect(bool val);
};

class CWUQuerysetExportResponse : public CSoapResponseBinding,
   implements IEspWUQuerysetExportResponse,
   implements IClientWUQuerysetExportResponse
{
protected:
	SoapStringParam m_Target;
	SoapParam<bool> m_Compressed;
	SoapParamBinary m_Data;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CWUQuerysetExportResponse(const char *serviceName, const char *bcompat);

	CWUQuerysetExportResponse(const char *serviceName, IRpcMessageBinding *init=NULL);
	CWUQuerysetExportResponse(const char *serviceName, IRpcMessage* rpcmsg);
	CWUQuerysetExportResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "WUQuerysetExportResponse";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CWUQuerysetExportResponse &from);

	void copy(IConstWUQuerysetExportResponse &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstWUQuerysetExportResponse &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	virtual void setRedirectUrl(const char *url)
	{ CSoapResponseBinding::setRedirectUrl(url); }

	virtual const IMultiException& getExceptions()
	{ return CSoapResponseBinding::getExceptions(); }

	virtual int queryClientStatus()
	{ return CSoapResponseBinding::getRpcState(); }

	virtual void noteException(IException& e)
	{  CSoapResponseBinding::noteException(e); }

	const char * getTarget();
	bool getCompressed();
	const MemoryBuffer & getData();
	void setTarget(const char * val);
	void setCompressed(bool val);
	void setData(const MemoryBuffer & val);
};

class CXQuerysetImportActivation : public SoapEnumParamNew<CQuerysetImportActivation>
{
public:
	CXQuerysetImportActivation(nilBehavior nilB) : SoapEnumParamNew<CQuerysetImportActivation>(nilB)
	{ doInit(); }
	CXQuerysetImportActivation(CQuerysetImportActivation defvalue_) : SoapEnumParamNew<CQuerysetImportActivation>(defvalue_)
	{ doInit(); }
	CXQuerysetImportActivation(const char* defvalue_) : SoapEnumParamNew<CQuerysetImportActivation>()
	{ doInit(); setDefaultValue(defvalue_); }
	static  void getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash &added)
	{ getSharedInstance().getXsdDefinitionInternal(context,request,schema,added); }
	static void getMapInfo(IMapInfo& info, BoolHash& added) { getSharedInstance().getMapInfo_(info,added); }

	static const char* stringOf(CQuerysetImportActivation val) { return getSharedInstance().toString(val); }

	static CQuerysetImportActivation enumOf(const char* s) { return getSharedInstance().toEnum(s); }

static const char *queryXsdElementName() { return "QuerysetImportActivation"; }
private:
	static CXQuerysetImportActivation& getSharedInstance() { static CXQuerysetImportActivation instance(nilIgnore); return instance; }
	void getMapInfo_(IMapInfo& info, BoolHash& added) {  }
	void getXsdDefinitionInternal(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash &added)
	{ getXsdDefinition_(context,request,schema,added,NULL); }
	void doInit()
	{
		static const char* inits[] = {"None","ActivateImportedActive",NULL};
		init("QuerysetImportActivation","string",inits);
	}
};

class CWUQuerysetImportRequest : public CSoapRequestBinding,
   implements IEspWUQuerysetImportRequest,
   implements IClientWUQuerysetImportRequest
{
protected:
	SoapStringParam m_Target;
	SoapStringParam m_QueryMask;
	SoapParam<bool> m_Replace;
	SoapParam<bool> m_ActiveOnly;
	CXQuerysetImportActivation m_Activation;
	SoapParam<bool> m_Compressed;
	SoapParamBinary m_Data;
	SoapParam<bool> m_AllowForeignFiles;
	SoapStringParam m_DfsServer;
	SoapParam<bool> m_CopyFiles;
	SoapParam<bool> m_OverwriteDfs;
	SoapStringParam m_SourceProcess;
	SoapParam<bool> m_UpdateSuperFiles;
	SoapParam<bool> m_UpdateCloneFrom;
	SoapParam<bool> m_AppendCluster;
	SoapParam<bool> m_IncludeFileErrors;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CWUQuerysetImportRequest(const char *serviceName, const char *bcompat);

	CWUQuerysetImportRequest(const char *serviceName, IRpcMessageBinding *init=NULL);
	CWUQuerysetImportRequest(const char *serviceName, IRpcMessage* rpcmsg);
	CWUQuerysetImportRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	IEspClientRpcSettings &rpc(){return *static_cast<IEspClientRpcSettings*>(this);}


	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "WUQuerysetImportRequest";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CWUQuerysetImportRequest &from);

	void copy(IConstWUQuerysetImportRequest &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstWUQuerysetImportRequest &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	const char * getTarget();
	const char * getQueryMask();
	bool getReplace();
	bool getActiveOnly();
	CQuerysetImportActivation getActivation();
	const char* getActivationAsString();
	bool getCompressed();
	const MemoryBuffer & getData();
	bool getAllowForeignFiles();
	const char * getDfsServer();
	bool getCopyFiles();
	bool getOverwriteDfs();
	const char * getSourceProcess();
	bool getUpdateSuperFiles();
	bool getUpdateCloneFrom();
	bool getAppendCluster();
	bool getIncludeFileErrors();
	void setTarget(const char * val);
	void setQueryMask(const char * val);
	void setReplace(bool val);
	void setActiveOnly(bool val);
	void setActivation(CQuerysetImportActivation val);
void setActivation(const char* val);
	void setCompressed(bool val);
	void setData(const MemoryBuffer & val);
	void setAllowForeignFiles(bool val);
	void setDfsServer(const char * val);
	void setCopyFiles(bool val);
	void setOverwriteDfs(bool val);
	void setSourceProcess(const char * val);
	void setUpdateSuperFiles(bool val);
	void setUpdateCloneFrom(bool val);
	void setAppendCluster(bool val);
	void setIncludeFileErrors(bool val);
};

class CWUQuerysetImportResponse : public CSoapResponseBinding,
   implements IEspWUQuerysetImportResponse,
   implements IClientWUQuerysetImportResponse
{
protected:
	SoapStringParam m_Target;
	SoapParam<bool> m_ClearedExisting;
	SoapParam<bool> m_Success;
	SoapStringArray m_ImportedQueries;
	SoapStringArray m_ExistingQueries;
	SoapStringArray m_MissingWuids;
	SoapStructArrayParam<IConstLogicalFileError, CLogicalFileError> m_FileErrors;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CWUQuerysetImportResponse(const char *serviceName, const char *bcompat);

	CWUQuerysetImportResponse(const char *serviceName, IRpcMessageBinding *init=NULL);
	CWUQuerysetImportResponse(const char *serviceName, IRpcMessage* rpcmsg);
	CWUQuerysetImportResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "WUQuerysetImportResponse";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CWUQuerysetImportResponse &from);

	void copy(IConstWUQuerysetImportResponse &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstWUQuerysetImportResponse &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	virtual void setRedirectUrl(const char *url)
	{ CSoapResponseBinding::setRedirectUrl(url); }

	virtual const IMultiException& getExceptions()
	{ return CSoapResponseBinding::getExceptions(); }

	virtual int queryClientStatus()
	{ return CSoapResponseBinding::getRpcState(); }

	virtual void noteException(IException& e)
	{  CSoapResponseBinding::noteException(e); }

	const char * getTarget();
	bool getClearedExisting();
	bool getSuccess();
	StringArray & getImportedQueries();
	StringArray & getExistingQueries();
	StringArray & getMissingWuids();
	IArrayOf<IConstLogicalFileError> & getFileErrors();
	void setTarget(const char * val);
	void setClearedExisting(bool val);
	void setSuccess(bool val);
	void setImportedQueries(StringArray &val);
	void setExistingQueries(StringArray &val);
	void setMissingWuids(StringArray &val);
	void setFileErrors(IArrayOf<IEspLogicalFileError> &val);
 void setFileErrors(IArrayOf<IConstLogicalFileError> &val);
};

class CWUUpdateQueryEntryRequest : public CSoapRequestBinding,
   implements IEspWUUpdateQueryEntryRequest,
   implements IClientWUUpdateQueryEntryRequest
{
protected:
	SoapStringParam m_QuerySet;
	SoapStringParam m_QueryId;
	SoapStringParam m_Comment;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CWUUpdateQueryEntryRequest(const char *serviceName, const char *bcompat);

	CWUUpdateQueryEntryRequest(const char *serviceName, IRpcMessageBinding *init=NULL);
	CWUUpdateQueryEntryRequest(const char *serviceName, IRpcMessage* rpcmsg);
	CWUUpdateQueryEntryRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	IEspClientRpcSettings &rpc(){return *static_cast<IEspClientRpcSettings*>(this);}


	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "WUUpdateQueryEntryRequest";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CWUUpdateQueryEntryRequest &from);

	void copy(IConstWUUpdateQueryEntryRequest &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstWUUpdateQueryEntryRequest &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	const char * getQuerySet();
	const char * getQueryId();
	const char * getComment();
	void setQuerySet(const char * val);
	void setQueryId(const char * val);
	void setComment(const char * val);
};

class CWUUpdateQueryEntryResponse : public CSoapResponseBinding,
   implements IEspWUUpdateQueryEntryResponse,
   implements IClientWUUpdateQueryEntryResponse
{
protected:

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CWUUpdateQueryEntryResponse(const char *serviceName, const char *bcompat);

	CWUUpdateQueryEntryResponse(const char *serviceName, IRpcMessageBinding *init=NULL);
	CWUUpdateQueryEntryResponse(const char *serviceName, IRpcMessage* rpcmsg);
	CWUUpdateQueryEntryResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "WUUpdateQueryEntryResponse";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CWUUpdateQueryEntryResponse &from);

	void copy(IConstWUUpdateQueryEntryResponse &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstWUUpdateQueryEntryResponse &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	virtual void setRedirectUrl(const char *url)
	{ CSoapResponseBinding::setRedirectUrl(url); }

	virtual const IMultiException& getExceptions()
	{ return CSoapResponseBinding::getExceptions(); }

	virtual int queryClientStatus()
	{ return CSoapResponseBinding::getRpcState(); }

	virtual void noteException(IException& e)
	{  CSoapResponseBinding::noteException(e); }

};

class CXQuerySetQueryActionTypes : public SoapEnumParamNew<CQuerySetQueryActionTypes>
{
public:
	CXQuerySetQueryActionTypes(nilBehavior nilB) : SoapEnumParamNew<CQuerySetQueryActionTypes>(nilB)
	{ doInit(); }
	CXQuerySetQueryActionTypes(CQuerySetQueryActionTypes defvalue_) : SoapEnumParamNew<CQuerySetQueryActionTypes>(defvalue_)
	{ doInit(); }
	CXQuerySetQueryActionTypes(const char* defvalue_) : SoapEnumParamNew<CQuerySetQueryActionTypes>()
	{ doInit(); setDefaultValue(defvalue_); }
	static  void getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash &added)
	{ getSharedInstance().getXsdDefinitionInternal(context,request,schema,added); }
	static void getMapInfo(IMapInfo& info, BoolHash& added) { getSharedInstance().getMapInfo_(info,added); }

	static const char* stringOf(CQuerySetQueryActionTypes val) { return getSharedInstance().toString(val); }

	static CQuerySetQueryActionTypes enumOf(const char* s) { return getSharedInstance().toEnum(s); }

static const char *queryXsdElementName() { return "QuerySetQueryActionTypes"; }
private:
	static CXQuerySetQueryActionTypes& getSharedInstance() { static CXQuerySetQueryActionTypes instance(nilIgnore); return instance; }
	void getMapInfo_(IMapInfo& info, BoolHash& added) {  }
	void getXsdDefinitionInternal(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash &added)
	{ getXsdDefinition_(context,request,schema,added,NULL); }
	void doInit()
	{
		static const char* inits[] = {"Suspend","Unsuspend","ToggleSuspend","Activate","Delete","RemoveAllAliases","ResetQueryStats",NULL};
		init("QuerySetQueryActionTypes","string",inits);
	}
};

class CQuerySetQueryClientState : public CSoapComplexType,
   implements IEspQuerySetQueryClientState,
   implements IClientQuerySetQueryClientState
{
protected:
	SoapStringParam m_Suspended;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CQuerySetQueryClientState(const char *serviceName, const char *bcompat);

	CQuerySetQueryClientState(const char *serviceName, IRpcMessageBinding *init=NULL);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "QuerySetQueryClientState";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CQuerySetQueryClientState &from);

	void copy(IConstQuerySetQueryClientState &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstQuerySetQueryClientState &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	const char * getSuspended();
	void setSuspended(const char * val);
};

class CQuerySetQueryActionItem : public CSoapComplexType,
   implements IEspQuerySetQueryActionItem,
   implements IClientQuerySetQueryActionItem
{
protected:
	SoapStringParam m_QueryId;
	SoapStruct<CQuerySetQueryClientState, IConstQuerySetQueryClientState> m_ClientState;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CQuerySetQueryActionItem(const char *serviceName, const char *bcompat);

	CQuerySetQueryActionItem(const char *serviceName, IRpcMessageBinding *init=NULL);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "QuerySetQueryActionItem";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CQuerySetQueryActionItem &from);

	void copy(IConstQuerySetQueryActionItem &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstQuerySetQueryActionItem &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	const char * getQueryId();
	IConstQuerySetQueryClientState & getClientState();
	void setQueryId(const char * val);
	IEspQuerySetQueryClientState & updateClientState();
	void setClientState(IConstQuerySetQueryClientState &ifrom);
};

class CWUQuerySetQueryActionRequest : public CSoapRequestBinding,
   implements IEspWUQuerySetQueryActionRequest,
   implements IClientWUQuerySetQueryActionRequest
{
protected:
	CXQuerySetQueryActionTypes m_Action;
	SoapStringParam m_QuerySetName;
	SoapStructArrayParam<IConstQuerySetQueryActionItem, CQuerySetQueryActionItem> m_Queries;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CWUQuerySetQueryActionRequest(const char *serviceName, const char *bcompat);

	CWUQuerySetQueryActionRequest(const char *serviceName, IRpcMessageBinding *init=NULL);
	CWUQuerySetQueryActionRequest(const char *serviceName, IRpcMessage* rpcmsg);
	CWUQuerySetQueryActionRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	IEspClientRpcSettings &rpc(){return *static_cast<IEspClientRpcSettings*>(this);}


	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "WUQuerySetQueryActionRequest";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CWUQuerySetQueryActionRequest &from);

	void copy(IConstWUQuerySetQueryActionRequest &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstWUQuerySetQueryActionRequest &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	CQuerySetQueryActionTypes getAction();
	const char* getActionAsString();
	const char * getQuerySetName();
	IArrayOf<IConstQuerySetQueryActionItem> & getQueries();
	void setAction(CQuerySetQueryActionTypes val);
void setAction(const char* val);
	void setQuerySetName(const char * val);
	void setQueries(IArrayOf<IEspQuerySetQueryActionItem> &val);
 void setQueries(IArrayOf<IConstQuerySetQueryActionItem> &val);
};

class CQuerySetQueryActionResult : public CSoapComplexType,
   implements IEspQuerySetQueryActionResult,
   implements IClientQuerySetQueryActionResult
{
protected:
	SoapStringParam m_QueryId;
	SoapParam<bool> m_Suspended;
	SoapParam<bool> m_Success;
	SoapParam<int> m_Code;
	SoapStringParam m_Message;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CQuerySetQueryActionResult(const char *serviceName, const char *bcompat);

	CQuerySetQueryActionResult(const char *serviceName, IRpcMessageBinding *init=NULL);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "QuerySetQueryActionResult";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CQuerySetQueryActionResult &from);

	void copy(IConstQuerySetQueryActionResult &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstQuerySetQueryActionResult &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	const char * getQueryId();
	bool getSuspended();
	bool getSuccess();
	int getCode();
	const char * getMessage();
	void setQueryId(const char * val);
	void setSuspended(bool val);
	void setSuccess(bool val);
	void setCode(int val);
	void setMessage(const char * val);
};

class CWUQuerySetQueryActionResponse : public CSoapResponseBinding,
   implements IEspWUQuerySetQueryActionResponse,
   implements IClientWUQuerySetQueryActionResponse
{
protected:
	CXQuerySetQueryActionTypes m_Action;
	SoapStringParam m_QuerySetName;
	SoapStructArrayParam<IConstQuerySetQueryActionResult, CQuerySetQueryActionResult> m_Results;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CWUQuerySetQueryActionResponse(const char *serviceName, const char *bcompat);

	CWUQuerySetQueryActionResponse(const char *serviceName, IRpcMessageBinding *init=NULL);
	CWUQuerySetQueryActionResponse(const char *serviceName, IRpcMessage* rpcmsg);
	CWUQuerySetQueryActionResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "WUQuerySetQueryActionResponse";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CWUQuerySetQueryActionResponse &from);

	void copy(IConstWUQuerySetQueryActionResponse &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstWUQuerySetQueryActionResponse &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	virtual void setRedirectUrl(const char *url)
	{ CSoapResponseBinding::setRedirectUrl(url); }

	virtual const IMultiException& getExceptions()
	{ return CSoapResponseBinding::getExceptions(); }

	virtual int queryClientStatus()
	{ return CSoapResponseBinding::getRpcState(); }

	virtual void noteException(IException& e)
	{  CSoapResponseBinding::noteException(e); }

	CQuerySetQueryActionTypes getAction();
	const char* getActionAsString();
	const char * getQuerySetName();
	IArrayOf<IConstQuerySetQueryActionResult> & getResults();
	void setAction(CQuerySetQueryActionTypes val);
void setAction(const char* val);
	void setQuerySetName(const char * val);
	void setResults(IArrayOf<IEspQuerySetQueryActionResult> &val);
 void setResults(IArrayOf<IConstQuerySetQueryActionResult> &val);
};

class CXQuerySetAliasActionTypes : public SoapEnumParamNew<CQuerySetAliasActionTypes>
{
public:
	CXQuerySetAliasActionTypes(nilBehavior nilB) : SoapEnumParamNew<CQuerySetAliasActionTypes>(nilB)
	{ doInit(); }
	CXQuerySetAliasActionTypes(CQuerySetAliasActionTypes defvalue_) : SoapEnumParamNew<CQuerySetAliasActionTypes>(defvalue_)
	{ doInit(); }
	CXQuerySetAliasActionTypes(const char* defvalue_) : SoapEnumParamNew<CQuerySetAliasActionTypes>()
	{ doInit(); setDefaultValue(defvalue_); }
	static  void getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash &added)
	{ getSharedInstance().getXsdDefinitionInternal(context,request,schema,added); }
	static void getMapInfo(IMapInfo& info, BoolHash& added) { getSharedInstance().getMapInfo_(info,added); }

	static const char* stringOf(CQuerySetAliasActionTypes val) { return getSharedInstance().toString(val); }

	static CQuerySetAliasActionTypes enumOf(const char* s) { return getSharedInstance().toEnum(s); }

static const char *queryXsdElementName() { return "QuerySetAliasActionTypes"; }
private:
	static CXQuerySetAliasActionTypes& getSharedInstance() { static CXQuerySetAliasActionTypes instance(nilIgnore); return instance; }
	void getMapInfo_(IMapInfo& info, BoolHash& added) {  }
	void getXsdDefinitionInternal(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash &added)
	{ getXsdDefinition_(context,request,schema,added,NULL); }
	void doInit()
	{
		static const char* inits[] = {"Deactivate",NULL};
		init("QuerySetAliasActionTypes","string",inits);
	}
};

class CQuerySetAliasActionItem : public CSoapComplexType,
   implements IEspQuerySetAliasActionItem,
   implements IClientQuerySetAliasActionItem
{
protected:
	SoapStringParam m_Name;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CQuerySetAliasActionItem(const char *serviceName, const char *bcompat);

	CQuerySetAliasActionItem(const char *serviceName, IRpcMessageBinding *init=NULL);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "QuerySetAliasActionItem";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CQuerySetAliasActionItem &from);

	void copy(IConstQuerySetAliasActionItem &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstQuerySetAliasActionItem &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	const char * getName();
	void setName(const char * val);
};

class CWUQuerySetAliasActionRequest : public CSoapRequestBinding,
   implements IEspWUQuerySetAliasActionRequest,
   implements IClientWUQuerySetAliasActionRequest
{
protected:
	CXQuerySetAliasActionTypes m_Action;
	SoapStringParam m_QuerySetName;
	SoapStructArrayParam<IConstQuerySetAliasActionItem, CQuerySetAliasActionItem> m_Aliases;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CWUQuerySetAliasActionRequest(const char *serviceName, const char *bcompat);

	CWUQuerySetAliasActionRequest(const char *serviceName, IRpcMessageBinding *init=NULL);
	CWUQuerySetAliasActionRequest(const char *serviceName, IRpcMessage* rpcmsg);
	CWUQuerySetAliasActionRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	IEspClientRpcSettings &rpc(){return *static_cast<IEspClientRpcSettings*>(this);}


	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "WUQuerySetAliasActionRequest";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CWUQuerySetAliasActionRequest &from);

	void copy(IConstWUQuerySetAliasActionRequest &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstWUQuerySetAliasActionRequest &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	CQuerySetAliasActionTypes getAction();
	const char* getActionAsString();
	const char * getQuerySetName();
	IArrayOf<IConstQuerySetAliasActionItem> & getAliases();
	void setAction(CQuerySetAliasActionTypes val);
void setAction(const char* val);
	void setQuerySetName(const char * val);
	void setAliases(IArrayOf<IEspQuerySetAliasActionItem> &val);
 void setAliases(IArrayOf<IConstQuerySetAliasActionItem> &val);
};

class CQuerySetAliasActionResult : public CSoapComplexType,
   implements IEspQuerySetAliasActionResult,
   implements IClientQuerySetAliasActionResult
{
protected:
	SoapStringParam m_Name;
	SoapParam<bool> m_Success;
	SoapParam<int> m_Code;
	SoapStringParam m_Message;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CQuerySetAliasActionResult(const char *serviceName, const char *bcompat);

	CQuerySetAliasActionResult(const char *serviceName, IRpcMessageBinding *init=NULL);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "QuerySetAliasActionResult";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CQuerySetAliasActionResult &from);

	void copy(IConstQuerySetAliasActionResult &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstQuerySetAliasActionResult &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	const char * getName();
	bool getSuccess();
	int getCode();
	const char * getMessage();
	void setName(const char * val);
	void setSuccess(bool val);
	void setCode(int val);
	void setMessage(const char * val);
};

class CWUQuerySetAliasActionResponse : public CSoapResponseBinding,
   implements IEspWUQuerySetAliasActionResponse,
   implements IClientWUQuerySetAliasActionResponse
{
protected:
	CXQuerySetAliasActionTypes m_Action;
	SoapStringParam m_QuerySetName;
	SoapStructArrayParam<IConstQuerySetAliasActionResult, CQuerySetAliasActionResult> m_Results;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CWUQuerySetAliasActionResponse(const char *serviceName, const char *bcompat);

	CWUQuerySetAliasActionResponse(const char *serviceName, IRpcMessageBinding *init=NULL);
	CWUQuerySetAliasActionResponse(const char *serviceName, IRpcMessage* rpcmsg);
	CWUQuerySetAliasActionResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "WUQuerySetAliasActionResponse";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CWUQuerySetAliasActionResponse &from);

	void copy(IConstWUQuerySetAliasActionResponse &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstWUQuerySetAliasActionResponse &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	virtual void setRedirectUrl(const char *url)
	{ CSoapResponseBinding::setRedirectUrl(url); }

	virtual const IMultiException& getExceptions()
	{ return CSoapResponseBinding::getExceptions(); }

	virtual int queryClientStatus()
	{ return CSoapResponseBinding::getRpcState(); }

	virtual void noteException(IException& e)
	{  CSoapResponseBinding::noteException(e); }

	CQuerySetAliasActionTypes getAction();
	const char* getActionAsString();
	const char * getQuerySetName();
	IArrayOf<IConstQuerySetAliasActionResult> & getResults();
	void setAction(CQuerySetAliasActionTypes val);
void setAction(const char* val);
	void setQuerySetName(const char * val);
	void setResults(IArrayOf<IEspQuerySetAliasActionResult> &val);
 void setResults(IArrayOf<IConstQuerySetAliasActionResult> &val);
};

class CWUQuerySetCopyQueryRequest : public CSoapRequestBinding,
   implements IEspWUQuerySetCopyQueryRequest,
   implements IClientWUQuerySetCopyQueryRequest
{
protected:
	SoapStringParam m_Source;
	SoapStringParam m_Target;
	SoapStringParam m_Cluster;
	SoapStringParam m_DaliServer;
	SoapParam<int> m_Activate;
	SoapParam<bool> m_Overwrite;
	SoapParam<bool> m_DontCopyFiles;
	SoapParam<int> m_Wait;
	SoapParam<bool> m_NoReload;
	SoapStringParam m_memoryLimit;
	SoapParam<unsigned int> m_TimeLimit;
	SoapParam<unsigned int> m_WarnTimeLimit;
	SoapStringParam m_priority;
	SoapStringParam m_Comment;
	SoapStringParam m_SourceProcess;
	SoapStringParam m_DestName;
	SoapParam<bool> m_AllowForeignFiles;
	SoapParam<bool> m_UpdateSuperFiles;
	SoapParam<bool> m_UpdateCloneFrom;
	SoapParam<bool> m_AppendCluster;
	SoapParam<bool> m_IncludeFileErrors;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CWUQuerySetCopyQueryRequest(const char *serviceName, const char *bcompat);

	CWUQuerySetCopyQueryRequest(const char *serviceName, IRpcMessageBinding *init=NULL);
	CWUQuerySetCopyQueryRequest(const char *serviceName, IRpcMessage* rpcmsg);
	CWUQuerySetCopyQueryRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	IEspClientRpcSettings &rpc(){return *static_cast<IEspClientRpcSettings*>(this);}


	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "WUQuerySetCopyQueryRequest";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CWUQuerySetCopyQueryRequest &from);

	void copy(IConstWUQuerySetCopyQueryRequest &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstWUQuerySetCopyQueryRequest &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	const char * getSource();
	const char * getTarget();
	const char * getCluster();
	const char * getDaliServer();
bool getActivate_isNull();
	int getActivate();
bool getOverwrite_isNull();
	bool getOverwrite();
bool getDontCopyFiles_isNull();
	bool getDontCopyFiles();
bool getWait_isNull();
	int getWait();
bool getNoReload_isNull();
	bool getNoReload();
	const char * getMemoryLimit();
bool getTimeLimit_isNull();
	unsigned int getTimeLimit();
bool getWarnTimeLimit_isNull();
	unsigned int getWarnTimeLimit();
	const char * getPriority();
	const char * getComment();
	const char * getSourceProcess();
	const char * getDestName();
bool getAllowForeignFiles_isNull();
	bool getAllowForeignFiles();
bool getUpdateSuperFiles_isNull();
	bool getUpdateSuperFiles();
bool getUpdateCloneFrom_isNull();
	bool getUpdateCloneFrom();
bool getAppendCluster_isNull();
	bool getAppendCluster();
bool getIncludeFileErrors_isNull();
	bool getIncludeFileErrors();
	void setSource(const char * val);
	void setTarget(const char * val);
	void setCluster(const char * val);
	void setDaliServer(const char * val);
	void setActivate_null();
	void setActivate(int val);
	void setOverwrite_null();
	void setOverwrite(bool val);
	void setDontCopyFiles_null();
	void setDontCopyFiles(bool val);
	void setWait_null();
	void setWait(int val);
	void setNoReload_null();
	void setNoReload(bool val);
	void setMemoryLimit(const char * val);
	void setTimeLimit_null();
	void setTimeLimit(unsigned int val);
	void setWarnTimeLimit_null();
	void setWarnTimeLimit(unsigned int val);
	void setPriority(const char * val);
	void setComment(const char * val);
	void setSourceProcess(const char * val);
	void setDestName(const char * val);
	void setAllowForeignFiles_null();
	void setAllowForeignFiles(bool val);
	void setUpdateSuperFiles_null();
	void setUpdateSuperFiles(bool val);
	void setUpdateCloneFrom_null();
	void setUpdateCloneFrom(bool val);
	void setAppendCluster_null();
	void setAppendCluster(bool val);
	void setIncludeFileErrors_null();
	void setIncludeFileErrors(bool val);
};

class CWUQuerySetCopyQueryResponse : public CSoapResponseBinding,
   implements IEspWUQuerySetCopyQueryResponse,
   implements IClientWUQuerySetCopyQueryResponse
{
protected:
	SoapStringParam m_QueryId;
	SoapStructArrayParam<IConstLogicalFileError, CLogicalFileError> m_FileErrors;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CWUQuerySetCopyQueryResponse(const char *serviceName, const char *bcompat);

	CWUQuerySetCopyQueryResponse(const char *serviceName, IRpcMessageBinding *init=NULL);
	CWUQuerySetCopyQueryResponse(const char *serviceName, IRpcMessage* rpcmsg);
	CWUQuerySetCopyQueryResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "WUQuerySetCopyQueryResponse";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CWUQuerySetCopyQueryResponse &from);

	void copy(IConstWUQuerySetCopyQueryResponse &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstWUQuerySetCopyQueryResponse &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	virtual void setRedirectUrl(const char *url)
	{ CSoapResponseBinding::setRedirectUrl(url); }

	virtual const IMultiException& getExceptions()
	{ return CSoapResponseBinding::getExceptions(); }

	virtual int queryClientStatus()
	{ return CSoapResponseBinding::getRpcState(); }

	virtual void noteException(IException& e)
	{  CSoapResponseBinding::noteException(e); }

	const char * getQueryId();
	IArrayOf<IConstLogicalFileError> & getFileErrors();
	void setQueryId(const char * val);
	void setFileErrors(IArrayOf<IEspLogicalFileError> &val);
 void setFileErrors(IArrayOf<IConstLogicalFileError> &val);
};

class CWUCopyQuerySetRequest : public CSoapRequestBinding,
   implements IEspWUCopyQuerySetRequest,
   implements IClientWUCopyQuerySetRequest
{
protected:
	SoapStringParam m_Source;
	SoapStringParam m_Target;
	SoapParam<bool> m_ActiveOnly;
	SoapParam<bool> m_CloneActiveState;
	SoapParam<bool> m_AllowForeignFiles;
	SoapStringParam m_DfsServer;
	SoapParam<bool> m_CopyFiles;
	SoapParam<bool> m_OverwriteDfs;
	SoapStringParam m_SourceProcess;
	SoapParam<bool> m_UpdateSuperFiles;
	SoapParam<bool> m_UpdateCloneFrom;
	SoapParam<bool> m_AppendCluster;
	SoapParam<bool> m_IncludeFileErrors;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CWUCopyQuerySetRequest(const char *serviceName, const char *bcompat);

	CWUCopyQuerySetRequest(const char *serviceName, IRpcMessageBinding *init=NULL);
	CWUCopyQuerySetRequest(const char *serviceName, IRpcMessage* rpcmsg);
	CWUCopyQuerySetRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	IEspClientRpcSettings &rpc(){return *static_cast<IEspClientRpcSettings*>(this);}


	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "WUCopyQuerySetRequest";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CWUCopyQuerySetRequest &from);

	void copy(IConstWUCopyQuerySetRequest &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstWUCopyQuerySetRequest &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	const char * getSource();
	const char * getTarget();
bool getActiveOnly_isNull();
	bool getActiveOnly();
bool getCloneActiveState_isNull();
	bool getCloneActiveState();
bool getAllowForeignFiles_isNull();
	bool getAllowForeignFiles();
	const char * getDfsServer();
bool getCopyFiles_isNull();
	bool getCopyFiles();
bool getOverwriteDfs_isNull();
	bool getOverwriteDfs();
	const char * getSourceProcess();
bool getUpdateSuperFiles_isNull();
	bool getUpdateSuperFiles();
bool getUpdateCloneFrom_isNull();
	bool getUpdateCloneFrom();
bool getAppendCluster_isNull();
	bool getAppendCluster();
bool getIncludeFileErrors_isNull();
	bool getIncludeFileErrors();
	void setSource(const char * val);
	void setTarget(const char * val);
	void setActiveOnly_null();
	void setActiveOnly(bool val);
	void setCloneActiveState_null();
	void setCloneActiveState(bool val);
	void setAllowForeignFiles_null();
	void setAllowForeignFiles(bool val);
	void setDfsServer(const char * val);
	void setCopyFiles_null();
	void setCopyFiles(bool val);
	void setOverwriteDfs_null();
	void setOverwriteDfs(bool val);
	void setSourceProcess(const char * val);
	void setUpdateSuperFiles_null();
	void setUpdateSuperFiles(bool val);
	void setUpdateCloneFrom_null();
	void setUpdateCloneFrom(bool val);
	void setAppendCluster_null();
	void setAppendCluster(bool val);
	void setIncludeFileErrors_null();
	void setIncludeFileErrors(bool val);
};

class CWUCopyQuerySetResponse : public CSoapResponseBinding,
   implements IEspWUCopyQuerySetResponse,
   implements IClientWUCopyQuerySetResponse
{
protected:
	SoapStringArray m_CopiedQueries;
	SoapStringArray m_ExistingQueries;
	SoapStructArrayParam<IConstLogicalFileError, CLogicalFileError> m_FileErrors;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CWUCopyQuerySetResponse(const char *serviceName, const char *bcompat);

	CWUCopyQuerySetResponse(const char *serviceName, IRpcMessageBinding *init=NULL);
	CWUCopyQuerySetResponse(const char *serviceName, IRpcMessage* rpcmsg);
	CWUCopyQuerySetResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "WUCopyQuerySetResponse";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CWUCopyQuerySetResponse &from);

	void copy(IConstWUCopyQuerySetResponse &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstWUCopyQuerySetResponse &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	virtual void setRedirectUrl(const char *url)
	{ CSoapResponseBinding::setRedirectUrl(url); }

	virtual const IMultiException& getExceptions()
	{ return CSoapResponseBinding::getExceptions(); }

	virtual int queryClientStatus()
	{ return CSoapResponseBinding::getRpcState(); }

	virtual void noteException(IException& e)
	{  CSoapResponseBinding::noteException(e); }

	StringArray & getCopiedQueries();
	StringArray & getExistingQueries();
	IArrayOf<IConstLogicalFileError> & getFileErrors();
	void setCopiedQueries(StringArray &val);
	void setExistingQueries(StringArray &val);
	void setFileErrors(IArrayOf<IEspLogicalFileError> &val);
 void setFileErrors(IArrayOf<IConstLogicalFileError> &val);
};

class CWUGetZAPInfoRequest : public CSoapRequestBinding,
   implements IEspWUGetZAPInfoRequest,
   implements IClientWUGetZAPInfoRequest
{
protected:
	SoapStringParam m_WUID;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CWUGetZAPInfoRequest(const char *serviceName, const char *bcompat);

	CWUGetZAPInfoRequest(const char *serviceName, IRpcMessageBinding *init=NULL);
	CWUGetZAPInfoRequest(const char *serviceName, IRpcMessage* rpcmsg);
	CWUGetZAPInfoRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	IEspClientRpcSettings &rpc(){return *static_cast<IEspClientRpcSettings*>(this);}


	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "WUGetZAPInfoRequest";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CWUGetZAPInfoRequest &from);

	void copy(IConstWUGetZAPInfoRequest &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstWUGetZAPInfoRequest &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	const char * getWUID();
	void setWUID(const char * val);
};

class CWUGetZAPInfoResponse : public CSoapResponseBinding,
   implements IEspWUGetZAPInfoResponse,
   implements IClientWUGetZAPInfoResponse
{
protected:
	SoapStringParam m_WUID;
	SoapStringParam m_ESPIPAddress;
	SoapStringParam m_ThorIPAddress;
	SoapStringParam m_BuildVersion;
	SoapStringParam m_Archive;
	SoapStringParam m_EmailTo;
	SoapStringParam m_EmailFrom;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CWUGetZAPInfoResponse(const char *serviceName, const char *bcompat);

	CWUGetZAPInfoResponse(const char *serviceName, IRpcMessageBinding *init=NULL);
	CWUGetZAPInfoResponse(const char *serviceName, IRpcMessage* rpcmsg);
	CWUGetZAPInfoResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "WUGetZAPInfoResponse";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CWUGetZAPInfoResponse &from);

	void copy(IConstWUGetZAPInfoResponse &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstWUGetZAPInfoResponse &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	virtual void setRedirectUrl(const char *url)
	{ CSoapResponseBinding::setRedirectUrl(url); }

	virtual const IMultiException& getExceptions()
	{ return CSoapResponseBinding::getExceptions(); }

	virtual int queryClientStatus()
	{ return CSoapResponseBinding::getRpcState(); }

	virtual void noteException(IException& e)
	{  CSoapResponseBinding::noteException(e); }

	const char * getWUID();
	const char * getESPIPAddress();
	const char * getThorIPAddress();
	const char * getBuildVersion();
	const char * getArchive();
	const char * getEmailTo();
	const char * getEmailFrom();
	void setWUID(const char * val);
	void setESPIPAddress(const char * val);
	void setThorIPAddress(const char * val);
	void setBuildVersion(const char * val);
	void setArchive(const char * val);
	void setEmailTo(const char * val);
	void setEmailFrom(const char * val);
};

class CWUCreateZAPInfoRequest : public CSoapRequestBinding,
   implements IEspWUCreateZAPInfoRequest,
   implements IClientWUCreateZAPInfoRequest
{
protected:
	SoapStringParam m_Wuid;
	SoapStringParam m_ESPIPAddress;
	SoapStringParam m_ThorIPAddress;
	SoapStringParam m_BuildVersion;
	SoapStringParam m_ProblemDescription;
	SoapStringParam m_WhatChanged;
	SoapStringParam m_WhereSlow;
	SoapStringParam m_Password;
	SoapStringParam m_ZAPFileName;
	SoapStringParam m_IncludeThorSlaveLog;
	SoapStringParam m_ZAPPassword;
	SoapParam<bool> m_SendEmail;
	SoapParam<bool> m_AttachZAPReportToEmail;
	SoapStringParam m_EmailFrom;
	SoapStringParam m_EmailSubject;
	SoapStringParam m_EmailBody;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CWUCreateZAPInfoRequest(const char *serviceName, const char *bcompat);

	CWUCreateZAPInfoRequest(const char *serviceName, IRpcMessageBinding *init=NULL);
	CWUCreateZAPInfoRequest(const char *serviceName, IRpcMessage* rpcmsg);
	CWUCreateZAPInfoRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	IEspClientRpcSettings &rpc(){return *static_cast<IEspClientRpcSettings*>(this);}


	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "WUCreateZAPInfoRequest";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CWUCreateZAPInfoRequest &from);

	void copy(IConstWUCreateZAPInfoRequest &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstWUCreateZAPInfoRequest &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	const char * getWuid();
	const char * getESPIPAddress();
	const char * getThorIPAddress();
	const char * getBuildVersion();
	const char * getProblemDescription();
	const char * getWhatChanged();
	const char * getWhereSlow();
	const char * getPassword();
	const char * getZAPFileName();
	const char * getIncludeThorSlaveLog();
	const char * getZAPPassword();
bool getSendEmail_isNull();
	bool getSendEmail();
bool getAttachZAPReportToEmail_isNull();
	bool getAttachZAPReportToEmail();
	const char * getEmailFrom();
	const char * getEmailSubject();
	const char * getEmailBody();
	void setWuid(const char * val);
	void setESPIPAddress(const char * val);
	void setThorIPAddress(const char * val);
	void setBuildVersion(const char * val);
	void setProblemDescription(const char * val);
	void setWhatChanged(const char * val);
	void setWhereSlow(const char * val);
	void setPassword(const char * val);
	void setZAPFileName(const char * val);
	void setIncludeThorSlaveLog(const char * val);
	void setZAPPassword(const char * val);
	void setSendEmail_null();
	void setSendEmail(bool val);
	void setAttachZAPReportToEmail_null();
	void setAttachZAPReportToEmail(bool val);
	void setEmailFrom(const char * val);
	void setEmailSubject(const char * val);
	void setEmailBody(const char * val);
};

class CWUCreateZAPInfoResponse : public CSoapResponseBinding,
   implements IEspWUCreateZAPInfoResponse,
   implements IClientWUCreateZAPInfoResponse
{
protected:
	SoapParamBinary m_thefile;
	SoapStringParam m_ZAPFileName;
	StringBuffer m_thefile_mimetype;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CWUCreateZAPInfoResponse(const char *serviceName, const char *bcompat);

	CWUCreateZAPInfoResponse(const char *serviceName, IRpcMessageBinding *init=NULL);
	CWUCreateZAPInfoResponse(const char *serviceName, IRpcMessage* rpcmsg);
	CWUCreateZAPInfoResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "WUCreateZAPInfoResponse";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return true;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CWUCreateZAPInfoResponse &from);

	void copy(IConstWUCreateZAPInfoResponse &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstWUCreateZAPInfoResponse &ifrom, StringBuffer& buffer, bool keepRootTag=true);

	void appendContent(IEspContext* ctx, MemoryBuffer& buffer, StringBuffer &mimetype);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	virtual void setRedirectUrl(const char *url)
	{ CSoapResponseBinding::setRedirectUrl(url); }

	virtual const IMultiException& getExceptions()
	{ return CSoapResponseBinding::getExceptions(); }

	virtual int queryClientStatus()
	{ return CSoapResponseBinding::getRpcState(); }

	virtual void noteException(IException& e)
	{  CSoapResponseBinding::noteException(e); }

	const char *getThefile_mimetype();
	const MemoryBuffer & getThefile();
	const char * getZAPFileName();
	void setThefile_mimetype(const char *  val);
	void setThefile(const MemoryBuffer & val);
	void setZAPFileName(const char * val);
};

class CWUCheckFeaturesRequest : public CSoapRequestBinding,
   implements IEspWUCheckFeaturesRequest,
   implements IClientWUCheckFeaturesRequest
{
protected:

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CWUCheckFeaturesRequest(const char *serviceName, const char *bcompat);

	CWUCheckFeaturesRequest(const char *serviceName, IRpcMessageBinding *init=NULL);
	CWUCheckFeaturesRequest(const char *serviceName, IRpcMessage* rpcmsg);
	CWUCheckFeaturesRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	IEspClientRpcSettings &rpc(){return *static_cast<IEspClientRpcSettings*>(this);}


	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "WUCheckFeaturesRequest";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CWUCheckFeaturesRequest &from);

	void copy(IConstWUCheckFeaturesRequest &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstWUCheckFeaturesRequest &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

};

class CDeploymentFeatures : public CSoapComplexType,
   implements IEspDeploymentFeatures,
   implements IClientDeploymentFeatures
{
protected:
	SoapParam<bool> m_UseCompression;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CDeploymentFeatures(const char *serviceName, const char *bcompat);

	CDeploymentFeatures(const char *serviceName, IRpcMessageBinding *init=NULL);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "DeploymentFeatures";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CDeploymentFeatures &from);

	void copy(IConstDeploymentFeatures &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstDeploymentFeatures &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	bool getUseCompression();
	void setUseCompression(bool val);
};

class CWUCheckFeaturesResponse : public CSoapResponseBinding,
   implements IEspWUCheckFeaturesResponse,
   implements IClientWUCheckFeaturesResponse
{
protected:
	SoapParam<int> m_BuildVersionMajor;
	SoapParam<int> m_BuildVersionMinor;
	SoapParam<int> m_BuildVersionPoint;
	SoapParam<unsigned int> m_maxRequestEntityLength;
	SoapStruct<CDeploymentFeatures, IConstDeploymentFeatures> m_Deployment;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CWUCheckFeaturesResponse(const char *serviceName, const char *bcompat);

	CWUCheckFeaturesResponse(const char *serviceName, IRpcMessageBinding *init=NULL);
	CWUCheckFeaturesResponse(const char *serviceName, IRpcMessage* rpcmsg);
	CWUCheckFeaturesResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "WUCheckFeaturesResponse";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CWUCheckFeaturesResponse &from);

	void copy(IConstWUCheckFeaturesResponse &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstWUCheckFeaturesResponse &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	virtual void setRedirectUrl(const char *url)
	{ CSoapResponseBinding::setRedirectUrl(url); }

	virtual const IMultiException& getExceptions()
	{ return CSoapResponseBinding::getExceptions(); }

	virtual int queryClientStatus()
	{ return CSoapResponseBinding::getRpcState(); }

	virtual void noteException(IException& e)
	{  CSoapResponseBinding::noteException(e); }

	int getBuildVersionMajor();
	int getBuildVersionMinor();
	int getBuildVersionPoint();
	unsigned int getMaxRequestEntityLength();
	IConstDeploymentFeatures & getDeployment();
	void setBuildVersionMajor(int val);
	void setBuildVersionMinor(int val);
	void setBuildVersionPoint(int val);
	void setMaxRequestEntityLength(unsigned int val);
	IEspDeploymentFeatures & updateDeployment();
	void setDeployment(IConstDeploymentFeatures &ifrom);
};

class CWUStatisticItem : public CSoapComplexType,
   implements IEspWUStatisticItem,
   implements IClientWUStatisticItem
{
protected:
	SoapStringParam m_Creator;
	SoapStringParam m_CreatorType;
	SoapStringParam m_Scope;
	SoapStringParam m_ScopeType;
	SoapStringParam m_Description;
	SoapStringParam m_TimeStamp;
	SoapStringParam m_Measure;
	SoapStringParam m_Kind;
	SoapStringParam m_Value;
	SoapParam<__int64> m_RawValue;
	SoapParam<__int64> m_Count;
	SoapParam<__int64> m_Max;
	SoapStringParam m_Wuid;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CWUStatisticItem(const char *serviceName, const char *bcompat);

	CWUStatisticItem(const char *serviceName, IRpcMessageBinding *init=NULL);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "WUStatisticItem";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CWUStatisticItem &from);

	void copy(IConstWUStatisticItem &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstWUStatisticItem &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	const char * getCreator();
	const char * getCreatorType();
	const char * getScope();
	const char * getScopeType();
	const char * getDescription();
	const char * getTimeStamp();
	const char * getMeasure();
	const char * getKind();
	const char * getValue();
bool getRawValue_isNull();
	__int64 getRawValue();
bool getCount_isNull();
	__int64 getCount();
bool getMax_isNull();
	__int64 getMax();
	const char * getWuid();
	void setCreator(const char * val);
	void setCreatorType(const char * val);
	void setScope(const char * val);
	void setScopeType(const char * val);
	void setDescription(const char * val);
	void setTimeStamp(const char * val);
	void setMeasure(const char * val);
	void setKind(const char * val);
	void setValue(const char * val);
	void setRawValue_null();
	void setRawValue(__int64 val);
	void setCount_null();
	void setCount(__int64 val);
	void setMax_null();
	void setMax(__int64 val);
	void setWuid(const char * val);
};

class CWUGetStatsRequest : public CSoapRequestBinding,
   implements IEspWUGetStatsRequest,
   implements IClientWUGetStatsRequest
{
protected:
	SoapStringParam m_WUID;
	SoapStringParam m_CreatorType;
	SoapStringParam m_Creator;
	SoapStringParam m_ScopeType;
	SoapStringParam m_Scope;
	SoapStringParam m_Kind;
	SoapStringParam m_Measure;
	SoapParam<unsigned int> m_MinScopeDepth;
	SoapParam<unsigned int> m_MaxScopeDepth;
	SoapParam<bool> m_IncludeGraphs;
	SoapParam<bool> m_CreateDescriptions;
	SoapParam<__int64> m_MinValue;
	SoapParam<__int64> m_MaxValue;
	SoapStringParam m_Filter;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CWUGetStatsRequest(const char *serviceName, const char *bcompat);

	CWUGetStatsRequest(const char *serviceName, IRpcMessageBinding *init=NULL);
	CWUGetStatsRequest(const char *serviceName, IRpcMessage* rpcmsg);
	CWUGetStatsRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	IEspClientRpcSettings &rpc(){return *static_cast<IEspClientRpcSettings*>(this);}


	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "WUGetStatsRequest";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CWUGetStatsRequest &from);

	void copy(IConstWUGetStatsRequest &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstWUGetStatsRequest &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	const char * getWUID();
	const char * getCreatorType();
	const char * getCreator();
	const char * getScopeType();
	const char * getScope();
	const char * getKind();
	const char * getMeasure();
bool getMinScopeDepth_isNull();
	unsigned int getMinScopeDepth();
bool getMaxScopeDepth_isNull();
	unsigned int getMaxScopeDepth();
bool getIncludeGraphs_isNull();
	bool getIncludeGraphs();
bool getCreateDescriptions_isNull();
	bool getCreateDescriptions();
bool getMinValue_isNull();
	__int64 getMinValue();
bool getMaxValue_isNull();
	__int64 getMaxValue();
	const char * getFilter();
	void setWUID(const char * val);
	void setCreatorType(const char * val);
	void setCreator(const char * val);
	void setScopeType(const char * val);
	void setScope(const char * val);
	void setKind(const char * val);
	void setMeasure(const char * val);
	void setMinScopeDepth_null();
	void setMinScopeDepth(unsigned int val);
	void setMaxScopeDepth_null();
	void setMaxScopeDepth(unsigned int val);
	void setIncludeGraphs_null();
	void setIncludeGraphs(bool val);
	void setCreateDescriptions_null();
	void setCreateDescriptions(bool val);
	void setMinValue_null();
	void setMinValue(__int64 val);
	void setMaxValue_null();
	void setMaxValue(__int64 val);
	void setFilter(const char * val);
};

class CWUGetStatsResponse : public CSoapResponseBinding,
   implements IEspWUGetStatsResponse,
   implements IClientWUGetStatsResponse
{
protected:
	SoapStringParam m_WUID;
	SoapStructArrayParam<IConstWUStatisticItem, CWUStatisticItem> m_Statistics;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CWUGetStatsResponse(const char *serviceName, const char *bcompat);

	CWUGetStatsResponse(const char *serviceName, IRpcMessageBinding *init=NULL);
	CWUGetStatsResponse(const char *serviceName, IRpcMessage* rpcmsg);
	CWUGetStatsResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "WUGetStatsResponse";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CWUGetStatsResponse &from);

	void copy(IConstWUGetStatsResponse &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstWUGetStatsResponse &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	virtual void setRedirectUrl(const char *url)
	{ CSoapResponseBinding::setRedirectUrl(url); }

	virtual const IMultiException& getExceptions()
	{ return CSoapResponseBinding::getExceptions(); }

	virtual int queryClientStatus()
	{ return CSoapResponseBinding::getRpcState(); }

	virtual void noteException(IException& e)
	{  CSoapResponseBinding::noteException(e); }

	const char * getWUID();
	IArrayOf<IConstWUStatisticItem> & getStatistics();
	void setWUID(const char * val);
	void setStatistics(IArrayOf<IEspWUStatisticItem> &val);
 void setStatistics(IArrayOf<IConstWUStatisticItem> &val);
};

class CWUArchiveFile : public CSoapComplexType,
   implements IEspWUArchiveFile,
   implements IClientWUArchiveFile
{
protected:
	SoapStringParam m_Name;
	SoapStringParam m_Key;
	SoapStringParam m_SourcePath;
	SoapStringParam m_Path;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CWUArchiveFile(const char *serviceName, const char *bcompat);

	CWUArchiveFile(const char *serviceName, IRpcMessageBinding *init=NULL);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "WUArchiveFile";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CWUArchiveFile &from);

	void copy(IConstWUArchiveFile &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstWUArchiveFile &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	const char * getName();
	const char * getKey();
	const char * getSourcePath();
	const char * getPath();
	void setName(const char * val);
	void setKey(const char * val);
	void setSourcePath(const char * val);
	void setPath(const char * val);
};

class CWUArchiveModule : public CSoapComplexType,
   implements IEspWUArchiveModule,
   implements IClientWUArchiveModule
{
protected:
	SoapStringParam m_Name;
	SoapStringParam m_FullName;
	SoapParam<unsigned int> m_Flags;
	SoapStringParam m_Key;
	SoapStringParam m_Plugin;
	SoapStringParam m_SourcePath;
	SoapStringParam m_Version;
	SoapStringParam m_Path;
	SoapStructArrayParam<IConstWUArchiveModule, CWUArchiveModule> m_ArchiveModules;
	SoapStructArrayParam<IConstWUArchiveFile, CWUArchiveFile> m_Files;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CWUArchiveModule(const char *serviceName, const char *bcompat);

	CWUArchiveModule(const char *serviceName, IRpcMessageBinding *init=NULL);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "WUArchiveModule";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CWUArchiveModule &from);

	void copy(IConstWUArchiveModule &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstWUArchiveModule &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	const char * getName();
	const char * getFullName();
bool getFlags_isNull();
	unsigned int getFlags();
	const char * getKey();
	const char * getPlugin();
	const char * getSourcePath();
	const char * getVersion();
	const char * getPath();
	IArrayOf<IConstWUArchiveModule> & getArchiveModules();
	IArrayOf<IConstWUArchiveFile> & getFiles();
	void setName(const char * val);
	void setFullName(const char * val);
	void setFlags_null();
	void setFlags(unsigned int val);
	void setKey(const char * val);
	void setPlugin(const char * val);
	void setSourcePath(const char * val);
	void setVersion(const char * val);
	void setPath(const char * val);
	void setArchiveModules(IArrayOf<IEspWUArchiveModule> &val);
 void setArchiveModules(IArrayOf<IConstWUArchiveModule> &val);
	void setFiles(IArrayOf<IEspWUArchiveFile> &val);
 void setFiles(IArrayOf<IConstWUArchiveFile> &val);
};

class CWUListArchiveFilesRequest : public CSoapRequestBinding,
   implements IEspWUListArchiveFilesRequest,
   implements IClientWUListArchiveFilesRequest
{
protected:
	SoapStringParam m_WUID;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CWUListArchiveFilesRequest(const char *serviceName, const char *bcompat);

	CWUListArchiveFilesRequest(const char *serviceName, IRpcMessageBinding *init=NULL);
	CWUListArchiveFilesRequest(const char *serviceName, IRpcMessage* rpcmsg);
	CWUListArchiveFilesRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	IEspClientRpcSettings &rpc(){return *static_cast<IEspClientRpcSettings*>(this);}


	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "WUListArchiveFilesRequest";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CWUListArchiveFilesRequest &from);

	void copy(IConstWUListArchiveFilesRequest &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstWUListArchiveFilesRequest &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	const char * getWUID();
	void setWUID(const char * val);
};

class CWUListArchiveFilesResponse : public CSoapResponseBinding,
   implements IEspWUListArchiveFilesResponse,
   implements IClientWUListArchiveFilesResponse
{
protected:
	SoapStructArrayParam<IConstWUArchiveModule, CWUArchiveModule> m_ArchiveModules;
	SoapStructArrayParam<IConstWUArchiveFile, CWUArchiveFile> m_Files;
	SoapStringParam m_Message;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CWUListArchiveFilesResponse(const char *serviceName, const char *bcompat);

	CWUListArchiveFilesResponse(const char *serviceName, IRpcMessageBinding *init=NULL);
	CWUListArchiveFilesResponse(const char *serviceName, IRpcMessage* rpcmsg);
	CWUListArchiveFilesResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "WUListArchiveFilesResponse";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CWUListArchiveFilesResponse &from);

	void copy(IConstWUListArchiveFilesResponse &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstWUListArchiveFilesResponse &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	virtual void setRedirectUrl(const char *url)
	{ CSoapResponseBinding::setRedirectUrl(url); }

	virtual const IMultiException& getExceptions()
	{ return CSoapResponseBinding::getExceptions(); }

	virtual int queryClientStatus()
	{ return CSoapResponseBinding::getRpcState(); }

	virtual void noteException(IException& e)
	{  CSoapResponseBinding::noteException(e); }

	IArrayOf<IConstWUArchiveModule> & getArchiveModules();
	IArrayOf<IConstWUArchiveFile> & getFiles();
	const char * getMessage();
	void setArchiveModules(IArrayOf<IEspWUArchiveModule> &val);
 void setArchiveModules(IArrayOf<IConstWUArchiveModule> &val);
	void setFiles(IArrayOf<IEspWUArchiveFile> &val);
 void setFiles(IArrayOf<IConstWUArchiveFile> &val);
	void setMessage(const char * val);
};

class CWUGetArchiveFileRequest : public CSoapRequestBinding,
   implements IEspWUGetArchiveFileRequest,
   implements IClientWUGetArchiveFileRequest
{
protected:
	SoapStringParam m_WUID;
	SoapStringParam m_ModuleName;
	SoapStringParam m_FileName;
	SoapStringParam m_Path;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CWUGetArchiveFileRequest(const char *serviceName, const char *bcompat);

	CWUGetArchiveFileRequest(const char *serviceName, IRpcMessageBinding *init=NULL);
	CWUGetArchiveFileRequest(const char *serviceName, IRpcMessage* rpcmsg);
	CWUGetArchiveFileRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	IEspClientRpcSettings &rpc(){return *static_cast<IEspClientRpcSettings*>(this);}


	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "WUGetArchiveFileRequest";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CWUGetArchiveFileRequest &from);

	void copy(IConstWUGetArchiveFileRequest &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstWUGetArchiveFileRequest &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	const char * getWUID();
	const char * getModuleName();
	const char * getFileName();
	const char * getPath();
	void setWUID(const char * val);
	void setModuleName(const char * val);
	void setFileName(const char * val);
	void setPath(const char * val);
};

class CWUGetArchiveFileResponse : public CSoapResponseBinding,
   implements IEspWUGetArchiveFileResponse,
   implements IClientWUGetArchiveFileResponse
{
protected:
	SoapStringParam m_File;
	SoapStringParam m_Message;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CWUGetArchiveFileResponse(const char *serviceName, const char *bcompat);

	CWUGetArchiveFileResponse(const char *serviceName, IRpcMessageBinding *init=NULL);
	CWUGetArchiveFileResponse(const char *serviceName, IRpcMessage* rpcmsg);
	CWUGetArchiveFileResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "WUGetArchiveFileResponse";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CWUGetArchiveFileResponse &from);

	void copy(IConstWUGetArchiveFileResponse &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstWUGetArchiveFileResponse &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	virtual void setRedirectUrl(const char *url)
	{ CSoapResponseBinding::setRedirectUrl(url); }

	virtual const IMultiException& getExceptions()
	{ return CSoapResponseBinding::getExceptions(); }

	virtual int queryClientStatus()
	{ return CSoapResponseBinding::getRpcState(); }

	virtual void noteException(IException& e)
	{  CSoapResponseBinding::noteException(e); }

	const char * getFile();
	const char * getMessage();
	void setFile(const char * val);
	void setMessage(const char * val);
};

class CWUGetNumFileToCopyRequest : public CSoapRequestBinding,
   implements IEspWUGetNumFileToCopyRequest,
   implements IClientWUGetNumFileToCopyRequest
{
protected:
	SoapStringParam m_ClusterName;
	SoapParam<__int64> m_PageSize;
	SoapParam<__int64> m_PageStartFrom;
	SoapStringParam m_Sortby;
	SoapParam<bool> m_Descending;
	SoapParam<__int64> m_CacheHint;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CWUGetNumFileToCopyRequest(const char *serviceName, const char *bcompat);

	CWUGetNumFileToCopyRequest(const char *serviceName, IRpcMessageBinding *init=NULL);
	CWUGetNumFileToCopyRequest(const char *serviceName, IRpcMessage* rpcmsg);
	CWUGetNumFileToCopyRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	IEspClientRpcSettings &rpc(){return *static_cast<IEspClientRpcSettings*>(this);}


	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "WUGetNumFileToCopyRequest";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CWUGetNumFileToCopyRequest &from);

	void copy(IConstWUGetNumFileToCopyRequest &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstWUGetNumFileToCopyRequest &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	const char * getClusterName();
bool getPageSize_isNull();
	__int64 getPageSize();
bool getPageStartFrom_isNull();
	__int64 getPageStartFrom();
	const char * getSortby();
bool getDescending_isNull();
	bool getDescending();
bool getCacheHint_isNull();
	__int64 getCacheHint();
	void setClusterName(const char * val);
	void setPageSize_null();
	void setPageSize(__int64 val);
	void setPageStartFrom_null();
	void setPageStartFrom(__int64 val);
	void setSortby(const char * val);
	void setDescending_null();
	void setDescending(bool val);
	void setCacheHint_null();
	void setCacheHint(__int64 val);
};

class CWUGetNumFileToCopyResponse : public CSoapResponseBinding,
   implements IEspWUGetNumFileToCopyResponse,
   implements IClientWUGetNumFileToCopyResponse
{
protected:
	SoapStructArrayParam<IConstClusterEndpoint, CClusterEndpoint> m_Endpoints;
	SoapParam<__int64> m_CacheHint;
	SoapParam<__int64> m_Total;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CWUGetNumFileToCopyResponse(const char *serviceName, const char *bcompat);

	CWUGetNumFileToCopyResponse(const char *serviceName, IRpcMessageBinding *init=NULL);
	CWUGetNumFileToCopyResponse(const char *serviceName, IRpcMessage* rpcmsg);
	CWUGetNumFileToCopyResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "WUGetNumFileToCopyResponse";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CWUGetNumFileToCopyResponse &from);

	void copy(IConstWUGetNumFileToCopyResponse &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstWUGetNumFileToCopyResponse &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	virtual void setRedirectUrl(const char *url)
	{ CSoapResponseBinding::setRedirectUrl(url); }

	virtual const IMultiException& getExceptions()
	{ return CSoapResponseBinding::getExceptions(); }

	virtual int queryClientStatus()
	{ return CSoapResponseBinding::getRpcState(); }

	virtual void noteException(IException& e)
	{  CSoapResponseBinding::noteException(e); }

	IArrayOf<IConstClusterEndpoint> & getEndpoints();
bool getCacheHint_isNull();
	__int64 getCacheHint();
bool getTotal_isNull();
	__int64 getTotal();
	void setEndpoints(IArrayOf<IEspClusterEndpoint> &val);
 void setEndpoints(IArrayOf<IConstClusterEndpoint> &val);
	void setCacheHint_null();
	void setCacheHint(__int64 val);
	void setTotal_null();
	void setTotal(__int64 val);
};

class CWUPropertyFilter : public CSoapComplexType,
   implements IEspWUPropertyFilter,
   implements IClientWUPropertyFilter
{
protected:
	SoapStringParam m_Name;
	SoapStringParam m_ExactValue;
	SoapStringParam m_MinValue;
	SoapStringParam m_MaxValue;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CWUPropertyFilter(const char *serviceName, const char *bcompat);

	CWUPropertyFilter(const char *serviceName, IRpcMessageBinding *init=NULL);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "WUPropertyFilter";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CWUPropertyFilter &from);

	void copy(IConstWUPropertyFilter &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstWUPropertyFilter &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	const char * getName();
	const char * getExactValue();
	const char * getMinValue();
	const char * getMaxValue();
	void setName(const char * val);
	void setExactValue(const char * val);
	void setMinValue(const char * val);
	void setMaxValue(const char * val);
};

class CWUScopeFilter : public CSoapComplexType,
   implements IEspWUScopeFilter,
   implements IClientWUScopeFilter
{
protected:
	SoapParam<int> m_MaxDepth;
	SoapStringArray m_Scopes;
	SoapStringArray m_Ids;
	SoapStringArray m_ScopeTypes;
	SoapStructArrayParam<IConstWUPropertyFilter, CWUPropertyFilter> m_PropertyFilters;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CWUScopeFilter(const char *serviceName, const char *bcompat);

	CWUScopeFilter(const char *serviceName, IRpcMessageBinding *init=NULL);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "WUScopeFilter";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CWUScopeFilter &from);

	void copy(IConstWUScopeFilter &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstWUScopeFilter &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	int getMaxDepth();
	StringArray & getScopes();
	StringArray & getIds();
	StringArray & getScopeTypes();
	IArrayOf<IConstWUPropertyFilter> & getPropertyFilters();
	void setMaxDepth(int val);
	void setScopes(StringArray &val);
	void setIds(StringArray &val);
	void setScopeTypes(StringArray &val);
	void setPropertyFilters(IArrayOf<IEspWUPropertyFilter> &val);
 void setPropertyFilters(IArrayOf<IConstWUPropertyFilter> &val);
};

class CWUNestedFilter : public CSoapComplexType,
   implements IEspWUNestedFilter,
   implements IClientWUNestedFilter
{
protected:
	SoapParam<unsigned int> m_Depth;
	SoapStringArray m_ScopeTypes;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CWUNestedFilter(const char *serviceName, const char *bcompat);

	CWUNestedFilter(const char *serviceName, IRpcMessageBinding *init=NULL);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "WUNestedFilter";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CWUNestedFilter &from);

	void copy(IConstWUNestedFilter &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstWUNestedFilter &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	unsigned int getDepth();
	StringArray & getScopeTypes();
	void setDepth(unsigned int val);
	void setScopeTypes(StringArray &val);
};

class CWUExtraProperties : public CSoapComplexType,
   implements IEspWUExtraProperties,
   implements IClientWUExtraProperties
{
protected:
	SoapStringParam m_scopeType;
	SoapStringArray m_Properties;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CWUExtraProperties(const char *serviceName, const char *bcompat);

	CWUExtraProperties(const char *serviceName, IRpcMessageBinding *init=NULL);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "WUExtraProperties";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CWUExtraProperties &from);

	void copy(IConstWUExtraProperties &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstWUExtraProperties &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	const char * getScopeType();
	StringArray & getProperties();
	void setScopeType(const char * val);
	void setProperties(StringArray &val);
};

class CWUPropertiesToReturn : public CSoapComplexType,
   implements IEspWUPropertiesToReturn,
   implements IClientWUPropertiesToReturn
{
protected:
	SoapParam<bool> m_AllStatistics;
	SoapParam<bool> m_AllAttributes;
	SoapParam<bool> m_AllHints;
	SoapParam<bool> m_AllScopes;
	SoapParam<bool> m_AllProperties;
	SoapStringParam m_MinVersion;
	SoapStringParam m_Measure;
	SoapStringArray m_Properties;
	SoapStructArrayParam<IConstWUExtraProperties, CWUExtraProperties> m_ExtraProperties;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CWUPropertiesToReturn(const char *serviceName, const char *bcompat);

	CWUPropertiesToReturn(const char *serviceName, IRpcMessageBinding *init=NULL);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "WUPropertiesToReturn";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CWUPropertiesToReturn &from);

	void copy(IConstWUPropertiesToReturn &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstWUPropertiesToReturn &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	bool getAllStatistics();
	bool getAllAttributes();
	bool getAllHints();
	bool getAllScopes();
	bool getAllProperties();
	const char * getMinVersion();
	const char * getMeasure();
	StringArray & getProperties();
	IArrayOf<IConstWUExtraProperties> & getExtraProperties();
	void setAllStatistics(bool val);
	void setAllAttributes(bool val);
	void setAllHints(bool val);
	void setAllScopes(bool val);
	void setAllProperties(bool val);
	void setMinVersion(const char * val);
	void setMeasure(const char * val);
	void setProperties(StringArray &val);
	void setExtraProperties(IArrayOf<IEspWUExtraProperties> &val);
 void setExtraProperties(IArrayOf<IConstWUExtraProperties> &val);
};

class CWUScopeOptions : public CSoapComplexType,
   implements IEspWUScopeOptions,
   implements IClientWUScopeOptions
{
protected:
	SoapParam<bool> m_IncludeMatchedScopesInResults;
	SoapParam<bool> m_IncludeScope;
	SoapParam<bool> m_IncludeId;
	SoapParam<bool> m_IncludeScopeType;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CWUScopeOptions(const char *serviceName, const char *bcompat);

	CWUScopeOptions(const char *serviceName, IRpcMessageBinding *init=NULL);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "WUScopeOptions";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CWUScopeOptions &from);

	void copy(IConstWUScopeOptions &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstWUScopeOptions &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	bool getIncludeMatchedScopesInResults();
	bool getIncludeScope();
	bool getIncludeId();
	bool getIncludeScopeType();
	void setIncludeMatchedScopesInResults(bool val);
	void setIncludeScope(bool val);
	void setIncludeId(bool val);
	void setIncludeScopeType(bool val);
};

class CWUPropertyOptions : public CSoapComplexType,
   implements IEspWUPropertyOptions,
   implements IClientWUPropertyOptions
{
protected:
	SoapParam<bool> m_IncludeName;
	SoapParam<bool> m_IncludeRawValue;
	SoapParam<bool> m_IncludeFormatted;
	SoapParam<bool> m_IncludeMeasure;
	SoapParam<bool> m_IncludeCreator;
	SoapParam<bool> m_IncludeCreatorType;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CWUPropertyOptions(const char *serviceName, const char *bcompat);

	CWUPropertyOptions(const char *serviceName, IRpcMessageBinding *init=NULL);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "WUPropertyOptions";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CWUPropertyOptions &from);

	void copy(IConstWUPropertyOptions &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstWUPropertyOptions &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	bool getIncludeName();
	bool getIncludeRawValue();
	bool getIncludeFormatted();
	bool getIncludeMeasure();
	bool getIncludeCreator();
	bool getIncludeCreatorType();
	void setIncludeName(bool val);
	void setIncludeRawValue(bool val);
	void setIncludeFormatted(bool val);
	void setIncludeMeasure(bool val);
	void setIncludeCreator(bool val);
	void setIncludeCreatorType(bool val);
};

class CWUDetailsRequest : public CSoapRequestBinding,
   implements IEspWUDetailsRequest,
   implements IClientWUDetailsRequest
{
protected:
	SoapStringParam m_WUID;
	SoapStruct<CWUScopeFilter, IConstWUScopeFilter> m_ScopeFilter;
	SoapStruct<CWUNestedFilter, IConstWUNestedFilter> m_NestedFilter;
	SoapStruct<CWUPropertiesToReturn, IConstWUPropertiesToReturn> m_PropertiesToReturn;
	SoapStringParam m_Filter;
	SoapStruct<CWUScopeOptions, IConstWUScopeOptions> m_ScopeOptions;
	SoapStruct<CWUPropertyOptions, IConstWUPropertyOptions> m_PropertyOptions;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CWUDetailsRequest(const char *serviceName, const char *bcompat);

	CWUDetailsRequest(const char *serviceName, IRpcMessageBinding *init=NULL);
	CWUDetailsRequest(const char *serviceName, IRpcMessage* rpcmsg);
	CWUDetailsRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	IEspClientRpcSettings &rpc(){return *static_cast<IEspClientRpcSettings*>(this);}


	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "WUDetailsRequest";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CWUDetailsRequest &from);

	void copy(IConstWUDetailsRequest &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstWUDetailsRequest &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	const char * getWUID();
	IConstWUScopeFilter & getScopeFilter();
	IConstWUNestedFilter & getNestedFilter();
	IConstWUPropertiesToReturn & getPropertiesToReturn();
	const char * getFilter();
	IConstWUScopeOptions & getScopeOptions();
	IConstWUPropertyOptions & getPropertyOptions();
	void setWUID(const char * val);
	IEspWUScopeFilter & updateScopeFilter();
	void setScopeFilter(IConstWUScopeFilter &ifrom);
	IEspWUNestedFilter & updateNestedFilter();
	void setNestedFilter(IConstWUNestedFilter &ifrom);
	IEspWUPropertiesToReturn & updatePropertiesToReturn();
	void setPropertiesToReturn(IConstWUPropertiesToReturn &ifrom);
	void setFilter(const char * val);
	IEspWUScopeOptions & updateScopeOptions();
	void setScopeOptions(IConstWUScopeOptions &ifrom);
	IEspWUPropertyOptions & updatePropertyOptions();
	void setPropertyOptions(IConstWUPropertyOptions &ifrom);
};

class CWUResponseProperty : public CSoapComplexType,
   implements IEspWUResponseProperty,
   implements IClientWUResponseProperty
{
protected:
	SoapStringParam m_Name;
	SoapStringParam m_RawValue;
	SoapStringParam m_Formatted;
	SoapStringParam m_Measure;
	SoapStringParam m_Creator;
	SoapStringParam m_CreatorType;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CWUResponseProperty(const char *serviceName, const char *bcompat);

	CWUResponseProperty(const char *serviceName, IRpcMessageBinding *init=NULL);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "WUResponseProperty";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CWUResponseProperty &from);

	void copy(IConstWUResponseProperty &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstWUResponseProperty &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	const char * getName();
	const char * getRawValue();
	const char * getFormatted();
	const char * getMeasure();
	const char * getCreator();
	const char * getCreatorType();
	void setName(const char * val);
	void setRawValue(const char * val);
	void setFormatted(const char * val);
	void setMeasure(const char * val);
	void setCreator(const char * val);
	void setCreatorType(const char * val);
};

class CWUResponseScope : public CSoapComplexType,
   implements IEspWUResponseScope,
   implements IClientWUResponseScope
{
protected:
	SoapStringParam m_ScopeName;
	SoapStringParam m_Id;
	SoapStringParam m_ScopeType;
	SoapStructArrayParam<IConstWUResponseProperty, CWUResponseProperty> m_Properties;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CWUResponseScope(const char *serviceName, const char *bcompat);

	CWUResponseScope(const char *serviceName, IRpcMessageBinding *init=NULL);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "WUResponseScope";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CWUResponseScope &from);

	void copy(IConstWUResponseScope &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstWUResponseScope &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	const char * getScopeName();
	const char * getId();
	const char * getScopeType();
	IArrayOf<IConstWUResponseProperty> & getProperties();
	void setScopeName(const char * val);
	void setId(const char * val);
	void setScopeType(const char * val);
	void setProperties(IArrayOf<IEspWUResponseProperty> &val);
 void setProperties(IArrayOf<IConstWUResponseProperty> &val);
};

class CWUDetailsResponse : public CSoapResponseBinding,
   implements IEspWUDetailsResponse,
   implements IClientWUDetailsResponse
{
protected:
	SoapStringParam m_MaxVersion;
	SoapStringParam m_WUID;
	SoapStructArrayParam<IConstWUResponseScope, CWUResponseScope> m_Scopes;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CWUDetailsResponse(const char *serviceName, const char *bcompat);

	CWUDetailsResponse(const char *serviceName, IRpcMessageBinding *init=NULL);
	CWUDetailsResponse(const char *serviceName, IRpcMessage* rpcmsg);
	CWUDetailsResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "WUDetailsResponse";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CWUDetailsResponse &from);

	void copy(IConstWUDetailsResponse &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstWUDetailsResponse &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	virtual void setRedirectUrl(const char *url)
	{ CSoapResponseBinding::setRedirectUrl(url); }

	virtual const IMultiException& getExceptions()
	{ return CSoapResponseBinding::getExceptions(); }

	virtual int queryClientStatus()
	{ return CSoapResponseBinding::getRpcState(); }

	virtual void noteException(IException& e)
	{  CSoapResponseBinding::noteException(e); }

	const char * getMaxVersion();
	const char * getWUID();
	IArrayOf<IConstWUResponseScope> & getScopes();
	void setMaxVersion(const char * val);
	void setWUID(const char * val);
	void setScopes(IArrayOf<IEspWUResponseScope> &val);
 void setScopes(IArrayOf<IConstWUResponseScope> &val);
};

class CXWUDetailsAttrValueType : public SoapEnumParamNew<CWUDetailsAttrValueType>
{
public:
	CXWUDetailsAttrValueType(nilBehavior nilB) : SoapEnumParamNew<CWUDetailsAttrValueType>(nilB)
	{ doInit(); }
	CXWUDetailsAttrValueType(CWUDetailsAttrValueType defvalue_) : SoapEnumParamNew<CWUDetailsAttrValueType>(defvalue_)
	{ doInit(); }
	CXWUDetailsAttrValueType(const char* defvalue_) : SoapEnumParamNew<CWUDetailsAttrValueType>()
	{ doInit(); setDefaultValue(defvalue_); }
	static  void getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash &added)
	{ getSharedInstance().getXsdDefinitionInternal(context,request,schema,added); }
	static void getMapInfo(IMapInfo& info, BoolHash& added) { getSharedInstance().getMapInfo_(info,added); }

	static const char* stringOf(CWUDetailsAttrValueType val) { return getSharedInstance().toString(val); }

	static CWUDetailsAttrValueType enumOf(const char* s) { return getSharedInstance().toEnum(s); }

static const char *queryXsdElementName() { return "WUDetailsAttrValueType"; }
private:
	static CXWUDetailsAttrValueType& getSharedInstance() { static CXWUDetailsAttrValueType instance(nilIgnore); return instance; }
	void getMapInfo_(IMapInfo& info, BoolHash& added) {  }
	void getXsdDefinitionInternal(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash &added)
	{ getXsdDefinition_(context,request,schema,added,NULL); }
	void doInit()
	{
		static const char* inits[] = {"Single","List","Multi",NULL};
		init("WUDetailsAttrValueType","string",inits);
	}
};

class CWUDetailsMetaProperty : public CSoapComplexType,
   implements IEspWUDetailsMetaProperty,
   implements IClientWUDetailsMetaProperty
{
protected:
	SoapStringParam m_Name;
	CXWUDetailsAttrValueType m_ValueType;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CWUDetailsMetaProperty(const char *serviceName, const char *bcompat);

	CWUDetailsMetaProperty(const char *serviceName, IRpcMessageBinding *init=NULL);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "WUDetailsMetaProperty";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CWUDetailsMetaProperty &from);

	void copy(IConstWUDetailsMetaProperty &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstWUDetailsMetaProperty &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	const char * getName();
	CWUDetailsAttrValueType getValueType();
	const char* getValueTypeAsString();
	void setName(const char * val);
	void setValueType(CWUDetailsAttrValueType val);
void setValueType(const char* val);
};

class CWUDetailsActivityInfo : public CSoapComplexType,
   implements IEspWUDetailsActivityInfo,
   implements IClientWUDetailsActivityInfo
{
protected:
	SoapParam<unsigned int> m_Kind;
	SoapStringParam m_Name;
	SoapParam<bool> m_IsSink;
	SoapParam<bool> m_IsSource;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CWUDetailsActivityInfo(const char *serviceName, const char *bcompat);

	CWUDetailsActivityInfo(const char *serviceName, IRpcMessageBinding *init=NULL);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "WUDetailsActivityInfo";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CWUDetailsActivityInfo &from);

	void copy(IConstWUDetailsActivityInfo &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstWUDetailsActivityInfo &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	unsigned int getKind();
	const char * getName();
	bool getIsSink();
	bool getIsSource();
	void setKind(unsigned int val);
	void setName(const char * val);
	void setIsSink(bool val);
	void setIsSource(bool val);
};

class CWUDetailsMetaRequest : public CSoapRequestBinding,
   implements IEspWUDetailsMetaRequest,
   implements IClientWUDetailsMetaRequest
{
protected:

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CWUDetailsMetaRequest(const char *serviceName, const char *bcompat);

	CWUDetailsMetaRequest(const char *serviceName, IRpcMessageBinding *init=NULL);
	CWUDetailsMetaRequest(const char *serviceName, IRpcMessage* rpcmsg);
	CWUDetailsMetaRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	IEspClientRpcSettings &rpc(){return *static_cast<IEspClientRpcSettings*>(this);}


	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "WUDetailsMetaRequest";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CWUDetailsMetaRequest &from);

	void copy(IConstWUDetailsMetaRequest &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstWUDetailsMetaRequest &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

};

class CWUDetailsMetaResponse : public CSoapResponseBinding,
   implements IEspWUDetailsMetaResponse,
   implements IClientWUDetailsMetaResponse
{
protected:
	SoapStructArrayParam<IConstWUDetailsMetaProperty, CWUDetailsMetaProperty> m_Properties;
	SoapStringArray m_ScopeTypes;
	SoapStringArray m_Measures;
	SoapStructArrayParam<IConstWUDetailsActivityInfo, CWUDetailsActivityInfo> m_Activities;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CWUDetailsMetaResponse(const char *serviceName, const char *bcompat);

	CWUDetailsMetaResponse(const char *serviceName, IRpcMessageBinding *init=NULL);
	CWUDetailsMetaResponse(const char *serviceName, IRpcMessage* rpcmsg);
	CWUDetailsMetaResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "WUDetailsMetaResponse";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CWUDetailsMetaResponse &from);

	void copy(IConstWUDetailsMetaResponse &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstWUDetailsMetaResponse &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	virtual void setRedirectUrl(const char *url)
	{ CSoapResponseBinding::setRedirectUrl(url); }

	virtual const IMultiException& getExceptions()
	{ return CSoapResponseBinding::getExceptions(); }

	virtual int queryClientStatus()
	{ return CSoapResponseBinding::getRpcState(); }

	virtual void noteException(IException& e)
	{  CSoapResponseBinding::noteException(e); }

	IArrayOf<IConstWUDetailsMetaProperty> & getProperties();
	StringArray & getScopeTypes();
	StringArray & getMeasures();
	IArrayOf<IConstWUDetailsActivityInfo> & getActivities();
	void setProperties(IArrayOf<IEspWUDetailsMetaProperty> &val);
 void setProperties(IArrayOf<IConstWUDetailsMetaProperty> &val);
	void setScopeTypes(StringArray &val);
	void setMeasures(StringArray &val);
	void setActivities(IArrayOf<IEspWUDetailsActivityInfo> &val);
 void setActivities(IArrayOf<IConstWUDetailsActivityInfo> &val);
};

class CWUEclDefinitionActionResult : public CSoapComplexType,
   implements IEspWUEclDefinitionActionResult,
   implements IClientWUEclDefinitionActionResult
{
protected:
	SoapStringParam m_EclDefinition;
	SoapStringParam m_Action;
	SoapStringParam m_WUID;
	SoapStringParam m_QueryID;
	SoapStringParam m_Result;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CWUEclDefinitionActionResult(const char *serviceName, const char *bcompat);

	CWUEclDefinitionActionResult(const char *serviceName, IRpcMessageBinding *init=NULL);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "WUEclDefinitionActionResult";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CWUEclDefinitionActionResult &from);

	void copy(IConstWUEclDefinitionActionResult &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstWUEclDefinitionActionResult &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	const char * getEclDefinition();
	const char * getAction();
	const char * getWUID();
	const char * getQueryID();
	const char * getResult();
	void setEclDefinition(const char * val);
	void setAction(const char * val);
	void setWUID(const char * val);
	void setQueryID(const char * val);
	void setResult(const char * val);
};

class CWUEclDefinitionActionRequest : public CSoapRequestBinding,
   implements IEspWUEclDefinitionActionRequest,
   implements IClientWUEclDefinitionActionRequest
{
protected:
	SoapStringArray m_EclDefinitions;
	CXEclDefinitionActions m_ActionType;
	SoapStringParam m_Target;
	SoapStringParam m_RemoteDali;
	SoapStringParam m_SourceProcess;
	SoapStringParam m_Priority;
	SoapStringParam m_Comment;
	SoapStringParam m_MemoryLimit;
	SoapParam<bool> m_DeletePrevious;
	SoapParam<bool> m_SuspendPrevious;
	SoapParam<bool> m_NoActivate;
	SoapParam<bool> m_NoReload;
	SoapParam<bool> m_DontCopyFiles;
	SoapParam<bool> m_AllowForeign;
	SoapParam<bool> m_UpdateDfs;
	SoapParam<bool> m_UpdateSuperfiles;
	SoapParam<bool> m_UpdateCloneFrom;
	SoapParam<bool> m_DontAppendCluster;
	SoapParam<int> m_MsToWait;
	SoapParam<int> m_TimeLimit;
	SoapParam<int> m_WarnTimeLimit;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CWUEclDefinitionActionRequest(const char *serviceName, const char *bcompat);

	CWUEclDefinitionActionRequest(const char *serviceName, IRpcMessageBinding *init=NULL);
	CWUEclDefinitionActionRequest(const char *serviceName, IRpcMessage* rpcmsg);
	CWUEclDefinitionActionRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	IEspClientRpcSettings &rpc(){return *static_cast<IEspClientRpcSettings*>(this);}


	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "WUEclDefinitionActionRequest";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CWUEclDefinitionActionRequest &from);

	void copy(IConstWUEclDefinitionActionRequest &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstWUEclDefinitionActionRequest &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	StringArray & getEclDefinitions();
	CEclDefinitionActions getActionType();
	const char* getActionTypeAsString();
	const char * getTarget();
	const char * getRemoteDali();
	const char * getSourceProcess();
	const char * getPriority();
	const char * getComment();
	const char * getMemoryLimit();
bool getDeletePrevious_isNull();
	bool getDeletePrevious();
bool getSuspendPrevious_isNull();
	bool getSuspendPrevious();
bool getNoActivate_isNull();
	bool getNoActivate();
bool getNoReload_isNull();
	bool getNoReload();
bool getDontCopyFiles_isNull();
	bool getDontCopyFiles();
bool getAllowForeign_isNull();
	bool getAllowForeign();
bool getUpdateDfs_isNull();
	bool getUpdateDfs();
bool getUpdateSuperfiles_isNull();
	bool getUpdateSuperfiles();
bool getUpdateCloneFrom_isNull();
	bool getUpdateCloneFrom();
bool getDontAppendCluster_isNull();
	bool getDontAppendCluster();
bool getMsToWait_isNull();
	int getMsToWait();
bool getTimeLimit_isNull();
	int getTimeLimit();
bool getWarnTimeLimit_isNull();
	int getWarnTimeLimit();
	void setEclDefinitions(StringArray &val);
	void setActionType(CEclDefinitionActions val);
void setActionType(const char* val);
	void setTarget(const char * val);
	void setRemoteDali(const char * val);
	void setSourceProcess(const char * val);
	void setPriority(const char * val);
	void setComment(const char * val);
	void setMemoryLimit(const char * val);
	void setDeletePrevious_null();
	void setDeletePrevious(bool val);
	void setSuspendPrevious_null();
	void setSuspendPrevious(bool val);
	void setNoActivate_null();
	void setNoActivate(bool val);
	void setNoReload_null();
	void setNoReload(bool val);
	void setDontCopyFiles_null();
	void setDontCopyFiles(bool val);
	void setAllowForeign_null();
	void setAllowForeign(bool val);
	void setUpdateDfs_null();
	void setUpdateDfs(bool val);
	void setUpdateSuperfiles_null();
	void setUpdateSuperfiles(bool val);
	void setUpdateCloneFrom_null();
	void setUpdateCloneFrom(bool val);
	void setDontAppendCluster_null();
	void setDontAppendCluster(bool val);
	void setMsToWait_null();
	void setMsToWait(int val);
	void setTimeLimit_null();
	void setTimeLimit(int val);
	void setWarnTimeLimit_null();
	void setWarnTimeLimit(int val);
};

class CWUEclDefinitionActionResponse : public CSoapResponseBinding,
   implements IEspWUEclDefinitionActionResponse,
   implements IClientWUEclDefinitionActionResponse
{
protected:
	SoapStructArrayParam<IConstWUEclDefinitionActionResult, CWUEclDefinitionActionResult> m_ActionResults;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CWUEclDefinitionActionResponse(const char *serviceName, const char *bcompat);

	CWUEclDefinitionActionResponse(const char *serviceName, IRpcMessageBinding *init=NULL);
	CWUEclDefinitionActionResponse(const char *serviceName, IRpcMessage* rpcmsg);
	CWUEclDefinitionActionResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "WUEclDefinitionActionResponse";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CWUEclDefinitionActionResponse &from);

	void copy(IConstWUEclDefinitionActionResponse &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstWUEclDefinitionActionResponse &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	virtual void setRedirectUrl(const char *url)
	{ CSoapResponseBinding::setRedirectUrl(url); }

	virtual const IMultiException& getExceptions()
	{ return CSoapResponseBinding::getExceptions(); }

	virtual int queryClientStatus()
	{ return CSoapResponseBinding::getRpcState(); }

	virtual void noteException(IException& e)
	{  CSoapResponseBinding::noteException(e); }

	IArrayOf<IConstWUEclDefinitionActionResult> & getActionResults();
	void setActionResults(IArrayOf<IEspWUEclDefinitionActionResult> &val);
 void setActionResults(IArrayOf<IConstWUEclDefinitionActionResult> &val);
};

class CWsWorkunitsPingRequest : public CSoapRequestBinding,
   implements IEspWsWorkunitsPingRequest,
   implements IClientWsWorkunitsPingRequest
{
protected:

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CWsWorkunitsPingRequest(const char *serviceName, const char *bcompat);

	CWsWorkunitsPingRequest(const char *serviceName, IRpcMessageBinding *init=NULL);
	CWsWorkunitsPingRequest(const char *serviceName, IRpcMessage* rpcmsg);
	CWsWorkunitsPingRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	IEspClientRpcSettings &rpc(){return *static_cast<IEspClientRpcSettings*>(this);}


	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "WsWorkunitsPingRequest";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CWsWorkunitsPingRequest &from);

	void copy(IConstWsWorkunitsPingRequest &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstWsWorkunitsPingRequest &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

};

class CWsWorkunitsPingResponse : public CSoapResponseBinding,
   implements IEspWsWorkunitsPingResponse,
   implements IClientWsWorkunitsPingResponse
{
protected:

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CWsWorkunitsPingResponse(const char *serviceName, const char *bcompat);

	CWsWorkunitsPingResponse(const char *serviceName, IRpcMessageBinding *init=NULL);
	CWsWorkunitsPingResponse(const char *serviceName, IRpcMessage* rpcmsg);
	CWsWorkunitsPingResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "WsWorkunitsPingResponse";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CWsWorkunitsPingResponse &from);

	void copy(IConstWsWorkunitsPingResponse &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstWsWorkunitsPingResponse &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	virtual void setRedirectUrl(const char *url)
	{ CSoapResponseBinding::setRedirectUrl(url); }

	virtual const IMultiException& getExceptions()
	{ return CSoapResponseBinding::getExceptions(); }

	virtual int queryClientStatus()
	{ return CSoapResponseBinding::getRpcState(); }

	virtual void noteException(IException& e)
	{  CSoapResponseBinding::noteException(e); }

};

class CWsWorkunits : public CInterface,
	implements IEspWsWorkunits
{
private:
	IEspContainer* m_container;
public:
	IMPLEMENT_IINTERFACE;

	CWsWorkunits(){}
	virtual ~CWsWorkunits(){}
	virtual void init(IPropertyTree *cfg, const char *process, const char *service)
	{
	}
	virtual bool init(const char * service, const char * type, IPropertyTree * cfg, const char * process)
	{
		return true;
	}
	virtual void setContainer(IEspContainer *c)
	{
		m_container = c;
	}
	virtual IEspContainer *queryContainer()
	{
		return m_container;
	}
	virtual const char* getServiceType(){return "WsWorkunits";}

	virtual bool unsubscribeServiceFromDali(){return false;}

	virtual bool subscribeServiceToDali(){return false;}

	virtual bool detachServiceFromDali(){return false;}

	virtual bool attachServiceToDali(){return false;}

	virtual bool canDetachFromDali(){return false;}

	//bool onGVCAjaxGraph(IEspContext &context, IEspGVCAjaxGraphRequest &req, IEspGVCAjaxGraphResponse &resp)
	//{
		//return false;
	//}
	bool onPing(IEspContext &context, IEspWsWorkunitsPingRequest &req, IEspWsWorkunitsPingResponse &resp)
	{
		return true;
	}
	//bool onWUAbort(IEspContext &context, IEspWUAbortRequest &req, IEspWUAbortResponse &resp)
	//{
		//return false;
	//}
	//bool onWUAction(IEspContext &context, IEspWUActionRequest &req, IEspWUActionResponse &resp)
	//{
		//return false;
	//}
	//bool onWUAddLocalFileToWorkunit(IEspContext &context, IEspWUAddLocalFileToWorkunitRequest &req, IEspWUAddLocalFileToWorkunitResponse &resp)
	//{
		//return false;
	//}
	//bool onWUCDebug(IEspContext &context, IEspWUDebugRequest &req, IEspWUDebugResponse &resp)
	//{
		//return false;
	//}
	//bool onWUCheckFeatures(IEspContext &context, IEspWUCheckFeaturesRequest &req, IEspWUCheckFeaturesResponse &resp)
	//{
		//return false;
	//}
	//bool onWUClusterJobQueueLOG(IEspContext &context, IEspWUClusterJobQueueLOGRequest &req, IEspWUClusterJobQueueLOGResponse &resp)
	//{
		//return false;
	//}
	//bool onWUClusterJobQueueXLS(IEspContext &context, IEspWUClusterJobQueueXLSRequest &req, IEspWUClusterJobQueueXLSResponse &resp)
	//{
		//return false;
	//}
	//bool onWUClusterJobSummaryXLS(IEspContext &context, IEspWUClusterJobSummaryXLSRequest &req, IEspWUClusterJobSummaryXLSResponse &resp)
	//{
		//return false;
	//}
	//bool onWUClusterJobXLS(IEspContext &context, IEspWUClusterJobXLSRequest &req, IEspWUClusterJobXLSResponse &resp)
	//{
		//return false;
	//}
	//bool onWUCompileECL(IEspContext &context, IEspWUCompileECLRequest &req, IEspWUCompileECLResponse &resp)
	//{
		//return false;
	//}
	//bool onWUCopyLogicalFiles(IEspContext &context, IEspWUCopyLogicalFilesRequest &req, IEspWUCopyLogicalFilesResponse &resp)
	//{
		//return false;
	//}
	//bool onWUCopyQuerySet(IEspContext &context, IEspWUCopyQuerySetRequest &req, IEspWUCopyQuerySetResponse &resp)
	//{
		//return false;
	//}
	//bool onWUCreate(IEspContext &context, IEspWUCreateRequest &req, IEspWUCreateResponse &resp)
	//{
		//return false;
	//}
	//bool onWUCreateAndUpdate(IEspContext &context, IEspWUUpdateRequest &req, IEspWUUpdateResponse &resp)
	//{
		//return false;
	//}
	//bool onWUCreateZAPInfo(IEspContext &context, IEspWUCreateZAPInfoRequest &req, IEspWUCreateZAPInfoResponse &resp)
	//{
		//return false;
	//}
	//bool onWUDelete(IEspContext &context, IEspWUDeleteRequest &req, IEspWUDeleteResponse &resp)
	//{
		//return false;
	//}
	//bool onWUDeployWorkunit(IEspContext &context, IEspWUDeployWorkunitRequest &req, IEspWUDeployWorkunitResponse &resp)
	//{
		//return false;
	//}
	//bool onWUDetails(IEspContext &context, IEspWUDetailsRequest &req, IEspWUDetailsResponse &resp)
	//{
		//return false;
	//}
	//bool onWUDetailsMeta(IEspContext &context, IEspWUDetailsMetaRequest &req, IEspWUDetailsMetaResponse &resp)
	//{
		//return false;
	//}
	//bool onWUEclDefinitionAction(IEspContext &context, IEspWUEclDefinitionActionRequest &req, IEspWUEclDefinitionActionResponse &resp)
	//{
		//return false;
	//}
	//bool onWUExport(IEspContext &context, IEspWUExportRequest &req, IEspWUExportResponse &resp)
	//{
		//return false;
	//}
	//bool onWUFile(IEspContext &context, IEspWULogFileRequest &req, IEspWULogFileResponse &resp)
	//{
		//return false;
	//}
	//bool onWUFullResult(IEspContext &context, IEspWUFullResultRequest &req, IEspWUFullResultResponse &resp)
	//{
		//return false;
	//}
	//bool onWUGVCGraphInfo(IEspContext &context, IEspWUGVCGraphInfoRequest &req, IEspWUGVCGraphInfoResponse &resp)
	//{
		//return false;
	//}
	//bool onWUGetArchiveFile(IEspContext &context, IEspWUGetArchiveFileRequest &req, IEspWUGetArchiveFileResponse &resp)
	//{
		//return false;
	//}
	//bool onWUGetDependancyTrees(IEspContext &context, IEspWUGetDependancyTreesRequest &req, IEspWUGetDependancyTreesResponse &resp)
	//{
		//return false;
	//}
	//bool onWUGetGraph(IEspContext &context, IEspWUGetGraphRequest &req, IEspWUGetGraphResponse &resp)
	//{
		//return false;
	//}
	//bool onWUGetGraphNameAndTypes(IEspContext &context, IEspWUGetGraphNameAndTypesRequest &req, IEspWUGetGraphNameAndTypesResponse &resp)
	//{
		//return false;
	//}
	//bool onWUGetNumFileToCopy(IEspContext &context, IEspWUGetNumFileToCopyRequest &req, IEspWUGetNumFileToCopyResponse &resp)
	//{
		//return false;
	//}
	//bool onWUGetStats(IEspContext &context, IEspWUGetStatsRequest &req, IEspWUGetStatsResponse &resp)
	//{
		//return false;
	//}
	//bool onWUGetThorJobList(IEspContext &context, IEspWUGetThorJobListRequest &req, IEspWUGetThorJobListResponse &resp)
	//{
		//return false;
	//}
	//bool onWUGetThorJobQueue(IEspContext &context, IEspWUGetThorJobQueueRequest &req, IEspWUGetThorJobQueueResponse &resp)
	//{
		//return false;
	//}
	//bool onWUGetZAPInfo(IEspContext &context, IEspWUGetZAPInfoRequest &req, IEspWUGetZAPInfoResponse &resp)
	//{
		//return false;
	//}
	//bool onWUGraphInfo(IEspContext &context, IEspWUGraphInfoRequest &req, IEspWUGraphInfoResponse &resp)
	//{
		//return false;
	//}
	//bool onWUGraphTiming(IEspContext &context, IEspWUGraphTimingRequest &req, IEspWUGraphTimingResponse &resp)
	//{
		//return false;
	//}
	//bool onWUInfo(IEspContext &context, IEspWUInfoRequest &req, IEspWUInfoResponse &resp)
	//{
		//return false;
	//}
	//bool onWUInfoDetails(IEspContext &context, IEspWUInfoRequest &req, IEspWUInfoResponse &resp)
	//{
		//return false;
	//}
	//bool onWUJobList(IEspContext &context, IEspWUJobListRequest &req, IEspWUJobListResponse &resp)
	//{
		//return false;
	//}
	//bool onWULightWeightQuery(IEspContext &context, IEspWULightWeightQueryRequest &req, IEspWULightWeightQueryResponse &resp)
	//{
		//return false;
	//}
	//bool onWUListArchiveFiles(IEspContext &context, IEspWUListArchiveFilesRequest &req, IEspWUListArchiveFilesResponse &resp)
	//{
		//return false;
	//}
	//bool onWUListLocalFileRequired(IEspContext &context, IEspWUListLocalFileRequiredRequest &req, IEspWUListLocalFileRequiredResponse &resp)
	//{
		//return false;
	//}
	//bool onWUListQueries(IEspContext &context, IEspWUListQueriesRequest &req, IEspWUListQueriesResponse &resp)
	//{
		//return false;
	//}
	//bool onWUListQueriesUsingFile(IEspContext &context, IEspWUListQueriesUsingFileRequest &req, IEspWUListQueriesUsingFileResponse &resp)
	//{
		//return false;
	//}
	//bool onWUMultiQuerysetDetails(IEspContext &context, IEspWUMultiQuerySetDetailsRequest &req, IEspWUMultiQuerySetDetailsResponse &resp)
	//{
		//return false;
	//}
	//bool onWUProcessGraph(IEspContext &context, IEspWUProcessGraphRequest &req, IEspWUProcessGraphResponse &resp)
	//{
		//return false;
	//}
	//bool onWUProtect(IEspContext &context, IEspWUProtectRequest &req, IEspWUProtectResponse &resp)
	//{
		//return false;
	//}
	//bool onWUPublishWorkunit(IEspContext &context, IEspWUPublishWorkunitRequest &req, IEspWUPublishWorkunitResponse &resp)
	//{
		//return false;
	//}
	//bool onWUPushEvent(IEspContext &context, IEspWUPushEventRequest &req, IEspWUPushEventResponse &resp)
	//{
		//return false;
	//}
	//bool onWUQuery(IEspContext &context, IEspWUQueryRequest &req, IEspWUQueryResponse &resp)
	//{
		//return false;
	//}
	//bool onWUQueryConfig(IEspContext &context, IEspWUQueryConfigRequest &req, IEspWUQueryConfigResponse &resp)
	//{
		//return false;
	//}
	//bool onWUQueryDetails(IEspContext &context, IEspWUQueryDetailsRequest &req, IEspWUQueryDetailsResponse &resp)
	//{
		//return false;
	//}
	//bool onWUQueryFiles(IEspContext &context, IEspWUQueryFilesRequest &req, IEspWUQueryFilesResponse &resp)
	//{
		//return false;
	//}
	//bool onWUQueryGetGraph(IEspContext &context, IEspWUQueryGetGraphRequest &req, IEspWUQueryGetGraphResponse &resp)
	//{
		//return false;
	//}
	//bool onWUQueryGetSummaryStats(IEspContext &context, IEspWUQueryGetSummaryStatsRequest &req, IEspWUQueryGetSummaryStatsResponse &resp)
	//{
		//return false;
	//}
	//bool onWUQuerysetAliasAction(IEspContext &context, IEspWUQuerySetAliasActionRequest &req, IEspWUQuerySetAliasActionResponse &resp)
	//{
		//return false;
	//}
	//bool onWUQuerysetCopyQuery(IEspContext &context, IEspWUQuerySetCopyQueryRequest &req, IEspWUQuerySetCopyQueryResponse &resp)
	//{
		//return false;
	//}
	//bool onWUQuerysetDetails(IEspContext &context, IEspWUQuerySetDetailsRequest &req, IEspWUQuerySetDetailsResponse &resp)
	//{
		//return false;
	//}
	//bool onWUQuerysetExport(IEspContext &context, IEspWUQuerysetExportRequest &req, IEspWUQuerysetExportResponse &resp)
	//{
		//return false;
	//}
	//bool onWUQuerysetImport(IEspContext &context, IEspWUQuerysetImportRequest &req, IEspWUQuerysetImportResponse &resp)
	//{
		//return false;
	//}
	//bool onWUQuerysetQueryAction(IEspContext &context, IEspWUQuerySetQueryActionRequest &req, IEspWUQuerySetQueryActionResponse &resp)
	//{
		//return false;
	//}
	//bool onWUQuerysets(IEspContext &context, IEspWUQuerysetsRequest &req, IEspWUQuerysetsResponse &resp)
	//{
		//return false;
	//}
	//bool onWURecreateQuery(IEspContext &context, IEspWURecreateQueryRequest &req, IEspWURecreateQueryResponse &resp)
	//{
		//return false;
	//}
	//bool onWUResubmit(IEspContext &context, IEspWUResubmitRequest &req, IEspWUResubmitResponse &resp)
	//{
		//return false;
	//}
	//bool onWUResult(IEspContext &context, IEspWUResultRequest &req, IEspWUResultResponse &resp)
	//{
		//return false;
	//}
	//bool onWUResultBin(IEspContext &context, IEspWUResultBinRequest &req, IEspWUResultBinResponse &resp)
	//{
		//return false;
	//}
	//bool onWUResultSummary(IEspContext &context, IEspWUResultSummaryRequest &req, IEspWUResultSummaryResponse &resp)
	//{
		//return false;
	//}
	//bool onWUResultView(IEspContext &context, IEspWUResultViewRequest &req, IEspWUResultViewResponse &resp)
	//{
		//return false;
	//}
	//bool onWURun(IEspContext &context, IEspWURunRequest &req, IEspWURunResponse &resp)
	//{
		//return false;
	//}
	//bool onWUSchedule(IEspContext &context, IEspWUScheduleRequest &req, IEspWUScheduleResponse &resp)
	//{
		//return false;
	//}
	//bool onWUShowScheduled(IEspContext &context, IEspWUShowScheduledRequest &req, IEspWUShowScheduledResponse &resp)
	//{
		//return false;
	//}
	//bool onWUSubmit(IEspContext &context, IEspWUSubmitRequest &req, IEspWUSubmitResponse &resp)
	//{
		//return false;
	//}
	//bool onWUSyntaxCheckECL(IEspContext &context, IEspWUSyntaxCheckRequest &req, IEspWUSyntaxCheckResponse &resp)
	//{
		//return false;
	//}
	//bool onWUUpdate(IEspContext &context, IEspWUUpdateRequest &req, IEspWUUpdateResponse &resp)
	//{
		//return false;
	//}
	//bool onWUUpdateQueryEntry(IEspContext &context, IEspWUUpdateQueryEntryRequest &req, IEspWUUpdateQueryEntryResponse &resp)
	//{
		//return false;
	//}
	//bool onWUWaitCompiled(IEspContext &context, IEspWUWaitRequest &req, IEspWUWaitResponse &resp)
	//{
		//return false;
	//}
	//bool onWUWaitComplete(IEspContext &context, IEspWUWaitRequest &req, IEspWUWaitResponse &resp)
	//{
		//return false;
	//}
};





class CWsWorkunitsSoapBinding : public CHttpSoapBinding
{
public:
	CWsWorkunitsSoapBinding(http_soap_log_level level=hsl_none);
	CWsWorkunitsSoapBinding(IPropertyTree* cfg, const char *bindname=NULL, const char *procname=NULL, http_soap_log_level level=hsl_none);
	virtual void init_strings();
	virtual unsigned getCacheMethodCount(){return m_cacheMethodCount;}
	virtual int processRequest(IRpcMessage* rpc_call, IRpcMessage* rpc_response);
	int getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &content, const char *service, const char *method, bool mda);
	virtual int getMethodHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &page, bool bIncludeFormTag);
	int getQualifiedNames(IEspContext& ctx, MethodInfoArray & methods);
	StringBuffer & getServiceName(StringBuffer &resp);
	bool isValidServiceName(IEspContext &context, const char *name);
	bool qualifyMethodName(IEspContext &context, const char *methname, StringBuffer *methQName);
	bool qualifyServiceName(IEspContext &context, const char *servname, const char *methname, StringBuffer &servQName, StringBuffer *methQName);
	virtual int onGetFile(IEspContext &context, CHttpRequest* request, CHttpResponse* response, const char *pathex);
	virtual int onGetForm(IEspContext &context, CHttpRequest* request, CHttpResponse* response, const char *service, const char *method);
	virtual int onGetXForm(IEspContext &context, CHttpRequest* request, CHttpResponse* response, const char *service, const char *method);
	virtual bool supportGeneratedForms(){return false;}
	virtual int onGetService(IEspContext &context, CHttpRequest* request, CHttpResponse* response, const char *service, const char *method, const char *pathex);
	virtual IRpcRequestBinding *createReqBinding(IEspContext &context, IHttpMessage* request, const char *service, const char *method);
	virtual int onGetInstantQuery(IEspContext &context, CHttpRequest* request, CHttpResponse* response, const char *service, const char *method);
	void setXslProcessor(IInterface *xslp_)
	{
		IXslProcessor *ixslp = dynamic_cast<IXslProcessor *>(xslp_);
		if (!ixslp)
			xslp.clear();
		else
			xslp.set(ixslp);
	}
private:
	Owned<IXslProcessor> xslp;
	void xslTransform(const char* xml, const char* xslFile, StringBuffer& output, IProperties *params)
	{
		if (xslp)
		{
			Owned<IXslTransform> xform = xslp->createXslTransform();
			StringBuffer xslpath;
			if (!strnicmp(xslFile, "/esp/xslt/", 10))
				if (!checkFileExists(xslpath.append(getCFD()).append("smc_xslt/").append(xslFile+10).str()) && !checkFileExists(xslpath.append(getCFD()).append("xslt/").append(xslFile+10).str()))
					return;
			xform->loadXslFromFile((xslpath.length()) ? xslpath.str() : xslFile);
			xform->setXmlSource(xml, strlen(xml)+1);
			if (params) xform->copyParameters(params);
			xform->transform(output.clear());
		}
	}
	unsigned m_cacheMethodCount = 0;
};



class CClientWsWorkunits : public CInterface,
	implements IClientWsWorkunits
{
protected:
	StringBuffer soap_proxy;
	StringBuffer soap_url;
	StringBuffer soap_userid;
	StringBuffer soap_password;
	StringBuffer soap_realm;
	StringBuffer soap_action;
	long soap_reqid = 0;

public:
	IMPLEMENT_IINTERFACE;

	CClientWsWorkunits()
	{
		soap_reqid=0;
			soap_action.append("WsWorkunits");
			soap_action.append("?ver_=").append("1.74");
	}
	virtual ~CClientWsWorkunits(){}
	virtual void setProxyAddress(const char *address)
	{
		soap_proxy.set(address);
	}
	virtual void addServiceUrl(const char *url)
	{
		soap_url.set(url);
	}
	virtual void removeServiceUrl(const char *url)
	{
	}
	virtual void setUsernameToken(const char *userid,const char *password,const char *realm)
	{
		 soap_userid.set(userid);
		 soap_password.set(password);
		 soap_realm.set(realm);
	}
	virtual void setAction(const char *action)
	{
		soap_action.set(action);
	}

	virtual IClientGVCAjaxGraphRequest * createGVCAjaxGraphRequest();
	virtual IClientGVCAjaxGraphResponse * GVCAjaxGraph(IClientGVCAjaxGraphRequest *request);
	virtual void async_GVCAjaxGraph(IClientGVCAjaxGraphRequest *request, IClientWsWorkunitsEvents *events,IInterface* state=0);

	virtual IClientGVCAjaxGraphResponse *GVCAjaxGraphFn(const char * Name_, const char * GraphName_, int SubGraphId_, bool SubGraphOnly_);

	virtual IClientWsWorkunitsPingRequest * createPingRequest();
	virtual IClientWsWorkunitsPingResponse * Ping(IClientWsWorkunitsPingRequest *request);
	virtual void async_Ping(IClientWsWorkunitsPingRequest *request, IClientWsWorkunitsEvents *events,IInterface* state=0);

	virtual IClientWsWorkunitsPingResponse *PingFn();

	virtual IClientWUAbortRequest * createWUAbortRequest();
	virtual IClientWUAbortResponse * WUAbort(IClientWUAbortRequest *request);
	virtual void async_WUAbort(IClientWUAbortRequest *request, IClientWsWorkunitsEvents *events,IInterface* state=0);

	virtual IClientWUAbortResponse *WUAbortFn(StringArray &Wuids_, int BlockTillFinishTimer_);

	virtual IClientWUActionRequest * createWUActionRequest();
	virtual IClientWUActionResponse * WUAction(IClientWUActionRequest *request);
	virtual void async_WUAction(IClientWUActionRequest *request, IClientWsWorkunitsEvents *events,IInterface* state=0);

	virtual IClientWUActionResponse *WUActionFn(StringArray &Wuids_, const char * ActionType_, CECLWUActions WUActionType_, const char * Cluster_, const char * Owner_, const char * State_, const char * StartDate_, const char * EndDate_, const char * ECL_, const char * Jobname_, const char * Test_, const char * CurrentPage_, const char * PageSize_, const char * Sortby_, bool Descending_, const char * EventServer_, const char * EventName_, const char * PageFrom_, int BlockTillFinishTimer_);

	virtual IClientWUAddLocalFileToWorkunitRequest * createWUAddLocalFileToWorkunitRequest();
	virtual IClientWUAddLocalFileToWorkunitResponse * WUAddLocalFileToWorkunit(IClientWUAddLocalFileToWorkunitRequest *request);
	virtual void async_WUAddLocalFileToWorkunit(IClientWUAddLocalFileToWorkunitRequest *request, IClientWsWorkunitsEvents *events,IInterface* state=0);

	virtual IClientWUAddLocalFileToWorkunitResponse *WUAddLocalFileToWorkunitFn(const char * Wuid_, const char * Name_, const char * Val_, const char * DefVal_, int Type_, int Length_);

	virtual IClientWUDebugRequest * createWUCDebugRequest();
	virtual IClientWUDebugResponse * WUCDebug(IClientWUDebugRequest *request);
	virtual void async_WUCDebug(IClientWUDebugRequest *request, IClientWsWorkunitsEvents *events,IInterface* state=0);

	virtual IClientWUDebugResponse *WUCDebugFn(const char * Wuid_, const char * Command_);

	virtual IClientWUCheckFeaturesRequest * createWUCheckFeaturesRequest();
	virtual IClientWUCheckFeaturesResponse * WUCheckFeatures(IClientWUCheckFeaturesRequest *request);
	virtual void async_WUCheckFeatures(IClientWUCheckFeaturesRequest *request, IClientWsWorkunitsEvents *events,IInterface* state=0);

	virtual IClientWUCheckFeaturesResponse *WUCheckFeaturesFn();

	virtual IClientWUClusterJobQueueLOGRequest * createWUClusterJobQueueLOGRequest();
	virtual IClientWUClusterJobQueueLOGResponse * WUClusterJobQueueLOG(IClientWUClusterJobQueueLOGRequest *request);
	virtual void async_WUClusterJobQueueLOG(IClientWUClusterJobQueueLOGRequest *request, IClientWsWorkunitsEvents *events,IInterface* state=0);

	virtual IClientWUClusterJobQueueLOGResponse *WUClusterJobQueueLOGFn(const char * Cluster_, const char * StartDate_, const char * EndDate_);

	virtual IClientWUClusterJobQueueXLSRequest * createWUClusterJobQueueXLSRequest();
	virtual IClientWUClusterJobQueueXLSResponse * WUClusterJobQueueXLS(IClientWUClusterJobQueueXLSRequest *request);
	virtual void async_WUClusterJobQueueXLS(IClientWUClusterJobQueueXLSRequest *request, IClientWsWorkunitsEvents *events,IInterface* state=0);

	virtual IClientWUClusterJobQueueXLSResponse *WUClusterJobQueueXLSFn(const char * Cluster_, const char * StartDate_, const char * EndDate_, const char * ShowType_);

	virtual IClientWUClusterJobSummaryXLSRequest * createWUClusterJobSummaryXLSRequest();
	virtual IClientWUClusterJobSummaryXLSResponse * WUClusterJobSummaryXLS(IClientWUClusterJobSummaryXLSRequest *request);
	virtual void async_WUClusterJobSummaryXLS(IClientWUClusterJobSummaryXLSRequest *request, IClientWsWorkunitsEvents *events,IInterface* state=0);

	virtual IClientWUClusterJobSummaryXLSResponse *WUClusterJobSummaryXLSFn(const char * Cluster_, const char * StartDate_, const char * EndDate_, bool ShowAll_, const char * BusinessStartTime_, const char * BusinessEndTime_);

	virtual IClientWUClusterJobXLSRequest * createWUClusterJobXLSRequest();
	virtual IClientWUClusterJobXLSResponse * WUClusterJobXLS(IClientWUClusterJobXLSRequest *request);
	virtual void async_WUClusterJobXLS(IClientWUClusterJobXLSRequest *request, IClientWsWorkunitsEvents *events,IInterface* state=0);

	virtual IClientWUClusterJobXLSResponse *WUClusterJobXLSFn(const char * Cluster_, const char * StartDate_, const char * EndDate_, bool ShowAll_, const char * BusinessStartTime_, const char * BusinessEndTime_);

	virtual IClientWUCompileECLRequest * createWUCompileECLRequest();
	virtual IClientWUCompileECLResponse * WUCompileECL(IClientWUCompileECLRequest *request);
	virtual void async_WUCompileECL(IClientWUCompileECLRequest *request, IClientWsWorkunitsEvents *events,IInterface* state=0);

	virtual IClientWUCompileECLResponse *WUCompileECLFn(const char * ECL_, const char * ModuleName_, const char * AttributeName_, const char * Queue_, const char * Cluster_, const char * Snapshot_, bool IncludeDependencies_, bool IncludeComplexity_, int TimeToWait_);

	virtual IClientWUCopyLogicalFilesRequest * createWUCopyLogicalFilesRequest();
	virtual IClientWUCopyLogicalFilesResponse * WUCopyLogicalFiles(IClientWUCopyLogicalFilesRequest *request);
	virtual void async_WUCopyLogicalFiles(IClientWUCopyLogicalFilesRequest *request, IClientWsWorkunitsEvents *events,IInterface* state=0);

	virtual IClientWUCopyLogicalFilesResponse *WUCopyLogicalFilesFn(const char * Wuid_, const char * Cluster_, bool CopyLocal_);

	virtual IClientWUCopyQuerySetRequest * createWUCopyQuerySetRequest();
	virtual IClientWUCopyQuerySetResponse * WUCopyQuerySet(IClientWUCopyQuerySetRequest *request);
	virtual void async_WUCopyQuerySet(IClientWUCopyQuerySetRequest *request, IClientWsWorkunitsEvents *events,IInterface* state=0);

	virtual IClientWUCopyQuerySetResponse *WUCopyQuerySetFn(const char * Source_, const char * Target_, bool ActiveOnly_, bool CloneActiveState_, bool AllowForeignFiles_, const char * DfsServer_, bool CopyFiles_, bool OverwriteDfs_, const char * SourceProcess_, bool UpdateSuperFiles_, bool UpdateCloneFrom_, bool AppendCluster_, bool IncludeFileErrors_);

	virtual IClientWUCreateRequest * createWUCreateRequest();
	virtual IClientWUCreateResponse * WUCreate(IClientWUCreateRequest *request);
	virtual void async_WUCreate(IClientWUCreateRequest *request, IClientWsWorkunitsEvents *events,IInterface* state=0);

	virtual IClientWUCreateResponse *WUCreateFn();

	virtual IClientWUUpdateRequest * createWUCreateAndUpdateRequest();
	virtual IClientWUUpdateResponse * WUCreateAndUpdate(IClientWUUpdateRequest *request);
	virtual void async_WUCreateAndUpdate(IClientWUUpdateRequest *request, IClientWsWorkunitsEvents *events,IInterface* state=0);

	virtual IClientWUUpdateResponse *WUCreateAndUpdateFn(const char * Wuid_, int State_, int StateOrig_, const char * Jobname_, const char * JobnameOrig_, const char * QueryText_, int Action_, const char * Description_, const char * DescriptionOrig_, bool AddDrilldownFields_, int ResultLimit_, bool Protected_, bool ProtectedOrig_, int PriorityClass_, int PriorityLevel_, const char * Scope_, const char * ScopeOrig_, const char * ClusterSelection_, const char * ClusterOrig_, const char * XmlParams_, const char * ThorSlaveIP_, const char * QueryMainDefinition_, IArrayOf<IConstDebugValue> &DebugValues_, IArrayOf<IConstApplicationValue> &ApplicationValues_);

	virtual IClientWUCreateZAPInfoRequest * createWUCreateZAPInfoRequest();
	virtual IClientWUCreateZAPInfoResponse * WUCreateZAPInfo(IClientWUCreateZAPInfoRequest *request);
	virtual void async_WUCreateZAPInfo(IClientWUCreateZAPInfoRequest *request, IClientWsWorkunitsEvents *events,IInterface* state=0);

	virtual IClientWUCreateZAPInfoResponse *WUCreateZAPInfoFn(const char * Wuid_, const char * ESPIPAddress_, const char * ThorIPAddress_, const char * BuildVersion_, const char * ProblemDescription_, const char * WhatChanged_, const char * WhereSlow_, const char * Password_, const char * ZAPFileName_, const char * IncludeThorSlaveLog_, const char * ZAPPassword_, bool SendEmail_, bool AttachZAPReportToEmail_, const char * EmailFrom_, const char * EmailSubject_, const char * EmailBody_);

	virtual IClientWUDeleteRequest * createWUDeleteRequest();
	virtual IClientWUDeleteResponse * WUDelete(IClientWUDeleteRequest *request);
	virtual void async_WUDelete(IClientWUDeleteRequest *request, IClientWsWorkunitsEvents *events,IInterface* state=0);

	virtual IClientWUDeleteResponse *WUDeleteFn(StringArray &Wuids_, int BlockTillFinishTimer_);

	virtual IClientWUDeployWorkunitRequest * createWUDeployWorkunitRequest();
	virtual IClientWUDeployWorkunitResponse * WUDeployWorkunit(IClientWUDeployWorkunitRequest *request);
	virtual void async_WUDeployWorkunit(IClientWUDeployWorkunitRequest *request, IClientWsWorkunitsEvents *events,IInterface* state=0);

	virtual IClientWUDeployWorkunitResponse *WUDeployWorkunitFn(const char * Cluster_, const char * Name_, int Wait_, const char * ObjType_, const char * FileName_, const MemoryBuffer & Object_, int ResultLimit_, const char * QueryMainDefinition_, const char * Snapshot_, IArrayOf<IConstNamedValue> &DebugValues_);

	virtual IClientWUDetailsRequest * createWUDetailsRequest();
	virtual IClientWUDetailsResponse * WUDetails(IClientWUDetailsRequest *request);
	virtual void async_WUDetails(IClientWUDetailsRequest *request, IClientWsWorkunitsEvents *events,IInterface* state=0);

	virtual IClientWUDetailsResponse *WUDetailsFn(const char * WUID_, IConstWUScopeFilter &ScopeFilter_, IConstWUNestedFilter &NestedFilter_, IConstWUPropertiesToReturn &PropertiesToReturn_, const char * Filter_, IConstWUScopeOptions &ScopeOptions_, IConstWUPropertyOptions &PropertyOptions_);

	virtual IClientWUDetailsMetaRequest * createWUDetailsMetaRequest();
	virtual IClientWUDetailsMetaResponse * WUDetailsMeta(IClientWUDetailsMetaRequest *request);
	virtual void async_WUDetailsMeta(IClientWUDetailsMetaRequest *request, IClientWsWorkunitsEvents *events,IInterface* state=0);

	virtual IClientWUDetailsMetaResponse *WUDetailsMetaFn();

	virtual IClientWUEclDefinitionActionRequest * createWUEclDefinitionActionRequest();
	virtual IClientWUEclDefinitionActionResponse * WUEclDefinitionAction(IClientWUEclDefinitionActionRequest *request);
	virtual void async_WUEclDefinitionAction(IClientWUEclDefinitionActionRequest *request, IClientWsWorkunitsEvents *events,IInterface* state=0);

	virtual IClientWUEclDefinitionActionResponse *WUEclDefinitionActionFn(StringArray &EclDefinitions_, CEclDefinitionActions ActionType_, const char * Target_, const char * RemoteDali_, const char * SourceProcess_, const char * Priority_, const char * Comment_, const char * MemoryLimit_, bool DeletePrevious_, bool SuspendPrevious_, bool NoActivate_, bool NoReload_, bool DontCopyFiles_, bool AllowForeign_, bool UpdateDfs_, bool UpdateSuperfiles_, bool UpdateCloneFrom_, bool DontAppendCluster_, int MsToWait_, int TimeLimit_, int WarnTimeLimit_);

	virtual IClientWUExportRequest * createWUExportRequest();
	virtual IClientWUExportResponse * WUExport(IClientWUExportRequest *request);
	virtual void async_WUExport(IClientWUExportRequest *request, IClientWsWorkunitsEvents *events,IInterface* state=0);

	virtual IClientWUExportResponse *WUExportFn(const char * Cluster_, const char * Owner_, const char * State_, const char * StartDate_, const char * EndDate_, const char * ECL_, const char * Jobname_);

	virtual IClientWULogFileRequest * createWUFileRequest();
	virtual IClientWULogFileResponse * WUFile(IClientWULogFileRequest *request);
	virtual void async_WUFile(IClientWULogFileRequest *request, IClientWsWorkunitsEvents *events,IInterface* state=0);

	virtual IClientWULogFileResponse *WUFileFn(const char * Name_, const char * Wuid_, const char * Type_, int Option_, const char * SlaveIP_, const char * IPAddress_, const char * Description_, const char * QuerySet_, const char * Query_, const char * Process_, const char * ClusterGroup_, const char * LogDate_, int SlaveNumber_, __int64 SizeLimit_, const char * PlainText_);

	virtual IClientWUFullResultRequest * createWUFullResultRequest();
	virtual IClientWUFullResultResponse * WUFullResult(IClientWUFullResultRequest *request);
	virtual void async_WUFullResult(IClientWUFullResultRequest *request, IClientWsWorkunitsEvents *events,IInterface* state=0);

	virtual IClientWUFullResultResponse *WUFullResultFn(const char * Wuid_, bool NoRootTag_, CWUExceptionSeverity ExceptionSeverity_);

	virtual IClientWUGVCGraphInfoRequest * createWUGVCGraphInfoRequest();
	virtual IClientWUGVCGraphInfoResponse * WUGVCGraphInfo(IClientWUGVCGraphInfoRequest *request);
	virtual void async_WUGVCGraphInfo(IClientWUGVCGraphInfoRequest *request, IClientWsWorkunitsEvents *events,IInterface* state=0);

	virtual IClientWUGVCGraphInfoResponse *WUGVCGraphInfoFn(const char * Wuid_, const char * Name_, const char * GID_, int BatchWU_, int SubgraphId_);

	virtual IClientWUGetArchiveFileRequest * createWUGetArchiveFileRequest();
	virtual IClientWUGetArchiveFileResponse * WUGetArchiveFile(IClientWUGetArchiveFileRequest *request);
	virtual void async_WUGetArchiveFile(IClientWUGetArchiveFileRequest *request, IClientWsWorkunitsEvents *events,IInterface* state=0);

	virtual IClientWUGetArchiveFileResponse *WUGetArchiveFileFn(const char * WUID_, const char * ModuleName_, const char * FileName_, const char * Path_);

	virtual IClientWUGetDependancyTreesRequest * createWUGetDependancyTreesRequest();
	virtual IClientWUGetDependancyTreesResponse * WUGetDependancyTrees(IClientWUGetDependancyTreesRequest *request);
	virtual void async_WUGetDependancyTrees(IClientWUGetDependancyTreesRequest *request, IClientWsWorkunitsEvents *events,IInterface* state=0);

	virtual IClientWUGetDependancyTreesResponse *WUGetDependancyTreesFn(const char * Cluster_, const char * Queue_, const char * Snapshot_, const char * Items_, const char * TimeoutMilliSec_);

	virtual IClientWUGetGraphRequest * createWUGetGraphRequest();
	virtual IClientWUGetGraphResponse * WUGetGraph(IClientWUGetGraphRequest *request);
	virtual void async_WUGetGraph(IClientWUGetGraphRequest *request, IClientWsWorkunitsEvents *events,IInterface* state=0);

	virtual IClientWUGetGraphResponse *WUGetGraphFn(const char * Wuid_, const char * GraphName_, const char * SubGraphId_);

	virtual IClientWUGetGraphNameAndTypesRequest * createWUGetGraphNameAndTypesRequest();
	virtual IClientWUGetGraphNameAndTypesResponse * WUGetGraphNameAndTypes(IClientWUGetGraphNameAndTypesRequest *request);
	virtual void async_WUGetGraphNameAndTypes(IClientWUGetGraphNameAndTypesRequest *request, IClientWsWorkunitsEvents *events,IInterface* state=0);

	virtual IClientWUGetGraphNameAndTypesResponse *WUGetGraphNameAndTypesFn(const char * Wuid_, const char * Type_);

	virtual IClientWUGetNumFileToCopyRequest * createWUGetNumFileToCopyRequest();
	virtual IClientWUGetNumFileToCopyResponse * WUGetNumFileToCopy(IClientWUGetNumFileToCopyRequest *request);
	virtual void async_WUGetNumFileToCopy(IClientWUGetNumFileToCopyRequest *request, IClientWsWorkunitsEvents *events,IInterface* state=0);

	virtual IClientWUGetNumFileToCopyResponse *WUGetNumFileToCopyFn(const char * ClusterName_, __int64 PageSize_, __int64 PageStartFrom_, const char * Sortby_, bool Descending_, __int64 CacheHint_);

	virtual IClientWUGetStatsRequest * createWUGetStatsRequest();
	virtual IClientWUGetStatsResponse * WUGetStats(IClientWUGetStatsRequest *request);
	virtual void async_WUGetStats(IClientWUGetStatsRequest *request, IClientWsWorkunitsEvents *events,IInterface* state=0);

	virtual IClientWUGetStatsResponse *WUGetStatsFn(const char * WUID_, const char * CreatorType_, const char * Creator_, const char * ScopeType_, const char * Scope_, const char * Kind_, const char * Measure_, unsigned int MinScopeDepth_, unsigned int MaxScopeDepth_, bool IncludeGraphs_, bool CreateDescriptions_, __int64 MinValue_, __int64 MaxValue_, const char * Filter_);

	virtual IClientWUGetThorJobListRequest * createWUGetThorJobListRequest();
	virtual IClientWUGetThorJobListResponse * WUGetThorJobList(IClientWUGetThorJobListRequest *request);
	virtual void async_WUGetThorJobList(IClientWUGetThorJobListRequest *request, IClientWsWorkunitsEvents *events,IInterface* state=0);

	virtual IClientWUGetThorJobListResponse *WUGetThorJobListFn(const char * Cluster_, const char * StartDate_, const char * EndDate_, unsigned int MaxJobsToReturn_);

	virtual IClientWUGetThorJobQueueRequest * createWUGetThorJobQueueRequest();
	virtual IClientWUGetThorJobQueueResponse * WUGetThorJobQueue(IClientWUGetThorJobQueueRequest *request);
	virtual void async_WUGetThorJobQueue(IClientWUGetThorJobQueueRequest *request, IClientWsWorkunitsEvents *events,IInterface* state=0);

	virtual IClientWUGetThorJobQueueResponse *WUGetThorJobQueueFn(const char * Cluster_, const char * StartDate_, const char * EndDate_, unsigned int MaxJobQueueItemsToReturn_);

	virtual IClientWUGetZAPInfoRequest * createWUGetZAPInfoRequest();
	virtual IClientWUGetZAPInfoResponse * WUGetZAPInfo(IClientWUGetZAPInfoRequest *request);
	virtual void async_WUGetZAPInfo(IClientWUGetZAPInfoRequest *request, IClientWsWorkunitsEvents *events,IInterface* state=0);

	virtual IClientWUGetZAPInfoResponse *WUGetZAPInfoFn(const char * WUID_);

	virtual IClientWUGraphInfoRequest * createWUGraphInfoRequest();
	virtual IClientWUGraphInfoResponse * WUGraphInfo(IClientWUGraphInfoRequest *request);
	virtual void async_WUGraphInfo(IClientWUGraphInfoRequest *request, IClientWsWorkunitsEvents *events,IInterface* state=0);

	virtual IClientWUGraphInfoResponse *WUGraphInfoFn(const char * Wuid_, const char * Name_, const char * GID_, int BatchWU_);

	virtual IClientWUGraphTimingRequest * createWUGraphTimingRequest();
	virtual IClientWUGraphTimingResponse * WUGraphTiming(IClientWUGraphTimingRequest *request);
	virtual void async_WUGraphTiming(IClientWUGraphTimingRequest *request, IClientWsWorkunitsEvents *events,IInterface* state=0);

	virtual IClientWUGraphTimingResponse *WUGraphTimingFn(const char * Wuid_);

	virtual IClientWUInfoRequest * createWUInfoRequest();
	virtual IClientWUInfoResponse * WUInfo(IClientWUInfoRequest *request);
	virtual void async_WUInfo(IClientWUInfoRequest *request, IClientWsWorkunitsEvents *events,IInterface* state=0);

	virtual IClientWUInfoResponse *WUInfoFn(const char * Wuid_, bool TruncateEclTo64k_, const char * Type_, bool IncludeExceptions_, bool IncludeGraphs_, bool IncludeSourceFiles_, bool IncludeResults_, bool IncludeResultsViewNames_, bool IncludeVariables_, bool IncludeTimers_, bool IncludeDebugValues_, bool IncludeApplicationValues_, bool IncludeWorkflows_, bool IncludeXmlSchemas_, bool IncludeResourceURLs_, bool IncludeECL_, bool IncludeHelpers_, bool IncludeAllowedClusters_, bool IncludeTotalClusterTime_, bool SuppressResultSchemas_, const char * ThorSlaveIP_);

	virtual IClientWUInfoRequest * createWUInfoDetailsRequest();
	virtual IClientWUInfoResponse * WUInfoDetails(IClientWUInfoRequest *request);
	virtual void async_WUInfoDetails(IClientWUInfoRequest *request, IClientWsWorkunitsEvents *events,IInterface* state=0);

	virtual IClientWUInfoResponse *WUInfoDetailsFn(const char * Wuid_, bool TruncateEclTo64k_, const char * Type_, bool IncludeExceptions_, bool IncludeGraphs_, bool IncludeSourceFiles_, bool IncludeResults_, bool IncludeResultsViewNames_, bool IncludeVariables_, bool IncludeTimers_, bool IncludeDebugValues_, bool IncludeApplicationValues_, bool IncludeWorkflows_, bool IncludeXmlSchemas_, bool IncludeResourceURLs_, bool IncludeECL_, bool IncludeHelpers_, bool IncludeAllowedClusters_, bool IncludeTotalClusterTime_, bool SuppressResultSchemas_, const char * ThorSlaveIP_);

	virtual IClientWUJobListRequest * createWUJobListRequest();
	virtual IClientWUJobListResponse * WUJobList(IClientWUJobListRequest *request);
	virtual void async_WUJobList(IClientWUJobListRequest *request, IClientWsWorkunitsEvents *events,IInterface* state=0);

	virtual IClientWUJobListResponse *WUJobListFn(const char * Cluster_, const char * Process_, const char * StartDate_, const char * EndDate_, bool ShowAll_, int BusinessStartHour_, int BusinessEndHour_);

	virtual IClientWULightWeightQueryRequest * createWULightWeightQueryRequest();
	virtual IClientWULightWeightQueryResponse * WULightWeightQuery(IClientWULightWeightQueryRequest *request);
	virtual void async_WULightWeightQuery(IClientWULightWeightQueryRequest *request, IClientWsWorkunitsEvents *events,IInterface* state=0);

	virtual IClientWULightWeightQueryResponse *WULightWeightQueryFn(const char * Wuid_, const char * Type_, const char * Cluster_, const char * Owner_, const char * JobName_, const char * StartDate_, const char * EndDate_, const char * BeforeWU_, const char * AfterWU_, const char * State_, IArrayOf<IConstApplicationValue> &ApplicationValues_, __int64 PageStartFrom_, unsigned int PageSize_, const char * SortBy_, bool Descending_, __int64 CacheHint_);

	virtual IClientWUListArchiveFilesRequest * createWUListArchiveFilesRequest();
	virtual IClientWUListArchiveFilesResponse * WUListArchiveFiles(IClientWUListArchiveFilesRequest *request);
	virtual void async_WUListArchiveFiles(IClientWUListArchiveFilesRequest *request, IClientWsWorkunitsEvents *events,IInterface* state=0);

	virtual IClientWUListArchiveFilesResponse *WUListArchiveFilesFn(const char * WUID_);

	virtual IClientWUListLocalFileRequiredRequest * createWUListLocalFileRequiredRequest();
	virtual IClientWUListLocalFileRequiredResponse * WUListLocalFileRequired(IClientWUListLocalFileRequiredRequest *request);
	virtual void async_WUListLocalFileRequired(IClientWUListLocalFileRequiredRequest *request, IClientWsWorkunitsEvents *events,IInterface* state=0);

	virtual IClientWUListLocalFileRequiredResponse *WUListLocalFileRequiredFn(const char * Wuid_);

	virtual IClientWUListQueriesRequest * createWUListQueriesRequest();
	virtual IClientWUListQueriesResponse * WUListQueries(IClientWUListQueriesRequest *request);
	virtual void async_WUListQueries(IClientWUListQueriesRequest *request, IClientWsWorkunitsEvents *events,IInterface* state=0);

	virtual IClientWUListQueriesResponse *WUListQueriesFn(const char * QuerySetName_, const char * ClusterName_, const char * LibraryName_, __int64 MemoryLimitLow_, __int64 MemoryLimitHigh_, unsigned int TimeLimitLow_, unsigned int TimeLimitHigh_, unsigned int WarnTimeLimitLow_, unsigned int WarnTimeLimitHigh_, unsigned int PriorityLow_, unsigned int PriorityHigh_, bool Activated_, bool SuspendedByUser_, const char * WUID_, const char * QueryID_, const char * QueryName_, const char * PublishedBy_, unsigned int PageSize_, unsigned int PageStartFrom_, const char * Sortby_, bool Descending_, __int64 CacheHint_, const char * FileName_, bool CheckAllNodes_);

	virtual IClientWUListQueriesUsingFileRequest * createWUListQueriesUsingFileRequest();
	virtual IClientWUListQueriesUsingFileResponse * WUListQueriesUsingFile(IClientWUListQueriesUsingFileRequest *request);
	virtual void async_WUListQueriesUsingFile(IClientWUListQueriesUsingFileRequest *request, IClientWsWorkunitsEvents *events,IInterface* state=0);

	virtual IClientWUListQueriesUsingFileResponse *WUListQueriesUsingFileFn(const char * Target_, const char * Process_, const char * FileName_);

	virtual IClientWUMultiQuerySetDetailsRequest * createWUMultiQuerysetDetailsRequest();
	virtual IClientWUMultiQuerySetDetailsResponse * WUMultiQuerysetDetails(IClientWUMultiQuerySetDetailsRequest *request);
	virtual void async_WUMultiQuerysetDetails(IClientWUMultiQuerySetDetailsRequest *request, IClientWsWorkunitsEvents *events,IInterface* state=0);

	virtual IClientWUMultiQuerySetDetailsResponse *WUMultiQuerysetDetailsFn(const char * ClusterName_, const char * QuerySetName_, const char * Filter_, CWUQuerySetFilterType FilterType_, bool CheckAllNodes_);

	virtual IClientWUProcessGraphRequest * createWUProcessGraphRequest();
	virtual IClientWUProcessGraphResponse * WUProcessGraph(IClientWUProcessGraphRequest *request);
	virtual void async_WUProcessGraph(IClientWUProcessGraphRequest *request, IClientWsWorkunitsEvents *events,IInterface* state=0);

	virtual IClientWUProcessGraphResponse *WUProcessGraphFn(const char * Wuid_, const char * Name_);

	virtual IClientWUProtectRequest * createWUProtectRequest();
	virtual IClientWUProtectResponse * WUProtect(IClientWUProtectRequest *request);
	virtual void async_WUProtect(IClientWUProtectRequest *request, IClientWsWorkunitsEvents *events,IInterface* state=0);

	virtual IClientWUProtectResponse *WUProtectFn(StringArray &Wuids_, bool Protect_);

	virtual IClientWUPublishWorkunitRequest * createWUPublishWorkunitRequest();
	virtual IClientWUPublishWorkunitResponse * WUPublishWorkunit(IClientWUPublishWorkunitRequest *request);
	virtual void async_WUPublishWorkunit(IClientWUPublishWorkunitRequest *request, IClientWsWorkunitsEvents *events,IInterface* state=0);

	virtual IClientWUPublishWorkunitResponse *WUPublishWorkunitFn(const char * Wuid_, const char * Cluster_, const char * JobName_, int Activate_, bool NotifyCluster_, int Wait_, bool NoReload_, bool UpdateWorkUnitName_, const char * memoryLimit_, unsigned int TimeLimit_, unsigned int WarnTimeLimit_, const char * Priority_, const char * RemoteDali_, const char * Comment_, bool DontCopyFiles_, const char * SourceProcess_, bool AllowForeignFiles_, bool UpdateDfs_, bool UpdateSuperFiles_, bool UpdateCloneFrom_, bool AppendCluster_, bool IncludeFileErrors_);

	virtual IClientWUPushEventRequest * createWUPushEventRequest();
	virtual IClientWUPushEventResponse * WUPushEvent(IClientWUPushEventRequest *request);
	virtual void async_WUPushEvent(IClientWUPushEventRequest *request, IClientWsWorkunitsEvents *events,IInterface* state=0);

	virtual IClientWUPushEventResponse *WUPushEventFn(const char * EventName_, const char * EventText_);

	virtual IClientWUQueryRequest * createWUQueryRequest();
	virtual IClientWUQueryResponse * WUQuery(IClientWUQueryRequest *request);
	virtual void async_WUQuery(IClientWUQueryRequest *request, IClientWsWorkunitsEvents *events,IInterface* state=0);

	virtual IClientWUQueryResponse *WUQueryFn(const char * Wuid_, const char * Type_, const char * Cluster_, const char * RoxieCluster_, const char * Owner_, const char * State_, const char * StartDate_, const char * EndDate_, const char * ECL_, const char * Jobname_, const char * LogicalFile_, const char * LogicalFileSearchType_, const char * ApplicationName_, const char * ApplicationKey_, const char * ApplicationData_, IArrayOf<IConstApplicationValue> &ApplicationValues_, const char * BeforeWU_, const char * AfterWU_, const char * After_, const char * Before_, int Count_, __int64 PageSize_, __int64 PageStartFrom_, __int64 PageEndAt_, int LastNDays_, const char * Sortby_, bool Descending_, __int64 CacheHint_);

	virtual IClientWUQueryConfigRequest * createWUQueryConfigRequest();
	virtual IClientWUQueryConfigResponse * WUQueryConfig(IClientWUQueryConfigRequest *request);
	virtual void async_WUQueryConfig(IClientWUQueryConfigRequest *request, IClientWsWorkunitsEvents *events,IInterface* state=0);

	virtual IClientWUQueryConfigResponse *WUQueryConfigFn(const char * Target_, const char * QueryId_, int Wait_, bool NoReload_, const char * memoryLimit_, unsigned int TimeLimit_, unsigned int WarnTimeLimit_, const char * Priority_, const char * Comment_);

	virtual IClientWUQueryDetailsRequest * createWUQueryDetailsRequest();
	virtual IClientWUQueryDetailsResponse * WUQueryDetails(IClientWUQueryDetailsRequest *request);
	virtual void async_WUQueryDetails(IClientWUQueryDetailsRequest *request, IClientWsWorkunitsEvents *events,IInterface* state=0);

	virtual IClientWUQueryDetailsResponse *WUQueryDetailsFn(const char * QueryId_, const char * QuerySet_, bool IncludeStateOnClusters_, bool IncludeSuperFiles_, bool IncludeWsEclAddresses_, bool CheckAllNodes_);

	virtual IClientWUQueryFilesRequest * createWUQueryFilesRequest();
	virtual IClientWUQueryFilesResponse * WUQueryFiles(IClientWUQueryFilesRequest *request);
	virtual void async_WUQueryFiles(IClientWUQueryFilesRequest *request, IClientWsWorkunitsEvents *events,IInterface* state=0);

	virtual IClientWUQueryFilesResponse *WUQueryFilesFn(const char * Target_, const char * QueryId_);

	virtual IClientWUQueryGetGraphRequest * createWUQueryGetGraphRequest();
	virtual IClientWUQueryGetGraphResponse * WUQueryGetGraph(IClientWUQueryGetGraphRequest *request);
	virtual void async_WUQueryGetGraph(IClientWUQueryGetGraphRequest *request, IClientWsWorkunitsEvents *events,IInterface* state=0);

	virtual IClientWUQueryGetGraphResponse *WUQueryGetGraphFn(const char * Target_, const char * QueryId_, const char * GraphName_, const char * SubGraphId_);

	virtual IClientWUQueryGetSummaryStatsRequest * createWUQueryGetSummaryStatsRequest();
	virtual IClientWUQueryGetSummaryStatsResponse * WUQueryGetSummaryStats(IClientWUQueryGetSummaryStatsRequest *request);
	virtual void async_WUQueryGetSummaryStats(IClientWUQueryGetSummaryStatsRequest *request, IClientWsWorkunitsEvents *events,IInterface* state=0);

	virtual IClientWUQueryGetSummaryStatsResponse *WUQueryGetSummaryStatsFn(const char * Target_, const char * QueryId_, const char * FromTime_, const char * ToTime_);

	virtual IClientWUQuerySetAliasActionRequest * createWUQuerysetAliasActionRequest();
	virtual IClientWUQuerySetAliasActionResponse * WUQuerysetAliasAction(IClientWUQuerySetAliasActionRequest *request);
	virtual void async_WUQuerysetAliasAction(IClientWUQuerySetAliasActionRequest *request, IClientWsWorkunitsEvents *events,IInterface* state=0);

	virtual IClientWUQuerySetAliasActionResponse *WUQuerysetAliasActionFn(CQuerySetAliasActionTypes Action_, const char * QuerySetName_, IArrayOf<IConstQuerySetAliasActionItem> &Aliases_);

	virtual IClientWUQuerySetCopyQueryRequest * createWUQuerysetCopyQueryRequest();
	virtual IClientWUQuerySetCopyQueryResponse * WUQuerysetCopyQuery(IClientWUQuerySetCopyQueryRequest *request);
	virtual void async_WUQuerysetCopyQuery(IClientWUQuerySetCopyQueryRequest *request, IClientWsWorkunitsEvents *events,IInterface* state=0);

	virtual IClientWUQuerySetCopyQueryResponse *WUQuerysetCopyQueryFn(const char * Source_, const char * Target_, const char * Cluster_, const char * DaliServer_, int Activate_, bool Overwrite_, bool DontCopyFiles_, int Wait_, bool NoReload_, const char * memoryLimit_, unsigned int TimeLimit_, unsigned int WarnTimeLimit_, const char * priority_, const char * Comment_, const char * SourceProcess_, const char * DestName_, bool AllowForeignFiles_, bool UpdateSuperFiles_, bool UpdateCloneFrom_, bool AppendCluster_, bool IncludeFileErrors_);

	virtual IClientWUQuerySetDetailsRequest * createWUQuerysetDetailsRequest();
	virtual IClientWUQuerySetDetailsResponse * WUQuerysetDetails(IClientWUQuerySetDetailsRequest *request);
	virtual void async_WUQuerysetDetails(IClientWUQuerySetDetailsRequest *request, IClientWsWorkunitsEvents *events,IInterface* state=0);

	virtual IClientWUQuerySetDetailsResponse *WUQuerysetDetailsFn(const char * QuerySetName_, const char * Filter_, const char * ClusterName_, CWUQuerySetFilterType FilterType_, bool CheckAllNodes_);

	virtual IClientWUQuerysetExportRequest * createWUQuerysetExportRequest();
	virtual IClientWUQuerysetExportResponse * WUQuerysetExport(IClientWUQuerysetExportRequest *request);
	virtual void async_WUQuerysetExport(IClientWUQuerysetExportRequest *request, IClientWsWorkunitsEvents *events,IInterface* state=0);

	virtual IClientWUQuerysetExportResponse *WUQuerysetExportFn(const char * Target_, bool Compress_, bool ActiveOnly_, bool Protect_);

	virtual IClientWUQuerysetImportRequest * createWUQuerysetImportRequest();
	virtual IClientWUQuerysetImportResponse * WUQuerysetImport(IClientWUQuerysetImportRequest *request);
	virtual void async_WUQuerysetImport(IClientWUQuerysetImportRequest *request, IClientWsWorkunitsEvents *events,IInterface* state=0);

	virtual IClientWUQuerysetImportResponse *WUQuerysetImportFn(const char * Target_, const char * QueryMask_, bool Replace_, bool ActiveOnly_, CQuerysetImportActivation Activation_, bool Compressed_, const MemoryBuffer & Data_, bool AllowForeignFiles_, const char * DfsServer_, bool CopyFiles_, bool OverwriteDfs_, const char * SourceProcess_, bool UpdateSuperFiles_, bool UpdateCloneFrom_, bool AppendCluster_, bool IncludeFileErrors_);

	virtual IClientWUQuerySetQueryActionRequest * createWUQuerysetQueryActionRequest();
	virtual IClientWUQuerySetQueryActionResponse * WUQuerysetQueryAction(IClientWUQuerySetQueryActionRequest *request);
	virtual void async_WUQuerysetQueryAction(IClientWUQuerySetQueryActionRequest *request, IClientWsWorkunitsEvents *events,IInterface* state=0);

	virtual IClientWUQuerySetQueryActionResponse *WUQuerysetQueryActionFn(CQuerySetQueryActionTypes Action_, const char * QuerySetName_, IArrayOf<IConstQuerySetQueryActionItem> &Queries_);

	virtual IClientWUQuerysetsRequest * createWUQuerysetsRequest();
	virtual IClientWUQuerysetsResponse * WUQuerysets(IClientWUQuerysetsRequest *request);
	virtual void async_WUQuerysets(IClientWUQuerysetsRequest *request, IClientWsWorkunitsEvents *events,IInterface* state=0);

	virtual IClientWUQuerysetsResponse *WUQuerysetsFn(bool test_);

	virtual IClientWURecreateQueryRequest * createWURecreateQueryRequest();
	virtual IClientWURecreateQueryResponse * WURecreateQuery(IClientWURecreateQueryRequest *request);
	virtual void async_WURecreateQuery(IClientWURecreateQueryRequest *request, IClientWsWorkunitsEvents *events,IInterface* state=0);

	virtual IClientWURecreateQueryResponse *WURecreateQueryFn(const char * Target_, const char * QueryId_, IArrayOf<IConstNamedValue> &DebugValues_, const char * DestTarget_, bool Republish_, CWUQueryActivationMode Activate_, bool NoReload_, const char * MemoryLimit_, unsigned int TimeLimit_, unsigned int WarnTimeLimit_, const char * Priority_, const char * Comment_, const char * RemoteDali_, bool DontCopyFiles_, const char * SourceProcess_, bool AllowForeignFiles_, bool UpdateDfs_, bool UpdateSuperFiles_, bool UpdateCloneFrom_, bool AppendCluster_, bool IncludeFileErrors_, int Wait_);

	virtual IClientWUResubmitRequest * createWUResubmitRequest();
	virtual IClientWUResubmitResponse * WUResubmit(IClientWUResubmitRequest *request);
	virtual void async_WUResubmit(IClientWUResubmitRequest *request, IClientWsWorkunitsEvents *events,IInterface* state=0);

	virtual IClientWUResubmitResponse *WUResubmitFn(StringArray &Wuids_, bool Recompile_, int BlockTillFinishTimer_, bool ResetWorkflow_, bool CloneWorkunit_);

	virtual IClientWUResultRequest * createWUResultRequest();
	virtual IClientWUResultResponse * WUResult(IClientWUResultRequest *request);
	virtual void async_WUResult(IClientWUResultRequest *request, IClientWsWorkunitsEvents *events,IInterface* state=0);

	virtual IClientWUResultResponse *WUResultFn(const char * Wuid_, int Sequence_, const char * ResultName_, const char * LogicalName_, const char * Cluster_, bool SuppressXmlSchema_, bool BypassCachedResult_, IArrayOf<IConstNamedValue> &FilterBy_, __int64 Start_, int Count_);

	virtual IClientWUResultBinRequest * createWUResultBinRequest();
	virtual IClientWUResultBinResponse * WUResultBin(IClientWUResultBinRequest *request);
	virtual void async_WUResultBin(IClientWUResultBinRequest *request, IClientWsWorkunitsEvents *events,IInterface* state=0);

	virtual IClientWUResultBinResponse *WUResultBinFn(const char * LogicalName_, const char * Wuid_, const char * ResultName_, int Sequence_, const char * Format_, const char * Cluster_, IArrayOf<IConstNamedValue> &FilterBy_, __int64 Start_, int Count_);

	virtual IClientWUResultSummaryRequest * createWUResultSummaryRequest();
	virtual IClientWUResultSummaryResponse * WUResultSummary(IClientWUResultSummaryRequest *request);
	virtual void async_WUResultSummary(IClientWUResultSummaryRequest *request, IClientWsWorkunitsEvents *events,IInterface* state=0);

	virtual IClientWUResultSummaryResponse *WUResultSummaryFn(const char * Wuid_, int Sequence_);

	virtual IClientWUResultViewRequest * createWUResultViewRequest();
	virtual IClientWUResultViewResponse * WUResultView(IClientWUResultViewRequest *request);
	virtual void async_WUResultView(IClientWUResultViewRequest *request, IClientWsWorkunitsEvents *events,IInterface* state=0);

	virtual IClientWUResultViewResponse *WUResultViewFn(const char * Wuid_, const char * ViewName_, int Sequence_, const char * ResultName_);

	virtual IClientWURunRequest * createWURunRequest();
	virtual IClientWURunResponse * WURun(IClientWURunRequest *request);
	virtual void async_WURun(IClientWURunRequest *request, IClientWsWorkunitsEvents *events,IInterface* state=0);

	virtual IClientWURunResponse *WURunFn(const char * QuerySet_, const char * Query_, const char * Wuid_, bool CloneWorkunit_, const char * Cluster_, int Wait_, const char * Input_, bool NoRootTag_, IArrayOf<IConstNamedValue> &DebugValues_, IArrayOf<IConstNamedValue> &Variables_, IArrayOf<IConstApplicationValue> &ApplicationValues_, CWUExceptionSeverity ExceptionSeverity_);

	virtual IClientWUScheduleRequest * createWUScheduleRequest();
	virtual IClientWUScheduleResponse * WUSchedule(IClientWUScheduleRequest *request);
	virtual void async_WUSchedule(IClientWUScheduleRequest *request, IClientWsWorkunitsEvents *events,IInterface* state=0);

	virtual IClientWUScheduleResponse *WUScheduleFn(const char * Wuid_, const char * Cluster_, const char * Queue_, const char * Snapshot_, const char * When_, int MaxRunTime_);

	virtual IClientWUShowScheduledRequest * createWUShowScheduledRequest();
	virtual IClientWUShowScheduledResponse * WUShowScheduled(IClientWUShowScheduledRequest *request);
	virtual void async_WUShowScheduled(IClientWUShowScheduledRequest *request, IClientWsWorkunitsEvents *events,IInterface* state=0);

	virtual IClientWUShowScheduledResponse *WUShowScheduledFn(const char * Cluster_, const char * EventName_, const char * PushEventName_, const char * PushEventText_, const char * State_, const char * JobName_);

	virtual IClientWUSubmitRequest * createWUSubmitRequest();
	virtual IClientWUSubmitResponse * WUSubmit(IClientWUSubmitRequest *request);
	virtual void async_WUSubmit(IClientWUSubmitRequest *request, IClientWsWorkunitsEvents *events,IInterface* state=0);

	virtual IClientWUSubmitResponse *WUSubmitFn(const char * Wuid_, const char * Cluster_, const char * Queue_, const char * Snapshot_, int MaxRunTime_, int BlockTillFinishTimer_, bool SyntaxCheck_, bool NotifyCluster_);

	virtual IClientWUSyntaxCheckRequest * createWUSyntaxCheckECLRequest();
	virtual IClientWUSyntaxCheckResponse * WUSyntaxCheckECL(IClientWUSyntaxCheckRequest *request);
	virtual void async_WUSyntaxCheckECL(IClientWUSyntaxCheckRequest *request, IClientWsWorkunitsEvents *events,IInterface* state=0);

	virtual IClientWUSyntaxCheckResponse *WUSyntaxCheckECLFn(const char * ECL_, const char * ModuleName_, const char * AttributeName_, const char * Queue_, const char * Cluster_, const char * Snapshot_, int TimeToWait_, IArrayOf<IConstDebugValue> &DebugValues_);

	virtual IClientWUUpdateRequest * createWUUpdateRequest();
	virtual IClientWUUpdateResponse * WUUpdate(IClientWUUpdateRequest *request);
	virtual void async_WUUpdate(IClientWUUpdateRequest *request, IClientWsWorkunitsEvents *events,IInterface* state=0);

	virtual IClientWUUpdateResponse *WUUpdateFn(const char * Wuid_, int State_, int StateOrig_, const char * Jobname_, const char * JobnameOrig_, const char * QueryText_, int Action_, const char * Description_, const char * DescriptionOrig_, bool AddDrilldownFields_, int ResultLimit_, bool Protected_, bool ProtectedOrig_, int PriorityClass_, int PriorityLevel_, const char * Scope_, const char * ScopeOrig_, const char * ClusterSelection_, const char * ClusterOrig_, const char * XmlParams_, const char * ThorSlaveIP_, const char * QueryMainDefinition_, IArrayOf<IConstDebugValue> &DebugValues_, IArrayOf<IConstApplicationValue> &ApplicationValues_);

	virtual IClientWUUpdateQueryEntryRequest * createWUUpdateQueryEntryRequest();
	virtual IClientWUUpdateQueryEntryResponse * WUUpdateQueryEntry(IClientWUUpdateQueryEntryRequest *request);
	virtual void async_WUUpdateQueryEntry(IClientWUUpdateQueryEntryRequest *request, IClientWsWorkunitsEvents *events,IInterface* state=0);

	virtual IClientWUUpdateQueryEntryResponse *WUUpdateQueryEntryFn(const char * QuerySet_, const char * QueryId_, const char * Comment_);

	virtual IClientWUWaitRequest * createWUWaitCompiledRequest();
	virtual IClientWUWaitResponse * WUWaitCompiled(IClientWUWaitRequest *request);
	virtual void async_WUWaitCompiled(IClientWUWaitRequest *request, IClientWsWorkunitsEvents *events,IInterface* state=0);

	virtual IClientWUWaitResponse *WUWaitCompiledFn(const char * Wuid_, int Wait_, bool ReturnOnWait_);

	virtual IClientWUWaitRequest * createWUWaitCompleteRequest();
	virtual IClientWUWaitResponse * WUWaitComplete(IClientWUWaitRequest *request);
	virtual void async_WUWaitComplete(IClientWUWaitRequest *request, IClientWsWorkunitsEvents *events,IInterface* state=0);

	virtual IClientWUWaitResponse *WUWaitCompleteFn(const char * Wuid_, int Wait_, bool ReturnOnWait_);
	static int transferThunkEvent(void *data);
#ifdef _WIN32
	static void espWorkerThread(void* data);
#else
	static void *espWorkerThread(void *data);
#endif
};



}
using namespace ws_workunits;

#endif //ws_workunits_ESPGEN_INCLUDED
