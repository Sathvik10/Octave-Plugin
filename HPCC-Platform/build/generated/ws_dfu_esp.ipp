// *** Source file generated by HIDL Version 1.3 from ws_dfu.ecm ***
// *** Not to be hand edited (changes will be lost on re-generation) ***

#ifndef ws_dfu_EX_ESPGEN_INCLUDED
#define ws_dfu_EX_ESPGEN_INCLUDED

#pragma warning( disable : 4786)

//JLib
#include "jliball.hpp"

//SCM Interfaces
#include "esp.hpp"
#include "soapesp.hpp"
#include "ws_dfu.hpp"
//ESP Bindings
#include "SOAP/Platform/soapmessage.hpp"
#include "SOAP/Platform/soapmacro.hpp"
#include "SOAP/Platform/soapservice.hpp"
#include "SOAP/Platform/soapparam.hpp"
#include "SOAP/client/soapclient.hpp"


namespace ws_dfu
{

class CXDFUArrayActions : public SoapEnumParamNew<CDFUArrayActions>
{
public:
	CXDFUArrayActions(nilBehavior nilB) : SoapEnumParamNew<CDFUArrayActions>(nilB)
	{ doInit(); }
	CXDFUArrayActions(CDFUArrayActions defvalue_) : SoapEnumParamNew<CDFUArrayActions>(defvalue_)
	{ doInit(); }
	CXDFUArrayActions(const char* defvalue_) : SoapEnumParamNew<CDFUArrayActions>()
	{ doInit(); setDefaultValue(defvalue_); }
	static  void getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash &added)
	{ getSharedInstance().getXsdDefinitionInternal(context,request,schema,added); }
	static void getMapInfo(IMapInfo& info, BoolHash& added) { getSharedInstance().getMapInfo_(info,added); }

	static const char* stringOf(CDFUArrayActions val) { return getSharedInstance().toString(val); }

	static CDFUArrayActions enumOf(const char* s) { return getSharedInstance().toEnum(s); }

static const char *queryXsdElementName() { return "DFUArrayActions"; }
private:
	static CXDFUArrayActions& getSharedInstance() { static CXDFUArrayActions instance(nilIgnore); return instance; }
	void getMapInfo_(IMapInfo& info, BoolHash& added) {  }
	void getXsdDefinitionInternal(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash &added)
	{ getXsdDefinition_(context,request,schema,added,NULL); }
	void doInit()
	{
		static const char* inits[] = {"Delete","Add To Superfile",NULL};
		init("DFUArrayActions","string",inits);
	}
};

class CXDFUChangeProtection : public SoapEnumParamNew<CDFUChangeProtection>
{
public:
	CXDFUChangeProtection(nilBehavior nilB) : SoapEnumParamNew<CDFUChangeProtection>(nilB)
	{ doInit(); }
	CXDFUChangeProtection(CDFUChangeProtection defvalue_) : SoapEnumParamNew<CDFUChangeProtection>(defvalue_)
	{ doInit(); }
	CXDFUChangeProtection(const char* defvalue_) : SoapEnumParamNew<CDFUChangeProtection>()
	{ doInit(); setDefaultValue(defvalue_); }
	static  void getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash &added)
	{ getSharedInstance().getXsdDefinitionInternal(context,request,schema,added); }
	static void getMapInfo(IMapInfo& info, BoolHash& added) { getSharedInstance().getMapInfo_(info,added); }

	static const char* stringOf(CDFUChangeProtection val) { return getSharedInstance().toString(val); }

	static CDFUChangeProtection enumOf(const char* s) { return getSharedInstance().toEnum(s); }

static const char *queryXsdElementName() { return "DFUChangeProtection"; }
private:
	static CXDFUChangeProtection& getSharedInstance() { static CXDFUChangeProtection instance(nilIgnore); return instance; }
	void getMapInfo_(IMapInfo& info, BoolHash& added) {  }
	void getXsdDefinitionInternal(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash &added)
	{
		const char* descriptions [] = {"No Change","Protect","Unprotect",};
		getXsdDefinition_(context,request,schema,added,descriptions);
	}
	void doInit()
	{
		static const char* inits[] = {"0","1","2",NULL};
		init("DFUChangeProtection","int",inits);
	}
};

class CXDFUDefFileFormat : public SoapEnumParamNew<CDFUDefFileFormat>
{
public:
	CXDFUDefFileFormat(nilBehavior nilB) : SoapEnumParamNew<CDFUDefFileFormat>(nilB)
	{ doInit(); }
	CXDFUDefFileFormat(CDFUDefFileFormat defvalue_) : SoapEnumParamNew<CDFUDefFileFormat>(defvalue_)
	{ doInit(); }
	CXDFUDefFileFormat(const char* defvalue_) : SoapEnumParamNew<CDFUDefFileFormat>()
	{ doInit(); setDefaultValue(defvalue_); }
	static  void getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash &added)
	{ getSharedInstance().getXsdDefinitionInternal(context,request,schema,added); }
	static void getMapInfo(IMapInfo& info, BoolHash& added) { getSharedInstance().getMapInfo_(info,added); }

	static const char* stringOf(CDFUDefFileFormat val) { return getSharedInstance().toString(val); }

	static CDFUDefFileFormat enumOf(const char* s) { return getSharedInstance().toEnum(s); }

static const char *queryXsdElementName() { return "DFUDefFileFormat"; }
private:
	static CXDFUDefFileFormat& getSharedInstance() { static CXDFUDefFileFormat instance(nilIgnore); return instance; }
	void getMapInfo_(IMapInfo& info, BoolHash& added) {  }
	void getXsdDefinitionInternal(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash &added)
	{ getXsdDefinition_(context,request,schema,added,NULL); }
	void doInit()
	{
		static const char* inits[] = {"xml","def",NULL};
		init("DFUDefFileFormat","string",inits);
	}
};

class CXSecAccessType : public SoapEnumParamNew<CSecAccessType>
{
public:
	CXSecAccessType(nilBehavior nilB) : SoapEnumParamNew<CSecAccessType>(nilB)
	{ doInit(); }
	CXSecAccessType(CSecAccessType defvalue_) : SoapEnumParamNew<CSecAccessType>(defvalue_)
	{ doInit(); }
	CXSecAccessType(const char* defvalue_) : SoapEnumParamNew<CSecAccessType>()
	{ doInit(); setDefaultValue(defvalue_); }
	static  void getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash &added)
	{ getSharedInstance().getXsdDefinitionInternal(context,request,schema,added); }
	static void getMapInfo(IMapInfo& info, BoolHash& added) { getSharedInstance().getMapInfo_(info,added); }

	static const char* stringOf(CSecAccessType val) { return getSharedInstance().toString(val); }

	static CSecAccessType enumOf(const char* s) { return getSharedInstance().toEnum(s); }

static const char *queryXsdElementName() { return "SecAccessType"; }
private:
	static CXSecAccessType& getSharedInstance() { static CXSecAccessType instance(nilIgnore); return instance; }
	void getMapInfo_(IMapInfo& info, BoolHash& added) {  }
	void getXsdDefinitionInternal(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash &added)
	{ getXsdDefinition_(context,request,schema,added,NULL); }
	void doInit()
	{
		static const char* inits[] = {"None","Access","Read","Write","Full",NULL};
		init("SecAccessType","string",inits);
	}
};

class CXFileAccessRole : public SoapEnumParamNew<CFileAccessRole>
{
public:
	CXFileAccessRole(nilBehavior nilB) : SoapEnumParamNew<CFileAccessRole>(nilB)
	{ doInit(); }
	CXFileAccessRole(CFileAccessRole defvalue_) : SoapEnumParamNew<CFileAccessRole>(defvalue_)
	{ doInit(); }
	CXFileAccessRole(const char* defvalue_) : SoapEnumParamNew<CFileAccessRole>()
	{ doInit(); setDefaultValue(defvalue_); }
	static  void getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash &added)
	{ getSharedInstance().getXsdDefinitionInternal(context,request,schema,added); }
	static void getMapInfo(IMapInfo& info, BoolHash& added) { getSharedInstance().getMapInfo_(info,added); }

	static const char* stringOf(CFileAccessRole val) { return getSharedInstance().toString(val); }

	static CFileAccessRole enumOf(const char* s) { return getSharedInstance().toEnum(s); }

static const char *queryXsdElementName() { return "FileAccessRole"; }
private:
	static CXFileAccessRole& getSharedInstance() { static CXFileAccessRole instance(nilIgnore); return instance; }
	void getMapInfo_(IMapInfo& info, BoolHash& added) {  }
	void getXsdDefinitionInternal(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash &added)
	{ getXsdDefinition_(context,request,schema,added,NULL); }
	void doInit()
	{
		static const char* inits[] = {"Token","Engine","External",NULL};
		init("FileAccessRole","string",inits);
	}
};

class CSpaceItem : public CSoapComplexType,
   implements IEspSpaceItem,
   implements IClientSpaceItem
{
protected:
	SoapStringParam m_Name;
	SoapStringParam m_LargestFile;
	SoapStringParam m_SmallestFile;
	SoapParam<__int64> m_NumOfFilesInt;
	SoapParam<__int64> m_NumOfFilesIntUnknown;
	SoapParam<__int64> m_TotalSizeInt;
	SoapParam<__int64> m_LargestSizeInt;
	SoapParam<__int64> m_SmallestSizeInt;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CSpaceItem(const char *serviceName, const char *bcompat);

	CSpaceItem(const char *serviceName, IRpcMessageBinding *init=NULL);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "SpaceItem";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CSpaceItem &from);

	void copy(IConstSpaceItem &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstSpaceItem &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	const char * getName();
	const char * getLargestFile();
	const char * getSmallestFile();
	__int64 getNumOfFilesInt();
	__int64 getNumOfFilesIntUnknown();
	__int64 getTotalSizeInt();
	__int64 getLargestSizeInt();
	__int64 getSmallestSizeInt();
	void setName(const char * val);
	void setLargestFile(const char * val);
	void setSmallestFile(const char * val);
	void setNumOfFilesInt(__int64 val);
	void setNumOfFilesIntUnknown(__int64 val);
	void setTotalSizeInt(__int64 val);
	void setLargestSizeInt(__int64 val);
	void setSmallestSizeInt(__int64 val);
};

class CDFUFilePartition : public CSoapComplexType,
   implements IEspDFUFilePartition,
   implements IClientDFUFilePartition
{
protected:
	SoapParam<__int64> m_FieldMask;
	SoapStringArray m_FieldNames;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CDFUFilePartition(const char *serviceName, const char *bcompat);

	CDFUFilePartition(const char *serviceName, IRpcMessageBinding *init=NULL);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "DFUFilePartition";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CDFUFilePartition &from);

	void copy(IConstDFUFilePartition &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstDFUFilePartition &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	__int64 getFieldMask();
	StringArray & getFieldNames();
	void setFieldMask(__int64 val);
	void setFieldNames(StringArray &val);
};

class CDFUFileBloom : public CSoapComplexType,
   implements IEspDFUFileBloom,
   implements IClientDFUFileBloom
{
protected:
	SoapParam<__int64> m_FieldMask;
	SoapStringArray m_FieldNames;
	SoapParam<__int64> m_Limit;
	SoapStringParam m_Probability;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CDFUFileBloom(const char *serviceName, const char *bcompat);

	CDFUFileBloom(const char *serviceName, IRpcMessageBinding *init=NULL);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "DFUFileBloom";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CDFUFileBloom &from);

	void copy(IConstDFUFileBloom &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstDFUFileBloom &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	__int64 getFieldMask();
	StringArray & getFieldNames();
	__int64 getLimit();
	const char * getProbability();
	void setFieldMask(__int64 val);
	void setFieldNames(StringArray &val);
	void setLimit(__int64 val);
	void setProbability(const char * val);
};

class CDFULogicalFile : public CSoapComplexType,
   implements IEspDFULogicalFile,
   implements IClientDFULogicalFile
{
protected:
	SoapStringParam m_Prefix;
	SoapStringParam m_ClusterName;
	SoapStringParam m_NodeGroup;
	SoapStringParam m_Directory;
	SoapStringParam m_Description;
	SoapStringParam m_Parts;
	SoapStringParam m_Name;
	SoapStringParam m_Owner;
	SoapStringParam m_Totalsize;
	SoapStringParam m_RecordCount;
	SoapStringParam m_Modified;
	SoapStringParam m_LongSize;
	SoapStringParam m_LongRecordCount;
	SoapParam<bool> m_isSuperfile;
	SoapParam<bool> m_isZipfile;
	SoapParam<bool> m_isDirectory;
	SoapParam<bool> m_Replicate;
	SoapParam<__int64> m_IntSize;
	SoapParam<__int64> m_IntRecordCount;
	SoapParam<bool> m_FromRoxieCluster;
	SoapParam<bool> m_BrowseData;
	SoapParam<bool> m_IsKeyFile;
	SoapParam<bool> m_IsCompressed;
	SoapStringParam m_ContentType;
	SoapParam<__int64> m_CompressedFileSize;
	SoapStringParam m_SuperOwners;
	SoapParam<bool> m_Persistent;
	SoapParam<bool> m_IsProtected;
	SoapStringParam m_KeyType;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CDFULogicalFile(const char *serviceName, const char *bcompat);

	CDFULogicalFile(const char *serviceName, IRpcMessageBinding *init=NULL);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "DFULogicalFile";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CDFULogicalFile &from);

	void copy(IConstDFULogicalFile &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstDFULogicalFile &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	const char * getPrefix();
	const char * getClusterName();
	const char * getNodeGroup();
	const char * getDirectory();
	const char * getDescription();
	const char * getParts();
	const char * getName();
	const char * getOwner();
	const char * getTotalsize();
	const char * getRecordCount();
	const char * getModified();
	const char * getLongSize();
	const char * getLongRecordCount();
	bool getIsSuperfile();
	bool getIsZipfile();
	bool getIsDirectory();
	bool getReplicate();
	__int64 getIntSize();
	__int64 getIntRecordCount();
	bool getFromRoxieCluster();
	bool getBrowseData();
	bool getIsKeyFile();
	bool getIsCompressed();
	const char * getContentType();
	__int64 getCompressedFileSize();
	const char * getSuperOwners();
	bool getPersistent();
	bool getIsProtected();
	const char * getKeyType();
	void setPrefix(const char * val);
	void setClusterName(const char * val);
	void setNodeGroup(const char * val);
	void setDirectory(const char * val);
	void setDescription(const char * val);
	void setParts(const char * val);
	void setName(const char * val);
	void setOwner(const char * val);
	void setTotalsize(const char * val);
	void setRecordCount(const char * val);
	void setModified(const char * val);
	void setLongSize(const char * val);
	void setLongRecordCount(const char * val);
	void setIsSuperfile(bool val);
	void setIsZipfile(bool val);
	void setIsDirectory(bool val);
	void setReplicate(bool val);
	void setIntSize(__int64 val);
	void setIntRecordCount(__int64 val);
	void setFromRoxieCluster(bool val);
	void setBrowseData(bool val);
	void setIsKeyFile(bool val);
	void setIsCompressed(bool val);
	void setContentType(const char * val);
	void setCompressedFileSize(__int64 val);
	void setSuperOwners(const char * val);
	void setPersistent(bool val);
	void setIsProtected(bool val);
	void setKeyType(const char * val);
};

class CDFUPart : public CSoapComplexType,
   implements IEspDFUPart,
   implements IClientDFUPart
{
protected:
	SoapParam<int> m_Id;
	SoapParam<int> m_Copy;
	SoapStringParam m_ActualSize;
	SoapStringParam m_Ip;
	SoapStringParam m_Partsize;
	SoapParam<__int64> m_PartSizeInt64;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CDFUPart(const char *serviceName, const char *bcompat);

	CDFUPart(const char *serviceName, IRpcMessageBinding *init=NULL);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "DFUPart";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CDFUPart &from);

	void copy(IConstDFUPart &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstDFUPart &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	int getId();
	int getCopy();
	const char * getActualSize();
	const char * getIp();
	const char * getPartsize();
	__int64 getPartSizeInt64();
	void setId(int val);
	void setCopy(int val);
	void setActualSize(const char * val);
	void setIp(const char * val);
	void setPartsize(const char * val);
	void setPartSizeInt64(__int64 val);
};

class CDFUFileStat : public CSoapComplexType,
   implements IEspDFUFileStat,
   implements IClientDFUFileStat
{
protected:
	SoapStringParam m_MinSkew;
	SoapStringParam m_MaxSkew;
	SoapParam<__int64> m_MinSkewInt64;
	SoapParam<__int64> m_MaxSkewInt64;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CDFUFileStat(const char *serviceName, const char *bcompat);

	CDFUFileStat(const char *serviceName, IRpcMessageBinding *init=NULL);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "DFUFileStat";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CDFUFileStat &from);

	void copy(IConstDFUFileStat &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstDFUFileStat &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	const char * getMinSkew();
	const char * getMaxSkew();
	__int64 getMinSkewInt64();
	__int64 getMaxSkewInt64();
	void setMinSkew(const char * val);
	void setMaxSkew(const char * val);
	void setMinSkewInt64(__int64 val);
	void setMaxSkewInt64(__int64 val);
};

class CDFUFilePartsOnCluster : public CSoapComplexType,
   implements IEspDFUFilePartsOnCluster,
   implements IClientDFUFilePartsOnCluster
{
protected:
	SoapStringParam m_Cluster;
	SoapStringParam m_BaseDir;
	SoapStringParam m_ReplicateDir;
	SoapParam<bool> m_Replicate;
	SoapParam<bool> m_CanReplicate;
	SoapStructArrayParam<IConstDFUPart, CDFUPart> m_DFUFileParts;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CDFUFilePartsOnCluster(const char *serviceName, const char *bcompat);

	CDFUFilePartsOnCluster(const char *serviceName, IRpcMessageBinding *init=NULL);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "DFUFilePartsOnCluster";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CDFUFilePartsOnCluster &from);

	void copy(IConstDFUFilePartsOnCluster &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstDFUFilePartsOnCluster &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	const char * getCluster();
	const char * getBaseDir();
	const char * getReplicateDir();
bool getReplicate_isNull();
	bool getReplicate();
bool getCanReplicate_isNull();
	bool getCanReplicate();
	IArrayOf<IConstDFUPart> & getDFUFileParts();
	void setCluster(const char * val);
	void setBaseDir(const char * val);
	void setReplicateDir(const char * val);
	void setReplicate_null();
	void setReplicate(bool val);
	void setCanReplicate_null();
	void setCanReplicate(bool val);
	void setDFUFileParts(IArrayOf<IEspDFUPart> &val);
 void setDFUFileParts(IArrayOf<IConstDFUPart> &val);
};

class CDFUFileProtect : public CSoapComplexType,
   implements IEspDFUFileProtect,
   implements IClientDFUFileProtect
{
protected:
	SoapStringParam m_Owner;
	SoapParam<int> m_Count;
	SoapStringParam m_Modified;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CDFUFileProtect(const char *serviceName, const char *bcompat);

	CDFUFileProtect(const char *serviceName, IRpcMessageBinding *init=NULL);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "DFUFileProtect";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CDFUFileProtect &from);

	void copy(IConstDFUFileProtect &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstDFUFileProtect &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	const char * getOwner();
bool getCount_isNull();
	int getCount();
	const char * getModified();
	void setOwner(const char * val);
	void setCount_null();
	void setCount(int val);
	void setModified(const char * val);
};

class CDFUFileDetail : public CSoapComplexType,
   implements IEspDFUFileDetail,
   implements IClientDFUFileDetail
{
protected:
	SoapStringParam m_Name;
	SoapStringParam m_Filename;
	SoapStringParam m_Prefix;
	SoapStringParam m_NodeGroup;
	SoapParam<int> m_NumParts;
	SoapStringParam m_Description;
	SoapStringParam m_Dir;
	SoapStringParam m_PathMask;
	SoapStringParam m_Filesize;
	SoapParam<__int64> m_FileSizeInt64;
	SoapStringParam m_ActualSize;
	SoapStringParam m_RecordSize;
	SoapStringParam m_RecordCount;
	SoapParam<__int64> m_RecordSizeInt64;
	SoapParam<__int64> m_RecordCountInt64;
	SoapStringParam m_Wuid;
	SoapStringParam m_Owner;
	SoapStringParam m_Cluster;
	SoapStringParam m_JobName;
	SoapStringParam m_Persistent;
	SoapStringParam m_Format;
	SoapStringParam m_MaxRecordSize;
	SoapStringParam m_CsvSeparate;
	SoapStringParam m_CsvQuote;
	SoapStringParam m_CsvTerminate;
	SoapStringParam m_CsvEscape;
	SoapStringParam m_Modified;
	SoapStringParam m_Ecl;
	SoapParam<bool> m_ZipFile;
	SoapStruct<CDFUFileStat, IConstDFUFileStat> m_Stat;
	SoapStructArrayParam<IConstDFUPart, CDFUPart> m_DFUFileParts;
	SoapStructArrayParam<IConstDFUFilePartsOnCluster, CDFUFilePartsOnCluster> m_DFUFilePartsOnClusters;
	SoapParam<bool> m_isSuperfile;
	SoapParam<bool> m_ShowFileContent;
	SoapStringArray m_subfiles;
	SoapStructArrayParam<IConstDFULogicalFile, CDFULogicalFile> m_Superfiles;
	SoapStructArrayParam<IConstDFUFileProtect, CDFUFileProtect> m_ProtectList;
	SoapParam<bool> m_FromRoxieCluster;
	SoapStringArray m_Graphs;
	SoapStringParam m_UserPermission;
	SoapStringParam m_ContentType;
	SoapParam<__int64> m_CompressedFileSize;
	SoapStringParam m_PercentCompressed;
	SoapParam<bool> m_IsCompressed;
	SoapParam<bool> m_BrowseData;
	SoapStringParam m_jsonInfo;
	SoapParamBinary m_binInfo;
	SoapStringParam m_PackageID;
	SoapStruct<CDFUFilePartition, IConstDFUFilePartition> m_Partition;
	SoapStructArrayParam<IConstDFUFileBloom, CDFUFileBloom> m_Blooms;
	SoapParam<int> m_ExpireDays;
	SoapStringParam m_KeyType;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CDFUFileDetail(const char *serviceName, const char *bcompat);

	CDFUFileDetail(const char *serviceName, IRpcMessageBinding *init=NULL);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "DFUFileDetail";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CDFUFileDetail &from);

	void copy(IConstDFUFileDetail &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstDFUFileDetail &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	const char * getName();
	const char * getFilename();
	const char * getPrefix();
	const char * getNodeGroup();
bool getNumParts_isNull();
	int getNumParts();
	const char * getDescription();
	const char * getDir();
	const char * getPathMask();
	const char * getFilesize();
bool getFileSizeInt64_isNull();
	__int64 getFileSizeInt64();
	const char * getActualSize();
	const char * getRecordSize();
	const char * getRecordCount();
bool getRecordSizeInt64_isNull();
	__int64 getRecordSizeInt64();
bool getRecordCountInt64_isNull();
	__int64 getRecordCountInt64();
	const char * getWuid();
	const char * getOwner();
	const char * getCluster();
	const char * getJobName();
	const char * getPersistent();
	const char * getFormat();
	const char * getMaxRecordSize();
	const char * getCsvSeparate();
	const char * getCsvQuote();
	const char * getCsvTerminate();
	const char * getCsvEscape();
	const char * getModified();
	const char * getEcl();
bool getZipFile_isNull();
	bool getZipFile();
	IConstDFUFileStat & getStat();
	IArrayOf<IConstDFUPart> & getDFUFileParts();
	IArrayOf<IConstDFUFilePartsOnCluster> & getDFUFilePartsOnClusters();
bool getIsSuperfile_isNull();
	bool getIsSuperfile();
bool getShowFileContent_isNull();
	bool getShowFileContent();
	StringArray & getSubfiles();
	IArrayOf<IConstDFULogicalFile> & getSuperfiles();
	IArrayOf<IConstDFUFileProtect> & getProtectList();
bool getFromRoxieCluster_isNull();
	bool getFromRoxieCluster();
	StringArray & getGraphs();
	const char * getUserPermission();
	const char * getContentType();
bool getCompressedFileSize_isNull();
	__int64 getCompressedFileSize();
	const char * getPercentCompressed();
bool getIsCompressed_isNull();
	bool getIsCompressed();
bool getBrowseData_isNull();
	bool getBrowseData();
	const char * getJsonInfo();
	const MemoryBuffer & getBinInfo();
	const char * getPackageID();
	IConstDFUFilePartition & getPartition();
	IArrayOf<IConstDFUFileBloom> & getBlooms();
bool getExpireDays_isNull();
	int getExpireDays();
	const char * getKeyType();
	void setName(const char * val);
	void setFilename(const char * val);
	void setPrefix(const char * val);
	void setNodeGroup(const char * val);
	void setNumParts_null();
	void setNumParts(int val);
	void setDescription(const char * val);
	void setDir(const char * val);
	void setPathMask(const char * val);
	void setFilesize(const char * val);
	void setFileSizeInt64_null();
	void setFileSizeInt64(__int64 val);
	void setActualSize(const char * val);
	void setRecordSize(const char * val);
	void setRecordCount(const char * val);
	void setRecordSizeInt64_null();
	void setRecordSizeInt64(__int64 val);
	void setRecordCountInt64_null();
	void setRecordCountInt64(__int64 val);
	void setWuid(const char * val);
	void setOwner(const char * val);
	void setCluster(const char * val);
	void setJobName(const char * val);
	void setPersistent(const char * val);
	void setFormat(const char * val);
	void setMaxRecordSize(const char * val);
	void setCsvSeparate(const char * val);
	void setCsvQuote(const char * val);
	void setCsvTerminate(const char * val);
	void setCsvEscape(const char * val);
	void setModified(const char * val);
	void setEcl(const char * val);
	void setZipFile_null();
	void setZipFile(bool val);
	IEspDFUFileStat & updateStat();
	void setStat(IConstDFUFileStat &ifrom);
	void setDFUFileParts(IArrayOf<IEspDFUPart> &val);
 void setDFUFileParts(IArrayOf<IConstDFUPart> &val);
	void setDFUFilePartsOnClusters(IArrayOf<IEspDFUFilePartsOnCluster> &val);
 void setDFUFilePartsOnClusters(IArrayOf<IConstDFUFilePartsOnCluster> &val);
	void setIsSuperfile_null();
	void setIsSuperfile(bool val);
	void setShowFileContent_null();
	void setShowFileContent(bool val);
	void setSubfiles(StringArray &val);
	void setSuperfiles(IArrayOf<IEspDFULogicalFile> &val);
 void setSuperfiles(IArrayOf<IConstDFULogicalFile> &val);
	void setProtectList(IArrayOf<IEspDFUFileProtect> &val);
 void setProtectList(IArrayOf<IConstDFUFileProtect> &val);
	void setFromRoxieCluster_null();
	void setFromRoxieCluster(bool val);
	void setGraphs(StringArray &val);
	void setUserPermission(const char * val);
	void setContentType(const char * val);
	void setCompressedFileSize_null();
	void setCompressedFileSize(__int64 val);
	void setPercentCompressed(const char * val);
	void setIsCompressed_null();
	void setIsCompressed(bool val);
	void setBrowseData_null();
	void setBrowseData(bool val);
	void setJsonInfo(const char * val);
	void setBinInfo(const MemoryBuffer & val);
	void setPackageID(const char * val);
	IEspDFUFilePartition & updatePartition();
	void setPartition(IConstDFUFilePartition &ifrom);
	void setBlooms(IArrayOf<IEspDFUFileBloom> &val);
 void setBlooms(IArrayOf<IConstDFUFileBloom> &val);
	void setExpireDays_null();
	void setExpireDays(int val);
	void setKeyType(const char * val);
};

class CDFUSpaceItem : public CSoapComplexType,
   implements IEspDFUSpaceItem,
   implements IClientDFUSpaceItem
{
protected:
	SoapStringParam m_Name;
	SoapStringParam m_NumOfFiles;
	SoapStringParam m_NumOfFilesUnknown;
	SoapStringParam m_TotalSize;
	SoapStringParam m_LargestFile;
	SoapStringParam m_LargestSize;
	SoapStringParam m_SmallestFile;
	SoapStringParam m_SmallestSize;
	SoapParam<__int64> m_NumOfFilesInt64;
	SoapParam<__int64> m_NumOfFilesUnknownInt64;
	SoapParam<__int64> m_TotalSizeInt64;
	SoapParam<__int64> m_LargestSizeInt64;
	SoapParam<__int64> m_SmallestSizeInt64;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CDFUSpaceItem(const char *serviceName, const char *bcompat);

	CDFUSpaceItem(const char *serviceName, IRpcMessageBinding *init=NULL);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "DFUSpaceItem";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CDFUSpaceItem &from);

	void copy(IConstDFUSpaceItem &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstDFUSpaceItem &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	const char * getName();
	const char * getNumOfFiles();
	const char * getNumOfFilesUnknown();
	const char * getTotalSize();
	const char * getLargestFile();
	const char * getLargestSize();
	const char * getSmallestFile();
	const char * getSmallestSize();
	__int64 getNumOfFilesInt64();
	__int64 getNumOfFilesUnknownInt64();
	__int64 getTotalSizeInt64();
	__int64 getLargestSizeInt64();
	__int64 getSmallestSizeInt64();
	void setName(const char * val);
	void setNumOfFiles(const char * val);
	void setNumOfFilesUnknown(const char * val);
	void setTotalSize(const char * val);
	void setLargestFile(const char * val);
	void setLargestSize(const char * val);
	void setSmallestFile(const char * val);
	void setSmallestSize(const char * val);
	void setNumOfFilesInt64(__int64 val);
	void setNumOfFilesUnknownInt64(__int64 val);
	void setTotalSizeInt64(__int64 val);
	void setLargestSizeInt64(__int64 val);
	void setSmallestSizeInt64(__int64 val);
};

class CDFUActionInfo : public CSoapComplexType,
   implements IEspDFUActionInfo,
   implements IClientDFUActionInfo
{
protected:
	SoapStringParam m_FileName;
	SoapStringParam m_NodeGroup;
	SoapStringParam m_ActionResult;
	SoapParam<bool> m_Failed;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CDFUActionInfo(const char *serviceName, const char *bcompat);

	CDFUActionInfo(const char *serviceName, IRpcMessageBinding *init=NULL);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "DFUActionInfo";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CDFUActionInfo &from);

	void copy(IConstDFUActionInfo &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstDFUActionInfo &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	const char * getFileName();
	const char * getNodeGroup();
	const char * getActionResult();
	bool getFailed();
	void setFileName(const char * val);
	void setNodeGroup(const char * val);
	void setActionResult(const char * val);
	void setFailed(bool val);
};

class CDFUQueryRequest : public CSoapRequestBinding,
   implements IEspDFUQueryRequest,
   implements IClientDFUQueryRequest
{
protected:
	SoapStringParam m_Prefix;
	SoapStringParam m_ClusterName;
	SoapStringParam m_NodeGroup;
	SoapStringParam m_ContentType;
	SoapStringParam m_LogicalName;
	SoapStringParam m_Owner;
	SoapStringParam m_StartDate;
	SoapStringParam m_EndDate;
	SoapStringParam m_FileType;
	SoapParam<__int64> m_FileSizeFrom;
	SoapParam<__int64> m_FileSizeTo;
	SoapParam<int> m_FirstN;
	SoapStringParam m_FirstNType;
	SoapParam<int> m_PageSize;
	SoapParam<int> m_PageStartFrom;
	SoapStringParam m_Sortby;
	SoapParam<bool> m_Descending;
	SoapParam<bool> m_OneLevelDirFileReturn;
	SoapParam<__int64> m_CacheHint;
	SoapParam<int> m_MaxNumberOfFiles;
	SoapParam<bool> m_IncludeSuperOwner;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CDFUQueryRequest(const char *serviceName, const char *bcompat);

	CDFUQueryRequest(const char *serviceName, IRpcMessageBinding *init=NULL);
	CDFUQueryRequest(const char *serviceName, IRpcMessage* rpcmsg);
	CDFUQueryRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	IEspClientRpcSettings &rpc(){return *static_cast<IEspClientRpcSettings*>(this);}


	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "DFUQueryRequest";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CDFUQueryRequest &from);

	void copy(IConstDFUQueryRequest &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstDFUQueryRequest &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	const char * getPrefix();
	const char * getClusterName();
	const char * getNodeGroup();
	const char * getContentType();
	const char * getLogicalName();
	const char * getOwner();
	const char * getStartDate();
	const char * getEndDate();
	const char * getFileType();
bool getFileSizeFrom_isNull();
	__int64 getFileSizeFrom();
bool getFileSizeTo_isNull();
	__int64 getFileSizeTo();
bool getFirstN_isNull();
	int getFirstN();
	const char * getFirstNType();
bool getPageSize_isNull();
	int getPageSize();
bool getPageStartFrom_isNull();
	int getPageStartFrom();
	const char * getSortby();
bool getDescending_isNull();
	bool getDescending();
bool getOneLevelDirFileReturn_isNull();
	bool getOneLevelDirFileReturn();
bool getCacheHint_isNull();
	__int64 getCacheHint();
bool getMaxNumberOfFiles_isNull();
	int getMaxNumberOfFiles();
bool getIncludeSuperOwner_isNull();
	bool getIncludeSuperOwner();
	void setPrefix(const char * val);
	void setClusterName(const char * val);
	void setNodeGroup(const char * val);
	void setContentType(const char * val);
	void setLogicalName(const char * val);
	void setOwner(const char * val);
	void setStartDate(const char * val);
	void setEndDate(const char * val);
	void setFileType(const char * val);
	void setFileSizeFrom_null();
	void setFileSizeFrom(__int64 val);
	void setFileSizeTo_null();
	void setFileSizeTo(__int64 val);
	void setFirstN_null();
	void setFirstN(int val);
	void setFirstNType(const char * val);
	void setPageSize_null();
	void setPageSize(int val);
	void setPageStartFrom_null();
	void setPageStartFrom(int val);
	void setSortby(const char * val);
	void setDescending_null();
	void setDescending(bool val);
	void setOneLevelDirFileReturn_null();
	void setOneLevelDirFileReturn(bool val);
	void setCacheHint_null();
	void setCacheHint(__int64 val);
	void setMaxNumberOfFiles_null();
	void setMaxNumberOfFiles(int val);
	void setIncludeSuperOwner_null();
	void setIncludeSuperOwner(bool val);
};

class CDFUQueryResponse : public CSoapResponseBinding,
   implements IEspDFUQueryResponse,
   implements IClientDFUQueryResponse
{
protected:
	SoapStructArrayParam<IConstDFULogicalFile, CDFULogicalFile> m_DFULogicalFiles;
	SoapStringParam m_Prefix;
	SoapStringParam m_ClusterName;
	SoapStringParam m_NodeGroup;
	SoapStringParam m_LogicalName;
	SoapStringParam m_Description;
	SoapStringParam m_Owner;
	SoapStringParam m_StartDate;
	SoapStringParam m_EndDate;
	SoapStringParam m_FileType;
	SoapParam<__int64> m_FileSizeFrom;
	SoapParam<__int64> m_FileSizeTo;
	SoapParam<int> m_FirstN;
	SoapStringParam m_FirstNType;
	SoapParam<int> m_PageSize;
	SoapParam<__int64> m_PageStartFrom;
	SoapParam<__int64> m_LastPageFrom;
	SoapParam<__int64> m_PageEndAt;
	SoapParam<__int64> m_PrevPageFrom;
	SoapParam<__int64> m_NextPageFrom;
	SoapParam<__int64> m_NumFiles;
	SoapStringParam m_Sortby;
	SoapParam<bool> m_Descending;
	SoapStringParam m_BasicQuery;
	SoapStringParam m_ParametersForPaging;
	SoapStringParam m_Filters;
	SoapParam<__int64> m_CacheHint;
	SoapParam<bool> m_IsSubsetOfFiles;
	SoapStringParam m_Warning;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CDFUQueryResponse(const char *serviceName, const char *bcompat);

	CDFUQueryResponse(const char *serviceName, IRpcMessageBinding *init=NULL);
	CDFUQueryResponse(const char *serviceName, IRpcMessage* rpcmsg);
	CDFUQueryResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "DFUQueryResponse";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CDFUQueryResponse &from);

	void copy(IConstDFUQueryResponse &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstDFUQueryResponse &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	virtual void setRedirectUrl(const char *url)
	{ CSoapResponseBinding::setRedirectUrl(url); }

	virtual const IMultiException& getExceptions()
	{ return CSoapResponseBinding::getExceptions(); }

	virtual int queryClientStatus()
	{ return CSoapResponseBinding::getRpcState(); }

	virtual void noteException(IException& e)
	{  CSoapResponseBinding::noteException(e); }

	IArrayOf<IConstDFULogicalFile> & getDFULogicalFiles();
	const char * getPrefix();
	const char * getClusterName();
	const char * getNodeGroup();
	const char * getLogicalName();
	const char * getDescription();
	const char * getOwner();
	const char * getStartDate();
	const char * getEndDate();
	const char * getFileType();
	__int64 getFileSizeFrom();
	__int64 getFileSizeTo();
	int getFirstN();
	const char * getFirstNType();
	int getPageSize();
	__int64 getPageStartFrom();
	__int64 getLastPageFrom();
	__int64 getPageEndAt();
	__int64 getPrevPageFrom();
	__int64 getNextPageFrom();
	__int64 getNumFiles();
	const char * getSortby();
	bool getDescending();
	const char * getBasicQuery();
	const char * getParametersForPaging();
	const char * getFilters();
	__int64 getCacheHint();
	bool getIsSubsetOfFiles();
	const char * getWarning();
	void setDFULogicalFiles(IArrayOf<IEspDFULogicalFile> &val);
 void setDFULogicalFiles(IArrayOf<IConstDFULogicalFile> &val);
	void setPrefix(const char * val);
	void setClusterName(const char * val);
	void setNodeGroup(const char * val);
	void setLogicalName(const char * val);
	void setDescription(const char * val);
	void setOwner(const char * val);
	void setStartDate(const char * val);
	void setEndDate(const char * val);
	void setFileType(const char * val);
	void setFileSizeFrom(__int64 val);
	void setFileSizeTo(__int64 val);
	void setFirstN(int val);
	void setFirstNType(const char * val);
	void setPageSize(int val);
	void setPageStartFrom(__int64 val);
	void setLastPageFrom(__int64 val);
	void setPageEndAt(__int64 val);
	void setPrevPageFrom(__int64 val);
	void setNextPageFrom(__int64 val);
	void setNumFiles(__int64 val);
	void setSortby(const char * val);
	void setDescending(bool val);
	void setBasicQuery(const char * val);
	void setParametersForPaging(const char * val);
	void setFilters(const char * val);
	void setCacheHint(__int64 val);
	void setIsSubsetOfFiles(bool val);
	void setWarning(const char * val);
};

class CDFUSearchRequest : public CSoapRequestBinding,
   implements IEspDFUSearchRequest,
   implements IClientDFUSearchRequest
{
protected:
	SoapStringParam m_ShowExample;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CDFUSearchRequest(const char *serviceName, const char *bcompat);

	CDFUSearchRequest(const char *serviceName, IRpcMessageBinding *init=NULL);
	CDFUSearchRequest(const char *serviceName, IRpcMessage* rpcmsg);
	CDFUSearchRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	IEspClientRpcSettings &rpc(){return *static_cast<IEspClientRpcSettings*>(this);}


	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "DFUSearchRequest";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CDFUSearchRequest &from);

	void copy(IConstDFUSearchRequest &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstDFUSearchRequest &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	const char * getShowExample();
	void setShowExample(const char * val);
};

class CDFUSearchResponse : public CSoapResponseBinding,
   implements IEspDFUSearchResponse,
   implements IClientDFUSearchResponse
{
protected:
	SoapStringParam m_ShowExample;
	SoapStringArray m_ClusterNames;
	SoapStringArray m_FileTypes;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CDFUSearchResponse(const char *serviceName, const char *bcompat);

	CDFUSearchResponse(const char *serviceName, IRpcMessageBinding *init=NULL);
	CDFUSearchResponse(const char *serviceName, IRpcMessage* rpcmsg);
	CDFUSearchResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "DFUSearchResponse";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CDFUSearchResponse &from);

	void copy(IConstDFUSearchResponse &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstDFUSearchResponse &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	virtual void setRedirectUrl(const char *url)
	{ CSoapResponseBinding::setRedirectUrl(url); }

	virtual const IMultiException& getExceptions()
	{ return CSoapResponseBinding::getExceptions(); }

	virtual int queryClientStatus()
	{ return CSoapResponseBinding::getRpcState(); }

	virtual void noteException(IException& e)
	{  CSoapResponseBinding::noteException(e); }

	const char * getShowExample();
	StringArray & getClusterNames();
	StringArray & getFileTypes();
	void setShowExample(const char * val);
	void setClusterNames(StringArray &val);
	void setFileTypes(StringArray &val);
};

class CDFUArrayActionRequest : public CSoapRequestBinding,
   implements IEspDFUArrayActionRequest,
   implements IClientDFUArrayActionRequest
{
protected:
	CXDFUArrayActions m_Type;
	SoapParam<bool> m_NoDelete;
	SoapStringParam m_BackToPage;
	SoapStringArray m_LogicalFiles;
	SoapParam<bool> m_removeFromSuperfiles;
	SoapParam<bool> m_removeRecursively;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CDFUArrayActionRequest(const char *serviceName, const char *bcompat);

	CDFUArrayActionRequest(const char *serviceName, IRpcMessageBinding *init=NULL);
	CDFUArrayActionRequest(const char *serviceName, IRpcMessage* rpcmsg);
	CDFUArrayActionRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	IEspClientRpcSettings &rpc(){return *static_cast<IEspClientRpcSettings*>(this);}


	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "DFUArrayActionRequest";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CDFUArrayActionRequest &from);

	void copy(IConstDFUArrayActionRequest &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstDFUArrayActionRequest &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	CDFUArrayActions getType();
	const char* getTypeAsString();
	bool getNoDelete();
	const char * getBackToPage();
	StringArray & getLogicalFiles();
	bool getRemoveFromSuperfiles();
	bool getRemoveRecursively();
	void setType(CDFUArrayActions val);
void setType(const char* val);
	void setNoDelete(bool val);
	void setBackToPage(const char * val);
	void setLogicalFiles(StringArray &val);
	void setRemoveFromSuperfiles(bool val);
	void setRemoveRecursively(bool val);
};

class CDFUArrayActionResponse : public CSoapResponseBinding,
   implements IEspDFUArrayActionResponse,
   implements IClientDFUArrayActionResponse
{
protected:
	SoapStringParam m_BackToPage;
	SoapStringParam m_RedirectTo;
	SoapStringParam m_DFUArrayActionResult;
	SoapStructArrayParam<IConstDFUActionInfo, CDFUActionInfo> m_ActionResults;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CDFUArrayActionResponse(const char *serviceName, const char *bcompat);

	CDFUArrayActionResponse(const char *serviceName, IRpcMessageBinding *init=NULL);
	CDFUArrayActionResponse(const char *serviceName, IRpcMessage* rpcmsg);
	CDFUArrayActionResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "DFUArrayActionResponse";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CDFUArrayActionResponse &from);

	void copy(IConstDFUArrayActionResponse &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstDFUArrayActionResponse &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	virtual void setRedirectUrl(const char *url)
	{ CSoapResponseBinding::setRedirectUrl(url); }

	virtual const IMultiException& getExceptions()
	{ return CSoapResponseBinding::getExceptions(); }

	virtual int queryClientStatus()
	{ return CSoapResponseBinding::getRpcState(); }

	virtual void noteException(IException& e)
	{  CSoapResponseBinding::noteException(e); }

	const char * getBackToPage();
	const char * getRedirectTo();
	const char * getDFUArrayActionResult();
	IArrayOf<IConstDFUActionInfo> & getActionResults();
	void setBackToPage(const char * val);
	void setRedirectTo(const char * val);
	void setDFUArrayActionResult(const char * val);
	void setActionResults(IArrayOf<IEspDFUActionInfo> &val);
 void setActionResults(IArrayOf<IConstDFUActionInfo> &val);
};

class CDFUInfoRequest : public CSoapRequestBinding,
   implements IEspDFUInfoRequest,
   implements IClientDFUInfoRequest
{
protected:
	SoapStringParam m_Name;
	SoapStringParam m_Cluster;
	SoapParam<bool> m_UpdateDescription;
	SoapStringParam m_QuerySet;
	SoapStringParam m_Query;
	SoapStringParam m_FileName;
	SoapStringParam m_FileDesc;
	SoapParam<bool> m_IncludeJsonTypeInfo;
	SoapParam<bool> m_IncludeBinTypeInfo;
	CXDFUChangeProtection m_Protect;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CDFUInfoRequest(const char *serviceName, const char *bcompat);

	CDFUInfoRequest(const char *serviceName, IRpcMessageBinding *init=NULL);
	CDFUInfoRequest(const char *serviceName, IRpcMessage* rpcmsg);
	CDFUInfoRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	IEspClientRpcSettings &rpc(){return *static_cast<IEspClientRpcSettings*>(this);}


	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "DFUInfoRequest";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CDFUInfoRequest &from);

	void copy(IConstDFUInfoRequest &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstDFUInfoRequest &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	const char * getName();
	const char * getCluster();
	bool getUpdateDescription();
	const char * getQuerySet();
	const char * getQuery();
	const char * getFileName();
	const char * getFileDesc();
	bool getIncludeJsonTypeInfo();
	bool getIncludeBinTypeInfo();
	CDFUChangeProtection getProtect();
	const char* getProtectAsString();
	void setName(const char * val);
	void setCluster(const char * val);
	void setUpdateDescription(bool val);
	void setQuerySet(const char * val);
	void setQuery(const char * val);
	void setFileName(const char * val);
	void setFileDesc(const char * val);
	void setIncludeJsonTypeInfo(bool val);
	void setIncludeBinTypeInfo(bool val);
	void setProtect(CDFUChangeProtection val);
void setProtect(const char* val);
};

class CDFUInfoResponse : public CSoapResponseBinding,
   implements IEspDFUInfoResponse,
   implements IClientDFUInfoResponse
{
protected:
	SoapStruct<CDFUFileDetail, IConstDFUFileDetail> m_FileDetail;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CDFUInfoResponse(const char *serviceName, const char *bcompat);

	CDFUInfoResponse(const char *serviceName, IRpcMessageBinding *init=NULL);
	CDFUInfoResponse(const char *serviceName, IRpcMessage* rpcmsg);
	CDFUInfoResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "DFUInfoResponse";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CDFUInfoResponse &from);

	void copy(IConstDFUInfoResponse &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstDFUInfoResponse &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	virtual void setRedirectUrl(const char *url)
	{ CSoapResponseBinding::setRedirectUrl(url); }

	virtual const IMultiException& getExceptions()
	{ return CSoapResponseBinding::getExceptions(); }

	virtual int queryClientStatus()
	{ return CSoapResponseBinding::getRpcState(); }

	virtual void noteException(IException& e)
	{  CSoapResponseBinding::noteException(e); }

	IConstDFUFileDetail & getFileDetail();
	IEspDFUFileDetail & updateFileDetail();
	void setFileDetail(IConstDFUFileDetail &ifrom);
};

class CDFUDefFileRequest : public CSoapRequestBinding,
   implements IEspDFUDefFileRequest,
   implements IClientDFUDefFileRequest
{
protected:
	SoapStringParam m_Name;
	CXDFUDefFileFormat m_Format;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CDFUDefFileRequest(const char *serviceName, const char *bcompat);

	CDFUDefFileRequest(const char *serviceName, IRpcMessageBinding *init=NULL);
	CDFUDefFileRequest(const char *serviceName, IRpcMessage* rpcmsg);
	CDFUDefFileRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	IEspClientRpcSettings &rpc(){return *static_cast<IEspClientRpcSettings*>(this);}


	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "DFUDefFileRequest";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CDFUDefFileRequest &from);

	void copy(IConstDFUDefFileRequest &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstDFUDefFileRequest &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	const char * getName();
	CDFUDefFileFormat getFormat();
	const char* getFormatAsString();
	void setName(const char * val);
	void setFormat(CDFUDefFileFormat val);
void setFormat(const char* val);
};

class CDFUDefFileResponse : public CSoapResponseBinding,
   implements IEspDFUDefFileResponse,
   implements IClientDFUDefFileResponse
{
protected:
	SoapParamBinary m_defFile;
	StringBuffer m_defFile_mimetype;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CDFUDefFileResponse(const char *serviceName, const char *bcompat);

	CDFUDefFileResponse(const char *serviceName, IRpcMessageBinding *init=NULL);
	CDFUDefFileResponse(const char *serviceName, IRpcMessage* rpcmsg);
	CDFUDefFileResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "DFUDefFileResponse";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return true;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CDFUDefFileResponse &from);

	void copy(IConstDFUDefFileResponse &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstDFUDefFileResponse &ifrom, StringBuffer& buffer, bool keepRootTag=true);

	void appendContent(IEspContext* ctx, MemoryBuffer& buffer, StringBuffer &mimetype);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	virtual void setRedirectUrl(const char *url)
	{ CSoapResponseBinding::setRedirectUrl(url); }

	virtual const IMultiException& getExceptions()
	{ return CSoapResponseBinding::getExceptions(); }

	virtual int queryClientStatus()
	{ return CSoapResponseBinding::getRpcState(); }

	virtual void noteException(IException& e)
	{  CSoapResponseBinding::noteException(e); }

	const char *getDefFile_mimetype();
	const MemoryBuffer & getDefFile();
	void setDefFile_mimetype(const char *  val);
	void setDefFile(const MemoryBuffer & val);
};

class CDFURecordTypeInfoRequest : public CSoapRequestBinding,
   implements IEspDFURecordTypeInfoRequest,
   implements IClientDFURecordTypeInfoRequest
{
protected:
	SoapStringParam m_Name;
	SoapParam<bool> m_IncludeJsonTypeInfo;
	SoapParam<bool> m_IncludeBinTypeInfo;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CDFURecordTypeInfoRequest(const char *serviceName, const char *bcompat);

	CDFURecordTypeInfoRequest(const char *serviceName, IRpcMessageBinding *init=NULL);
	CDFURecordTypeInfoRequest(const char *serviceName, IRpcMessage* rpcmsg);
	CDFURecordTypeInfoRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	IEspClientRpcSettings &rpc(){return *static_cast<IEspClientRpcSettings*>(this);}


	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "DFURecordTypeInfoRequest";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CDFURecordTypeInfoRequest &from);

	void copy(IConstDFURecordTypeInfoRequest &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstDFURecordTypeInfoRequest &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	const char * getName();
	bool getIncludeJsonTypeInfo();
	bool getIncludeBinTypeInfo();
	void setName(const char * val);
	void setIncludeJsonTypeInfo(bool val);
	void setIncludeBinTypeInfo(bool val);
};

class CDFURecordTypeInfoResponse : public CSoapResponseBinding,
   implements IEspDFURecordTypeInfoResponse,
   implements IClientDFURecordTypeInfoResponse
{
protected:
	SoapStringParam m_jsonInfo;
	SoapParamBinary m_binInfo;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CDFURecordTypeInfoResponse(const char *serviceName, const char *bcompat);

	CDFURecordTypeInfoResponse(const char *serviceName, IRpcMessageBinding *init=NULL);
	CDFURecordTypeInfoResponse(const char *serviceName, IRpcMessage* rpcmsg);
	CDFURecordTypeInfoResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "DFURecordTypeInfoResponse";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CDFURecordTypeInfoResponse &from);

	void copy(IConstDFURecordTypeInfoResponse &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstDFURecordTypeInfoResponse &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	virtual void setRedirectUrl(const char *url)
	{ CSoapResponseBinding::setRedirectUrl(url); }

	virtual const IMultiException& getExceptions()
	{ return CSoapResponseBinding::getExceptions(); }

	virtual int queryClientStatus()
	{ return CSoapResponseBinding::getRpcState(); }

	virtual void noteException(IException& e)
	{  CSoapResponseBinding::noteException(e); }

	const char * getJsonInfo();
	const MemoryBuffer & getBinInfo();
	void setJsonInfo(const char * val);
	void setBinInfo(const MemoryBuffer & val);
};

class CEclRecordTypeInfoRequest : public CSoapRequestBinding,
   implements IEspEclRecordTypeInfoRequest,
   implements IClientEclRecordTypeInfoRequest
{
protected:
	SoapStringParam m_Ecl;
	SoapParam<bool> m_IncludeJsonTypeInfo;
	SoapParam<bool> m_IncludeBinTypeInfo;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CEclRecordTypeInfoRequest(const char *serviceName, const char *bcompat);

	CEclRecordTypeInfoRequest(const char *serviceName, IRpcMessageBinding *init=NULL);
	CEclRecordTypeInfoRequest(const char *serviceName, IRpcMessage* rpcmsg);
	CEclRecordTypeInfoRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	IEspClientRpcSettings &rpc(){return *static_cast<IEspClientRpcSettings*>(this);}


	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "EclRecordTypeInfoRequest";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CEclRecordTypeInfoRequest &from);

	void copy(IConstEclRecordTypeInfoRequest &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstEclRecordTypeInfoRequest &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	const char * getEcl();
	bool getIncludeJsonTypeInfo();
	bool getIncludeBinTypeInfo();
	void setEcl(const char * val);
	void setIncludeJsonTypeInfo(bool val);
	void setIncludeBinTypeInfo(bool val);
};

class CEclRecordTypeInfoResponse : public CSoapResponseBinding,
   implements IEspEclRecordTypeInfoResponse,
   implements IClientEclRecordTypeInfoResponse
{
protected:
	SoapStringParam m_jsonInfo;
	SoapParamBinary m_binInfo;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CEclRecordTypeInfoResponse(const char *serviceName, const char *bcompat);

	CEclRecordTypeInfoResponse(const char *serviceName, IRpcMessageBinding *init=NULL);
	CEclRecordTypeInfoResponse(const char *serviceName, IRpcMessage* rpcmsg);
	CEclRecordTypeInfoResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "EclRecordTypeInfoResponse";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CEclRecordTypeInfoResponse &from);

	void copy(IConstEclRecordTypeInfoResponse &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstEclRecordTypeInfoResponse &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	virtual void setRedirectUrl(const char *url)
	{ CSoapResponseBinding::setRedirectUrl(url); }

	virtual const IMultiException& getExceptions()
	{ return CSoapResponseBinding::getExceptions(); }

	virtual int queryClientStatus()
	{ return CSoapResponseBinding::getRpcState(); }

	virtual void noteException(IException& e)
	{  CSoapResponseBinding::noteException(e); }

	const char * getJsonInfo();
	const MemoryBuffer & getBinInfo();
	void setJsonInfo(const char * val);
	void setBinInfo(const MemoryBuffer & val);
};

class CSuperfileActionRequest : public CSoapRequestBinding,
   implements IEspSuperfileActionRequest,
   implements IClientSuperfileActionRequest
{
protected:
	SoapStringParam m_action;
	SoapStringParam m_superfile;
	SoapStringArray m_subfiles;
	SoapStringParam m_before;
	SoapParam<bool> m_delete;
	SoapParam<bool> m_removeSuperfile;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CSuperfileActionRequest(const char *serviceName, const char *bcompat);

	CSuperfileActionRequest(const char *serviceName, IRpcMessageBinding *init=NULL);
	CSuperfileActionRequest(const char *serviceName, IRpcMessage* rpcmsg);
	CSuperfileActionRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	IEspClientRpcSettings &rpc(){return *static_cast<IEspClientRpcSettings*>(this);}


	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "SuperfileActionRequest";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CSuperfileActionRequest &from);

	void copy(IConstSuperfileActionRequest &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstSuperfileActionRequest &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	const char * getAction();
	const char * getSuperfile();
	StringArray & getSubfiles();
	const char * getBefore();
	bool getDelete();
	bool getRemoveSuperfile();
	void setAction(const char * val);
	void setSuperfile(const char * val);
	void setSubfiles(StringArray &val);
	void setBefore(const char * val);
	void setDelete(bool val);
	void setRemoveSuperfile(bool val);
};

class CSuperfileActionResponse : public CSoapResponseBinding,
   implements IEspSuperfileActionResponse,
   implements IClientSuperfileActionResponse
{
protected:
	SoapStringParam m_superfile;
	SoapParam<int> m_retcode;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CSuperfileActionResponse(const char *serviceName, const char *bcompat);

	CSuperfileActionResponse(const char *serviceName, IRpcMessageBinding *init=NULL);
	CSuperfileActionResponse(const char *serviceName, IRpcMessage* rpcmsg);
	CSuperfileActionResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "SuperfileActionResponse";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CSuperfileActionResponse &from);

	void copy(IConstSuperfileActionResponse &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstSuperfileActionResponse &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	virtual void setRedirectUrl(const char *url)
	{ CSoapResponseBinding::setRedirectUrl(url); }

	virtual const IMultiException& getExceptions()
	{ return CSoapResponseBinding::getExceptions(); }

	virtual int queryClientStatus()
	{ return CSoapResponseBinding::getRpcState(); }

	virtual void noteException(IException& e)
	{  CSoapResponseBinding::noteException(e); }

	const char * getSuperfile();
bool getRetcode_isNull();
	int getRetcode();
	void setSuperfile(const char * val);
	void setRetcode_null();
	void setRetcode(int val);
};

class CAddtoSuperfileRequest : public CSoapRequestBinding,
   implements IEspAddtoSuperfileRequest,
   implements IClientAddtoSuperfileRequest
{
protected:
	SoapStringParam m_Superfile;
	SoapStringParam m_Subfiles;
	SoapStringArray m_names;
	SoapParam<bool> m_ExistingFile;
	SoapStringParam m_BackToPage;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CAddtoSuperfileRequest(const char *serviceName, const char *bcompat);

	CAddtoSuperfileRequest(const char *serviceName, IRpcMessageBinding *init=NULL);
	CAddtoSuperfileRequest(const char *serviceName, IRpcMessage* rpcmsg);
	CAddtoSuperfileRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	IEspClientRpcSettings &rpc(){return *static_cast<IEspClientRpcSettings*>(this);}


	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "AddtoSuperfileRequest";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CAddtoSuperfileRequest &from);

	void copy(IConstAddtoSuperfileRequest &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstAddtoSuperfileRequest &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	const char * getSuperfile();
	const char * getSubfiles();
	StringArray & getNames();
	bool getExistingFile();
	const char * getBackToPage();
	void setSuperfile(const char * val);
	void setSubfiles(const char * val);
	void setNames(StringArray &val);
	void setExistingFile(bool val);
	void setBackToPage(const char * val);
};

class CAddtoSuperfileResponse : public CSoapResponseBinding,
   implements IEspAddtoSuperfileResponse,
   implements IClientAddtoSuperfileResponse
{
protected:
	SoapStringParam m_Subfiles;
	SoapStringParam m_BackToPage;
	SoapStringArray m_SubfileNames;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CAddtoSuperfileResponse(const char *serviceName, const char *bcompat);

	CAddtoSuperfileResponse(const char *serviceName, IRpcMessageBinding *init=NULL);
	CAddtoSuperfileResponse(const char *serviceName, IRpcMessage* rpcmsg);
	CAddtoSuperfileResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "AddtoSuperfileResponse";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CAddtoSuperfileResponse &from);

	void copy(IConstAddtoSuperfileResponse &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstAddtoSuperfileResponse &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	virtual void setRedirectUrl(const char *url)
	{ CSoapResponseBinding::setRedirectUrl(url); }

	virtual const IMultiException& getExceptions()
	{ return CSoapResponseBinding::getExceptions(); }

	virtual int queryClientStatus()
	{ return CSoapResponseBinding::getRpcState(); }

	virtual void noteException(IException& e)
	{  CSoapResponseBinding::noteException(e); }

	const char * getSubfiles();
	const char * getBackToPage();
	StringArray & getSubfileNames();
	void setSubfiles(const char * val);
	void setBackToPage(const char * val);
	void setSubfileNames(StringArray &val);
};

class CSuperfileListRequest : public CSoapRequestBinding,
   implements IEspSuperfileListRequest,
   implements IClientSuperfileListRequest
{
protected:
	SoapStringParam m_superfile;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CSuperfileListRequest(const char *serviceName, const char *bcompat);

	CSuperfileListRequest(const char *serviceName, IRpcMessageBinding *init=NULL);
	CSuperfileListRequest(const char *serviceName, IRpcMessage* rpcmsg);
	CSuperfileListRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	IEspClientRpcSettings &rpc(){return *static_cast<IEspClientRpcSettings*>(this);}


	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "SuperfileListRequest";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CSuperfileListRequest &from);

	void copy(IConstSuperfileListRequest &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstSuperfileListRequest &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	const char * getSuperfile();
	void setSuperfile(const char * val);
};

class CSuperfileListResponse : public CSoapResponseBinding,
   implements IEspSuperfileListResponse,
   implements IClientSuperfileListResponse
{
protected:
	SoapStringParam m_superfile;
	SoapStringArray m_subfiles;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CSuperfileListResponse(const char *serviceName, const char *bcompat);

	CSuperfileListResponse(const char *serviceName, IRpcMessageBinding *init=NULL);
	CSuperfileListResponse(const char *serviceName, IRpcMessage* rpcmsg);
	CSuperfileListResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "SuperfileListResponse";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CSuperfileListResponse &from);

	void copy(IConstSuperfileListResponse &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstSuperfileListResponse &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	virtual void setRedirectUrl(const char *url)
	{ CSoapResponseBinding::setRedirectUrl(url); }

	virtual const IMultiException& getExceptions()
	{ return CSoapResponseBinding::getExceptions(); }

	virtual int queryClientStatus()
	{ return CSoapResponseBinding::getRpcState(); }

	virtual void noteException(IException& e)
	{  CSoapResponseBinding::noteException(e); }

	const char * getSuperfile();
	StringArray & getSubfiles();
	void setSuperfile(const char * val);
	void setSubfiles(StringArray &val);
};

class CSuperfileAddRawRequest : public CSoapRequestBinding,
   implements IEspSuperfileAddRawRequest,
   implements IClientSuperfileAddRawRequest
{
protected:
	SoapStringParam m_superfile;
	SoapStringParam m_subfiles;
	SoapStringParam m_before;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CSuperfileAddRawRequest(const char *serviceName, const char *bcompat);

	CSuperfileAddRawRequest(const char *serviceName, IRpcMessageBinding *init=NULL);
	CSuperfileAddRawRequest(const char *serviceName, IRpcMessage* rpcmsg);
	CSuperfileAddRawRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	IEspClientRpcSettings &rpc(){return *static_cast<IEspClientRpcSettings*>(this);}


	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "SuperfileAddRawRequest";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CSuperfileAddRawRequest &from);

	void copy(IConstSuperfileAddRawRequest &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstSuperfileAddRawRequest &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	const char * getSuperfile();
	const char * getSubfiles();
	const char * getBefore();
	void setSuperfile(const char * val);
	void setSubfiles(const char * val);
	void setBefore(const char * val);
};

class CSuperfileAddRawResponse : public CSoapResponseBinding,
   implements IEspSuperfileAddRawResponse,
   implements IClientSuperfileAddRawResponse
{
protected:
	SoapStringParam m_superfile;
	SoapParam<int> m_retcode;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CSuperfileAddRawResponse(const char *serviceName, const char *bcompat);

	CSuperfileAddRawResponse(const char *serviceName, IRpcMessageBinding *init=NULL);
	CSuperfileAddRawResponse(const char *serviceName, IRpcMessage* rpcmsg);
	CSuperfileAddRawResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "SuperfileAddRawResponse";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CSuperfileAddRawResponse &from);

	void copy(IConstSuperfileAddRawResponse &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstSuperfileAddRawResponse &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	virtual void setRedirectUrl(const char *url)
	{ CSoapResponseBinding::setRedirectUrl(url); }

	virtual const IMultiException& getExceptions()
	{ return CSoapResponseBinding::getExceptions(); }

	virtual int queryClientStatus()
	{ return CSoapResponseBinding::getRpcState(); }

	virtual void noteException(IException& e)
	{  CSoapResponseBinding::noteException(e); }

	const char * getSuperfile();
bool getRetcode_isNull();
	int getRetcode();
	void setSuperfile(const char * val);
	void setRetcode_null();
	void setRetcode(int val);
};

class CSavexmlRequest : public CSoapRequestBinding,
   implements IEspSavexmlRequest,
   implements IClientSavexmlRequest
{
protected:
	SoapStringParam m_name;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CSavexmlRequest(const char *serviceName, const char *bcompat);

	CSavexmlRequest(const char *serviceName, IRpcMessageBinding *init=NULL);
	CSavexmlRequest(const char *serviceName, IRpcMessage* rpcmsg);
	CSavexmlRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	IEspClientRpcSettings &rpc(){return *static_cast<IEspClientRpcSettings*>(this);}


	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "SavexmlRequest";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CSavexmlRequest &from);

	void copy(IConstSavexmlRequest &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstSavexmlRequest &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	const char * getName();
	void setName(const char * val);
};

class CSavexmlResponse : public CSoapResponseBinding,
   implements IEspSavexmlResponse,
   implements IClientSavexmlResponse
{
protected:
	SoapParamBinary m_xmlmap;
	StringBuffer m_xmlmap_mimetype;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CSavexmlResponse(const char *serviceName, const char *bcompat);

	CSavexmlResponse(const char *serviceName, IRpcMessageBinding *init=NULL);
	CSavexmlResponse(const char *serviceName, IRpcMessage* rpcmsg);
	CSavexmlResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "SavexmlResponse";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return true;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CSavexmlResponse &from);

	void copy(IConstSavexmlResponse &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstSavexmlResponse &ifrom, StringBuffer& buffer, bool keepRootTag=true);

	void appendContent(IEspContext* ctx, MemoryBuffer& buffer, StringBuffer &mimetype);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	virtual void setRedirectUrl(const char *url)
	{ CSoapResponseBinding::setRedirectUrl(url); }

	virtual const IMultiException& getExceptions()
	{ return CSoapResponseBinding::getExceptions(); }

	virtual int queryClientStatus()
	{ return CSoapResponseBinding::getRpcState(); }

	virtual void noteException(IException& e)
	{  CSoapResponseBinding::noteException(e); }

	const char *getXmlmap_mimetype();
	const MemoryBuffer & getXmlmap();
	void setXmlmap_mimetype(const char *  val);
	void setXmlmap(const MemoryBuffer & val);
};

class CAddRequest : public CSoapRequestBinding,
   implements IEspAddRequest,
   implements IClientAddRequest
{
protected:
	SoapStringParam m_dstname;
	SoapParamBinary m_xmlmap;
	StringBuffer m_xmlmap_mimetype;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CAddRequest(const char *serviceName, const char *bcompat);

	CAddRequest(const char *serviceName, IRpcMessageBinding *init=NULL);
	CAddRequest(const char *serviceName, IRpcMessage* rpcmsg);
	CAddRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	IEspClientRpcSettings &rpc(){return *static_cast<IEspClientRpcSettings*>(this);}


	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "AddRequest";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return true;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CAddRequest &from);

	void copy(IConstAddRequest &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstAddRequest &ifrom, StringBuffer& buffer, bool keepRootTag=true);

	void appendContent(IEspContext* ctx, MemoryBuffer& buffer, StringBuffer &mimetype);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	const char * getDstname();
	const char *getXmlmap_mimetype();
	const MemoryBuffer & getXmlmap();
	void setDstname(const char * val);
	void setXmlmap_mimetype(const char *  val);
	void setXmlmap(const MemoryBuffer & val);
};

class CAddResponse : public CSoapResponseBinding,
   implements IEspAddResponse,
   implements IClientAddResponse
{
protected:

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CAddResponse(const char *serviceName, const char *bcompat);

	CAddResponse(const char *serviceName, IRpcMessageBinding *init=NULL);
	CAddResponse(const char *serviceName, IRpcMessage* rpcmsg);
	CAddResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "AddResponse";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CAddResponse &from);

	void copy(IConstAddResponse &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstAddResponse &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	virtual void setRedirectUrl(const char *url)
	{ CSoapResponseBinding::setRedirectUrl(url); }

	virtual const IMultiException& getExceptions()
	{ return CSoapResponseBinding::getExceptions(); }

	virtual int queryClientStatus()
	{ return CSoapResponseBinding::getRpcState(); }

	virtual void noteException(IException& e)
	{  CSoapResponseBinding::noteException(e); }

};

class CAddRemoteRequest : public CSoapRequestBinding,
   implements IEspAddRemoteRequest,
   implements IClientAddRemoteRequest
{
protected:
	SoapStringParam m_dstname;
	SoapStringParam m_srcname;
	SoapStringParam m_srcdali;
	SoapStringParam m_srcusername;
	SoapStringParam m_srcpassword;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CAddRemoteRequest(const char *serviceName, const char *bcompat);

	CAddRemoteRequest(const char *serviceName, IRpcMessageBinding *init=NULL);
	CAddRemoteRequest(const char *serviceName, IRpcMessage* rpcmsg);
	CAddRemoteRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	IEspClientRpcSettings &rpc(){return *static_cast<IEspClientRpcSettings*>(this);}


	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "AddRemoteRequest";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CAddRemoteRequest &from);

	void copy(IConstAddRemoteRequest &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstAddRemoteRequest &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	const char * getDstname();
	const char * getSrcname();
	const char * getSrcdali();
	const char * getSrcusername();
	const char * getSrcpassword();
	void setDstname(const char * val);
	void setSrcname(const char * val);
	void setSrcdali(const char * val);
	void setSrcusername(const char * val);
	void setSrcpassword(const char * val);
};

class CAddRemoteResponse : public CSoapResponseBinding,
   implements IEspAddRemoteResponse,
   implements IClientAddRemoteResponse
{
protected:

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CAddRemoteResponse(const char *serviceName, const char *bcompat);

	CAddRemoteResponse(const char *serviceName, IRpcMessageBinding *init=NULL);
	CAddRemoteResponse(const char *serviceName, IRpcMessage* rpcmsg);
	CAddRemoteResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "AddRemoteResponse";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CAddRemoteResponse &from);

	void copy(IConstAddRemoteResponse &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstAddRemoteResponse &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	virtual void setRedirectUrl(const char *url)
	{ CSoapResponseBinding::setRedirectUrl(url); }

	virtual const IMultiException& getExceptions()
	{ return CSoapResponseBinding::getExceptions(); }

	virtual int queryClientStatus()
	{ return CSoapResponseBinding::getRpcState(); }

	virtual void noteException(IException& e)
	{  CSoapResponseBinding::noteException(e); }

};

class CDFUSpaceRequest : public CSoapRequestBinding,
   implements IEspDFUSpaceRequest,
   implements IClientDFUSpaceRequest
{
protected:
	SoapStringParam m_CountBy;
	SoapStringParam m_ScopeUnder;
	SoapStringParam m_OwnerUnder;
	SoapStringParam m_Interval;
	SoapStringParam m_StartDate;
	SoapStringParam m_EndDate;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CDFUSpaceRequest(const char *serviceName, const char *bcompat);

	CDFUSpaceRequest(const char *serviceName, IRpcMessageBinding *init=NULL);
	CDFUSpaceRequest(const char *serviceName, IRpcMessage* rpcmsg);
	CDFUSpaceRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	IEspClientRpcSettings &rpc(){return *static_cast<IEspClientRpcSettings*>(this);}


	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "DFUSpaceRequest";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CDFUSpaceRequest &from);

	void copy(IConstDFUSpaceRequest &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstDFUSpaceRequest &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	const char * getCountBy();
	const char * getScopeUnder();
	const char * getOwnerUnder();
	const char * getInterval();
	const char * getStartDate();
	const char * getEndDate();
	void setCountBy(const char * val);
	void setScopeUnder(const char * val);
	void setOwnerUnder(const char * val);
	void setInterval(const char * val);
	void setStartDate(const char * val);
	void setEndDate(const char * val);
};

class CDFUSpaceResponse : public CSoapResponseBinding,
   implements IEspDFUSpaceResponse,
   implements IClientDFUSpaceResponse
{
protected:
	SoapStringParam m_CountBy;
	SoapStringParam m_ScopeUnder;
	SoapStringParam m_OwnerUnder;
	SoapStringParam m_Interval;
	SoapStringParam m_StartDate;
	SoapStringParam m_EndDate;
	SoapStructArrayParam<IConstDFUSpaceItem, CDFUSpaceItem> m_DFUSpaceItems;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CDFUSpaceResponse(const char *serviceName, const char *bcompat);

	CDFUSpaceResponse(const char *serviceName, IRpcMessageBinding *init=NULL);
	CDFUSpaceResponse(const char *serviceName, IRpcMessage* rpcmsg);
	CDFUSpaceResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "DFUSpaceResponse";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CDFUSpaceResponse &from);

	void copy(IConstDFUSpaceResponse &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstDFUSpaceResponse &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	virtual void setRedirectUrl(const char *url)
	{ CSoapResponseBinding::setRedirectUrl(url); }

	virtual const IMultiException& getExceptions()
	{ return CSoapResponseBinding::getExceptions(); }

	virtual int queryClientStatus()
	{ return CSoapResponseBinding::getRpcState(); }

	virtual void noteException(IException& e)
	{  CSoapResponseBinding::noteException(e); }

	const char * getCountBy();
	const char * getScopeUnder();
	const char * getOwnerUnder();
	const char * getInterval();
	const char * getStartDate();
	const char * getEndDate();
	IArrayOf<IConstDFUSpaceItem> & getDFUSpaceItems();
	void setCountBy(const char * val);
	void setScopeUnder(const char * val);
	void setOwnerUnder(const char * val);
	void setInterval(const char * val);
	void setStartDate(const char * val);
	void setEndDate(const char * val);
	void setDFUSpaceItems(IArrayOf<IEspDFUSpaceItem> &val);
 void setDFUSpaceItems(IArrayOf<IConstDFUSpaceItem> &val);
};

class CDFUFileViewRequest : public CSoapRequestBinding,
   implements IEspDFUFileViewRequest,
   implements IClientDFUFileViewRequest
{
protected:
	SoapStringParam m_Scope;
	SoapParam<bool> m_IncludeSuperOwner;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CDFUFileViewRequest(const char *serviceName, const char *bcompat);

	CDFUFileViewRequest(const char *serviceName, IRpcMessageBinding *init=NULL);
	CDFUFileViewRequest(const char *serviceName, IRpcMessage* rpcmsg);
	CDFUFileViewRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	IEspClientRpcSettings &rpc(){return *static_cast<IEspClientRpcSettings*>(this);}


	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "DFUFileViewRequest";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CDFUFileViewRequest &from);

	void copy(IConstDFUFileViewRequest &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstDFUFileViewRequest &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	const char * getScope();
bool getIncludeSuperOwner_isNull();
	bool getIncludeSuperOwner();
	void setScope(const char * val);
	void setIncludeSuperOwner_null();
	void setIncludeSuperOwner(bool val);
};

class CDFUFileViewResponse : public CSoapResponseBinding,
   implements IEspDFUFileViewResponse,
   implements IClientDFUFileViewResponse
{
protected:
	SoapStringParam m_Scope;
	SoapParam<int> m_NumFiles;
	SoapStructArrayParam<IConstDFULogicalFile, CDFULogicalFile> m_DFULogicalFiles;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CDFUFileViewResponse(const char *serviceName, const char *bcompat);

	CDFUFileViewResponse(const char *serviceName, IRpcMessageBinding *init=NULL);
	CDFUFileViewResponse(const char *serviceName, IRpcMessage* rpcmsg);
	CDFUFileViewResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "DFUFileViewResponse";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CDFUFileViewResponse &from);

	void copy(IConstDFUFileViewResponse &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstDFUFileViewResponse &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	virtual void setRedirectUrl(const char *url)
	{ CSoapResponseBinding::setRedirectUrl(url); }

	virtual const IMultiException& getExceptions()
	{ return CSoapResponseBinding::getExceptions(); }

	virtual int queryClientStatus()
	{ return CSoapResponseBinding::getRpcState(); }

	virtual void noteException(IException& e)
	{  CSoapResponseBinding::noteException(e); }

	const char * getScope();
	int getNumFiles();
	IArrayOf<IConstDFULogicalFile> & getDFULogicalFiles();
	void setScope(const char * val);
	void setNumFiles(int val);
	void setDFULogicalFiles(IArrayOf<IEspDFULogicalFile> &val);
 void setDFULogicalFiles(IArrayOf<IConstDFULogicalFile> &val);
};

class CDFUDataColumn : public CSoapComplexType,
   implements IEspDFUDataColumn,
   implements IClientDFUDataColumn
{
protected:
	SoapParam<int> m_ColumnID;
	SoapStringParam m_ColumnLabel;
	SoapStringParam m_ColumnType;
	SoapStringParam m_ColumnValue;
	SoapParam<int> m_ColumnSize;
	SoapParam<int> m_MaxSize;
	SoapStringParam m_ColumnEclType;
	SoapParam<int> m_ColumnRawSize;
	SoapParam<bool> m_IsNaturalColumn;
	SoapParam<bool> m_IsKeyedColumn;
	SoapStructArrayParam<IConstDFUDataColumn, CDFUDataColumn> m_DataColumns;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CDFUDataColumn(const char *serviceName, const char *bcompat);

	CDFUDataColumn(const char *serviceName, IRpcMessageBinding *init=NULL);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "DFUDataColumn";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CDFUDataColumn &from);

	void copy(IConstDFUDataColumn &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstDFUDataColumn &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

bool getColumnID_isNull();
	int getColumnID();
	const char * getColumnLabel();
	const char * getColumnType();
	const char * getColumnValue();
bool getColumnSize_isNull();
	int getColumnSize();
bool getMaxSize_isNull();
	int getMaxSize();
	const char * getColumnEclType();
bool getColumnRawSize_isNull();
	int getColumnRawSize();
bool getIsNaturalColumn_isNull();
	bool getIsNaturalColumn();
bool getIsKeyedColumn_isNull();
	bool getIsKeyedColumn();
	IArrayOf<IConstDFUDataColumn> & getDataColumns();
	void setColumnID_null();
	void setColumnID(int val);
	void setColumnLabel(const char * val);
	void setColumnType(const char * val);
	void setColumnValue(const char * val);
	void setColumnSize_null();
	void setColumnSize(int val);
	void setMaxSize_null();
	void setMaxSize(int val);
	void setColumnEclType(const char * val);
	void setColumnRawSize_null();
	void setColumnRawSize(int val);
	void setIsNaturalColumn_null();
	void setIsNaturalColumn(bool val);
	void setIsKeyedColumn_null();
	void setIsKeyedColumn(bool val);
	void setDataColumns(IArrayOf<IEspDFUDataColumn> &val);
 void setDataColumns(IArrayOf<IConstDFUDataColumn> &val);
};

class CDFUGetDataColumnsRequest : public CSoapRequestBinding,
   implements IEspDFUGetDataColumnsRequest,
   implements IClientDFUGetDataColumnsRequest
{
protected:
	SoapStringParam m_OpenLogicalName;
	SoapStringParam m_LogicalName;
	SoapStringParam m_FilterBy;
	SoapStringParam m_ShowColumns;
	SoapParam<int> m_ChooseFile;
	SoapStringParam m_Cluster;
	SoapStringParam m_ClusterType;
	SoapParam<__int64> m_StartIndex;
	SoapParam<__int64> m_EndIndex;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CDFUGetDataColumnsRequest(const char *serviceName, const char *bcompat);

	CDFUGetDataColumnsRequest(const char *serviceName, IRpcMessageBinding *init=NULL);
	CDFUGetDataColumnsRequest(const char *serviceName, IRpcMessage* rpcmsg);
	CDFUGetDataColumnsRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	IEspClientRpcSettings &rpc(){return *static_cast<IEspClientRpcSettings*>(this);}


	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "DFUGetDataColumnsRequest";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CDFUGetDataColumnsRequest &from);

	void copy(IConstDFUGetDataColumnsRequest &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstDFUGetDataColumnsRequest &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	const char * getOpenLogicalName();
	const char * getLogicalName();
	const char * getFilterBy();
	const char * getShowColumns();
	int getChooseFile();
	const char * getCluster();
	const char * getClusterType();
	__int64 getStartIndex();
	__int64 getEndIndex();
	void setOpenLogicalName(const char * val);
	void setLogicalName(const char * val);
	void setFilterBy(const char * val);
	void setShowColumns(const char * val);
	void setChooseFile(int val);
	void setCluster(const char * val);
	void setClusterType(const char * val);
	void setStartIndex(__int64 val);
	void setEndIndex(__int64 val);
};

class CDFUGetDataColumnsResponse : public CSoapResponseBinding,
   implements IEspDFUGetDataColumnsResponse,
   implements IClientDFUGetDataColumnsResponse
{
protected:
	SoapStringParam m_LogicalName;
	SoapParam<__int64> m_StartIndex;
	SoapParam<__int64> m_EndIndex;
	SoapStructArrayParam<IConstDFUDataColumn, CDFUDataColumn> m_DFUDataKeyedColumns1;
	SoapStructArrayParam<IConstDFUDataColumn, CDFUDataColumn> m_DFUDataKeyedColumns2;
	SoapStructArrayParam<IConstDFUDataColumn, CDFUDataColumn> m_DFUDataKeyedColumns3;
	SoapStructArrayParam<IConstDFUDataColumn, CDFUDataColumn> m_DFUDataKeyedColumns4;
	SoapStructArrayParam<IConstDFUDataColumn, CDFUDataColumn> m_DFUDataKeyedColumns5;
	SoapStructArrayParam<IConstDFUDataColumn, CDFUDataColumn> m_DFUDataKeyedColumns6;
	SoapStructArrayParam<IConstDFUDataColumn, CDFUDataColumn> m_DFUDataKeyedColumns7;
	SoapStructArrayParam<IConstDFUDataColumn, CDFUDataColumn> m_DFUDataKeyedColumns8;
	SoapStructArrayParam<IConstDFUDataColumn, CDFUDataColumn> m_DFUDataKeyedColumns9;
	SoapStructArrayParam<IConstDFUDataColumn, CDFUDataColumn> m_DFUDataKeyedColumns10;
	SoapStructArrayParam<IConstDFUDataColumn, CDFUDataColumn> m_DFUDataKeyedColumns11;
	SoapStructArrayParam<IConstDFUDataColumn, CDFUDataColumn> m_DFUDataKeyedColumns12;
	SoapStructArrayParam<IConstDFUDataColumn, CDFUDataColumn> m_DFUDataKeyedColumns13;
	SoapStructArrayParam<IConstDFUDataColumn, CDFUDataColumn> m_DFUDataKeyedColumns14;
	SoapStructArrayParam<IConstDFUDataColumn, CDFUDataColumn> m_DFUDataKeyedColumns15;
	SoapStructArrayParam<IConstDFUDataColumn, CDFUDataColumn> m_DFUDataKeyedColumns16;
	SoapStructArrayParam<IConstDFUDataColumn, CDFUDataColumn> m_DFUDataKeyedColumns17;
	SoapStructArrayParam<IConstDFUDataColumn, CDFUDataColumn> m_DFUDataKeyedColumns18;
	SoapStructArrayParam<IConstDFUDataColumn, CDFUDataColumn> m_DFUDataKeyedColumns19;
	SoapStructArrayParam<IConstDFUDataColumn, CDFUDataColumn> m_DFUDataKeyedColumns20;
	SoapStructArrayParam<IConstDFUDataColumn, CDFUDataColumn> m_DFUDataNonKeyedColumns1;
	SoapStructArrayParam<IConstDFUDataColumn, CDFUDataColumn> m_DFUDataNonKeyedColumns2;
	SoapStructArrayParam<IConstDFUDataColumn, CDFUDataColumn> m_DFUDataNonKeyedColumns3;
	SoapStructArrayParam<IConstDFUDataColumn, CDFUDataColumn> m_DFUDataNonKeyedColumns4;
	SoapStructArrayParam<IConstDFUDataColumn, CDFUDataColumn> m_DFUDataNonKeyedColumns5;
	SoapStructArrayParam<IConstDFUDataColumn, CDFUDataColumn> m_DFUDataNonKeyedColumns6;
	SoapStructArrayParam<IConstDFUDataColumn, CDFUDataColumn> m_DFUDataNonKeyedColumns7;
	SoapStructArrayParam<IConstDFUDataColumn, CDFUDataColumn> m_DFUDataNonKeyedColumns8;
	SoapStructArrayParam<IConstDFUDataColumn, CDFUDataColumn> m_DFUDataNonKeyedColumns9;
	SoapStructArrayParam<IConstDFUDataColumn, CDFUDataColumn> m_DFUDataNonKeyedColumns10;
	SoapStructArrayParam<IConstDFUDataColumn, CDFUDataColumn> m_DFUDataNonKeyedColumns11;
	SoapStructArrayParam<IConstDFUDataColumn, CDFUDataColumn> m_DFUDataNonKeyedColumns12;
	SoapStructArrayParam<IConstDFUDataColumn, CDFUDataColumn> m_DFUDataNonKeyedColumns13;
	SoapStructArrayParam<IConstDFUDataColumn, CDFUDataColumn> m_DFUDataNonKeyedColumns14;
	SoapStructArrayParam<IConstDFUDataColumn, CDFUDataColumn> m_DFUDataNonKeyedColumns15;
	SoapStructArrayParam<IConstDFUDataColumn, CDFUDataColumn> m_DFUDataNonKeyedColumns16;
	SoapStructArrayParam<IConstDFUDataColumn, CDFUDataColumn> m_DFUDataNonKeyedColumns17;
	SoapStructArrayParam<IConstDFUDataColumn, CDFUDataColumn> m_DFUDataNonKeyedColumns18;
	SoapStructArrayParam<IConstDFUDataColumn, CDFUDataColumn> m_DFUDataNonKeyedColumns19;
	SoapStructArrayParam<IConstDFUDataColumn, CDFUDataColumn> m_DFUDataNonKeyedColumns20;
	SoapParam<__int64> m_RowCount;
	SoapStringParam m_ShowColumns;
	SoapParam<int> m_ChooseFile;
	SoapStringParam m_Cluster;
	SoapStringParam m_ClusterType;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CDFUGetDataColumnsResponse(const char *serviceName, const char *bcompat);

	CDFUGetDataColumnsResponse(const char *serviceName, IRpcMessageBinding *init=NULL);
	CDFUGetDataColumnsResponse(const char *serviceName, IRpcMessage* rpcmsg);
	CDFUGetDataColumnsResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "DFUGetDataColumnsResponse";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CDFUGetDataColumnsResponse &from);

	void copy(IConstDFUGetDataColumnsResponse &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstDFUGetDataColumnsResponse &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	virtual void setRedirectUrl(const char *url)
	{ CSoapResponseBinding::setRedirectUrl(url); }

	virtual const IMultiException& getExceptions()
	{ return CSoapResponseBinding::getExceptions(); }

	virtual int queryClientStatus()
	{ return CSoapResponseBinding::getRpcState(); }

	virtual void noteException(IException& e)
	{  CSoapResponseBinding::noteException(e); }

	const char * getLogicalName();
bool getStartIndex_isNull();
	__int64 getStartIndex();
bool getEndIndex_isNull();
	__int64 getEndIndex();
	IArrayOf<IConstDFUDataColumn> & getDFUDataKeyedColumns1();
	IArrayOf<IConstDFUDataColumn> & getDFUDataKeyedColumns2();
	IArrayOf<IConstDFUDataColumn> & getDFUDataKeyedColumns3();
	IArrayOf<IConstDFUDataColumn> & getDFUDataKeyedColumns4();
	IArrayOf<IConstDFUDataColumn> & getDFUDataKeyedColumns5();
	IArrayOf<IConstDFUDataColumn> & getDFUDataKeyedColumns6();
	IArrayOf<IConstDFUDataColumn> & getDFUDataKeyedColumns7();
	IArrayOf<IConstDFUDataColumn> & getDFUDataKeyedColumns8();
	IArrayOf<IConstDFUDataColumn> & getDFUDataKeyedColumns9();
	IArrayOf<IConstDFUDataColumn> & getDFUDataKeyedColumns10();
	IArrayOf<IConstDFUDataColumn> & getDFUDataKeyedColumns11();
	IArrayOf<IConstDFUDataColumn> & getDFUDataKeyedColumns12();
	IArrayOf<IConstDFUDataColumn> & getDFUDataKeyedColumns13();
	IArrayOf<IConstDFUDataColumn> & getDFUDataKeyedColumns14();
	IArrayOf<IConstDFUDataColumn> & getDFUDataKeyedColumns15();
	IArrayOf<IConstDFUDataColumn> & getDFUDataKeyedColumns16();
	IArrayOf<IConstDFUDataColumn> & getDFUDataKeyedColumns17();
	IArrayOf<IConstDFUDataColumn> & getDFUDataKeyedColumns18();
	IArrayOf<IConstDFUDataColumn> & getDFUDataKeyedColumns19();
	IArrayOf<IConstDFUDataColumn> & getDFUDataKeyedColumns20();
	IArrayOf<IConstDFUDataColumn> & getDFUDataNonKeyedColumns1();
	IArrayOf<IConstDFUDataColumn> & getDFUDataNonKeyedColumns2();
	IArrayOf<IConstDFUDataColumn> & getDFUDataNonKeyedColumns3();
	IArrayOf<IConstDFUDataColumn> & getDFUDataNonKeyedColumns4();
	IArrayOf<IConstDFUDataColumn> & getDFUDataNonKeyedColumns5();
	IArrayOf<IConstDFUDataColumn> & getDFUDataNonKeyedColumns6();
	IArrayOf<IConstDFUDataColumn> & getDFUDataNonKeyedColumns7();
	IArrayOf<IConstDFUDataColumn> & getDFUDataNonKeyedColumns8();
	IArrayOf<IConstDFUDataColumn> & getDFUDataNonKeyedColumns9();
	IArrayOf<IConstDFUDataColumn> & getDFUDataNonKeyedColumns10();
	IArrayOf<IConstDFUDataColumn> & getDFUDataNonKeyedColumns11();
	IArrayOf<IConstDFUDataColumn> & getDFUDataNonKeyedColumns12();
	IArrayOf<IConstDFUDataColumn> & getDFUDataNonKeyedColumns13();
	IArrayOf<IConstDFUDataColumn> & getDFUDataNonKeyedColumns14();
	IArrayOf<IConstDFUDataColumn> & getDFUDataNonKeyedColumns15();
	IArrayOf<IConstDFUDataColumn> & getDFUDataNonKeyedColumns16();
	IArrayOf<IConstDFUDataColumn> & getDFUDataNonKeyedColumns17();
	IArrayOf<IConstDFUDataColumn> & getDFUDataNonKeyedColumns18();
	IArrayOf<IConstDFUDataColumn> & getDFUDataNonKeyedColumns19();
	IArrayOf<IConstDFUDataColumn> & getDFUDataNonKeyedColumns20();
bool getRowCount_isNull();
	__int64 getRowCount();
	const char * getShowColumns();
bool getChooseFile_isNull();
	int getChooseFile();
	const char * getCluster();
	const char * getClusterType();
	void setLogicalName(const char * val);
	void setStartIndex_null();
	void setStartIndex(__int64 val);
	void setEndIndex_null();
	void setEndIndex(__int64 val);
	void setDFUDataKeyedColumns1(IArrayOf<IEspDFUDataColumn> &val);
 void setDFUDataKeyedColumns1(IArrayOf<IConstDFUDataColumn> &val);
	void setDFUDataKeyedColumns2(IArrayOf<IEspDFUDataColumn> &val);
 void setDFUDataKeyedColumns2(IArrayOf<IConstDFUDataColumn> &val);
	void setDFUDataKeyedColumns3(IArrayOf<IEspDFUDataColumn> &val);
 void setDFUDataKeyedColumns3(IArrayOf<IConstDFUDataColumn> &val);
	void setDFUDataKeyedColumns4(IArrayOf<IEspDFUDataColumn> &val);
 void setDFUDataKeyedColumns4(IArrayOf<IConstDFUDataColumn> &val);
	void setDFUDataKeyedColumns5(IArrayOf<IEspDFUDataColumn> &val);
 void setDFUDataKeyedColumns5(IArrayOf<IConstDFUDataColumn> &val);
	void setDFUDataKeyedColumns6(IArrayOf<IEspDFUDataColumn> &val);
 void setDFUDataKeyedColumns6(IArrayOf<IConstDFUDataColumn> &val);
	void setDFUDataKeyedColumns7(IArrayOf<IEspDFUDataColumn> &val);
 void setDFUDataKeyedColumns7(IArrayOf<IConstDFUDataColumn> &val);
	void setDFUDataKeyedColumns8(IArrayOf<IEspDFUDataColumn> &val);
 void setDFUDataKeyedColumns8(IArrayOf<IConstDFUDataColumn> &val);
	void setDFUDataKeyedColumns9(IArrayOf<IEspDFUDataColumn> &val);
 void setDFUDataKeyedColumns9(IArrayOf<IConstDFUDataColumn> &val);
	void setDFUDataKeyedColumns10(IArrayOf<IEspDFUDataColumn> &val);
 void setDFUDataKeyedColumns10(IArrayOf<IConstDFUDataColumn> &val);
	void setDFUDataKeyedColumns11(IArrayOf<IEspDFUDataColumn> &val);
 void setDFUDataKeyedColumns11(IArrayOf<IConstDFUDataColumn> &val);
	void setDFUDataKeyedColumns12(IArrayOf<IEspDFUDataColumn> &val);
 void setDFUDataKeyedColumns12(IArrayOf<IConstDFUDataColumn> &val);
	void setDFUDataKeyedColumns13(IArrayOf<IEspDFUDataColumn> &val);
 void setDFUDataKeyedColumns13(IArrayOf<IConstDFUDataColumn> &val);
	void setDFUDataKeyedColumns14(IArrayOf<IEspDFUDataColumn> &val);
 void setDFUDataKeyedColumns14(IArrayOf<IConstDFUDataColumn> &val);
	void setDFUDataKeyedColumns15(IArrayOf<IEspDFUDataColumn> &val);
 void setDFUDataKeyedColumns15(IArrayOf<IConstDFUDataColumn> &val);
	void setDFUDataKeyedColumns16(IArrayOf<IEspDFUDataColumn> &val);
 void setDFUDataKeyedColumns16(IArrayOf<IConstDFUDataColumn> &val);
	void setDFUDataKeyedColumns17(IArrayOf<IEspDFUDataColumn> &val);
 void setDFUDataKeyedColumns17(IArrayOf<IConstDFUDataColumn> &val);
	void setDFUDataKeyedColumns18(IArrayOf<IEspDFUDataColumn> &val);
 void setDFUDataKeyedColumns18(IArrayOf<IConstDFUDataColumn> &val);
	void setDFUDataKeyedColumns19(IArrayOf<IEspDFUDataColumn> &val);
 void setDFUDataKeyedColumns19(IArrayOf<IConstDFUDataColumn> &val);
	void setDFUDataKeyedColumns20(IArrayOf<IEspDFUDataColumn> &val);
 void setDFUDataKeyedColumns20(IArrayOf<IConstDFUDataColumn> &val);
	void setDFUDataNonKeyedColumns1(IArrayOf<IEspDFUDataColumn> &val);
 void setDFUDataNonKeyedColumns1(IArrayOf<IConstDFUDataColumn> &val);
	void setDFUDataNonKeyedColumns2(IArrayOf<IEspDFUDataColumn> &val);
 void setDFUDataNonKeyedColumns2(IArrayOf<IConstDFUDataColumn> &val);
	void setDFUDataNonKeyedColumns3(IArrayOf<IEspDFUDataColumn> &val);
 void setDFUDataNonKeyedColumns3(IArrayOf<IConstDFUDataColumn> &val);
	void setDFUDataNonKeyedColumns4(IArrayOf<IEspDFUDataColumn> &val);
 void setDFUDataNonKeyedColumns4(IArrayOf<IConstDFUDataColumn> &val);
	void setDFUDataNonKeyedColumns5(IArrayOf<IEspDFUDataColumn> &val);
 void setDFUDataNonKeyedColumns5(IArrayOf<IConstDFUDataColumn> &val);
	void setDFUDataNonKeyedColumns6(IArrayOf<IEspDFUDataColumn> &val);
 void setDFUDataNonKeyedColumns6(IArrayOf<IConstDFUDataColumn> &val);
	void setDFUDataNonKeyedColumns7(IArrayOf<IEspDFUDataColumn> &val);
 void setDFUDataNonKeyedColumns7(IArrayOf<IConstDFUDataColumn> &val);
	void setDFUDataNonKeyedColumns8(IArrayOf<IEspDFUDataColumn> &val);
 void setDFUDataNonKeyedColumns8(IArrayOf<IConstDFUDataColumn> &val);
	void setDFUDataNonKeyedColumns9(IArrayOf<IEspDFUDataColumn> &val);
 void setDFUDataNonKeyedColumns9(IArrayOf<IConstDFUDataColumn> &val);
	void setDFUDataNonKeyedColumns10(IArrayOf<IEspDFUDataColumn> &val);
 void setDFUDataNonKeyedColumns10(IArrayOf<IConstDFUDataColumn> &val);
	void setDFUDataNonKeyedColumns11(IArrayOf<IEspDFUDataColumn> &val);
 void setDFUDataNonKeyedColumns11(IArrayOf<IConstDFUDataColumn> &val);
	void setDFUDataNonKeyedColumns12(IArrayOf<IEspDFUDataColumn> &val);
 void setDFUDataNonKeyedColumns12(IArrayOf<IConstDFUDataColumn> &val);
	void setDFUDataNonKeyedColumns13(IArrayOf<IEspDFUDataColumn> &val);
 void setDFUDataNonKeyedColumns13(IArrayOf<IConstDFUDataColumn> &val);
	void setDFUDataNonKeyedColumns14(IArrayOf<IEspDFUDataColumn> &val);
 void setDFUDataNonKeyedColumns14(IArrayOf<IConstDFUDataColumn> &val);
	void setDFUDataNonKeyedColumns15(IArrayOf<IEspDFUDataColumn> &val);
 void setDFUDataNonKeyedColumns15(IArrayOf<IConstDFUDataColumn> &val);
	void setDFUDataNonKeyedColumns16(IArrayOf<IEspDFUDataColumn> &val);
 void setDFUDataNonKeyedColumns16(IArrayOf<IConstDFUDataColumn> &val);
	void setDFUDataNonKeyedColumns17(IArrayOf<IEspDFUDataColumn> &val);
 void setDFUDataNonKeyedColumns17(IArrayOf<IConstDFUDataColumn> &val);
	void setDFUDataNonKeyedColumns18(IArrayOf<IEspDFUDataColumn> &val);
 void setDFUDataNonKeyedColumns18(IArrayOf<IConstDFUDataColumn> &val);
	void setDFUDataNonKeyedColumns19(IArrayOf<IEspDFUDataColumn> &val);
 void setDFUDataNonKeyedColumns19(IArrayOf<IConstDFUDataColumn> &val);
	void setDFUDataNonKeyedColumns20(IArrayOf<IEspDFUDataColumn> &val);
 void setDFUDataNonKeyedColumns20(IArrayOf<IConstDFUDataColumn> &val);
	void setRowCount_null();
	void setRowCount(__int64 val);
	void setShowColumns(const char * val);
	void setChooseFile_null();
	void setChooseFile(int val);
	void setCluster(const char * val);
	void setClusterType(const char * val);
};

class CDFUBrowseDataRequest : public CSoapRequestBinding,
   implements IEspDFUBrowseDataRequest,
   implements IClientDFUBrowseDataRequest
{
protected:
	SoapStringParam m_LogicalName;
	SoapStringParam m_FilterBy;
	SoapStringParam m_ShowColumns;
	SoapParam<bool> m_SchemaOnly;
	SoapParam<__int64> m_StartForGoback;
	SoapParam<int> m_CountForGoback;
	SoapParam<int> m_ChooseFile;
	SoapStringParam m_Cluster;
	SoapStringParam m_ClusterType;
	SoapStringParam m_ParentName;
	SoapParam<__int64> m_Start;
	SoapParam<int> m_Count;
	SoapParam<bool> m_DisableUppercaseTranslation;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CDFUBrowseDataRequest(const char *serviceName, const char *bcompat);

	CDFUBrowseDataRequest(const char *serviceName, IRpcMessageBinding *init=NULL);
	CDFUBrowseDataRequest(const char *serviceName, IRpcMessage* rpcmsg);
	CDFUBrowseDataRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	IEspClientRpcSettings &rpc(){return *static_cast<IEspClientRpcSettings*>(this);}


	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "DFUBrowseDataRequest";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CDFUBrowseDataRequest &from);

	void copy(IConstDFUBrowseDataRequest &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstDFUBrowseDataRequest &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	const char * getLogicalName();
	const char * getFilterBy();
	const char * getShowColumns();
	bool getSchemaOnly();
	__int64 getStartForGoback();
	int getCountForGoback();
	int getChooseFile();
	const char * getCluster();
	const char * getClusterType();
	const char * getParentName();
	__int64 getStart();
	int getCount();
	bool getDisableUppercaseTranslation();
	void setLogicalName(const char * val);
	void setFilterBy(const char * val);
	void setShowColumns(const char * val);
	void setSchemaOnly(bool val);
	void setStartForGoback(__int64 val);
	void setCountForGoback(int val);
	void setChooseFile(int val);
	void setCluster(const char * val);
	void setClusterType(const char * val);
	void setParentName(const char * val);
	void setStart(__int64 val);
	void setCount(int val);
	void setDisableUppercaseTranslation(bool val);
};

class CDFUBrowseDataResponse : public CSoapResponseBinding,
   implements IEspDFUBrowseDataResponse,
   implements IClientDFUBrowseDataResponse
{
protected:
	SoapStringParam m_Name;
	SoapStringParam m_LogicalName;
	SoapStringParam m_FilterBy;
	SoapStringParam m_FilterForGoBack;
	SoapStructArrayParam<IConstDFUDataColumn, CDFUDataColumn> m_ColumnsHidden;
	SoapParam<int> m_ColumnCount;
	SoapParam<__int64> m_StartForGoback;
	SoapParam<int> m_CountForGoback;
	SoapParam<int> m_ChooseFile;
	SoapParam<bool> m_SchemaOnly;
	SoapStringParam m_Cluster;
	SoapStringParam m_ClusterType;
	SoapStringParam m_ParentName;
	SoapParam<__int64> m_Start;
	SoapParam<__int64> m_Count;
	SoapParam<__int64> m_PageSize;
	SoapParam<__int64> m_Total;
	SoapStringParam m_Result;
	SoapStringParam m_MsgToDisplay;
	SoapParam<bool> m_DisableUppercaseTranslation;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CDFUBrowseDataResponse(const char *serviceName, const char *bcompat);

	CDFUBrowseDataResponse(const char *serviceName, IRpcMessageBinding *init=NULL);
	CDFUBrowseDataResponse(const char *serviceName, IRpcMessage* rpcmsg);
	CDFUBrowseDataResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "DFUBrowseDataResponse";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CDFUBrowseDataResponse &from);

	void copy(IConstDFUBrowseDataResponse &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstDFUBrowseDataResponse &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	virtual void setRedirectUrl(const char *url)
	{ CSoapResponseBinding::setRedirectUrl(url); }

	virtual const IMultiException& getExceptions()
	{ return CSoapResponseBinding::getExceptions(); }

	virtual int queryClientStatus()
	{ return CSoapResponseBinding::getRpcState(); }

	virtual void noteException(IException& e)
	{  CSoapResponseBinding::noteException(e); }

	const char * getName();
	const char * getLogicalName();
	const char * getFilterBy();
	const char * getFilterForGoBack();
	IArrayOf<IConstDFUDataColumn> & getColumnsHidden();
bool getColumnCount_isNull();
	int getColumnCount();
bool getStartForGoback_isNull();
	__int64 getStartForGoback();
bool getCountForGoback_isNull();
	int getCountForGoback();
bool getChooseFile_isNull();
	int getChooseFile();
bool getSchemaOnly_isNull();
	bool getSchemaOnly();
	const char * getCluster();
	const char * getClusterType();
	const char * getParentName();
bool getStart_isNull();
	__int64 getStart();
bool getCount_isNull();
	__int64 getCount();
bool getPageSize_isNull();
	__int64 getPageSize();
bool getTotal_isNull();
	__int64 getTotal();
	const char * getResult();
	const char * getMsgToDisplay();
bool getDisableUppercaseTranslation_isNull();
	bool getDisableUppercaseTranslation();
	void setName(const char * val);
	void setLogicalName(const char * val);
	void setFilterBy(const char * val);
	void setFilterForGoBack(const char * val);
	void setColumnsHidden(IArrayOf<IEspDFUDataColumn> &val);
 void setColumnsHidden(IArrayOf<IConstDFUDataColumn> &val);
	void setColumnCount_null();
	void setColumnCount(int val);
	void setStartForGoback_null();
	void setStartForGoback(__int64 val);
	void setCountForGoback_null();
	void setCountForGoback(int val);
	void setChooseFile_null();
	void setChooseFile(int val);
	void setSchemaOnly_null();
	void setSchemaOnly(bool val);
	void setCluster(const char * val);
	void setClusterType(const char * val);
	void setParentName(const char * val);
	void setStart_null();
	void setStart(__int64 val);
	void setCount_null();
	void setCount(__int64 val);
	void setPageSize_null();
	void setPageSize(__int64 val);
	void setTotal_null();
	void setTotal(__int64 val);
	void setResult(const char * val);
	void setMsgToDisplay(const char * val);
	void setDisableUppercaseTranslation_null();
	void setDisableUppercaseTranslation(bool val);
};

class CDFUData : public CSoapComplexType,
   implements IEspDFUData,
   implements IClientDFUData
{
protected:
	SoapStringParam m_Name;
	SoapStringParam m_Data;
	SoapParam<__int64> m_NumRows;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CDFUData(const char *serviceName, const char *bcompat);

	CDFUData(const char *serviceName, IRpcMessageBinding *init=NULL);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "DFUData";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CDFUData &from);

	void copy(IConstDFUData &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstDFUData &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	const char * getName();
	const char * getData();
	__int64 getNumRows();
	void setName(const char * val);
	void setData(const char * val);
	void setNumRows(__int64 val);
};

class CDFUSearchDataRequest : public CSoapRequestBinding,
   implements IEspDFUSearchDataRequest,
   implements IClientDFUSearchDataRequest
{
protected:
	SoapStringParam m_Cluster;
	SoapStringParam m_ClusterType;
	SoapStringParam m_OpenLogicalName;
	SoapStringParam m_FilterBy;
	SoapStringParam m_ShowColumns;
	SoapParam<int> m_ChooseFile;
	SoapParam<__int64> m_StartIndex;
	SoapParam<__int64> m_EndIndex;
	SoapStringParam m_LogicalName;
	SoapStringParam m_ParentName;
	SoapParam<__int64> m_StartForGoback;
	SoapParam<int> m_CountForGoback;
	SoapParam<__int64> m_Start;
	SoapParam<int> m_Count;
	SoapStringParam m_File;
	SoapStringParam m_Key;
	SoapParam<bool> m_SchemaOnly;
	SoapParam<bool> m_RoxieSelections;
	SoapParam<bool> m_DisableUppercaseTranslation;
	SoapStringParam m_SelectedKey;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CDFUSearchDataRequest(const char *serviceName, const char *bcompat);

	CDFUSearchDataRequest(const char *serviceName, IRpcMessageBinding *init=NULL);
	CDFUSearchDataRequest(const char *serviceName, IRpcMessage* rpcmsg);
	CDFUSearchDataRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	IEspClientRpcSettings &rpc(){return *static_cast<IEspClientRpcSettings*>(this);}


	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "DFUSearchDataRequest";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CDFUSearchDataRequest &from);

	void copy(IConstDFUSearchDataRequest &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstDFUSearchDataRequest &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	const char * getCluster();
	const char * getClusterType();
	const char * getOpenLogicalName();
	const char * getFilterBy();
	const char * getShowColumns();
	int getChooseFile();
	__int64 getStartIndex();
	__int64 getEndIndex();
	const char * getLogicalName();
	const char * getParentName();
	__int64 getStartForGoback();
	int getCountForGoback();
	__int64 getStart();
	int getCount();
	const char * getFile();
	const char * getKey();
	bool getSchemaOnly();
	bool getRoxieSelections();
	bool getDisableUppercaseTranslation();
	const char * getSelectedKey();
	void setCluster(const char * val);
	void setClusterType(const char * val);
	void setOpenLogicalName(const char * val);
	void setFilterBy(const char * val);
	void setShowColumns(const char * val);
	void setChooseFile(int val);
	void setStartIndex(__int64 val);
	void setEndIndex(__int64 val);
	void setLogicalName(const char * val);
	void setParentName(const char * val);
	void setStartForGoback(__int64 val);
	void setCountForGoback(int val);
	void setStart(__int64 val);
	void setCount(int val);
	void setFile(const char * val);
	void setKey(const char * val);
	void setSchemaOnly(bool val);
	void setRoxieSelections(bool val);
	void setDisableUppercaseTranslation(bool val);
	void setSelectedKey(const char * val);
};

class CDFUSearchDataResponse : public CSoapResponseBinding,
   implements IEspDFUSearchDataResponse,
   implements IClientDFUSearchDataResponse
{
protected:
	SoapStringParam m_OpenLogicalName;
	SoapStringParam m_LogicalName;
	SoapStringParam m_ParentName;
	SoapParam<__int64> m_StartIndex;
	SoapParam<__int64> m_EndIndex;
	SoapStructArrayParam<IConstDFUDataColumn, CDFUDataColumn> m_DFUDataKeyedColumns1;
	SoapStructArrayParam<IConstDFUDataColumn, CDFUDataColumn> m_DFUDataKeyedColumns2;
	SoapStructArrayParam<IConstDFUDataColumn, CDFUDataColumn> m_DFUDataKeyedColumns3;
	SoapStructArrayParam<IConstDFUDataColumn, CDFUDataColumn> m_DFUDataKeyedColumns4;
	SoapStructArrayParam<IConstDFUDataColumn, CDFUDataColumn> m_DFUDataKeyedColumns5;
	SoapStructArrayParam<IConstDFUDataColumn, CDFUDataColumn> m_DFUDataKeyedColumns6;
	SoapStructArrayParam<IConstDFUDataColumn, CDFUDataColumn> m_DFUDataKeyedColumns7;
	SoapStructArrayParam<IConstDFUDataColumn, CDFUDataColumn> m_DFUDataKeyedColumns8;
	SoapStructArrayParam<IConstDFUDataColumn, CDFUDataColumn> m_DFUDataKeyedColumns9;
	SoapStructArrayParam<IConstDFUDataColumn, CDFUDataColumn> m_DFUDataKeyedColumns10;
	SoapStructArrayParam<IConstDFUDataColumn, CDFUDataColumn> m_DFUDataKeyedColumns11;
	SoapStructArrayParam<IConstDFUDataColumn, CDFUDataColumn> m_DFUDataKeyedColumns12;
	SoapStructArrayParam<IConstDFUDataColumn, CDFUDataColumn> m_DFUDataKeyedColumns13;
	SoapStructArrayParam<IConstDFUDataColumn, CDFUDataColumn> m_DFUDataKeyedColumns14;
	SoapStructArrayParam<IConstDFUDataColumn, CDFUDataColumn> m_DFUDataKeyedColumns15;
	SoapStructArrayParam<IConstDFUDataColumn, CDFUDataColumn> m_DFUDataKeyedColumns16;
	SoapStructArrayParam<IConstDFUDataColumn, CDFUDataColumn> m_DFUDataKeyedColumns17;
	SoapStructArrayParam<IConstDFUDataColumn, CDFUDataColumn> m_DFUDataKeyedColumns18;
	SoapStructArrayParam<IConstDFUDataColumn, CDFUDataColumn> m_DFUDataKeyedColumns19;
	SoapStructArrayParam<IConstDFUDataColumn, CDFUDataColumn> m_DFUDataKeyedColumns20;
	SoapStructArrayParam<IConstDFUDataColumn, CDFUDataColumn> m_DFUDataNonKeyedColumns1;
	SoapStructArrayParam<IConstDFUDataColumn, CDFUDataColumn> m_DFUDataNonKeyedColumns2;
	SoapStructArrayParam<IConstDFUDataColumn, CDFUDataColumn> m_DFUDataNonKeyedColumns3;
	SoapStructArrayParam<IConstDFUDataColumn, CDFUDataColumn> m_DFUDataNonKeyedColumns4;
	SoapStructArrayParam<IConstDFUDataColumn, CDFUDataColumn> m_DFUDataNonKeyedColumns5;
	SoapStructArrayParam<IConstDFUDataColumn, CDFUDataColumn> m_DFUDataNonKeyedColumns6;
	SoapStructArrayParam<IConstDFUDataColumn, CDFUDataColumn> m_DFUDataNonKeyedColumns7;
	SoapStructArrayParam<IConstDFUDataColumn, CDFUDataColumn> m_DFUDataNonKeyedColumns8;
	SoapStructArrayParam<IConstDFUDataColumn, CDFUDataColumn> m_DFUDataNonKeyedColumns9;
	SoapStructArrayParam<IConstDFUDataColumn, CDFUDataColumn> m_DFUDataNonKeyedColumns10;
	SoapStructArrayParam<IConstDFUDataColumn, CDFUDataColumn> m_DFUDataNonKeyedColumns11;
	SoapStructArrayParam<IConstDFUDataColumn, CDFUDataColumn> m_DFUDataNonKeyedColumns12;
	SoapStructArrayParam<IConstDFUDataColumn, CDFUDataColumn> m_DFUDataNonKeyedColumns13;
	SoapStructArrayParam<IConstDFUDataColumn, CDFUDataColumn> m_DFUDataNonKeyedColumns14;
	SoapStructArrayParam<IConstDFUDataColumn, CDFUDataColumn> m_DFUDataNonKeyedColumns15;
	SoapStructArrayParam<IConstDFUDataColumn, CDFUDataColumn> m_DFUDataNonKeyedColumns16;
	SoapStructArrayParam<IConstDFUDataColumn, CDFUDataColumn> m_DFUDataNonKeyedColumns17;
	SoapStructArrayParam<IConstDFUDataColumn, CDFUDataColumn> m_DFUDataNonKeyedColumns18;
	SoapStructArrayParam<IConstDFUDataColumn, CDFUDataColumn> m_DFUDataNonKeyedColumns19;
	SoapStructArrayParam<IConstDFUDataColumn, CDFUDataColumn> m_DFUDataNonKeyedColumns20;
	SoapParam<__int64> m_RowCount;
	SoapStringParam m_ShowColumns;
	SoapParam<int> m_ChooseFile;
	SoapStringParam m_Name;
	SoapStringParam m_FilterBy;
	SoapStringParam m_FilterForGoBack;
	SoapStructArrayParam<IConstDFUDataColumn, CDFUDataColumn> m_ColumnsHidden;
	SoapParam<int> m_ColumnCount;
	SoapParam<__int64> m_StartForGoback;
	SoapParam<int> m_CountForGoback;
	SoapParam<__int64> m_Start;
	SoapParam<__int64> m_Count;
	SoapParam<__int64> m_PageSize;
	SoapParam<__int64> m_Total;
	SoapStringParam m_Result;
	SoapStringParam m_MsgToDisplay;
	SoapStringParam m_Cluster;
	SoapStringParam m_ClusterType;
	SoapStringParam m_File;
	SoapStringParam m_Key;
	SoapParam<bool> m_SchemaOnly;
	SoapParam<bool> m_RoxieSelections;
	SoapParam<bool> m_DisableUppercaseTranslation;
	SoapParam<bool> m_AutoUppercaseTranslation;
	SoapStringParam m_SelectedKey;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CDFUSearchDataResponse(const char *serviceName, const char *bcompat);

	CDFUSearchDataResponse(const char *serviceName, IRpcMessageBinding *init=NULL);
	CDFUSearchDataResponse(const char *serviceName, IRpcMessage* rpcmsg);
	CDFUSearchDataResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "DFUSearchDataResponse";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CDFUSearchDataResponse &from);

	void copy(IConstDFUSearchDataResponse &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstDFUSearchDataResponse &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	virtual void setRedirectUrl(const char *url)
	{ CSoapResponseBinding::setRedirectUrl(url); }

	virtual const IMultiException& getExceptions()
	{ return CSoapResponseBinding::getExceptions(); }

	virtual int queryClientStatus()
	{ return CSoapResponseBinding::getRpcState(); }

	virtual void noteException(IException& e)
	{  CSoapResponseBinding::noteException(e); }

	const char * getOpenLogicalName();
	const char * getLogicalName();
	const char * getParentName();
bool getStartIndex_isNull();
	__int64 getStartIndex();
bool getEndIndex_isNull();
	__int64 getEndIndex();
	IArrayOf<IConstDFUDataColumn> & getDFUDataKeyedColumns1();
	IArrayOf<IConstDFUDataColumn> & getDFUDataKeyedColumns2();
	IArrayOf<IConstDFUDataColumn> & getDFUDataKeyedColumns3();
	IArrayOf<IConstDFUDataColumn> & getDFUDataKeyedColumns4();
	IArrayOf<IConstDFUDataColumn> & getDFUDataKeyedColumns5();
	IArrayOf<IConstDFUDataColumn> & getDFUDataKeyedColumns6();
	IArrayOf<IConstDFUDataColumn> & getDFUDataKeyedColumns7();
	IArrayOf<IConstDFUDataColumn> & getDFUDataKeyedColumns8();
	IArrayOf<IConstDFUDataColumn> & getDFUDataKeyedColumns9();
	IArrayOf<IConstDFUDataColumn> & getDFUDataKeyedColumns10();
	IArrayOf<IConstDFUDataColumn> & getDFUDataKeyedColumns11();
	IArrayOf<IConstDFUDataColumn> & getDFUDataKeyedColumns12();
	IArrayOf<IConstDFUDataColumn> & getDFUDataKeyedColumns13();
	IArrayOf<IConstDFUDataColumn> & getDFUDataKeyedColumns14();
	IArrayOf<IConstDFUDataColumn> & getDFUDataKeyedColumns15();
	IArrayOf<IConstDFUDataColumn> & getDFUDataKeyedColumns16();
	IArrayOf<IConstDFUDataColumn> & getDFUDataKeyedColumns17();
	IArrayOf<IConstDFUDataColumn> & getDFUDataKeyedColumns18();
	IArrayOf<IConstDFUDataColumn> & getDFUDataKeyedColumns19();
	IArrayOf<IConstDFUDataColumn> & getDFUDataKeyedColumns20();
	IArrayOf<IConstDFUDataColumn> & getDFUDataNonKeyedColumns1();
	IArrayOf<IConstDFUDataColumn> & getDFUDataNonKeyedColumns2();
	IArrayOf<IConstDFUDataColumn> & getDFUDataNonKeyedColumns3();
	IArrayOf<IConstDFUDataColumn> & getDFUDataNonKeyedColumns4();
	IArrayOf<IConstDFUDataColumn> & getDFUDataNonKeyedColumns5();
	IArrayOf<IConstDFUDataColumn> & getDFUDataNonKeyedColumns6();
	IArrayOf<IConstDFUDataColumn> & getDFUDataNonKeyedColumns7();
	IArrayOf<IConstDFUDataColumn> & getDFUDataNonKeyedColumns8();
	IArrayOf<IConstDFUDataColumn> & getDFUDataNonKeyedColumns9();
	IArrayOf<IConstDFUDataColumn> & getDFUDataNonKeyedColumns10();
	IArrayOf<IConstDFUDataColumn> & getDFUDataNonKeyedColumns11();
	IArrayOf<IConstDFUDataColumn> & getDFUDataNonKeyedColumns12();
	IArrayOf<IConstDFUDataColumn> & getDFUDataNonKeyedColumns13();
	IArrayOf<IConstDFUDataColumn> & getDFUDataNonKeyedColumns14();
	IArrayOf<IConstDFUDataColumn> & getDFUDataNonKeyedColumns15();
	IArrayOf<IConstDFUDataColumn> & getDFUDataNonKeyedColumns16();
	IArrayOf<IConstDFUDataColumn> & getDFUDataNonKeyedColumns17();
	IArrayOf<IConstDFUDataColumn> & getDFUDataNonKeyedColumns18();
	IArrayOf<IConstDFUDataColumn> & getDFUDataNonKeyedColumns19();
	IArrayOf<IConstDFUDataColumn> & getDFUDataNonKeyedColumns20();
bool getRowCount_isNull();
	__int64 getRowCount();
	const char * getShowColumns();
bool getChooseFile_isNull();
	int getChooseFile();
	const char * getName();
	const char * getFilterBy();
	const char * getFilterForGoBack();
	IArrayOf<IConstDFUDataColumn> & getColumnsHidden();
bool getColumnCount_isNull();
	int getColumnCount();
bool getStartForGoback_isNull();
	__int64 getStartForGoback();
bool getCountForGoback_isNull();
	int getCountForGoback();
bool getStart_isNull();
	__int64 getStart();
bool getCount_isNull();
	__int64 getCount();
bool getPageSize_isNull();
	__int64 getPageSize();
bool getTotal_isNull();
	__int64 getTotal();
	const char * getResult();
	const char * getMsgToDisplay();
	const char * getCluster();
	const char * getClusterType();
	const char * getFile();
	const char * getKey();
bool getSchemaOnly_isNull();
	bool getSchemaOnly();
bool getRoxieSelections_isNull();
	bool getRoxieSelections();
bool getDisableUppercaseTranslation_isNull();
	bool getDisableUppercaseTranslation();
bool getAutoUppercaseTranslation_isNull();
	bool getAutoUppercaseTranslation();
	const char * getSelectedKey();
	void setOpenLogicalName(const char * val);
	void setLogicalName(const char * val);
	void setParentName(const char * val);
	void setStartIndex_null();
	void setStartIndex(__int64 val);
	void setEndIndex_null();
	void setEndIndex(__int64 val);
	void setDFUDataKeyedColumns1(IArrayOf<IEspDFUDataColumn> &val);
 void setDFUDataKeyedColumns1(IArrayOf<IConstDFUDataColumn> &val);
	void setDFUDataKeyedColumns2(IArrayOf<IEspDFUDataColumn> &val);
 void setDFUDataKeyedColumns2(IArrayOf<IConstDFUDataColumn> &val);
	void setDFUDataKeyedColumns3(IArrayOf<IEspDFUDataColumn> &val);
 void setDFUDataKeyedColumns3(IArrayOf<IConstDFUDataColumn> &val);
	void setDFUDataKeyedColumns4(IArrayOf<IEspDFUDataColumn> &val);
 void setDFUDataKeyedColumns4(IArrayOf<IConstDFUDataColumn> &val);
	void setDFUDataKeyedColumns5(IArrayOf<IEspDFUDataColumn> &val);
 void setDFUDataKeyedColumns5(IArrayOf<IConstDFUDataColumn> &val);
	void setDFUDataKeyedColumns6(IArrayOf<IEspDFUDataColumn> &val);
 void setDFUDataKeyedColumns6(IArrayOf<IConstDFUDataColumn> &val);
	void setDFUDataKeyedColumns7(IArrayOf<IEspDFUDataColumn> &val);
 void setDFUDataKeyedColumns7(IArrayOf<IConstDFUDataColumn> &val);
	void setDFUDataKeyedColumns8(IArrayOf<IEspDFUDataColumn> &val);
 void setDFUDataKeyedColumns8(IArrayOf<IConstDFUDataColumn> &val);
	void setDFUDataKeyedColumns9(IArrayOf<IEspDFUDataColumn> &val);
 void setDFUDataKeyedColumns9(IArrayOf<IConstDFUDataColumn> &val);
	void setDFUDataKeyedColumns10(IArrayOf<IEspDFUDataColumn> &val);
 void setDFUDataKeyedColumns10(IArrayOf<IConstDFUDataColumn> &val);
	void setDFUDataKeyedColumns11(IArrayOf<IEspDFUDataColumn> &val);
 void setDFUDataKeyedColumns11(IArrayOf<IConstDFUDataColumn> &val);
	void setDFUDataKeyedColumns12(IArrayOf<IEspDFUDataColumn> &val);
 void setDFUDataKeyedColumns12(IArrayOf<IConstDFUDataColumn> &val);
	void setDFUDataKeyedColumns13(IArrayOf<IEspDFUDataColumn> &val);
 void setDFUDataKeyedColumns13(IArrayOf<IConstDFUDataColumn> &val);
	void setDFUDataKeyedColumns14(IArrayOf<IEspDFUDataColumn> &val);
 void setDFUDataKeyedColumns14(IArrayOf<IConstDFUDataColumn> &val);
	void setDFUDataKeyedColumns15(IArrayOf<IEspDFUDataColumn> &val);
 void setDFUDataKeyedColumns15(IArrayOf<IConstDFUDataColumn> &val);
	void setDFUDataKeyedColumns16(IArrayOf<IEspDFUDataColumn> &val);
 void setDFUDataKeyedColumns16(IArrayOf<IConstDFUDataColumn> &val);
	void setDFUDataKeyedColumns17(IArrayOf<IEspDFUDataColumn> &val);
 void setDFUDataKeyedColumns17(IArrayOf<IConstDFUDataColumn> &val);
	void setDFUDataKeyedColumns18(IArrayOf<IEspDFUDataColumn> &val);
 void setDFUDataKeyedColumns18(IArrayOf<IConstDFUDataColumn> &val);
	void setDFUDataKeyedColumns19(IArrayOf<IEspDFUDataColumn> &val);
 void setDFUDataKeyedColumns19(IArrayOf<IConstDFUDataColumn> &val);
	void setDFUDataKeyedColumns20(IArrayOf<IEspDFUDataColumn> &val);
 void setDFUDataKeyedColumns20(IArrayOf<IConstDFUDataColumn> &val);
	void setDFUDataNonKeyedColumns1(IArrayOf<IEspDFUDataColumn> &val);
 void setDFUDataNonKeyedColumns1(IArrayOf<IConstDFUDataColumn> &val);
	void setDFUDataNonKeyedColumns2(IArrayOf<IEspDFUDataColumn> &val);
 void setDFUDataNonKeyedColumns2(IArrayOf<IConstDFUDataColumn> &val);
	void setDFUDataNonKeyedColumns3(IArrayOf<IEspDFUDataColumn> &val);
 void setDFUDataNonKeyedColumns3(IArrayOf<IConstDFUDataColumn> &val);
	void setDFUDataNonKeyedColumns4(IArrayOf<IEspDFUDataColumn> &val);
 void setDFUDataNonKeyedColumns4(IArrayOf<IConstDFUDataColumn> &val);
	void setDFUDataNonKeyedColumns5(IArrayOf<IEspDFUDataColumn> &val);
 void setDFUDataNonKeyedColumns5(IArrayOf<IConstDFUDataColumn> &val);
	void setDFUDataNonKeyedColumns6(IArrayOf<IEspDFUDataColumn> &val);
 void setDFUDataNonKeyedColumns6(IArrayOf<IConstDFUDataColumn> &val);
	void setDFUDataNonKeyedColumns7(IArrayOf<IEspDFUDataColumn> &val);
 void setDFUDataNonKeyedColumns7(IArrayOf<IConstDFUDataColumn> &val);
	void setDFUDataNonKeyedColumns8(IArrayOf<IEspDFUDataColumn> &val);
 void setDFUDataNonKeyedColumns8(IArrayOf<IConstDFUDataColumn> &val);
	void setDFUDataNonKeyedColumns9(IArrayOf<IEspDFUDataColumn> &val);
 void setDFUDataNonKeyedColumns9(IArrayOf<IConstDFUDataColumn> &val);
	void setDFUDataNonKeyedColumns10(IArrayOf<IEspDFUDataColumn> &val);
 void setDFUDataNonKeyedColumns10(IArrayOf<IConstDFUDataColumn> &val);
	void setDFUDataNonKeyedColumns11(IArrayOf<IEspDFUDataColumn> &val);
 void setDFUDataNonKeyedColumns11(IArrayOf<IConstDFUDataColumn> &val);
	void setDFUDataNonKeyedColumns12(IArrayOf<IEspDFUDataColumn> &val);
 void setDFUDataNonKeyedColumns12(IArrayOf<IConstDFUDataColumn> &val);
	void setDFUDataNonKeyedColumns13(IArrayOf<IEspDFUDataColumn> &val);
 void setDFUDataNonKeyedColumns13(IArrayOf<IConstDFUDataColumn> &val);
	void setDFUDataNonKeyedColumns14(IArrayOf<IEspDFUDataColumn> &val);
 void setDFUDataNonKeyedColumns14(IArrayOf<IConstDFUDataColumn> &val);
	void setDFUDataNonKeyedColumns15(IArrayOf<IEspDFUDataColumn> &val);
 void setDFUDataNonKeyedColumns15(IArrayOf<IConstDFUDataColumn> &val);
	void setDFUDataNonKeyedColumns16(IArrayOf<IEspDFUDataColumn> &val);
 void setDFUDataNonKeyedColumns16(IArrayOf<IConstDFUDataColumn> &val);
	void setDFUDataNonKeyedColumns17(IArrayOf<IEspDFUDataColumn> &val);
 void setDFUDataNonKeyedColumns17(IArrayOf<IConstDFUDataColumn> &val);
	void setDFUDataNonKeyedColumns18(IArrayOf<IEspDFUDataColumn> &val);
 void setDFUDataNonKeyedColumns18(IArrayOf<IConstDFUDataColumn> &val);
	void setDFUDataNonKeyedColumns19(IArrayOf<IEspDFUDataColumn> &val);
 void setDFUDataNonKeyedColumns19(IArrayOf<IConstDFUDataColumn> &val);
	void setDFUDataNonKeyedColumns20(IArrayOf<IEspDFUDataColumn> &val);
 void setDFUDataNonKeyedColumns20(IArrayOf<IConstDFUDataColumn> &val);
	void setRowCount_null();
	void setRowCount(__int64 val);
	void setShowColumns(const char * val);
	void setChooseFile_null();
	void setChooseFile(int val);
	void setName(const char * val);
	void setFilterBy(const char * val);
	void setFilterForGoBack(const char * val);
	void setColumnsHidden(IArrayOf<IEspDFUDataColumn> &val);
 void setColumnsHidden(IArrayOf<IConstDFUDataColumn> &val);
	void setColumnCount_null();
	void setColumnCount(int val);
	void setStartForGoback_null();
	void setStartForGoback(__int64 val);
	void setCountForGoback_null();
	void setCountForGoback(int val);
	void setStart_null();
	void setStart(__int64 val);
	void setCount_null();
	void setCount(__int64 val);
	void setPageSize_null();
	void setPageSize(__int64 val);
	void setTotal_null();
	void setTotal(__int64 val);
	void setResult(const char * val);
	void setMsgToDisplay(const char * val);
	void setCluster(const char * val);
	void setClusterType(const char * val);
	void setFile(const char * val);
	void setKey(const char * val);
	void setSchemaOnly_null();
	void setSchemaOnly(bool val);
	void setRoxieSelections_null();
	void setRoxieSelections(bool val);
	void setDisableUppercaseTranslation_null();
	void setDisableUppercaseTranslation(bool val);
	void setAutoUppercaseTranslation_null();
	void setAutoUppercaseTranslation(bool val);
	void setSelectedKey(const char * val);
};

class CDFUGetFileMetaDataRequest : public CSoapRequestBinding,
   implements IEspDFUGetFileMetaDataRequest,
   implements IClientDFUGetFileMetaDataRequest
{
protected:
	SoapStringParam m_LogicalFileName;
	SoapStringParam m_ClusterName;
	SoapParam<bool> m_IncludeXmlSchema;
	SoapParam<bool> m_AddHeaderInXmlSchema;
	SoapParam<bool> m_IncludeXmlXPathSchema;
	SoapParam<bool> m_AddHeaderInXmlXPathSchema;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CDFUGetFileMetaDataRequest(const char *serviceName, const char *bcompat);

	CDFUGetFileMetaDataRequest(const char *serviceName, IRpcMessageBinding *init=NULL);
	CDFUGetFileMetaDataRequest(const char *serviceName, IRpcMessage* rpcmsg);
	CDFUGetFileMetaDataRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	IEspClientRpcSettings &rpc(){return *static_cast<IEspClientRpcSettings*>(this);}


	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "DFUGetFileMetaDataRequest";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CDFUGetFileMetaDataRequest &from);

	void copy(IConstDFUGetFileMetaDataRequest &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstDFUGetFileMetaDataRequest &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	const char * getLogicalFileName();
	const char * getClusterName();
	bool getIncludeXmlSchema();
	bool getAddHeaderInXmlSchema();
	bool getIncludeXmlXPathSchema();
	bool getAddHeaderInXmlXPathSchema();
	void setLogicalFileName(const char * val);
	void setClusterName(const char * val);
	void setIncludeXmlSchema(bool val);
	void setAddHeaderInXmlSchema(bool val);
	void setIncludeXmlXPathSchema(bool val);
	void setAddHeaderInXmlXPathSchema(bool val);
};

class CDFUGetFileMetaDataResponse : public CSoapResponseBinding,
   implements IEspDFUGetFileMetaDataResponse,
   implements IClientDFUGetFileMetaDataResponse
{
protected:
	SoapParam<int> m_TotalColumnCount;
	SoapParam<int> m_KeyedColumnCount;
	SoapStructArrayParam<IConstDFUDataColumn, CDFUDataColumn> m_DataColumns;
	SoapStringParam m_XmlSchema;
	SoapStringParam m_XmlXPathSchema;
	SoapParam<__int64> m_TotalResultRows;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CDFUGetFileMetaDataResponse(const char *serviceName, const char *bcompat);

	CDFUGetFileMetaDataResponse(const char *serviceName, IRpcMessageBinding *init=NULL);
	CDFUGetFileMetaDataResponse(const char *serviceName, IRpcMessage* rpcmsg);
	CDFUGetFileMetaDataResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "DFUGetFileMetaDataResponse";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CDFUGetFileMetaDataResponse &from);

	void copy(IConstDFUGetFileMetaDataResponse &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstDFUGetFileMetaDataResponse &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	virtual void setRedirectUrl(const char *url)
	{ CSoapResponseBinding::setRedirectUrl(url); }

	virtual const IMultiException& getExceptions()
	{ return CSoapResponseBinding::getExceptions(); }

	virtual int queryClientStatus()
	{ return CSoapResponseBinding::getRpcState(); }

	virtual void noteException(IException& e)
	{  CSoapResponseBinding::noteException(e); }

bool getTotalColumnCount_isNull();
	int getTotalColumnCount();
bool getKeyedColumnCount_isNull();
	int getKeyedColumnCount();
	IArrayOf<IConstDFUDataColumn> & getDataColumns();
	const char * getXmlSchema();
	const char * getXmlXPathSchema();
bool getTotalResultRows_isNull();
	__int64 getTotalResultRows();
	void setTotalColumnCount_null();
	void setTotalColumnCount(int val);
	void setKeyedColumnCount_null();
	void setKeyedColumnCount(int val);
	void setDataColumns(IArrayOf<IEspDFUDataColumn> &val);
 void setDataColumns(IArrayOf<IConstDFUDataColumn> &val);
	void setXmlSchema(const char * val);
	void setXmlXPathSchema(const char * val);
	void setTotalResultRows_null();
	void setTotalResultRows(__int64 val);
};

class CListHistoryRequest : public CSoapRequestBinding,
   implements IEspListHistoryRequest,
   implements IClientListHistoryRequest
{
protected:
	SoapStringParam m_Name;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CListHistoryRequest(const char *serviceName, const char *bcompat);

	CListHistoryRequest(const char *serviceName, IRpcMessageBinding *init=NULL);
	CListHistoryRequest(const char *serviceName, IRpcMessage* rpcmsg);
	CListHistoryRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	IEspClientRpcSettings &rpc(){return *static_cast<IEspClientRpcSettings*>(this);}


	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "ListHistoryRequest";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CListHistoryRequest &from);

	void copy(IConstListHistoryRequest &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstListHistoryRequest &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	const char * getName();
	void setName(const char * val);
};

class CHistory : public CSoapComplexType,
   implements IEspHistory,
   implements IClientHistory
{
protected:
	SoapStringParam m_Name;
	SoapStringParam m_Operation;
	SoapStringParam m_Timestamp;
	SoapStringParam m_IP;
	SoapStringParam m_Path;
	SoapStringParam m_Owner;
	SoapStringParam m_Workunit;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CHistory(const char *serviceName, const char *bcompat);

	CHistory(const char *serviceName, IRpcMessageBinding *init=NULL);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "History";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CHistory &from);

	void copy(IConstHistory &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstHistory &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	const char * getName();
	const char * getOperation();
	const char * getTimestamp();
	const char * getIP();
	const char * getPath();
	const char * getOwner();
	const char * getWorkunit();
	void setName(const char * val);
	void setOperation(const char * val);
	void setTimestamp(const char * val);
	void setIP(const char * val);
	void setPath(const char * val);
	void setOwner(const char * val);
	void setWorkunit(const char * val);
};

class CListHistoryResponse : public CSoapResponseBinding,
   implements IEspListHistoryResponse,
   implements IClientListHistoryResponse
{
protected:
	SoapParamBinary m_xmlmap;
	SoapStructArrayParam<IConstHistory, CHistory> m_History;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CListHistoryResponse(const char *serviceName, const char *bcompat);

	CListHistoryResponse(const char *serviceName, IRpcMessageBinding *init=NULL);
	CListHistoryResponse(const char *serviceName, IRpcMessage* rpcmsg);
	CListHistoryResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "ListHistoryResponse";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CListHistoryResponse &from);

	void copy(IConstListHistoryResponse &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstListHistoryResponse &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	virtual void setRedirectUrl(const char *url)
	{ CSoapResponseBinding::setRedirectUrl(url); }

	virtual const IMultiException& getExceptions()
	{ return CSoapResponseBinding::getExceptions(); }

	virtual int queryClientStatus()
	{ return CSoapResponseBinding::getRpcState(); }

	virtual void noteException(IException& e)
	{  CSoapResponseBinding::noteException(e); }

	const MemoryBuffer & getXmlmap();
	IArrayOf<IConstHistory> & getHistory();
	void setXmlmap(const MemoryBuffer & val);
	void setHistory(IArrayOf<IEspHistory> &val);
 void setHistory(IArrayOf<IConstHistory> &val);
};

class CEraseHistoryRequest : public CSoapRequestBinding,
   implements IEspEraseHistoryRequest,
   implements IClientEraseHistoryRequest
{
protected:
	SoapStringParam m_Name;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CEraseHistoryRequest(const char *serviceName, const char *bcompat);

	CEraseHistoryRequest(const char *serviceName, IRpcMessageBinding *init=NULL);
	CEraseHistoryRequest(const char *serviceName, IRpcMessage* rpcmsg);
	CEraseHistoryRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	IEspClientRpcSettings &rpc(){return *static_cast<IEspClientRpcSettings*>(this);}


	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "EraseHistoryRequest";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CEraseHistoryRequest &from);

	void copy(IConstEraseHistoryRequest &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstEraseHistoryRequest &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	const char * getName();
	void setName(const char * val);
};

class CEraseHistoryResponse : public CSoapResponseBinding,
   implements IEspEraseHistoryResponse,
   implements IClientEraseHistoryResponse
{
protected:
	SoapParamBinary m_xmlmap;
	SoapStructArrayParam<IConstHistory, CHistory> m_History;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CEraseHistoryResponse(const char *serviceName, const char *bcompat);

	CEraseHistoryResponse(const char *serviceName, IRpcMessageBinding *init=NULL);
	CEraseHistoryResponse(const char *serviceName, IRpcMessage* rpcmsg);
	CEraseHistoryResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "EraseHistoryResponse";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CEraseHistoryResponse &from);

	void copy(IConstEraseHistoryResponse &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstEraseHistoryResponse &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	virtual void setRedirectUrl(const char *url)
	{ CSoapResponseBinding::setRedirectUrl(url); }

	virtual const IMultiException& getExceptions()
	{ return CSoapResponseBinding::getExceptions(); }

	virtual int queryClientStatus()
	{ return CSoapResponseBinding::getRpcState(); }

	virtual void noteException(IException& e)
	{  CSoapResponseBinding::noteException(e); }

	const MemoryBuffer & getXmlmap();
	IArrayOf<IConstHistory> & getHistory();
	void setXmlmap(const MemoryBuffer & val);
	void setHistory(IArrayOf<IEspHistory> &val);
 void setHistory(IArrayOf<IConstHistory> &val);
};

class CDFUFileAccessRequestBase : public CSoapComplexType,
   implements IEspDFUFileAccessRequestBase,
   implements IClientDFUFileAccessRequestBase
{
protected:
	SoapStringParam m_Name;
	SoapStringParam m_Cluster;
	SoapStringParam m_JobId;
	SoapParam<int> m_ExpirySeconds;
	CXFileAccessRole m_AccessRole;
	CXSecAccessType m_AccessType;
	SoapParam<bool> m_ReturnJsonTypeInfo;
	SoapParam<bool> m_ReturnBinTypeInfo;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CDFUFileAccessRequestBase(const char *serviceName, const char *bcompat);

	CDFUFileAccessRequestBase(const char *serviceName, IRpcMessageBinding *init=NULL);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "DFUFileAccessRequestBase";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CDFUFileAccessRequestBase &from);

	void copy(IConstDFUFileAccessRequestBase &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstDFUFileAccessRequestBase &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	const char * getName();
	const char * getCluster();
	const char * getJobId();
	int getExpirySeconds();
	CFileAccessRole getAccessRole();
	const char* getAccessRoleAsString();
	CSecAccessType getAccessType();
	const char* getAccessTypeAsString();
	bool getReturnJsonTypeInfo();
	bool getReturnBinTypeInfo();
	void setName(const char * val);
	void setCluster(const char * val);
	void setJobId(const char * val);
	void setExpirySeconds(int val);
	void setAccessRole(CFileAccessRole val);
void setAccessRole(const char* val);
	void setAccessType(CSecAccessType val);
void setAccessType(const char* val);
	void setReturnJsonTypeInfo(bool val);
	void setReturnBinTypeInfo(bool val);
};

class CDFUFileAccessRequest : public CSoapRequestBinding,
   implements IEspDFUFileAccessRequest,
   implements IClientDFUFileAccessRequest
{
protected:
	SoapStruct<CDFUFileAccessRequestBase, IConstDFUFileAccessRequestBase> m_RequestBase;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CDFUFileAccessRequest(const char *serviceName, const char *bcompat);

	CDFUFileAccessRequest(const char *serviceName, IRpcMessageBinding *init=NULL);
	CDFUFileAccessRequest(const char *serviceName, IRpcMessage* rpcmsg);
	CDFUFileAccessRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	IEspClientRpcSettings &rpc(){return *static_cast<IEspClientRpcSettings*>(this);}


	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "DFUFileAccessRequest";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CDFUFileAccessRequest &from);

	void copy(IConstDFUFileAccessRequest &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstDFUFileAccessRequest &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	IConstDFUFileAccessRequestBase & getRequestBase();
	IEspDFUFileAccessRequestBase & updateRequestBase();
	void setRequestBase(IConstDFUFileAccessRequestBase &ifrom);
};

class CDFUFileAccessV2Request : public CSoapRequestBinding,
   implements IEspDFUFileAccessV2Request,
   implements IClientDFUFileAccessV2Request
{
protected:
	SoapStringParam m_Name;
	SoapStringParam m_Cluster;
	SoapStringParam m_RequestId;
	SoapParam<int> m_ExpirySeconds;
	SoapParam<bool> m_ReturnTextResponse;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CDFUFileAccessV2Request(const char *serviceName, const char *bcompat);

	CDFUFileAccessV2Request(const char *serviceName, IRpcMessageBinding *init=NULL);
	CDFUFileAccessV2Request(const char *serviceName, IRpcMessage* rpcmsg);
	CDFUFileAccessV2Request(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	IEspClientRpcSettings &rpc(){return *static_cast<IEspClientRpcSettings*>(this);}


	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "DFUFileAccessV2Request";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CDFUFileAccessV2Request &from);

	void copy(IConstDFUFileAccessV2Request &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstDFUFileAccessV2Request &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	const char * getName();
	const char * getCluster();
	const char * getRequestId();
	int getExpirySeconds();
	bool getReturnTextResponse();
	void setName(const char * val);
	void setCluster(const char * val);
	void setRequestId(const char * val);
	void setExpirySeconds(int val);
	void setReturnTextResponse(bool val);
};

class CDFUPartLocation : public CSoapComplexType,
   implements IEspDFUPartLocation,
   implements IClientDFUPartLocation
{
protected:
	SoapParam<int> m_LocationIndex;
	SoapStringParam m_Host;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CDFUPartLocation(const char *serviceName, const char *bcompat);

	CDFUPartLocation(const char *serviceName, IRpcMessageBinding *init=NULL);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "DFUPartLocation";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CDFUPartLocation &from);

	void copy(IConstDFUPartLocation &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstDFUPartLocation &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	int getLocationIndex();
	const char * getHost();
	void setLocationIndex(int val);
	void setHost(const char * val);
};

class CDFUFileCopy : public CSoapComplexType,
   implements IEspDFUFileCopy,
   implements IClientDFUFileCopy
{
protected:
	SoapParam<int> m_CopyIndex;
	SoapParam<int> m_LocationIndex;
	SoapStringParam m_Path;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CDFUFileCopy(const char *serviceName, const char *bcompat);

	CDFUFileCopy(const char *serviceName, IRpcMessageBinding *init=NULL);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "DFUFileCopy";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CDFUFileCopy &from);

	void copy(IConstDFUFileCopy &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstDFUFileCopy &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	int getCopyIndex();
	int getLocationIndex();
	const char * getPath();
	void setCopyIndex(int val);
	void setLocationIndex(int val);
	void setPath(const char * val);
};

class CDFUFilePart : public CSoapComplexType,
   implements IEspDFUFilePart,
   implements IClientDFUFilePart
{
protected:
	SoapParam<int> m_PartIndex;
	SoapStructArrayParam<IConstDFUFileCopy, CDFUFileCopy> m_Copies;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CDFUFilePart(const char *serviceName, const char *bcompat);

	CDFUFilePart(const char *serviceName, IRpcMessageBinding *init=NULL);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "DFUFilePart";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CDFUFilePart &from);

	void copy(IConstDFUFilePart &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstDFUFilePart &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	int getPartIndex();
	IArrayOf<IConstDFUFileCopy> & getCopies();
	void setPartIndex(int val);
	void setCopies(IArrayOf<IEspDFUFileCopy> &val);
 void setCopies(IArrayOf<IConstDFUFileCopy> &val);
};

class CDFUFileAccessInfo : public CSoapComplexType,
   implements IEspDFUFileAccessInfo,
   implements IClientDFUFileAccessInfo
{
protected:
	SoapStringParam m_MetaInfoBlob;
	SoapStringParam m_ExpiryTime;
	SoapParam<int> m_NumParts;
	SoapStructArrayParam<IConstDFUPartLocation, CDFUPartLocation> m_FileLocations;
	SoapStructArrayParam<IConstDFUFilePart, CDFUFilePart> m_FileParts;
	SoapParamBinary m_RecordTypeInfoBin;
	SoapStringParam m_RecordTypeInfoJson;
	SoapParam<int> m_fileAccessPort;
	SoapParam<bool> m_fileAccessSSL;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CDFUFileAccessInfo(const char *serviceName, const char *bcompat);

	CDFUFileAccessInfo(const char *serviceName, IRpcMessageBinding *init=NULL);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "DFUFileAccessInfo";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CDFUFileAccessInfo &from);

	void copy(IConstDFUFileAccessInfo &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstDFUFileAccessInfo &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	const char * getMetaInfoBlob();
	const char * getExpiryTime();
	int getNumParts();
	IArrayOf<IConstDFUPartLocation> & getFileLocations();
	IArrayOf<IConstDFUFilePart> & getFileParts();
	const MemoryBuffer & getRecordTypeInfoBin();
	const char * getRecordTypeInfoJson();
	int getFileAccessPort();
	bool getFileAccessSSL();
	void setMetaInfoBlob(const char * val);
	void setExpiryTime(const char * val);
	void setNumParts(int val);
	void setFileLocations(IArrayOf<IEspDFUPartLocation> &val);
 void setFileLocations(IArrayOf<IConstDFUPartLocation> &val);
	void setFileParts(IArrayOf<IEspDFUFilePart> &val);
 void setFileParts(IArrayOf<IConstDFUFilePart> &val);
	void setRecordTypeInfoBin(const MemoryBuffer & val);
	void setRecordTypeInfoJson(const char * val);
	void setFileAccessPort(int val);
	void setFileAccessSSL(bool val);
};

class CDFUFileAccessResponse : public CSoapResponseBinding,
   implements IEspDFUFileAccessResponse,
   implements IClientDFUFileAccessResponse
{
protected:
	SoapStruct<CDFUFileAccessInfo, IConstDFUFileAccessInfo> m_AccessInfo;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CDFUFileAccessResponse(const char *serviceName, const char *bcompat);

	CDFUFileAccessResponse(const char *serviceName, IRpcMessageBinding *init=NULL);
	CDFUFileAccessResponse(const char *serviceName, IRpcMessage* rpcmsg);
	CDFUFileAccessResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "DFUFileAccessResponse";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CDFUFileAccessResponse &from);

	void copy(IConstDFUFileAccessResponse &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstDFUFileAccessResponse &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	virtual void setRedirectUrl(const char *url)
	{ CSoapResponseBinding::setRedirectUrl(url); }

	virtual const IMultiException& getExceptions()
	{ return CSoapResponseBinding::getExceptions(); }

	virtual int queryClientStatus()
	{ return CSoapResponseBinding::getRpcState(); }

	virtual void noteException(IException& e)
	{  CSoapResponseBinding::noteException(e); }

	IConstDFUFileAccessInfo & getAccessInfo();
	IEspDFUFileAccessInfo & updateAccessInfo();
	void setAccessInfo(IConstDFUFileAccessInfo &ifrom);
};

class CXDFUFileType : public SoapEnumParamNew<CDFUFileType>
{
public:
	CXDFUFileType(nilBehavior nilB) : SoapEnumParamNew<CDFUFileType>(nilB)
	{ doInit(); }
	CXDFUFileType(CDFUFileType defvalue_) : SoapEnumParamNew<CDFUFileType>(defvalue_)
	{ doInit(); }
	CXDFUFileType(const char* defvalue_) : SoapEnumParamNew<CDFUFileType>()
	{ doInit(); setDefaultValue(defvalue_); }
	static  void getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash &added)
	{ getSharedInstance().getXsdDefinitionInternal(context,request,schema,added); }
	static void getMapInfo(IMapInfo& info, BoolHash& added) { getSharedInstance().getMapInfo_(info,added); }

	static const char* stringOf(CDFUFileType val) { return getSharedInstance().toString(val); }

	static CDFUFileType enumOf(const char* s) { return getSharedInstance().toEnum(s); }

static const char *queryXsdElementName() { return "DFUFileType"; }
private:
	static CXDFUFileType& getSharedInstance() { static CXDFUFileType instance(nilIgnore); return instance; }
	void getMapInfo_(IMapInfo& info, BoolHash& added) {  }
	void getXsdDefinitionInternal(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash &added)
	{ getXsdDefinition_(context,request,schema,added,NULL); }
	void doInit()
	{
		static const char* inits[] = {"Flat","Index","Xml","Csv",NULL};
		init("DFUFileType","string",inits);
	}
};

class CDFUFileCreateRequest : public CSoapRequestBinding,
   implements IEspDFUFileCreateRequest,
   implements IClientDFUFileCreateRequest
{
protected:
	SoapStringParam m_ECLRecordDefinition;
	SoapStringArray m_PartLocations;
	SoapStruct<CDFUFileAccessRequestBase, IConstDFUFileAccessRequestBase> m_RequestBase;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CDFUFileCreateRequest(const char *serviceName, const char *bcompat);

	CDFUFileCreateRequest(const char *serviceName, IRpcMessageBinding *init=NULL);
	CDFUFileCreateRequest(const char *serviceName, IRpcMessage* rpcmsg);
	CDFUFileCreateRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	IEspClientRpcSettings &rpc(){return *static_cast<IEspClientRpcSettings*>(this);}


	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "DFUFileCreateRequest";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CDFUFileCreateRequest &from);

	void copy(IConstDFUFileCreateRequest &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstDFUFileCreateRequest &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	const char * getECLRecordDefinition();
	StringArray & getPartLocations();
	IConstDFUFileAccessRequestBase & getRequestBase();
	void setECLRecordDefinition(const char * val);
	void setPartLocations(StringArray &val);
	IEspDFUFileAccessRequestBase & updateRequestBase();
	void setRequestBase(IConstDFUFileAccessRequestBase &ifrom);
};

class CDFUFileCreateV2Request : public CSoapRequestBinding,
   implements IEspDFUFileCreateV2Request,
   implements IClientDFUFileCreateV2Request
{
protected:
	SoapStringParam m_Name;
	SoapStringParam m_Cluster;
	CXDFUFileType m_Type;
	SoapStringParam m_ECLRecordDefinition;
	SoapStringParam m_RequestId;
	SoapParam<int> m_ExpirySeconds;
	SoapParam<bool> m_ReturnTextResponse;
	SoapParam<bool> m_Compressed;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CDFUFileCreateV2Request(const char *serviceName, const char *bcompat);

	CDFUFileCreateV2Request(const char *serviceName, IRpcMessageBinding *init=NULL);
	CDFUFileCreateV2Request(const char *serviceName, IRpcMessage* rpcmsg);
	CDFUFileCreateV2Request(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	IEspClientRpcSettings &rpc(){return *static_cast<IEspClientRpcSettings*>(this);}


	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "DFUFileCreateV2Request";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CDFUFileCreateV2Request &from);

	void copy(IConstDFUFileCreateV2Request &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstDFUFileCreateV2Request &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	const char * getName();
	const char * getCluster();
	CDFUFileType getType();
	const char* getTypeAsString();
	const char * getECLRecordDefinition();
	const char * getRequestId();
bool getExpirySeconds_isNull();
	int getExpirySeconds();
bool getReturnTextResponse_isNull();
	bool getReturnTextResponse();
bool getCompressed_isNull();
	bool getCompressed();
	void setName(const char * val);
	void setCluster(const char * val);
	void setType(CDFUFileType val);
void setType(const char* val);
	void setECLRecordDefinition(const char * val);
	void setRequestId(const char * val);
	void setExpirySeconds_null();
	void setExpirySeconds(int val);
	void setReturnTextResponse_null();
	void setReturnTextResponse(bool val);
	void setCompressed_null();
	void setCompressed(bool val);
};

class CDFUFileCreateResponse : public CSoapResponseBinding,
   implements IEspDFUFileCreateResponse,
   implements IClientDFUFileCreateResponse
{
protected:
	SoapStringParam m_FileId;
	SoapStringParam m_Warning;
	SoapStruct<CDFUFileAccessInfo, IConstDFUFileAccessInfo> m_AccessInfo;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CDFUFileCreateResponse(const char *serviceName, const char *bcompat);

	CDFUFileCreateResponse(const char *serviceName, IRpcMessageBinding *init=NULL);
	CDFUFileCreateResponse(const char *serviceName, IRpcMessage* rpcmsg);
	CDFUFileCreateResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "DFUFileCreateResponse";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CDFUFileCreateResponse &from);

	void copy(IConstDFUFileCreateResponse &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstDFUFileCreateResponse &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	virtual void setRedirectUrl(const char *url)
	{ CSoapResponseBinding::setRedirectUrl(url); }

	virtual const IMultiException& getExceptions()
	{ return CSoapResponseBinding::getExceptions(); }

	virtual int queryClientStatus()
	{ return CSoapResponseBinding::getRpcState(); }

	virtual void noteException(IException& e)
	{  CSoapResponseBinding::noteException(e); }

	const char * getFileId();
	const char * getWarning();
	IConstDFUFileAccessInfo & getAccessInfo();
	void setFileId(const char * val);
	void setWarning(const char * val);
	IEspDFUFileAccessInfo & updateAccessInfo();
	void setAccessInfo(IConstDFUFileAccessInfo &ifrom);
};

class CDFUFilePublishRequest : public CSoapRequestBinding,
   implements IEspDFUFilePublishRequest,
   implements IClientDFUFilePublishRequest
{
protected:
	SoapStringParam m_FileId;
	SoapParam<bool> m_Overwrite;
	SoapParamBinary m_FileDescriptorBlob;
	SoapStringParam m_ECLRecordDefinition;
	SoapParam<__int64> m_RecordCount;
	SoapParam<__int64> m_FileSize;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CDFUFilePublishRequest(const char *serviceName, const char *bcompat);

	CDFUFilePublishRequest(const char *serviceName, IRpcMessageBinding *init=NULL);
	CDFUFilePublishRequest(const char *serviceName, IRpcMessage* rpcmsg);
	CDFUFilePublishRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	IEspClientRpcSettings &rpc(){return *static_cast<IEspClientRpcSettings*>(this);}


	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "DFUFilePublishRequest";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CDFUFilePublishRequest &from);

	void copy(IConstDFUFilePublishRequest &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstDFUFilePublishRequest &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	const char * getFileId();
bool getOverwrite_isNull();
	bool getOverwrite();
	const MemoryBuffer & getFileDescriptorBlob();
	const char * getECLRecordDefinition();
bool getRecordCount_isNull();
	__int64 getRecordCount();
bool getFileSize_isNull();
	__int64 getFileSize();
	void setFileId(const char * val);
	void setOverwrite_null();
	void setOverwrite(bool val);
	void setFileDescriptorBlob(const MemoryBuffer & val);
	void setECLRecordDefinition(const char * val);
	void setRecordCount_null();
	void setRecordCount(__int64 val);
	void setFileSize_null();
	void setFileSize(__int64 val);
};

class CDFUFilePublishResponse : public CSoapResponseBinding,
   implements IEspDFUFilePublishResponse,
   implements IClientDFUFilePublishResponse
{
protected:

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CDFUFilePublishResponse(const char *serviceName, const char *bcompat);

	CDFUFilePublishResponse(const char *serviceName, IRpcMessageBinding *init=NULL);
	CDFUFilePublishResponse(const char *serviceName, IRpcMessage* rpcmsg);
	CDFUFilePublishResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "DFUFilePublishResponse";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CDFUFilePublishResponse &from);

	void copy(IConstDFUFilePublishResponse &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstDFUFilePublishResponse &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	virtual void setRedirectUrl(const char *url)
	{ CSoapResponseBinding::setRedirectUrl(url); }

	virtual const IMultiException& getExceptions()
	{ return CSoapResponseBinding::getExceptions(); }

	virtual int queryClientStatus()
	{ return CSoapResponseBinding::getRpcState(); }

	virtual void noteException(IException& e)
	{  CSoapResponseBinding::noteException(e); }

};

class CWsDfuPingRequest : public CSoapRequestBinding,
   implements IEspWsDfuPingRequest,
   implements IClientWsDfuPingRequest
{
protected:

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CWsDfuPingRequest(const char *serviceName, const char *bcompat);

	CWsDfuPingRequest(const char *serviceName, IRpcMessageBinding *init=NULL);
	CWsDfuPingRequest(const char *serviceName, IRpcMessage* rpcmsg);
	CWsDfuPingRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	IEspClientRpcSettings &rpc(){return *static_cast<IEspClientRpcSettings*>(this);}


	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "WsDfuPingRequest";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CWsDfuPingRequest &from);

	void copy(IConstWsDfuPingRequest &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstWsDfuPingRequest &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

};

class CWsDfuPingResponse : public CSoapResponseBinding,
   implements IEspWsDfuPingResponse,
   implements IClientWsDfuPingResponse
{
protected:

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CWsDfuPingResponse(const char *serviceName, const char *bcompat);

	CWsDfuPingResponse(const char *serviceName, IRpcMessageBinding *init=NULL);
	CWsDfuPingResponse(const char *serviceName, IRpcMessage* rpcmsg);
	CWsDfuPingResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "WsDfuPingResponse";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CWsDfuPingResponse &from);

	void copy(IConstWsDfuPingResponse &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstWsDfuPingResponse &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	virtual void setRedirectUrl(const char *url)
	{ CSoapResponseBinding::setRedirectUrl(url); }

	virtual const IMultiException& getExceptions()
	{ return CSoapResponseBinding::getExceptions(); }

	virtual int queryClientStatus()
	{ return CSoapResponseBinding::getRpcState(); }

	virtual void noteException(IException& e)
	{  CSoapResponseBinding::noteException(e); }

};

class CWsDfu : public CInterface,
	implements IEspWsDfu
{
private:
	IEspContainer* m_container;
public:
	IMPLEMENT_IINTERFACE;

	CWsDfu(){}
	virtual ~CWsDfu(){}
	virtual void init(IPropertyTree *cfg, const char *process, const char *service)
	{
	}
	virtual bool init(const char * service, const char * type, IPropertyTree * cfg, const char * process)
	{
		return true;
	}
	virtual void setContainer(IEspContainer *c)
	{
		m_container = c;
	}
	virtual IEspContainer *queryContainer()
	{
		return m_container;
	}
	virtual const char* getServiceType(){return "WsDfu";}

	virtual bool unsubscribeServiceFromDali(){return false;}

	virtual bool subscribeServiceToDali(){return false;}

	virtual bool detachServiceFromDali(){return false;}

	virtual bool attachServiceToDali(){return false;}

	virtual bool canDetachFromDali(){return false;}

	//bool onAdd(IEspContext &context, IEspAddRequest &req, IEspAddResponse &resp)
	//{
		//return false;
	//}
	//bool onAddRemote(IEspContext &context, IEspAddRemoteRequest &req, IEspAddRemoteResponse &resp)
	//{
		//return false;
	//}
	//bool onAddtoSuperfile(IEspContext &context, IEspAddtoSuperfileRequest &req, IEspAddtoSuperfileResponse &resp)
	//{
		//return false;
	//}
	//bool onDFUArrayAction(IEspContext &context, IEspDFUArrayActionRequest &req, IEspDFUArrayActionResponse &resp)
	//{
		//return false;
	//}
	//bool onDFUBrowseData(IEspContext &context, IEspDFUBrowseDataRequest &req, IEspDFUBrowseDataResponse &resp)
	//{
		//return false;
	//}
	//bool onDFUDefFile(IEspContext &context, IEspDFUDefFileRequest &req, IEspDFUDefFileResponse &resp)
	//{
		//return false;
	//}
	//bool onDFUFileAccess(IEspContext &context, IEspDFUFileAccessRequest &req, IEspDFUFileAccessResponse &resp)
	//{
		//return false;
	//}
	//bool onDFUFileAccessV2(IEspContext &context, IEspDFUFileAccessV2Request &req, IEspDFUFileAccessResponse &resp)
	//{
		//return false;
	//}
	//bool onDFUFileCreate(IEspContext &context, IEspDFUFileCreateRequest &req, IEspDFUFileCreateResponse &resp)
	//{
		//return false;
	//}
	//bool onDFUFileCreateV2(IEspContext &context, IEspDFUFileCreateV2Request &req, IEspDFUFileCreateResponse &resp)
	//{
		//return false;
	//}
	//bool onDFUFilePublish(IEspContext &context, IEspDFUFilePublishRequest &req, IEspDFUFilePublishResponse &resp)
	//{
		//return false;
	//}
	//bool onDFUFileView(IEspContext &context, IEspDFUFileViewRequest &req, IEspDFUFileViewResponse &resp)
	//{
		//return false;
	//}
	//bool onDFUGetDataColumns(IEspContext &context, IEspDFUGetDataColumnsRequest &req, IEspDFUGetDataColumnsResponse &resp)
	//{
		//return false;
	//}
	//bool onDFUGetFileMetaData(IEspContext &context, IEspDFUGetFileMetaDataRequest &req, IEspDFUGetFileMetaDataResponse &resp)
	//{
		//return false;
	//}
	//bool onDFUInfo(IEspContext &context, IEspDFUInfoRequest &req, IEspDFUInfoResponse &resp)
	//{
		//return false;
	//}
	//bool onDFUQuery(IEspContext &context, IEspDFUQueryRequest &req, IEspDFUQueryResponse &resp)
	//{
		//return false;
	//}
	//bool onDFURecordTypeInfo(IEspContext &context, IEspDFURecordTypeInfoRequest &req, IEspDFURecordTypeInfoResponse &resp)
	//{
		//return false;
	//}
	//bool onDFUSearch(IEspContext &context, IEspDFUSearchRequest &req, IEspDFUSearchResponse &resp)
	//{
		//return false;
	//}
	//bool onDFUSearchData(IEspContext &context, IEspDFUSearchDataRequest &req, IEspDFUSearchDataResponse &resp)
	//{
		//return false;
	//}
	//bool onDFUSpace(IEspContext &context, IEspDFUSpaceRequest &req, IEspDFUSpaceResponse &resp)
	//{
		//return false;
	//}
	//bool onEclRecordTypeInfo(IEspContext &context, IEspEclRecordTypeInfoRequest &req, IEspEclRecordTypeInfoResponse &resp)
	//{
		//return false;
	//}
	//bool onEraseHistory(IEspContext &context, IEspEraseHistoryRequest &req, IEspEraseHistoryResponse &resp)
	//{
		//return false;
	//}
	//bool onListHistory(IEspContext &context, IEspListHistoryRequest &req, IEspListHistoryResponse &resp)
	//{
		//return false;
	//}
	bool onPing(IEspContext &context, IEspWsDfuPingRequest &req, IEspWsDfuPingResponse &resp)
	{
		return true;
	}
	//bool onSavexml(IEspContext &context, IEspSavexmlRequest &req, IEspSavexmlResponse &resp)
	//{
		//return false;
	//}
	//bool onSuperfileAction(IEspContext &context, IEspSuperfileActionRequest &req, IEspSuperfileActionResponse &resp)
	//{
		//return false;
	//}
	//bool onSuperfileList(IEspContext &context, IEspSuperfileListRequest &req, IEspSuperfileListResponse &resp)
	//{
		//return false;
	//}
};





class CWsDfuSoapBinding : public CHttpSoapBinding
{
public:
	CWsDfuSoapBinding(http_soap_log_level level=hsl_none);
	CWsDfuSoapBinding(IPropertyTree* cfg, const char *bindname=NULL, const char *procname=NULL, http_soap_log_level level=hsl_none);
	virtual void init_strings();
	virtual unsigned getCacheMethodCount(){return m_cacheMethodCount;}
	virtual int processRequest(IRpcMessage* rpc_call, IRpcMessage* rpc_response);
	int getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &content, const char *service, const char *method, bool mda);
	virtual int getMethodHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &page, bool bIncludeFormTag);
	int getQualifiedNames(IEspContext& ctx, MethodInfoArray & methods);
	StringBuffer & getServiceName(StringBuffer &resp);
	bool isValidServiceName(IEspContext &context, const char *name);
	bool qualifyMethodName(IEspContext &context, const char *methname, StringBuffer *methQName);
	bool qualifyServiceName(IEspContext &context, const char *servname, const char *methname, StringBuffer &servQName, StringBuffer *methQName);
	virtual int onGetFile(IEspContext &context, CHttpRequest* request, CHttpResponse* response, const char *pathex);
	virtual int onGetForm(IEspContext &context, CHttpRequest* request, CHttpResponse* response, const char *service, const char *method);
	virtual int onGetXForm(IEspContext &context, CHttpRequest* request, CHttpResponse* response, const char *service, const char *method);
	virtual bool supportGeneratedForms(){return false;}
	virtual int onGetService(IEspContext &context, CHttpRequest* request, CHttpResponse* response, const char *service, const char *method, const char *pathex);
	virtual IRpcRequestBinding *createReqBinding(IEspContext &context, IHttpMessage* request, const char *service, const char *method);
	virtual int onGetInstantQuery(IEspContext &context, CHttpRequest* request, CHttpResponse* response, const char *service, const char *method);
	void setXslProcessor(IInterface *xslp_)
	{
		IXslProcessor *ixslp = dynamic_cast<IXslProcessor *>(xslp_);
		if (!ixslp)
			xslp.clear();
		else
			xslp.set(ixslp);
	}
private:
	Owned<IXslProcessor> xslp;
	void xslTransform(const char* xml, const char* xslFile, StringBuffer& output, IProperties *params)
	{
		if (xslp)
		{
			Owned<IXslTransform> xform = xslp->createXslTransform();
			StringBuffer xslpath;
			if (!strnicmp(xslFile, "/esp/xslt/", 10))
				if (!checkFileExists(xslpath.append(getCFD()).append("smc_xslt/").append(xslFile+10).str()) && !checkFileExists(xslpath.append(getCFD()).append("xslt/").append(xslFile+10).str()))
					return;
			xform->loadXslFromFile((xslpath.length()) ? xslpath.str() : xslFile);
			xform->setXmlSource(xml, strlen(xml)+1);
			if (params) xform->copyParameters(params);
			xform->transform(output.clear());
		}
	}
	unsigned m_cacheMethodCount = 0;
};



class CClientWsDfu : public CInterface,
	implements IClientWsDfu
{
protected:
	StringBuffer soap_proxy;
	StringBuffer soap_url;
	StringBuffer soap_userid;
	StringBuffer soap_password;
	StringBuffer soap_realm;
	StringBuffer soap_action;
	long soap_reqid = 0;

public:
	IMPLEMENT_IINTERFACE;

	CClientWsDfu()
	{
		soap_reqid=0;
			soap_action.append("WsDfu");
			soap_action.append("?ver_=").append("1.50");
	}
	virtual ~CClientWsDfu(){}
	virtual void setProxyAddress(const char *address)
	{
		soap_proxy.set(address);
	}
	virtual void addServiceUrl(const char *url)
	{
		soap_url.set(url);
	}
	virtual void removeServiceUrl(const char *url)
	{
	}
	virtual void setUsernameToken(const char *userid,const char *password,const char *realm)
	{
		 soap_userid.set(userid);
		 soap_password.set(password);
		 soap_realm.set(realm);
	}
	virtual void setAction(const char *action)
	{
		soap_action.set(action);
	}

	virtual IClientAddRequest * createAddRequest();
	virtual IClientAddResponse * Add(IClientAddRequest *request);
	virtual void async_Add(IClientAddRequest *request, IClientWsDfuEvents *events,IInterface* state=0);

	virtual IClientAddResponse *AddFn(const char * dstname_, const MemoryBuffer & xmlmap_);

	virtual IClientAddRemoteRequest * createAddRemoteRequest();
	virtual IClientAddRemoteResponse * AddRemote(IClientAddRemoteRequest *request);
	virtual void async_AddRemote(IClientAddRemoteRequest *request, IClientWsDfuEvents *events,IInterface* state=0);

	virtual IClientAddRemoteResponse *AddRemoteFn(const char * dstname_, const char * srcname_, const char * srcdali_, const char * srcusername_, const char * srcpassword_);

	virtual IClientAddtoSuperfileRequest * createAddtoSuperfileRequest();
	virtual IClientAddtoSuperfileResponse * AddtoSuperfile(IClientAddtoSuperfileRequest *request);
	virtual void async_AddtoSuperfile(IClientAddtoSuperfileRequest *request, IClientWsDfuEvents *events,IInterface* state=0);

	virtual IClientAddtoSuperfileResponse *AddtoSuperfileFn(const char * Superfile_, const char * Subfiles_, StringArray &names_, bool ExistingFile_, const char * BackToPage_);

	virtual IClientDFUArrayActionRequest * createDFUArrayActionRequest();
	virtual IClientDFUArrayActionResponse * DFUArrayAction(IClientDFUArrayActionRequest *request);
	virtual void async_DFUArrayAction(IClientDFUArrayActionRequest *request, IClientWsDfuEvents *events,IInterface* state=0);

	virtual IClientDFUArrayActionResponse *DFUArrayActionFn(CDFUArrayActions Type_, bool NoDelete_, const char * BackToPage_, StringArray &LogicalFiles_, bool removeFromSuperfiles_, bool removeRecursively_);

	virtual IClientDFUBrowseDataRequest * createDFUBrowseDataRequest();
	virtual IClientDFUBrowseDataResponse * DFUBrowseData(IClientDFUBrowseDataRequest *request);
	virtual void async_DFUBrowseData(IClientDFUBrowseDataRequest *request, IClientWsDfuEvents *events,IInterface* state=0);

	virtual IClientDFUBrowseDataResponse *DFUBrowseDataFn(const char * LogicalName_, const char * FilterBy_, const char * ShowColumns_, bool SchemaOnly_, __int64 StartForGoback_, int CountForGoback_, int ChooseFile_, const char * Cluster_, const char * ClusterType_, const char * ParentName_, __int64 Start_, int Count_, bool DisableUppercaseTranslation_);

	virtual IClientDFUDefFileRequest * createDFUDefFileRequest();
	virtual IClientDFUDefFileResponse * DFUDefFile(IClientDFUDefFileRequest *request);
	virtual void async_DFUDefFile(IClientDFUDefFileRequest *request, IClientWsDfuEvents *events,IInterface* state=0);

	virtual IClientDFUDefFileResponse *DFUDefFileFn(const char * Name_, CDFUDefFileFormat Format_);

	virtual IClientDFUFileAccessRequest * createDFUFileAccessRequest();
	virtual IClientDFUFileAccessResponse * DFUFileAccess(IClientDFUFileAccessRequest *request);
	virtual void async_DFUFileAccess(IClientDFUFileAccessRequest *request, IClientWsDfuEvents *events,IInterface* state=0);

	virtual IClientDFUFileAccessResponse *DFUFileAccessFn(IConstDFUFileAccessRequestBase &RequestBase_);

	virtual IClientDFUFileAccessV2Request * createDFUFileAccessV2Request();
	virtual IClientDFUFileAccessResponse * DFUFileAccessV2(IClientDFUFileAccessV2Request *request);
	virtual void async_DFUFileAccessV2(IClientDFUFileAccessV2Request *request, IClientWsDfuEvents *events,IInterface* state=0);

	virtual IClientDFUFileAccessResponse *DFUFileAccessV2Fn(const char * Name_, const char * Cluster_, const char * RequestId_, int ExpirySeconds_, bool ReturnTextResponse_);

	virtual IClientDFUFileCreateRequest * createDFUFileCreateRequest();
	virtual IClientDFUFileCreateResponse * DFUFileCreate(IClientDFUFileCreateRequest *request);
	virtual void async_DFUFileCreate(IClientDFUFileCreateRequest *request, IClientWsDfuEvents *events,IInterface* state=0);

	virtual IClientDFUFileCreateResponse *DFUFileCreateFn(const char * ECLRecordDefinition_, StringArray &PartLocations_, IConstDFUFileAccessRequestBase &RequestBase_);

	virtual IClientDFUFileCreateV2Request * createDFUFileCreateV2Request();
	virtual IClientDFUFileCreateResponse * DFUFileCreateV2(IClientDFUFileCreateV2Request *request);
	virtual void async_DFUFileCreateV2(IClientDFUFileCreateV2Request *request, IClientWsDfuEvents *events,IInterface* state=0);

	virtual IClientDFUFileCreateResponse *DFUFileCreateV2Fn(const char * Name_, const char * Cluster_, CDFUFileType Type_, const char * ECLRecordDefinition_, const char * RequestId_, int ExpirySeconds_, bool ReturnTextResponse_, bool Compressed_);

	virtual IClientDFUFilePublishRequest * createDFUFilePublishRequest();
	virtual IClientDFUFilePublishResponse * DFUFilePublish(IClientDFUFilePublishRequest *request);
	virtual void async_DFUFilePublish(IClientDFUFilePublishRequest *request, IClientWsDfuEvents *events,IInterface* state=0);

	virtual IClientDFUFilePublishResponse *DFUFilePublishFn(const char * FileId_, bool Overwrite_, const MemoryBuffer & FileDescriptorBlob_, const char * ECLRecordDefinition_, __int64 RecordCount_, __int64 FileSize_);

	virtual IClientDFUFileViewRequest * createDFUFileViewRequest();
	virtual IClientDFUFileViewResponse * DFUFileView(IClientDFUFileViewRequest *request);
	virtual void async_DFUFileView(IClientDFUFileViewRequest *request, IClientWsDfuEvents *events,IInterface* state=0);

	virtual IClientDFUFileViewResponse *DFUFileViewFn(const char * Scope_, bool IncludeSuperOwner_);

	virtual IClientDFUGetDataColumnsRequest * createDFUGetDataColumnsRequest();
	virtual IClientDFUGetDataColumnsResponse * DFUGetDataColumns(IClientDFUGetDataColumnsRequest *request);
	virtual void async_DFUGetDataColumns(IClientDFUGetDataColumnsRequest *request, IClientWsDfuEvents *events,IInterface* state=0);

	virtual IClientDFUGetDataColumnsResponse *DFUGetDataColumnsFn(const char * OpenLogicalName_, const char * LogicalName_, const char * FilterBy_, const char * ShowColumns_, int ChooseFile_, const char * Cluster_, const char * ClusterType_, __int64 StartIndex_, __int64 EndIndex_);

	virtual IClientDFUGetFileMetaDataRequest * createDFUGetFileMetaDataRequest();
	virtual IClientDFUGetFileMetaDataResponse * DFUGetFileMetaData(IClientDFUGetFileMetaDataRequest *request);
	virtual void async_DFUGetFileMetaData(IClientDFUGetFileMetaDataRequest *request, IClientWsDfuEvents *events,IInterface* state=0);

	virtual IClientDFUGetFileMetaDataResponse *DFUGetFileMetaDataFn(const char * LogicalFileName_, const char * ClusterName_, bool IncludeXmlSchema_, bool AddHeaderInXmlSchema_, bool IncludeXmlXPathSchema_, bool AddHeaderInXmlXPathSchema_);

	virtual IClientDFUInfoRequest * createDFUInfoRequest();
	virtual IClientDFUInfoResponse * DFUInfo(IClientDFUInfoRequest *request);
	virtual void async_DFUInfo(IClientDFUInfoRequest *request, IClientWsDfuEvents *events,IInterface* state=0);

	virtual IClientDFUInfoResponse *DFUInfoFn(const char * Name_, const char * Cluster_, bool UpdateDescription_, const char * QuerySet_, const char * Query_, const char * FileName_, const char * FileDesc_, bool IncludeJsonTypeInfo_, bool IncludeBinTypeInfo_, CDFUChangeProtection Protect_);

	virtual IClientDFUQueryRequest * createDFUQueryRequest();
	virtual IClientDFUQueryResponse * DFUQuery(IClientDFUQueryRequest *request);
	virtual void async_DFUQuery(IClientDFUQueryRequest *request, IClientWsDfuEvents *events,IInterface* state=0);

	virtual IClientDFUQueryResponse *DFUQueryFn(const char * Prefix_, const char * ClusterName_, const char * NodeGroup_, const char * ContentType_, const char * LogicalName_, const char * Owner_, const char * StartDate_, const char * EndDate_, const char * FileType_, __int64 FileSizeFrom_, __int64 FileSizeTo_, int FirstN_, const char * FirstNType_, int PageSize_, int PageStartFrom_, const char * Sortby_, bool Descending_, bool OneLevelDirFileReturn_, __int64 CacheHint_, int MaxNumberOfFiles_, bool IncludeSuperOwner_);

	virtual IClientDFURecordTypeInfoRequest * createDFURecordTypeInfoRequest();
	virtual IClientDFURecordTypeInfoResponse * DFURecordTypeInfo(IClientDFURecordTypeInfoRequest *request);
	virtual void async_DFURecordTypeInfo(IClientDFURecordTypeInfoRequest *request, IClientWsDfuEvents *events,IInterface* state=0);

	virtual IClientDFURecordTypeInfoResponse *DFURecordTypeInfoFn(const char * Name_, bool IncludeJsonTypeInfo_, bool IncludeBinTypeInfo_);

	virtual IClientDFUSearchRequest * createDFUSearchRequest();
	virtual IClientDFUSearchResponse * DFUSearch(IClientDFUSearchRequest *request);
	virtual void async_DFUSearch(IClientDFUSearchRequest *request, IClientWsDfuEvents *events,IInterface* state=0);

	virtual IClientDFUSearchResponse *DFUSearchFn(const char * ShowExample_);

	virtual IClientDFUSearchDataRequest * createDFUSearchDataRequest();
	virtual IClientDFUSearchDataResponse * DFUSearchData(IClientDFUSearchDataRequest *request);
	virtual void async_DFUSearchData(IClientDFUSearchDataRequest *request, IClientWsDfuEvents *events,IInterface* state=0);

	virtual IClientDFUSearchDataResponse *DFUSearchDataFn(const char * Cluster_, const char * ClusterType_, const char * OpenLogicalName_, const char * FilterBy_, const char * ShowColumns_, int ChooseFile_, __int64 StartIndex_, __int64 EndIndex_, const char * LogicalName_, const char * ParentName_, __int64 StartForGoback_, int CountForGoback_, __int64 Start_, int Count_, const char * File_, const char * Key_, bool SchemaOnly_, bool RoxieSelections_, bool DisableUppercaseTranslation_, const char * SelectedKey_);

	virtual IClientDFUSpaceRequest * createDFUSpaceRequest();
	virtual IClientDFUSpaceResponse * DFUSpace(IClientDFUSpaceRequest *request);
	virtual void async_DFUSpace(IClientDFUSpaceRequest *request, IClientWsDfuEvents *events,IInterface* state=0);

	virtual IClientDFUSpaceResponse *DFUSpaceFn(const char * CountBy_, const char * ScopeUnder_, const char * OwnerUnder_, const char * Interval_, const char * StartDate_, const char * EndDate_);

	virtual IClientEclRecordTypeInfoRequest * createEclRecordTypeInfoRequest();
	virtual IClientEclRecordTypeInfoResponse * EclRecordTypeInfo(IClientEclRecordTypeInfoRequest *request);
	virtual void async_EclRecordTypeInfo(IClientEclRecordTypeInfoRequest *request, IClientWsDfuEvents *events,IInterface* state=0);

	virtual IClientEclRecordTypeInfoResponse *EclRecordTypeInfoFn(const char * Ecl_, bool IncludeJsonTypeInfo_, bool IncludeBinTypeInfo_);

	virtual IClientEraseHistoryRequest * createEraseHistoryRequest();
	virtual IClientEraseHistoryResponse * EraseHistory(IClientEraseHistoryRequest *request);
	virtual void async_EraseHistory(IClientEraseHistoryRequest *request, IClientWsDfuEvents *events,IInterface* state=0);

	virtual IClientEraseHistoryResponse *EraseHistoryFn(const char * Name_);

	virtual IClientListHistoryRequest * createListHistoryRequest();
	virtual IClientListHistoryResponse * ListHistory(IClientListHistoryRequest *request);
	virtual void async_ListHistory(IClientListHistoryRequest *request, IClientWsDfuEvents *events,IInterface* state=0);

	virtual IClientListHistoryResponse *ListHistoryFn(const char * Name_);

	virtual IClientWsDfuPingRequest * createPingRequest();
	virtual IClientWsDfuPingResponse * Ping(IClientWsDfuPingRequest *request);
	virtual void async_Ping(IClientWsDfuPingRequest *request, IClientWsDfuEvents *events,IInterface* state=0);

	virtual IClientWsDfuPingResponse *PingFn();

	virtual IClientSavexmlRequest * createSavexmlRequest();
	virtual IClientSavexmlResponse * Savexml(IClientSavexmlRequest *request);
	virtual void async_Savexml(IClientSavexmlRequest *request, IClientWsDfuEvents *events,IInterface* state=0);

	virtual IClientSavexmlResponse *SavexmlFn(const char * name_);

	virtual IClientSuperfileActionRequest * createSuperfileActionRequest();
	virtual IClientSuperfileActionResponse * SuperfileAction(IClientSuperfileActionRequest *request);
	virtual void async_SuperfileAction(IClientSuperfileActionRequest *request, IClientWsDfuEvents *events,IInterface* state=0);

	virtual IClientSuperfileActionResponse *SuperfileActionFn(const char * action_, const char * superfile_, StringArray &subfiles_, const char * before_, bool delete_, bool removeSuperfile_);

	virtual IClientSuperfileListRequest * createSuperfileListRequest();
	virtual IClientSuperfileListResponse * SuperfileList(IClientSuperfileListRequest *request);
	virtual void async_SuperfileList(IClientSuperfileListRequest *request, IClientWsDfuEvents *events,IInterface* state=0);

	virtual IClientSuperfileListResponse *SuperfileListFn(const char * superfile_);
	static int transferThunkEvent(void *data);
#ifdef _WIN32
	static void espWorkerThread(void* data);
#else
	static void *espWorkerThread(void *data);
#endif
};



}
using namespace ws_dfu;

#endif //ws_dfu_ESPGEN_INCLUDED
