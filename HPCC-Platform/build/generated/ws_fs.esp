// *** Source file generated by HIDL Version 1.3 from ws_fs.ecm ***
// *** Not to be hand edited (changes will be lost on re-generation) ***

#ifndef ws_fs_ESPGEN_INCLUDED
#define ws_fs_ESPGEN_INCLUDED

#include "ws_fs_esp.ipp"

#ifdef _WIN32
#include "edwin.h"
#include <process.h>
#endif



//=======================================================
// class CDFUWorkunit Implementation
//=======================================================

CDFUWorkunit::CDFUWorkunit(const char *serviceName, IRpcMessageBinding *init)
	: m_ID(nilRemove),m_DFUServerName(nilRemove),m_ClusterName(nilRemove),m_JobName(nilRemove),m_Queue(nilRemove),m_User(nilRemove),m_isProtected(nilRemove),m_Command(nilRemove),m_CommandMessage(nilRemove),m_PercentDone(nilRemove),m_SecsLeft(nilRemove),m_ProgressMessage(nilRemove),m_SummaryMessage(nilRemove),m_State(nilRemove),m_SourceLogicalName(nilRemove),m_SourceIP(nilRemove),m_SourceFilePath(nilRemove),m_SourceDali(nilRemove),m_SourceRecordSize(nilRemove),m_SourceFormat(nilRemove),m_RowTag(nilRemove),m_SourceNumParts(nilRemove),m_SourceDirectory(nilRemove),m_DestLogicalName(nilRemove),m_DestGroupName(nilRemove),m_DestDirectory(nilRemove),m_DestIP(nilRemove),m_DestFilePath(nilRemove),m_DestFormat(nilRemove),m_DestNumParts(nilRemove),m_DestRecordSize(nilRemove),m_Replicate(nilRemove),m_Overwrite(nilRemove),m_Compress(nilRemove),m_SourceCsvSeparate(nilRemove),m_SourceCsvQuote(nilRemove),m_SourceCsvTerminate(nilRemove),m_SourceCsvEscape(nilRemove),m_TimeStarted(nilRemove),m_TimeStopped(nilRemove),m_StateMessage(nilRemove),m_MonitorEventName(nilRemove),m_MonitorSub(nilRemove),m_MonitorShotLimit(nilRemove),m_SourceDiffKeyName(nilRemove),m_DestDiffKeyName(nilRemove),m_Archived(0, nilRemove,false),m_encrypt(nilRemove),m_decrypt(nilRemove),m_failIfNoSourceFile(0, nilRemove,false),m_recordStructurePresent(0, nilRemove,false),m_quotedTerminator(1, nilRemove,false),m_preserveCompression(1, nilRemove,false),m_expireDays(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("DFUWorkunit");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CDFUWorkunit::CDFUWorkunit(const char *serviceName, const char *bc)
	: m_ID(nilRemove),m_DFUServerName(nilRemove),m_ClusterName(nilRemove),m_JobName(nilRemove),m_Queue(nilRemove),m_User(nilRemove),m_isProtected(nilRemove),m_Command(nilRemove),m_CommandMessage(nilRemove),m_PercentDone(nilRemove),m_SecsLeft(nilRemove),m_ProgressMessage(nilRemove),m_SummaryMessage(nilRemove),m_State(nilRemove),m_SourceLogicalName(nilRemove),m_SourceIP(nilRemove),m_SourceFilePath(nilRemove),m_SourceDali(nilRemove),m_SourceRecordSize(nilRemove),m_SourceFormat(nilRemove),m_RowTag(nilRemove),m_SourceNumParts(nilRemove),m_SourceDirectory(nilRemove),m_DestLogicalName(nilRemove),m_DestGroupName(nilRemove),m_DestDirectory(nilRemove),m_DestIP(nilRemove),m_DestFilePath(nilRemove),m_DestFormat(nilRemove),m_DestNumParts(nilRemove),m_DestRecordSize(nilRemove),m_Replicate(nilRemove),m_Overwrite(nilRemove),m_Compress(nilRemove),m_SourceCsvSeparate(nilRemove),m_SourceCsvQuote(nilRemove),m_SourceCsvTerminate(nilRemove),m_SourceCsvEscape(nilRemove),m_TimeStarted(nilRemove),m_TimeStopped(nilRemove),m_StateMessage(nilRemove),m_MonitorEventName(nilRemove),m_MonitorSub(nilRemove),m_MonitorShotLimit(nilRemove),m_SourceDiffKeyName(nilRemove),m_DestDiffKeyName(nilRemove),m_Archived(0, nilRemove,false),m_encrypt(nilRemove),m_decrypt(nilRemove),m_failIfNoSourceFile(0, nilRemove,false),m_recordStructurePresent(0, nilRemove,false),m_quotedTerminator(1, nilRemove,false),m_preserveCompression(1, nilRemove,false),m_expireDays(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("DFUWorkunit");
}

StringBuffer &CDFUWorkunit::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:complexType name=\"%s\">\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"ID\" type=\"xsd:string\"/>\n");
		if (!context.suppressed("DFUWorkunit","DFUServerName")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"DFUServerName\" type=\"xsd:string\"/>\n");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"ClusterName\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"JobName\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Queue\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"User\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"isProtected\" type=\"xsd:boolean\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Command\" type=\"xsd:int\"/>\n");
		if (!context.suppressed("DFUWorkunit","CommandMessage")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"CommandMessage\" type=\"xsd:string\"/>\n");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"PercentDone\" type=\"xsd:int\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"SecsLeft\" type=\"xsd:int\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"ProgressMessage\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"SummaryMessage\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"State\" type=\"xsd:int\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"SourceLogicalName\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"SourceIP\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"SourceFilePath\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"SourceDali\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"SourceRecordSize\" type=\"xsd:int\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"SourceFormat\" type=\"xsd:int\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"RowTag\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"SourceNumParts\" type=\"xsd:int\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"SourceDirectory\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"DestLogicalName\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"DestGroupName\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"DestDirectory\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"DestIP\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"DestFilePath\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"DestFormat\" type=\"xsd:int\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"DestNumParts\" type=\"xsd:int\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"DestRecordSize\" type=\"xsd:int\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Replicate\" type=\"xsd:boolean\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Overwrite\" type=\"xsd:boolean\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Compress\" type=\"xsd:boolean\"/>\n");
		if (!context.suppressed("DFUWorkunit","SourceCsvSeparate")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"SourceCsvSeparate\" type=\"xsd:string\"/>\n");
		}
		if (!context.suppressed("DFUWorkunit","SourceCsvQuote")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"SourceCsvQuote\" type=\"xsd:string\"/>\n");
		}
		if (!context.suppressed("DFUWorkunit","SourceCsvTerminate")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"SourceCsvTerminate\" type=\"xsd:string\"/>\n");
		}
		if (!context.suppressed("DFUWorkunit","SourceCsvEscape")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"SourceCsvEscape\" type=\"xsd:string\"/>\n");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"TimeStarted\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"TimeStopped\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"StateMessage\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"MonitorEventName\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"MonitorSub\" type=\"xsd:boolean\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"MonitorShotLimit\" type=\"xsd:int\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"SourceDiffKeyName\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"DestDiffKeyName\" type=\"xsd:string\"/>\n");
		if (!context.suppressed("DFUWorkunit","Archived")) {
			schema.append("<xsd:element minOccurs=\"0\" default=\"false\" name=\"Archived\" type=\"xsd:boolean\"/>\n");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"encrypt\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"decrypt\" type=\"xsd:string\"/>\n");
		if (!context.suppressed("DFUWorkunit","failIfNoSourceFile")) {
			schema.append("<xsd:element minOccurs=\"0\" default=\"false\" name=\"failIfNoSourceFile\" type=\"xsd:boolean\"/>\n");
		}
		if (!context.suppressed("DFUWorkunit","recordStructurePresent")) {
			schema.append("<xsd:element minOccurs=\"0\" default=\"false\" name=\"recordStructurePresent\" type=\"xsd:boolean\"/>\n");
		}
		if (!context.suppressed("DFUWorkunit","quotedTerminator")) {
			schema.append("<xsd:element minOccurs=\"0\" default=\"true\" name=\"quotedTerminator\" type=\"xsd:boolean\"/>\n");
		}
		if (!context.suppressed("DFUWorkunit","preserveCompression")) {
			schema.append("<xsd:element minOccurs=\"0\" default=\"true\" name=\"preserveCompression\" type=\"xsd:boolean\"/>\n");
		}
		if (!context.suppressed("DFUWorkunit","expireDays")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"expireDays\" type=\"xsd:int\"/>\n");
		}
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType>\n");
		}
	}
	return schema;
}

void CDFUWorkunit::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CDFUWorkunit::getMapInfo(IMapInfo& info, BoolHash& added)
{
	info.addMinVersion("DFUWorkunit","DFUServerName",1.06);
	info.addMinVersion("DFUWorkunit","CommandMessage",1.03);
	info.addMinVersion("DFUWorkunit","SourceCsvSeparate",1.04);
	info.addMinVersion("DFUWorkunit","SourceCsvQuote",1.04);
	info.addMinVersion("DFUWorkunit","SourceCsvTerminate",1.04);
	info.addMinVersion("DFUWorkunit","SourceCsvEscape",1.05);
	info.addMinVersion("DFUWorkunit","Archived",1.03);
	info.addMinVersion("DFUWorkunit","failIfNoSourceFile",1.08);
	info.addMinVersion("DFUWorkunit","recordStructurePresent",1.09);
	info.addMinVersion("DFUWorkunit","quotedTerminator",1.1);
	info.addMinVersion("DFUWorkunit","preserveCompression",1.12);
	info.addMinVersion("DFUWorkunit","expireDays",1.14);
}

StringBuffer &CDFUWorkunit::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("ID");
	form.appendf("  <tr><td><b>ID: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (!context.suppressed("DFUWorkunit","DFUServerName")) {
		extfix.clear();
		if (prefix && *prefix)
			extfix.append(prefix).append(".");
		extfix.append("DFUServerName");
		form.appendf("  <tr><td><b>DFUServerName: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
		form.append("</td></tr>\n");
	}
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("ClusterName");
	form.appendf("  <tr><td><b>ClusterName: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("JobName");
	form.appendf("  <tr><td><b>JobName: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Queue");
	form.appendf("  <tr><td><b>Queue: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("User");
	form.appendf("  <tr><td><b>User: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("isProtected");
	
	form.appendf("  <tr><td><b>isProtected? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	extfix.clear();
	if (prefix && *prefix) extfix.append(prefix).append(".");
		extfix.append("Command");
	form.appendf("  <tr><td><b>Command: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
	form.append("</td></tr>\n");
	if (!context.suppressed("DFUWorkunit","CommandMessage")) {
		extfix.clear();
		if (prefix && *prefix)
			extfix.append(prefix).append(".");
		extfix.append("CommandMessage");
		form.appendf("  <tr><td><b>CommandMessage: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
		form.append("</td></tr>\n");
	}
	extfix.clear();
	if (prefix && *prefix) extfix.append(prefix).append(".");
		extfix.append("PercentDone");
	form.appendf("  <tr><td><b>PercentDone: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix) extfix.append(prefix).append(".");
		extfix.append("SecsLeft");
	form.appendf("  <tr><td><b>SecsLeft: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("ProgressMessage");
	form.appendf("  <tr><td><b>ProgressMessage: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("SummaryMessage");
	form.appendf("  <tr><td><b>SummaryMessage: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix) extfix.append(prefix).append(".");
		extfix.append("State");
	form.appendf("  <tr><td><b>State: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("SourceLogicalName");
	form.appendf("  <tr><td><b>SourceLogicalName: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("SourceIP");
	form.appendf("  <tr><td><b>SourceIP: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("SourceFilePath");
	form.appendf("  <tr><td><b>SourceFilePath: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("SourceDali");
	form.appendf("  <tr><td><b>SourceDali: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix) extfix.append(prefix).append(".");
		extfix.append("SourceRecordSize");
	form.appendf("  <tr><td><b>SourceRecordSize: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix) extfix.append(prefix).append(".");
		extfix.append("SourceFormat");
	form.appendf("  <tr><td><b>SourceFormat: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("RowTag");
	form.appendf("  <tr><td><b>RowTag: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix) extfix.append(prefix).append(".");
		extfix.append("SourceNumParts");
	form.appendf("  <tr><td><b>SourceNumParts: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("SourceDirectory");
	form.appendf("  <tr><td><b>SourceDirectory: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("DestLogicalName");
	form.appendf("  <tr><td><b>DestLogicalName: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("DestGroupName");
	form.appendf("  <tr><td><b>DestGroupName: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("DestDirectory");
	form.appendf("  <tr><td><b>DestDirectory: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("DestIP");
	form.appendf("  <tr><td><b>DestIP: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("DestFilePath");
	form.appendf("  <tr><td><b>DestFilePath: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix) extfix.append(prefix).append(".");
		extfix.append("DestFormat");
	form.appendf("  <tr><td><b>DestFormat: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix) extfix.append(prefix).append(".");
		extfix.append("DestNumParts");
	form.appendf("  <tr><td><b>DestNumParts: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix) extfix.append(prefix).append(".");
		extfix.append("DestRecordSize");
	form.appendf("  <tr><td><b>DestRecordSize: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Replicate");
	
	form.appendf("  <tr><td><b>Replicate? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Overwrite");
	
	form.appendf("  <tr><td><b>Overwrite? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Compress");
	
	form.appendf("  <tr><td><b>Compress? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	if (!context.suppressed("DFUWorkunit","SourceCsvSeparate")) {
		extfix.clear();
		if (prefix && *prefix)
			extfix.append(prefix).append(".");
		extfix.append("SourceCsvSeparate");
		form.appendf("  <tr><td><b>SourceCsvSeparate: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
		form.append("</td></tr>\n");
	}
	if (!context.suppressed("DFUWorkunit","SourceCsvQuote")) {
		extfix.clear();
		if (prefix && *prefix)
			extfix.append(prefix).append(".");
		extfix.append("SourceCsvQuote");
		form.appendf("  <tr><td><b>SourceCsvQuote: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
		form.append("</td></tr>\n");
	}
	if (!context.suppressed("DFUWorkunit","SourceCsvTerminate")) {
		extfix.clear();
		if (prefix && *prefix)
			extfix.append(prefix).append(".");
		extfix.append("SourceCsvTerminate");
		form.appendf("  <tr><td><b>SourceCsvTerminate: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
		form.append("</td></tr>\n");
	}
	if (!context.suppressed("DFUWorkunit","SourceCsvEscape")) {
		extfix.clear();
		if (prefix && *prefix)
			extfix.append(prefix).append(".");
		extfix.append("SourceCsvEscape");
		form.appendf("  <tr><td><b>SourceCsvEscape: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
		form.append("</td></tr>\n");
	}
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("TimeStarted");
	form.appendf("  <tr><td><b>TimeStarted: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("TimeStopped");
	form.appendf("  <tr><td><b>TimeStopped: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("StateMessage");
	form.appendf("  <tr><td><b>StateMessage: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("MonitorEventName");
	form.appendf("  <tr><td><b>MonitorEventName: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("MonitorSub");
	
	form.appendf("  <tr><td><b>MonitorSub? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	extfix.clear();
	if (prefix && *prefix) extfix.append(prefix).append(".");
		extfix.append("MonitorShotLimit");
	form.appendf("  <tr><td><b>MonitorShotLimit: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("SourceDiffKeyName");
	form.appendf("  <tr><td><b>SourceDiffKeyName: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("DestDiffKeyName");
	form.appendf("  <tr><td><b>DestDiffKeyName: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (!context.suppressed("DFUWorkunit","Archived")) {
		extfix.clear();
		if (prefix && *prefix)
			extfix.append(prefix).append(".");
		extfix.append("Archived");
		
	form.appendf("  <tr><td><b>Archived? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	}
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("encrypt");
	form.appendf("  <tr><td><b>encrypt: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("decrypt");
	form.appendf("  <tr><td><b>decrypt: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (!context.suppressed("DFUWorkunit","failIfNoSourceFile")) {
		extfix.clear();
		if (prefix && *prefix)
			extfix.append(prefix).append(".");
		extfix.append("failIfNoSourceFile");
		
	form.appendf("  <tr><td><b>failIfNoSourceFile? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	}
	if (!context.suppressed("DFUWorkunit","recordStructurePresent")) {
		extfix.clear();
		if (prefix && *prefix)
			extfix.append(prefix).append(".");
		extfix.append("recordStructurePresent");
		
	form.appendf("  <tr><td><b>recordStructurePresent? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	}
	if (!context.suppressed("DFUWorkunit","quotedTerminator")) {
		extfix.clear();
		if (prefix && *prefix)
			extfix.append(prefix).append(".");
		extfix.append("quotedTerminator");
		
	form.appendf("  <tr><td><b>quotedTerminator? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\" checked=\"1\" /></td></tr>\n", extfix.str());
	}
	if (!context.suppressed("DFUWorkunit","preserveCompression")) {
		extfix.clear();
		if (prefix && *prefix)
			extfix.append(prefix).append(".");
		extfix.append("preserveCompression");
		
	form.appendf("  <tr><td><b>preserveCompression? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\" checked=\"1\" /></td></tr>\n", extfix.str());
	}
	if (!context.suppressed("DFUWorkunit","expireDays")) {
		extfix.clear();
		if (prefix && *prefix) extfix.append(prefix).append(".");
			extfix.append("expireDays");
		form.appendf("  <tr><td><b>expireDays: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
		form.append("</td></tr>\n");
	}
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CDFUWorkunit::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CDFUWorkunit::serialize(IRpcMessage& rpc_resp)
{
	IEspContext* ctx = rpc_resp.queryContext();
	double clientVer= ctx ? ctx->getClientVersion() : -1; /* no context gets everything */
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_ID.marshall(rpc_resp, "ID", "", "", "");
	if ((clientVer==-1.0 || clientVer>=1.06))
		m_DFUServerName.marshall(rpc_resp, "DFUServerName", "", "", "");
	m_ClusterName.marshall(rpc_resp, "ClusterName", "", "", "");
	m_JobName.marshall(rpc_resp, "JobName", "", "", "");
	m_Queue.marshall(rpc_resp, "Queue", "", "", "");
	m_User.marshall(rpc_resp, "User", "", "", "");
	m_isProtected.marshall(rpc_resp, "isProtected", "", "", "");
	m_Command.marshall(rpc_resp, "Command", "", "", "");
	if ((clientVer==-1.0 || clientVer>=1.03))
		m_CommandMessage.marshall(rpc_resp, "CommandMessage", "", "", "");
	m_PercentDone.marshall(rpc_resp, "PercentDone", "", "", "");
	m_SecsLeft.marshall(rpc_resp, "SecsLeft", "", "", "");
	m_ProgressMessage.marshall(rpc_resp, "ProgressMessage", "", "", "");
	m_SummaryMessage.marshall(rpc_resp, "SummaryMessage", "", "", "");
	m_State.marshall(rpc_resp, "State", "", "", "");
	m_SourceLogicalName.marshall(rpc_resp, "SourceLogicalName", "", "", "");
	m_SourceIP.marshall(rpc_resp, "SourceIP", "", "", "");
	m_SourceFilePath.marshall(rpc_resp, "SourceFilePath", "", "", "");
	m_SourceDali.marshall(rpc_resp, "SourceDali", "", "", "");
	m_SourceRecordSize.marshall(rpc_resp, "SourceRecordSize", "", "", "");
	m_SourceFormat.marshall(rpc_resp, "SourceFormat", "", "", "");
	m_RowTag.marshall(rpc_resp, "RowTag", "", "", "");
	m_SourceNumParts.marshall(rpc_resp, "SourceNumParts", "", "", "");
	m_SourceDirectory.marshall(rpc_resp, "SourceDirectory", "", "", "");
	m_DestLogicalName.marshall(rpc_resp, "DestLogicalName", "", "", "");
	m_DestGroupName.marshall(rpc_resp, "DestGroupName", "", "", "");
	m_DestDirectory.marshall(rpc_resp, "DestDirectory", "", "", "");
	m_DestIP.marshall(rpc_resp, "DestIP", "", "", "");
	m_DestFilePath.marshall(rpc_resp, "DestFilePath", "", "", "");
	m_DestFormat.marshall(rpc_resp, "DestFormat", "", "", "");
	m_DestNumParts.marshall(rpc_resp, "DestNumParts", "", "", "");
	m_DestRecordSize.marshall(rpc_resp, "DestRecordSize", "", "", "");
	m_Replicate.marshall(rpc_resp, "Replicate", "", "", "");
	m_Overwrite.marshall(rpc_resp, "Overwrite", "", "", "");
	m_Compress.marshall(rpc_resp, "Compress", "", "", "");
	if ((clientVer==-1.0 || clientVer>=1.04))
		m_SourceCsvSeparate.marshall(rpc_resp, "SourceCsvSeparate", "", "", "");
	if ((clientVer==-1.0 || clientVer>=1.04))
		m_SourceCsvQuote.marshall(rpc_resp, "SourceCsvQuote", "", "", "");
	if ((clientVer==-1.0 || clientVer>=1.04))
		m_SourceCsvTerminate.marshall(rpc_resp, "SourceCsvTerminate", "", "", "");
	if ((clientVer==-1.0 || clientVer>=1.05))
		m_SourceCsvEscape.marshall(rpc_resp, "SourceCsvEscape", "", "", "");
	m_TimeStarted.marshall(rpc_resp, "TimeStarted", "", "", "");
	m_TimeStopped.marshall(rpc_resp, "TimeStopped", "", "", "");
	m_StateMessage.marshall(rpc_resp, "StateMessage", "", "", "");
	m_MonitorEventName.marshall(rpc_resp, "MonitorEventName", "", "", "");
	m_MonitorSub.marshall(rpc_resp, "MonitorSub", "", "", "");
	m_MonitorShotLimit.marshall(rpc_resp, "MonitorShotLimit", "", "", "");
	m_SourceDiffKeyName.marshall(rpc_resp, "SourceDiffKeyName", "", "", "");
	m_DestDiffKeyName.marshall(rpc_resp, "DestDiffKeyName", "", "", "");
	if ((clientVer==-1.0 || clientVer>=1.03))
		m_Archived.marshall(rpc_resp, "Archived", "", "", "");
	m_encrypt.marshall(rpc_resp, "encrypt", "", "", "");
	m_decrypt.marshall(rpc_resp, "decrypt", "", "", "");
	if ((clientVer==-1.0 || clientVer>=1.08))
		m_failIfNoSourceFile.marshall(rpc_resp, "failIfNoSourceFile", "", "", "");
	if ((clientVer==-1.0 || clientVer>=1.09))
		m_recordStructurePresent.marshall(rpc_resp, "recordStructurePresent", "", "", "");
	if ((clientVer==-1.0 || clientVer>=1.1))
		m_quotedTerminator.marshall(rpc_resp, "quotedTerminator", "", "", "");
	if ((clientVer==-1.0 || clientVer>=1.12))
		m_preserveCompression.marshall(rpc_resp, "preserveCompression", "", "", "");
	if ((clientVer==-1.0 || clientVer>=1.14))
		m_expireDays.marshall(rpc_resp, "expireDays", "", "", "");
}


void CDFUWorkunit::copy(CDFUWorkunit &from)
{
	m_ID.copy(from.m_ID);
	m_DFUServerName.copy(from.m_DFUServerName);
	m_ClusterName.copy(from.m_ClusterName);
	m_JobName.copy(from.m_JobName);
	m_Queue.copy(from.m_Queue);
	m_User.copy(from.m_User);
	m_isProtected.copy(from.m_isProtected);
	m_Command.copy(from.m_Command);
	m_CommandMessage.copy(from.m_CommandMessage);
	m_PercentDone.copy(from.m_PercentDone);
	m_SecsLeft.copy(from.m_SecsLeft);
	m_ProgressMessage.copy(from.m_ProgressMessage);
	m_SummaryMessage.copy(from.m_SummaryMessage);
	m_State.copy(from.m_State);
	m_SourceLogicalName.copy(from.m_SourceLogicalName);
	m_SourceIP.copy(from.m_SourceIP);
	m_SourceFilePath.copy(from.m_SourceFilePath);
	m_SourceDali.copy(from.m_SourceDali);
	m_SourceRecordSize.copy(from.m_SourceRecordSize);
	m_SourceFormat.copy(from.m_SourceFormat);
	m_RowTag.copy(from.m_RowTag);
	m_SourceNumParts.copy(from.m_SourceNumParts);
	m_SourceDirectory.copy(from.m_SourceDirectory);
	m_DestLogicalName.copy(from.m_DestLogicalName);
	m_DestGroupName.copy(from.m_DestGroupName);
	m_DestDirectory.copy(from.m_DestDirectory);
	m_DestIP.copy(from.m_DestIP);
	m_DestFilePath.copy(from.m_DestFilePath);
	m_DestFormat.copy(from.m_DestFormat);
	m_DestNumParts.copy(from.m_DestNumParts);
	m_DestRecordSize.copy(from.m_DestRecordSize);
	m_Replicate.copy(from.m_Replicate);
	m_Overwrite.copy(from.m_Overwrite);
	m_Compress.copy(from.m_Compress);
	m_SourceCsvSeparate.copy(from.m_SourceCsvSeparate);
	m_SourceCsvQuote.copy(from.m_SourceCsvQuote);
	m_SourceCsvTerminate.copy(from.m_SourceCsvTerminate);
	m_SourceCsvEscape.copy(from.m_SourceCsvEscape);
	m_TimeStarted.copy(from.m_TimeStarted);
	m_TimeStopped.copy(from.m_TimeStopped);
	m_StateMessage.copy(from.m_StateMessage);
	m_MonitorEventName.copy(from.m_MonitorEventName);
	m_MonitorSub.copy(from.m_MonitorSub);
	m_MonitorShotLimit.copy(from.m_MonitorShotLimit);
	m_SourceDiffKeyName.copy(from.m_SourceDiffKeyName);
	m_DestDiffKeyName.copy(from.m_DestDiffKeyName);
	m_Archived.copy(from.m_Archived);
	m_encrypt.copy(from.m_encrypt);
	m_decrypt.copy(from.m_decrypt);
	m_failIfNoSourceFile.copy(from.m_failIfNoSourceFile);
	m_recordStructurePresent.copy(from.m_recordStructurePresent);
	m_quotedTerminator.copy(from.m_quotedTerminator);
	m_preserveCompression.copy(from.m_preserveCompression);
	m_expireDays.copy(from.m_expireDays);
}


void CDFUWorkunit::copy(IConstDFUWorkunit &ifrom)
{
	setID(ifrom.getID());
	setDFUServerName(ifrom.getDFUServerName());
	setClusterName(ifrom.getClusterName());
	setJobName(ifrom.getJobName());
	setQueue(ifrom.getQueue());
	setUser(ifrom.getUser());
	setIsProtected(ifrom.getIsProtected());
	setCommand(ifrom.getCommand());
	setCommandMessage(ifrom.getCommandMessage());
	setPercentDone(ifrom.getPercentDone());
	setSecsLeft(ifrom.getSecsLeft());
	setProgressMessage(ifrom.getProgressMessage());
	setSummaryMessage(ifrom.getSummaryMessage());
	setState(ifrom.getState());
	setSourceLogicalName(ifrom.getSourceLogicalName());
	setSourceIP(ifrom.getSourceIP());
	setSourceFilePath(ifrom.getSourceFilePath());
	setSourceDali(ifrom.getSourceDali());
	setSourceRecordSize(ifrom.getSourceRecordSize());
	setSourceFormat(ifrom.getSourceFormat());
	setRowTag(ifrom.getRowTag());
	setSourceNumParts(ifrom.getSourceNumParts());
	setSourceDirectory(ifrom.getSourceDirectory());
	setDestLogicalName(ifrom.getDestLogicalName());
	setDestGroupName(ifrom.getDestGroupName());
	setDestDirectory(ifrom.getDestDirectory());
	setDestIP(ifrom.getDestIP());
	setDestFilePath(ifrom.getDestFilePath());
	setDestFormat(ifrom.getDestFormat());
	setDestNumParts(ifrom.getDestNumParts());
	setDestRecordSize(ifrom.getDestRecordSize());
	setReplicate(ifrom.getReplicate());
	setOverwrite(ifrom.getOverwrite());
	setCompress(ifrom.getCompress());
	setSourceCsvSeparate(ifrom.getSourceCsvSeparate());
	setSourceCsvQuote(ifrom.getSourceCsvQuote());
	setSourceCsvTerminate(ifrom.getSourceCsvTerminate());
	setSourceCsvEscape(ifrom.getSourceCsvEscape());
	setTimeStarted(ifrom.getTimeStarted());
	setTimeStopped(ifrom.getTimeStopped());
	setStateMessage(ifrom.getStateMessage());
	setMonitorEventName(ifrom.getMonitorEventName());
	setMonitorSub(ifrom.getMonitorSub());
	setMonitorShotLimit(ifrom.getMonitorShotLimit());
	setSourceDiffKeyName(ifrom.getSourceDiffKeyName());
	setDestDiffKeyName(ifrom.getDestDiffKeyName());
	setArchived(ifrom.getArchived());
	setEncrypt(ifrom.getEncrypt());
	setDecrypt(ifrom.getDecrypt());
	setFailIfNoSourceFile(ifrom.getFailIfNoSourceFile());
	setRecordStructurePresent(ifrom.getRecordStructurePresent());
	setQuotedTerminator(ifrom.getQuotedTerminator());
	setPreserveCompression(ifrom.getPreserveCompression());
	setExpireDays(ifrom.getExpireDays());
}


void CDFUWorkunit::getAttributes(IProperties &attributes)
{
}


void CDFUWorkunit::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	double clientVer = ctx ? ctx->getClientVersion() : -1;
	m_ID.toStr(ctx, buffer, "ID", "", true, "", "");
	if ((clientVer==-1.0 || clientVer>=1.06))
		m_DFUServerName.toStr(ctx, buffer, "DFUServerName", "", true, "", "");
	m_ClusterName.toStr(ctx, buffer, "ClusterName", "", true, "", "");
	m_JobName.toStr(ctx, buffer, "JobName", "", true, "", "");
	m_Queue.toStr(ctx, buffer, "Queue", "", true, "", "");
	m_User.toStr(ctx, buffer, "User", "", true, "", "");
	m_isProtected.toStr(ctx, buffer, "isProtected", "", true, "", "");
	m_Command.toStr(ctx, buffer, "Command", "", true, "", "");
	if ((clientVer==-1.0 || clientVer>=1.03))
		m_CommandMessage.toStr(ctx, buffer, "CommandMessage", "", true, "", "");
	m_PercentDone.toStr(ctx, buffer, "PercentDone", "", true, "", "");
	m_SecsLeft.toStr(ctx, buffer, "SecsLeft", "", true, "", "");
	m_ProgressMessage.toStr(ctx, buffer, "ProgressMessage", "", true, "", "");
	m_SummaryMessage.toStr(ctx, buffer, "SummaryMessage", "", true, "", "");
	m_State.toStr(ctx, buffer, "State", "", true, "", "");
	m_SourceLogicalName.toStr(ctx, buffer, "SourceLogicalName", "", true, "", "");
	m_SourceIP.toStr(ctx, buffer, "SourceIP", "", true, "", "");
	m_SourceFilePath.toStr(ctx, buffer, "SourceFilePath", "", true, "", "");
	m_SourceDali.toStr(ctx, buffer, "SourceDali", "", true, "", "");
	m_SourceRecordSize.toStr(ctx, buffer, "SourceRecordSize", "", true, "", "");
	m_SourceFormat.toStr(ctx, buffer, "SourceFormat", "", true, "", "");
	m_RowTag.toStr(ctx, buffer, "RowTag", "", true, "", "");
	m_SourceNumParts.toStr(ctx, buffer, "SourceNumParts", "", true, "", "");
	m_SourceDirectory.toStr(ctx, buffer, "SourceDirectory", "", true, "", "");
	m_DestLogicalName.toStr(ctx, buffer, "DestLogicalName", "", true, "", "");
	m_DestGroupName.toStr(ctx, buffer, "DestGroupName", "", true, "", "");
	m_DestDirectory.toStr(ctx, buffer, "DestDirectory", "", true, "", "");
	m_DestIP.toStr(ctx, buffer, "DestIP", "", true, "", "");
	m_DestFilePath.toStr(ctx, buffer, "DestFilePath", "", true, "", "");
	m_DestFormat.toStr(ctx, buffer, "DestFormat", "", true, "", "");
	m_DestNumParts.toStr(ctx, buffer, "DestNumParts", "", true, "", "");
	m_DestRecordSize.toStr(ctx, buffer, "DestRecordSize", "", true, "", "");
	m_Replicate.toStr(ctx, buffer, "Replicate", "", true, "", "");
	m_Overwrite.toStr(ctx, buffer, "Overwrite", "", true, "", "");
	m_Compress.toStr(ctx, buffer, "Compress", "", true, "", "");
	if ((clientVer==-1.0 || clientVer>=1.04))
		m_SourceCsvSeparate.toStr(ctx, buffer, "SourceCsvSeparate", "", true, "", "");
	if ((clientVer==-1.0 || clientVer>=1.04))
		m_SourceCsvQuote.toStr(ctx, buffer, "SourceCsvQuote", "", true, "", "");
	if ((clientVer==-1.0 || clientVer>=1.04))
		m_SourceCsvTerminate.toStr(ctx, buffer, "SourceCsvTerminate", "", true, "", "");
	if ((clientVer==-1.0 || clientVer>=1.05))
		m_SourceCsvEscape.toStr(ctx, buffer, "SourceCsvEscape", "", true, "", "");
	m_TimeStarted.toStr(ctx, buffer, "TimeStarted", "", true, "", "");
	m_TimeStopped.toStr(ctx, buffer, "TimeStopped", "", true, "", "");
	m_StateMessage.toStr(ctx, buffer, "StateMessage", "", true, "", "");
	m_MonitorEventName.toStr(ctx, buffer, "MonitorEventName", "", true, "", "");
	m_MonitorSub.toStr(ctx, buffer, "MonitorSub", "", true, "", "");
	m_MonitorShotLimit.toStr(ctx, buffer, "MonitorShotLimit", "", true, "", "");
	m_SourceDiffKeyName.toStr(ctx, buffer, "SourceDiffKeyName", "", true, "", "");
	m_DestDiffKeyName.toStr(ctx, buffer, "DestDiffKeyName", "", true, "", "");
	if ((clientVer==-1.0 || clientVer>=1.03))
		m_Archived.toStr(ctx, buffer, "Archived", "", true, "", "");
	m_encrypt.toStr(ctx, buffer, "encrypt", "", true, "", "");
	m_decrypt.toStr(ctx, buffer, "decrypt", "", true, "", "");
	if ((clientVer==-1.0 || clientVer>=1.08))
		m_failIfNoSourceFile.toStr(ctx, buffer, "failIfNoSourceFile", "", true, "", "");
	if ((clientVer==-1.0 || clientVer>=1.09))
		m_recordStructurePresent.toStr(ctx, buffer, "recordStructurePresent", "", true, "", "");
	if ((clientVer==-1.0 || clientVer>=1.1))
		m_quotedTerminator.toStr(ctx, buffer, "quotedTerminator", "", true, "", "");
	if ((clientVer==-1.0 || clientVer>=1.12))
		m_preserveCompression.toStr(ctx, buffer, "preserveCompression", "", true, "", "");
	if ((clientVer==-1.0 || clientVer>=1.14))
		m_expireDays.toStr(ctx, buffer, "expireDays", "", true, "", "");
}


void CDFUWorkunit::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CDFUWorkunit::serializer(IEspContext* ctx, IConstDFUWorkunit &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<DFUWorkunit>");
	double clientVer = ctx ? ctx->getClientVersion() : -1;
	// field ID
	{
		const char* s = src.getID();
		if (s && *s)
		{
			buffer.append("<ID>");
			encodeUtf8XML(s,buffer);
			buffer.append("</ID>");
		}
	}
	// field DFUServerName
	if ((clientVer==-1.0 || clientVer>=1.06))
	{
		const char* s = src.getDFUServerName();
		if (s && *s)
		{
			buffer.append("<DFUServerName>");
			encodeUtf8XML(s,buffer);
			buffer.append("</DFUServerName>");
		}
	}
	// field ClusterName
	{
		const char* s = src.getClusterName();
		if (s && *s)
		{
			buffer.append("<ClusterName>");
			encodeUtf8XML(s,buffer);
			buffer.append("</ClusterName>");
		}
	}
	// field JobName
	{
		const char* s = src.getJobName();
		if (s && *s)
		{
			buffer.append("<JobName>");
			encodeUtf8XML(s,buffer);
			buffer.append("</JobName>");
		}
	}
	// field Queue
	{
		const char* s = src.getQueue();
		if (s && *s)
		{
			buffer.append("<Queue>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Queue>");
		}
	}
	// field User
	{
		const char* s = src.getUser();
		if (s && *s)
		{
			buffer.append("<User>");
			encodeUtf8XML(s,buffer);
			buffer.append("</User>");
		}
	}
	// field isProtected
	{
		bool b = src.getIsProtected();
		if (b)
			buffer.appendf("<isProtected>1</isProtected>");
	}
	// field Command
	{
		int n = src.getCommand();
		if (n)
			buffer.appendf("<Command>%d</Command>", n);
	}
	// field CommandMessage
	if ((clientVer==-1.0 || clientVer>=1.03))
	{
		const char* s = src.getCommandMessage();
		if (s && *s)
		{
			buffer.append("<CommandMessage>");
			encodeUtf8XML(s,buffer);
			buffer.append("</CommandMessage>");
		}
	}
	// field PercentDone
	{
		int n = src.getPercentDone();
		if (n)
			buffer.appendf("<PercentDone>%d</PercentDone>", n);
	}
	// field SecsLeft
	{
		int n = src.getSecsLeft();
		if (n)
			buffer.appendf("<SecsLeft>%d</SecsLeft>", n);
	}
	// field ProgressMessage
	{
		const char* s = src.getProgressMessage();
		if (s && *s)
		{
			buffer.append("<ProgressMessage>");
			encodeUtf8XML(s,buffer);
			buffer.append("</ProgressMessage>");
		}
	}
	// field SummaryMessage
	{
		const char* s = src.getSummaryMessage();
		if (s && *s)
		{
			buffer.append("<SummaryMessage>");
			encodeUtf8XML(s,buffer);
			buffer.append("</SummaryMessage>");
		}
	}
	// field State
	{
		int n = src.getState();
		if (n)
			buffer.appendf("<State>%d</State>", n);
	}
	// field SourceLogicalName
	{
		const char* s = src.getSourceLogicalName();
		if (s && *s)
		{
			buffer.append("<SourceLogicalName>");
			encodeUtf8XML(s,buffer);
			buffer.append("</SourceLogicalName>");
		}
	}
	// field SourceIP
	{
		const char* s = src.getSourceIP();
		if (s && *s)
		{
			buffer.append("<SourceIP>");
			encodeUtf8XML(s,buffer);
			buffer.append("</SourceIP>");
		}
	}
	// field SourceFilePath
	{
		const char* s = src.getSourceFilePath();
		if (s && *s)
		{
			buffer.append("<SourceFilePath>");
			encodeUtf8XML(s,buffer);
			buffer.append("</SourceFilePath>");
		}
	}
	// field SourceDali
	{
		const char* s = src.getSourceDali();
		if (s && *s)
		{
			buffer.append("<SourceDali>");
			encodeUtf8XML(s,buffer);
			buffer.append("</SourceDali>");
		}
	}
	// field SourceRecordSize
	{
		int n = src.getSourceRecordSize();
		if (n)
			buffer.appendf("<SourceRecordSize>%d</SourceRecordSize>", n);
	}
	// field SourceFormat
	{
		int n = src.getSourceFormat();
		if (n)
			buffer.appendf("<SourceFormat>%d</SourceFormat>", n);
	}
	// field RowTag
	{
		const char* s = src.getRowTag();
		if (s && *s)
		{
			buffer.append("<RowTag>");
			encodeUtf8XML(s,buffer);
			buffer.append("</RowTag>");
		}
	}
	// field SourceNumParts
	{
		int n = src.getSourceNumParts();
		if (n)
			buffer.appendf("<SourceNumParts>%d</SourceNumParts>", n);
	}
	// field SourceDirectory
	{
		const char* s = src.getSourceDirectory();
		if (s && *s)
		{
			buffer.append("<SourceDirectory>");
			encodeUtf8XML(s,buffer);
			buffer.append("</SourceDirectory>");
		}
	}
	// field DestLogicalName
	{
		const char* s = src.getDestLogicalName();
		if (s && *s)
		{
			buffer.append("<DestLogicalName>");
			encodeUtf8XML(s,buffer);
			buffer.append("</DestLogicalName>");
		}
	}
	// field DestGroupName
	{
		const char* s = src.getDestGroupName();
		if (s && *s)
		{
			buffer.append("<DestGroupName>");
			encodeUtf8XML(s,buffer);
			buffer.append("</DestGroupName>");
		}
	}
	// field DestDirectory
	{
		const char* s = src.getDestDirectory();
		if (s && *s)
		{
			buffer.append("<DestDirectory>");
			encodeUtf8XML(s,buffer);
			buffer.append("</DestDirectory>");
		}
	}
	// field DestIP
	{
		const char* s = src.getDestIP();
		if (s && *s)
		{
			buffer.append("<DestIP>");
			encodeUtf8XML(s,buffer);
			buffer.append("</DestIP>");
		}
	}
	// field DestFilePath
	{
		const char* s = src.getDestFilePath();
		if (s && *s)
		{
			buffer.append("<DestFilePath>");
			encodeUtf8XML(s,buffer);
			buffer.append("</DestFilePath>");
		}
	}
	// field DestFormat
	{
		int n = src.getDestFormat();
		if (n)
			buffer.appendf("<DestFormat>%d</DestFormat>", n);
	}
	// field DestNumParts
	{
		int n = src.getDestNumParts();
		if (n)
			buffer.appendf("<DestNumParts>%d</DestNumParts>", n);
	}
	// field DestRecordSize
	{
		int n = src.getDestRecordSize();
		if (n)
			buffer.appendf("<DestRecordSize>%d</DestRecordSize>", n);
	}
	// field Replicate
	{
		bool b = src.getReplicate();
		if (b)
			buffer.appendf("<Replicate>1</Replicate>");
	}
	// field Overwrite
	{
		bool b = src.getOverwrite();
		if (b)
			buffer.appendf("<Overwrite>1</Overwrite>");
	}
	// field Compress
	{
		bool b = src.getCompress();
		if (b)
			buffer.appendf("<Compress>1</Compress>");
	}
	// field SourceCsvSeparate
	if ((clientVer==-1.0 || clientVer>=1.04))
	{
		const char* s = src.getSourceCsvSeparate();
		if (s && *s)
		{
			buffer.append("<SourceCsvSeparate>");
			encodeUtf8XML(s,buffer);
			buffer.append("</SourceCsvSeparate>");
		}
	}
	// field SourceCsvQuote
	if ((clientVer==-1.0 || clientVer>=1.04))
	{
		const char* s = src.getSourceCsvQuote();
		if (s && *s)
		{
			buffer.append("<SourceCsvQuote>");
			encodeUtf8XML(s,buffer);
			buffer.append("</SourceCsvQuote>");
		}
	}
	// field SourceCsvTerminate
	if ((clientVer==-1.0 || clientVer>=1.04))
	{
		const char* s = src.getSourceCsvTerminate();
		if (s && *s)
		{
			buffer.append("<SourceCsvTerminate>");
			encodeUtf8XML(s,buffer);
			buffer.append("</SourceCsvTerminate>");
		}
	}
	// field SourceCsvEscape
	if ((clientVer==-1.0 || clientVer>=1.05))
	{
		const char* s = src.getSourceCsvEscape();
		if (s && *s)
		{
			buffer.append("<SourceCsvEscape>");
			encodeUtf8XML(s,buffer);
			buffer.append("</SourceCsvEscape>");
		}
	}
	// field TimeStarted
	{
		const char* s = src.getTimeStarted();
		if (s && *s)
		{
			buffer.append("<TimeStarted>");
			encodeUtf8XML(s,buffer);
			buffer.append("</TimeStarted>");
		}
	}
	// field TimeStopped
	{
		const char* s = src.getTimeStopped();
		if (s && *s)
		{
			buffer.append("<TimeStopped>");
			encodeUtf8XML(s,buffer);
			buffer.append("</TimeStopped>");
		}
	}
	// field StateMessage
	{
		const char* s = src.getStateMessage();
		if (s && *s)
		{
			buffer.append("<StateMessage>");
			encodeUtf8XML(s,buffer);
			buffer.append("</StateMessage>");
		}
	}
	// field MonitorEventName
	{
		const char* s = src.getMonitorEventName();
		if (s && *s)
		{
			buffer.append("<MonitorEventName>");
			encodeUtf8XML(s,buffer);
			buffer.append("</MonitorEventName>");
		}
	}
	// field MonitorSub
	{
		bool b = src.getMonitorSub();
		if (b)
			buffer.appendf("<MonitorSub>1</MonitorSub>");
	}
	// field MonitorShotLimit
	{
		int n = src.getMonitorShotLimit();
		if (n)
			buffer.appendf("<MonitorShotLimit>%d</MonitorShotLimit>", n);
	}
	// field SourceDiffKeyName
	{
		const char* s = src.getSourceDiffKeyName();
		if (s && *s)
		{
			buffer.append("<SourceDiffKeyName>");
			encodeUtf8XML(s,buffer);
			buffer.append("</SourceDiffKeyName>");
		}
	}
	// field DestDiffKeyName
	{
		const char* s = src.getDestDiffKeyName();
		if (s && *s)
		{
			buffer.append("<DestDiffKeyName>");
			encodeUtf8XML(s,buffer);
			buffer.append("</DestDiffKeyName>");
		}
	}
	// field Archived
	if ((clientVer==-1.0 || clientVer>=1.03))
	{
		bool b = src.getArchived();
		if (b)
			buffer.appendf("<Archived>1</Archived>");
	}
	// field encrypt
	{
		const char* s = src.getEncrypt();
		if (s && *s)
		{
			buffer.append("<encrypt>");
			encodeUtf8XML(s,buffer);
			buffer.append("</encrypt>");
		}
	}
	// field decrypt
	{
		const char* s = src.getDecrypt();
		if (s && *s)
		{
			buffer.append("<decrypt>");
			encodeUtf8XML(s,buffer);
			buffer.append("</decrypt>");
		}
	}
	// field failIfNoSourceFile
	if ((clientVer==-1.0 || clientVer>=1.08))
	{
		bool b = src.getFailIfNoSourceFile();
		if (b)
			buffer.appendf("<failIfNoSourceFile>1</failIfNoSourceFile>");
	}
	// field recordStructurePresent
	if ((clientVer==-1.0 || clientVer>=1.09))
	{
		bool b = src.getRecordStructurePresent();
		if (b)
			buffer.appendf("<recordStructurePresent>1</recordStructurePresent>");
	}
	// field quotedTerminator
	if ((clientVer==-1.0 || clientVer>=1.1))
	{
		bool b = src.getQuotedTerminator();
		if (b)
			buffer.appendf("<quotedTerminator>1</quotedTerminator>");
	}
	// field preserveCompression
	if ((clientVer==-1.0 || clientVer>=1.12))
	{
		bool b = src.getPreserveCompression();
		if (b)
			buffer.appendf("<preserveCompression>1</preserveCompression>");
	}
	// field expireDays
	if ((clientVer==-1.0 || clientVer>=1.14))
	{
		int n = src.getExpireDays();
		if (n)
			buffer.appendf("<expireDays>%d</expireDays>", n);
	}
	if (keepRootTag)
		buffer.append("</DFUWorkunit>");
}

bool CDFUWorkunit::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_ID.unmarshall(rpc_request, "ID", basepath);
	hasValue |= m_DFUServerName.unmarshall(rpc_request, "DFUServerName", basepath);
	hasValue |= m_ClusterName.unmarshall(rpc_request, "ClusterName", basepath);
	hasValue |= m_JobName.unmarshall(rpc_request, "JobName", basepath);
	hasValue |= m_Queue.unmarshall(rpc_request, "Queue", basepath);
	hasValue |= m_User.unmarshall(rpc_request, "User", basepath);
	hasValue |= m_isProtected.unmarshall(rpc_request, "isProtected", basepath);
	hasValue |= m_Command.unmarshall(rpc_request, "Command", basepath);
	hasValue |= m_CommandMessage.unmarshall(rpc_request, "CommandMessage", basepath);
	hasValue |= m_PercentDone.unmarshall(rpc_request, "PercentDone", basepath);
	hasValue |= m_SecsLeft.unmarshall(rpc_request, "SecsLeft", basepath);
	hasValue |= m_ProgressMessage.unmarshall(rpc_request, "ProgressMessage", basepath);
	hasValue |= m_SummaryMessage.unmarshall(rpc_request, "SummaryMessage", basepath);
	hasValue |= m_State.unmarshall(rpc_request, "State", basepath);
	hasValue |= m_SourceLogicalName.unmarshall(rpc_request, "SourceLogicalName", basepath);
	hasValue |= m_SourceIP.unmarshall(rpc_request, "SourceIP", basepath);
	hasValue |= m_SourceFilePath.unmarshall(rpc_request, "SourceFilePath", basepath);
	hasValue |= m_SourceDali.unmarshall(rpc_request, "SourceDali", basepath);
	hasValue |= m_SourceRecordSize.unmarshall(rpc_request, "SourceRecordSize", basepath);
	hasValue |= m_SourceFormat.unmarshall(rpc_request, "SourceFormat", basepath);
	hasValue |= m_RowTag.unmarshall(rpc_request, "RowTag", basepath);
	hasValue |= m_SourceNumParts.unmarshall(rpc_request, "SourceNumParts", basepath);
	hasValue |= m_SourceDirectory.unmarshall(rpc_request, "SourceDirectory", basepath);
	hasValue |= m_DestLogicalName.unmarshall(rpc_request, "DestLogicalName", basepath);
	hasValue |= m_DestGroupName.unmarshall(rpc_request, "DestGroupName", basepath);
	hasValue |= m_DestDirectory.unmarshall(rpc_request, "DestDirectory", basepath);
	hasValue |= m_DestIP.unmarshall(rpc_request, "DestIP", basepath);
	hasValue |= m_DestFilePath.unmarshall(rpc_request, "DestFilePath", basepath);
	hasValue |= m_DestFormat.unmarshall(rpc_request, "DestFormat", basepath);
	hasValue |= m_DestNumParts.unmarshall(rpc_request, "DestNumParts", basepath);
	hasValue |= m_DestRecordSize.unmarshall(rpc_request, "DestRecordSize", basepath);
	hasValue |= m_Replicate.unmarshall(rpc_request, "Replicate", basepath);
	hasValue |= m_Overwrite.unmarshall(rpc_request, "Overwrite", basepath);
	hasValue |= m_Compress.unmarshall(rpc_request, "Compress", basepath);
	hasValue |= m_SourceCsvSeparate.unmarshall(rpc_request, "SourceCsvSeparate", basepath);
	hasValue |= m_SourceCsvQuote.unmarshall(rpc_request, "SourceCsvQuote", basepath);
	hasValue |= m_SourceCsvTerminate.unmarshall(rpc_request, "SourceCsvTerminate", basepath);
	hasValue |= m_SourceCsvEscape.unmarshall(rpc_request, "SourceCsvEscape", basepath);
	hasValue |= m_TimeStarted.unmarshall(rpc_request, "TimeStarted", basepath);
	hasValue |= m_TimeStopped.unmarshall(rpc_request, "TimeStopped", basepath);
	hasValue |= m_StateMessage.unmarshall(rpc_request, "StateMessage", basepath);
	hasValue |= m_MonitorEventName.unmarshall(rpc_request, "MonitorEventName", basepath);
	hasValue |= m_MonitorSub.unmarshall(rpc_request, "MonitorSub", basepath);
	hasValue |= m_MonitorShotLimit.unmarshall(rpc_request, "MonitorShotLimit", basepath);
	hasValue |= m_SourceDiffKeyName.unmarshall(rpc_request, "SourceDiffKeyName", basepath);
	hasValue |= m_DestDiffKeyName.unmarshall(rpc_request, "DestDiffKeyName", basepath);
	hasValue |= m_Archived.unmarshall(rpc_request, "Archived", basepath);
	hasValue |= m_encrypt.unmarshall(rpc_request, "encrypt", basepath);
	hasValue |= m_decrypt.unmarshall(rpc_request, "decrypt", basepath);
	hasValue |= m_failIfNoSourceFile.unmarshall(rpc_request, "failIfNoSourceFile", basepath);
	hasValue |= m_recordStructurePresent.unmarshall(rpc_request, "recordStructurePresent", basepath);
	hasValue |= m_quotedTerminator.unmarshall(rpc_request, "quotedTerminator", basepath);
	hasValue |= m_preserveCompression.unmarshall(rpc_request, "preserveCompression", basepath);
	hasValue |= m_expireDays.unmarshall(rpc_request, "expireDays", basepath);
	return hasValue;
}

bool CDFUWorkunit::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_ID.unmarshall(ctx, soapval, "ID");
	hasValue |= m_DFUServerName.unmarshall(ctx, soapval, "DFUServerName");
	hasValue |= m_ClusterName.unmarshall(ctx, soapval, "ClusterName");
	hasValue |= m_JobName.unmarshall(ctx, soapval, "JobName");
	hasValue |= m_Queue.unmarshall(ctx, soapval, "Queue");
	hasValue |= m_User.unmarshall(ctx, soapval, "User");
	hasValue |= m_isProtected.unmarshall(ctx, soapval, "isProtected");
	hasValue |= m_Command.unmarshall(ctx, soapval, "Command");
	hasValue |= m_CommandMessage.unmarshall(ctx, soapval, "CommandMessage");
	hasValue |= m_PercentDone.unmarshall(ctx, soapval, "PercentDone");
	hasValue |= m_SecsLeft.unmarshall(ctx, soapval, "SecsLeft");
	hasValue |= m_ProgressMessage.unmarshall(ctx, soapval, "ProgressMessage");
	hasValue |= m_SummaryMessage.unmarshall(ctx, soapval, "SummaryMessage");
	hasValue |= m_State.unmarshall(ctx, soapval, "State");
	hasValue |= m_SourceLogicalName.unmarshall(ctx, soapval, "SourceLogicalName");
	hasValue |= m_SourceIP.unmarshall(ctx, soapval, "SourceIP");
	hasValue |= m_SourceFilePath.unmarshall(ctx, soapval, "SourceFilePath");
	hasValue |= m_SourceDali.unmarshall(ctx, soapval, "SourceDali");
	hasValue |= m_SourceRecordSize.unmarshall(ctx, soapval, "SourceRecordSize");
	hasValue |= m_SourceFormat.unmarshall(ctx, soapval, "SourceFormat");
	hasValue |= m_RowTag.unmarshall(ctx, soapval, "RowTag");
	hasValue |= m_SourceNumParts.unmarshall(ctx, soapval, "SourceNumParts");
	hasValue |= m_SourceDirectory.unmarshall(ctx, soapval, "SourceDirectory");
	hasValue |= m_DestLogicalName.unmarshall(ctx, soapval, "DestLogicalName");
	hasValue |= m_DestGroupName.unmarshall(ctx, soapval, "DestGroupName");
	hasValue |= m_DestDirectory.unmarshall(ctx, soapval, "DestDirectory");
	hasValue |= m_DestIP.unmarshall(ctx, soapval, "DestIP");
	hasValue |= m_DestFilePath.unmarshall(ctx, soapval, "DestFilePath");
	hasValue |= m_DestFormat.unmarshall(ctx, soapval, "DestFormat");
	hasValue |= m_DestNumParts.unmarshall(ctx, soapval, "DestNumParts");
	hasValue |= m_DestRecordSize.unmarshall(ctx, soapval, "DestRecordSize");
	hasValue |= m_Replicate.unmarshall(ctx, soapval, "Replicate");
	hasValue |= m_Overwrite.unmarshall(ctx, soapval, "Overwrite");
	hasValue |= m_Compress.unmarshall(ctx, soapval, "Compress");
	hasValue |= m_SourceCsvSeparate.unmarshall(ctx, soapval, "SourceCsvSeparate");
	hasValue |= m_SourceCsvQuote.unmarshall(ctx, soapval, "SourceCsvQuote");
	hasValue |= m_SourceCsvTerminate.unmarshall(ctx, soapval, "SourceCsvTerminate");
	hasValue |= m_SourceCsvEscape.unmarshall(ctx, soapval, "SourceCsvEscape");
	hasValue |= m_TimeStarted.unmarshall(ctx, soapval, "TimeStarted");
	hasValue |= m_TimeStopped.unmarshall(ctx, soapval, "TimeStopped");
	hasValue |= m_StateMessage.unmarshall(ctx, soapval, "StateMessage");
	hasValue |= m_MonitorEventName.unmarshall(ctx, soapval, "MonitorEventName");
	hasValue |= m_MonitorSub.unmarshall(ctx, soapval, "MonitorSub");
	hasValue |= m_MonitorShotLimit.unmarshall(ctx, soapval, "MonitorShotLimit");
	hasValue |= m_SourceDiffKeyName.unmarshall(ctx, soapval, "SourceDiffKeyName");
	hasValue |= m_DestDiffKeyName.unmarshall(ctx, soapval, "DestDiffKeyName");
	hasValue |= m_Archived.unmarshall(ctx, soapval, "Archived");
	hasValue |= m_encrypt.unmarshall(ctx, soapval, "encrypt");
	hasValue |= m_decrypt.unmarshall(ctx, soapval, "decrypt");
	hasValue |= m_failIfNoSourceFile.unmarshall(ctx, soapval, "failIfNoSourceFile");
	hasValue |= m_recordStructurePresent.unmarshall(ctx, soapval, "recordStructurePresent");
	hasValue |= m_quotedTerminator.unmarshall(ctx, soapval, "quotedTerminator");
	hasValue |= m_preserveCompression.unmarshall(ctx, soapval, "preserveCompression");
	hasValue |= m_expireDays.unmarshall(ctx, soapval, "expireDays");
	return hasValue;
}

bool CDFUWorkunit::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_ID.unmarshall(ctx, params, attachments, "ID", basepath);
	hasValue |= m_DFUServerName.unmarshall(ctx, params, attachments, "DFUServerName", basepath);
	hasValue |= m_ClusterName.unmarshall(ctx, params, attachments, "ClusterName", basepath);
	hasValue |= m_JobName.unmarshall(ctx, params, attachments, "JobName", basepath);
	hasValue |= m_Queue.unmarshall(ctx, params, attachments, "Queue", basepath);
	hasValue |= m_User.unmarshall(ctx, params, attachments, "User", basepath);
	hasValue |= m_isProtected.unmarshall(ctx, params, attachments, "isProtected", basepath);
	hasValue |= m_Command.unmarshall(ctx, params, attachments, "Command", basepath);
	hasValue |= m_CommandMessage.unmarshall(ctx, params, attachments, "CommandMessage", basepath);
	hasValue |= m_PercentDone.unmarshall(ctx, params, attachments, "PercentDone", basepath);
	hasValue |= m_SecsLeft.unmarshall(ctx, params, attachments, "SecsLeft", basepath);
	hasValue |= m_ProgressMessage.unmarshall(ctx, params, attachments, "ProgressMessage", basepath);
	hasValue |= m_SummaryMessage.unmarshall(ctx, params, attachments, "SummaryMessage", basepath);
	hasValue |= m_State.unmarshall(ctx, params, attachments, "State", basepath);
	hasValue |= m_SourceLogicalName.unmarshall(ctx, params, attachments, "SourceLogicalName", basepath);
	hasValue |= m_SourceIP.unmarshall(ctx, params, attachments, "SourceIP", basepath);
	hasValue |= m_SourceFilePath.unmarshall(ctx, params, attachments, "SourceFilePath", basepath);
	hasValue |= m_SourceDali.unmarshall(ctx, params, attachments, "SourceDali", basepath);
	hasValue |= m_SourceRecordSize.unmarshall(ctx, params, attachments, "SourceRecordSize", basepath);
	hasValue |= m_SourceFormat.unmarshall(ctx, params, attachments, "SourceFormat", basepath);
	hasValue |= m_RowTag.unmarshall(ctx, params, attachments, "RowTag", basepath);
	hasValue |= m_SourceNumParts.unmarshall(ctx, params, attachments, "SourceNumParts", basepath);
	hasValue |= m_SourceDirectory.unmarshall(ctx, params, attachments, "SourceDirectory", basepath);
	hasValue |= m_DestLogicalName.unmarshall(ctx, params, attachments, "DestLogicalName", basepath);
	hasValue |= m_DestGroupName.unmarshall(ctx, params, attachments, "DestGroupName", basepath);
	hasValue |= m_DestDirectory.unmarshall(ctx, params, attachments, "DestDirectory", basepath);
	hasValue |= m_DestIP.unmarshall(ctx, params, attachments, "DestIP", basepath);
	hasValue |= m_DestFilePath.unmarshall(ctx, params, attachments, "DestFilePath", basepath);
	hasValue |= m_DestFormat.unmarshall(ctx, params, attachments, "DestFormat", basepath);
	hasValue |= m_DestNumParts.unmarshall(ctx, params, attachments, "DestNumParts", basepath);
	hasValue |= m_DestRecordSize.unmarshall(ctx, params, attachments, "DestRecordSize", basepath);
	hasValue |= m_Replicate.unmarshall(ctx, params, attachments, "Replicate", basepath);
	hasValue |= m_Overwrite.unmarshall(ctx, params, attachments, "Overwrite", basepath);
	hasValue |= m_Compress.unmarshall(ctx, params, attachments, "Compress", basepath);
	hasValue |= m_SourceCsvSeparate.unmarshall(ctx, params, attachments, "SourceCsvSeparate", basepath);
	hasValue |= m_SourceCsvQuote.unmarshall(ctx, params, attachments, "SourceCsvQuote", basepath);
	hasValue |= m_SourceCsvTerminate.unmarshall(ctx, params, attachments, "SourceCsvTerminate", basepath);
	hasValue |= m_SourceCsvEscape.unmarshall(ctx, params, attachments, "SourceCsvEscape", basepath);
	hasValue |= m_TimeStarted.unmarshall(ctx, params, attachments, "TimeStarted", basepath);
	hasValue |= m_TimeStopped.unmarshall(ctx, params, attachments, "TimeStopped", basepath);
	hasValue |= m_StateMessage.unmarshall(ctx, params, attachments, "StateMessage", basepath);
	hasValue |= m_MonitorEventName.unmarshall(ctx, params, attachments, "MonitorEventName", basepath);
	hasValue |= m_MonitorSub.unmarshall(ctx, params, attachments, "MonitorSub", basepath);
	hasValue |= m_MonitorShotLimit.unmarshall(ctx, params, attachments, "MonitorShotLimit", basepath);
	hasValue |= m_SourceDiffKeyName.unmarshall(ctx, params, attachments, "SourceDiffKeyName", basepath);
	hasValue |= m_DestDiffKeyName.unmarshall(ctx, params, attachments, "DestDiffKeyName", basepath);
	hasValue |= m_Archived.unmarshall(ctx, params, attachments, "Archived", basepath);
	hasValue |= m_encrypt.unmarshall(ctx, params, attachments, "encrypt", basepath);
	hasValue |= m_decrypt.unmarshall(ctx, params, attachments, "decrypt", basepath);
	hasValue |= m_failIfNoSourceFile.unmarshall(ctx, params, attachments, "failIfNoSourceFile", basepath);
	hasValue |= m_recordStructurePresent.unmarshall(ctx, params, attachments, "recordStructurePresent", basepath);
	hasValue |= m_quotedTerminator.unmarshall(ctx, params, attachments, "quotedTerminator", basepath);
	hasValue |= m_preserveCompression.unmarshall(ctx, params, attachments, "preserveCompression", basepath);
	hasValue |= m_expireDays.unmarshall(ctx, params, attachments, "expireDays", basepath);
	return hasValue;
}

const char * CDFUWorkunit::getID() { return m_ID.query();}
const char * CDFUWorkunit::getDFUServerName() { return m_DFUServerName.query();}
const char * CDFUWorkunit::getClusterName() { return m_ClusterName.query();}
const char * CDFUWorkunit::getJobName() { return m_JobName.query();}
const char * CDFUWorkunit::getQueue() { return m_Queue.query();}
const char * CDFUWorkunit::getUser() { return m_User.query();}
bool CDFUWorkunit::getIsProtected_isNull(){return m_isProtected.is_nil();}
bool CDFUWorkunit::getIsProtected() { return m_isProtected;}
bool CDFUWorkunit::getCommand_isNull(){return m_Command.is_nil();}
int CDFUWorkunit::getCommand() { return m_Command;}
const char * CDFUWorkunit::getCommandMessage() { return m_CommandMessage.query();}
bool CDFUWorkunit::getPercentDone_isNull(){return m_PercentDone.is_nil();}
int CDFUWorkunit::getPercentDone() { return m_PercentDone;}
bool CDFUWorkunit::getSecsLeft_isNull(){return m_SecsLeft.is_nil();}
int CDFUWorkunit::getSecsLeft() { return m_SecsLeft;}
const char * CDFUWorkunit::getProgressMessage() { return m_ProgressMessage.query();}
const char * CDFUWorkunit::getSummaryMessage() { return m_SummaryMessage.query();}
bool CDFUWorkunit::getState_isNull(){return m_State.is_nil();}
int CDFUWorkunit::getState() { return m_State;}
const char * CDFUWorkunit::getSourceLogicalName() { return m_SourceLogicalName.query();}
const char * CDFUWorkunit::getSourceIP() { return m_SourceIP.query();}
const char * CDFUWorkunit::getSourceFilePath() { return m_SourceFilePath.query();}
const char * CDFUWorkunit::getSourceDali() { return m_SourceDali.query();}
bool CDFUWorkunit::getSourceRecordSize_isNull(){return m_SourceRecordSize.is_nil();}
int CDFUWorkunit::getSourceRecordSize() { return m_SourceRecordSize;}
bool CDFUWorkunit::getSourceFormat_isNull(){return m_SourceFormat.is_nil();}
int CDFUWorkunit::getSourceFormat() { return m_SourceFormat;}
const char * CDFUWorkunit::getRowTag() { return m_RowTag.query();}
bool CDFUWorkunit::getSourceNumParts_isNull(){return m_SourceNumParts.is_nil();}
int CDFUWorkunit::getSourceNumParts() { return m_SourceNumParts;}
const char * CDFUWorkunit::getSourceDirectory() { return m_SourceDirectory.query();}
const char * CDFUWorkunit::getDestLogicalName() { return m_DestLogicalName.query();}
const char * CDFUWorkunit::getDestGroupName() { return m_DestGroupName.query();}
const char * CDFUWorkunit::getDestDirectory() { return m_DestDirectory.query();}
const char * CDFUWorkunit::getDestIP() { return m_DestIP.query();}
const char * CDFUWorkunit::getDestFilePath() { return m_DestFilePath.query();}
bool CDFUWorkunit::getDestFormat_isNull(){return m_DestFormat.is_nil();}
int CDFUWorkunit::getDestFormat() { return m_DestFormat;}
bool CDFUWorkunit::getDestNumParts_isNull(){return m_DestNumParts.is_nil();}
int CDFUWorkunit::getDestNumParts() { return m_DestNumParts;}
bool CDFUWorkunit::getDestRecordSize_isNull(){return m_DestRecordSize.is_nil();}
int CDFUWorkunit::getDestRecordSize() { return m_DestRecordSize;}
bool CDFUWorkunit::getReplicate_isNull(){return m_Replicate.is_nil();}
bool CDFUWorkunit::getReplicate() { return m_Replicate;}
bool CDFUWorkunit::getOverwrite_isNull(){return m_Overwrite.is_nil();}
bool CDFUWorkunit::getOverwrite() { return m_Overwrite;}
bool CDFUWorkunit::getCompress_isNull(){return m_Compress.is_nil();}
bool CDFUWorkunit::getCompress() { return m_Compress;}
const char * CDFUWorkunit::getSourceCsvSeparate() { return m_SourceCsvSeparate.query();}
const char * CDFUWorkunit::getSourceCsvQuote() { return m_SourceCsvQuote.query();}
const char * CDFUWorkunit::getSourceCsvTerminate() { return m_SourceCsvTerminate.query();}
const char * CDFUWorkunit::getSourceCsvEscape() { return m_SourceCsvEscape.query();}
const char * CDFUWorkunit::getTimeStarted() { return m_TimeStarted.query();}
const char * CDFUWorkunit::getTimeStopped() { return m_TimeStopped.query();}
const char * CDFUWorkunit::getStateMessage() { return m_StateMessage.query();}
const char * CDFUWorkunit::getMonitorEventName() { return m_MonitorEventName.query();}
bool CDFUWorkunit::getMonitorSub_isNull(){return m_MonitorSub.is_nil();}
bool CDFUWorkunit::getMonitorSub() { return m_MonitorSub;}
bool CDFUWorkunit::getMonitorShotLimit_isNull(){return m_MonitorShotLimit.is_nil();}
int CDFUWorkunit::getMonitorShotLimit() { return m_MonitorShotLimit;}
const char * CDFUWorkunit::getSourceDiffKeyName() { return m_SourceDiffKeyName.query();}
const char * CDFUWorkunit::getDestDiffKeyName() { return m_DestDiffKeyName.query();}
bool CDFUWorkunit::getArchived_isNull(){return m_Archived.is_nil();}
bool CDFUWorkunit::getArchived() { return m_Archived;}
const char * CDFUWorkunit::getEncrypt() { return m_encrypt.query();}
const char * CDFUWorkunit::getDecrypt() { return m_decrypt.query();}
bool CDFUWorkunit::getFailIfNoSourceFile_isNull(){return m_failIfNoSourceFile.is_nil();}
bool CDFUWorkunit::getFailIfNoSourceFile() { return m_failIfNoSourceFile;}
bool CDFUWorkunit::getRecordStructurePresent_isNull(){return m_recordStructurePresent.is_nil();}
bool CDFUWorkunit::getRecordStructurePresent() { return m_recordStructurePresent;}
bool CDFUWorkunit::getQuotedTerminator_isNull(){return m_quotedTerminator.is_nil();}
bool CDFUWorkunit::getQuotedTerminator() { return m_quotedTerminator;}
bool CDFUWorkunit::getPreserveCompression_isNull(){return m_preserveCompression.is_nil();}
bool CDFUWorkunit::getPreserveCompression() { return m_preserveCompression;}
bool CDFUWorkunit::getExpireDays_isNull(){return m_expireDays.is_nil();}
int CDFUWorkunit::getExpireDays() { return m_expireDays;}
void CDFUWorkunit::setID(const char * val){ m_ID.set(val); }
void CDFUWorkunit::setDFUServerName(const char * val){ m_DFUServerName.set(val); }
void CDFUWorkunit::setClusterName(const char * val){ m_ClusterName.set(val); }
void CDFUWorkunit::setJobName(const char * val){ m_JobName.set(val); }
void CDFUWorkunit::setQueue(const char * val){ m_Queue.set(val); }
void CDFUWorkunit::setUser(const char * val){ m_User.set(val); }
void CDFUWorkunit::setIsProtected_null(){ m_isProtected.Nil(); }void CDFUWorkunit::setIsProtected(bool val){ m_isProtected=val; }
void CDFUWorkunit::setCommand_null(){ m_Command.Nil(); }void CDFUWorkunit::setCommand(int val){ m_Command=val; }
void CDFUWorkunit::setCommandMessage(const char * val){ m_CommandMessage.set(val); }
void CDFUWorkunit::setPercentDone_null(){ m_PercentDone.Nil(); }void CDFUWorkunit::setPercentDone(int val){ m_PercentDone=val; }
void CDFUWorkunit::setSecsLeft_null(){ m_SecsLeft.Nil(); }void CDFUWorkunit::setSecsLeft(int val){ m_SecsLeft=val; }
void CDFUWorkunit::setProgressMessage(const char * val){ m_ProgressMessage.set(val); }
void CDFUWorkunit::setSummaryMessage(const char * val){ m_SummaryMessage.set(val); }
void CDFUWorkunit::setState_null(){ m_State.Nil(); }void CDFUWorkunit::setState(int val){ m_State=val; }
void CDFUWorkunit::setSourceLogicalName(const char * val){ m_SourceLogicalName.set(val); }
void CDFUWorkunit::setSourceIP(const char * val){ m_SourceIP.set(val); }
void CDFUWorkunit::setSourceFilePath(const char * val){ m_SourceFilePath.set(val); }
void CDFUWorkunit::setSourceDali(const char * val){ m_SourceDali.set(val); }
void CDFUWorkunit::setSourceRecordSize_null(){ m_SourceRecordSize.Nil(); }void CDFUWorkunit::setSourceRecordSize(int val){ m_SourceRecordSize=val; }
void CDFUWorkunit::setSourceFormat_null(){ m_SourceFormat.Nil(); }void CDFUWorkunit::setSourceFormat(int val){ m_SourceFormat=val; }
void CDFUWorkunit::setRowTag(const char * val){ m_RowTag.set(val); }
void CDFUWorkunit::setSourceNumParts_null(){ m_SourceNumParts.Nil(); }void CDFUWorkunit::setSourceNumParts(int val){ m_SourceNumParts=val; }
void CDFUWorkunit::setSourceDirectory(const char * val){ m_SourceDirectory.set(val); }
void CDFUWorkunit::setDestLogicalName(const char * val){ m_DestLogicalName.set(val); }
void CDFUWorkunit::setDestGroupName(const char * val){ m_DestGroupName.set(val); }
void CDFUWorkunit::setDestDirectory(const char * val){ m_DestDirectory.set(val); }
void CDFUWorkunit::setDestIP(const char * val){ m_DestIP.set(val); }
void CDFUWorkunit::setDestFilePath(const char * val){ m_DestFilePath.set(val); }
void CDFUWorkunit::setDestFormat_null(){ m_DestFormat.Nil(); }void CDFUWorkunit::setDestFormat(int val){ m_DestFormat=val; }
void CDFUWorkunit::setDestNumParts_null(){ m_DestNumParts.Nil(); }void CDFUWorkunit::setDestNumParts(int val){ m_DestNumParts=val; }
void CDFUWorkunit::setDestRecordSize_null(){ m_DestRecordSize.Nil(); }void CDFUWorkunit::setDestRecordSize(int val){ m_DestRecordSize=val; }
void CDFUWorkunit::setReplicate_null(){ m_Replicate.Nil(); }void CDFUWorkunit::setReplicate(bool val){ m_Replicate=val; }
void CDFUWorkunit::setOverwrite_null(){ m_Overwrite.Nil(); }void CDFUWorkunit::setOverwrite(bool val){ m_Overwrite=val; }
void CDFUWorkunit::setCompress_null(){ m_Compress.Nil(); }void CDFUWorkunit::setCompress(bool val){ m_Compress=val; }
void CDFUWorkunit::setSourceCsvSeparate(const char * val){ m_SourceCsvSeparate.set(val); }
void CDFUWorkunit::setSourceCsvQuote(const char * val){ m_SourceCsvQuote.set(val); }
void CDFUWorkunit::setSourceCsvTerminate(const char * val){ m_SourceCsvTerminate.set(val); }
void CDFUWorkunit::setSourceCsvEscape(const char * val){ m_SourceCsvEscape.set(val); }
void CDFUWorkunit::setTimeStarted(const char * val){ m_TimeStarted.set(val); }
void CDFUWorkunit::setTimeStopped(const char * val){ m_TimeStopped.set(val); }
void CDFUWorkunit::setStateMessage(const char * val){ m_StateMessage.set(val); }
void CDFUWorkunit::setMonitorEventName(const char * val){ m_MonitorEventName.set(val); }
void CDFUWorkunit::setMonitorSub_null(){ m_MonitorSub.Nil(); }void CDFUWorkunit::setMonitorSub(bool val){ m_MonitorSub=val; }
void CDFUWorkunit::setMonitorShotLimit_null(){ m_MonitorShotLimit.Nil(); }void CDFUWorkunit::setMonitorShotLimit(int val){ m_MonitorShotLimit=val; }
void CDFUWorkunit::setSourceDiffKeyName(const char * val){ m_SourceDiffKeyName.set(val); }
void CDFUWorkunit::setDestDiffKeyName(const char * val){ m_DestDiffKeyName.set(val); }
void CDFUWorkunit::setArchived_null(){ m_Archived.Nil(); }void CDFUWorkunit::setArchived(bool val){ m_Archived=val; }
void CDFUWorkunit::setEncrypt(const char * val){ m_encrypt.set(val); }
void CDFUWorkunit::setDecrypt(const char * val){ m_decrypt.set(val); }
void CDFUWorkunit::setFailIfNoSourceFile_null(){ m_failIfNoSourceFile.Nil(); }void CDFUWorkunit::setFailIfNoSourceFile(bool val){ m_failIfNoSourceFile=val; }
void CDFUWorkunit::setRecordStructurePresent_null(){ m_recordStructurePresent.Nil(); }void CDFUWorkunit::setRecordStructurePresent(bool val){ m_recordStructurePresent=val; }
void CDFUWorkunit::setQuotedTerminator_null(){ m_quotedTerminator.Nil(); }void CDFUWorkunit::setQuotedTerminator(bool val){ m_quotedTerminator=val; }
void CDFUWorkunit::setPreserveCompression_null(){ m_preserveCompression.Nil(); }void CDFUWorkunit::setPreserveCompression(bool val){ m_preserveCompression=val; }
void CDFUWorkunit::setExpireDays_null(){ m_expireDays.Nil(); }void CDFUWorkunit::setExpireDays(int val){ m_expireDays=val; }
extern "C"  IEspDFUWorkunit *createDFUWorkunit(const char *serv, const char *msgname){return ((IEspDFUWorkunit *)new CDFUWorkunit(serv /*, msgname*/));}
extern "C"  IClientDFUWorkunit *createClientDFUWorkunit(const char *serv, const char *msgname){return ((IClientDFUWorkunit *)new CDFUWorkunit(serv /*, msgname*/));}

//=======================================================
// class CGroupNode Implementation
//=======================================================

CGroupNode::CGroupNode(const char *serviceName, IRpcMessageBinding *init)
	: m_Name(nilRemove),m_ClusterType(nilRemove),m_ReplicateOutputs(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GroupNode");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CGroupNode::CGroupNode(const char *serviceName, const char *bc)
	: m_Name(nilRemove),m_ClusterType(nilRemove),m_ReplicateOutputs(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GroupNode");
}

StringBuffer &CGroupNode::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:complexType name=\"%s\">\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Name\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"ClusterType\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"ReplicateOutputs\" type=\"xsd:boolean\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType>\n");
		}
	}
	return schema;
}

void CGroupNode::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CGroupNode::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CGroupNode::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Name");
	form.appendf("  <tr><td><b>Name: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("ClusterType");
	form.appendf("  <tr><td><b>ClusterType: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("ReplicateOutputs");
	
	form.appendf("  <tr><td><b>ReplicateOutputs? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CGroupNode::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CGroupNode::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_Name.marshall(rpc_resp, "Name", "", "", "");
	m_ClusterType.marshall(rpc_resp, "ClusterType", "", "", "");
	m_ReplicateOutputs.marshall(rpc_resp, "ReplicateOutputs", "", "", "");
}


void CGroupNode::copy(CGroupNode &from)
{
	m_Name.copy(from.m_Name);
	m_ClusterType.copy(from.m_ClusterType);
	m_ReplicateOutputs.copy(from.m_ReplicateOutputs);
}


void CGroupNode::copy(IConstGroupNode &ifrom)
{
	setName(ifrom.getName());
	setClusterType(ifrom.getClusterType());
	setReplicateOutputs(ifrom.getReplicateOutputs());
}


void CGroupNode::getAttributes(IProperties &attributes)
{
}


void CGroupNode::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_Name.toStr(ctx, buffer, "Name", "", true, "", "");
	m_ClusterType.toStr(ctx, buffer, "ClusterType", "", true, "", "");
	m_ReplicateOutputs.toStr(ctx, buffer, "ReplicateOutputs", "", true, "", "");
}


void CGroupNode::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CGroupNode::serializer(IEspContext* ctx, IConstGroupNode &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<GroupNode>");
	// field Name
	{
		const char* s = src.getName();
		if (s && *s)
		{
			buffer.append("<Name>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Name>");
		}
	}
	// field ClusterType
	{
		const char* s = src.getClusterType();
		if (s && *s)
		{
			buffer.append("<ClusterType>");
			encodeUtf8XML(s,buffer);
			buffer.append("</ClusterType>");
		}
	}
	// field ReplicateOutputs
	{
		bool b = src.getReplicateOutputs();
		if (b)
			buffer.appendf("<ReplicateOutputs>1</ReplicateOutputs>");
	}
	if (keepRootTag)
		buffer.append("</GroupNode>");
}

bool CGroupNode::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_Name.unmarshall(rpc_request, "Name", basepath);
	hasValue |= m_ClusterType.unmarshall(rpc_request, "ClusterType", basepath);
	hasValue |= m_ReplicateOutputs.unmarshall(rpc_request, "ReplicateOutputs", basepath);
	return hasValue;
}

bool CGroupNode::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Name.unmarshall(ctx, soapval, "Name");
	hasValue |= m_ClusterType.unmarshall(ctx, soapval, "ClusterType");
	hasValue |= m_ReplicateOutputs.unmarshall(ctx, soapval, "ReplicateOutputs");
	return hasValue;
}

bool CGroupNode::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Name.unmarshall(ctx, params, attachments, "Name", basepath);
	hasValue |= m_ClusterType.unmarshall(ctx, params, attachments, "ClusterType", basepath);
	hasValue |= m_ReplicateOutputs.unmarshall(ctx, params, attachments, "ReplicateOutputs", basepath);
	return hasValue;
}

const char * CGroupNode::getName() { return m_Name.query();}
const char * CGroupNode::getClusterType() { return m_ClusterType.query();}
bool CGroupNode::getReplicateOutputs_isNull(){return m_ReplicateOutputs.is_nil();}
bool CGroupNode::getReplicateOutputs() { return m_ReplicateOutputs;}
void CGroupNode::setName(const char * val){ m_Name.set(val); }
void CGroupNode::setClusterType(const char * val){ m_ClusterType.set(val); }
void CGroupNode::setReplicateOutputs_null(){ m_ReplicateOutputs.Nil(); }void CGroupNode::setReplicateOutputs(bool val){ m_ReplicateOutputs=val; }
extern "C"  IEspGroupNode *createGroupNode(const char *serv, const char *msgname){return ((IEspGroupNode *)new CGroupNode(serv /*, msgname*/));}
extern "C"  IClientGroupNode *createClientGroupNode(const char *serv, const char *msgname){return ((IClientGroupNode *)new CGroupNode(serv /*, msgname*/));}

//=======================================================
// class CDFUException Implementation
//=======================================================

CDFUException::CDFUException(const char *serviceName, IRpcMessageBinding *init)
	: m_Code(nilIgnore),m_Message(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("DFUException");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CDFUException::CDFUException(const char *serviceName, const char *bc)
	: m_Code(nilIgnore),m_Message(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("DFUException");
}

StringBuffer &CDFUException::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:complexType name=\"%s\">\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Code\" type=\"xsd:int\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Message\" type=\"xsd:string\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType>\n");
		}
	}
	return schema;
}

void CDFUException::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CDFUException::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CDFUException::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix) extfix.append(prefix).append(".");
		extfix.append("Code");
	form.appendf("  <tr><td><b>Code: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Message");
	form.appendf("  <tr><td><b>Message: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CDFUException::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CDFUException::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_Code.marshall(rpc_resp, "Code", "", "", "");
	m_Message.marshall(rpc_resp, "Message", "", "", "");
}


void CDFUException::copy(CDFUException &from)
{
	m_Code.copy(from.m_Code);
	m_Message.copy(from.m_Message);
}


void CDFUException::copy(IConstDFUException &ifrom)
{
	setCode(ifrom.getCode());
	setMessage(ifrom.getMessage());
}


void CDFUException::getAttributes(IProperties &attributes)
{
}


void CDFUException::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_Code.toStr(ctx, buffer, "Code", "", true, "", "");
	m_Message.toStr(ctx, buffer, "Message", "", true, "", "");
}


void CDFUException::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CDFUException::serializer(IEspContext* ctx, IConstDFUException &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<DFUException>");
	// field Code
	{
		int n = src.getCode();
		if (n)
			buffer.appendf("<Code>%d</Code>", n);
	}
	// field Message
	{
		const char* s = src.getMessage();
		if (s && *s)
		{
			buffer.append("<Message>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Message>");
		}
	}
	if (keepRootTag)
		buffer.append("</DFUException>");
}

bool CDFUException::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_Code.unmarshall(rpc_request, "Code", basepath);
	hasValue |= m_Message.unmarshall(rpc_request, "Message", basepath);
	return hasValue;
}

bool CDFUException::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Code.unmarshall(ctx, soapval, "Code");
	hasValue |= m_Message.unmarshall(ctx, soapval, "Message");
	return hasValue;
}

bool CDFUException::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Code.unmarshall(ctx, params, attachments, "Code", basepath);
	hasValue |= m_Message.unmarshall(ctx, params, attachments, "Message", basepath);
	return hasValue;
}

int CDFUException::getCode() { return m_Code;}
const char * CDFUException::getMessage() { return m_Message.query();}
void CDFUException::setCode(int val){ m_Code=val; }
void CDFUException::setMessage(const char * val){ m_Message.set(val); }
extern "C"  IEspDFUException *createDFUException(const char *serv, const char *msgname){return ((IEspDFUException *)new CDFUException(serv /*, msgname*/));}
extern "C"  IClientDFUException *createClientDFUException(const char *serv, const char *msgname){return ((IClientDFUException *)new CDFUException(serv /*, msgname*/));}

//=======================================================
// class CDFUActionResult Implementation
//=======================================================

CDFUActionResult::CDFUActionResult(const char *serviceName, IRpcMessageBinding *init)
	: m_ID(nilRemove),m_Action(nilRemove),m_Result(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("DFUActionResult");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CDFUActionResult::CDFUActionResult(const char *serviceName, const char *bc)
	: m_ID(nilRemove),m_Action(nilRemove),m_Result(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("DFUActionResult");
}

StringBuffer &CDFUActionResult::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:complexType name=\"%s\">\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"ID\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Action\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Result\" type=\"xsd:string\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType>\n");
		}
	}
	return schema;
}

void CDFUActionResult::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CDFUActionResult::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CDFUActionResult::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("ID");
	form.appendf("  <tr><td><b>ID: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Action");
	form.appendf("  <tr><td><b>Action: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Result");
	form.appendf("  <tr><td><b>Result: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CDFUActionResult::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CDFUActionResult::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_ID.marshall(rpc_resp, "ID", "", "", "");
	m_Action.marshall(rpc_resp, "Action", "", "", "");
	m_Result.marshall(rpc_resp, "Result", "", "", "");
}


void CDFUActionResult::copy(CDFUActionResult &from)
{
	m_ID.copy(from.m_ID);
	m_Action.copy(from.m_Action);
	m_Result.copy(from.m_Result);
}


void CDFUActionResult::copy(IConstDFUActionResult &ifrom)
{
	setID(ifrom.getID());
	setAction(ifrom.getAction());
	setResult(ifrom.getResult());
}


void CDFUActionResult::getAttributes(IProperties &attributes)
{
}


void CDFUActionResult::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_ID.toStr(ctx, buffer, "ID", "", true, "", "");
	m_Action.toStr(ctx, buffer, "Action", "", true, "", "");
	m_Result.toStr(ctx, buffer, "Result", "", true, "", "");
}


void CDFUActionResult::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CDFUActionResult::serializer(IEspContext* ctx, IConstDFUActionResult &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<DFUActionResult>");
	// field ID
	{
		const char* s = src.getID();
		if (s && *s)
		{
			buffer.append("<ID>");
			encodeUtf8XML(s,buffer);
			buffer.append("</ID>");
		}
	}
	// field Action
	{
		const char* s = src.getAction();
		if (s && *s)
		{
			buffer.append("<Action>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Action>");
		}
	}
	// field Result
	{
		const char* s = src.getResult();
		if (s && *s)
		{
			buffer.append("<Result>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Result>");
		}
	}
	if (keepRootTag)
		buffer.append("</DFUActionResult>");
}

bool CDFUActionResult::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_ID.unmarshall(rpc_request, "ID", basepath);
	hasValue |= m_Action.unmarshall(rpc_request, "Action", basepath);
	hasValue |= m_Result.unmarshall(rpc_request, "Result", basepath);
	return hasValue;
}

bool CDFUActionResult::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_ID.unmarshall(ctx, soapval, "ID");
	hasValue |= m_Action.unmarshall(ctx, soapval, "Action");
	hasValue |= m_Result.unmarshall(ctx, soapval, "Result");
	return hasValue;
}

bool CDFUActionResult::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_ID.unmarshall(ctx, params, attachments, "ID", basepath);
	hasValue |= m_Action.unmarshall(ctx, params, attachments, "Action", basepath);
	hasValue |= m_Result.unmarshall(ctx, params, attachments, "Result", basepath);
	return hasValue;
}

const char * CDFUActionResult::getID() { return m_ID.query();}
const char * CDFUActionResult::getAction() { return m_Action.query();}
const char * CDFUActionResult::getResult() { return m_Result.query();}
void CDFUActionResult::setID(const char * val){ m_ID.set(val); }
void CDFUActionResult::setAction(const char * val){ m_Action.set(val); }
void CDFUActionResult::setResult(const char * val){ m_Result.set(val); }
extern "C"  IEspDFUActionResult *createDFUActionResult(const char *serv, const char *msgname){return ((IEspDFUActionResult *)new CDFUActionResult(serv /*, msgname*/));}
extern "C"  IClientDFUActionResult *createClientDFUActionResult(const char *serv, const char *msgname){return ((IClientDFUActionResult *)new CDFUActionResult(serv /*, msgname*/));}

//=======================================================
// class CDFUWUSearchRequest Implementation
//=======================================================

CDFUWUSearchRequest::CDFUWUSearchRequest(const char *serviceName, IRpcMessageBinding *init)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("DFUWUSearchRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CDFUWUSearchRequest::CDFUWUSearchRequest(const char *serviceName, const char *bc)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("DFUWUSearchRequest");
}

CDFUWUSearchRequest::CDFUWUSearchRequest(const char *serviceName, IRpcMessage* rpcmsg)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("DFUWUSearchRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CDFUWUSearchRequest::CDFUWUSearchRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("DFUWUSearchRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CDFUWUSearchRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType><xsd:all/></xsd:complexType></xsd:element>\n", msgTypeName);
		}
	}
	return schema;
}

void CDFUWUSearchRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CDFUWUSearchRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CDFUWUSearchRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CDFUWUSearchRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CDFUWUSearchRequest::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

}


void CDFUWUSearchRequest::copy(CDFUWUSearchRequest &from)
{
}


void CDFUWUSearchRequest::copy(IConstDFUWUSearchRequest &ifrom)
{
}


void CDFUWUSearchRequest::getAttributes(IProperties &attributes)
{
}


void CDFUWUSearchRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
}


void CDFUWUSearchRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CDFUWUSearchRequest::serializer(IEspContext* ctx, IConstDFUWUSearchRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<DFUWUSearchRequest>");
	if (keepRootTag)
		buffer.append("</DFUWUSearchRequest>");
}

bool CDFUWUSearchRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	return hasValue;
}

bool CDFUWUSearchRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	return hasValue;
}

bool CDFUWUSearchRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	return hasValue;
}

extern "C"  IEspDFUWUSearchRequest *createDFUWUSearchRequest(const char *serv){return ((IEspDFUWUSearchRequest *)new CDFUWUSearchRequest(serv));}
extern "C"  IClientDFUWUSearchRequest *createClientDFUWUSearchRequest(const char *serv){return ((IClientDFUWUSearchRequest *)new CDFUWUSearchRequest(serv));}

//=======================================================
// class CDFUWUSearchResponse Implementation
//=======================================================

CDFUWUSearchResponse::CDFUWUSearchResponse(const char *serviceName, IRpcMessageBinding *init)
	: m_ClusterNames(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("DFUWUSearchResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CDFUWUSearchResponse::CDFUWUSearchResponse(const char *serviceName, const char *bc)
	: m_ClusterNames(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("DFUWUSearchResponse");
}

CDFUWUSearchResponse::CDFUWUSearchResponse(const char *serviceName, IRpcMessage* rpcmsg)
	: m_ClusterNames(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("DFUWUSearchResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CDFUWUSearchResponse::CDFUWUSearchResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_ClusterNames(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("DFUWUSearchResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CDFUWUSearchResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		schema.append("<xsd:element name=\"Exceptions\" type=\"tns:ArrayOfEspException\" minOccurs=\"0\" maxOccurs=\"1\"/>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"ClusterNames\">");
		schema.append("<xsd:complexType><xsd:sequence>");
		schema.append("<xsd:element name=\"ClusterName\" type=\"xsd:string\" minOccurs=\"0\" maxOccurs=\"unbounded\"/>\n");
		schema.append("</xsd:sequence></xsd:complexType>\n");
		schema.append("</xsd:element>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CDFUWUSearchResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CDFUWUSearchResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CDFUWUSearchResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("ClusterNames");
	form.appendf("<tr><td><b>ClusterNames: </b></td><td>");
	form.appendf("<textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea>", extfix.str());
	form.append("</td></tr>");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CDFUWUSearchResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CDFUWUSearchResponse::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
		m_ClusterNames.marshall(rpc_resp, "ClusterNames", "ClusterName");
	}
}


void CDFUWUSearchResponse::copy(CDFUWUSearchResponse &from)
{
	m_ClusterNames.copy(from.m_ClusterNames);
}


void CDFUWUSearchResponse::copy(IConstDFUWUSearchResponse &ifrom)
{
	setClusterNames(ifrom.getClusterNames());
}


void CDFUWUSearchResponse::getAttributes(IProperties &attributes)
{
}


void CDFUWUSearchResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
		m_ClusterNames.toStr(ctx, buffer, "ClusterNames", "ClusterName");
	}
}


void CDFUWUSearchResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CDFUWUSearchResponse::serializer(IEspContext* ctx, IConstDFUWUSearchResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<DFUWUSearchResponse>");
	// field ClusterNames
	{
		StringArray& v = src.getClusterNames();
		if (v.length()>0)
			buffer.append("<ClusterNames>");
		for (size32_t i=0;i<v.length();i++)
			buffer.appendf("<ClusterName>%s</ClusterName>",v.item(i));
		if (v.length()>0)
			buffer.append("</ClusterNames>");
	}
	if (keepRootTag)
		buffer.append("</DFUWUSearchResponse>");
}

bool CDFUWUSearchResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
		hasValue |= m_ClusterNames.unmarshall(rpc_request, "ClusterNames", basepath);
	}
	return hasValue;
}

bool CDFUWUSearchResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_ClusterNames.unmarshall(ctx, soapval, "ClusterNames");
	return hasValue;
}

bool CDFUWUSearchResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_ClusterNames.unmarshall(ctx, params, attachments, "ClusterNames", basepath);
	return hasValue;
}

StringArray & CDFUWUSearchResponse::getClusterNames() { return (StringArray &) m_ClusterNames; }
void CDFUWUSearchResponse::setClusterNames(StringArray &val){ m_ClusterNames->kill();  CloneArray(m_ClusterNames.getValue(), val); }
extern "C"  IEspDFUWUSearchResponse *createDFUWUSearchResponse(const char *serv){return ((IEspDFUWUSearchResponse *)new CDFUWUSearchResponse(serv));}
extern "C"  IClientDFUWUSearchResponse *createClientDFUWUSearchResponse(const char *serv){return ((IClientDFUWUSearchResponse *)new CDFUWUSearchResponse(serv));}

//=======================================================
// class CGetDFUWorkunits Implementation
//=======================================================

CGetDFUWorkunits::CGetDFUWorkunits(const char *serviceName, IRpcMessageBinding *init)
	: m_Wuid(nilIgnore),m_Owner(nilIgnore),m_Cluster(nilIgnore),m_StateReq(nilIgnore),m_Type(nilIgnore),m_Jobname(nilIgnore),m_PageSize(nilIgnore),m_CurrentPage(nilIgnore),m_PageStartFrom(-1, nilIgnore,false),m_Sortby(nilIgnore),m_Descending(0, nilIgnore,false),m_CacheHint(-1, nilIgnore,false)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetDFUWorkunits");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CGetDFUWorkunits::CGetDFUWorkunits(const char *serviceName, const char *bc)
	: m_Wuid(nilIgnore),m_Owner(nilIgnore),m_Cluster(nilIgnore),m_StateReq(nilIgnore),m_Type(nilIgnore),m_Jobname(nilIgnore),m_PageSize(nilIgnore),m_CurrentPage(nilIgnore),m_PageStartFrom(-1, nilIgnore,false),m_Sortby(nilIgnore),m_Descending(0, nilIgnore,false),m_CacheHint(-1, nilIgnore,false)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetDFUWorkunits");
}

CGetDFUWorkunits::CGetDFUWorkunits(const char *serviceName, IRpcMessage* rpcmsg)
	: m_Wuid(nilIgnore),m_Owner(nilIgnore),m_Cluster(nilIgnore),m_StateReq(nilIgnore),m_Type(nilIgnore),m_Jobname(nilIgnore),m_PageSize(nilIgnore),m_CurrentPage(nilIgnore),m_PageStartFrom(-1, nilIgnore,false),m_Sortby(nilIgnore),m_Descending(0, nilIgnore,false),m_CacheHint(-1, nilIgnore,false)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetDFUWorkunits");
	unserialize(*rpcmsg,NULL,NULL);
}

CGetDFUWorkunits::CGetDFUWorkunits(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_Wuid(nilIgnore),m_Owner(nilIgnore),m_Cluster(nilIgnore),m_StateReq(nilIgnore),m_Type(nilIgnore),m_Jobname(nilIgnore),m_PageSize(nilIgnore),m_CurrentPage(nilIgnore),m_PageStartFrom(-1, nilIgnore,false),m_Sortby(nilIgnore),m_Descending(0, nilIgnore,false),m_CacheHint(-1, nilIgnore,false)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetDFUWorkunits");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CGetDFUWorkunits::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		if (!context.suppressed("GetDFUWorkunits","Wuid")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"Wuid\" type=\"xsd:string\"/>\n");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Owner\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Cluster\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"StateReq\" type=\"xsd:string\"/>\n");
		if (!context.suppressed("GetDFUWorkunits","Type")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"Type\" type=\"xsd:string\"/>\n");
		}
		if (!context.suppressed("GetDFUWorkunits","Jobname")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"Jobname\" type=\"xsd:string\"/>\n");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"PageSize\" type=\"xsd:long\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"CurrentPage\" type=\"xsd:int\"/>\n");
		if (!context.suppressed("GetDFUWorkunits","PageStartFrom")) {
			schema.append("<xsd:element minOccurs=\"0\" default=\"-1\" name=\"PageStartFrom\" type=\"xsd:long\"/>\n");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Sortby\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" default=\"false\" name=\"Descending\" type=\"xsd:boolean\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" default=\"-1\" name=\"CacheHint\" type=\"xsd:long\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CGetDFUWorkunits::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CGetDFUWorkunits::getMapInfo(IMapInfo& info, BoolHash& added)
{
	info.addMinVersion("GetDFUWorkunits","Wuid",1.12);
	info.addMinVersion("GetDFUWorkunits","Type",1.03);
	info.addMinVersion("GetDFUWorkunits","Jobname",1.03);
	info.addMinVersion("GetDFUWorkunits","PageStartFrom",1.01);
}

StringBuffer &CGetDFUWorkunits::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	if (!context.suppressed("GetDFUWorkunits","Wuid")) {
		extfix.clear();
		if (prefix && *prefix)
			extfix.append(prefix).append(".");
		extfix.append("Wuid");
		form.appendf("  <tr><td><b>Wuid: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
		form.append("</td></tr>\n");
	}
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Owner");
	form.appendf("  <tr><td><b>Owner: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Cluster");
	form.appendf("  <tr><td><b>Cluster: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("StateReq");
	form.appendf("  <tr><td><b>StateReq: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (!context.suppressed("GetDFUWorkunits","Type")) {
		extfix.clear();
		if (prefix && *prefix)
			extfix.append(prefix).append(".");
		extfix.append("Type");
		form.appendf("  <tr><td><b>Type: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
		form.append("</td></tr>\n");
	}
	if (!context.suppressed("GetDFUWorkunits","Jobname")) {
		extfix.clear();
		if (prefix && *prefix)
			extfix.append(prefix).append(".");
		extfix.append("Jobname");
		form.appendf("  <tr><td><b>Jobname: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
		form.append("</td></tr>\n");
	}
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("PageSize");
	form.appendf("  <tr><td><b>PageSize: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix) extfix.append(prefix).append(".");
		extfix.append("CurrentPage");
	form.appendf("  <tr><td><b>CurrentPage: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
	form.append("</td></tr>\n");
	if (!context.suppressed("GetDFUWorkunits","PageStartFrom")) {
		extfix.clear();
		if (prefix && *prefix)
			extfix.append(prefix).append(".");
		extfix.append("PageStartFrom");
		form.appendf("  <tr><td><b>PageStartFrom: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
		form.append("</td></tr>\n");
	}
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Sortby");
	form.appendf("  <tr><td><b>Sortby: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Descending");
	
	form.appendf("  <tr><td><b>Descending? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("CacheHint");
	form.appendf("  <tr><td><b>CacheHint: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CGetDFUWorkunits::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CGetDFUWorkunits::serialize(IRpcMessage& rpc_resp)
{
	IEspContext* ctx = rpc_resp.queryContext();
	double clientVer= ctx ? ctx->getClientVersion() : -1; /* no context gets everything */
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	if ((clientVer==-1.0 || clientVer>=1.12))
		m_Wuid.marshall(rpc_resp, "Wuid", "", "", "");
	m_Owner.marshall(rpc_resp, "Owner", "", "", "");
	m_Cluster.marshall(rpc_resp, "Cluster", "", "", "");
	m_StateReq.marshall(rpc_resp, "StateReq", "", "", "");
	if ((clientVer==-1.0 || clientVer>=1.03))
		m_Type.marshall(rpc_resp, "Type", "", "", "");
	if ((clientVer==-1.0 || clientVer>=1.03))
		m_Jobname.marshall(rpc_resp, "Jobname", "", "", "");
	m_PageSize.marshall(rpc_resp, "PageSize", "", "", "");
	m_CurrentPage.marshall(rpc_resp, "CurrentPage", "", "", "");
	if ((clientVer==-1.0 || clientVer>=1.01))
		m_PageStartFrom.marshall(rpc_resp, "PageStartFrom", "", "", "");
	m_Sortby.marshall(rpc_resp, "Sortby", "", "", "");
	m_Descending.marshall(rpc_resp, "Descending", "", "", "");
	m_CacheHint.marshall(rpc_resp, "CacheHint", "", "", "");
}


void CGetDFUWorkunits::copy(CGetDFUWorkunits &from)
{
	m_Wuid.copy(from.m_Wuid);
	m_Owner.copy(from.m_Owner);
	m_Cluster.copy(from.m_Cluster);
	m_StateReq.copy(from.m_StateReq);
	m_Type.copy(from.m_Type);
	m_Jobname.copy(from.m_Jobname);
	m_PageSize.copy(from.m_PageSize);
	m_CurrentPage.copy(from.m_CurrentPage);
	m_PageStartFrom.copy(from.m_PageStartFrom);
	m_Sortby.copy(from.m_Sortby);
	m_Descending.copy(from.m_Descending);
	m_CacheHint.copy(from.m_CacheHint);
}


void CGetDFUWorkunits::copy(IConstGetDFUWorkunits &ifrom)
{
	setWuid(ifrom.getWuid());
	setOwner(ifrom.getOwner());
	setCluster(ifrom.getCluster());
	setStateReq(ifrom.getStateReq());
	setType(ifrom.getType());
	setJobname(ifrom.getJobname());
	setPageSize(ifrom.getPageSize());
	setCurrentPage(ifrom.getCurrentPage());
	setPageStartFrom(ifrom.getPageStartFrom());
	setSortby(ifrom.getSortby());
	setDescending(ifrom.getDescending());
	setCacheHint(ifrom.getCacheHint());
}


void CGetDFUWorkunits::getAttributes(IProperties &attributes)
{
}


void CGetDFUWorkunits::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	double clientVer = ctx ? ctx->getClientVersion() : -1;
	if ((clientVer==-1.0 || clientVer>=1.12))
		m_Wuid.toStr(ctx, buffer, "Wuid", "", true, "", "");
	m_Owner.toStr(ctx, buffer, "Owner", "", true, "", "");
	m_Cluster.toStr(ctx, buffer, "Cluster", "", true, "", "");
	m_StateReq.toStr(ctx, buffer, "StateReq", "", true, "", "");
	if ((clientVer==-1.0 || clientVer>=1.03))
		m_Type.toStr(ctx, buffer, "Type", "", true, "", "");
	if ((clientVer==-1.0 || clientVer>=1.03))
		m_Jobname.toStr(ctx, buffer, "Jobname", "", true, "", "");
	m_PageSize.toStr(ctx, buffer, "PageSize", "", true, "", "");
	m_CurrentPage.toStr(ctx, buffer, "CurrentPage", "", true, "", "");
	if ((clientVer==-1.0 || clientVer>=1.01))
		m_PageStartFrom.toStr(ctx, buffer, "PageStartFrom", "", true, "", "");
	m_Sortby.toStr(ctx, buffer, "Sortby", "", true, "", "");
	m_Descending.toStr(ctx, buffer, "Descending", "", true, "", "");
	m_CacheHint.toStr(ctx, buffer, "CacheHint", "", true, "", "");
}


void CGetDFUWorkunits::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CGetDFUWorkunits::serializer(IEspContext* ctx, IConstGetDFUWorkunits &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<GetDFUWorkunits>");
	double clientVer = ctx ? ctx->getClientVersion() : -1;
	// field Wuid
	if ((clientVer==-1.0 || clientVer>=1.12))
	{
		const char* s = src.getWuid();
		if (s && *s)
		{
			buffer.append("<Wuid>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Wuid>");
		}
	}
	// field Owner
	{
		const char* s = src.getOwner();
		if (s && *s)
		{
			buffer.append("<Owner>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Owner>");
		}
	}
	// field Cluster
	{
		const char* s = src.getCluster();
		if (s && *s)
		{
			buffer.append("<Cluster>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Cluster>");
		}
	}
	// field StateReq
	{
		const char* s = src.getStateReq();
		if (s && *s)
		{
			buffer.append("<StateReq>");
			encodeUtf8XML(s,buffer);
			buffer.append("</StateReq>");
		}
	}
	// field Type
	if ((clientVer==-1.0 || clientVer>=1.03))
	{
		const char* s = src.getType();
		if (s && *s)
		{
			buffer.append("<Type>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Type>");
		}
	}
	// field Jobname
	if ((clientVer==-1.0 || clientVer>=1.03))
	{
		const char* s = src.getJobname();
		if (s && *s)
		{
			buffer.append("<Jobname>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Jobname>");
		}
	}
	// field PageSize
	{
		//*** default kind: TK_INT; type=int64, name=PageSize
		buffer.append("<PageSize>");
		buffer.append(src.getPageSize());
		buffer.append("</PageSize>");
	}
	// field CurrentPage
	{
		int n = src.getCurrentPage();
		if (n)
			buffer.appendf("<CurrentPage>%d</CurrentPage>", n);
	}
	// field PageStartFrom
	if ((clientVer==-1.0 || clientVer>=1.01))
	{
		//*** default kind: TK_INT; type=int64, name=PageStartFrom
		buffer.append("<PageStartFrom>");
		buffer.append(src.getPageStartFrom());
		buffer.append("</PageStartFrom>");
	}
	// field Sortby
	{
		const char* s = src.getSortby();
		if (s && *s)
		{
			buffer.append("<Sortby>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Sortby>");
		}
	}
	// field Descending
	{
		bool b = src.getDescending();
		if (b)
			buffer.appendf("<Descending>1</Descending>");
	}
	// field CacheHint
	{
		//*** default kind: TK_INT; type=int64, name=CacheHint
		buffer.append("<CacheHint>");
		buffer.append(src.getCacheHint());
		buffer.append("</CacheHint>");
	}
	if (keepRootTag)
		buffer.append("</GetDFUWorkunits>");
}

bool CGetDFUWorkunits::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_Wuid.unmarshall(rpc_request, "Wuid", basepath);
	hasValue |= m_Owner.unmarshall(rpc_request, "Owner", basepath);
	hasValue |= m_Cluster.unmarshall(rpc_request, "Cluster", basepath);
	hasValue |= m_StateReq.unmarshall(rpc_request, "StateReq", basepath);
	hasValue |= m_Type.unmarshall(rpc_request, "Type", basepath);
	hasValue |= m_Jobname.unmarshall(rpc_request, "Jobname", basepath);
	hasValue |= m_PageSize.unmarshall(rpc_request, "PageSize", basepath);
	hasValue |= m_CurrentPage.unmarshall(rpc_request, "CurrentPage", basepath);
	hasValue |= m_PageStartFrom.unmarshall(rpc_request, "PageStartFrom", basepath);
	hasValue |= m_Sortby.unmarshall(rpc_request, "Sortby", basepath);
	hasValue |= m_Descending.unmarshall(rpc_request, "Descending", basepath);
	hasValue |= m_CacheHint.unmarshall(rpc_request, "CacheHint", basepath);
	return hasValue;
}

bool CGetDFUWorkunits::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Wuid.unmarshall(ctx, soapval, "Wuid");
	hasValue |= m_Owner.unmarshall(ctx, soapval, "Owner");
	hasValue |= m_Cluster.unmarshall(ctx, soapval, "Cluster");
	hasValue |= m_StateReq.unmarshall(ctx, soapval, "StateReq");
	hasValue |= m_Type.unmarshall(ctx, soapval, "Type");
	hasValue |= m_Jobname.unmarshall(ctx, soapval, "Jobname");
	hasValue |= m_PageSize.unmarshall(ctx, soapval, "PageSize");
	hasValue |= m_CurrentPage.unmarshall(ctx, soapval, "CurrentPage");
	hasValue |= m_PageStartFrom.unmarshall(ctx, soapval, "PageStartFrom");
	hasValue |= m_Sortby.unmarshall(ctx, soapval, "Sortby");
	hasValue |= m_Descending.unmarshall(ctx, soapval, "Descending");
	hasValue |= m_CacheHint.unmarshall(ctx, soapval, "CacheHint");
	return hasValue;
}

bool CGetDFUWorkunits::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Wuid.unmarshall(ctx, params, attachments, "Wuid", basepath);
	hasValue |= m_Owner.unmarshall(ctx, params, attachments, "Owner", basepath);
	hasValue |= m_Cluster.unmarshall(ctx, params, attachments, "Cluster", basepath);
	hasValue |= m_StateReq.unmarshall(ctx, params, attachments, "StateReq", basepath);
	hasValue |= m_Type.unmarshall(ctx, params, attachments, "Type", basepath);
	hasValue |= m_Jobname.unmarshall(ctx, params, attachments, "Jobname", basepath);
	hasValue |= m_PageSize.unmarshall(ctx, params, attachments, "PageSize", basepath);
	hasValue |= m_CurrentPage.unmarshall(ctx, params, attachments, "CurrentPage", basepath);
	hasValue |= m_PageStartFrom.unmarshall(ctx, params, attachments, "PageStartFrom", basepath);
	hasValue |= m_Sortby.unmarshall(ctx, params, attachments, "Sortby", basepath);
	hasValue |= m_Descending.unmarshall(ctx, params, attachments, "Descending", basepath);
	hasValue |= m_CacheHint.unmarshall(ctx, params, attachments, "CacheHint", basepath);
	return hasValue;
}

const char * CGetDFUWorkunits::getWuid() { return m_Wuid.query();}
const char * CGetDFUWorkunits::getOwner() { return m_Owner.query();}
const char * CGetDFUWorkunits::getCluster() { return m_Cluster.query();}
const char * CGetDFUWorkunits::getStateReq() { return m_StateReq.query();}
const char * CGetDFUWorkunits::getType() { return m_Type.query();}
const char * CGetDFUWorkunits::getJobname() { return m_Jobname.query();}
__int64 CGetDFUWorkunits::getPageSize() { return m_PageSize;}
int CGetDFUWorkunits::getCurrentPage() { return m_CurrentPage;}
__int64 CGetDFUWorkunits::getPageStartFrom() { return m_PageStartFrom;}
const char * CGetDFUWorkunits::getSortby() { return m_Sortby.query();}
bool CGetDFUWorkunits::getDescending() { return m_Descending;}
__int64 CGetDFUWorkunits::getCacheHint() { return m_CacheHint;}
void CGetDFUWorkunits::setWuid(const char * val){ m_Wuid.set(val); }
void CGetDFUWorkunits::setOwner(const char * val){ m_Owner.set(val); }
void CGetDFUWorkunits::setCluster(const char * val){ m_Cluster.set(val); }
void CGetDFUWorkunits::setStateReq(const char * val){ m_StateReq.set(val); }
void CGetDFUWorkunits::setType(const char * val){ m_Type.set(val); }
void CGetDFUWorkunits::setJobname(const char * val){ m_Jobname.set(val); }
void CGetDFUWorkunits::setPageSize(__int64 val){ m_PageSize=val; }
void CGetDFUWorkunits::setCurrentPage(int val){ m_CurrentPage=val; }
void CGetDFUWorkunits::setPageStartFrom(__int64 val){ m_PageStartFrom=val; }
void CGetDFUWorkunits::setSortby(const char * val){ m_Sortby.set(val); }
void CGetDFUWorkunits::setDescending(bool val){ m_Descending=val; }
void CGetDFUWorkunits::setCacheHint(__int64 val){ m_CacheHint=val; }
extern "C"  IEspGetDFUWorkunits *createGetDFUWorkunits(const char *serv){return ((IEspGetDFUWorkunits *)new CGetDFUWorkunits(serv));}
extern "C"  IClientGetDFUWorkunits *createClientGetDFUWorkunits(const char *serv){return ((IClientGetDFUWorkunits *)new CGetDFUWorkunits(serv));}

//=======================================================
// class CGetDFUWorkunitsResponse Implementation
//=======================================================

CGetDFUWorkunitsResponse::CGetDFUWorkunitsResponse(const char *serviceName, IRpcMessageBinding *init)
	: m_results(nilIgnore),m_Type(nilIgnore),m_Owner(nilIgnore),m_Cluster(nilIgnore),m_StateReq(nilIgnore),m_PageSize(nilIgnore),m_PrevPage(nilIgnore),m_NextPage(nilIgnore),m_LastPage(-1, nilIgnore,false),m_NumWUs(nilIgnore),m_PageStartFrom(-1, nilIgnore,false),m_PageEndAt(nilIgnore),m_First(1, nilIgnore,false),m_Sortby(nilIgnore),m_Descending(0, nilIgnore,false),m_BasicQuery(nilIgnore),m_Filters(nilIgnore),m_CacheHint(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetDFUWorkunitsResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CGetDFUWorkunitsResponse::CGetDFUWorkunitsResponse(const char *serviceName, const char *bc)
	: m_results(nilIgnore),m_Type(nilIgnore),m_Owner(nilIgnore),m_Cluster(nilIgnore),m_StateReq(nilIgnore),m_PageSize(nilIgnore),m_PrevPage(nilIgnore),m_NextPage(nilIgnore),m_LastPage(-1, nilIgnore,false),m_NumWUs(nilIgnore),m_PageStartFrom(-1, nilIgnore,false),m_PageEndAt(nilIgnore),m_First(1, nilIgnore,false),m_Sortby(nilIgnore),m_Descending(0, nilIgnore,false),m_BasicQuery(nilIgnore),m_Filters(nilIgnore),m_CacheHint(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetDFUWorkunitsResponse");
}

CGetDFUWorkunitsResponse::CGetDFUWorkunitsResponse(const char *serviceName, IRpcMessage* rpcmsg)
	: m_results(nilIgnore),m_Type(nilIgnore),m_Owner(nilIgnore),m_Cluster(nilIgnore),m_StateReq(nilIgnore),m_PageSize(nilIgnore),m_PrevPage(nilIgnore),m_NextPage(nilIgnore),m_LastPage(-1, nilIgnore,false),m_NumWUs(nilIgnore),m_PageStartFrom(-1, nilIgnore,false),m_PageEndAt(nilIgnore),m_First(1, nilIgnore,false),m_Sortby(nilIgnore),m_Descending(0, nilIgnore,false),m_BasicQuery(nilIgnore),m_Filters(nilIgnore),m_CacheHint(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetDFUWorkunitsResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CGetDFUWorkunitsResponse::CGetDFUWorkunitsResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_results(nilIgnore),m_Type(nilIgnore),m_Owner(nilIgnore),m_Cluster(nilIgnore),m_StateReq(nilIgnore),m_PageSize(nilIgnore),m_PrevPage(nilIgnore),m_NextPage(nilIgnore),m_LastPage(-1, nilIgnore,false),m_NumWUs(nilIgnore),m_PageStartFrom(-1, nilIgnore,false),m_PageEndAt(nilIgnore),m_First(1, nilIgnore,false),m_Sortby(nilIgnore),m_Descending(0, nilIgnore,false),m_BasicQuery(nilIgnore),m_Filters(nilIgnore),m_CacheHint(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetDFUWorkunitsResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CGetDFUWorkunitsResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		schema.append("<xsd:element name=\"Exceptions\" type=\"tns:ArrayOfEspException\" minOccurs=\"0\" maxOccurs=\"1\"/>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"results\" type=\"tns:ArrayOfDFUWorkunit\"/>\n");
		if (!context.suppressed("GetDFUWorkunitsResponse","Type")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"Type\" type=\"xsd:string\"/>\n");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Owner\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Cluster\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"StateReq\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"PageSize\" type=\"xsd:long\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"PrevPage\" type=\"xsd:long\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"NextPage\" type=\"xsd:long\"/>\n");
		if (!context.suppressed("GetDFUWorkunitsResponse","LastPage")) {
			schema.append("<xsd:element minOccurs=\"0\" default=\"-1\" name=\"LastPage\" type=\"xsd:long\"/>\n");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"NumWUs\" type=\"xsd:long\"/>\n");
		if (!context.suppressed("GetDFUWorkunitsResponse","PageStartFrom")) {
			schema.append("<xsd:element minOccurs=\"0\" default=\"-1\" name=\"PageStartFrom\" type=\"xsd:long\"/>\n");
		}
		if (!context.suppressed("GetDFUWorkunitsResponse","PageEndAt")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"PageEndAt\" type=\"xsd:long\"/>\n");
		}
		schema.append("<xsd:element minOccurs=\"0\" default=\"true\" name=\"First\" type=\"xsd:boolean\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Sortby\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" default=\"false\" name=\"Descending\" type=\"xsd:boolean\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"BasicQuery\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Filters\" type=\"xsd:string\"/>\n");
		if (!context.suppressed("GetDFUWorkunitsResponse","CacheHint")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"CacheHint\" type=\"xsd:long\"/>\n");
		}
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	if (!(flags & 0x10)  || (flags & 0x100))
	{
		CDFUWorkunit::getXsdDefinition(context, request, schema, added);
	}
	if (added.getValue("DFUWorkunit") && added.getValue("ArrayOfDFUWorkunit")==NULL) {
		schema.append("<xsd:complexType name=\"ArrayOfDFUWorkunit\">\n");
		schema.append("<xsd:sequence>\n");
		schema.append("<xsd:element minOccurs=\"0\" maxOccurs=\"unbounded\" name=\"DFUWorkunit\" type=\"tns:DFUWorkunit\"/>\n");
		schema.append("</xsd:sequence>\n");
		schema.append("</xsd:complexType>\n");
		added.setValue("ArrayOfDFUWorkunit",1);
	}
	return schema;
}

void CGetDFUWorkunitsResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CGetDFUWorkunitsResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
	info.addMinVersion("GetDFUWorkunitsResponse","Type",1.03);
	info.addMinVersion("GetDFUWorkunitsResponse","LastPage",1.01);
	info.addMinVersion("GetDFUWorkunitsResponse","PageStartFrom",1.01);
	info.addMinVersion("GetDFUWorkunitsResponse","PageEndAt",1.01);
	info.addMinVersion("GetDFUWorkunitsResponse","CacheHint",1.07);
	if (!added.getValue("DFUWorkunit"))
	{
		added.setValue("DFUWorkunit",1);
		CDFUWorkunit::getMapInfo(info,added);
	}
}

StringBuffer &CGetDFUWorkunitsResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("results");
	form.appendf("<tr><td><b>results: </b></td><td>");
	form.appendf("<table><tr><td><textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea></td>", extfix.str());
	form.append("</tr></table>");
	form.append("</td></tr>");
	if (!context.suppressed("GetDFUWorkunitsResponse","Type")) {
		extfix.clear();
		if (prefix && *prefix)
			extfix.append(prefix).append(".");
		extfix.append("Type");
		form.appendf("  <tr><td><b>Type: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
		form.append("</td></tr>\n");
	}
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Owner");
	form.appendf("  <tr><td><b>Owner: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Cluster");
	form.appendf("  <tr><td><b>Cluster: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("StateReq");
	form.appendf("  <tr><td><b>StateReq: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("PageSize");
	form.appendf("  <tr><td><b>PageSize: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("PrevPage");
	form.appendf("  <tr><td><b>PrevPage: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("NextPage");
	form.appendf("  <tr><td><b>NextPage: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (!context.suppressed("GetDFUWorkunitsResponse","LastPage")) {
		extfix.clear();
		if (prefix && *prefix)
			extfix.append(prefix).append(".");
		extfix.append("LastPage");
		form.appendf("  <tr><td><b>LastPage: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
		form.append("</td></tr>\n");
	}
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("NumWUs");
	form.appendf("  <tr><td><b>NumWUs: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (!context.suppressed("GetDFUWorkunitsResponse","PageStartFrom")) {
		extfix.clear();
		if (prefix && *prefix)
			extfix.append(prefix).append(".");
		extfix.append("PageStartFrom");
		form.appendf("  <tr><td><b>PageStartFrom: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
		form.append("</td></tr>\n");
	}
	if (!context.suppressed("GetDFUWorkunitsResponse","PageEndAt")) {
		extfix.clear();
		if (prefix && *prefix)
			extfix.append(prefix).append(".");
		extfix.append("PageEndAt");
		form.appendf("  <tr><td><b>PageEndAt: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
		form.append("</td></tr>\n");
	}
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("First");
	
	form.appendf("  <tr><td><b>First? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\" checked=\"1\" /></td></tr>\n", extfix.str());
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Sortby");
	form.appendf("  <tr><td><b>Sortby: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Descending");
	
	form.appendf("  <tr><td><b>Descending? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("BasicQuery");
	form.appendf("  <tr><td><b>BasicQuery: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Filters");
	form.appendf("  <tr><td><b>Filters: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (!context.suppressed("GetDFUWorkunitsResponse","CacheHint")) {
		extfix.clear();
		if (prefix && *prefix)
			extfix.append(prefix).append(".");
		extfix.append("CacheHint");
		form.appendf("  <tr><td><b>CacheHint: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
		form.append("</td></tr>\n");
	}
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CGetDFUWorkunitsResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CGetDFUWorkunitsResponse::serialize(IRpcMessage& rpc_resp)
{
	IEspContext* ctx = rpc_resp.queryContext();
	double clientVer= ctx ? ctx->getClientVersion() : -1; /* no context gets everything */
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	rpc_resp.setEncodeXml(false);
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
		m_results.marshall(rpc_resp, "results", "DFUWorkunit");
		if ((clientVer==-1.0 || clientVer>=1.03))
			m_Type.marshall(rpc_resp, "Type", "", "", "");
		m_Owner.marshall(rpc_resp, "Owner", "", "", "");
		m_Cluster.marshall(rpc_resp, "Cluster", "", "", "");
		m_StateReq.marshall(rpc_resp, "StateReq", "", "", "");
		m_PageSize.marshall(rpc_resp, "PageSize", "", "", "");
		m_PrevPage.marshall(rpc_resp, "PrevPage", "", "", "");
		m_NextPage.marshall(rpc_resp, "NextPage", "", "", "");
		if ((clientVer==-1.0 || clientVer>=1.01))
			m_LastPage.marshall(rpc_resp, "LastPage", "", "", "");
		m_NumWUs.marshall(rpc_resp, "NumWUs", "", "", "");
		if ((clientVer==-1.0 || clientVer>=1.01))
			m_PageStartFrom.marshall(rpc_resp, "PageStartFrom", "", "", "");
		if ((clientVer==-1.0 || clientVer>=1.01))
			m_PageEndAt.marshall(rpc_resp, "PageEndAt", "", "", "");
		m_First.marshall(rpc_resp, "First", "", "", "");
		m_Sortby.marshall(rpc_resp, "Sortby", "", "", "");
		m_Descending.marshall(rpc_resp, "Descending", "", "", "");
		m_BasicQuery.marshall(rpc_resp, "BasicQuery", "", "", "");
		m_Filters.marshall(rpc_resp, "Filters", "", "", "");
		if ((clientVer==-1.0 || clientVer>=1.07))
			m_CacheHint.marshall(rpc_resp, "CacheHint", "", "", "");
	}
}


void CGetDFUWorkunitsResponse::copy(CGetDFUWorkunitsResponse &from)
{
	m_results.copy(from.m_results);
	m_Type.copy(from.m_Type);
	m_Owner.copy(from.m_Owner);
	m_Cluster.copy(from.m_Cluster);
	m_StateReq.copy(from.m_StateReq);
	m_PageSize.copy(from.m_PageSize);
	m_PrevPage.copy(from.m_PrevPage);
	m_NextPage.copy(from.m_NextPage);
	m_LastPage.copy(from.m_LastPage);
	m_NumWUs.copy(from.m_NumWUs);
	m_PageStartFrom.copy(from.m_PageStartFrom);
	m_PageEndAt.copy(from.m_PageEndAt);
	m_First.copy(from.m_First);
	m_Sortby.copy(from.m_Sortby);
	m_Descending.copy(from.m_Descending);
	m_BasicQuery.copy(from.m_BasicQuery);
	m_Filters.copy(from.m_Filters);
	m_CacheHint.copy(from.m_CacheHint);
}


void CGetDFUWorkunitsResponse::copy(IConstGetDFUWorkunitsResponse &ifrom)
{
	setResults(ifrom.getResults());
	setType(ifrom.getType());
	setOwner(ifrom.getOwner());
	setCluster(ifrom.getCluster());
	setStateReq(ifrom.getStateReq());
	setPageSize(ifrom.getPageSize());
	setPrevPage(ifrom.getPrevPage());
	setNextPage(ifrom.getNextPage());
	setLastPage(ifrom.getLastPage());
	setNumWUs(ifrom.getNumWUs());
	setPageStartFrom(ifrom.getPageStartFrom());
	setPageEndAt(ifrom.getPageEndAt());
	setFirst(ifrom.getFirst());
	setSortby(ifrom.getSortby());
	setDescending(ifrom.getDescending());
	setBasicQuery(ifrom.getBasicQuery());
	setFilters(ifrom.getFilters());
	setCacheHint(ifrom.getCacheHint());
}


void CGetDFUWorkunitsResponse::getAttributes(IProperties &attributes)
{
}


void CGetDFUWorkunitsResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
		double clientVer = ctx ? ctx->getClientVersion() : -1;
		m_results.toStr(ctx, buffer, "results", "DFUWorkunit");
		if ((clientVer==-1.0 || clientVer>=1.03))
			m_Type.toStr(ctx, buffer, "Type", "", false, "", "");
		m_Owner.toStr(ctx, buffer, "Owner", "", false, "", "");
		m_Cluster.toStr(ctx, buffer, "Cluster", "", false, "", "");
		m_StateReq.toStr(ctx, buffer, "StateReq", "", false, "", "");
		m_PageSize.toStr(ctx, buffer, "PageSize", "", false, "", "");
		m_PrevPage.toStr(ctx, buffer, "PrevPage", "", false, "", "");
		m_NextPage.toStr(ctx, buffer, "NextPage", "", false, "", "");
		if ((clientVer==-1.0 || clientVer>=1.01))
			m_LastPage.toStr(ctx, buffer, "LastPage", "", false, "", "");
		m_NumWUs.toStr(ctx, buffer, "NumWUs", "", false, "", "");
		if ((clientVer==-1.0 || clientVer>=1.01))
			m_PageStartFrom.toStr(ctx, buffer, "PageStartFrom", "", false, "", "");
		if ((clientVer==-1.0 || clientVer>=1.01))
			m_PageEndAt.toStr(ctx, buffer, "PageEndAt", "", false, "", "");
		m_First.toStr(ctx, buffer, "First", "", false, "", "");
		m_Sortby.toStr(ctx, buffer, "Sortby", "", false, "", "");
		m_Descending.toStr(ctx, buffer, "Descending", "", false, "", "");
		m_BasicQuery.toStr(ctx, buffer, "BasicQuery", "", false, "", "");
		m_Filters.toStr(ctx, buffer, "Filters", "", false, "", "");
		if ((clientVer==-1.0 || clientVer>=1.07))
			m_CacheHint.toStr(ctx, buffer, "CacheHint", "", false, "", "");
	}
}


void CGetDFUWorkunitsResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CGetDFUWorkunitsResponse::serializer(IEspContext* ctx, IConstGetDFUWorkunitsResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<GetDFUWorkunitsResponse>");
	double clientVer = ctx ? ctx->getClientVersion() : -1;
	// field results
	{
		IArrayOf<IConstDFUWorkunit>& v = src.getResults();
		int size = v.length();
		if (size>0)
			buffer.append("<results>");
		for (int i=0;i<size;i++)
		{
			buffer.append("<Item>");
			CDFUWorkunit::serializer(ctx,v.item(i),buffer,false);
			buffer.append("</Item>");
		}
		if (size>0)
			buffer.append("</results>");
	}
	// field Type
	if ((clientVer==-1.0 || clientVer>=1.03))
	{
		const char* s = src.getType();
		if (s && *s)
		buffer.appendf("<Type>%s</Type>",s);
	}
	// field Owner
	{
		const char* s = src.getOwner();
		if (s && *s)
		buffer.appendf("<Owner>%s</Owner>",s);
	}
	// field Cluster
	{
		const char* s = src.getCluster();
		if (s && *s)
		buffer.appendf("<Cluster>%s</Cluster>",s);
	}
	// field StateReq
	{
		const char* s = src.getStateReq();
		if (s && *s)
		buffer.appendf("<StateReq>%s</StateReq>",s);
	}
	// field PageSize
	{
		//*** default kind: TK_INT; type=int64, name=PageSize
		buffer.append("<PageSize>");
		buffer.append(src.getPageSize());
		buffer.append("</PageSize>");
	}
	// field PrevPage
	{
		//*** default kind: TK_INT; type=int64, name=PrevPage
		buffer.append("<PrevPage>");
		buffer.append(src.getPrevPage());
		buffer.append("</PrevPage>");
	}
	// field NextPage
	{
		//*** default kind: TK_INT; type=int64, name=NextPage
		buffer.append("<NextPage>");
		buffer.append(src.getNextPage());
		buffer.append("</NextPage>");
	}
	// field LastPage
	if ((clientVer==-1.0 || clientVer>=1.01))
	{
		//*** default kind: TK_INT; type=int64, name=LastPage
		buffer.append("<LastPage>");
		buffer.append(src.getLastPage());
		buffer.append("</LastPage>");
	}
	// field NumWUs
	{
		//*** default kind: TK_INT; type=int64, name=NumWUs
		buffer.append("<NumWUs>");
		buffer.append(src.getNumWUs());
		buffer.append("</NumWUs>");
	}
	// field PageStartFrom
	if ((clientVer==-1.0 || clientVer>=1.01))
	{
		//*** default kind: TK_INT; type=int64, name=PageStartFrom
		buffer.append("<PageStartFrom>");
		buffer.append(src.getPageStartFrom());
		buffer.append("</PageStartFrom>");
	}
	// field PageEndAt
	if ((clientVer==-1.0 || clientVer>=1.01))
	{
		//*** default kind: TK_INT; type=int64, name=PageEndAt
		buffer.append("<PageEndAt>");
		buffer.append(src.getPageEndAt());
		buffer.append("</PageEndAt>");
	}
	// field First
	{
		bool b = src.getFirst();
		if (b)
			buffer.appendf("<First>1</First>");
	}
	// field Sortby
	{
		const char* s = src.getSortby();
		if (s && *s)
		buffer.appendf("<Sortby>%s</Sortby>",s);
	}
	// field Descending
	{
		bool b = src.getDescending();
		if (b)
			buffer.appendf("<Descending>1</Descending>");
	}
	// field BasicQuery
	{
		const char* s = src.getBasicQuery();
		if (s && *s)
		buffer.appendf("<BasicQuery>%s</BasicQuery>",s);
	}
	// field Filters
	{
		const char* s = src.getFilters();
		if (s && *s)
		buffer.appendf("<Filters>%s</Filters>",s);
	}
	// field CacheHint
	if ((clientVer==-1.0 || clientVer>=1.07))
	{
		//*** default kind: TK_INT; type=int64, name=CacheHint
		buffer.append("<CacheHint>");
		buffer.append(src.getCacheHint());
		buffer.append("</CacheHint>");
	}
	if (keepRootTag)
		buffer.append("</GetDFUWorkunitsResponse>");
}

bool CGetDFUWorkunitsResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
		hasValue |= m_results.unmarshall(rpc_request, "results", basepath);
		hasValue |= m_Type.unmarshall(rpc_request, "Type", basepath);
		hasValue |= m_Owner.unmarshall(rpc_request, "Owner", basepath);
		hasValue |= m_Cluster.unmarshall(rpc_request, "Cluster", basepath);
		hasValue |= m_StateReq.unmarshall(rpc_request, "StateReq", basepath);
		hasValue |= m_PageSize.unmarshall(rpc_request, "PageSize", basepath);
		hasValue |= m_PrevPage.unmarshall(rpc_request, "PrevPage", basepath);
		hasValue |= m_NextPage.unmarshall(rpc_request, "NextPage", basepath);
		hasValue |= m_LastPage.unmarshall(rpc_request, "LastPage", basepath);
		hasValue |= m_NumWUs.unmarshall(rpc_request, "NumWUs", basepath);
		hasValue |= m_PageStartFrom.unmarshall(rpc_request, "PageStartFrom", basepath);
		hasValue |= m_PageEndAt.unmarshall(rpc_request, "PageEndAt", basepath);
		hasValue |= m_First.unmarshall(rpc_request, "First", basepath);
		hasValue |= m_Sortby.unmarshall(rpc_request, "Sortby", basepath);
		hasValue |= m_Descending.unmarshall(rpc_request, "Descending", basepath);
		hasValue |= m_BasicQuery.unmarshall(rpc_request, "BasicQuery", basepath);
		hasValue |= m_Filters.unmarshall(rpc_request, "Filters", basepath);
		hasValue |= m_CacheHint.unmarshall(rpc_request, "CacheHint", basepath);
	}
	return hasValue;
}

bool CGetDFUWorkunitsResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_results.unmarshall(ctx, soapval, "results");
	hasValue |= m_Type.unmarshall(ctx, soapval, "Type");
	hasValue |= m_Owner.unmarshall(ctx, soapval, "Owner");
	hasValue |= m_Cluster.unmarshall(ctx, soapval, "Cluster");
	hasValue |= m_StateReq.unmarshall(ctx, soapval, "StateReq");
	hasValue |= m_PageSize.unmarshall(ctx, soapval, "PageSize");
	hasValue |= m_PrevPage.unmarshall(ctx, soapval, "PrevPage");
	hasValue |= m_NextPage.unmarshall(ctx, soapval, "NextPage");
	hasValue |= m_LastPage.unmarshall(ctx, soapval, "LastPage");
	hasValue |= m_NumWUs.unmarshall(ctx, soapval, "NumWUs");
	hasValue |= m_PageStartFrom.unmarshall(ctx, soapval, "PageStartFrom");
	hasValue |= m_PageEndAt.unmarshall(ctx, soapval, "PageEndAt");
	hasValue |= m_First.unmarshall(ctx, soapval, "First");
	hasValue |= m_Sortby.unmarshall(ctx, soapval, "Sortby");
	hasValue |= m_Descending.unmarshall(ctx, soapval, "Descending");
	hasValue |= m_BasicQuery.unmarshall(ctx, soapval, "BasicQuery");
	hasValue |= m_Filters.unmarshall(ctx, soapval, "Filters");
	hasValue |= m_CacheHint.unmarshall(ctx, soapval, "CacheHint");
	return hasValue;
}

bool CGetDFUWorkunitsResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_results.unmarshall(ctx, params, attachments, "results", basepath);
	hasValue |= m_Type.unmarshall(ctx, params, attachments, "Type", basepath);
	hasValue |= m_Owner.unmarshall(ctx, params, attachments, "Owner", basepath);
	hasValue |= m_Cluster.unmarshall(ctx, params, attachments, "Cluster", basepath);
	hasValue |= m_StateReq.unmarshall(ctx, params, attachments, "StateReq", basepath);
	hasValue |= m_PageSize.unmarshall(ctx, params, attachments, "PageSize", basepath);
	hasValue |= m_PrevPage.unmarshall(ctx, params, attachments, "PrevPage", basepath);
	hasValue |= m_NextPage.unmarshall(ctx, params, attachments, "NextPage", basepath);
	hasValue |= m_LastPage.unmarshall(ctx, params, attachments, "LastPage", basepath);
	hasValue |= m_NumWUs.unmarshall(ctx, params, attachments, "NumWUs", basepath);
	hasValue |= m_PageStartFrom.unmarshall(ctx, params, attachments, "PageStartFrom", basepath);
	hasValue |= m_PageEndAt.unmarshall(ctx, params, attachments, "PageEndAt", basepath);
	hasValue |= m_First.unmarshall(ctx, params, attachments, "First", basepath);
	hasValue |= m_Sortby.unmarshall(ctx, params, attachments, "Sortby", basepath);
	hasValue |= m_Descending.unmarshall(ctx, params, attachments, "Descending", basepath);
	hasValue |= m_BasicQuery.unmarshall(ctx, params, attachments, "BasicQuery", basepath);
	hasValue |= m_Filters.unmarshall(ctx, params, attachments, "Filters", basepath);
	hasValue |= m_CacheHint.unmarshall(ctx, params, attachments, "CacheHint", basepath);
	return hasValue;
}

IArrayOf<IConstDFUWorkunit> & CGetDFUWorkunitsResponse::getResults() { return (IArrayOf<IConstDFUWorkunit> &) m_results; }
const char * CGetDFUWorkunitsResponse::getType() { return m_Type.query();}
const char * CGetDFUWorkunitsResponse::getOwner() { return m_Owner.query();}
const char * CGetDFUWorkunitsResponse::getCluster() { return m_Cluster.query();}
const char * CGetDFUWorkunitsResponse::getStateReq() { return m_StateReq.query();}
__int64 CGetDFUWorkunitsResponse::getPageSize() { return m_PageSize;}
__int64 CGetDFUWorkunitsResponse::getPrevPage() { return m_PrevPage;}
__int64 CGetDFUWorkunitsResponse::getNextPage() { return m_NextPage;}
__int64 CGetDFUWorkunitsResponse::getLastPage() { return m_LastPage;}
__int64 CGetDFUWorkunitsResponse::getNumWUs() { return m_NumWUs;}
__int64 CGetDFUWorkunitsResponse::getPageStartFrom() { return m_PageStartFrom;}
__int64 CGetDFUWorkunitsResponse::getPageEndAt() { return m_PageEndAt;}
bool CGetDFUWorkunitsResponse::getFirst() { return m_First;}
const char * CGetDFUWorkunitsResponse::getSortby() { return m_Sortby.query();}
bool CGetDFUWorkunitsResponse::getDescending() { return m_Descending;}
const char * CGetDFUWorkunitsResponse::getBasicQuery() { return m_BasicQuery.query();}
const char * CGetDFUWorkunitsResponse::getFilters() { return m_Filters.query();}
__int64 CGetDFUWorkunitsResponse::getCacheHint() { return m_CacheHint;}
void CGetDFUWorkunitsResponse::setResults(IArrayOf<IEspDFUWorkunit> &val)
{
	m_results->kill();
	IArrayOf<IConstDFUWorkunit> &target = m_results.getValue();
	ForEachItemIn(idx, val)
	{
		IEspDFUWorkunit &item = (val).item(idx);
		item.Link();
		target.append(item);
	}
}
void CGetDFUWorkunitsResponse::setResults(IArrayOf<IConstDFUWorkunit> &val)
{
	m_results->kill();
	IArrayOf<IConstDFUWorkunit> &target = m_results.getValue();
	ForEachItemIn(idx, val)
	{
		IConstDFUWorkunit &item = val.item(idx);
		item.Link();
		target.append(item);
	}
}
void CGetDFUWorkunitsResponse::setType(const char * val){ m_Type.set(val); }
void CGetDFUWorkunitsResponse::setOwner(const char * val){ m_Owner.set(val); }
void CGetDFUWorkunitsResponse::setCluster(const char * val){ m_Cluster.set(val); }
void CGetDFUWorkunitsResponse::setStateReq(const char * val){ m_StateReq.set(val); }
void CGetDFUWorkunitsResponse::setPageSize(__int64 val){ m_PageSize=val; }
void CGetDFUWorkunitsResponse::setPrevPage(__int64 val){ m_PrevPage=val; }
void CGetDFUWorkunitsResponse::setNextPage(__int64 val){ m_NextPage=val; }
void CGetDFUWorkunitsResponse::setLastPage(__int64 val){ m_LastPage=val; }
void CGetDFUWorkunitsResponse::setNumWUs(__int64 val){ m_NumWUs=val; }
void CGetDFUWorkunitsResponse::setPageStartFrom(__int64 val){ m_PageStartFrom=val; }
void CGetDFUWorkunitsResponse::setPageEndAt(__int64 val){ m_PageEndAt=val; }
void CGetDFUWorkunitsResponse::setFirst(bool val){ m_First=val; }
void CGetDFUWorkunitsResponse::setSortby(const char * val){ m_Sortby.set(val); }
void CGetDFUWorkunitsResponse::setDescending(bool val){ m_Descending=val; }
void CGetDFUWorkunitsResponse::setBasicQuery(const char * val){ m_BasicQuery.set(val); }
void CGetDFUWorkunitsResponse::setFilters(const char * val){ m_Filters.set(val); }
void CGetDFUWorkunitsResponse::setCacheHint(__int64 val){ m_CacheHint=val; }
extern "C"  IEspGetDFUWorkunitsResponse *createGetDFUWorkunitsResponse(const char *serv){return ((IEspGetDFUWorkunitsResponse *)new CGetDFUWorkunitsResponse(serv));}
extern "C"  IClientGetDFUWorkunitsResponse *createClientGetDFUWorkunitsResponse(const char *serv){return ((IClientGetDFUWorkunitsResponse *)new CGetDFUWorkunitsResponse(serv));}

//=======================================================
// class CProgressRequest Implementation
//=======================================================

CProgressRequest::CProgressRequest(const char *serviceName, IRpcMessageBinding *init)
	: m_wuid(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ProgressRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CProgressRequest::CProgressRequest(const char *serviceName, const char *bc)
	: m_wuid(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ProgressRequest");
}

CProgressRequest::CProgressRequest(const char *serviceName, IRpcMessage* rpcmsg)
	: m_wuid(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ProgressRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CProgressRequest::CProgressRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_wuid(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ProgressRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CProgressRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"wuid\" type=\"xsd:string\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CProgressRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CProgressRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CProgressRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("wuid");
	form.appendf("  <tr><td><b>wuid: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CProgressRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CProgressRequest::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_wuid.marshall(rpc_resp, "wuid", "", "", "");
}


void CProgressRequest::copy(CProgressRequest &from)
{
	m_wuid.copy(from.m_wuid);
}


void CProgressRequest::copy(IConstProgressRequest &ifrom)
{
	setWuid(ifrom.getWuid());
}


void CProgressRequest::getAttributes(IProperties &attributes)
{
}


void CProgressRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_wuid.toStr(ctx, buffer, "wuid", "", true, "", "");
}


void CProgressRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CProgressRequest::serializer(IEspContext* ctx, IConstProgressRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<ProgressRequest>");
	// field wuid
	{
		const char* s = src.getWuid();
		if (s && *s)
		{
			buffer.append("<wuid>");
			encodeUtf8XML(s,buffer);
			buffer.append("</wuid>");
		}
	}
	if (keepRootTag)
		buffer.append("</ProgressRequest>");
}

bool CProgressRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_wuid.unmarshall(rpc_request, "wuid", basepath);
	return hasValue;
}

bool CProgressRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_wuid.unmarshall(ctx, soapval, "wuid");
	return hasValue;
}

bool CProgressRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_wuid.unmarshall(ctx, params, attachments, "wuid", basepath);
	return hasValue;
}

const char * CProgressRequest::getWuid() { return m_wuid.query();}
void CProgressRequest::setWuid(const char * val){ m_wuid.set(val); }
extern "C"  IEspProgressRequest *createProgressRequest(const char *serv){return ((IEspProgressRequest *)new CProgressRequest(serv));}
extern "C"  IClientProgressRequest *createClientProgressRequest(const char *serv){return ((IClientProgressRequest *)new CProgressRequest(serv));}

//=======================================================
// class CProgressResponse Implementation
//=======================================================

CProgressResponse::CProgressResponse(const char *serviceName, IRpcMessageBinding *init)
	: m_wuid(nilIgnore),m_PercentDone(nilIgnore),m_SecsLeft(nilIgnore),m_KbPerSecAve(nilIgnore),m_KbPerSec(nilIgnore),m_SlavesDone(nilIgnore),m_TimeTaken(nilIgnore),m_ProgressMessage(nilIgnore),m_SummaryMessage(nilIgnore),m_State(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ProgressResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CProgressResponse::CProgressResponse(const char *serviceName, const char *bc)
	: m_wuid(nilIgnore),m_PercentDone(nilIgnore),m_SecsLeft(nilIgnore),m_KbPerSecAve(nilIgnore),m_KbPerSec(nilIgnore),m_SlavesDone(nilIgnore),m_TimeTaken(nilIgnore),m_ProgressMessage(nilIgnore),m_SummaryMessage(nilIgnore),m_State(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ProgressResponse");
}

CProgressResponse::CProgressResponse(const char *serviceName, IRpcMessage* rpcmsg)
	: m_wuid(nilIgnore),m_PercentDone(nilIgnore),m_SecsLeft(nilIgnore),m_KbPerSecAve(nilIgnore),m_KbPerSec(nilIgnore),m_SlavesDone(nilIgnore),m_TimeTaken(nilIgnore),m_ProgressMessage(nilIgnore),m_SummaryMessage(nilIgnore),m_State(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ProgressResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CProgressResponse::CProgressResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_wuid(nilIgnore),m_PercentDone(nilIgnore),m_SecsLeft(nilIgnore),m_KbPerSecAve(nilIgnore),m_KbPerSec(nilIgnore),m_SlavesDone(nilIgnore),m_TimeTaken(nilIgnore),m_ProgressMessage(nilIgnore),m_SummaryMessage(nilIgnore),m_State(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ProgressResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CProgressResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		schema.append("<xsd:element name=\"Exceptions\" type=\"tns:ArrayOfEspException\" minOccurs=\"0\" maxOccurs=\"1\"/>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"wuid\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"PercentDone\" type=\"xsd:int\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"SecsLeft\" type=\"xsd:int\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"KbPerSecAve\" type=\"xsd:int\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"KbPerSec\" type=\"xsd:int\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"SlavesDone\" type=\"xsd:int\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"TimeTaken\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"ProgressMessage\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"SummaryMessage\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"State\" type=\"xsd:string\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CProgressResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CProgressResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CProgressResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("wuid");
	form.appendf("  <tr><td><b>wuid: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix) extfix.append(prefix).append(".");
		extfix.append("PercentDone");
	form.appendf("  <tr><td><b>PercentDone: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix) extfix.append(prefix).append(".");
		extfix.append("SecsLeft");
	form.appendf("  <tr><td><b>SecsLeft: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix) extfix.append(prefix).append(".");
		extfix.append("KbPerSecAve");
	form.appendf("  <tr><td><b>KbPerSecAve: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix) extfix.append(prefix).append(".");
		extfix.append("KbPerSec");
	form.appendf("  <tr><td><b>KbPerSec: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix) extfix.append(prefix).append(".");
		extfix.append("SlavesDone");
	form.appendf("  <tr><td><b>SlavesDone: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("TimeTaken");
	form.appendf("  <tr><td><b>TimeTaken: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("ProgressMessage");
	form.appendf("  <tr><td><b>ProgressMessage: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("SummaryMessage");
	form.appendf("  <tr><td><b>SummaryMessage: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("State");
	form.appendf("  <tr><td><b>State: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CProgressResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CProgressResponse::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	rpc_resp.setEncodeXml(false);
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
		m_wuid.marshall(rpc_resp, "wuid", "", "", "");
		m_PercentDone.marshall(rpc_resp, "PercentDone", "", "", "");
		m_SecsLeft.marshall(rpc_resp, "SecsLeft", "", "", "");
		m_KbPerSecAve.marshall(rpc_resp, "KbPerSecAve", "", "", "");
		m_KbPerSec.marshall(rpc_resp, "KbPerSec", "", "", "");
		m_SlavesDone.marshall(rpc_resp, "SlavesDone", "", "", "");
		m_TimeTaken.marshall(rpc_resp, "TimeTaken", "", "", "");
		m_ProgressMessage.marshall(rpc_resp, "ProgressMessage", "", "", "");
		m_SummaryMessage.marshall(rpc_resp, "SummaryMessage", "", "", "");
		m_State.marshall(rpc_resp, "State", "", "", "");
	}
}


void CProgressResponse::copy(CProgressResponse &from)
{
	m_wuid.copy(from.m_wuid);
	m_PercentDone.copy(from.m_PercentDone);
	m_SecsLeft.copy(from.m_SecsLeft);
	m_KbPerSecAve.copy(from.m_KbPerSecAve);
	m_KbPerSec.copy(from.m_KbPerSec);
	m_SlavesDone.copy(from.m_SlavesDone);
	m_TimeTaken.copy(from.m_TimeTaken);
	m_ProgressMessage.copy(from.m_ProgressMessage);
	m_SummaryMessage.copy(from.m_SummaryMessage);
	m_State.copy(from.m_State);
}


void CProgressResponse::copy(IConstProgressResponse &ifrom)
{
	setWuid(ifrom.getWuid());
	setPercentDone(ifrom.getPercentDone());
	setSecsLeft(ifrom.getSecsLeft());
	setKbPerSecAve(ifrom.getKbPerSecAve());
	setKbPerSec(ifrom.getKbPerSec());
	setSlavesDone(ifrom.getSlavesDone());
	setTimeTaken(ifrom.getTimeTaken());
	setProgressMessage(ifrom.getProgressMessage());
	setSummaryMessage(ifrom.getSummaryMessage());
	setState(ifrom.getState());
}


void CProgressResponse::getAttributes(IProperties &attributes)
{
}


void CProgressResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
		m_wuid.toStr(ctx, buffer, "wuid", "", false, "", "");
		m_PercentDone.toStr(ctx, buffer, "PercentDone", "", false, "", "");
		m_SecsLeft.toStr(ctx, buffer, "SecsLeft", "", false, "", "");
		m_KbPerSecAve.toStr(ctx, buffer, "KbPerSecAve", "", false, "", "");
		m_KbPerSec.toStr(ctx, buffer, "KbPerSec", "", false, "", "");
		m_SlavesDone.toStr(ctx, buffer, "SlavesDone", "", false, "", "");
		m_TimeTaken.toStr(ctx, buffer, "TimeTaken", "", false, "", "");
		m_ProgressMessage.toStr(ctx, buffer, "ProgressMessage", "", false, "", "");
		m_SummaryMessage.toStr(ctx, buffer, "SummaryMessage", "", false, "", "");
		m_State.toStr(ctx, buffer, "State", "", false, "", "");
	}
}


void CProgressResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CProgressResponse::serializer(IEspContext* ctx, IConstProgressResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<ProgressResponse>");
	// field wuid
	{
		const char* s = src.getWuid();
		if (s && *s)
		buffer.appendf("<wuid>%s</wuid>",s);
	}
	// field PercentDone
	{
		int n = src.getPercentDone();
		if (n)
			buffer.appendf("<PercentDone>%d</PercentDone>", n);
	}
	// field SecsLeft
	{
		int n = src.getSecsLeft();
		if (n)
			buffer.appendf("<SecsLeft>%d</SecsLeft>", n);
	}
	// field KbPerSecAve
	{
		int n = src.getKbPerSecAve();
		if (n)
			buffer.appendf("<KbPerSecAve>%d</KbPerSecAve>", n);
	}
	// field KbPerSec
	{
		int n = src.getKbPerSec();
		if (n)
			buffer.appendf("<KbPerSec>%d</KbPerSec>", n);
	}
	// field SlavesDone
	{
		int n = src.getSlavesDone();
		if (n)
			buffer.appendf("<SlavesDone>%d</SlavesDone>", n);
	}
	// field TimeTaken
	{
		const char* s = src.getTimeTaken();
		if (s && *s)
		buffer.appendf("<TimeTaken>%s</TimeTaken>",s);
	}
	// field ProgressMessage
	{
		const char* s = src.getProgressMessage();
		if (s && *s)
		buffer.appendf("<ProgressMessage>%s</ProgressMessage>",s);
	}
	// field SummaryMessage
	{
		const char* s = src.getSummaryMessage();
		if (s && *s)
		buffer.appendf("<SummaryMessage>%s</SummaryMessage>",s);
	}
	// field State
	{
		const char* s = src.getState();
		if (s && *s)
		buffer.appendf("<State>%s</State>",s);
	}
	if (keepRootTag)
		buffer.append("</ProgressResponse>");
}

bool CProgressResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
		hasValue |= m_wuid.unmarshall(rpc_request, "wuid", basepath);
		hasValue |= m_PercentDone.unmarshall(rpc_request, "PercentDone", basepath);
		hasValue |= m_SecsLeft.unmarshall(rpc_request, "SecsLeft", basepath);
		hasValue |= m_KbPerSecAve.unmarshall(rpc_request, "KbPerSecAve", basepath);
		hasValue |= m_KbPerSec.unmarshall(rpc_request, "KbPerSec", basepath);
		hasValue |= m_SlavesDone.unmarshall(rpc_request, "SlavesDone", basepath);
		hasValue |= m_TimeTaken.unmarshall(rpc_request, "TimeTaken", basepath);
		hasValue |= m_ProgressMessage.unmarshall(rpc_request, "ProgressMessage", basepath);
		hasValue |= m_SummaryMessage.unmarshall(rpc_request, "SummaryMessage", basepath);
		hasValue |= m_State.unmarshall(rpc_request, "State", basepath);
	}
	return hasValue;
}

bool CProgressResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_wuid.unmarshall(ctx, soapval, "wuid");
	hasValue |= m_PercentDone.unmarshall(ctx, soapval, "PercentDone");
	hasValue |= m_SecsLeft.unmarshall(ctx, soapval, "SecsLeft");
	hasValue |= m_KbPerSecAve.unmarshall(ctx, soapval, "KbPerSecAve");
	hasValue |= m_KbPerSec.unmarshall(ctx, soapval, "KbPerSec");
	hasValue |= m_SlavesDone.unmarshall(ctx, soapval, "SlavesDone");
	hasValue |= m_TimeTaken.unmarshall(ctx, soapval, "TimeTaken");
	hasValue |= m_ProgressMessage.unmarshall(ctx, soapval, "ProgressMessage");
	hasValue |= m_SummaryMessage.unmarshall(ctx, soapval, "SummaryMessage");
	hasValue |= m_State.unmarshall(ctx, soapval, "State");
	return hasValue;
}

bool CProgressResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_wuid.unmarshall(ctx, params, attachments, "wuid", basepath);
	hasValue |= m_PercentDone.unmarshall(ctx, params, attachments, "PercentDone", basepath);
	hasValue |= m_SecsLeft.unmarshall(ctx, params, attachments, "SecsLeft", basepath);
	hasValue |= m_KbPerSecAve.unmarshall(ctx, params, attachments, "KbPerSecAve", basepath);
	hasValue |= m_KbPerSec.unmarshall(ctx, params, attachments, "KbPerSec", basepath);
	hasValue |= m_SlavesDone.unmarshall(ctx, params, attachments, "SlavesDone", basepath);
	hasValue |= m_TimeTaken.unmarshall(ctx, params, attachments, "TimeTaken", basepath);
	hasValue |= m_ProgressMessage.unmarshall(ctx, params, attachments, "ProgressMessage", basepath);
	hasValue |= m_SummaryMessage.unmarshall(ctx, params, attachments, "SummaryMessage", basepath);
	hasValue |= m_State.unmarshall(ctx, params, attachments, "State", basepath);
	return hasValue;
}

const char * CProgressResponse::getWuid() { return m_wuid.query();}
int CProgressResponse::getPercentDone() { return m_PercentDone;}
int CProgressResponse::getSecsLeft() { return m_SecsLeft;}
int CProgressResponse::getKbPerSecAve() { return m_KbPerSecAve;}
int CProgressResponse::getKbPerSec() { return m_KbPerSec;}
int CProgressResponse::getSlavesDone() { return m_SlavesDone;}
const char * CProgressResponse::getTimeTaken() { return m_TimeTaken.query();}
const char * CProgressResponse::getProgressMessage() { return m_ProgressMessage.query();}
const char * CProgressResponse::getSummaryMessage() { return m_SummaryMessage.query();}
const char * CProgressResponse::getState() { return m_State.query();}
void CProgressResponse::setWuid(const char * val){ m_wuid.set(val); }
void CProgressResponse::setPercentDone(int val){ m_PercentDone=val; }
void CProgressResponse::setSecsLeft(int val){ m_SecsLeft=val; }
void CProgressResponse::setKbPerSecAve(int val){ m_KbPerSecAve=val; }
void CProgressResponse::setKbPerSec(int val){ m_KbPerSec=val; }
void CProgressResponse::setSlavesDone(int val){ m_SlavesDone=val; }
void CProgressResponse::setTimeTaken(const char * val){ m_TimeTaken.set(val); }
void CProgressResponse::setProgressMessage(const char * val){ m_ProgressMessage.set(val); }
void CProgressResponse::setSummaryMessage(const char * val){ m_SummaryMessage.set(val); }
void CProgressResponse::setState(const char * val){ m_State.set(val); }
extern "C"  IEspProgressResponse *createProgressResponse(const char *serv){return ((IEspProgressResponse *)new CProgressResponse(serv));}
extern "C"  IClientProgressResponse *createClientProgressResponse(const char *serv){return ((IClientProgressResponse *)new CProgressResponse(serv));}

//=======================================================
// class CGetDFUWorkunit Implementation
//=======================================================

CGetDFUWorkunit::CGetDFUWorkunit(const char *serviceName, IRpcMessageBinding *init)
	: m_wuid(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetDFUWorkunit");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CGetDFUWorkunit::CGetDFUWorkunit(const char *serviceName, const char *bc)
	: m_wuid(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetDFUWorkunit");
}

CGetDFUWorkunit::CGetDFUWorkunit(const char *serviceName, IRpcMessage* rpcmsg)
	: m_wuid(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetDFUWorkunit");
	unserialize(*rpcmsg,NULL,NULL);
}

CGetDFUWorkunit::CGetDFUWorkunit(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_wuid(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetDFUWorkunit");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CGetDFUWorkunit::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"wuid\" type=\"xsd:string\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CGetDFUWorkunit::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CGetDFUWorkunit::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CGetDFUWorkunit::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("wuid");
	form.appendf("  <tr><td><b>wuid: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CGetDFUWorkunit::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CGetDFUWorkunit::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_wuid.marshall(rpc_resp, "wuid", "", "", "");
}


void CGetDFUWorkunit::copy(CGetDFUWorkunit &from)
{
	m_wuid.copy(from.m_wuid);
}


void CGetDFUWorkunit::copy(IConstGetDFUWorkunit &ifrom)
{
	setWuid(ifrom.getWuid());
}


void CGetDFUWorkunit::getAttributes(IProperties &attributes)
{
}


void CGetDFUWorkunit::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_wuid.toStr(ctx, buffer, "wuid", "", true, "", "");
}


void CGetDFUWorkunit::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CGetDFUWorkunit::serializer(IEspContext* ctx, IConstGetDFUWorkunit &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<GetDFUWorkunit>");
	// field wuid
	{
		const char* s = src.getWuid();
		if (s && *s)
		{
			buffer.append("<wuid>");
			encodeUtf8XML(s,buffer);
			buffer.append("</wuid>");
		}
	}
	if (keepRootTag)
		buffer.append("</GetDFUWorkunit>");
}

bool CGetDFUWorkunit::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_wuid.unmarshall(rpc_request, "wuid", basepath);
	return hasValue;
}

bool CGetDFUWorkunit::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_wuid.unmarshall(ctx, soapval, "wuid");
	return hasValue;
}

bool CGetDFUWorkunit::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_wuid.unmarshall(ctx, params, attachments, "wuid", basepath);
	return hasValue;
}

const char * CGetDFUWorkunit::getWuid() { return m_wuid.query();}
void CGetDFUWorkunit::setWuid(const char * val){ m_wuid.set(val); }
extern "C"  IEspGetDFUWorkunit *createGetDFUWorkunit(const char *serv){return ((IEspGetDFUWorkunit *)new CGetDFUWorkunit(serv));}
extern "C"  IClientGetDFUWorkunit *createClientGetDFUWorkunit(const char *serv){return ((IClientGetDFUWorkunit *)new CGetDFUWorkunit(serv));}

//=======================================================
// class CGetDFUWorkunitResponse Implementation
//=======================================================

CGetDFUWorkunitResponse::CGetDFUWorkunitResponse(const char *serviceName, IRpcMessageBinding *init)
	: m_result(serviceName, nilIgnore),m_AutoRefresh(0, nilIgnore,false)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetDFUWorkunitResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CGetDFUWorkunitResponse::CGetDFUWorkunitResponse(const char *serviceName, const char *bc)
	: m_result(serviceName, nilIgnore),m_AutoRefresh(0, nilIgnore,false)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetDFUWorkunitResponse");
}

CGetDFUWorkunitResponse::CGetDFUWorkunitResponse(const char *serviceName, IRpcMessage* rpcmsg)
	: m_result(serviceName, nilIgnore),m_AutoRefresh(0, nilIgnore,false)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetDFUWorkunitResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CGetDFUWorkunitResponse::CGetDFUWorkunitResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_result(serviceName, nilIgnore),m_AutoRefresh(0, nilIgnore,false)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetDFUWorkunitResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CGetDFUWorkunitResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		schema.append("<xsd:element name=\"Exceptions\" type=\"tns:ArrayOfEspException\" minOccurs=\"0\" maxOccurs=\"1\"/>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"result\" type=\"tns:DFUWorkunit\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"AutoRefresh\" type=\"xsd:int\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	if (!(flags & 0x10)  || (flags & 0x100))
	{
		CDFUWorkunit::getXsdDefinition(context, request, schema, added);
	}
	return schema;
}

void CGetDFUWorkunitResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CGetDFUWorkunitResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
	if (!added.getValue("DFUWorkunit"))
	{
		added.setValue("DFUWorkunit",1);
		CDFUWorkunit::getMapInfo(info,added);
	}
}

StringBuffer &CGetDFUWorkunitResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("result");
	form.append("<tr>").append("<td><b>result: </b></td><td><hr/>");
	CDFUWorkunit::getHtmlForm(context, request, serv, method, form, false, extfix.str());
	form.append("<hr/></td></tr>");
	extfix.clear();
	if (prefix && *prefix) extfix.append(prefix).append(".");
		extfix.append("AutoRefresh");
	form.appendf("  <tr><td><b>AutoRefresh: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CGetDFUWorkunitResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CGetDFUWorkunitResponse::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
		m_result.marshall(rpc_resp, "result", "", "", "");
		m_AutoRefresh.marshall(rpc_resp, "AutoRefresh", "", "", "");
	}
}


void CGetDFUWorkunitResponse::copy(CGetDFUWorkunitResponse &from)
{
	m_result.copy(from.m_result);
	m_AutoRefresh.copy(from.m_AutoRefresh);
}


void CGetDFUWorkunitResponse::copy(IConstGetDFUWorkunitResponse &ifrom)
{
	setResult(ifrom.getResult());
	setAutoRefresh(ifrom.getAutoRefresh());
}


void CGetDFUWorkunitResponse::getAttributes(IProperties &attributes)
{
}


void CGetDFUWorkunitResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
		m_result.toStr(ctx, buffer, "result", "", false, "", "");
		m_AutoRefresh.toStr(ctx, buffer, "AutoRefresh", "", true, "", "");
	}
}


void CGetDFUWorkunitResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CGetDFUWorkunitResponse::serializer(IEspContext* ctx, IConstGetDFUWorkunitResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<GetDFUWorkunitResponse>");
	// field result
	{
		StringBuffer tmp;
		CDFUWorkunit::serializer(ctx,src.getResult(), tmp, false);
		if (tmp.length()>0)
			buffer.appendf("<result>%s</result>",tmp.str());
	}
	// field AutoRefresh
	{
		int n = src.getAutoRefresh();
		if (n)
			buffer.appendf("<AutoRefresh>%d</AutoRefresh>", n);
	}
	if (keepRootTag)
		buffer.append("</GetDFUWorkunitResponse>");
}

bool CGetDFUWorkunitResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
		hasValue |= m_result.unmarshall(rpc_request, "result", basepath);
		hasValue |= m_AutoRefresh.unmarshall(rpc_request, "AutoRefresh", basepath);
	}
	return hasValue;
}

bool CGetDFUWorkunitResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_result.unmarshall(ctx, soapval, "result");
	hasValue |= m_AutoRefresh.unmarshall(ctx, soapval, "AutoRefresh");
	return hasValue;
}

bool CGetDFUWorkunitResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_result.unmarshall(ctx, params, attachments, "result", basepath);
	hasValue |= m_AutoRefresh.unmarshall(ctx, params, attachments, "AutoRefresh", basepath);
	return hasValue;
}

IConstDFUWorkunit & CGetDFUWorkunitResponse::getResult() { return (IConstDFUWorkunit &) m_result.getValue();}
int CGetDFUWorkunitResponse::getAutoRefresh() { return m_AutoRefresh;}
IEspDFUWorkunit & CGetDFUWorkunitResponse::updateResult(){ return (IEspDFUWorkunit &) m_result.getValue(); }
void CGetDFUWorkunitResponse::setResult(IConstDFUWorkunit &ifrom){ m_result.copy(ifrom); }
void CGetDFUWorkunitResponse::setAutoRefresh(int val){ m_AutoRefresh=val; }
extern "C"  IEspGetDFUWorkunitResponse *createGetDFUWorkunitResponse(const char *serv){return ((IEspGetDFUWorkunitResponse *)new CGetDFUWorkunitResponse(serv));}
extern "C"  IClientGetDFUWorkunitResponse *createClientGetDFUWorkunitResponse(const char *serv){return ((IClientGetDFUWorkunitResponse *)new CGetDFUWorkunitResponse(serv));}

//=======================================================
// class CCreateDFUWorkunit Implementation
//=======================================================

CCreateDFUWorkunit::CCreateDFUWorkunit(const char *serviceName, IRpcMessageBinding *init)
	: m_DFUServerQueue(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("CreateDFUWorkunit");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CCreateDFUWorkunit::CCreateDFUWorkunit(const char *serviceName, const char *bc)
	: m_DFUServerQueue(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("CreateDFUWorkunit");
}

CCreateDFUWorkunit::CCreateDFUWorkunit(const char *serviceName, IRpcMessage* rpcmsg)
	: m_DFUServerQueue(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("CreateDFUWorkunit");
	unserialize(*rpcmsg,NULL,NULL);
}

CCreateDFUWorkunit::CCreateDFUWorkunit(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_DFUServerQueue(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("CreateDFUWorkunit");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CCreateDFUWorkunit::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		if (!context.suppressed("CreateDFUWorkunit","DFUServerQueue")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"DFUServerQueue\" type=\"xsd:string\"/>\n");
		}
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CCreateDFUWorkunit::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CCreateDFUWorkunit::getMapInfo(IMapInfo& info, BoolHash& added)
{
	info.addMinVersion("CreateDFUWorkunit","DFUServerQueue",1.14);
}

StringBuffer &CCreateDFUWorkunit::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	if (!context.suppressed("CreateDFUWorkunit","DFUServerQueue")) {
		extfix.clear();
		if (prefix && *prefix)
			extfix.append(prefix).append(".");
		extfix.append("DFUServerQueue");
		form.appendf("  <tr><td><b>DFUServerQueue: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
		form.append("</td></tr>\n");
	}
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CCreateDFUWorkunit::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CCreateDFUWorkunit::serialize(IRpcMessage& rpc_resp)
{
	IEspContext* ctx = rpc_resp.queryContext();
	double clientVer= ctx ? ctx->getClientVersion() : -1; /* no context gets everything */
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	if ((clientVer==-1.0 || clientVer>=1.14))
		m_DFUServerQueue.marshall(rpc_resp, "DFUServerQueue", "", "", "");
}


void CCreateDFUWorkunit::copy(CCreateDFUWorkunit &from)
{
	m_DFUServerQueue.copy(from.m_DFUServerQueue);
}


void CCreateDFUWorkunit::copy(IConstCreateDFUWorkunit &ifrom)
{
	setDFUServerQueue(ifrom.getDFUServerQueue());
}


void CCreateDFUWorkunit::getAttributes(IProperties &attributes)
{
}


void CCreateDFUWorkunit::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	double clientVer = ctx ? ctx->getClientVersion() : -1;
	if ((clientVer==-1.0 || clientVer>=1.14))
		m_DFUServerQueue.toStr(ctx, buffer, "DFUServerQueue", "", true, "", "");
}


void CCreateDFUWorkunit::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CCreateDFUWorkunit::serializer(IEspContext* ctx, IConstCreateDFUWorkunit &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<CreateDFUWorkunit>");
	double clientVer = ctx ? ctx->getClientVersion() : -1;
	// field DFUServerQueue
	if ((clientVer==-1.0 || clientVer>=1.14))
	{
		const char* s = src.getDFUServerQueue();
		if (s && *s)
		{
			buffer.append("<DFUServerQueue>");
			encodeUtf8XML(s,buffer);
			buffer.append("</DFUServerQueue>");
		}
	}
	if (keepRootTag)
		buffer.append("</CreateDFUWorkunit>");
}

bool CCreateDFUWorkunit::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_DFUServerQueue.unmarshall(rpc_request, "DFUServerQueue", basepath);
	return hasValue;
}

bool CCreateDFUWorkunit::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_DFUServerQueue.unmarshall(ctx, soapval, "DFUServerQueue");
	return hasValue;
}

bool CCreateDFUWorkunit::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_DFUServerQueue.unmarshall(ctx, params, attachments, "DFUServerQueue", basepath);
	return hasValue;
}

const char * CCreateDFUWorkunit::getDFUServerQueue() { return m_DFUServerQueue.query();}
void CCreateDFUWorkunit::setDFUServerQueue(const char * val){ m_DFUServerQueue.set(val); }
extern "C"  IEspCreateDFUWorkunit *createCreateDFUWorkunit(const char *serv){return ((IEspCreateDFUWorkunit *)new CCreateDFUWorkunit(serv));}
extern "C"  IClientCreateDFUWorkunit *createClientCreateDFUWorkunit(const char *serv){return ((IClientCreateDFUWorkunit *)new CCreateDFUWorkunit(serv));}

//=======================================================
// class CCreateDFUWorkunitResponse Implementation
//=======================================================

CCreateDFUWorkunitResponse::CCreateDFUWorkunitResponse(const char *serviceName, IRpcMessageBinding *init)
	: m_result(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("CreateDFUWorkunitResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CCreateDFUWorkunitResponse::CCreateDFUWorkunitResponse(const char *serviceName, const char *bc)
	: m_result(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("CreateDFUWorkunitResponse");
}

CCreateDFUWorkunitResponse::CCreateDFUWorkunitResponse(const char *serviceName, IRpcMessage* rpcmsg)
	: m_result(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("CreateDFUWorkunitResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CCreateDFUWorkunitResponse::CCreateDFUWorkunitResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_result(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("CreateDFUWorkunitResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CCreateDFUWorkunitResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		schema.append("<xsd:element name=\"Exceptions\" type=\"tns:ArrayOfEspException\" minOccurs=\"0\" maxOccurs=\"1\"/>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"result\" type=\"tns:DFUWorkunit\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	if (!(flags & 0x10)  || (flags & 0x100))
	{
		CDFUWorkunit::getXsdDefinition(context, request, schema, added);
	}
	return schema;
}

void CCreateDFUWorkunitResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CCreateDFUWorkunitResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
	if (!added.getValue("DFUWorkunit"))
	{
		added.setValue("DFUWorkunit",1);
		CDFUWorkunit::getMapInfo(info,added);
	}
}

StringBuffer &CCreateDFUWorkunitResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("result");
	form.append("<tr>").append("<td><b>result: </b></td><td><hr/>");
	CDFUWorkunit::getHtmlForm(context, request, serv, method, form, false, extfix.str());
	form.append("<hr/></td></tr>");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CCreateDFUWorkunitResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CCreateDFUWorkunitResponse::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
		m_result.marshall(rpc_resp, "result", "", "", "");
	}
}


void CCreateDFUWorkunitResponse::copy(CCreateDFUWorkunitResponse &from)
{
	m_result.copy(from.m_result);
}


void CCreateDFUWorkunitResponse::copy(IConstCreateDFUWorkunitResponse &ifrom)
{
	setResult(ifrom.getResult());
}


void CCreateDFUWorkunitResponse::getAttributes(IProperties &attributes)
{
}


void CCreateDFUWorkunitResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
		m_result.toStr(ctx, buffer, "result", "", false, "", "");
	}
}


void CCreateDFUWorkunitResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CCreateDFUWorkunitResponse::serializer(IEspContext* ctx, IConstCreateDFUWorkunitResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<CreateDFUWorkunitResponse>");
	// field result
	{
		StringBuffer tmp;
		CDFUWorkunit::serializer(ctx,src.getResult(), tmp, false);
		if (tmp.length()>0)
			buffer.appendf("<result>%s</result>",tmp.str());
	}
	if (keepRootTag)
		buffer.append("</CreateDFUWorkunitResponse>");
}

bool CCreateDFUWorkunitResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
		hasValue |= m_result.unmarshall(rpc_request, "result", basepath);
	}
	return hasValue;
}

bool CCreateDFUWorkunitResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_result.unmarshall(ctx, soapval, "result");
	return hasValue;
}

bool CCreateDFUWorkunitResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_result.unmarshall(ctx, params, attachments, "result", basepath);
	return hasValue;
}

IConstDFUWorkunit & CCreateDFUWorkunitResponse::getResult() { return (IConstDFUWorkunit &) m_result.getValue();}
IEspDFUWorkunit & CCreateDFUWorkunitResponse::updateResult(){ return (IEspDFUWorkunit &) m_result.getValue(); }
void CCreateDFUWorkunitResponse::setResult(IConstDFUWorkunit &ifrom){ m_result.copy(ifrom); }
extern "C"  IEspCreateDFUWorkunitResponse *createCreateDFUWorkunitResponse(const char *serv){return ((IEspCreateDFUWorkunitResponse *)new CCreateDFUWorkunitResponse(serv));}
extern "C"  IClientCreateDFUWorkunitResponse *createClientCreateDFUWorkunitResponse(const char *serv){return ((IClientCreateDFUWorkunitResponse *)new CCreateDFUWorkunitResponse(serv));}

//=======================================================
// class CUpdateDFUWorkunit Implementation
//=======================================================

CUpdateDFUWorkunit::CUpdateDFUWorkunit(const char *serviceName, IRpcMessageBinding *init)
	: m_wu(serviceName, nilIgnore),m_ClusterOrig(nilIgnore),m_JobNameOrig(nilIgnore),m_isProtectedOrig(nilIgnore),m_StateOrig(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("UpdateDFUWorkunit");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CUpdateDFUWorkunit::CUpdateDFUWorkunit(const char *serviceName, const char *bc)
	: m_wu(serviceName, nilIgnore),m_ClusterOrig(nilIgnore),m_JobNameOrig(nilIgnore),m_isProtectedOrig(nilIgnore),m_StateOrig(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("UpdateDFUWorkunit");
}

CUpdateDFUWorkunit::CUpdateDFUWorkunit(const char *serviceName, IRpcMessage* rpcmsg)
	: m_wu(serviceName, nilIgnore),m_ClusterOrig(nilIgnore),m_JobNameOrig(nilIgnore),m_isProtectedOrig(nilIgnore),m_StateOrig(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("UpdateDFUWorkunit");
	unserialize(*rpcmsg,NULL,NULL);
}

CUpdateDFUWorkunit::CUpdateDFUWorkunit(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_wu(serviceName, nilIgnore),m_ClusterOrig(nilIgnore),m_JobNameOrig(nilIgnore),m_isProtectedOrig(nilIgnore),m_StateOrig(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("UpdateDFUWorkunit");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CUpdateDFUWorkunit::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"wu\" type=\"tns:DFUWorkunit\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"ClusterOrig\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"JobNameOrig\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"isProtectedOrig\" type=\"xsd:boolean\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"StateOrig\" type=\"xsd:int\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	if (!(flags & 0x10)  || (flags & 0x100))
	{
		CDFUWorkunit::getXsdDefinition(context, request, schema, added);
	}
	return schema;
}

void CUpdateDFUWorkunit::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CUpdateDFUWorkunit::getMapInfo(IMapInfo& info, BoolHash& added)
{
	if (!added.getValue("DFUWorkunit"))
	{
		added.setValue("DFUWorkunit",1);
		CDFUWorkunit::getMapInfo(info,added);
	}
}

StringBuffer &CUpdateDFUWorkunit::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("wu");
	form.append("<tr>").append("<td><b>wu: </b></td><td><hr/>");
	CDFUWorkunit::getHtmlForm(context, request, serv, method, form, false, extfix.str());
	form.append("<hr/></td></tr>");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("ClusterOrig");
	form.appendf("  <tr><td><b>ClusterOrig: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("JobNameOrig");
	form.appendf("  <tr><td><b>JobNameOrig: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("isProtectedOrig");
	
	form.appendf("  <tr><td><b>isProtectedOrig? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	extfix.clear();
	if (prefix && *prefix) extfix.append(prefix).append(".");
		extfix.append("StateOrig");
	form.appendf("  <tr><td><b>StateOrig: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CUpdateDFUWorkunit::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CUpdateDFUWorkunit::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_wu.marshall(rpc_resp, "wu", "", "", "");
	m_ClusterOrig.marshall(rpc_resp, "ClusterOrig", "", "", "");
	m_JobNameOrig.marshall(rpc_resp, "JobNameOrig", "", "", "");
	m_isProtectedOrig.marshall(rpc_resp, "isProtectedOrig", "", "", "");
	m_StateOrig.marshall(rpc_resp, "StateOrig", "", "", "");
}


void CUpdateDFUWorkunit::copy(CUpdateDFUWorkunit &from)
{
	m_wu.copy(from.m_wu);
	m_ClusterOrig.copy(from.m_ClusterOrig);
	m_JobNameOrig.copy(from.m_JobNameOrig);
	m_isProtectedOrig.copy(from.m_isProtectedOrig);
	m_StateOrig.copy(from.m_StateOrig);
}


void CUpdateDFUWorkunit::copy(IConstUpdateDFUWorkunit &ifrom)
{
	setWu(ifrom.getWu());
	setClusterOrig(ifrom.getClusterOrig());
	setJobNameOrig(ifrom.getJobNameOrig());
	setIsProtectedOrig(ifrom.getIsProtectedOrig());
	setStateOrig(ifrom.getStateOrig());
}


void CUpdateDFUWorkunit::getAttributes(IProperties &attributes)
{
}


void CUpdateDFUWorkunit::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_wu.toStr(ctx, buffer, "wu", "", false, "", "");
	m_ClusterOrig.toStr(ctx, buffer, "ClusterOrig", "", true, "", "");
	m_JobNameOrig.toStr(ctx, buffer, "JobNameOrig", "", true, "", "");
	m_isProtectedOrig.toStr(ctx, buffer, "isProtectedOrig", "", true, "", "");
	m_StateOrig.toStr(ctx, buffer, "StateOrig", "", true, "", "");
}


void CUpdateDFUWorkunit::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CUpdateDFUWorkunit::serializer(IEspContext* ctx, IConstUpdateDFUWorkunit &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<UpdateDFUWorkunit>");
	// field wu
	{
		StringBuffer tmp;
		CDFUWorkunit::serializer(ctx,src.getWu(), tmp, false);
		if (tmp.length()>0)
			buffer.appendf("<wu>%s</wu>",tmp.str());
	}
	// field ClusterOrig
	{
		const char* s = src.getClusterOrig();
		if (s && *s)
		{
			buffer.append("<ClusterOrig>");
			encodeUtf8XML(s,buffer);
			buffer.append("</ClusterOrig>");
		}
	}
	// field JobNameOrig
	{
		const char* s = src.getJobNameOrig();
		if (s && *s)
		{
			buffer.append("<JobNameOrig>");
			encodeUtf8XML(s,buffer);
			buffer.append("</JobNameOrig>");
		}
	}
	// field isProtectedOrig
	{
		bool b = src.getIsProtectedOrig();
		if (b)
			buffer.appendf("<isProtectedOrig>1</isProtectedOrig>");
	}
	// field StateOrig
	{
		int n = src.getStateOrig();
		if (n)
			buffer.appendf("<StateOrig>%d</StateOrig>", n);
	}
	if (keepRootTag)
		buffer.append("</UpdateDFUWorkunit>");
}

bool CUpdateDFUWorkunit::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_wu.unmarshall(rpc_request, "wu", basepath);
	hasValue |= m_ClusterOrig.unmarshall(rpc_request, "ClusterOrig", basepath);
	hasValue |= m_JobNameOrig.unmarshall(rpc_request, "JobNameOrig", basepath);
	hasValue |= m_isProtectedOrig.unmarshall(rpc_request, "isProtectedOrig", basepath);
	hasValue |= m_StateOrig.unmarshall(rpc_request, "StateOrig", basepath);
	return hasValue;
}

bool CUpdateDFUWorkunit::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_wu.unmarshall(ctx, soapval, "wu");
	hasValue |= m_ClusterOrig.unmarshall(ctx, soapval, "ClusterOrig");
	hasValue |= m_JobNameOrig.unmarshall(ctx, soapval, "JobNameOrig");
	hasValue |= m_isProtectedOrig.unmarshall(ctx, soapval, "isProtectedOrig");
	hasValue |= m_StateOrig.unmarshall(ctx, soapval, "StateOrig");
	return hasValue;
}

bool CUpdateDFUWorkunit::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_wu.unmarshall(ctx, params, attachments, "wu", basepath);
	hasValue |= m_ClusterOrig.unmarshall(ctx, params, attachments, "ClusterOrig", basepath);
	hasValue |= m_JobNameOrig.unmarshall(ctx, params, attachments, "JobNameOrig", basepath);
	hasValue |= m_isProtectedOrig.unmarshall(ctx, params, attachments, "isProtectedOrig", basepath);
	hasValue |= m_StateOrig.unmarshall(ctx, params, attachments, "StateOrig", basepath);
	return hasValue;
}

IConstDFUWorkunit & CUpdateDFUWorkunit::getWu() { return (IConstDFUWorkunit &) m_wu.getValue();}
const char * CUpdateDFUWorkunit::getClusterOrig() { return m_ClusterOrig.query();}
const char * CUpdateDFUWorkunit::getJobNameOrig() { return m_JobNameOrig.query();}
bool CUpdateDFUWorkunit::getIsProtectedOrig() { return m_isProtectedOrig;}
int CUpdateDFUWorkunit::getStateOrig() { return m_StateOrig;}
IEspDFUWorkunit & CUpdateDFUWorkunit::updateWu(){ return (IEspDFUWorkunit &) m_wu.getValue(); }
void CUpdateDFUWorkunit::setWu(IConstDFUWorkunit &ifrom){ m_wu.copy(ifrom); }
void CUpdateDFUWorkunit::setClusterOrig(const char * val){ m_ClusterOrig.set(val); }
void CUpdateDFUWorkunit::setJobNameOrig(const char * val){ m_JobNameOrig.set(val); }
void CUpdateDFUWorkunit::setIsProtectedOrig(bool val){ m_isProtectedOrig=val; }
void CUpdateDFUWorkunit::setStateOrig(int val){ m_StateOrig=val; }
extern "C"  IEspUpdateDFUWorkunit *createUpdateDFUWorkunit(const char *serv){return ((IEspUpdateDFUWorkunit *)new CUpdateDFUWorkunit(serv));}
extern "C"  IClientUpdateDFUWorkunit *createClientUpdateDFUWorkunit(const char *serv){return ((IClientUpdateDFUWorkunit *)new CUpdateDFUWorkunit(serv));}

//=======================================================
// class CUpdateDFUWorkunitResponse Implementation
//=======================================================

CUpdateDFUWorkunitResponse::CUpdateDFUWorkunitResponse(const char *serviceName, IRpcMessageBinding *init)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("UpdateDFUWorkunitResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CUpdateDFUWorkunitResponse::CUpdateDFUWorkunitResponse(const char *serviceName, const char *bc)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("UpdateDFUWorkunitResponse");
}

CUpdateDFUWorkunitResponse::CUpdateDFUWorkunitResponse(const char *serviceName, IRpcMessage* rpcmsg)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("UpdateDFUWorkunitResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CUpdateDFUWorkunitResponse::CUpdateDFUWorkunitResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("UpdateDFUWorkunitResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CUpdateDFUWorkunitResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		schema.append("<xsd:element name=\"Exceptions\" type=\"tns:ArrayOfEspException\" minOccurs=\"0\" maxOccurs=\"1\"/>");
		}
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CUpdateDFUWorkunitResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CUpdateDFUWorkunitResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CUpdateDFUWorkunitResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CUpdateDFUWorkunitResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CUpdateDFUWorkunitResponse::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
	}
}


void CUpdateDFUWorkunitResponse::copy(CUpdateDFUWorkunitResponse &from)
{
}


void CUpdateDFUWorkunitResponse::copy(IConstUpdateDFUWorkunitResponse &ifrom)
{
}


void CUpdateDFUWorkunitResponse::getAttributes(IProperties &attributes)
{
}


void CUpdateDFUWorkunitResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
	}
}


void CUpdateDFUWorkunitResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CUpdateDFUWorkunitResponse::serializer(IEspContext* ctx, IConstUpdateDFUWorkunitResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<UpdateDFUWorkunitResponse>");
	if (keepRootTag)
		buffer.append("</UpdateDFUWorkunitResponse>");
}

bool CUpdateDFUWorkunitResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
	}
	return hasValue;
}

bool CUpdateDFUWorkunitResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	return hasValue;
}

bool CUpdateDFUWorkunitResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	return hasValue;
}

extern "C"  IEspUpdateDFUWorkunitResponse *createUpdateDFUWorkunitResponse(const char *serv){return ((IEspUpdateDFUWorkunitResponse *)new CUpdateDFUWorkunitResponse(serv));}
extern "C"  IClientUpdateDFUWorkunitResponse *createClientUpdateDFUWorkunitResponse(const char *serv){return ((IClientUpdateDFUWorkunitResponse *)new CUpdateDFUWorkunitResponse(serv));}

//=======================================================
// class CDeleteDFUWorkunit Implementation
//=======================================================

CDeleteDFUWorkunit::CDeleteDFUWorkunit(const char *serviceName, IRpcMessageBinding *init)
	: m_wuid(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("DeleteDFUWorkunit");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CDeleteDFUWorkunit::CDeleteDFUWorkunit(const char *serviceName, const char *bc)
	: m_wuid(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("DeleteDFUWorkunit");
}

CDeleteDFUWorkunit::CDeleteDFUWorkunit(const char *serviceName, IRpcMessage* rpcmsg)
	: m_wuid(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("DeleteDFUWorkunit");
	unserialize(*rpcmsg,NULL,NULL);
}

CDeleteDFUWorkunit::CDeleteDFUWorkunit(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_wuid(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("DeleteDFUWorkunit");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CDeleteDFUWorkunit::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"wuid\" type=\"xsd:string\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CDeleteDFUWorkunit::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CDeleteDFUWorkunit::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CDeleteDFUWorkunit::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("wuid");
	form.appendf("  <tr><td><b>wuid: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CDeleteDFUWorkunit::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CDeleteDFUWorkunit::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_wuid.marshall(rpc_resp, "wuid", "", "", "");
}


void CDeleteDFUWorkunit::copy(CDeleteDFUWorkunit &from)
{
	m_wuid.copy(from.m_wuid);
}


void CDeleteDFUWorkunit::copy(IConstDeleteDFUWorkunit &ifrom)
{
	setWuid(ifrom.getWuid());
}


void CDeleteDFUWorkunit::getAttributes(IProperties &attributes)
{
}


void CDeleteDFUWorkunit::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_wuid.toStr(ctx, buffer, "wuid", "", true, "", "");
}


void CDeleteDFUWorkunit::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CDeleteDFUWorkunit::serializer(IEspContext* ctx, IConstDeleteDFUWorkunit &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<DeleteDFUWorkunit>");
	// field wuid
	{
		const char* s = src.getWuid();
		if (s && *s)
		{
			buffer.append("<wuid>");
			encodeUtf8XML(s,buffer);
			buffer.append("</wuid>");
		}
	}
	if (keepRootTag)
		buffer.append("</DeleteDFUWorkunit>");
}

bool CDeleteDFUWorkunit::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_wuid.unmarshall(rpc_request, "wuid", basepath);
	return hasValue;
}

bool CDeleteDFUWorkunit::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_wuid.unmarshall(ctx, soapval, "wuid");
	return hasValue;
}

bool CDeleteDFUWorkunit::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_wuid.unmarshall(ctx, params, attachments, "wuid", basepath);
	return hasValue;
}

const char * CDeleteDFUWorkunit::getWuid() { return m_wuid.query();}
void CDeleteDFUWorkunit::setWuid(const char * val){ m_wuid.set(val); }
extern "C"  IEspDeleteDFUWorkunit *createDeleteDFUWorkunit(const char *serv){return ((IEspDeleteDFUWorkunit *)new CDeleteDFUWorkunit(serv));}
extern "C"  IClientDeleteDFUWorkunit *createClientDeleteDFUWorkunit(const char *serv){return ((IClientDeleteDFUWorkunit *)new CDeleteDFUWorkunit(serv));}

//=======================================================
// class CDeleteDFUWorkunitResponse Implementation
//=======================================================

CDeleteDFUWorkunitResponse::CDeleteDFUWorkunitResponse(const char *serviceName, IRpcMessageBinding *init)
	: m_result(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("DeleteDFUWorkunitResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CDeleteDFUWorkunitResponse::CDeleteDFUWorkunitResponse(const char *serviceName, const char *bc)
	: m_result(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("DeleteDFUWorkunitResponse");
}

CDeleteDFUWorkunitResponse::CDeleteDFUWorkunitResponse(const char *serviceName, IRpcMessage* rpcmsg)
	: m_result(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("DeleteDFUWorkunitResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CDeleteDFUWorkunitResponse::CDeleteDFUWorkunitResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_result(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("DeleteDFUWorkunitResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CDeleteDFUWorkunitResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		schema.append("<xsd:element name=\"Exceptions\" type=\"tns:ArrayOfEspException\" minOccurs=\"0\" maxOccurs=\"1\"/>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"result\" type=\"xsd:boolean\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CDeleteDFUWorkunitResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CDeleteDFUWorkunitResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CDeleteDFUWorkunitResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("result");
	
	form.appendf("  <tr><td><b>result? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CDeleteDFUWorkunitResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CDeleteDFUWorkunitResponse::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
		m_result.marshall(rpc_resp, "result", "", "", "");
	}
}


void CDeleteDFUWorkunitResponse::copy(CDeleteDFUWorkunitResponse &from)
{
	m_result.copy(from.m_result);
}


void CDeleteDFUWorkunitResponse::copy(IConstDeleteDFUWorkunitResponse &ifrom)
{
	setResult(ifrom.getResult());
}


void CDeleteDFUWorkunitResponse::getAttributes(IProperties &attributes)
{
}


void CDeleteDFUWorkunitResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
		m_result.toStr(ctx, buffer, "result", "", true, "", "");
	}
}


void CDeleteDFUWorkunitResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CDeleteDFUWorkunitResponse::serializer(IEspContext* ctx, IConstDeleteDFUWorkunitResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<DeleteDFUWorkunitResponse>");
	// field result
	{
		bool b = src.getResult();
		if (b)
			buffer.appendf("<result>1</result>");
	}
	if (keepRootTag)
		buffer.append("</DeleteDFUWorkunitResponse>");
}

bool CDeleteDFUWorkunitResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
		hasValue |= m_result.unmarshall(rpc_request, "result", basepath);
	}
	return hasValue;
}

bool CDeleteDFUWorkunitResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_result.unmarshall(ctx, soapval, "result");
	return hasValue;
}

bool CDeleteDFUWorkunitResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_result.unmarshall(ctx, params, attachments, "result", basepath);
	return hasValue;
}

bool CDeleteDFUWorkunitResponse::getResult() { return m_result;}
void CDeleteDFUWorkunitResponse::setResult(bool val){ m_result=val; }
extern "C"  IEspDeleteDFUWorkunitResponse *createDeleteDFUWorkunitResponse(const char *serv){return ((IEspDeleteDFUWorkunitResponse *)new CDeleteDFUWorkunitResponse(serv));}
extern "C"  IClientDeleteDFUWorkunitResponse *createClientDeleteDFUWorkunitResponse(const char *serv){return ((IClientDeleteDFUWorkunitResponse *)new CDeleteDFUWorkunitResponse(serv));}

//=======================================================
// class CDeleteDFUWorkunits Implementation
//=======================================================

CDeleteDFUWorkunits::CDeleteDFUWorkunits(const char *serviceName, IRpcMessageBinding *init)
	: m_wuids(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("DeleteDFUWorkunits");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CDeleteDFUWorkunits::CDeleteDFUWorkunits(const char *serviceName, const char *bc)
	: m_wuids(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("DeleteDFUWorkunits");
}

CDeleteDFUWorkunits::CDeleteDFUWorkunits(const char *serviceName, IRpcMessage* rpcmsg)
	: m_wuids(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("DeleteDFUWorkunits");
	unserialize(*rpcmsg,NULL,NULL);
}

CDeleteDFUWorkunits::CDeleteDFUWorkunits(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_wuids(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("DeleteDFUWorkunits");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CDeleteDFUWorkunits::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"wuids\" type=\"tns:EspStringArray\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	if (added.getValue("EspStringArray")==NULL) {
		addEspNativeArray(schema,"string","EspStringArray");
		added.setValue("EspStringArray",1);
	}
	return schema;
}

void CDeleteDFUWorkunits::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CDeleteDFUWorkunits::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CDeleteDFUWorkunits::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("wuids");
	form.appendf("<tr><td><b>wuids: </b></td><td>");
	form.appendf("<textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea>", extfix.str());
	form.append("</td></tr>");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CDeleteDFUWorkunits::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CDeleteDFUWorkunits::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_wuids.marshall(rpc_resp, "wuids", "Item");
}


void CDeleteDFUWorkunits::copy(CDeleteDFUWorkunits &from)
{
	m_wuids.copy(from.m_wuids);
}


void CDeleteDFUWorkunits::copy(IConstDeleteDFUWorkunits &ifrom)
{
	setWuids(ifrom.getWuids());
}


void CDeleteDFUWorkunits::getAttributes(IProperties &attributes)
{
}


void CDeleteDFUWorkunits::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_wuids.toStr(ctx, buffer, "wuids", "Item");
}


void CDeleteDFUWorkunits::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CDeleteDFUWorkunits::serializer(IEspContext* ctx, IConstDeleteDFUWorkunits &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<DeleteDFUWorkunits>");
	// field wuids
	{
		StringArray& v = src.getWuids();
		if (v.length()>0)
			buffer.append("<wuids>");
		for (size32_t i=0;i<v.length();i++)
			buffer.appendf("<Item>%s</Item>",v.item(i));
		if (v.length()>0)
			buffer.append("</wuids>");
	}
	if (keepRootTag)
		buffer.append("</DeleteDFUWorkunits>");
}

bool CDeleteDFUWorkunits::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_wuids.unmarshall(rpc_request, "wuids", basepath);
	return hasValue;
}

bool CDeleteDFUWorkunits::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_wuids.unmarshall(ctx, soapval, "wuids");
	return hasValue;
}

bool CDeleteDFUWorkunits::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_wuids.unmarshall(ctx, params, attachments, "wuids", basepath);
	return hasValue;
}

StringArray & CDeleteDFUWorkunits::getWuids() { return (StringArray &) m_wuids; }
void CDeleteDFUWorkunits::setWuids(StringArray &val){ m_wuids->kill();  CloneArray(m_wuids.getValue(), val); }
extern "C"  IEspDeleteDFUWorkunits *createDeleteDFUWorkunits(const char *serv){return ((IEspDeleteDFUWorkunits *)new CDeleteDFUWorkunits(serv));}
extern "C"  IClientDeleteDFUWorkunits *createClientDeleteDFUWorkunits(const char *serv){return ((IClientDeleteDFUWorkunits *)new CDeleteDFUWorkunits(serv));}

//=======================================================
// class CDeleteDFUWorkunitsResponse Implementation
//=======================================================

CDeleteDFUWorkunitsResponse::CDeleteDFUWorkunitsResponse(const char *serviceName, IRpcMessageBinding *init)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("DeleteDFUWorkunitsResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CDeleteDFUWorkunitsResponse::CDeleteDFUWorkunitsResponse(const char *serviceName, const char *bc)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("DeleteDFUWorkunitsResponse");
}

CDeleteDFUWorkunitsResponse::CDeleteDFUWorkunitsResponse(const char *serviceName, IRpcMessage* rpcmsg)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("DeleteDFUWorkunitsResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CDeleteDFUWorkunitsResponse::CDeleteDFUWorkunitsResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("DeleteDFUWorkunitsResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CDeleteDFUWorkunitsResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		schema.append("<xsd:element name=\"Exceptions\" type=\"tns:ArrayOfEspException\" minOccurs=\"0\" maxOccurs=\"1\"/>");
		}
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CDeleteDFUWorkunitsResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CDeleteDFUWorkunitsResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CDeleteDFUWorkunitsResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CDeleteDFUWorkunitsResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CDeleteDFUWorkunitsResponse::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
	}
}


void CDeleteDFUWorkunitsResponse::copy(CDeleteDFUWorkunitsResponse &from)
{
}


void CDeleteDFUWorkunitsResponse::copy(IConstDeleteDFUWorkunitsResponse &ifrom)
{
}


void CDeleteDFUWorkunitsResponse::getAttributes(IProperties &attributes)
{
}


void CDeleteDFUWorkunitsResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
	}
}


void CDeleteDFUWorkunitsResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CDeleteDFUWorkunitsResponse::serializer(IEspContext* ctx, IConstDeleteDFUWorkunitsResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<DeleteDFUWorkunitsResponse>");
	if (keepRootTag)
		buffer.append("</DeleteDFUWorkunitsResponse>");
}

bool CDeleteDFUWorkunitsResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
	}
	return hasValue;
}

bool CDeleteDFUWorkunitsResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	return hasValue;
}

bool CDeleteDFUWorkunitsResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	return hasValue;
}

extern "C"  IEspDeleteDFUWorkunitsResponse *createDeleteDFUWorkunitsResponse(const char *serv){return ((IEspDeleteDFUWorkunitsResponse *)new CDeleteDFUWorkunitsResponse(serv));}
extern "C"  IClientDeleteDFUWorkunitsResponse *createClientDeleteDFUWorkunitsResponse(const char *serv){return ((IClientDeleteDFUWorkunitsResponse *)new CDeleteDFUWorkunitsResponse(serv));}

//=======================================================
// class CDFUWorkunitsActionRequest Implementation
//=======================================================

CDFUWorkunitsActionRequest::CDFUWorkunitsActionRequest(const char *serviceName, IRpcMessageBinding *init)
	: m_wuids(nilIgnore),m_Type(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("DFUWorkunitsActionRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CDFUWorkunitsActionRequest::CDFUWorkunitsActionRequest(const char *serviceName, const char *bc)
	: m_wuids(nilIgnore),m_Type(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("DFUWorkunitsActionRequest");
}

CDFUWorkunitsActionRequest::CDFUWorkunitsActionRequest(const char *serviceName, IRpcMessage* rpcmsg)
	: m_wuids(nilIgnore),m_Type(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("DFUWorkunitsActionRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CDFUWorkunitsActionRequest::CDFUWorkunitsActionRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_wuids(nilIgnore),m_Type(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("DFUWorkunitsActionRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CDFUWorkunitsActionRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"wuids\" type=\"tns:EspStringArray\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Type\" type=\"tns:DFUWUActions\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	if (!(flags & 0x10)  || (flags & 0x100))
	{
		CXDFUWUActions::getXsdDefinition(context, request, schema, added);
	}
	if (added.getValue("EspStringArray")==NULL) {
		addEspNativeArray(schema,"string","EspStringArray");
		added.setValue("EspStringArray",1);
	}
	return schema;
}

void CDFUWorkunitsActionRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CDFUWorkunitsActionRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
	if (!added.getValue("DFUWUActions"))
	{
		added.setValue("DFUWUActions",1);
		CXDFUWUActions::getMapInfo(info,added);
	}
}

StringBuffer &CDFUWorkunitsActionRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("wuids");
	form.appendf("<tr><td><b>wuids: </b></td><td>");
	form.appendf("<textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea>", extfix.str());
	form.append("</td></tr>");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Type");
	form.appendf("  <tr><td><b>Type: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CDFUWorkunitsActionRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CDFUWorkunitsActionRequest::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_wuids.marshall(rpc_resp, "wuids", "Item");
	m_Type.marshall(rpc_resp, "Type", "", "", "");
}


void CDFUWorkunitsActionRequest::copy(CDFUWorkunitsActionRequest &from)
{
	m_wuids.copy(from.m_wuids);
	m_Type.copy(from.m_Type);
}


void CDFUWorkunitsActionRequest::copy(IConstDFUWorkunitsActionRequest &ifrom)
{
	setWuids(ifrom.getWuids());
	setType(ifrom.getType());
}


void CDFUWorkunitsActionRequest::getAttributes(IProperties &attributes)
{
}


void CDFUWorkunitsActionRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_wuids.toStr(ctx, buffer, "wuids", "Item");
	m_Type.toStr(ctx, buffer, "Type", "", true, "", "");
}


void CDFUWorkunitsActionRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CDFUWorkunitsActionRequest::serializer(IEspContext* ctx, IConstDFUWorkunitsActionRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<DFUWorkunitsActionRequest>");
	// field wuids
	{
		StringArray& v = src.getWuids();
		if (v.length()>0)
			buffer.append("<wuids>");
		for (size32_t i=0;i<v.length();i++)
			buffer.appendf("<Item>%s</Item>",v.item(i));
		if (v.length()>0)
			buffer.append("</wuids>");
	}
	// field Type
	{
		const char* s = src.getTypeAsString();
		buffer.append("<Type>");
		encodeUtf8XML(s,buffer);
		buffer.append("</Type>");
	}
	if (keepRootTag)
		buffer.append("</DFUWorkunitsActionRequest>");
}

bool CDFUWorkunitsActionRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_wuids.unmarshall(rpc_request, "wuids", basepath);
	hasValue |= m_Type.unmarshall(rpc_request, "Type", basepath);
	return hasValue;
}

bool CDFUWorkunitsActionRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_wuids.unmarshall(ctx, soapval, "wuids");
	hasValue |= m_Type.unmarshall(ctx, soapval, "Type");
	return hasValue;
}

bool CDFUWorkunitsActionRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_wuids.unmarshall(ctx, params, attachments, "wuids", basepath);
	hasValue |= m_Type.unmarshall(ctx, params, attachments, "Type", basepath);
	return hasValue;
}

StringArray & CDFUWorkunitsActionRequest::getWuids() { return (StringArray &) m_wuids; }
CDFUWUActions CDFUWorkunitsActionRequest::getType() { return m_Type.getValue(); }
const char* CDFUWorkunitsActionRequest::getTypeAsString() {  return (const char*)m_Type; }
void CDFUWorkunitsActionRequest::setWuids(StringArray &val){ m_wuids->kill();  CloneArray(m_wuids.getValue(), val); }
void CDFUWorkunitsActionRequest::setType(CDFUWUActions val) { m_Type.setValue(val); }
void CDFUWorkunitsActionRequest::setType(const char* val) { m_Type.setValue(val); }
extern "C"  IEspDFUWorkunitsActionRequest *createDFUWorkunitsActionRequest(const char *serv){return ((IEspDFUWorkunitsActionRequest *)new CDFUWorkunitsActionRequest(serv));}
extern "C"  IClientDFUWorkunitsActionRequest *createClientDFUWorkunitsActionRequest(const char *serv){return ((IClientDFUWorkunitsActionRequest *)new CDFUWorkunitsActionRequest(serv));}

//=======================================================
// class CDFUWorkunitsActionResponse Implementation
//=======================================================

CDFUWorkunitsActionResponse::CDFUWorkunitsActionResponse(const char *serviceName, IRpcMessageBinding *init)
	: m_FirstColumn("WUID", nilIgnore),m_DFUActionResults(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("DFUWorkunitsActionResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CDFUWorkunitsActionResponse::CDFUWorkunitsActionResponse(const char *serviceName, const char *bc)
	: m_FirstColumn("WUID", nilIgnore),m_DFUActionResults(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("DFUWorkunitsActionResponse");
}

CDFUWorkunitsActionResponse::CDFUWorkunitsActionResponse(const char *serviceName, IRpcMessage* rpcmsg)
	: m_FirstColumn("WUID", nilIgnore),m_DFUActionResults(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("DFUWorkunitsActionResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CDFUWorkunitsActionResponse::CDFUWorkunitsActionResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_FirstColumn("WUID", nilIgnore),m_DFUActionResults(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("DFUWorkunitsActionResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CDFUWorkunitsActionResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		schema.append("<xsd:element name=\"Exceptions\" type=\"tns:ArrayOfEspException\" minOccurs=\"0\" maxOccurs=\"1\"/>");
		}
		schema.append("<xsd:element minOccurs=\"0\" default=\"WUID\" name=\"FirstColumn\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"DFUActionResults\" type=\"tns:ArrayOfDFUActionResult\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	if (!(flags & 0x10)  || (flags & 0x100))
	{
		CDFUActionResult::getXsdDefinition(context, request, schema, added);
	}
	if (added.getValue("DFUActionResult") && added.getValue("ArrayOfDFUActionResult")==NULL) {
		schema.append("<xsd:complexType name=\"ArrayOfDFUActionResult\">\n");
		schema.append("<xsd:sequence>\n");
		schema.append("<xsd:element minOccurs=\"0\" maxOccurs=\"unbounded\" name=\"DFUActionResult\" type=\"tns:DFUActionResult\"/>\n");
		schema.append("</xsd:sequence>\n");
		schema.append("</xsd:complexType>\n");
		added.setValue("ArrayOfDFUActionResult",1);
	}
	return schema;
}

void CDFUWorkunitsActionResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CDFUWorkunitsActionResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
	if (!added.getValue("DFUActionResult"))
	{
		added.setValue("DFUActionResult",1);
		CDFUActionResult::getMapInfo(info,added);
	}
}

StringBuffer &CDFUWorkunitsActionResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("FirstColumn");
	form.appendf("  <tr><td><b>FirstColumn: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"WUID\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("DFUActionResults");
	form.appendf("<tr><td><b>DFUActionResults: </b></td><td>");
	form.appendf("<table><tr><td><textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea></td>", extfix.str());
	form.append("</tr></table>");
	form.append("</td></tr>");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CDFUWorkunitsActionResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CDFUWorkunitsActionResponse::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
		m_FirstColumn.marshall(rpc_resp, "FirstColumn", "", "", "");
		m_DFUActionResults.marshall(rpc_resp, "DFUActionResults", "DFUActionResult");
	}
}


void CDFUWorkunitsActionResponse::copy(CDFUWorkunitsActionResponse &from)
{
	m_FirstColumn.copy(from.m_FirstColumn);
	m_DFUActionResults.copy(from.m_DFUActionResults);
}


void CDFUWorkunitsActionResponse::copy(IConstDFUWorkunitsActionResponse &ifrom)
{
	setFirstColumn(ifrom.getFirstColumn());
	setDFUActionResults(ifrom.getDFUActionResults());
}


void CDFUWorkunitsActionResponse::getAttributes(IProperties &attributes)
{
}


void CDFUWorkunitsActionResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
		m_FirstColumn.toStr(ctx, buffer, "FirstColumn", "", true, "", "");
		m_DFUActionResults.toStr(ctx, buffer, "DFUActionResults", "DFUActionResult");
	}
}


void CDFUWorkunitsActionResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CDFUWorkunitsActionResponse::serializer(IEspContext* ctx, IConstDFUWorkunitsActionResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<DFUWorkunitsActionResponse>");
	// field FirstColumn
	{
		const char* s = src.getFirstColumn();
		if (s && *s)
		{
			buffer.append("<FirstColumn>");
			encodeUtf8XML(s,buffer);
			buffer.append("</FirstColumn>");
		}
	}
	// field DFUActionResults
	{
		IArrayOf<IConstDFUActionResult>& v = src.getDFUActionResults();
		int size = v.length();
		if (size>0)
			buffer.append("<DFUActionResults>");
		for (int i=0;i<size;i++)
		{
			buffer.append("<Item>");
			CDFUActionResult::serializer(ctx,v.item(i),buffer,false);
			buffer.append("</Item>");
		}
		if (size>0)
			buffer.append("</DFUActionResults>");
	}
	if (keepRootTag)
		buffer.append("</DFUWorkunitsActionResponse>");
}

bool CDFUWorkunitsActionResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
		hasValue |= m_FirstColumn.unmarshall(rpc_request, "FirstColumn", basepath);
		hasValue |= m_DFUActionResults.unmarshall(rpc_request, "DFUActionResults", basepath);
	}
	return hasValue;
}

bool CDFUWorkunitsActionResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_FirstColumn.unmarshall(ctx, soapval, "FirstColumn");
	hasValue |= m_DFUActionResults.unmarshall(ctx, soapval, "DFUActionResults");
	return hasValue;
}

bool CDFUWorkunitsActionResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_FirstColumn.unmarshall(ctx, params, attachments, "FirstColumn", basepath);
	hasValue |= m_DFUActionResults.unmarshall(ctx, params, attachments, "DFUActionResults", basepath);
	return hasValue;
}

const char * CDFUWorkunitsActionResponse::getFirstColumn() { return m_FirstColumn.query();}
IArrayOf<IConstDFUActionResult> & CDFUWorkunitsActionResponse::getDFUActionResults() { return (IArrayOf<IConstDFUActionResult> &) m_DFUActionResults; }
void CDFUWorkunitsActionResponse::setFirstColumn(const char * val){ m_FirstColumn.set(val); }
void CDFUWorkunitsActionResponse::setDFUActionResults(IArrayOf<IEspDFUActionResult> &val)
{
	m_DFUActionResults->kill();
	IArrayOf<IConstDFUActionResult> &target = m_DFUActionResults.getValue();
	ForEachItemIn(idx, val)
	{
		IEspDFUActionResult &item = (val).item(idx);
		item.Link();
		target.append(item);
	}
}
void CDFUWorkunitsActionResponse::setDFUActionResults(IArrayOf<IConstDFUActionResult> &val)
{
	m_DFUActionResults->kill();
	IArrayOf<IConstDFUActionResult> &target = m_DFUActionResults.getValue();
	ForEachItemIn(idx, val)
	{
		IConstDFUActionResult &item = val.item(idx);
		item.Link();
		target.append(item);
	}
}
extern "C"  IEspDFUWorkunitsActionResponse *createDFUWorkunitsActionResponse(const char *serv){return ((IEspDFUWorkunitsActionResponse *)new CDFUWorkunitsActionResponse(serv));}
extern "C"  IClientDFUWorkunitsActionResponse *createClientDFUWorkunitsActionResponse(const char *serv){return ((IClientDFUWorkunitsActionResponse *)new CDFUWorkunitsActionResponse(serv));}

//=======================================================
// class CSubmitDFUWorkunit Implementation
//=======================================================

CSubmitDFUWorkunit::CSubmitDFUWorkunit(const char *serviceName, IRpcMessageBinding *init)
	: m_wuid(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("SubmitDFUWorkunit");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CSubmitDFUWorkunit::CSubmitDFUWorkunit(const char *serviceName, const char *bc)
	: m_wuid(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("SubmitDFUWorkunit");
}

CSubmitDFUWorkunit::CSubmitDFUWorkunit(const char *serviceName, IRpcMessage* rpcmsg)
	: m_wuid(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("SubmitDFUWorkunit");
	unserialize(*rpcmsg,NULL,NULL);
}

CSubmitDFUWorkunit::CSubmitDFUWorkunit(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_wuid(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("SubmitDFUWorkunit");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CSubmitDFUWorkunit::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"wuid\" type=\"xsd:string\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CSubmitDFUWorkunit::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CSubmitDFUWorkunit::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CSubmitDFUWorkunit::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("wuid");
	form.appendf("  <tr><td><b>wuid: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CSubmitDFUWorkunit::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CSubmitDFUWorkunit::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_wuid.marshall(rpc_resp, "wuid", "", "", "");
}


void CSubmitDFUWorkunit::copy(CSubmitDFUWorkunit &from)
{
	m_wuid.copy(from.m_wuid);
}


void CSubmitDFUWorkunit::copy(IConstSubmitDFUWorkunit &ifrom)
{
	setWuid(ifrom.getWuid());
}


void CSubmitDFUWorkunit::getAttributes(IProperties &attributes)
{
}


void CSubmitDFUWorkunit::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_wuid.toStr(ctx, buffer, "wuid", "", true, "", "");
}


void CSubmitDFUWorkunit::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CSubmitDFUWorkunit::serializer(IEspContext* ctx, IConstSubmitDFUWorkunit &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<SubmitDFUWorkunit>");
	// field wuid
	{
		const char* s = src.getWuid();
		if (s && *s)
		{
			buffer.append("<wuid>");
			encodeUtf8XML(s,buffer);
			buffer.append("</wuid>");
		}
	}
	if (keepRootTag)
		buffer.append("</SubmitDFUWorkunit>");
}

bool CSubmitDFUWorkunit::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_wuid.unmarshall(rpc_request, "wuid", basepath);
	return hasValue;
}

bool CSubmitDFUWorkunit::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_wuid.unmarshall(ctx, soapval, "wuid");
	return hasValue;
}

bool CSubmitDFUWorkunit::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_wuid.unmarshall(ctx, params, attachments, "wuid", basepath);
	return hasValue;
}

const char * CSubmitDFUWorkunit::getWuid() { return m_wuid.query();}
void CSubmitDFUWorkunit::setWuid(const char * val){ m_wuid.set(val); }
extern "C"  IEspSubmitDFUWorkunit *createSubmitDFUWorkunit(const char *serv){return ((IEspSubmitDFUWorkunit *)new CSubmitDFUWorkunit(serv));}
extern "C"  IClientSubmitDFUWorkunit *createClientSubmitDFUWorkunit(const char *serv){return ((IClientSubmitDFUWorkunit *)new CSubmitDFUWorkunit(serv));}

//=======================================================
// class CSubmitDFUWorkunitResponse Implementation
//=======================================================

CSubmitDFUWorkunitResponse::CSubmitDFUWorkunitResponse(const char *serviceName, IRpcMessageBinding *init)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("SubmitDFUWorkunitResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CSubmitDFUWorkunitResponse::CSubmitDFUWorkunitResponse(const char *serviceName, const char *bc)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("SubmitDFUWorkunitResponse");
}

CSubmitDFUWorkunitResponse::CSubmitDFUWorkunitResponse(const char *serviceName, IRpcMessage* rpcmsg)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("SubmitDFUWorkunitResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CSubmitDFUWorkunitResponse::CSubmitDFUWorkunitResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("SubmitDFUWorkunitResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CSubmitDFUWorkunitResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		schema.append("<xsd:element name=\"Exceptions\" type=\"tns:ArrayOfEspException\" minOccurs=\"0\" maxOccurs=\"1\"/>");
		}
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CSubmitDFUWorkunitResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CSubmitDFUWorkunitResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CSubmitDFUWorkunitResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CSubmitDFUWorkunitResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CSubmitDFUWorkunitResponse::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
	}
}


void CSubmitDFUWorkunitResponse::copy(CSubmitDFUWorkunitResponse &from)
{
}


void CSubmitDFUWorkunitResponse::copy(IConstSubmitDFUWorkunitResponse &ifrom)
{
}


void CSubmitDFUWorkunitResponse::getAttributes(IProperties &attributes)
{
}


void CSubmitDFUWorkunitResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
	}
}


void CSubmitDFUWorkunitResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CSubmitDFUWorkunitResponse::serializer(IEspContext* ctx, IConstSubmitDFUWorkunitResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<SubmitDFUWorkunitResponse>");
	if (keepRootTag)
		buffer.append("</SubmitDFUWorkunitResponse>");
}

bool CSubmitDFUWorkunitResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
	}
	return hasValue;
}

bool CSubmitDFUWorkunitResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	return hasValue;
}

bool CSubmitDFUWorkunitResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	return hasValue;
}

extern "C"  IEspSubmitDFUWorkunitResponse *createSubmitDFUWorkunitResponse(const char *serv){return ((IEspSubmitDFUWorkunitResponse *)new CSubmitDFUWorkunitResponse(serv));}
extern "C"  IClientSubmitDFUWorkunitResponse *createClientSubmitDFUWorkunitResponse(const char *serv){return ((IClientSubmitDFUWorkunitResponse *)new CSubmitDFUWorkunitResponse(serv));}

//=======================================================
// class CAbortDFUWorkunit Implementation
//=======================================================

CAbortDFUWorkunit::CAbortDFUWorkunit(const char *serviceName, IRpcMessageBinding *init)
	: m_wuid(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("AbortDFUWorkunit");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CAbortDFUWorkunit::CAbortDFUWorkunit(const char *serviceName, const char *bc)
	: m_wuid(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("AbortDFUWorkunit");
}

CAbortDFUWorkunit::CAbortDFUWorkunit(const char *serviceName, IRpcMessage* rpcmsg)
	: m_wuid(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("AbortDFUWorkunit");
	unserialize(*rpcmsg,NULL,NULL);
}

CAbortDFUWorkunit::CAbortDFUWorkunit(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_wuid(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("AbortDFUWorkunit");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CAbortDFUWorkunit::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"wuid\" type=\"xsd:string\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CAbortDFUWorkunit::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CAbortDFUWorkunit::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CAbortDFUWorkunit::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("wuid");
	form.appendf("  <tr><td><b>wuid: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CAbortDFUWorkunit::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CAbortDFUWorkunit::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_wuid.marshall(rpc_resp, "wuid", "", "", "");
}


void CAbortDFUWorkunit::copy(CAbortDFUWorkunit &from)
{
	m_wuid.copy(from.m_wuid);
}


void CAbortDFUWorkunit::copy(IConstAbortDFUWorkunit &ifrom)
{
	setWuid(ifrom.getWuid());
}


void CAbortDFUWorkunit::getAttributes(IProperties &attributes)
{
}


void CAbortDFUWorkunit::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_wuid.toStr(ctx, buffer, "wuid", "", true, "", "");
}


void CAbortDFUWorkunit::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CAbortDFUWorkunit::serializer(IEspContext* ctx, IConstAbortDFUWorkunit &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<AbortDFUWorkunit>");
	// field wuid
	{
		const char* s = src.getWuid();
		if (s && *s)
		{
			buffer.append("<wuid>");
			encodeUtf8XML(s,buffer);
			buffer.append("</wuid>");
		}
	}
	if (keepRootTag)
		buffer.append("</AbortDFUWorkunit>");
}

bool CAbortDFUWorkunit::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_wuid.unmarshall(rpc_request, "wuid", basepath);
	return hasValue;
}

bool CAbortDFUWorkunit::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_wuid.unmarshall(ctx, soapval, "wuid");
	return hasValue;
}

bool CAbortDFUWorkunit::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_wuid.unmarshall(ctx, params, attachments, "wuid", basepath);
	return hasValue;
}

const char * CAbortDFUWorkunit::getWuid() { return m_wuid.query();}
void CAbortDFUWorkunit::setWuid(const char * val){ m_wuid.set(val); }
extern "C"  IEspAbortDFUWorkunit *createAbortDFUWorkunit(const char *serv){return ((IEspAbortDFUWorkunit *)new CAbortDFUWorkunit(serv));}
extern "C"  IClientAbortDFUWorkunit *createClientAbortDFUWorkunit(const char *serv){return ((IClientAbortDFUWorkunit *)new CAbortDFUWorkunit(serv));}

//=======================================================
// class CAbortDFUWorkunitResponse Implementation
//=======================================================

CAbortDFUWorkunitResponse::CAbortDFUWorkunitResponse(const char *serviceName, IRpcMessageBinding *init)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("AbortDFUWorkunitResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CAbortDFUWorkunitResponse::CAbortDFUWorkunitResponse(const char *serviceName, const char *bc)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("AbortDFUWorkunitResponse");
}

CAbortDFUWorkunitResponse::CAbortDFUWorkunitResponse(const char *serviceName, IRpcMessage* rpcmsg)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("AbortDFUWorkunitResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CAbortDFUWorkunitResponse::CAbortDFUWorkunitResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("AbortDFUWorkunitResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CAbortDFUWorkunitResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		schema.append("<xsd:element name=\"Exceptions\" type=\"tns:ArrayOfEspException\" minOccurs=\"0\" maxOccurs=\"1\"/>");
		}
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CAbortDFUWorkunitResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CAbortDFUWorkunitResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CAbortDFUWorkunitResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CAbortDFUWorkunitResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CAbortDFUWorkunitResponse::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
	}
}


void CAbortDFUWorkunitResponse::copy(CAbortDFUWorkunitResponse &from)
{
}


void CAbortDFUWorkunitResponse::copy(IConstAbortDFUWorkunitResponse &ifrom)
{
}


void CAbortDFUWorkunitResponse::getAttributes(IProperties &attributes)
{
}


void CAbortDFUWorkunitResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
	}
}


void CAbortDFUWorkunitResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CAbortDFUWorkunitResponse::serializer(IEspContext* ctx, IConstAbortDFUWorkunitResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<AbortDFUWorkunitResponse>");
	if (keepRootTag)
		buffer.append("</AbortDFUWorkunitResponse>");
}

bool CAbortDFUWorkunitResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
	}
	return hasValue;
}

bool CAbortDFUWorkunitResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	return hasValue;
}

bool CAbortDFUWorkunitResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	return hasValue;
}

extern "C"  IEspAbortDFUWorkunitResponse *createAbortDFUWorkunitResponse(const char *serv){return ((IEspAbortDFUWorkunitResponse *)new CAbortDFUWorkunitResponse(serv));}
extern "C"  IClientAbortDFUWorkunitResponse *createClientAbortDFUWorkunitResponse(const char *serv){return ((IClientAbortDFUWorkunitResponse *)new CAbortDFUWorkunitResponse(serv));}

//=======================================================
// class CGetDFUExceptions Implementation
//=======================================================

CGetDFUExceptions::CGetDFUExceptions(const char *serviceName, IRpcMessageBinding *init)
	: m_wuid(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetDFUExceptions");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CGetDFUExceptions::CGetDFUExceptions(const char *serviceName, const char *bc)
	: m_wuid(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetDFUExceptions");
}

CGetDFUExceptions::CGetDFUExceptions(const char *serviceName, IRpcMessage* rpcmsg)
	: m_wuid(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetDFUExceptions");
	unserialize(*rpcmsg,NULL,NULL);
}

CGetDFUExceptions::CGetDFUExceptions(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_wuid(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetDFUExceptions");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CGetDFUExceptions::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"wuid\" type=\"xsd:string\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CGetDFUExceptions::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CGetDFUExceptions::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CGetDFUExceptions::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("wuid");
	form.appendf("  <tr><td><b>wuid: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CGetDFUExceptions::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CGetDFUExceptions::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_wuid.marshall(rpc_resp, "wuid", "", "", "");
}


void CGetDFUExceptions::copy(CGetDFUExceptions &from)
{
	m_wuid.copy(from.m_wuid);
}


void CGetDFUExceptions::copy(IConstGetDFUExceptions &ifrom)
{
	setWuid(ifrom.getWuid());
}


void CGetDFUExceptions::getAttributes(IProperties &attributes)
{
}


void CGetDFUExceptions::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_wuid.toStr(ctx, buffer, "wuid", "", true, "", "");
}


void CGetDFUExceptions::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CGetDFUExceptions::serializer(IEspContext* ctx, IConstGetDFUExceptions &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<GetDFUExceptions>");
	// field wuid
	{
		const char* s = src.getWuid();
		if (s && *s)
		{
			buffer.append("<wuid>");
			encodeUtf8XML(s,buffer);
			buffer.append("</wuid>");
		}
	}
	if (keepRootTag)
		buffer.append("</GetDFUExceptions>");
}

bool CGetDFUExceptions::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_wuid.unmarshall(rpc_request, "wuid", basepath);
	return hasValue;
}

bool CGetDFUExceptions::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_wuid.unmarshall(ctx, soapval, "wuid");
	return hasValue;
}

bool CGetDFUExceptions::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_wuid.unmarshall(ctx, params, attachments, "wuid", basepath);
	return hasValue;
}

const char * CGetDFUExceptions::getWuid() { return m_wuid.query();}
void CGetDFUExceptions::setWuid(const char * val){ m_wuid.set(val); }
extern "C"  IEspGetDFUExceptions *createGetDFUExceptions(const char *serv){return ((IEspGetDFUExceptions *)new CGetDFUExceptions(serv));}
extern "C"  IClientGetDFUExceptions *createClientGetDFUExceptions(const char *serv){return ((IClientGetDFUExceptions *)new CGetDFUExceptions(serv));}

//=======================================================
// class CGetDFUExceptionsResponse Implementation
//=======================================================

CGetDFUExceptionsResponse::CGetDFUExceptionsResponse(const char *serviceName, IRpcMessageBinding *init)
	: m_result(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetDFUExceptionsResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CGetDFUExceptionsResponse::CGetDFUExceptionsResponse(const char *serviceName, const char *bc)
	: m_result(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetDFUExceptionsResponse");
}

CGetDFUExceptionsResponse::CGetDFUExceptionsResponse(const char *serviceName, IRpcMessage* rpcmsg)
	: m_result(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetDFUExceptionsResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CGetDFUExceptionsResponse::CGetDFUExceptionsResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_result(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetDFUExceptionsResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CGetDFUExceptionsResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		schema.append("<xsd:element name=\"Exceptions\" type=\"tns:ArrayOfEspException\" minOccurs=\"0\" maxOccurs=\"1\"/>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"result\" type=\"tns:ArrayOfDFUException\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	if (!(flags & 0x10)  || (flags & 0x100))
	{
		CDFUException::getXsdDefinition(context, request, schema, added);
	}
	if (added.getValue("DFUException") && added.getValue("ArrayOfDFUException")==NULL) {
		schema.append("<xsd:complexType name=\"ArrayOfDFUException\">\n");
		schema.append("<xsd:sequence>\n");
		schema.append("<xsd:element minOccurs=\"0\" maxOccurs=\"unbounded\" name=\"DFUException\" type=\"tns:DFUException\"/>\n");
		schema.append("</xsd:sequence>\n");
		schema.append("</xsd:complexType>\n");
		added.setValue("ArrayOfDFUException",1);
	}
	return schema;
}

void CGetDFUExceptionsResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CGetDFUExceptionsResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
	if (!added.getValue("DFUException"))
	{
		added.setValue("DFUException",1);
		CDFUException::getMapInfo(info,added);
	}
}

StringBuffer &CGetDFUExceptionsResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("result");
	form.appendf("<tr><td><b>result: </b></td><td>");
	form.appendf("<table><tr><td><textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea></td>", extfix.str());
	form.append("</tr></table>");
	form.append("</td></tr>");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CGetDFUExceptionsResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CGetDFUExceptionsResponse::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
		m_result.marshall(rpc_resp, "result", "DFUException");
	}
}


void CGetDFUExceptionsResponse::copy(CGetDFUExceptionsResponse &from)
{
	m_result.copy(from.m_result);
}


void CGetDFUExceptionsResponse::copy(IConstGetDFUExceptionsResponse &ifrom)
{
	setResult(ifrom.getResult());
}


void CGetDFUExceptionsResponse::getAttributes(IProperties &attributes)
{
}


void CGetDFUExceptionsResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
		m_result.toStr(ctx, buffer, "result", "DFUException");
	}
}


void CGetDFUExceptionsResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CGetDFUExceptionsResponse::serializer(IEspContext* ctx, IConstGetDFUExceptionsResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<GetDFUExceptionsResponse>");
	// field result
	{
		IArrayOf<IConstDFUException>& v = src.getResult();
		int size = v.length();
		if (size>0)
			buffer.append("<result>");
		for (int i=0;i<size;i++)
		{
			buffer.append("<Item>");
			CDFUException::serializer(ctx,v.item(i),buffer,false);
			buffer.append("</Item>");
		}
		if (size>0)
			buffer.append("</result>");
	}
	if (keepRootTag)
		buffer.append("</GetDFUExceptionsResponse>");
}

bool CGetDFUExceptionsResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
		hasValue |= m_result.unmarshall(rpc_request, "result", basepath);
	}
	return hasValue;
}

bool CGetDFUExceptionsResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_result.unmarshall(ctx, soapval, "result");
	return hasValue;
}

bool CGetDFUExceptionsResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_result.unmarshall(ctx, params, attachments, "result", basepath);
	return hasValue;
}

IArrayOf<IConstDFUException> & CGetDFUExceptionsResponse::getResult() { return (IArrayOf<IConstDFUException> &) m_result; }
void CGetDFUExceptionsResponse::setResult(IArrayOf<IEspDFUException> &val)
{
	m_result->kill();
	IArrayOf<IConstDFUException> &target = m_result.getValue();
	ForEachItemIn(idx, val)
	{
		IEspDFUException &item = (val).item(idx);
		item.Link();
		target.append(item);
	}
}
void CGetDFUExceptionsResponse::setResult(IArrayOf<IConstDFUException> &val)
{
	m_result->kill();
	IArrayOf<IConstDFUException> &target = m_result.getValue();
	ForEachItemIn(idx, val)
	{
		IConstDFUException &item = val.item(idx);
		item.Link();
		target.append(item);
	}
}
extern "C"  IEspGetDFUExceptionsResponse *createGetDFUExceptionsResponse(const char *serv){return ((IEspGetDFUExceptionsResponse *)new CGetDFUExceptionsResponse(serv));}
extern "C"  IClientGetDFUExceptionsResponse *createClientGetDFUExceptionsResponse(const char *serv){return ((IClientGetDFUExceptionsResponse *)new CGetDFUExceptionsResponse(serv));}

//=======================================================
// class CSprayFixed Implementation
//=======================================================

CSprayFixed::CSprayFixed(const char *serviceName, IRpcMessageBinding *init)
	: m_sourceIP(nilRemove),m_sourcePath(nilRemove),m_srcxml(nilRemove),m_sourceFormat(nilRemove),m_sourceRecordSize(nilRemove),m_destGroup(nilRemove),m_destLogicalName(nilRemove),m_overwrite(nilRemove),m_replicate(nilRemove),m_ReplicateOffset(1, nilRemove,false),m_maxConnections(nilRemove),m_throttle(nilRemove),m_transferBufferSize(nilRemove),m_prefix(nilRemove),m_nosplit(0, nilRemove,false),m_norecover(0, nilRemove,false),m_compress(0, nilRemove,false),m_push(0, nilRemove,false),m_pull(0, nilRemove,false),m_encrypt(nilRemove),m_decrypt(nilRemove),m_wrap(0, nilRemove,false),m_failIfNoSourceFile(0, nilRemove,false),m_recordStructurePresent(0, nilRemove,false),m_quotedTerminator(1, nilRemove,false),m_expireDays(nilRemove),m_DFUServerQueue(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("SprayFixed");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CSprayFixed::CSprayFixed(const char *serviceName, const char *bc)
	: m_sourceIP(nilRemove),m_sourcePath(nilRemove),m_srcxml(nilRemove),m_sourceFormat(nilRemove),m_sourceRecordSize(nilRemove),m_destGroup(nilRemove),m_destLogicalName(nilRemove),m_overwrite(nilRemove),m_replicate(nilRemove),m_ReplicateOffset(1, nilRemove,false),m_maxConnections(nilRemove),m_throttle(nilRemove),m_transferBufferSize(nilRemove),m_prefix(nilRemove),m_nosplit(0, nilRemove,false),m_norecover(0, nilRemove,false),m_compress(0, nilRemove,false),m_push(0, nilRemove,false),m_pull(0, nilRemove,false),m_encrypt(nilRemove),m_decrypt(nilRemove),m_wrap(0, nilRemove,false),m_failIfNoSourceFile(0, nilRemove,false),m_recordStructurePresent(0, nilRemove,false),m_quotedTerminator(1, nilRemove,false),m_expireDays(nilRemove),m_DFUServerQueue(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("SprayFixed");
}

CSprayFixed::CSprayFixed(const char *serviceName, IRpcMessage* rpcmsg)
	: m_sourceIP(nilRemove),m_sourcePath(nilRemove),m_srcxml(nilRemove),m_sourceFormat(nilRemove),m_sourceRecordSize(nilRemove),m_destGroup(nilRemove),m_destLogicalName(nilRemove),m_overwrite(nilRemove),m_replicate(nilRemove),m_ReplicateOffset(1, nilRemove,false),m_maxConnections(nilRemove),m_throttle(nilRemove),m_transferBufferSize(nilRemove),m_prefix(nilRemove),m_nosplit(0, nilRemove,false),m_norecover(0, nilRemove,false),m_compress(0, nilRemove,false),m_push(0, nilRemove,false),m_pull(0, nilRemove,false),m_encrypt(nilRemove),m_decrypt(nilRemove),m_wrap(0, nilRemove,false),m_failIfNoSourceFile(0, nilRemove,false),m_recordStructurePresent(0, nilRemove,false),m_quotedTerminator(1, nilRemove,false),m_expireDays(nilRemove),m_DFUServerQueue(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("SprayFixed");
	unserialize(*rpcmsg,NULL,NULL);
}

CSprayFixed::CSprayFixed(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_sourceIP(nilRemove),m_sourcePath(nilRemove),m_srcxml(nilRemove),m_sourceFormat(nilRemove),m_sourceRecordSize(nilRemove),m_destGroup(nilRemove),m_destLogicalName(nilRemove),m_overwrite(nilRemove),m_replicate(nilRemove),m_ReplicateOffset(1, nilRemove,false),m_maxConnections(nilRemove),m_throttle(nilRemove),m_transferBufferSize(nilRemove),m_prefix(nilRemove),m_nosplit(0, nilRemove,false),m_norecover(0, nilRemove,false),m_compress(0, nilRemove,false),m_push(0, nilRemove,false),m_pull(0, nilRemove,false),m_encrypt(nilRemove),m_decrypt(nilRemove),m_wrap(0, nilRemove,false),m_failIfNoSourceFile(0, nilRemove,false),m_recordStructurePresent(0, nilRemove,false),m_quotedTerminator(1, nilRemove,false),m_expireDays(nilRemove),m_DFUServerQueue(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("SprayFixed");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CSprayFixed::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"sourceIP\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"sourcePath\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"srcxml\" type=\"xsd:base64Binary\"/>\n");
		if (!context.suppressed("SprayFixed","sourceFormat")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"sourceFormat\" type=\"xsd:string\"/>\n");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"sourceRecordSize\" type=\"xsd:int\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"destGroup\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"destLogicalName\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"overwrite\" type=\"xsd:boolean\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"replicate\" type=\"xsd:boolean\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" default=\"1\" name=\"ReplicateOffset\" type=\"xsd:int\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"maxConnections\" type=\"xsd:int\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"throttle\" type=\"xsd:int\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"transferBufferSize\" type=\"xsd:int\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"prefix\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" default=\"false\" name=\"nosplit\" type=\"xsd:boolean\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" default=\"false\" name=\"norecover\" type=\"xsd:boolean\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" default=\"false\" name=\"compress\" type=\"xsd:boolean\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" default=\"false\" name=\"push\" type=\"xsd:boolean\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" default=\"false\" name=\"pull\" type=\"xsd:boolean\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"encrypt\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"decrypt\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" default=\"false\" name=\"wrap\" type=\"xsd:boolean\"/>\n");
		if (!context.suppressed("SprayFixed","failIfNoSourceFile")) {
			schema.append("<xsd:element minOccurs=\"0\" default=\"false\" name=\"failIfNoSourceFile\" type=\"xsd:boolean\"/>\n");
		}
		if (!context.suppressed("SprayFixed","recordStructurePresent")) {
			schema.append("<xsd:element minOccurs=\"0\" default=\"false\" name=\"recordStructurePresent\" type=\"xsd:boolean\"/>\n");
		}
		if (!context.suppressed("SprayFixed","quotedTerminator")) {
			schema.append("<xsd:element minOccurs=\"0\" default=\"true\" name=\"quotedTerminator\" type=\"xsd:boolean\"/>\n");
		}
		if (!context.suppressed("SprayFixed","expireDays")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"expireDays\" type=\"xsd:int\"/>\n");
		}
		if (!context.suppressed("SprayFixed","DFUServerQueue")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"DFUServerQueue\" type=\"xsd:string\"/>\n");
		}
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CSprayFixed::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CSprayFixed::getMapInfo(IMapInfo& info, BoolHash& added)
{
	info.addMinVersion("SprayFixed","sourceFormat",1.09);
	info.addMinVersion("SprayFixed","failIfNoSourceFile",1.08);
	info.addMinVersion("SprayFixed","recordStructurePresent",1.09);
	info.addMinVersion("SprayFixed","quotedTerminator",1.1);
	info.addMinVersion("SprayFixed","expireDays",1.14);
	info.addMinVersion("SprayFixed","DFUServerQueue",1.14);
}

StringBuffer &CSprayFixed::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("sourceIP");
	form.appendf("  <tr><td><b>sourceIP: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("sourcePath");
	form.appendf("  <tr><td><b>sourcePath: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("srcxml");
	form.appendf("  <tr><td><b>srcxml: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (!context.suppressed("SprayFixed","sourceFormat")) {
		extfix.clear();
		if (prefix && *prefix)
			extfix.append(prefix).append(".");
		extfix.append("sourceFormat");
		form.appendf("  <tr><td><b>sourceFormat: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
		form.append("</td></tr>\n");
	}
	extfix.clear();
	if (prefix && *prefix) extfix.append(prefix).append(".");
		extfix.append("sourceRecordSize");
	form.appendf("  <tr><td><b>sourceRecordSize: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("destGroup");
	form.appendf("  <tr><td><b>destGroup: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("destLogicalName");
	form.appendf("  <tr><td><b>destLogicalName: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("overwrite");
	
	form.appendf("  <tr><td><b>overwrite? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("replicate");
	
	form.appendf("  <tr><td><b>replicate? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	extfix.clear();
	if (prefix && *prefix) extfix.append(prefix).append(".");
		extfix.append("ReplicateOffset");
	form.appendf("  <tr><td><b>ReplicateOffset: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"	 value=\"1\"/>", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix) extfix.append(prefix).append(".");
		extfix.append("maxConnections");
	form.appendf("  <tr><td><b>maxConnections: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix) extfix.append(prefix).append(".");
		extfix.append("throttle");
	form.appendf("  <tr><td><b>throttle: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix) extfix.append(prefix).append(".");
		extfix.append("transferBufferSize");
	form.appendf("  <tr><td><b>transferBufferSize: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("prefix");
	form.appendf("  <tr><td><b>prefix: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("nosplit");
	
	form.appendf("  <tr><td><b>nosplit? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("norecover");
	
	form.appendf("  <tr><td><b>norecover? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("compress");
	
	form.appendf("  <tr><td><b>compress? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("push");
	
	form.appendf("  <tr><td><b>push? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("pull");
	
	form.appendf("  <tr><td><b>pull? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("encrypt");
	form.appendf("  <tr><td><b>encrypt: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("decrypt");
	form.appendf("  <tr><td><b>decrypt: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("wrap");
	
	form.appendf("  <tr><td><b>wrap? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	if (!context.suppressed("SprayFixed","failIfNoSourceFile")) {
		extfix.clear();
		if (prefix && *prefix)
			extfix.append(prefix).append(".");
		extfix.append("failIfNoSourceFile");
		
	form.appendf("  <tr><td><b>failIfNoSourceFile? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	}
	if (!context.suppressed("SprayFixed","recordStructurePresent")) {
		extfix.clear();
		if (prefix && *prefix)
			extfix.append(prefix).append(".");
		extfix.append("recordStructurePresent");
		
	form.appendf("  <tr><td><b>recordStructurePresent? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	}
	if (!context.suppressed("SprayFixed","quotedTerminator")) {
		extfix.clear();
		if (prefix && *prefix)
			extfix.append(prefix).append(".");
		extfix.append("quotedTerminator");
		
	form.appendf("  <tr><td><b>quotedTerminator? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\" checked=\"1\" /></td></tr>\n", extfix.str());
	}
	if (!context.suppressed("SprayFixed","expireDays")) {
		extfix.clear();
		if (prefix && *prefix) extfix.append(prefix).append(".");
			extfix.append("expireDays");
		form.appendf("  <tr><td><b>expireDays: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
		form.append("</td></tr>\n");
	}
	if (!context.suppressed("SprayFixed","DFUServerQueue")) {
		extfix.clear();
		if (prefix && *prefix)
			extfix.append(prefix).append(".");
		extfix.append("DFUServerQueue");
		form.appendf("  <tr><td><b>DFUServerQueue: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
		form.append("</td></tr>\n");
	}
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CSprayFixed::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CSprayFixed::serialize(IRpcMessage& rpc_resp)
{
	IEspContext* ctx = rpc_resp.queryContext();
	double clientVer= ctx ? ctx->getClientVersion() : -1; /* no context gets everything */
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_sourceIP.marshall(rpc_resp, "sourceIP", "", "", "");
	m_sourcePath.marshall(rpc_resp, "sourcePath", "", "", "");
	m_srcxml.marshall(rpc_resp, "srcxml", "", "", "");
	if ((clientVer==-1.0 || clientVer>=1.09))
		m_sourceFormat.marshall(rpc_resp, "sourceFormat", "", "", "");
	m_sourceRecordSize.marshall(rpc_resp, "sourceRecordSize", "", "", "");
	m_destGroup.marshall(rpc_resp, "destGroup", "", "", "");
	m_destLogicalName.marshall(rpc_resp, "destLogicalName", "", "", "");
	m_overwrite.marshall(rpc_resp, "overwrite", "", "", "");
	m_replicate.marshall(rpc_resp, "replicate", "", "", "");
	m_ReplicateOffset.marshall(rpc_resp, "ReplicateOffset", "", "", "");
	m_maxConnections.marshall(rpc_resp, "maxConnections", "", "", "");
	m_throttle.marshall(rpc_resp, "throttle", "", "", "");
	m_transferBufferSize.marshall(rpc_resp, "transferBufferSize", "", "", "");
	m_prefix.marshall(rpc_resp, "prefix", "", "", "");
	m_nosplit.marshall(rpc_resp, "nosplit", "", "", "");
	m_norecover.marshall(rpc_resp, "norecover", "", "", "");
	m_compress.marshall(rpc_resp, "compress", "", "", "");
	m_push.marshall(rpc_resp, "push", "", "", "");
	m_pull.marshall(rpc_resp, "pull", "", "", "");
	m_encrypt.marshall(rpc_resp, "encrypt", "", "", "");
	m_decrypt.marshall(rpc_resp, "decrypt", "", "", "");
	m_wrap.marshall(rpc_resp, "wrap", "", "", "");
	if ((clientVer==-1.0 || clientVer>=1.08))
		m_failIfNoSourceFile.marshall(rpc_resp, "failIfNoSourceFile", "", "", "");
	if ((clientVer==-1.0 || clientVer>=1.09))
		m_recordStructurePresent.marshall(rpc_resp, "recordStructurePresent", "", "", "");
	if ((clientVer==-1.0 || clientVer>=1.1))
		m_quotedTerminator.marshall(rpc_resp, "quotedTerminator", "", "", "");
	if ((clientVer==-1.0 || clientVer>=1.14))
		m_expireDays.marshall(rpc_resp, "expireDays", "", "", "");
	if ((clientVer==-1.0 || clientVer>=1.14))
		m_DFUServerQueue.marshall(rpc_resp, "DFUServerQueue", "", "", "");
}


void CSprayFixed::copy(CSprayFixed &from)
{
	m_sourceIP.copy(from.m_sourceIP);
	m_sourcePath.copy(from.m_sourcePath);
	m_srcxml.copy(from.m_srcxml);
	m_sourceFormat.copy(from.m_sourceFormat);
	m_sourceRecordSize.copy(from.m_sourceRecordSize);
	m_destGroup.copy(from.m_destGroup);
	m_destLogicalName.copy(from.m_destLogicalName);
	m_overwrite.copy(from.m_overwrite);
	m_replicate.copy(from.m_replicate);
	m_ReplicateOffset.copy(from.m_ReplicateOffset);
	m_maxConnections.copy(from.m_maxConnections);
	m_throttle.copy(from.m_throttle);
	m_transferBufferSize.copy(from.m_transferBufferSize);
	m_prefix.copy(from.m_prefix);
	m_nosplit.copy(from.m_nosplit);
	m_norecover.copy(from.m_norecover);
	m_compress.copy(from.m_compress);
	m_push.copy(from.m_push);
	m_pull.copy(from.m_pull);
	m_encrypt.copy(from.m_encrypt);
	m_decrypt.copy(from.m_decrypt);
	m_wrap.copy(from.m_wrap);
	m_failIfNoSourceFile.copy(from.m_failIfNoSourceFile);
	m_recordStructurePresent.copy(from.m_recordStructurePresent);
	m_quotedTerminator.copy(from.m_quotedTerminator);
	m_expireDays.copy(from.m_expireDays);
	m_DFUServerQueue.copy(from.m_DFUServerQueue);
}


void CSprayFixed::copy(IConstSprayFixed &ifrom)
{
	setSourceIP(ifrom.getSourceIP());
	setSourcePath(ifrom.getSourcePath());
	setSrcxml(ifrom.getSrcxml());
	setSourceFormat(ifrom.getSourceFormat());
	setSourceRecordSize(ifrom.getSourceRecordSize());
	setDestGroup(ifrom.getDestGroup());
	setDestLogicalName(ifrom.getDestLogicalName());
	setOverwrite(ifrom.getOverwrite());
	setReplicate(ifrom.getReplicate());
	setReplicateOffset(ifrom.getReplicateOffset());
	setMaxConnections(ifrom.getMaxConnections());
	setThrottle(ifrom.getThrottle());
	setTransferBufferSize(ifrom.getTransferBufferSize());
	setPrefix(ifrom.getPrefix());
	setNosplit(ifrom.getNosplit());
	setNorecover(ifrom.getNorecover());
	setCompress(ifrom.getCompress());
	setPush(ifrom.getPush());
	setPull(ifrom.getPull());
	setEncrypt(ifrom.getEncrypt());
	setDecrypt(ifrom.getDecrypt());
	setWrap(ifrom.getWrap());
	setFailIfNoSourceFile(ifrom.getFailIfNoSourceFile());
	setRecordStructurePresent(ifrom.getRecordStructurePresent());
	setQuotedTerminator(ifrom.getQuotedTerminator());
	setExpireDays(ifrom.getExpireDays());
	setDFUServerQueue(ifrom.getDFUServerQueue());
}


void CSprayFixed::getAttributes(IProperties &attributes)
{
}


void CSprayFixed::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	double clientVer = ctx ? ctx->getClientVersion() : -1;
	m_sourceIP.toStr(ctx, buffer, "sourceIP", "", true, "", "");
	m_sourcePath.toStr(ctx, buffer, "sourcePath", "", true, "", "");
	m_srcxml.toStr(ctx, buffer, "srcxml", "", true, "", "");
	if ((clientVer==-1.0 || clientVer>=1.09))
		m_sourceFormat.toStr(ctx, buffer, "sourceFormat", "", true, "", "");
	m_sourceRecordSize.toStr(ctx, buffer, "sourceRecordSize", "", true, "", "");
	m_destGroup.toStr(ctx, buffer, "destGroup", "", true, "", "");
	m_destLogicalName.toStr(ctx, buffer, "destLogicalName", "", true, "", "");
	m_overwrite.toStr(ctx, buffer, "overwrite", "", true, "", "");
	m_replicate.toStr(ctx, buffer, "replicate", "", true, "", "");
	m_ReplicateOffset.toStr(ctx, buffer, "ReplicateOffset", "", true, "", "");
	m_maxConnections.toStr(ctx, buffer, "maxConnections", "", true, "", "");
	m_throttle.toStr(ctx, buffer, "throttle", "", true, "", "");
	m_transferBufferSize.toStr(ctx, buffer, "transferBufferSize", "", true, "", "");
	m_prefix.toStr(ctx, buffer, "prefix", "", true, "", "");
	m_nosplit.toStr(ctx, buffer, "nosplit", "", true, "", "");
	m_norecover.toStr(ctx, buffer, "norecover", "", true, "", "");
	m_compress.toStr(ctx, buffer, "compress", "", true, "", "");
	m_push.toStr(ctx, buffer, "push", "", true, "", "");
	m_pull.toStr(ctx, buffer, "pull", "", true, "", "");
	m_encrypt.toStr(ctx, buffer, "encrypt", "", true, "", "");
	m_decrypt.toStr(ctx, buffer, "decrypt", "", true, "", "");
	m_wrap.toStr(ctx, buffer, "wrap", "", true, "", "");
	if ((clientVer==-1.0 || clientVer>=1.08))
		m_failIfNoSourceFile.toStr(ctx, buffer, "failIfNoSourceFile", "", true, "", "");
	if ((clientVer==-1.0 || clientVer>=1.09))
		m_recordStructurePresent.toStr(ctx, buffer, "recordStructurePresent", "", true, "", "");
	if ((clientVer==-1.0 || clientVer>=1.1))
		m_quotedTerminator.toStr(ctx, buffer, "quotedTerminator", "", true, "", "");
	if ((clientVer==-1.0 || clientVer>=1.14))
		m_expireDays.toStr(ctx, buffer, "expireDays", "", true, "", "");
	if ((clientVer==-1.0 || clientVer>=1.14))
		m_DFUServerQueue.toStr(ctx, buffer, "DFUServerQueue", "", true, "", "");
}


void CSprayFixed::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CSprayFixed::serializer(IEspContext* ctx, IConstSprayFixed &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<SprayFixed>");
	double clientVer = ctx ? ctx->getClientVersion() : -1;
	// field sourceIP
	{
		const char* s = src.getSourceIP();
		if (s && *s)
		{
			buffer.append("<sourceIP>");
			encodeUtf8XML(s,buffer);
			buffer.append("</sourceIP>");
		}
	}
	// field sourcePath
	{
		const char* s = src.getSourcePath();
		if (s && *s)
		{
			buffer.append("<sourcePath>");
			encodeUtf8XML(s,buffer);
			buffer.append("</sourcePath>");
		}
	}
	// field srcxml
	{
		StringBuffer tmp;
		JBASE64_Encode(src.getSrcxml().toByteArray(), src.getSrcxml().length(), tmp);
		if (tmp.length()>0)
			buffer.appendf("<srcxml>%s</srcxml>",tmp.str());
	}
	// field sourceFormat
	if ((clientVer==-1.0 || clientVer>=1.09))
	{
		const char* s = src.getSourceFormat();
		if (s && *s)
		{
			buffer.append("<sourceFormat>");
			encodeUtf8XML(s,buffer);
			buffer.append("</sourceFormat>");
		}
	}
	// field sourceRecordSize
	{
		int n = src.getSourceRecordSize();
		if (n)
			buffer.appendf("<sourceRecordSize>%d</sourceRecordSize>", n);
	}
	// field destGroup
	{
		const char* s = src.getDestGroup();
		if (s && *s)
		{
			buffer.append("<destGroup>");
			encodeUtf8XML(s,buffer);
			buffer.append("</destGroup>");
		}
	}
	// field destLogicalName
	{
		const char* s = src.getDestLogicalName();
		if (s && *s)
		{
			buffer.append("<destLogicalName>");
			encodeUtf8XML(s,buffer);
			buffer.append("</destLogicalName>");
		}
	}
	// field overwrite
	{
		bool b = src.getOverwrite();
		if (b)
			buffer.appendf("<overwrite>1</overwrite>");
	}
	// field replicate
	{
		bool b = src.getReplicate();
		if (b)
			buffer.appendf("<replicate>1</replicate>");
	}
	// field ReplicateOffset
	{
		int n = src.getReplicateOffset();
		if (n)
			buffer.appendf("<ReplicateOffset>%d</ReplicateOffset>", n);
	}
	// field maxConnections
	{
		int n = src.getMaxConnections();
		if (n)
			buffer.appendf("<maxConnections>%d</maxConnections>", n);
	}
	// field throttle
	{
		int n = src.getThrottle();
		if (n)
			buffer.appendf("<throttle>%d</throttle>", n);
	}
	// field transferBufferSize
	{
		int n = src.getTransferBufferSize();
		if (n)
			buffer.appendf("<transferBufferSize>%d</transferBufferSize>", n);
	}
	// field prefix
	{
		const char* s = src.getPrefix();
		if (s && *s)
		{
			buffer.append("<prefix>");
			encodeUtf8XML(s,buffer);
			buffer.append("</prefix>");
		}
	}
	// field nosplit
	{
		bool b = src.getNosplit();
		if (b)
			buffer.appendf("<nosplit>1</nosplit>");
	}
	// field norecover
	{
		bool b = src.getNorecover();
		if (b)
			buffer.appendf("<norecover>1</norecover>");
	}
	// field compress
	{
		bool b = src.getCompress();
		if (b)
			buffer.appendf("<compress>1</compress>");
	}
	// field push
	{
		bool b = src.getPush();
		if (b)
			buffer.appendf("<push>1</push>");
	}
	// field pull
	{
		bool b = src.getPull();
		if (b)
			buffer.appendf("<pull>1</pull>");
	}
	// field encrypt
	{
		const char* s = src.getEncrypt();
		if (s && *s)
		{
			buffer.append("<encrypt>");
			encodeUtf8XML(s,buffer);
			buffer.append("</encrypt>");
		}
	}
	// field decrypt
	{
		const char* s = src.getDecrypt();
		if (s && *s)
		{
			buffer.append("<decrypt>");
			encodeUtf8XML(s,buffer);
			buffer.append("</decrypt>");
		}
	}
	// field wrap
	{
		bool b = src.getWrap();
		if (b)
			buffer.appendf("<wrap>1</wrap>");
	}
	// field failIfNoSourceFile
	if ((clientVer==-1.0 || clientVer>=1.08))
	{
		bool b = src.getFailIfNoSourceFile();
		if (b)
			buffer.appendf("<failIfNoSourceFile>1</failIfNoSourceFile>");
	}
	// field recordStructurePresent
	if ((clientVer==-1.0 || clientVer>=1.09))
	{
		bool b = src.getRecordStructurePresent();
		if (b)
			buffer.appendf("<recordStructurePresent>1</recordStructurePresent>");
	}
	// field quotedTerminator
	if ((clientVer==-1.0 || clientVer>=1.1))
	{
		bool b = src.getQuotedTerminator();
		if (b)
			buffer.appendf("<quotedTerminator>1</quotedTerminator>");
	}
	// field expireDays
	if ((clientVer==-1.0 || clientVer>=1.14))
	{
		int n = src.getExpireDays();
		if (n)
			buffer.appendf("<expireDays>%d</expireDays>", n);
	}
	// field DFUServerQueue
	if ((clientVer==-1.0 || clientVer>=1.14))
	{
		const char* s = src.getDFUServerQueue();
		if (s && *s)
		{
			buffer.append("<DFUServerQueue>");
			encodeUtf8XML(s,buffer);
			buffer.append("</DFUServerQueue>");
		}
	}
	if (keepRootTag)
		buffer.append("</SprayFixed>");
}

bool CSprayFixed::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_sourceIP.unmarshall(rpc_request, "sourceIP", basepath);
	hasValue |= m_sourcePath.unmarshall(rpc_request, "sourcePath", basepath);
	hasValue |= m_srcxml.unmarshall(rpc_request, "srcxml", basepath);
	hasValue |= m_sourceFormat.unmarshall(rpc_request, "sourceFormat", basepath);
	hasValue |= m_sourceRecordSize.unmarshall(rpc_request, "sourceRecordSize", basepath);
	hasValue |= m_destGroup.unmarshall(rpc_request, "destGroup", basepath);
	hasValue |= m_destLogicalName.unmarshall(rpc_request, "destLogicalName", basepath);
	hasValue |= m_overwrite.unmarshall(rpc_request, "overwrite", basepath);
	hasValue |= m_replicate.unmarshall(rpc_request, "replicate", basepath);
	hasValue |= m_ReplicateOffset.unmarshall(rpc_request, "ReplicateOffset", basepath);
	hasValue |= m_maxConnections.unmarshall(rpc_request, "maxConnections", basepath);
	hasValue |= m_throttle.unmarshall(rpc_request, "throttle", basepath);
	hasValue |= m_transferBufferSize.unmarshall(rpc_request, "transferBufferSize", basepath);
	hasValue |= m_prefix.unmarshall(rpc_request, "prefix", basepath);
	hasValue |= m_nosplit.unmarshall(rpc_request, "nosplit", basepath);
	hasValue |= m_norecover.unmarshall(rpc_request, "norecover", basepath);
	hasValue |= m_compress.unmarshall(rpc_request, "compress", basepath);
	hasValue |= m_push.unmarshall(rpc_request, "push", basepath);
	hasValue |= m_pull.unmarshall(rpc_request, "pull", basepath);
	hasValue |= m_encrypt.unmarshall(rpc_request, "encrypt", basepath);
	hasValue |= m_decrypt.unmarshall(rpc_request, "decrypt", basepath);
	hasValue |= m_wrap.unmarshall(rpc_request, "wrap", basepath);
	hasValue |= m_failIfNoSourceFile.unmarshall(rpc_request, "failIfNoSourceFile", basepath);
	hasValue |= m_recordStructurePresent.unmarshall(rpc_request, "recordStructurePresent", basepath);
	hasValue |= m_quotedTerminator.unmarshall(rpc_request, "quotedTerminator", basepath);
	hasValue |= m_expireDays.unmarshall(rpc_request, "expireDays", basepath);
	hasValue |= m_DFUServerQueue.unmarshall(rpc_request, "DFUServerQueue", basepath);
	return hasValue;
}

bool CSprayFixed::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_sourceIP.unmarshall(ctx, soapval, "sourceIP");
	hasValue |= m_sourcePath.unmarshall(ctx, soapval, "sourcePath");
	hasValue |= m_srcxml.unmarshall(ctx, soapval, "srcxml");
	hasValue |= m_sourceFormat.unmarshall(ctx, soapval, "sourceFormat");
	hasValue |= m_sourceRecordSize.unmarshall(ctx, soapval, "sourceRecordSize");
	hasValue |= m_destGroup.unmarshall(ctx, soapval, "destGroup");
	hasValue |= m_destLogicalName.unmarshall(ctx, soapval, "destLogicalName");
	hasValue |= m_overwrite.unmarshall(ctx, soapval, "overwrite");
	hasValue |= m_replicate.unmarshall(ctx, soapval, "replicate");
	hasValue |= m_ReplicateOffset.unmarshall(ctx, soapval, "ReplicateOffset");
	hasValue |= m_maxConnections.unmarshall(ctx, soapval, "maxConnections");
	hasValue |= m_throttle.unmarshall(ctx, soapval, "throttle");
	hasValue |= m_transferBufferSize.unmarshall(ctx, soapval, "transferBufferSize");
	hasValue |= m_prefix.unmarshall(ctx, soapval, "prefix");
	hasValue |= m_nosplit.unmarshall(ctx, soapval, "nosplit");
	hasValue |= m_norecover.unmarshall(ctx, soapval, "norecover");
	hasValue |= m_compress.unmarshall(ctx, soapval, "compress");
	hasValue |= m_push.unmarshall(ctx, soapval, "push");
	hasValue |= m_pull.unmarshall(ctx, soapval, "pull");
	hasValue |= m_encrypt.unmarshall(ctx, soapval, "encrypt");
	hasValue |= m_decrypt.unmarshall(ctx, soapval, "decrypt");
	hasValue |= m_wrap.unmarshall(ctx, soapval, "wrap");
	hasValue |= m_failIfNoSourceFile.unmarshall(ctx, soapval, "failIfNoSourceFile");
	hasValue |= m_recordStructurePresent.unmarshall(ctx, soapval, "recordStructurePresent");
	hasValue |= m_quotedTerminator.unmarshall(ctx, soapval, "quotedTerminator");
	hasValue |= m_expireDays.unmarshall(ctx, soapval, "expireDays");
	hasValue |= m_DFUServerQueue.unmarshall(ctx, soapval, "DFUServerQueue");
	return hasValue;
}

bool CSprayFixed::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_sourceIP.unmarshall(ctx, params, attachments, "sourceIP", basepath);
	hasValue |= m_sourcePath.unmarshall(ctx, params, attachments, "sourcePath", basepath);
	hasValue |= m_srcxml.unmarshall(ctx, params, attachments, "srcxml", basepath);
	hasValue |= m_sourceFormat.unmarshall(ctx, params, attachments, "sourceFormat", basepath);
	hasValue |= m_sourceRecordSize.unmarshall(ctx, params, attachments, "sourceRecordSize", basepath);
	hasValue |= m_destGroup.unmarshall(ctx, params, attachments, "destGroup", basepath);
	hasValue |= m_destLogicalName.unmarshall(ctx, params, attachments, "destLogicalName", basepath);
	hasValue |= m_overwrite.unmarshall(ctx, params, attachments, "overwrite", basepath);
	hasValue |= m_replicate.unmarshall(ctx, params, attachments, "replicate", basepath);
	hasValue |= m_ReplicateOffset.unmarshall(ctx, params, attachments, "ReplicateOffset", basepath);
	hasValue |= m_maxConnections.unmarshall(ctx, params, attachments, "maxConnections", basepath);
	hasValue |= m_throttle.unmarshall(ctx, params, attachments, "throttle", basepath);
	hasValue |= m_transferBufferSize.unmarshall(ctx, params, attachments, "transferBufferSize", basepath);
	hasValue |= m_prefix.unmarshall(ctx, params, attachments, "prefix", basepath);
	hasValue |= m_nosplit.unmarshall(ctx, params, attachments, "nosplit", basepath);
	hasValue |= m_norecover.unmarshall(ctx, params, attachments, "norecover", basepath);
	hasValue |= m_compress.unmarshall(ctx, params, attachments, "compress", basepath);
	hasValue |= m_push.unmarshall(ctx, params, attachments, "push", basepath);
	hasValue |= m_pull.unmarshall(ctx, params, attachments, "pull", basepath);
	hasValue |= m_encrypt.unmarshall(ctx, params, attachments, "encrypt", basepath);
	hasValue |= m_decrypt.unmarshall(ctx, params, attachments, "decrypt", basepath);
	hasValue |= m_wrap.unmarshall(ctx, params, attachments, "wrap", basepath);
	hasValue |= m_failIfNoSourceFile.unmarshall(ctx, params, attachments, "failIfNoSourceFile", basepath);
	hasValue |= m_recordStructurePresent.unmarshall(ctx, params, attachments, "recordStructurePresent", basepath);
	hasValue |= m_quotedTerminator.unmarshall(ctx, params, attachments, "quotedTerminator", basepath);
	hasValue |= m_expireDays.unmarshall(ctx, params, attachments, "expireDays", basepath);
	hasValue |= m_DFUServerQueue.unmarshall(ctx, params, attachments, "DFUServerQueue", basepath);
	return hasValue;
}

const char * CSprayFixed::getSourceIP() { return m_sourceIP.query();}
const char * CSprayFixed::getSourcePath() { return m_sourcePath.query();}
const MemoryBuffer & CSprayFixed::getSrcxml() { return m_srcxml.getValue();}
const char * CSprayFixed::getSourceFormat() { return m_sourceFormat.query();}
bool CSprayFixed::getSourceRecordSize_isNull(){return m_sourceRecordSize.is_nil();}
int CSprayFixed::getSourceRecordSize() { return m_sourceRecordSize;}
const char * CSprayFixed::getDestGroup() { return m_destGroup.query();}
const char * CSprayFixed::getDestLogicalName() { return m_destLogicalName.query();}
bool CSprayFixed::getOverwrite_isNull(){return m_overwrite.is_nil();}
bool CSprayFixed::getOverwrite() { return m_overwrite;}
bool CSprayFixed::getReplicate_isNull(){return m_replicate.is_nil();}
bool CSprayFixed::getReplicate() { return m_replicate;}
bool CSprayFixed::getReplicateOffset_isNull(){return m_ReplicateOffset.is_nil();}
int CSprayFixed::getReplicateOffset() { return m_ReplicateOffset;}
bool CSprayFixed::getMaxConnections_isNull(){return m_maxConnections.is_nil();}
int CSprayFixed::getMaxConnections() { return m_maxConnections;}
bool CSprayFixed::getThrottle_isNull(){return m_throttle.is_nil();}
int CSprayFixed::getThrottle() { return m_throttle;}
bool CSprayFixed::getTransferBufferSize_isNull(){return m_transferBufferSize.is_nil();}
int CSprayFixed::getTransferBufferSize() { return m_transferBufferSize;}
const char * CSprayFixed::getPrefix() { return m_prefix.query();}
bool CSprayFixed::getNosplit_isNull(){return m_nosplit.is_nil();}
bool CSprayFixed::getNosplit() { return m_nosplit;}
bool CSprayFixed::getNorecover_isNull(){return m_norecover.is_nil();}
bool CSprayFixed::getNorecover() { return m_norecover;}
bool CSprayFixed::getCompress_isNull(){return m_compress.is_nil();}
bool CSprayFixed::getCompress() { return m_compress;}
bool CSprayFixed::getPush_isNull(){return m_push.is_nil();}
bool CSprayFixed::getPush() { return m_push;}
bool CSprayFixed::getPull_isNull(){return m_pull.is_nil();}
bool CSprayFixed::getPull() { return m_pull;}
const char * CSprayFixed::getEncrypt() { return m_encrypt.query();}
const char * CSprayFixed::getDecrypt() { return m_decrypt.query();}
bool CSprayFixed::getWrap_isNull(){return m_wrap.is_nil();}
bool CSprayFixed::getWrap() { return m_wrap;}
bool CSprayFixed::getFailIfNoSourceFile_isNull(){return m_failIfNoSourceFile.is_nil();}
bool CSprayFixed::getFailIfNoSourceFile() { return m_failIfNoSourceFile;}
bool CSprayFixed::getRecordStructurePresent_isNull(){return m_recordStructurePresent.is_nil();}
bool CSprayFixed::getRecordStructurePresent() { return m_recordStructurePresent;}
bool CSprayFixed::getQuotedTerminator_isNull(){return m_quotedTerminator.is_nil();}
bool CSprayFixed::getQuotedTerminator() { return m_quotedTerminator;}
bool CSprayFixed::getExpireDays_isNull(){return m_expireDays.is_nil();}
int CSprayFixed::getExpireDays() { return m_expireDays;}
const char * CSprayFixed::getDFUServerQueue() { return m_DFUServerQueue.query();}
void CSprayFixed::setSourceIP(const char * val){ m_sourceIP.set(val); }
void CSprayFixed::setSourcePath(const char * val){ m_sourcePath.set(val); }
void CSprayFixed::setSrcxml(const MemoryBuffer & val){ m_srcxml->clear().append(val); }
void CSprayFixed::setSourceFormat(const char * val){ m_sourceFormat.set(val); }
void CSprayFixed::setSourceRecordSize_null(){ m_sourceRecordSize.Nil(); }void CSprayFixed::setSourceRecordSize(int val){ m_sourceRecordSize=val; }
void CSprayFixed::setDestGroup(const char * val){ m_destGroup.set(val); }
void CSprayFixed::setDestLogicalName(const char * val){ m_destLogicalName.set(val); }
void CSprayFixed::setOverwrite_null(){ m_overwrite.Nil(); }void CSprayFixed::setOverwrite(bool val){ m_overwrite=val; }
void CSprayFixed::setReplicate_null(){ m_replicate.Nil(); }void CSprayFixed::setReplicate(bool val){ m_replicate=val; }
void CSprayFixed::setReplicateOffset_null(){ m_ReplicateOffset.Nil(); }void CSprayFixed::setReplicateOffset(int val){ m_ReplicateOffset=val; }
void CSprayFixed::setMaxConnections_null(){ m_maxConnections.Nil(); }void CSprayFixed::setMaxConnections(int val){ m_maxConnections=val; }
void CSprayFixed::setThrottle_null(){ m_throttle.Nil(); }void CSprayFixed::setThrottle(int val){ m_throttle=val; }
void CSprayFixed::setTransferBufferSize_null(){ m_transferBufferSize.Nil(); }void CSprayFixed::setTransferBufferSize(int val){ m_transferBufferSize=val; }
void CSprayFixed::setPrefix(const char * val){ m_prefix.set(val); }
void CSprayFixed::setNosplit_null(){ m_nosplit.Nil(); }void CSprayFixed::setNosplit(bool val){ m_nosplit=val; }
void CSprayFixed::setNorecover_null(){ m_norecover.Nil(); }void CSprayFixed::setNorecover(bool val){ m_norecover=val; }
void CSprayFixed::setCompress_null(){ m_compress.Nil(); }void CSprayFixed::setCompress(bool val){ m_compress=val; }
void CSprayFixed::setPush_null(){ m_push.Nil(); }void CSprayFixed::setPush(bool val){ m_push=val; }
void CSprayFixed::setPull_null(){ m_pull.Nil(); }void CSprayFixed::setPull(bool val){ m_pull=val; }
void CSprayFixed::setEncrypt(const char * val){ m_encrypt.set(val); }
void CSprayFixed::setDecrypt(const char * val){ m_decrypt.set(val); }
void CSprayFixed::setWrap_null(){ m_wrap.Nil(); }void CSprayFixed::setWrap(bool val){ m_wrap=val; }
void CSprayFixed::setFailIfNoSourceFile_null(){ m_failIfNoSourceFile.Nil(); }void CSprayFixed::setFailIfNoSourceFile(bool val){ m_failIfNoSourceFile=val; }
void CSprayFixed::setRecordStructurePresent_null(){ m_recordStructurePresent.Nil(); }void CSprayFixed::setRecordStructurePresent(bool val){ m_recordStructurePresent=val; }
void CSprayFixed::setQuotedTerminator_null(){ m_quotedTerminator.Nil(); }void CSprayFixed::setQuotedTerminator(bool val){ m_quotedTerminator=val; }
void CSprayFixed::setExpireDays_null(){ m_expireDays.Nil(); }void CSprayFixed::setExpireDays(int val){ m_expireDays=val; }
void CSprayFixed::setDFUServerQueue(const char * val){ m_DFUServerQueue.set(val); }
extern "C"  IEspSprayFixed *createSprayFixed(const char *serv){return ((IEspSprayFixed *)new CSprayFixed(serv));}
extern "C"  IClientSprayFixed *createClientSprayFixed(const char *serv){return ((IClientSprayFixed *)new CSprayFixed(serv));}

//=======================================================
// class CSprayFixedResponse Implementation
//=======================================================

CSprayFixedResponse::CSprayFixedResponse(const char *serviceName, IRpcMessageBinding *init)
	: m_wuid(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("SprayFixedResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CSprayFixedResponse::CSprayFixedResponse(const char *serviceName, const char *bc)
	: m_wuid(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("SprayFixedResponse");
}

CSprayFixedResponse::CSprayFixedResponse(const char *serviceName, IRpcMessage* rpcmsg)
	: m_wuid(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("SprayFixedResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CSprayFixedResponse::CSprayFixedResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_wuid(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("SprayFixedResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CSprayFixedResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		schema.append("<xsd:element name=\"Exceptions\" type=\"tns:ArrayOfEspException\" minOccurs=\"0\" maxOccurs=\"1\"/>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"wuid\" type=\"xsd:string\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CSprayFixedResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CSprayFixedResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CSprayFixedResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("wuid");
	form.appendf("  <tr><td><b>wuid: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CSprayFixedResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CSprayFixedResponse::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
		m_wuid.marshall(rpc_resp, "wuid", "", "", "");
	}
}


void CSprayFixedResponse::copy(CSprayFixedResponse &from)
{
	m_wuid.copy(from.m_wuid);
}


void CSprayFixedResponse::copy(IConstSprayFixedResponse &ifrom)
{
	setWuid(ifrom.getWuid());
}


void CSprayFixedResponse::getAttributes(IProperties &attributes)
{
}


void CSprayFixedResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
		m_wuid.toStr(ctx, buffer, "wuid", "", true, "", "");
	}
}


void CSprayFixedResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CSprayFixedResponse::serializer(IEspContext* ctx, IConstSprayFixedResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<SprayFixedResponse>");
	// field wuid
	{
		const char* s = src.getWuid();
		if (s && *s)
		{
			buffer.append("<wuid>");
			encodeUtf8XML(s,buffer);
			buffer.append("</wuid>");
		}
	}
	if (keepRootTag)
		buffer.append("</SprayFixedResponse>");
}

bool CSprayFixedResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
		hasValue |= m_wuid.unmarshall(rpc_request, "wuid", basepath);
	}
	return hasValue;
}

bool CSprayFixedResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_wuid.unmarshall(ctx, soapval, "wuid");
	return hasValue;
}

bool CSprayFixedResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_wuid.unmarshall(ctx, params, attachments, "wuid", basepath);
	return hasValue;
}

const char * CSprayFixedResponse::getWuid() { return m_wuid.query();}
void CSprayFixedResponse::setWuid(const char * val){ m_wuid.set(val); }
extern "C"  IEspSprayFixedResponse *createSprayFixedResponse(const char *serv){return ((IEspSprayFixedResponse *)new CSprayFixedResponse(serv));}
extern "C"  IClientSprayFixedResponse *createClientSprayFixedResponse(const char *serv){return ((IClientSprayFixedResponse *)new CSprayFixedResponse(serv));}

//=======================================================
// class CSprayVariable Implementation
//=======================================================

CSprayVariable::CSprayVariable(const char *serviceName, IRpcMessageBinding *init)
	: m_sourceIP(nilRemove),m_sourcePath(nilRemove),m_srcxml(nilRemove),m_sourceMaxRecordSize(nilRemove),m_sourceFormat(nilRemove),m_NoSourceCsvSeparator(0, nilRemove,false),m_sourceCsvSeparate(nilRemove),m_sourceCsvTerminate(nilRemove),m_sourceCsvQuote(nilRemove),m_sourceCsvEscape(nilRemove),m_sourceRowTag(nilRemove),m_destGroup(nilRemove),m_destLogicalName(nilRemove),m_overwrite(nilRemove),m_replicate(nilRemove),m_ReplicateOffset(1, nilRemove,false),m_maxConnections(nilRemove),m_throttle(nilRemove),m_transferBufferSize(nilRemove),m_prefix(nilRemove),m_nosplit(0, nilRemove,false),m_norecover(0, nilRemove,false),m_compress(0, nilRemove,false),m_push(0, nilRemove,false),m_pull(0, nilRemove,false),m_encrypt(nilRemove),m_decrypt(nilRemove),m_failIfNoSourceFile(0, nilRemove,false),m_recordStructurePresent(0, nilRemove,false),m_quotedTerminator(1, nilRemove,false),m_sourceRowPath(nilRemove),m_isJSON(0, nilRemove,false),m_expireDays(nilRemove),m_DFUServerQueue(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("SprayVariable");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CSprayVariable::CSprayVariable(const char *serviceName, const char *bc)
	: m_sourceIP(nilRemove),m_sourcePath(nilRemove),m_srcxml(nilRemove),m_sourceMaxRecordSize(nilRemove),m_sourceFormat(nilRemove),m_NoSourceCsvSeparator(0, nilRemove,false),m_sourceCsvSeparate(nilRemove),m_sourceCsvTerminate(nilRemove),m_sourceCsvQuote(nilRemove),m_sourceCsvEscape(nilRemove),m_sourceRowTag(nilRemove),m_destGroup(nilRemove),m_destLogicalName(nilRemove),m_overwrite(nilRemove),m_replicate(nilRemove),m_ReplicateOffset(1, nilRemove,false),m_maxConnections(nilRemove),m_throttle(nilRemove),m_transferBufferSize(nilRemove),m_prefix(nilRemove),m_nosplit(0, nilRemove,false),m_norecover(0, nilRemove,false),m_compress(0, nilRemove,false),m_push(0, nilRemove,false),m_pull(0, nilRemove,false),m_encrypt(nilRemove),m_decrypt(nilRemove),m_failIfNoSourceFile(0, nilRemove,false),m_recordStructurePresent(0, nilRemove,false),m_quotedTerminator(1, nilRemove,false),m_sourceRowPath(nilRemove),m_isJSON(0, nilRemove,false),m_expireDays(nilRemove),m_DFUServerQueue(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("SprayVariable");
}

CSprayVariable::CSprayVariable(const char *serviceName, IRpcMessage* rpcmsg)
	: m_sourceIP(nilRemove),m_sourcePath(nilRemove),m_srcxml(nilRemove),m_sourceMaxRecordSize(nilRemove),m_sourceFormat(nilRemove),m_NoSourceCsvSeparator(0, nilRemove,false),m_sourceCsvSeparate(nilRemove),m_sourceCsvTerminate(nilRemove),m_sourceCsvQuote(nilRemove),m_sourceCsvEscape(nilRemove),m_sourceRowTag(nilRemove),m_destGroup(nilRemove),m_destLogicalName(nilRemove),m_overwrite(nilRemove),m_replicate(nilRemove),m_ReplicateOffset(1, nilRemove,false),m_maxConnections(nilRemove),m_throttle(nilRemove),m_transferBufferSize(nilRemove),m_prefix(nilRemove),m_nosplit(0, nilRemove,false),m_norecover(0, nilRemove,false),m_compress(0, nilRemove,false),m_push(0, nilRemove,false),m_pull(0, nilRemove,false),m_encrypt(nilRemove),m_decrypt(nilRemove),m_failIfNoSourceFile(0, nilRemove,false),m_recordStructurePresent(0, nilRemove,false),m_quotedTerminator(1, nilRemove,false),m_sourceRowPath(nilRemove),m_isJSON(0, nilRemove,false),m_expireDays(nilRemove),m_DFUServerQueue(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("SprayVariable");
	unserialize(*rpcmsg,NULL,NULL);
}

CSprayVariable::CSprayVariable(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_sourceIP(nilRemove),m_sourcePath(nilRemove),m_srcxml(nilRemove),m_sourceMaxRecordSize(nilRemove),m_sourceFormat(nilRemove),m_NoSourceCsvSeparator(0, nilRemove,false),m_sourceCsvSeparate(nilRemove),m_sourceCsvTerminate(nilRemove),m_sourceCsvQuote(nilRemove),m_sourceCsvEscape(nilRemove),m_sourceRowTag(nilRemove),m_destGroup(nilRemove),m_destLogicalName(nilRemove),m_overwrite(nilRemove),m_replicate(nilRemove),m_ReplicateOffset(1, nilRemove,false),m_maxConnections(nilRemove),m_throttle(nilRemove),m_transferBufferSize(nilRemove),m_prefix(nilRemove),m_nosplit(0, nilRemove,false),m_norecover(0, nilRemove,false),m_compress(0, nilRemove,false),m_push(0, nilRemove,false),m_pull(0, nilRemove,false),m_encrypt(nilRemove),m_decrypt(nilRemove),m_failIfNoSourceFile(0, nilRemove,false),m_recordStructurePresent(0, nilRemove,false),m_quotedTerminator(1, nilRemove,false),m_sourceRowPath(nilRemove),m_isJSON(0, nilRemove,false),m_expireDays(nilRemove),m_DFUServerQueue(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("SprayVariable");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CSprayVariable::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"sourceIP\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"sourcePath\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"srcxml\" type=\"xsd:base64Binary\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"sourceMaxRecordSize\" type=\"xsd:int\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"sourceFormat\" type=\"xsd:int\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" default=\"false\" name=\"NoSourceCsvSeparator\" type=\"xsd:boolean\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"sourceCsvSeparate\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"sourceCsvTerminate\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"sourceCsvQuote\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"sourceCsvEscape\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"sourceRowTag\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"destGroup\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"destLogicalName\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"overwrite\" type=\"xsd:boolean\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"replicate\" type=\"xsd:boolean\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" default=\"1\" name=\"ReplicateOffset\" type=\"xsd:int\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"maxConnections\" type=\"xsd:int\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"throttle\" type=\"xsd:int\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"transferBufferSize\" type=\"xsd:int\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"prefix\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" default=\"false\" name=\"nosplit\" type=\"xsd:boolean\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" default=\"false\" name=\"norecover\" type=\"xsd:boolean\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" default=\"false\" name=\"compress\" type=\"xsd:boolean\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" default=\"false\" name=\"push\" type=\"xsd:boolean\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" default=\"false\" name=\"pull\" type=\"xsd:boolean\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"encrypt\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"decrypt\" type=\"xsd:string\"/>\n");
		if (!context.suppressed("SprayVariable","failIfNoSourceFile")) {
			schema.append("<xsd:element minOccurs=\"0\" default=\"false\" name=\"failIfNoSourceFile\" type=\"xsd:boolean\"/>\n");
		}
		if (!context.suppressed("SprayVariable","recordStructurePresent")) {
			schema.append("<xsd:element minOccurs=\"0\" default=\"false\" name=\"recordStructurePresent\" type=\"xsd:boolean\"/>\n");
		}
		if (!context.suppressed("SprayVariable","quotedTerminator")) {
			schema.append("<xsd:element minOccurs=\"0\" default=\"true\" name=\"quotedTerminator\" type=\"xsd:boolean\"/>\n");
		}
		if (!context.suppressed("SprayVariable","sourceRowPath")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"sourceRowPath\" type=\"xsd:string\"/>\n");
		}
		if (!context.suppressed("SprayVariable","isJSON")) {
			schema.append("<xsd:element minOccurs=\"0\" default=\"false\" name=\"isJSON\" type=\"xsd:boolean\"/>\n");
		}
		if (!context.suppressed("SprayVariable","expireDays")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"expireDays\" type=\"xsd:int\"/>\n");
		}
		if (!context.suppressed("SprayVariable","DFUServerQueue")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"DFUServerQueue\" type=\"xsd:string\"/>\n");
		}
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CSprayVariable::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CSprayVariable::getMapInfo(IMapInfo& info, BoolHash& added)
{
	info.addMinVersion("SprayVariable","failIfNoSourceFile",1.08);
	info.addMinVersion("SprayVariable","recordStructurePresent",1.09);
	info.addMinVersion("SprayVariable","quotedTerminator",1.1);
	info.addMinVersion("SprayVariable","sourceRowPath",1.11);
	info.addMinVersion("SprayVariable","isJSON",1.11);
	info.addMinVersion("SprayVariable","expireDays",1.14);
	info.addMinVersion("SprayVariable","DFUServerQueue",1.14);
}

StringBuffer &CSprayVariable::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("sourceIP");
	form.appendf("  <tr><td><b>sourceIP: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("sourcePath");
	form.appendf("  <tr><td><b>sourcePath: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("srcxml");
	form.appendf("  <tr><td><b>srcxml: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix) extfix.append(prefix).append(".");
		extfix.append("sourceMaxRecordSize");
	form.appendf("  <tr><td><b>sourceMaxRecordSize: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix) extfix.append(prefix).append(".");
		extfix.append("sourceFormat");
	form.appendf("  <tr><td><b>sourceFormat: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("NoSourceCsvSeparator");
	
	form.appendf("  <tr><td><b>NoSourceCsvSeparator? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("sourceCsvSeparate");
	form.appendf("  <tr><td><b>sourceCsvSeparate: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("sourceCsvTerminate");
	form.appendf("  <tr><td><b>sourceCsvTerminate: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("sourceCsvQuote");
	form.appendf("  <tr><td><b>sourceCsvQuote: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("sourceCsvEscape");
	form.appendf("  <tr><td><b>sourceCsvEscape: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("sourceRowTag");
	form.appendf("  <tr><td><b>sourceRowTag: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("destGroup");
	form.appendf("  <tr><td><b>destGroup: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("destLogicalName");
	form.appendf("  <tr><td><b>destLogicalName: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("overwrite");
	
	form.appendf("  <tr><td><b>overwrite? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("replicate");
	
	form.appendf("  <tr><td><b>replicate? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	extfix.clear();
	if (prefix && *prefix) extfix.append(prefix).append(".");
		extfix.append("ReplicateOffset");
	form.appendf("  <tr><td><b>ReplicateOffset: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"	 value=\"1\"/>", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix) extfix.append(prefix).append(".");
		extfix.append("maxConnections");
	form.appendf("  <tr><td><b>maxConnections: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix) extfix.append(prefix).append(".");
		extfix.append("throttle");
	form.appendf("  <tr><td><b>throttle: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix) extfix.append(prefix).append(".");
		extfix.append("transferBufferSize");
	form.appendf("  <tr><td><b>transferBufferSize: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("prefix");
	form.appendf("  <tr><td><b>prefix: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("nosplit");
	
	form.appendf("  <tr><td><b>nosplit? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("norecover");
	
	form.appendf("  <tr><td><b>norecover? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("compress");
	
	form.appendf("  <tr><td><b>compress? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("push");
	
	form.appendf("  <tr><td><b>push? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("pull");
	
	form.appendf("  <tr><td><b>pull? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("encrypt");
	form.appendf("  <tr><td><b>encrypt: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("decrypt");
	form.appendf("  <tr><td><b>decrypt: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (!context.suppressed("SprayVariable","failIfNoSourceFile")) {
		extfix.clear();
		if (prefix && *prefix)
			extfix.append(prefix).append(".");
		extfix.append("failIfNoSourceFile");
		
	form.appendf("  <tr><td><b>failIfNoSourceFile? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	}
	if (!context.suppressed("SprayVariable","recordStructurePresent")) {
		extfix.clear();
		if (prefix && *prefix)
			extfix.append(prefix).append(".");
		extfix.append("recordStructurePresent");
		
	form.appendf("  <tr><td><b>recordStructurePresent? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	}
	if (!context.suppressed("SprayVariable","quotedTerminator")) {
		extfix.clear();
		if (prefix && *prefix)
			extfix.append(prefix).append(".");
		extfix.append("quotedTerminator");
		
	form.appendf("  <tr><td><b>quotedTerminator? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\" checked=\"1\" /></td></tr>\n", extfix.str());
	}
	if (!context.suppressed("SprayVariable","sourceRowPath")) {
		extfix.clear();
		if (prefix && *prefix)
			extfix.append(prefix).append(".");
		extfix.append("sourceRowPath");
		form.appendf("  <tr><td><b>sourceRowPath: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
		form.append("</td></tr>\n");
	}
	if (!context.suppressed("SprayVariable","isJSON")) {
		extfix.clear();
		if (prefix && *prefix)
			extfix.append(prefix).append(".");
		extfix.append("isJSON");
		
	form.appendf("  <tr><td><b>isJSON? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	}
	if (!context.suppressed("SprayVariable","expireDays")) {
		extfix.clear();
		if (prefix && *prefix) extfix.append(prefix).append(".");
			extfix.append("expireDays");
		form.appendf("  <tr><td><b>expireDays: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
		form.append("</td></tr>\n");
	}
	if (!context.suppressed("SprayVariable","DFUServerQueue")) {
		extfix.clear();
		if (prefix && *prefix)
			extfix.append(prefix).append(".");
		extfix.append("DFUServerQueue");
		form.appendf("  <tr><td><b>DFUServerQueue: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
		form.append("</td></tr>\n");
	}
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CSprayVariable::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CSprayVariable::serialize(IRpcMessage& rpc_resp)
{
	IEspContext* ctx = rpc_resp.queryContext();
	double clientVer= ctx ? ctx->getClientVersion() : -1; /* no context gets everything */
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_sourceIP.marshall(rpc_resp, "sourceIP", "", "", "");
	m_sourcePath.marshall(rpc_resp, "sourcePath", "", "", "");
	m_srcxml.marshall(rpc_resp, "srcxml", "", "", "");
	m_sourceMaxRecordSize.marshall(rpc_resp, "sourceMaxRecordSize", "", "", "");
	m_sourceFormat.marshall(rpc_resp, "sourceFormat", "", "", "");
	m_NoSourceCsvSeparator.marshall(rpc_resp, "NoSourceCsvSeparator", "", "", "");
	m_sourceCsvSeparate.marshall(rpc_resp, "sourceCsvSeparate", "", "", "");
	m_sourceCsvTerminate.marshall(rpc_resp, "sourceCsvTerminate", "", "", "");
	m_sourceCsvQuote.marshall(rpc_resp, "sourceCsvQuote", "", "", "");
	m_sourceCsvEscape.marshall(rpc_resp, "sourceCsvEscape", "", "", "");
	m_sourceRowTag.marshall(rpc_resp, "sourceRowTag", "", "", "");
	m_destGroup.marshall(rpc_resp, "destGroup", "", "", "");
	m_destLogicalName.marshall(rpc_resp, "destLogicalName", "", "", "");
	m_overwrite.marshall(rpc_resp, "overwrite", "", "", "");
	m_replicate.marshall(rpc_resp, "replicate", "", "", "");
	m_ReplicateOffset.marshall(rpc_resp, "ReplicateOffset", "", "", "");
	m_maxConnections.marshall(rpc_resp, "maxConnections", "", "", "");
	m_throttle.marshall(rpc_resp, "throttle", "", "", "");
	m_transferBufferSize.marshall(rpc_resp, "transferBufferSize", "", "", "");
	m_prefix.marshall(rpc_resp, "prefix", "", "", "");
	m_nosplit.marshall(rpc_resp, "nosplit", "", "", "");
	m_norecover.marshall(rpc_resp, "norecover", "", "", "");
	m_compress.marshall(rpc_resp, "compress", "", "", "");
	m_push.marshall(rpc_resp, "push", "", "", "");
	m_pull.marshall(rpc_resp, "pull", "", "", "");
	m_encrypt.marshall(rpc_resp, "encrypt", "", "", "");
	m_decrypt.marshall(rpc_resp, "decrypt", "", "", "");
	if ((clientVer==-1.0 || clientVer>=1.08))
		m_failIfNoSourceFile.marshall(rpc_resp, "failIfNoSourceFile", "", "", "");
	if ((clientVer==-1.0 || clientVer>=1.09))
		m_recordStructurePresent.marshall(rpc_resp, "recordStructurePresent", "", "", "");
	if ((clientVer==-1.0 || clientVer>=1.1))
		m_quotedTerminator.marshall(rpc_resp, "quotedTerminator", "", "", "");
	if ((clientVer==-1.0 || clientVer>=1.11))
		m_sourceRowPath.marshall(rpc_resp, "sourceRowPath", "", "", "");
	if ((clientVer==-1.0 || clientVer>=1.11))
		m_isJSON.marshall(rpc_resp, "isJSON", "", "", "");
	if ((clientVer==-1.0 || clientVer>=1.14))
		m_expireDays.marshall(rpc_resp, "expireDays", "", "", "");
	if ((clientVer==-1.0 || clientVer>=1.14))
		m_DFUServerQueue.marshall(rpc_resp, "DFUServerQueue", "", "", "");
}


void CSprayVariable::copy(CSprayVariable &from)
{
	m_sourceIP.copy(from.m_sourceIP);
	m_sourcePath.copy(from.m_sourcePath);
	m_srcxml.copy(from.m_srcxml);
	m_sourceMaxRecordSize.copy(from.m_sourceMaxRecordSize);
	m_sourceFormat.copy(from.m_sourceFormat);
	m_NoSourceCsvSeparator.copy(from.m_NoSourceCsvSeparator);
	m_sourceCsvSeparate.copy(from.m_sourceCsvSeparate);
	m_sourceCsvTerminate.copy(from.m_sourceCsvTerminate);
	m_sourceCsvQuote.copy(from.m_sourceCsvQuote);
	m_sourceCsvEscape.copy(from.m_sourceCsvEscape);
	m_sourceRowTag.copy(from.m_sourceRowTag);
	m_destGroup.copy(from.m_destGroup);
	m_destLogicalName.copy(from.m_destLogicalName);
	m_overwrite.copy(from.m_overwrite);
	m_replicate.copy(from.m_replicate);
	m_ReplicateOffset.copy(from.m_ReplicateOffset);
	m_maxConnections.copy(from.m_maxConnections);
	m_throttle.copy(from.m_throttle);
	m_transferBufferSize.copy(from.m_transferBufferSize);
	m_prefix.copy(from.m_prefix);
	m_nosplit.copy(from.m_nosplit);
	m_norecover.copy(from.m_norecover);
	m_compress.copy(from.m_compress);
	m_push.copy(from.m_push);
	m_pull.copy(from.m_pull);
	m_encrypt.copy(from.m_encrypt);
	m_decrypt.copy(from.m_decrypt);
	m_failIfNoSourceFile.copy(from.m_failIfNoSourceFile);
	m_recordStructurePresent.copy(from.m_recordStructurePresent);
	m_quotedTerminator.copy(from.m_quotedTerminator);
	m_sourceRowPath.copy(from.m_sourceRowPath);
	m_isJSON.copy(from.m_isJSON);
	m_expireDays.copy(from.m_expireDays);
	m_DFUServerQueue.copy(from.m_DFUServerQueue);
}


void CSprayVariable::copy(IConstSprayVariable &ifrom)
{
	setSourceIP(ifrom.getSourceIP());
	setSourcePath(ifrom.getSourcePath());
	setSrcxml(ifrom.getSrcxml());
	setSourceMaxRecordSize(ifrom.getSourceMaxRecordSize());
	setSourceFormat(ifrom.getSourceFormat());
	setNoSourceCsvSeparator(ifrom.getNoSourceCsvSeparator());
	setSourceCsvSeparate(ifrom.getSourceCsvSeparate());
	setSourceCsvTerminate(ifrom.getSourceCsvTerminate());
	setSourceCsvQuote(ifrom.getSourceCsvQuote());
	setSourceCsvEscape(ifrom.getSourceCsvEscape());
	setSourceRowTag(ifrom.getSourceRowTag());
	setDestGroup(ifrom.getDestGroup());
	setDestLogicalName(ifrom.getDestLogicalName());
	setOverwrite(ifrom.getOverwrite());
	setReplicate(ifrom.getReplicate());
	setReplicateOffset(ifrom.getReplicateOffset());
	setMaxConnections(ifrom.getMaxConnections());
	setThrottle(ifrom.getThrottle());
	setTransferBufferSize(ifrom.getTransferBufferSize());
	setPrefix(ifrom.getPrefix());
	setNosplit(ifrom.getNosplit());
	setNorecover(ifrom.getNorecover());
	setCompress(ifrom.getCompress());
	setPush(ifrom.getPush());
	setPull(ifrom.getPull());
	setEncrypt(ifrom.getEncrypt());
	setDecrypt(ifrom.getDecrypt());
	setFailIfNoSourceFile(ifrom.getFailIfNoSourceFile());
	setRecordStructurePresent(ifrom.getRecordStructurePresent());
	setQuotedTerminator(ifrom.getQuotedTerminator());
	setSourceRowPath(ifrom.getSourceRowPath());
	setIsJSON(ifrom.getIsJSON());
	setExpireDays(ifrom.getExpireDays());
	setDFUServerQueue(ifrom.getDFUServerQueue());
}


void CSprayVariable::getAttributes(IProperties &attributes)
{
}


void CSprayVariable::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	double clientVer = ctx ? ctx->getClientVersion() : -1;
	m_sourceIP.toStr(ctx, buffer, "sourceIP", "", true, "", "");
	m_sourcePath.toStr(ctx, buffer, "sourcePath", "", true, "", "");
	m_srcxml.toStr(ctx, buffer, "srcxml", "", true, "", "");
	m_sourceMaxRecordSize.toStr(ctx, buffer, "sourceMaxRecordSize", "", true, "", "");
	m_sourceFormat.toStr(ctx, buffer, "sourceFormat", "", true, "", "");
	m_NoSourceCsvSeparator.toStr(ctx, buffer, "NoSourceCsvSeparator", "", true, "", "");
	m_sourceCsvSeparate.toStr(ctx, buffer, "sourceCsvSeparate", "", true, "", "");
	m_sourceCsvTerminate.toStr(ctx, buffer, "sourceCsvTerminate", "", true, "", "");
	m_sourceCsvQuote.toStr(ctx, buffer, "sourceCsvQuote", "", true, "", "");
	m_sourceCsvEscape.toStr(ctx, buffer, "sourceCsvEscape", "", true, "", "");
	m_sourceRowTag.toStr(ctx, buffer, "sourceRowTag", "", true, "", "");
	m_destGroup.toStr(ctx, buffer, "destGroup", "", true, "", "");
	m_destLogicalName.toStr(ctx, buffer, "destLogicalName", "", true, "", "");
	m_overwrite.toStr(ctx, buffer, "overwrite", "", true, "", "");
	m_replicate.toStr(ctx, buffer, "replicate", "", true, "", "");
	m_ReplicateOffset.toStr(ctx, buffer, "ReplicateOffset", "", true, "", "");
	m_maxConnections.toStr(ctx, buffer, "maxConnections", "", true, "", "");
	m_throttle.toStr(ctx, buffer, "throttle", "", true, "", "");
	m_transferBufferSize.toStr(ctx, buffer, "transferBufferSize", "", true, "", "");
	m_prefix.toStr(ctx, buffer, "prefix", "", true, "", "");
	m_nosplit.toStr(ctx, buffer, "nosplit", "", true, "", "");
	m_norecover.toStr(ctx, buffer, "norecover", "", true, "", "");
	m_compress.toStr(ctx, buffer, "compress", "", true, "", "");
	m_push.toStr(ctx, buffer, "push", "", true, "", "");
	m_pull.toStr(ctx, buffer, "pull", "", true, "", "");
	m_encrypt.toStr(ctx, buffer, "encrypt", "", true, "", "");
	m_decrypt.toStr(ctx, buffer, "decrypt", "", true, "", "");
	if ((clientVer==-1.0 || clientVer>=1.08))
		m_failIfNoSourceFile.toStr(ctx, buffer, "failIfNoSourceFile", "", true, "", "");
	if ((clientVer==-1.0 || clientVer>=1.09))
		m_recordStructurePresent.toStr(ctx, buffer, "recordStructurePresent", "", true, "", "");
	if ((clientVer==-1.0 || clientVer>=1.1))
		m_quotedTerminator.toStr(ctx, buffer, "quotedTerminator", "", true, "", "");
	if ((clientVer==-1.0 || clientVer>=1.11))
		m_sourceRowPath.toStr(ctx, buffer, "sourceRowPath", "", true, "", "");
	if ((clientVer==-1.0 || clientVer>=1.11))
		m_isJSON.toStr(ctx, buffer, "isJSON", "", true, "", "");
	if ((clientVer==-1.0 || clientVer>=1.14))
		m_expireDays.toStr(ctx, buffer, "expireDays", "", true, "", "");
	if ((clientVer==-1.0 || clientVer>=1.14))
		m_DFUServerQueue.toStr(ctx, buffer, "DFUServerQueue", "", true, "", "");
}


void CSprayVariable::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CSprayVariable::serializer(IEspContext* ctx, IConstSprayVariable &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<SprayVariable>");
	double clientVer = ctx ? ctx->getClientVersion() : -1;
	// field sourceIP
	{
		const char* s = src.getSourceIP();
		if (s && *s)
		{
			buffer.append("<sourceIP>");
			encodeUtf8XML(s,buffer);
			buffer.append("</sourceIP>");
		}
	}
	// field sourcePath
	{
		const char* s = src.getSourcePath();
		if (s && *s)
		{
			buffer.append("<sourcePath>");
			encodeUtf8XML(s,buffer);
			buffer.append("</sourcePath>");
		}
	}
	// field srcxml
	{
		StringBuffer tmp;
		JBASE64_Encode(src.getSrcxml().toByteArray(), src.getSrcxml().length(), tmp);
		if (tmp.length()>0)
			buffer.appendf("<srcxml>%s</srcxml>",tmp.str());
	}
	// field sourceMaxRecordSize
	{
		int n = src.getSourceMaxRecordSize();
		if (n)
			buffer.appendf("<sourceMaxRecordSize>%d</sourceMaxRecordSize>", n);
	}
	// field sourceFormat
	{
		int n = src.getSourceFormat();
		if (n)
			buffer.appendf("<sourceFormat>%d</sourceFormat>", n);
	}
	// field NoSourceCsvSeparator
	{
		bool b = src.getNoSourceCsvSeparator();
		if (b)
			buffer.appendf("<NoSourceCsvSeparator>1</NoSourceCsvSeparator>");
	}
	// field sourceCsvSeparate
	{
		const char* s = src.getSourceCsvSeparate();
		if (s && *s)
		{
			buffer.append("<sourceCsvSeparate>");
			encodeUtf8XML(s,buffer);
			buffer.append("</sourceCsvSeparate>");
		}
	}
	// field sourceCsvTerminate
	{
		const char* s = src.getSourceCsvTerminate();
		if (s && *s)
		{
			buffer.append("<sourceCsvTerminate>");
			encodeUtf8XML(s,buffer);
			buffer.append("</sourceCsvTerminate>");
		}
	}
	// field sourceCsvQuote
	{
		const char* s = src.getSourceCsvQuote();
		if (s && *s)
		{
			buffer.append("<sourceCsvQuote>");
			encodeUtf8XML(s,buffer);
			buffer.append("</sourceCsvQuote>");
		}
	}
	// field sourceCsvEscape
	{
		const char* s = src.getSourceCsvEscape();
		if (s && *s)
		{
			buffer.append("<sourceCsvEscape>");
			encodeUtf8XML(s,buffer);
			buffer.append("</sourceCsvEscape>");
		}
	}
	// field sourceRowTag
	{
		const char* s = src.getSourceRowTag();
		if (s && *s)
		{
			buffer.append("<sourceRowTag>");
			encodeUtf8XML(s,buffer);
			buffer.append("</sourceRowTag>");
		}
	}
	// field destGroup
	{
		const char* s = src.getDestGroup();
		if (s && *s)
		{
			buffer.append("<destGroup>");
			encodeUtf8XML(s,buffer);
			buffer.append("</destGroup>");
		}
	}
	// field destLogicalName
	{
		const char* s = src.getDestLogicalName();
		if (s && *s)
		{
			buffer.append("<destLogicalName>");
			encodeUtf8XML(s,buffer);
			buffer.append("</destLogicalName>");
		}
	}
	// field overwrite
	{
		bool b = src.getOverwrite();
		if (b)
			buffer.appendf("<overwrite>1</overwrite>");
	}
	// field replicate
	{
		bool b = src.getReplicate();
		if (b)
			buffer.appendf("<replicate>1</replicate>");
	}
	// field ReplicateOffset
	{
		int n = src.getReplicateOffset();
		if (n)
			buffer.appendf("<ReplicateOffset>%d</ReplicateOffset>", n);
	}
	// field maxConnections
	{
		int n = src.getMaxConnections();
		if (n)
			buffer.appendf("<maxConnections>%d</maxConnections>", n);
	}
	// field throttle
	{
		int n = src.getThrottle();
		if (n)
			buffer.appendf("<throttle>%d</throttle>", n);
	}
	// field transferBufferSize
	{
		int n = src.getTransferBufferSize();
		if (n)
			buffer.appendf("<transferBufferSize>%d</transferBufferSize>", n);
	}
	// field prefix
	{
		const char* s = src.getPrefix();
		if (s && *s)
		{
			buffer.append("<prefix>");
			encodeUtf8XML(s,buffer);
			buffer.append("</prefix>");
		}
	}
	// field nosplit
	{
		bool b = src.getNosplit();
		if (b)
			buffer.appendf("<nosplit>1</nosplit>");
	}
	// field norecover
	{
		bool b = src.getNorecover();
		if (b)
			buffer.appendf("<norecover>1</norecover>");
	}
	// field compress
	{
		bool b = src.getCompress();
		if (b)
			buffer.appendf("<compress>1</compress>");
	}
	// field push
	{
		bool b = src.getPush();
		if (b)
			buffer.appendf("<push>1</push>");
	}
	// field pull
	{
		bool b = src.getPull();
		if (b)
			buffer.appendf("<pull>1</pull>");
	}
	// field encrypt
	{
		const char* s = src.getEncrypt();
		if (s && *s)
		{
			buffer.append("<encrypt>");
			encodeUtf8XML(s,buffer);
			buffer.append("</encrypt>");
		}
	}
	// field decrypt
	{
		const char* s = src.getDecrypt();
		if (s && *s)
		{
			buffer.append("<decrypt>");
			encodeUtf8XML(s,buffer);
			buffer.append("</decrypt>");
		}
	}
	// field failIfNoSourceFile
	if ((clientVer==-1.0 || clientVer>=1.08))
	{
		bool b = src.getFailIfNoSourceFile();
		if (b)
			buffer.appendf("<failIfNoSourceFile>1</failIfNoSourceFile>");
	}
	// field recordStructurePresent
	if ((clientVer==-1.0 || clientVer>=1.09))
	{
		bool b = src.getRecordStructurePresent();
		if (b)
			buffer.appendf("<recordStructurePresent>1</recordStructurePresent>");
	}
	// field quotedTerminator
	if ((clientVer==-1.0 || clientVer>=1.1))
	{
		bool b = src.getQuotedTerminator();
		if (b)
			buffer.appendf("<quotedTerminator>1</quotedTerminator>");
	}
	// field sourceRowPath
	if ((clientVer==-1.0 || clientVer>=1.11))
	{
		const char* s = src.getSourceRowPath();
		if (s && *s)
		{
			buffer.append("<sourceRowPath>");
			encodeUtf8XML(s,buffer);
			buffer.append("</sourceRowPath>");
		}
	}
	// field isJSON
	if ((clientVer==-1.0 || clientVer>=1.11))
	{
		bool b = src.getIsJSON();
		if (b)
			buffer.appendf("<isJSON>1</isJSON>");
	}
	// field expireDays
	if ((clientVer==-1.0 || clientVer>=1.14))
	{
		int n = src.getExpireDays();
		if (n)
			buffer.appendf("<expireDays>%d</expireDays>", n);
	}
	// field DFUServerQueue
	if ((clientVer==-1.0 || clientVer>=1.14))
	{
		const char* s = src.getDFUServerQueue();
		if (s && *s)
		{
			buffer.append("<DFUServerQueue>");
			encodeUtf8XML(s,buffer);
			buffer.append("</DFUServerQueue>");
		}
	}
	if (keepRootTag)
		buffer.append("</SprayVariable>");
}

bool CSprayVariable::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_sourceIP.unmarshall(rpc_request, "sourceIP", basepath);
	hasValue |= m_sourcePath.unmarshall(rpc_request, "sourcePath", basepath);
	hasValue |= m_srcxml.unmarshall(rpc_request, "srcxml", basepath);
	hasValue |= m_sourceMaxRecordSize.unmarshall(rpc_request, "sourceMaxRecordSize", basepath);
	hasValue |= m_sourceFormat.unmarshall(rpc_request, "sourceFormat", basepath);
	hasValue |= m_NoSourceCsvSeparator.unmarshall(rpc_request, "NoSourceCsvSeparator", basepath);
	hasValue |= m_sourceCsvSeparate.unmarshall(rpc_request, "sourceCsvSeparate", basepath);
	hasValue |= m_sourceCsvTerminate.unmarshall(rpc_request, "sourceCsvTerminate", basepath);
	hasValue |= m_sourceCsvQuote.unmarshall(rpc_request, "sourceCsvQuote", basepath);
	hasValue |= m_sourceCsvEscape.unmarshall(rpc_request, "sourceCsvEscape", basepath);
	hasValue |= m_sourceRowTag.unmarshall(rpc_request, "sourceRowTag", basepath);
	hasValue |= m_destGroup.unmarshall(rpc_request, "destGroup", basepath);
	hasValue |= m_destLogicalName.unmarshall(rpc_request, "destLogicalName", basepath);
	hasValue |= m_overwrite.unmarshall(rpc_request, "overwrite", basepath);
	hasValue |= m_replicate.unmarshall(rpc_request, "replicate", basepath);
	hasValue |= m_ReplicateOffset.unmarshall(rpc_request, "ReplicateOffset", basepath);
	hasValue |= m_maxConnections.unmarshall(rpc_request, "maxConnections", basepath);
	hasValue |= m_throttle.unmarshall(rpc_request, "throttle", basepath);
	hasValue |= m_transferBufferSize.unmarshall(rpc_request, "transferBufferSize", basepath);
	hasValue |= m_prefix.unmarshall(rpc_request, "prefix", basepath);
	hasValue |= m_nosplit.unmarshall(rpc_request, "nosplit", basepath);
	hasValue |= m_norecover.unmarshall(rpc_request, "norecover", basepath);
	hasValue |= m_compress.unmarshall(rpc_request, "compress", basepath);
	hasValue |= m_push.unmarshall(rpc_request, "push", basepath);
	hasValue |= m_pull.unmarshall(rpc_request, "pull", basepath);
	hasValue |= m_encrypt.unmarshall(rpc_request, "encrypt", basepath);
	hasValue |= m_decrypt.unmarshall(rpc_request, "decrypt", basepath);
	hasValue |= m_failIfNoSourceFile.unmarshall(rpc_request, "failIfNoSourceFile", basepath);
	hasValue |= m_recordStructurePresent.unmarshall(rpc_request, "recordStructurePresent", basepath);
	hasValue |= m_quotedTerminator.unmarshall(rpc_request, "quotedTerminator", basepath);
	hasValue |= m_sourceRowPath.unmarshall(rpc_request, "sourceRowPath", basepath);
	hasValue |= m_isJSON.unmarshall(rpc_request, "isJSON", basepath);
	hasValue |= m_expireDays.unmarshall(rpc_request, "expireDays", basepath);
	hasValue |= m_DFUServerQueue.unmarshall(rpc_request, "DFUServerQueue", basepath);
	return hasValue;
}

bool CSprayVariable::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_sourceIP.unmarshall(ctx, soapval, "sourceIP");
	hasValue |= m_sourcePath.unmarshall(ctx, soapval, "sourcePath");
	hasValue |= m_srcxml.unmarshall(ctx, soapval, "srcxml");
	hasValue |= m_sourceMaxRecordSize.unmarshall(ctx, soapval, "sourceMaxRecordSize");
	hasValue |= m_sourceFormat.unmarshall(ctx, soapval, "sourceFormat");
	hasValue |= m_NoSourceCsvSeparator.unmarshall(ctx, soapval, "NoSourceCsvSeparator");
	hasValue |= m_sourceCsvSeparate.unmarshall(ctx, soapval, "sourceCsvSeparate");
	hasValue |= m_sourceCsvTerminate.unmarshall(ctx, soapval, "sourceCsvTerminate");
	hasValue |= m_sourceCsvQuote.unmarshall(ctx, soapval, "sourceCsvQuote");
	hasValue |= m_sourceCsvEscape.unmarshall(ctx, soapval, "sourceCsvEscape");
	hasValue |= m_sourceRowTag.unmarshall(ctx, soapval, "sourceRowTag");
	hasValue |= m_destGroup.unmarshall(ctx, soapval, "destGroup");
	hasValue |= m_destLogicalName.unmarshall(ctx, soapval, "destLogicalName");
	hasValue |= m_overwrite.unmarshall(ctx, soapval, "overwrite");
	hasValue |= m_replicate.unmarshall(ctx, soapval, "replicate");
	hasValue |= m_ReplicateOffset.unmarshall(ctx, soapval, "ReplicateOffset");
	hasValue |= m_maxConnections.unmarshall(ctx, soapval, "maxConnections");
	hasValue |= m_throttle.unmarshall(ctx, soapval, "throttle");
	hasValue |= m_transferBufferSize.unmarshall(ctx, soapval, "transferBufferSize");
	hasValue |= m_prefix.unmarshall(ctx, soapval, "prefix");
	hasValue |= m_nosplit.unmarshall(ctx, soapval, "nosplit");
	hasValue |= m_norecover.unmarshall(ctx, soapval, "norecover");
	hasValue |= m_compress.unmarshall(ctx, soapval, "compress");
	hasValue |= m_push.unmarshall(ctx, soapval, "push");
	hasValue |= m_pull.unmarshall(ctx, soapval, "pull");
	hasValue |= m_encrypt.unmarshall(ctx, soapval, "encrypt");
	hasValue |= m_decrypt.unmarshall(ctx, soapval, "decrypt");
	hasValue |= m_failIfNoSourceFile.unmarshall(ctx, soapval, "failIfNoSourceFile");
	hasValue |= m_recordStructurePresent.unmarshall(ctx, soapval, "recordStructurePresent");
	hasValue |= m_quotedTerminator.unmarshall(ctx, soapval, "quotedTerminator");
	hasValue |= m_sourceRowPath.unmarshall(ctx, soapval, "sourceRowPath");
	hasValue |= m_isJSON.unmarshall(ctx, soapval, "isJSON");
	hasValue |= m_expireDays.unmarshall(ctx, soapval, "expireDays");
	hasValue |= m_DFUServerQueue.unmarshall(ctx, soapval, "DFUServerQueue");
	return hasValue;
}

bool CSprayVariable::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_sourceIP.unmarshall(ctx, params, attachments, "sourceIP", basepath);
	hasValue |= m_sourcePath.unmarshall(ctx, params, attachments, "sourcePath", basepath);
	hasValue |= m_srcxml.unmarshall(ctx, params, attachments, "srcxml", basepath);
	hasValue |= m_sourceMaxRecordSize.unmarshall(ctx, params, attachments, "sourceMaxRecordSize", basepath);
	hasValue |= m_sourceFormat.unmarshall(ctx, params, attachments, "sourceFormat", basepath);
	hasValue |= m_NoSourceCsvSeparator.unmarshall(ctx, params, attachments, "NoSourceCsvSeparator", basepath);
	hasValue |= m_sourceCsvSeparate.unmarshall(ctx, params, attachments, "sourceCsvSeparate", basepath);
	hasValue |= m_sourceCsvTerminate.unmarshall(ctx, params, attachments, "sourceCsvTerminate", basepath);
	hasValue |= m_sourceCsvQuote.unmarshall(ctx, params, attachments, "sourceCsvQuote", basepath);
	hasValue |= m_sourceCsvEscape.unmarshall(ctx, params, attachments, "sourceCsvEscape", basepath);
	hasValue |= m_sourceRowTag.unmarshall(ctx, params, attachments, "sourceRowTag", basepath);
	hasValue |= m_destGroup.unmarshall(ctx, params, attachments, "destGroup", basepath);
	hasValue |= m_destLogicalName.unmarshall(ctx, params, attachments, "destLogicalName", basepath);
	hasValue |= m_overwrite.unmarshall(ctx, params, attachments, "overwrite", basepath);
	hasValue |= m_replicate.unmarshall(ctx, params, attachments, "replicate", basepath);
	hasValue |= m_ReplicateOffset.unmarshall(ctx, params, attachments, "ReplicateOffset", basepath);
	hasValue |= m_maxConnections.unmarshall(ctx, params, attachments, "maxConnections", basepath);
	hasValue |= m_throttle.unmarshall(ctx, params, attachments, "throttle", basepath);
	hasValue |= m_transferBufferSize.unmarshall(ctx, params, attachments, "transferBufferSize", basepath);
	hasValue |= m_prefix.unmarshall(ctx, params, attachments, "prefix", basepath);
	hasValue |= m_nosplit.unmarshall(ctx, params, attachments, "nosplit", basepath);
	hasValue |= m_norecover.unmarshall(ctx, params, attachments, "norecover", basepath);
	hasValue |= m_compress.unmarshall(ctx, params, attachments, "compress", basepath);
	hasValue |= m_push.unmarshall(ctx, params, attachments, "push", basepath);
	hasValue |= m_pull.unmarshall(ctx, params, attachments, "pull", basepath);
	hasValue |= m_encrypt.unmarshall(ctx, params, attachments, "encrypt", basepath);
	hasValue |= m_decrypt.unmarshall(ctx, params, attachments, "decrypt", basepath);
	hasValue |= m_failIfNoSourceFile.unmarshall(ctx, params, attachments, "failIfNoSourceFile", basepath);
	hasValue |= m_recordStructurePresent.unmarshall(ctx, params, attachments, "recordStructurePresent", basepath);
	hasValue |= m_quotedTerminator.unmarshall(ctx, params, attachments, "quotedTerminator", basepath);
	hasValue |= m_sourceRowPath.unmarshall(ctx, params, attachments, "sourceRowPath", basepath);
	hasValue |= m_isJSON.unmarshall(ctx, params, attachments, "isJSON", basepath);
	hasValue |= m_expireDays.unmarshall(ctx, params, attachments, "expireDays", basepath);
	hasValue |= m_DFUServerQueue.unmarshall(ctx, params, attachments, "DFUServerQueue", basepath);
	return hasValue;
}

const char * CSprayVariable::getSourceIP() { return m_sourceIP.query();}
const char * CSprayVariable::getSourcePath() { return m_sourcePath.query();}
const MemoryBuffer & CSprayVariable::getSrcxml() { return m_srcxml.getValue();}
bool CSprayVariable::getSourceMaxRecordSize_isNull(){return m_sourceMaxRecordSize.is_nil();}
int CSprayVariable::getSourceMaxRecordSize() { return m_sourceMaxRecordSize;}
bool CSprayVariable::getSourceFormat_isNull(){return m_sourceFormat.is_nil();}
int CSprayVariable::getSourceFormat() { return m_sourceFormat;}
bool CSprayVariable::getNoSourceCsvSeparator_isNull(){return m_NoSourceCsvSeparator.is_nil();}
bool CSprayVariable::getNoSourceCsvSeparator() { return m_NoSourceCsvSeparator;}
const char * CSprayVariable::getSourceCsvSeparate() { return m_sourceCsvSeparate.query();}
const char * CSprayVariable::getSourceCsvTerminate() { return m_sourceCsvTerminate.query();}
const char * CSprayVariable::getSourceCsvQuote() { return m_sourceCsvQuote.query();}
const char * CSprayVariable::getSourceCsvEscape() { return m_sourceCsvEscape.query();}
const char * CSprayVariable::getSourceRowTag() { return m_sourceRowTag.query();}
const char * CSprayVariable::getDestGroup() { return m_destGroup.query();}
const char * CSprayVariable::getDestLogicalName() { return m_destLogicalName.query();}
bool CSprayVariable::getOverwrite_isNull(){return m_overwrite.is_nil();}
bool CSprayVariable::getOverwrite() { return m_overwrite;}
bool CSprayVariable::getReplicate_isNull(){return m_replicate.is_nil();}
bool CSprayVariable::getReplicate() { return m_replicate;}
bool CSprayVariable::getReplicateOffset_isNull(){return m_ReplicateOffset.is_nil();}
int CSprayVariable::getReplicateOffset() { return m_ReplicateOffset;}
bool CSprayVariable::getMaxConnections_isNull(){return m_maxConnections.is_nil();}
int CSprayVariable::getMaxConnections() { return m_maxConnections;}
bool CSprayVariable::getThrottle_isNull(){return m_throttle.is_nil();}
int CSprayVariable::getThrottle() { return m_throttle;}
bool CSprayVariable::getTransferBufferSize_isNull(){return m_transferBufferSize.is_nil();}
int CSprayVariable::getTransferBufferSize() { return m_transferBufferSize;}
const char * CSprayVariable::getPrefix() { return m_prefix.query();}
bool CSprayVariable::getNosplit_isNull(){return m_nosplit.is_nil();}
bool CSprayVariable::getNosplit() { return m_nosplit;}
bool CSprayVariable::getNorecover_isNull(){return m_norecover.is_nil();}
bool CSprayVariable::getNorecover() { return m_norecover;}
bool CSprayVariable::getCompress_isNull(){return m_compress.is_nil();}
bool CSprayVariable::getCompress() { return m_compress;}
bool CSprayVariable::getPush_isNull(){return m_push.is_nil();}
bool CSprayVariable::getPush() { return m_push;}
bool CSprayVariable::getPull_isNull(){return m_pull.is_nil();}
bool CSprayVariable::getPull() { return m_pull;}
const char * CSprayVariable::getEncrypt() { return m_encrypt.query();}
const char * CSprayVariable::getDecrypt() { return m_decrypt.query();}
bool CSprayVariable::getFailIfNoSourceFile_isNull(){return m_failIfNoSourceFile.is_nil();}
bool CSprayVariable::getFailIfNoSourceFile() { return m_failIfNoSourceFile;}
bool CSprayVariable::getRecordStructurePresent_isNull(){return m_recordStructurePresent.is_nil();}
bool CSprayVariable::getRecordStructurePresent() { return m_recordStructurePresent;}
bool CSprayVariable::getQuotedTerminator_isNull(){return m_quotedTerminator.is_nil();}
bool CSprayVariable::getQuotedTerminator() { return m_quotedTerminator;}
const char * CSprayVariable::getSourceRowPath() { return m_sourceRowPath.query();}
bool CSprayVariable::getIsJSON_isNull(){return m_isJSON.is_nil();}
bool CSprayVariable::getIsJSON() { return m_isJSON;}
bool CSprayVariable::getExpireDays_isNull(){return m_expireDays.is_nil();}
int CSprayVariable::getExpireDays() { return m_expireDays;}
const char * CSprayVariable::getDFUServerQueue() { return m_DFUServerQueue.query();}
void CSprayVariable::setSourceIP(const char * val){ m_sourceIP.set(val); }
void CSprayVariable::setSourcePath(const char * val){ m_sourcePath.set(val); }
void CSprayVariable::setSrcxml(const MemoryBuffer & val){ m_srcxml->clear().append(val); }
void CSprayVariable::setSourceMaxRecordSize_null(){ m_sourceMaxRecordSize.Nil(); }void CSprayVariable::setSourceMaxRecordSize(int val){ m_sourceMaxRecordSize=val; }
void CSprayVariable::setSourceFormat_null(){ m_sourceFormat.Nil(); }void CSprayVariable::setSourceFormat(int val){ m_sourceFormat=val; }
void CSprayVariable::setNoSourceCsvSeparator_null(){ m_NoSourceCsvSeparator.Nil(); }void CSprayVariable::setNoSourceCsvSeparator(bool val){ m_NoSourceCsvSeparator=val; }
void CSprayVariable::setSourceCsvSeparate(const char * val){ m_sourceCsvSeparate.set(val); }
void CSprayVariable::setSourceCsvTerminate(const char * val){ m_sourceCsvTerminate.set(val); }
void CSprayVariable::setSourceCsvQuote(const char * val){ m_sourceCsvQuote.set(val); }
void CSprayVariable::setSourceCsvEscape(const char * val){ m_sourceCsvEscape.set(val); }
void CSprayVariable::setSourceRowTag(const char * val){ m_sourceRowTag.set(val); }
void CSprayVariable::setDestGroup(const char * val){ m_destGroup.set(val); }
void CSprayVariable::setDestLogicalName(const char * val){ m_destLogicalName.set(val); }
void CSprayVariable::setOverwrite_null(){ m_overwrite.Nil(); }void CSprayVariable::setOverwrite(bool val){ m_overwrite=val; }
void CSprayVariable::setReplicate_null(){ m_replicate.Nil(); }void CSprayVariable::setReplicate(bool val){ m_replicate=val; }
void CSprayVariable::setReplicateOffset_null(){ m_ReplicateOffset.Nil(); }void CSprayVariable::setReplicateOffset(int val){ m_ReplicateOffset=val; }
void CSprayVariable::setMaxConnections_null(){ m_maxConnections.Nil(); }void CSprayVariable::setMaxConnections(int val){ m_maxConnections=val; }
void CSprayVariable::setThrottle_null(){ m_throttle.Nil(); }void CSprayVariable::setThrottle(int val){ m_throttle=val; }
void CSprayVariable::setTransferBufferSize_null(){ m_transferBufferSize.Nil(); }void CSprayVariable::setTransferBufferSize(int val){ m_transferBufferSize=val; }
void CSprayVariable::setPrefix(const char * val){ m_prefix.set(val); }
void CSprayVariable::setNosplit_null(){ m_nosplit.Nil(); }void CSprayVariable::setNosplit(bool val){ m_nosplit=val; }
void CSprayVariable::setNorecover_null(){ m_norecover.Nil(); }void CSprayVariable::setNorecover(bool val){ m_norecover=val; }
void CSprayVariable::setCompress_null(){ m_compress.Nil(); }void CSprayVariable::setCompress(bool val){ m_compress=val; }
void CSprayVariable::setPush_null(){ m_push.Nil(); }void CSprayVariable::setPush(bool val){ m_push=val; }
void CSprayVariable::setPull_null(){ m_pull.Nil(); }void CSprayVariable::setPull(bool val){ m_pull=val; }
void CSprayVariable::setEncrypt(const char * val){ m_encrypt.set(val); }
void CSprayVariable::setDecrypt(const char * val){ m_decrypt.set(val); }
void CSprayVariable::setFailIfNoSourceFile_null(){ m_failIfNoSourceFile.Nil(); }void CSprayVariable::setFailIfNoSourceFile(bool val){ m_failIfNoSourceFile=val; }
void CSprayVariable::setRecordStructurePresent_null(){ m_recordStructurePresent.Nil(); }void CSprayVariable::setRecordStructurePresent(bool val){ m_recordStructurePresent=val; }
void CSprayVariable::setQuotedTerminator_null(){ m_quotedTerminator.Nil(); }void CSprayVariable::setQuotedTerminator(bool val){ m_quotedTerminator=val; }
void CSprayVariable::setSourceRowPath(const char * val){ m_sourceRowPath.set(val); }
void CSprayVariable::setIsJSON_null(){ m_isJSON.Nil(); }void CSprayVariable::setIsJSON(bool val){ m_isJSON=val; }
void CSprayVariable::setExpireDays_null(){ m_expireDays.Nil(); }void CSprayVariable::setExpireDays(int val){ m_expireDays=val; }
void CSprayVariable::setDFUServerQueue(const char * val){ m_DFUServerQueue.set(val); }
extern "C"  IEspSprayVariable *createSprayVariable(const char *serv){return ((IEspSprayVariable *)new CSprayVariable(serv));}
extern "C"  IClientSprayVariable *createClientSprayVariable(const char *serv){return ((IClientSprayVariable *)new CSprayVariable(serv));}

//=======================================================
// class CSprayResponse Implementation
//=======================================================

CSprayResponse::CSprayResponse(const char *serviceName, IRpcMessageBinding *init)
	: m_wuid(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("SprayResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CSprayResponse::CSprayResponse(const char *serviceName, const char *bc)
	: m_wuid(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("SprayResponse");
}

CSprayResponse::CSprayResponse(const char *serviceName, IRpcMessage* rpcmsg)
	: m_wuid(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("SprayResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CSprayResponse::CSprayResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_wuid(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("SprayResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CSprayResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		schema.append("<xsd:element name=\"Exceptions\" type=\"tns:ArrayOfEspException\" minOccurs=\"0\" maxOccurs=\"1\"/>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"wuid\" type=\"xsd:string\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CSprayResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CSprayResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CSprayResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("wuid");
	form.appendf("  <tr><td><b>wuid: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CSprayResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CSprayResponse::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
		m_wuid.marshall(rpc_resp, "wuid", "", "", "");
	}
}


void CSprayResponse::copy(CSprayResponse &from)
{
	m_wuid.copy(from.m_wuid);
}


void CSprayResponse::copy(IConstSprayResponse &ifrom)
{
	setWuid(ifrom.getWuid());
}


void CSprayResponse::getAttributes(IProperties &attributes)
{
}


void CSprayResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
		m_wuid.toStr(ctx, buffer, "wuid", "", true, "", "");
	}
}


void CSprayResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CSprayResponse::serializer(IEspContext* ctx, IConstSprayResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<SprayResponse>");
	// field wuid
	{
		const char* s = src.getWuid();
		if (s && *s)
		{
			buffer.append("<wuid>");
			encodeUtf8XML(s,buffer);
			buffer.append("</wuid>");
		}
	}
	if (keepRootTag)
		buffer.append("</SprayResponse>");
}

bool CSprayResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
		hasValue |= m_wuid.unmarshall(rpc_request, "wuid", basepath);
	}
	return hasValue;
}

bool CSprayResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_wuid.unmarshall(ctx, soapval, "wuid");
	return hasValue;
}

bool CSprayResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_wuid.unmarshall(ctx, params, attachments, "wuid", basepath);
	return hasValue;
}

const char * CSprayResponse::getWuid() { return m_wuid.query();}
void CSprayResponse::setWuid(const char * val){ m_wuid.set(val); }
extern "C"  IEspSprayResponse *createSprayResponse(const char *serv){return ((IEspSprayResponse *)new CSprayResponse(serv));}
extern "C"  IClientSprayResponse *createClientSprayResponse(const char *serv){return ((IClientSprayResponse *)new CSprayResponse(serv));}

//=======================================================
// class CReplicate Implementation
//=======================================================

CReplicate::CReplicate(const char *serviceName, IRpcMessageBinding *init)
	: m_sourceLogicalName(nilRemove),m_replicateOffset(1, nilRemove,false),m_cluster(nilRemove),m_repeatLast(0, nilRemove,false),m_onlyRepeated(0, nilRemove,false),m_DFUServerQueue(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("Replicate");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CReplicate::CReplicate(const char *serviceName, const char *bc)
	: m_sourceLogicalName(nilRemove),m_replicateOffset(1, nilRemove,false),m_cluster(nilRemove),m_repeatLast(0, nilRemove,false),m_onlyRepeated(0, nilRemove,false),m_DFUServerQueue(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("Replicate");
}

CReplicate::CReplicate(const char *serviceName, IRpcMessage* rpcmsg)
	: m_sourceLogicalName(nilRemove),m_replicateOffset(1, nilRemove,false),m_cluster(nilRemove),m_repeatLast(0, nilRemove,false),m_onlyRepeated(0, nilRemove,false),m_DFUServerQueue(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("Replicate");
	unserialize(*rpcmsg,NULL,NULL);
}

CReplicate::CReplicate(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_sourceLogicalName(nilRemove),m_replicateOffset(1, nilRemove,false),m_cluster(nilRemove),m_repeatLast(0, nilRemove,false),m_onlyRepeated(0, nilRemove,false),m_DFUServerQueue(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("Replicate");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CReplicate::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"sourceLogicalName\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" default=\"1\" name=\"replicateOffset\" type=\"xsd:int\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"cluster\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" default=\"false\" name=\"repeatLast\" type=\"xsd:boolean\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" default=\"false\" name=\"onlyRepeated\" type=\"xsd:boolean\"/>\n");
		if (!context.suppressed("Replicate","DFUServerQueue")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"DFUServerQueue\" type=\"xsd:string\"/>\n");
		}
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CReplicate::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CReplicate::getMapInfo(IMapInfo& info, BoolHash& added)
{
	info.addMinVersion("Replicate","DFUServerQueue",1.14);
}

StringBuffer &CReplicate::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("sourceLogicalName");
	form.appendf("  <tr><td><b>sourceLogicalName: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix) extfix.append(prefix).append(".");
		extfix.append("replicateOffset");
	form.appendf("  <tr><td><b>replicateOffset: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"	 value=\"1\"/>", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("cluster");
	form.appendf("  <tr><td><b>cluster: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("repeatLast");
	
	form.appendf("  <tr><td><b>repeatLast? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("onlyRepeated");
	
	form.appendf("  <tr><td><b>onlyRepeated? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	if (!context.suppressed("Replicate","DFUServerQueue")) {
		extfix.clear();
		if (prefix && *prefix)
			extfix.append(prefix).append(".");
		extfix.append("DFUServerQueue");
		form.appendf("  <tr><td><b>DFUServerQueue: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
		form.append("</td></tr>\n");
	}
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CReplicate::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CReplicate::serialize(IRpcMessage& rpc_resp)
{
	IEspContext* ctx = rpc_resp.queryContext();
	double clientVer= ctx ? ctx->getClientVersion() : -1; /* no context gets everything */
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_sourceLogicalName.marshall(rpc_resp, "sourceLogicalName", "", "", "");
	m_replicateOffset.marshall(rpc_resp, "replicateOffset", "", "", "");
	m_cluster.marshall(rpc_resp, "cluster", "", "", "");
	m_repeatLast.marshall(rpc_resp, "repeatLast", "", "", "");
	m_onlyRepeated.marshall(rpc_resp, "onlyRepeated", "", "", "");
	if ((clientVer==-1.0 || clientVer>=1.14))
		m_DFUServerQueue.marshall(rpc_resp, "DFUServerQueue", "", "", "");
}


void CReplicate::copy(CReplicate &from)
{
	m_sourceLogicalName.copy(from.m_sourceLogicalName);
	m_replicateOffset.copy(from.m_replicateOffset);
	m_cluster.copy(from.m_cluster);
	m_repeatLast.copy(from.m_repeatLast);
	m_onlyRepeated.copy(from.m_onlyRepeated);
	m_DFUServerQueue.copy(from.m_DFUServerQueue);
}


void CReplicate::copy(IConstReplicate &ifrom)
{
	setSourceLogicalName(ifrom.getSourceLogicalName());
	setReplicateOffset(ifrom.getReplicateOffset());
	setCluster(ifrom.getCluster());
	setRepeatLast(ifrom.getRepeatLast());
	setOnlyRepeated(ifrom.getOnlyRepeated());
	setDFUServerQueue(ifrom.getDFUServerQueue());
}


void CReplicate::getAttributes(IProperties &attributes)
{
}


void CReplicate::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	double clientVer = ctx ? ctx->getClientVersion() : -1;
	m_sourceLogicalName.toStr(ctx, buffer, "sourceLogicalName", "", true, "", "");
	m_replicateOffset.toStr(ctx, buffer, "replicateOffset", "", true, "", "");
	m_cluster.toStr(ctx, buffer, "cluster", "", true, "", "");
	m_repeatLast.toStr(ctx, buffer, "repeatLast", "", true, "", "");
	m_onlyRepeated.toStr(ctx, buffer, "onlyRepeated", "", true, "", "");
	if ((clientVer==-1.0 || clientVer>=1.14))
		m_DFUServerQueue.toStr(ctx, buffer, "DFUServerQueue", "", true, "", "");
}


void CReplicate::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CReplicate::serializer(IEspContext* ctx, IConstReplicate &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<Replicate>");
	double clientVer = ctx ? ctx->getClientVersion() : -1;
	// field sourceLogicalName
	{
		const char* s = src.getSourceLogicalName();
		if (s && *s)
		{
			buffer.append("<sourceLogicalName>");
			encodeUtf8XML(s,buffer);
			buffer.append("</sourceLogicalName>");
		}
	}
	// field replicateOffset
	{
		int n = src.getReplicateOffset();
		if (n)
			buffer.appendf("<replicateOffset>%d</replicateOffset>", n);
	}
	// field cluster
	{
		const char* s = src.getCluster();
		if (s && *s)
		{
			buffer.append("<cluster>");
			encodeUtf8XML(s,buffer);
			buffer.append("</cluster>");
		}
	}
	// field repeatLast
	{
		bool b = src.getRepeatLast();
		if (b)
			buffer.appendf("<repeatLast>1</repeatLast>");
	}
	// field onlyRepeated
	{
		bool b = src.getOnlyRepeated();
		if (b)
			buffer.appendf("<onlyRepeated>1</onlyRepeated>");
	}
	// field DFUServerQueue
	if ((clientVer==-1.0 || clientVer>=1.14))
	{
		const char* s = src.getDFUServerQueue();
		if (s && *s)
		{
			buffer.append("<DFUServerQueue>");
			encodeUtf8XML(s,buffer);
			buffer.append("</DFUServerQueue>");
		}
	}
	if (keepRootTag)
		buffer.append("</Replicate>");
}

bool CReplicate::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_sourceLogicalName.unmarshall(rpc_request, "sourceLogicalName", basepath);
	hasValue |= m_replicateOffset.unmarshall(rpc_request, "replicateOffset", basepath);
	hasValue |= m_cluster.unmarshall(rpc_request, "cluster", basepath);
	hasValue |= m_repeatLast.unmarshall(rpc_request, "repeatLast", basepath);
	hasValue |= m_onlyRepeated.unmarshall(rpc_request, "onlyRepeated", basepath);
	hasValue |= m_DFUServerQueue.unmarshall(rpc_request, "DFUServerQueue", basepath);
	return hasValue;
}

bool CReplicate::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_sourceLogicalName.unmarshall(ctx, soapval, "sourceLogicalName");
	hasValue |= m_replicateOffset.unmarshall(ctx, soapval, "replicateOffset");
	hasValue |= m_cluster.unmarshall(ctx, soapval, "cluster");
	hasValue |= m_repeatLast.unmarshall(ctx, soapval, "repeatLast");
	hasValue |= m_onlyRepeated.unmarshall(ctx, soapval, "onlyRepeated");
	hasValue |= m_DFUServerQueue.unmarshall(ctx, soapval, "DFUServerQueue");
	return hasValue;
}

bool CReplicate::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_sourceLogicalName.unmarshall(ctx, params, attachments, "sourceLogicalName", basepath);
	hasValue |= m_replicateOffset.unmarshall(ctx, params, attachments, "replicateOffset", basepath);
	hasValue |= m_cluster.unmarshall(ctx, params, attachments, "cluster", basepath);
	hasValue |= m_repeatLast.unmarshall(ctx, params, attachments, "repeatLast", basepath);
	hasValue |= m_onlyRepeated.unmarshall(ctx, params, attachments, "onlyRepeated", basepath);
	hasValue |= m_DFUServerQueue.unmarshall(ctx, params, attachments, "DFUServerQueue", basepath);
	return hasValue;
}

const char * CReplicate::getSourceLogicalName() { return m_sourceLogicalName.query();}
bool CReplicate::getReplicateOffset_isNull(){return m_replicateOffset.is_nil();}
int CReplicate::getReplicateOffset() { return m_replicateOffset;}
const char * CReplicate::getCluster() { return m_cluster.query();}
bool CReplicate::getRepeatLast_isNull(){return m_repeatLast.is_nil();}
bool CReplicate::getRepeatLast() { return m_repeatLast;}
bool CReplicate::getOnlyRepeated_isNull(){return m_onlyRepeated.is_nil();}
bool CReplicate::getOnlyRepeated() { return m_onlyRepeated;}
const char * CReplicate::getDFUServerQueue() { return m_DFUServerQueue.query();}
void CReplicate::setSourceLogicalName(const char * val){ m_sourceLogicalName.set(val); }
void CReplicate::setReplicateOffset_null(){ m_replicateOffset.Nil(); }void CReplicate::setReplicateOffset(int val){ m_replicateOffset=val; }
void CReplicate::setCluster(const char * val){ m_cluster.set(val); }
void CReplicate::setRepeatLast_null(){ m_repeatLast.Nil(); }void CReplicate::setRepeatLast(bool val){ m_repeatLast=val; }
void CReplicate::setOnlyRepeated_null(){ m_onlyRepeated.Nil(); }void CReplicate::setOnlyRepeated(bool val){ m_onlyRepeated=val; }
void CReplicate::setDFUServerQueue(const char * val){ m_DFUServerQueue.set(val); }
extern "C"  IEspReplicate *createReplicate(const char *serv){return ((IEspReplicate *)new CReplicate(serv));}
extern "C"  IClientReplicate *createClientReplicate(const char *serv){return ((IClientReplicate *)new CReplicate(serv));}

//=======================================================
// class CReplicateResponse Implementation
//=======================================================

CReplicateResponse::CReplicateResponse(const char *serviceName, IRpcMessageBinding *init)
	: m_wuid(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ReplicateResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CReplicateResponse::CReplicateResponse(const char *serviceName, const char *bc)
	: m_wuid(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ReplicateResponse");
}

CReplicateResponse::CReplicateResponse(const char *serviceName, IRpcMessage* rpcmsg)
	: m_wuid(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ReplicateResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CReplicateResponse::CReplicateResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_wuid(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ReplicateResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CReplicateResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		schema.append("<xsd:element name=\"Exceptions\" type=\"tns:ArrayOfEspException\" minOccurs=\"0\" maxOccurs=\"1\"/>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"wuid\" type=\"xsd:string\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CReplicateResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CReplicateResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CReplicateResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("wuid");
	form.appendf("  <tr><td><b>wuid: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CReplicateResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CReplicateResponse::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
		m_wuid.marshall(rpc_resp, "wuid", "", "", "");
	}
}


void CReplicateResponse::copy(CReplicateResponse &from)
{
	m_wuid.copy(from.m_wuid);
}


void CReplicateResponse::copy(IConstReplicateResponse &ifrom)
{
	setWuid(ifrom.getWuid());
}


void CReplicateResponse::getAttributes(IProperties &attributes)
{
}


void CReplicateResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
		m_wuid.toStr(ctx, buffer, "wuid", "", true, "", "");
	}
}


void CReplicateResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CReplicateResponse::serializer(IEspContext* ctx, IConstReplicateResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<ReplicateResponse>");
	// field wuid
	{
		const char* s = src.getWuid();
		if (s && *s)
		{
			buffer.append("<wuid>");
			encodeUtf8XML(s,buffer);
			buffer.append("</wuid>");
		}
	}
	if (keepRootTag)
		buffer.append("</ReplicateResponse>");
}

bool CReplicateResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
		hasValue |= m_wuid.unmarshall(rpc_request, "wuid", basepath);
	}
	return hasValue;
}

bool CReplicateResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_wuid.unmarshall(ctx, soapval, "wuid");
	return hasValue;
}

bool CReplicateResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_wuid.unmarshall(ctx, params, attachments, "wuid", basepath);
	return hasValue;
}

const char * CReplicateResponse::getWuid() { return m_wuid.query();}
void CReplicateResponse::setWuid(const char * val){ m_wuid.set(val); }
extern "C"  IEspReplicateResponse *createReplicateResponse(const char *serv){return ((IEspReplicateResponse *)new CReplicateResponse(serv));}
extern "C"  IClientReplicateResponse *createClientReplicateResponse(const char *serv){return ((IClientReplicateResponse *)new CReplicateResponse(serv));}

//=======================================================
// class CDespray Implementation
//=======================================================

CDespray::CDespray(const char *serviceName, IRpcMessageBinding *init)
	: m_sourceLogicalName(nilIgnore),m_destIP(nilIgnore),m_destPath(nilIgnore),m_dstxml(nilIgnore),m_overwrite(nilIgnore),m_maxConnections(nilIgnore),m_throttle(nilIgnore),m_transferBufferSize(nilIgnore),m_splitprefix(nilIgnore),m_norecover(0, nilIgnore,false),m_wrap(0, nilIgnore,false),m_multiCopy(0, nilIgnore,false),m_SingleConnection(nilIgnore),m_DFUServerQueue(nilIgnore),m_compress(0, nilIgnore,false),m_encrypt(nilIgnore),m_decrypt(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("Despray");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CDespray::CDespray(const char *serviceName, const char *bc)
	: m_sourceLogicalName(nilIgnore),m_destIP(nilIgnore),m_destPath(nilIgnore),m_dstxml(nilIgnore),m_overwrite(nilIgnore),m_maxConnections(nilIgnore),m_throttle(nilIgnore),m_transferBufferSize(nilIgnore),m_splitprefix(nilIgnore),m_norecover(0, nilIgnore,false),m_wrap(0, nilIgnore,false),m_multiCopy(0, nilIgnore,false),m_SingleConnection(nilIgnore),m_DFUServerQueue(nilIgnore),m_compress(0, nilIgnore,false),m_encrypt(nilIgnore),m_decrypt(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("Despray");
}

CDespray::CDespray(const char *serviceName, IRpcMessage* rpcmsg)
	: m_sourceLogicalName(nilIgnore),m_destIP(nilIgnore),m_destPath(nilIgnore),m_dstxml(nilIgnore),m_overwrite(nilIgnore),m_maxConnections(nilIgnore),m_throttle(nilIgnore),m_transferBufferSize(nilIgnore),m_splitprefix(nilIgnore),m_norecover(0, nilIgnore,false),m_wrap(0, nilIgnore,false),m_multiCopy(0, nilIgnore,false),m_SingleConnection(nilIgnore),m_DFUServerQueue(nilIgnore),m_compress(0, nilIgnore,false),m_encrypt(nilIgnore),m_decrypt(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("Despray");
	unserialize(*rpcmsg,NULL,NULL);
}

CDespray::CDespray(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_sourceLogicalName(nilIgnore),m_destIP(nilIgnore),m_destPath(nilIgnore),m_dstxml(nilIgnore),m_overwrite(nilIgnore),m_maxConnections(nilIgnore),m_throttle(nilIgnore),m_transferBufferSize(nilIgnore),m_splitprefix(nilIgnore),m_norecover(0, nilIgnore,false),m_wrap(0, nilIgnore,false),m_multiCopy(0, nilIgnore,false),m_SingleConnection(nilIgnore),m_DFUServerQueue(nilIgnore),m_compress(0, nilIgnore,false),m_encrypt(nilIgnore),m_decrypt(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("Despray");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CDespray::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"sourceLogicalName\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"destIP\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"destPath\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"dstxml\" type=\"xsd:base64Binary\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"overwrite\" type=\"xsd:boolean\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"maxConnections\" type=\"xsd:int\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"throttle\" type=\"xsd:int\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"transferBufferSize\" type=\"xsd:int\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"splitprefix\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" default=\"false\" name=\"norecover\" type=\"xsd:boolean\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" default=\"false\" name=\"wrap\" type=\"xsd:boolean\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" default=\"false\" name=\"multiCopy\" type=\"xsd:boolean\"/>\n");
		if (!context.suppressed("Despray","SingleConnection")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"SingleConnection\" type=\"xsd:boolean\"/>\n");
		}
		if (!context.suppressed("Despray","DFUServerQueue")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"DFUServerQueue\" type=\"xsd:string\"/>\n");
		}
		schema.append("<xsd:element minOccurs=\"0\" default=\"false\" name=\"compress\" type=\"xsd:boolean\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"encrypt\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"decrypt\" type=\"xsd:string\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CDespray::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CDespray::getMapInfo(IMapInfo& info, BoolHash& added)
{
	info.addMinVersion("Despray","SingleConnection",1.02);
	info.addMinVersion("Despray","DFUServerQueue",1.14);
}

StringBuffer &CDespray::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("sourceLogicalName");
	form.appendf("  <tr><td><b>sourceLogicalName: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("destIP");
	form.appendf("  <tr><td><b>destIP: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("destPath");
	form.appendf("  <tr><td><b>destPath: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("dstxml");
	form.appendf("  <tr><td><b>dstxml: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("overwrite");
	
	form.appendf("  <tr><td><b>overwrite? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	extfix.clear();
	if (prefix && *prefix) extfix.append(prefix).append(".");
		extfix.append("maxConnections");
	form.appendf("  <tr><td><b>maxConnections: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix) extfix.append(prefix).append(".");
		extfix.append("throttle");
	form.appendf("  <tr><td><b>throttle: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix) extfix.append(prefix).append(".");
		extfix.append("transferBufferSize");
	form.appendf("  <tr><td><b>transferBufferSize: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("splitprefix");
	form.appendf("  <tr><td><b>splitprefix: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("norecover");
	
	form.appendf("  <tr><td><b>norecover? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("wrap");
	
	form.appendf("  <tr><td><b>wrap? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("multiCopy");
	
	form.appendf("  <tr><td><b>multiCopy? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	if (!context.suppressed("Despray","SingleConnection")) {
		extfix.clear();
		if (prefix && *prefix)
			extfix.append(prefix).append(".");
		extfix.append("SingleConnection");
		
	form.appendf("  <tr><td><b>SingleConnection? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	}
	if (!context.suppressed("Despray","DFUServerQueue")) {
		extfix.clear();
		if (prefix && *prefix)
			extfix.append(prefix).append(".");
		extfix.append("DFUServerQueue");
		form.appendf("  <tr><td><b>DFUServerQueue: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
		form.append("</td></tr>\n");
	}
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("compress");
	
	form.appendf("  <tr><td><b>compress? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("encrypt");
	form.appendf("  <tr><td><b>encrypt: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("decrypt");
	form.appendf("  <tr><td><b>decrypt: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CDespray::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CDespray::serialize(IRpcMessage& rpc_resp)
{
	IEspContext* ctx = rpc_resp.queryContext();
	double clientVer= ctx ? ctx->getClientVersion() : -1; /* no context gets everything */
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_sourceLogicalName.marshall(rpc_resp, "sourceLogicalName", "", "", "");
	m_destIP.marshall(rpc_resp, "destIP", "", "", "");
	m_destPath.marshall(rpc_resp, "destPath", "", "", "");
	m_dstxml.marshall(rpc_resp, "dstxml", "", "", "");
	m_overwrite.marshall(rpc_resp, "overwrite", "", "", "");
	m_maxConnections.marshall(rpc_resp, "maxConnections", "", "", "");
	m_throttle.marshall(rpc_resp, "throttle", "", "", "");
	m_transferBufferSize.marshall(rpc_resp, "transferBufferSize", "", "", "");
	m_splitprefix.marshall(rpc_resp, "splitprefix", "", "", "");
	m_norecover.marshall(rpc_resp, "norecover", "", "", "");
	m_wrap.marshall(rpc_resp, "wrap", "", "", "");
	m_multiCopy.marshall(rpc_resp, "multiCopy", "", "", "");
	if ((clientVer==-1.0 || clientVer>=1.02))
		m_SingleConnection.marshall(rpc_resp, "SingleConnection", "", "", "");
	if ((clientVer==-1.0 || clientVer>=1.14))
		m_DFUServerQueue.marshall(rpc_resp, "DFUServerQueue", "", "", "");
	m_compress.marshall(rpc_resp, "compress", "", "", "");
	m_encrypt.marshall(rpc_resp, "encrypt", "", "", "");
	m_decrypt.marshall(rpc_resp, "decrypt", "", "", "");
}


void CDespray::copy(CDespray &from)
{
	m_sourceLogicalName.copy(from.m_sourceLogicalName);
	m_destIP.copy(from.m_destIP);
	m_destPath.copy(from.m_destPath);
	m_dstxml.copy(from.m_dstxml);
	m_overwrite.copy(from.m_overwrite);
	m_maxConnections.copy(from.m_maxConnections);
	m_throttle.copy(from.m_throttle);
	m_transferBufferSize.copy(from.m_transferBufferSize);
	m_splitprefix.copy(from.m_splitprefix);
	m_norecover.copy(from.m_norecover);
	m_wrap.copy(from.m_wrap);
	m_multiCopy.copy(from.m_multiCopy);
	m_SingleConnection.copy(from.m_SingleConnection);
	m_DFUServerQueue.copy(from.m_DFUServerQueue);
	m_compress.copy(from.m_compress);
	m_encrypt.copy(from.m_encrypt);
	m_decrypt.copy(from.m_decrypt);
}


void CDespray::copy(IConstDespray &ifrom)
{
	setSourceLogicalName(ifrom.getSourceLogicalName());
	setDestIP(ifrom.getDestIP());
	setDestPath(ifrom.getDestPath());
	setDstxml(ifrom.getDstxml());
	setOverwrite(ifrom.getOverwrite());
	setMaxConnections(ifrom.getMaxConnections());
	setThrottle(ifrom.getThrottle());
	setTransferBufferSize(ifrom.getTransferBufferSize());
	setSplitprefix(ifrom.getSplitprefix());
	setNorecover(ifrom.getNorecover());
	setWrap(ifrom.getWrap());
	setMultiCopy(ifrom.getMultiCopy());
	setSingleConnection(ifrom.getSingleConnection());
	setDFUServerQueue(ifrom.getDFUServerQueue());
	setCompress(ifrom.getCompress());
	setEncrypt(ifrom.getEncrypt());
	setDecrypt(ifrom.getDecrypt());
}


void CDespray::getAttributes(IProperties &attributes)
{
}


void CDespray::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	double clientVer = ctx ? ctx->getClientVersion() : -1;
	m_sourceLogicalName.toStr(ctx, buffer, "sourceLogicalName", "", true, "", "");
	m_destIP.toStr(ctx, buffer, "destIP", "", true, "", "");
	m_destPath.toStr(ctx, buffer, "destPath", "", true, "", "");
	m_dstxml.toStr(ctx, buffer, "dstxml", "", true, "", "");
	m_overwrite.toStr(ctx, buffer, "overwrite", "", true, "", "");
	m_maxConnections.toStr(ctx, buffer, "maxConnections", "", true, "", "");
	m_throttle.toStr(ctx, buffer, "throttle", "", true, "", "");
	m_transferBufferSize.toStr(ctx, buffer, "transferBufferSize", "", true, "", "");
	m_splitprefix.toStr(ctx, buffer, "splitprefix", "", true, "", "");
	m_norecover.toStr(ctx, buffer, "norecover", "", true, "", "");
	m_wrap.toStr(ctx, buffer, "wrap", "", true, "", "");
	m_multiCopy.toStr(ctx, buffer, "multiCopy", "", true, "", "");
	if ((clientVer==-1.0 || clientVer>=1.02))
		m_SingleConnection.toStr(ctx, buffer, "SingleConnection", "", true, "", "");
	if ((clientVer==-1.0 || clientVer>=1.14))
		m_DFUServerQueue.toStr(ctx, buffer, "DFUServerQueue", "", true, "", "");
	m_compress.toStr(ctx, buffer, "compress", "", true, "", "");
	m_encrypt.toStr(ctx, buffer, "encrypt", "", true, "", "");
	m_decrypt.toStr(ctx, buffer, "decrypt", "", true, "", "");
}


void CDespray::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CDespray::serializer(IEspContext* ctx, IConstDespray &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<Despray>");
	double clientVer = ctx ? ctx->getClientVersion() : -1;
	// field sourceLogicalName
	{
		const char* s = src.getSourceLogicalName();
		if (s && *s)
		{
			buffer.append("<sourceLogicalName>");
			encodeUtf8XML(s,buffer);
			buffer.append("</sourceLogicalName>");
		}
	}
	// field destIP
	{
		const char* s = src.getDestIP();
		if (s && *s)
		{
			buffer.append("<destIP>");
			encodeUtf8XML(s,buffer);
			buffer.append("</destIP>");
		}
	}
	// field destPath
	{
		const char* s = src.getDestPath();
		if (s && *s)
		{
			buffer.append("<destPath>");
			encodeUtf8XML(s,buffer);
			buffer.append("</destPath>");
		}
	}
	// field dstxml
	{
		StringBuffer tmp;
		JBASE64_Encode(src.getDstxml().toByteArray(), src.getDstxml().length(), tmp);
		if (tmp.length()>0)
			buffer.appendf("<dstxml>%s</dstxml>",tmp.str());
	}
	// field overwrite
	{
		bool b = src.getOverwrite();
		if (b)
			buffer.appendf("<overwrite>1</overwrite>");
	}
	// field maxConnections
	{
		int n = src.getMaxConnections();
		if (n)
			buffer.appendf("<maxConnections>%d</maxConnections>", n);
	}
	// field throttle
	{
		int n = src.getThrottle();
		if (n)
			buffer.appendf("<throttle>%d</throttle>", n);
	}
	// field transferBufferSize
	{
		int n = src.getTransferBufferSize();
		if (n)
			buffer.appendf("<transferBufferSize>%d</transferBufferSize>", n);
	}
	// field splitprefix
	{
		const char* s = src.getSplitprefix();
		if (s && *s)
		{
			buffer.append("<splitprefix>");
			encodeUtf8XML(s,buffer);
			buffer.append("</splitprefix>");
		}
	}
	// field norecover
	{
		bool b = src.getNorecover();
		if (b)
			buffer.appendf("<norecover>1</norecover>");
	}
	// field wrap
	{
		bool b = src.getWrap();
		if (b)
			buffer.appendf("<wrap>1</wrap>");
	}
	// field multiCopy
	{
		bool b = src.getMultiCopy();
		if (b)
			buffer.appendf("<multiCopy>1</multiCopy>");
	}
	// field SingleConnection
	if ((clientVer==-1.0 || clientVer>=1.02))
	{
		bool b = src.getSingleConnection();
		if (b)
			buffer.appendf("<SingleConnection>1</SingleConnection>");
	}
	// field DFUServerQueue
	if ((clientVer==-1.0 || clientVer>=1.14))
	{
		const char* s = src.getDFUServerQueue();
		if (s && *s)
		{
			buffer.append("<DFUServerQueue>");
			encodeUtf8XML(s,buffer);
			buffer.append("</DFUServerQueue>");
		}
	}
	// field compress
	{
		bool b = src.getCompress();
		if (b)
			buffer.appendf("<compress>1</compress>");
	}
	// field encrypt
	{
		const char* s = src.getEncrypt();
		if (s && *s)
		{
			buffer.append("<encrypt>");
			encodeUtf8XML(s,buffer);
			buffer.append("</encrypt>");
		}
	}
	// field decrypt
	{
		const char* s = src.getDecrypt();
		if (s && *s)
		{
			buffer.append("<decrypt>");
			encodeUtf8XML(s,buffer);
			buffer.append("</decrypt>");
		}
	}
	if (keepRootTag)
		buffer.append("</Despray>");
}

bool CDespray::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_sourceLogicalName.unmarshall(rpc_request, "sourceLogicalName", basepath);
	hasValue |= m_destIP.unmarshall(rpc_request, "destIP", basepath);
	hasValue |= m_destPath.unmarshall(rpc_request, "destPath", basepath);
	hasValue |= m_dstxml.unmarshall(rpc_request, "dstxml", basepath);
	hasValue |= m_overwrite.unmarshall(rpc_request, "overwrite", basepath);
	hasValue |= m_maxConnections.unmarshall(rpc_request, "maxConnections", basepath);
	hasValue |= m_throttle.unmarshall(rpc_request, "throttle", basepath);
	hasValue |= m_transferBufferSize.unmarshall(rpc_request, "transferBufferSize", basepath);
	hasValue |= m_splitprefix.unmarshall(rpc_request, "splitprefix", basepath);
	hasValue |= m_norecover.unmarshall(rpc_request, "norecover", basepath);
	hasValue |= m_wrap.unmarshall(rpc_request, "wrap", basepath);
	hasValue |= m_multiCopy.unmarshall(rpc_request, "multiCopy", basepath);
	hasValue |= m_SingleConnection.unmarshall(rpc_request, "SingleConnection", basepath);
	hasValue |= m_DFUServerQueue.unmarshall(rpc_request, "DFUServerQueue", basepath);
	hasValue |= m_compress.unmarshall(rpc_request, "compress", basepath);
	hasValue |= m_encrypt.unmarshall(rpc_request, "encrypt", basepath);
	hasValue |= m_decrypt.unmarshall(rpc_request, "decrypt", basepath);
	return hasValue;
}

bool CDespray::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_sourceLogicalName.unmarshall(ctx, soapval, "sourceLogicalName");
	hasValue |= m_destIP.unmarshall(ctx, soapval, "destIP");
	hasValue |= m_destPath.unmarshall(ctx, soapval, "destPath");
	hasValue |= m_dstxml.unmarshall(ctx, soapval, "dstxml");
	hasValue |= m_overwrite.unmarshall(ctx, soapval, "overwrite");
	hasValue |= m_maxConnections.unmarshall(ctx, soapval, "maxConnections");
	hasValue |= m_throttle.unmarshall(ctx, soapval, "throttle");
	hasValue |= m_transferBufferSize.unmarshall(ctx, soapval, "transferBufferSize");
	hasValue |= m_splitprefix.unmarshall(ctx, soapval, "splitprefix");
	hasValue |= m_norecover.unmarshall(ctx, soapval, "norecover");
	hasValue |= m_wrap.unmarshall(ctx, soapval, "wrap");
	hasValue |= m_multiCopy.unmarshall(ctx, soapval, "multiCopy");
	hasValue |= m_SingleConnection.unmarshall(ctx, soapval, "SingleConnection");
	hasValue |= m_DFUServerQueue.unmarshall(ctx, soapval, "DFUServerQueue");
	hasValue |= m_compress.unmarshall(ctx, soapval, "compress");
	hasValue |= m_encrypt.unmarshall(ctx, soapval, "encrypt");
	hasValue |= m_decrypt.unmarshall(ctx, soapval, "decrypt");
	return hasValue;
}

bool CDespray::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_sourceLogicalName.unmarshall(ctx, params, attachments, "sourceLogicalName", basepath);
	hasValue |= m_destIP.unmarshall(ctx, params, attachments, "destIP", basepath);
	hasValue |= m_destPath.unmarshall(ctx, params, attachments, "destPath", basepath);
	hasValue |= m_dstxml.unmarshall(ctx, params, attachments, "dstxml", basepath);
	hasValue |= m_overwrite.unmarshall(ctx, params, attachments, "overwrite", basepath);
	hasValue |= m_maxConnections.unmarshall(ctx, params, attachments, "maxConnections", basepath);
	hasValue |= m_throttle.unmarshall(ctx, params, attachments, "throttle", basepath);
	hasValue |= m_transferBufferSize.unmarshall(ctx, params, attachments, "transferBufferSize", basepath);
	hasValue |= m_splitprefix.unmarshall(ctx, params, attachments, "splitprefix", basepath);
	hasValue |= m_norecover.unmarshall(ctx, params, attachments, "norecover", basepath);
	hasValue |= m_wrap.unmarshall(ctx, params, attachments, "wrap", basepath);
	hasValue |= m_multiCopy.unmarshall(ctx, params, attachments, "multiCopy", basepath);
	hasValue |= m_SingleConnection.unmarshall(ctx, params, attachments, "SingleConnection", basepath);
	hasValue |= m_DFUServerQueue.unmarshall(ctx, params, attachments, "DFUServerQueue", basepath);
	hasValue |= m_compress.unmarshall(ctx, params, attachments, "compress", basepath);
	hasValue |= m_encrypt.unmarshall(ctx, params, attachments, "encrypt", basepath);
	hasValue |= m_decrypt.unmarshall(ctx, params, attachments, "decrypt", basepath);
	return hasValue;
}

const char * CDespray::getSourceLogicalName() { return m_sourceLogicalName.query();}
const char * CDespray::getDestIP() { return m_destIP.query();}
const char * CDespray::getDestPath() { return m_destPath.query();}
const MemoryBuffer & CDespray::getDstxml() { return m_dstxml.getValue();}
bool CDespray::getOverwrite() { return m_overwrite;}
int CDespray::getMaxConnections() { return m_maxConnections;}
int CDespray::getThrottle() { return m_throttle;}
int CDespray::getTransferBufferSize() { return m_transferBufferSize;}
const char * CDespray::getSplitprefix() { return m_splitprefix.query();}
bool CDespray::getNorecover() { return m_norecover;}
bool CDespray::getWrap() { return m_wrap;}
bool CDespray::getMultiCopy() { return m_multiCopy;}
bool CDespray::getSingleConnection() { return m_SingleConnection;}
const char * CDespray::getDFUServerQueue() { return m_DFUServerQueue.query();}
bool CDespray::getCompress() { return m_compress;}
const char * CDespray::getEncrypt() { return m_encrypt.query();}
const char * CDespray::getDecrypt() { return m_decrypt.query();}
void CDespray::setSourceLogicalName(const char * val){ m_sourceLogicalName.set(val); }
void CDespray::setDestIP(const char * val){ m_destIP.set(val); }
void CDespray::setDestPath(const char * val){ m_destPath.set(val); }
void CDespray::setDstxml(const MemoryBuffer & val){ m_dstxml->clear().append(val); }
void CDespray::setOverwrite(bool val){ m_overwrite=val; }
void CDespray::setMaxConnections(int val){ m_maxConnections=val; }
void CDespray::setThrottle(int val){ m_throttle=val; }
void CDespray::setTransferBufferSize(int val){ m_transferBufferSize=val; }
void CDespray::setSplitprefix(const char * val){ m_splitprefix.set(val); }
void CDespray::setNorecover(bool val){ m_norecover=val; }
void CDespray::setWrap(bool val){ m_wrap=val; }
void CDespray::setMultiCopy(bool val){ m_multiCopy=val; }
void CDespray::setSingleConnection(bool val){ m_SingleConnection=val; }
void CDespray::setDFUServerQueue(const char * val){ m_DFUServerQueue.set(val); }
void CDespray::setCompress(bool val){ m_compress=val; }
void CDespray::setEncrypt(const char * val){ m_encrypt.set(val); }
void CDespray::setDecrypt(const char * val){ m_decrypt.set(val); }
extern "C"  IEspDespray *createDespray(const char *serv){return ((IEspDespray *)new CDespray(serv));}
extern "C"  IClientDespray *createClientDespray(const char *serv){return ((IClientDespray *)new CDespray(serv));}

//=======================================================
// class CDesprayResponse Implementation
//=======================================================

CDesprayResponse::CDesprayResponse(const char *serviceName, IRpcMessageBinding *init)
	: m_wuid(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("DesprayResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CDesprayResponse::CDesprayResponse(const char *serviceName, const char *bc)
	: m_wuid(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("DesprayResponse");
}

CDesprayResponse::CDesprayResponse(const char *serviceName, IRpcMessage* rpcmsg)
	: m_wuid(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("DesprayResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CDesprayResponse::CDesprayResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_wuid(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("DesprayResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CDesprayResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		schema.append("<xsd:element name=\"Exceptions\" type=\"tns:ArrayOfEspException\" minOccurs=\"0\" maxOccurs=\"1\"/>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"wuid\" type=\"xsd:string\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CDesprayResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CDesprayResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CDesprayResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("wuid");
	form.appendf("  <tr><td><b>wuid: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CDesprayResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CDesprayResponse::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
		m_wuid.marshall(rpc_resp, "wuid", "", "", "");
	}
}


void CDesprayResponse::copy(CDesprayResponse &from)
{
	m_wuid.copy(from.m_wuid);
}


void CDesprayResponse::copy(IConstDesprayResponse &ifrom)
{
	setWuid(ifrom.getWuid());
}


void CDesprayResponse::getAttributes(IProperties &attributes)
{
}


void CDesprayResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
		m_wuid.toStr(ctx, buffer, "wuid", "", true, "", "");
	}
}


void CDesprayResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CDesprayResponse::serializer(IEspContext* ctx, IConstDesprayResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<DesprayResponse>");
	// field wuid
	{
		const char* s = src.getWuid();
		if (s && *s)
		{
			buffer.append("<wuid>");
			encodeUtf8XML(s,buffer);
			buffer.append("</wuid>");
		}
	}
	if (keepRootTag)
		buffer.append("</DesprayResponse>");
}

bool CDesprayResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
		hasValue |= m_wuid.unmarshall(rpc_request, "wuid", basepath);
	}
	return hasValue;
}

bool CDesprayResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_wuid.unmarshall(ctx, soapval, "wuid");
	return hasValue;
}

bool CDesprayResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_wuid.unmarshall(ctx, params, attachments, "wuid", basepath);
	return hasValue;
}

const char * CDesprayResponse::getWuid() { return m_wuid.query();}
void CDesprayResponse::setWuid(const char * val){ m_wuid.set(val); }
extern "C"  IEspDesprayResponse *createDesprayResponse(const char *serv){return ((IEspDesprayResponse *)new CDesprayResponse(serv));}
extern "C"  IClientDesprayResponse *createClientDesprayResponse(const char *serv){return ((IClientDesprayResponse *)new CDesprayResponse(serv));}

//=======================================================
// class CCopy Implementation
//=======================================================

CCopy::CCopy(const char *serviceName, IRpcMessageBinding *init)
	: m_sourceLogicalName(nilRemove),m_destGroup(nilRemove),m_destGroupRoxie(nilRemove),m_destLogicalName(nilRemove),m_sourceDali(nilRemove),m_srcusername(nilRemove),m_srcpassword(nilRemove),m_overwrite(nilRemove),m_replicate(nilRemove),m_ReplicateOffset(1, nilRemove,false),m_maxConnections(nilRemove),m_throttle(nilRemove),m_transferBufferSize(nilRemove),m_nosplit(nilRemove),m_norecover(0, nilRemove,false),m_compress(0, nilRemove,false),m_Wrap(0, nilRemove,false),m_Multicopy(0, nilRemove,false),m_SourceDiffKeyName(nilRemove),m_DestDiffKeyName(nilRemove),m_superCopy(0, nilRemove,false),m_push(0, nilRemove,false),m_pull(0, nilRemove,false),m_ifnewer(0, nilRemove,false),m_encrypt(nilRemove),m_decrypt(nilRemove),m_preserveCompression(1, nilRemove,false),m_DFUServerQueue(nilRemove),m_ExpireDays(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("Copy");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CCopy::CCopy(const char *serviceName, const char *bc)
	: m_sourceLogicalName(nilRemove),m_destGroup(nilRemove),m_destGroupRoxie(nilRemove),m_destLogicalName(nilRemove),m_sourceDali(nilRemove),m_srcusername(nilRemove),m_srcpassword(nilRemove),m_overwrite(nilRemove),m_replicate(nilRemove),m_ReplicateOffset(1, nilRemove,false),m_maxConnections(nilRemove),m_throttle(nilRemove),m_transferBufferSize(nilRemove),m_nosplit(nilRemove),m_norecover(0, nilRemove,false),m_compress(0, nilRemove,false),m_Wrap(0, nilRemove,false),m_Multicopy(0, nilRemove,false),m_SourceDiffKeyName(nilRemove),m_DestDiffKeyName(nilRemove),m_superCopy(0, nilRemove,false),m_push(0, nilRemove,false),m_pull(0, nilRemove,false),m_ifnewer(0, nilRemove,false),m_encrypt(nilRemove),m_decrypt(nilRemove),m_preserveCompression(1, nilRemove,false),m_DFUServerQueue(nilRemove),m_ExpireDays(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("Copy");
}

CCopy::CCopy(const char *serviceName, IRpcMessage* rpcmsg)
	: m_sourceLogicalName(nilRemove),m_destGroup(nilRemove),m_destGroupRoxie(nilRemove),m_destLogicalName(nilRemove),m_sourceDali(nilRemove),m_srcusername(nilRemove),m_srcpassword(nilRemove),m_overwrite(nilRemove),m_replicate(nilRemove),m_ReplicateOffset(1, nilRemove,false),m_maxConnections(nilRemove),m_throttle(nilRemove),m_transferBufferSize(nilRemove),m_nosplit(nilRemove),m_norecover(0, nilRemove,false),m_compress(0, nilRemove,false),m_Wrap(0, nilRemove,false),m_Multicopy(0, nilRemove,false),m_SourceDiffKeyName(nilRemove),m_DestDiffKeyName(nilRemove),m_superCopy(0, nilRemove,false),m_push(0, nilRemove,false),m_pull(0, nilRemove,false),m_ifnewer(0, nilRemove,false),m_encrypt(nilRemove),m_decrypt(nilRemove),m_preserveCompression(1, nilRemove,false),m_DFUServerQueue(nilRemove),m_ExpireDays(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("Copy");
	unserialize(*rpcmsg,NULL,NULL);
}

CCopy::CCopy(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_sourceLogicalName(nilRemove),m_destGroup(nilRemove),m_destGroupRoxie(nilRemove),m_destLogicalName(nilRemove),m_sourceDali(nilRemove),m_srcusername(nilRemove),m_srcpassword(nilRemove),m_overwrite(nilRemove),m_replicate(nilRemove),m_ReplicateOffset(1, nilRemove,false),m_maxConnections(nilRemove),m_throttle(nilRemove),m_transferBufferSize(nilRemove),m_nosplit(nilRemove),m_norecover(0, nilRemove,false),m_compress(0, nilRemove,false),m_Wrap(0, nilRemove,false),m_Multicopy(0, nilRemove,false),m_SourceDiffKeyName(nilRemove),m_DestDiffKeyName(nilRemove),m_superCopy(0, nilRemove,false),m_push(0, nilRemove,false),m_pull(0, nilRemove,false),m_ifnewer(0, nilRemove,false),m_encrypt(nilRemove),m_decrypt(nilRemove),m_preserveCompression(1, nilRemove,false),m_DFUServerQueue(nilRemove),m_ExpireDays(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("Copy");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CCopy::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"sourceLogicalName\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"destGroup\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"destGroupRoxie\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"destLogicalName\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"sourceDali\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"srcusername\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"srcpassword\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"overwrite\" type=\"xsd:boolean\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"replicate\" type=\"xsd:boolean\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" default=\"1\" name=\"ReplicateOffset\" type=\"xsd:int\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"maxConnections\" type=\"xsd:int\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"throttle\" type=\"xsd:int\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"transferBufferSize\" type=\"xsd:int\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"nosplit\" type=\"xsd:boolean\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" default=\"false\" name=\"norecover\" type=\"xsd:boolean\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" default=\"false\" name=\"compress\" type=\"xsd:boolean\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" default=\"false\" name=\"Wrap\" type=\"xsd:boolean\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" default=\"false\" name=\"Multicopy\" type=\"xsd:boolean\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"SourceDiffKeyName\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"DestDiffKeyName\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" default=\"false\" name=\"superCopy\" type=\"xsd:boolean\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" default=\"false\" name=\"push\" type=\"xsd:boolean\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" default=\"false\" name=\"pull\" type=\"xsd:boolean\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" default=\"false\" name=\"ifnewer\" type=\"xsd:boolean\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"encrypt\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"decrypt\" type=\"xsd:string\"/>\n");
		if (!context.suppressed("Copy","preserveCompression")) {
			schema.append("<xsd:element minOccurs=\"0\" default=\"true\" name=\"preserveCompression\" type=\"xsd:boolean\"/>\n");
		}
		if (!context.suppressed("Copy","DFUServerQueue")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"DFUServerQueue\" type=\"xsd:string\"/>\n");
		}
		if (!context.suppressed("Copy","ExpireDays")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"ExpireDays\" type=\"xsd:int\"/>\n");
		}
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CCopy::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CCopy::getMapInfo(IMapInfo& info, BoolHash& added)
{
	info.addMinVersion("Copy","preserveCompression",1.12);
	info.addMinVersion("Copy","DFUServerQueue",1.14);
	info.addMinVersion("Copy","ExpireDays",1.17);
}

StringBuffer &CCopy::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("sourceLogicalName");
	form.appendf("  <tr><td><b>sourceLogicalName: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("destGroup");
	form.appendf("  <tr><td><b>destGroup: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("destGroupRoxie");
	form.appendf("  <tr><td><b>destGroupRoxie: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("destLogicalName");
	form.appendf("  <tr><td><b>destLogicalName: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("sourceDali");
	form.appendf("  <tr><td><b>sourceDali: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("srcusername");
	form.appendf("  <tr><td><b>srcusername: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("srcpassword");
	form.appendf("  <tr><td><b>srcpassword: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("overwrite");
	
	form.appendf("  <tr><td><b>overwrite? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("replicate");
	
	form.appendf("  <tr><td><b>replicate? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	extfix.clear();
	if (prefix && *prefix) extfix.append(prefix).append(".");
		extfix.append("ReplicateOffset");
	form.appendf("  <tr><td><b>ReplicateOffset: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"	 value=\"1\"/>", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix) extfix.append(prefix).append(".");
		extfix.append("maxConnections");
	form.appendf("  <tr><td><b>maxConnections: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix) extfix.append(prefix).append(".");
		extfix.append("throttle");
	form.appendf("  <tr><td><b>throttle: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix) extfix.append(prefix).append(".");
		extfix.append("transferBufferSize");
	form.appendf("  <tr><td><b>transferBufferSize: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("nosplit");
	
	form.appendf("  <tr><td><b>nosplit? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("norecover");
	
	form.appendf("  <tr><td><b>norecover? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("compress");
	
	form.appendf("  <tr><td><b>compress? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Wrap");
	
	form.appendf("  <tr><td><b>Wrap? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Multicopy");
	
	form.appendf("  <tr><td><b>Multicopy? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("SourceDiffKeyName");
	form.appendf("  <tr><td><b>SourceDiffKeyName: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("DestDiffKeyName");
	form.appendf("  <tr><td><b>DestDiffKeyName: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("superCopy");
	
	form.appendf("  <tr><td><b>superCopy? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("push");
	
	form.appendf("  <tr><td><b>push? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("pull");
	
	form.appendf("  <tr><td><b>pull? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("ifnewer");
	
	form.appendf("  <tr><td><b>ifnewer? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("encrypt");
	form.appendf("  <tr><td><b>encrypt: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("decrypt");
	form.appendf("  <tr><td><b>decrypt: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (!context.suppressed("Copy","preserveCompression")) {
		extfix.clear();
		if (prefix && *prefix)
			extfix.append(prefix).append(".");
		extfix.append("preserveCompression");
		
	form.appendf("  <tr><td><b>preserveCompression? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\" checked=\"1\" /></td></tr>\n", extfix.str());
	}
	if (!context.suppressed("Copy","DFUServerQueue")) {
		extfix.clear();
		if (prefix && *prefix)
			extfix.append(prefix).append(".");
		extfix.append("DFUServerQueue");
		form.appendf("  <tr><td><b>DFUServerQueue: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
		form.append("</td></tr>\n");
	}
	if (!context.suppressed("Copy","ExpireDays")) {
		extfix.clear();
		if (prefix && *prefix) extfix.append(prefix).append(".");
			extfix.append("ExpireDays");
		form.appendf("  <tr><td><b>ExpireDays: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
		form.append("</td></tr>\n");
	}
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CCopy::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CCopy::serialize(IRpcMessage& rpc_resp)
{
	IEspContext* ctx = rpc_resp.queryContext();
	double clientVer= ctx ? ctx->getClientVersion() : -1; /* no context gets everything */
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_sourceLogicalName.marshall(rpc_resp, "sourceLogicalName", "", "", "");
	m_destGroup.marshall(rpc_resp, "destGroup", "", "", "");
	m_destGroupRoxie.marshall(rpc_resp, "destGroupRoxie", "", "", "");
	m_destLogicalName.marshall(rpc_resp, "destLogicalName", "", "", "");
	m_sourceDali.marshall(rpc_resp, "sourceDali", "", "", "");
	m_srcusername.marshall(rpc_resp, "srcusername", "", "", "");
	m_srcpassword.marshall(rpc_resp, "srcpassword", "", "", "");
	m_overwrite.marshall(rpc_resp, "overwrite", "", "", "");
	m_replicate.marshall(rpc_resp, "replicate", "", "", "");
	m_ReplicateOffset.marshall(rpc_resp, "ReplicateOffset", "", "", "");
	m_maxConnections.marshall(rpc_resp, "maxConnections", "", "", "");
	m_throttle.marshall(rpc_resp, "throttle", "", "", "");
	m_transferBufferSize.marshall(rpc_resp, "transferBufferSize", "", "", "");
	m_nosplit.marshall(rpc_resp, "nosplit", "", "", "");
	m_norecover.marshall(rpc_resp, "norecover", "", "", "");
	m_compress.marshall(rpc_resp, "compress", "", "", "");
	m_Wrap.marshall(rpc_resp, "Wrap", "", "", "");
	m_Multicopy.marshall(rpc_resp, "Multicopy", "", "", "");
	m_SourceDiffKeyName.marshall(rpc_resp, "SourceDiffKeyName", "", "", "");
	m_DestDiffKeyName.marshall(rpc_resp, "DestDiffKeyName", "", "", "");
	m_superCopy.marshall(rpc_resp, "superCopy", "", "", "");
	m_push.marshall(rpc_resp, "push", "", "", "");
	m_pull.marshall(rpc_resp, "pull", "", "", "");
	m_ifnewer.marshall(rpc_resp, "ifnewer", "", "", "");
	m_encrypt.marshall(rpc_resp, "encrypt", "", "", "");
	m_decrypt.marshall(rpc_resp, "decrypt", "", "", "");
	if ((clientVer==-1.0 || clientVer>=1.12))
		m_preserveCompression.marshall(rpc_resp, "preserveCompression", "", "", "");
	if ((clientVer==-1.0 || clientVer>=1.14))
		m_DFUServerQueue.marshall(rpc_resp, "DFUServerQueue", "", "", "");
	if ((clientVer==-1.0 || clientVer>=1.17))
		m_ExpireDays.marshall(rpc_resp, "ExpireDays", "", "", "");
}


void CCopy::copy(CCopy &from)
{
	m_sourceLogicalName.copy(from.m_sourceLogicalName);
	m_destGroup.copy(from.m_destGroup);
	m_destGroupRoxie.copy(from.m_destGroupRoxie);
	m_destLogicalName.copy(from.m_destLogicalName);
	m_sourceDali.copy(from.m_sourceDali);
	m_srcusername.copy(from.m_srcusername);
	m_srcpassword.copy(from.m_srcpassword);
	m_overwrite.copy(from.m_overwrite);
	m_replicate.copy(from.m_replicate);
	m_ReplicateOffset.copy(from.m_ReplicateOffset);
	m_maxConnections.copy(from.m_maxConnections);
	m_throttle.copy(from.m_throttle);
	m_transferBufferSize.copy(from.m_transferBufferSize);
	m_nosplit.copy(from.m_nosplit);
	m_norecover.copy(from.m_norecover);
	m_compress.copy(from.m_compress);
	m_Wrap.copy(from.m_Wrap);
	m_Multicopy.copy(from.m_Multicopy);
	m_SourceDiffKeyName.copy(from.m_SourceDiffKeyName);
	m_DestDiffKeyName.copy(from.m_DestDiffKeyName);
	m_superCopy.copy(from.m_superCopy);
	m_push.copy(from.m_push);
	m_pull.copy(from.m_pull);
	m_ifnewer.copy(from.m_ifnewer);
	m_encrypt.copy(from.m_encrypt);
	m_decrypt.copy(from.m_decrypt);
	m_preserveCompression.copy(from.m_preserveCompression);
	m_DFUServerQueue.copy(from.m_DFUServerQueue);
	m_ExpireDays.copy(from.m_ExpireDays);
}


void CCopy::copy(IConstCopy &ifrom)
{
	setSourceLogicalName(ifrom.getSourceLogicalName());
	setDestGroup(ifrom.getDestGroup());
	setDestGroupRoxie(ifrom.getDestGroupRoxie());
	setDestLogicalName(ifrom.getDestLogicalName());
	setSourceDali(ifrom.getSourceDali());
	setSrcusername(ifrom.getSrcusername());
	setSrcpassword(ifrom.getSrcpassword());
	setOverwrite(ifrom.getOverwrite());
	setReplicate(ifrom.getReplicate());
	setReplicateOffset(ifrom.getReplicateOffset());
	setMaxConnections(ifrom.getMaxConnections());
	setThrottle(ifrom.getThrottle());
	setTransferBufferSize(ifrom.getTransferBufferSize());
	setNosplit(ifrom.getNosplit());
	setNorecover(ifrom.getNorecover());
	setCompress(ifrom.getCompress());
	setWrap(ifrom.getWrap());
	setMulticopy(ifrom.getMulticopy());
	setSourceDiffKeyName(ifrom.getSourceDiffKeyName());
	setDestDiffKeyName(ifrom.getDestDiffKeyName());
	setSuperCopy(ifrom.getSuperCopy());
	setPush(ifrom.getPush());
	setPull(ifrom.getPull());
	setIfnewer(ifrom.getIfnewer());
	setEncrypt(ifrom.getEncrypt());
	setDecrypt(ifrom.getDecrypt());
	setPreserveCompression(ifrom.getPreserveCompression());
	setDFUServerQueue(ifrom.getDFUServerQueue());
	setExpireDays(ifrom.getExpireDays());
}


void CCopy::getAttributes(IProperties &attributes)
{
}


void CCopy::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	double clientVer = ctx ? ctx->getClientVersion() : -1;
	m_sourceLogicalName.toStr(ctx, buffer, "sourceLogicalName", "", true, "", "");
	m_destGroup.toStr(ctx, buffer, "destGroup", "", true, "", "");
	m_destGroupRoxie.toStr(ctx, buffer, "destGroupRoxie", "", true, "", "");
	m_destLogicalName.toStr(ctx, buffer, "destLogicalName", "", true, "", "");
	m_sourceDali.toStr(ctx, buffer, "sourceDali", "", true, "", "");
	m_srcusername.toStr(ctx, buffer, "srcusername", "", true, "", "");
	m_srcpassword.toStr(ctx, buffer, "srcpassword", "", true, "", "");
	m_overwrite.toStr(ctx, buffer, "overwrite", "", true, "", "");
	m_replicate.toStr(ctx, buffer, "replicate", "", true, "", "");
	m_ReplicateOffset.toStr(ctx, buffer, "ReplicateOffset", "", true, "", "");
	m_maxConnections.toStr(ctx, buffer, "maxConnections", "", true, "", "");
	m_throttle.toStr(ctx, buffer, "throttle", "", true, "", "");
	m_transferBufferSize.toStr(ctx, buffer, "transferBufferSize", "", true, "", "");
	m_nosplit.toStr(ctx, buffer, "nosplit", "", true, "", "");
	m_norecover.toStr(ctx, buffer, "norecover", "", true, "", "");
	m_compress.toStr(ctx, buffer, "compress", "", true, "", "");
	m_Wrap.toStr(ctx, buffer, "Wrap", "", true, "", "");
	m_Multicopy.toStr(ctx, buffer, "Multicopy", "", true, "", "");
	m_SourceDiffKeyName.toStr(ctx, buffer, "SourceDiffKeyName", "", true, "", "");
	m_DestDiffKeyName.toStr(ctx, buffer, "DestDiffKeyName", "", true, "", "");
	m_superCopy.toStr(ctx, buffer, "superCopy", "", true, "", "");
	m_push.toStr(ctx, buffer, "push", "", true, "", "");
	m_pull.toStr(ctx, buffer, "pull", "", true, "", "");
	m_ifnewer.toStr(ctx, buffer, "ifnewer", "", true, "", "");
	m_encrypt.toStr(ctx, buffer, "encrypt", "", true, "", "");
	m_decrypt.toStr(ctx, buffer, "decrypt", "", true, "", "");
	if ((clientVer==-1.0 || clientVer>=1.12))
		m_preserveCompression.toStr(ctx, buffer, "preserveCompression", "", true, "", "");
	if ((clientVer==-1.0 || clientVer>=1.14))
		m_DFUServerQueue.toStr(ctx, buffer, "DFUServerQueue", "", true, "", "");
	if ((clientVer==-1.0 || clientVer>=1.17))
		m_ExpireDays.toStr(ctx, buffer, "ExpireDays", "", true, "", "");
}


void CCopy::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CCopy::serializer(IEspContext* ctx, IConstCopy &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<Copy>");
	double clientVer = ctx ? ctx->getClientVersion() : -1;
	// field sourceLogicalName
	{
		const char* s = src.getSourceLogicalName();
		if (s && *s)
		{
			buffer.append("<sourceLogicalName>");
			encodeUtf8XML(s,buffer);
			buffer.append("</sourceLogicalName>");
		}
	}
	// field destGroup
	{
		const char* s = src.getDestGroup();
		if (s && *s)
		{
			buffer.append("<destGroup>");
			encodeUtf8XML(s,buffer);
			buffer.append("</destGroup>");
		}
	}
	// field destGroupRoxie
	{
		const char* s = src.getDestGroupRoxie();
		if (s && *s)
		{
			buffer.append("<destGroupRoxie>");
			encodeUtf8XML(s,buffer);
			buffer.append("</destGroupRoxie>");
		}
	}
	// field destLogicalName
	{
		const char* s = src.getDestLogicalName();
		if (s && *s)
		{
			buffer.append("<destLogicalName>");
			encodeUtf8XML(s,buffer);
			buffer.append("</destLogicalName>");
		}
	}
	// field sourceDali
	{
		const char* s = src.getSourceDali();
		if (s && *s)
		{
			buffer.append("<sourceDali>");
			encodeUtf8XML(s,buffer);
			buffer.append("</sourceDali>");
		}
	}
	// field srcusername
	{
		const char* s = src.getSrcusername();
		if (s && *s)
		{
			buffer.append("<srcusername>");
			encodeUtf8XML(s,buffer);
			buffer.append("</srcusername>");
		}
	}
	// field srcpassword
	{
		const char* s = src.getSrcpassword();
		if (s && *s)
		{
			buffer.append("<srcpassword>");
			encodeUtf8XML(s,buffer);
			buffer.append("</srcpassword>");
		}
	}
	// field overwrite
	{
		bool b = src.getOverwrite();
		if (b)
			buffer.appendf("<overwrite>1</overwrite>");
	}
	// field replicate
	{
		bool b = src.getReplicate();
		if (b)
			buffer.appendf("<replicate>1</replicate>");
	}
	// field ReplicateOffset
	{
		int n = src.getReplicateOffset();
		if (n)
			buffer.appendf("<ReplicateOffset>%d</ReplicateOffset>", n);
	}
	// field maxConnections
	{
		int n = src.getMaxConnections();
		if (n)
			buffer.appendf("<maxConnections>%d</maxConnections>", n);
	}
	// field throttle
	{
		int n = src.getThrottle();
		if (n)
			buffer.appendf("<throttle>%d</throttle>", n);
	}
	// field transferBufferSize
	{
		int n = src.getTransferBufferSize();
		if (n)
			buffer.appendf("<transferBufferSize>%d</transferBufferSize>", n);
	}
	// field nosplit
	{
		bool b = src.getNosplit();
		if (b)
			buffer.appendf("<nosplit>1</nosplit>");
	}
	// field norecover
	{
		bool b = src.getNorecover();
		if (b)
			buffer.appendf("<norecover>1</norecover>");
	}
	// field compress
	{
		bool b = src.getCompress();
		if (b)
			buffer.appendf("<compress>1</compress>");
	}
	// field Wrap
	{
		bool b = src.getWrap();
		if (b)
			buffer.appendf("<Wrap>1</Wrap>");
	}
	// field Multicopy
	{
		bool b = src.getMulticopy();
		if (b)
			buffer.appendf("<Multicopy>1</Multicopy>");
	}
	// field SourceDiffKeyName
	{
		const char* s = src.getSourceDiffKeyName();
		if (s && *s)
		{
			buffer.append("<SourceDiffKeyName>");
			encodeUtf8XML(s,buffer);
			buffer.append("</SourceDiffKeyName>");
		}
	}
	// field DestDiffKeyName
	{
		const char* s = src.getDestDiffKeyName();
		if (s && *s)
		{
			buffer.append("<DestDiffKeyName>");
			encodeUtf8XML(s,buffer);
			buffer.append("</DestDiffKeyName>");
		}
	}
	// field superCopy
	{
		bool b = src.getSuperCopy();
		if (b)
			buffer.appendf("<superCopy>1</superCopy>");
	}
	// field push
	{
		bool b = src.getPush();
		if (b)
			buffer.appendf("<push>1</push>");
	}
	// field pull
	{
		bool b = src.getPull();
		if (b)
			buffer.appendf("<pull>1</pull>");
	}
	// field ifnewer
	{
		bool b = src.getIfnewer();
		if (b)
			buffer.appendf("<ifnewer>1</ifnewer>");
	}
	// field encrypt
	{
		const char* s = src.getEncrypt();
		if (s && *s)
		{
			buffer.append("<encrypt>");
			encodeUtf8XML(s,buffer);
			buffer.append("</encrypt>");
		}
	}
	// field decrypt
	{
		const char* s = src.getDecrypt();
		if (s && *s)
		{
			buffer.append("<decrypt>");
			encodeUtf8XML(s,buffer);
			buffer.append("</decrypt>");
		}
	}
	// field preserveCompression
	if ((clientVer==-1.0 || clientVer>=1.12))
	{
		bool b = src.getPreserveCompression();
		if (b)
			buffer.appendf("<preserveCompression>1</preserveCompression>");
	}
	// field DFUServerQueue
	if ((clientVer==-1.0 || clientVer>=1.14))
	{
		const char* s = src.getDFUServerQueue();
		if (s && *s)
		{
			buffer.append("<DFUServerQueue>");
			encodeUtf8XML(s,buffer);
			buffer.append("</DFUServerQueue>");
		}
	}
	// field ExpireDays
	if ((clientVer==-1.0 || clientVer>=1.17))
	{
		int n = src.getExpireDays();
		if (n)
			buffer.appendf("<ExpireDays>%d</ExpireDays>", n);
	}
	if (keepRootTag)
		buffer.append("</Copy>");
}

bool CCopy::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_sourceLogicalName.unmarshall(rpc_request, "sourceLogicalName", basepath);
	hasValue |= m_destGroup.unmarshall(rpc_request, "destGroup", basepath);
	hasValue |= m_destGroupRoxie.unmarshall(rpc_request, "destGroupRoxie", basepath);
	hasValue |= m_destLogicalName.unmarshall(rpc_request, "destLogicalName", basepath);
	hasValue |= m_sourceDali.unmarshall(rpc_request, "sourceDali", basepath);
	hasValue |= m_srcusername.unmarshall(rpc_request, "srcusername", basepath);
	hasValue |= m_srcpassword.unmarshall(rpc_request, "srcpassword", basepath);
	hasValue |= m_overwrite.unmarshall(rpc_request, "overwrite", basepath);
	hasValue |= m_replicate.unmarshall(rpc_request, "replicate", basepath);
	hasValue |= m_ReplicateOffset.unmarshall(rpc_request, "ReplicateOffset", basepath);
	hasValue |= m_maxConnections.unmarshall(rpc_request, "maxConnections", basepath);
	hasValue |= m_throttle.unmarshall(rpc_request, "throttle", basepath);
	hasValue |= m_transferBufferSize.unmarshall(rpc_request, "transferBufferSize", basepath);
	hasValue |= m_nosplit.unmarshall(rpc_request, "nosplit", basepath);
	hasValue |= m_norecover.unmarshall(rpc_request, "norecover", basepath);
	hasValue |= m_compress.unmarshall(rpc_request, "compress", basepath);
	hasValue |= m_Wrap.unmarshall(rpc_request, "Wrap", basepath);
	hasValue |= m_Multicopy.unmarshall(rpc_request, "Multicopy", basepath);
	hasValue |= m_SourceDiffKeyName.unmarshall(rpc_request, "SourceDiffKeyName", basepath);
	hasValue |= m_DestDiffKeyName.unmarshall(rpc_request, "DestDiffKeyName", basepath);
	hasValue |= m_superCopy.unmarshall(rpc_request, "superCopy", basepath);
	hasValue |= m_push.unmarshall(rpc_request, "push", basepath);
	hasValue |= m_pull.unmarshall(rpc_request, "pull", basepath);
	hasValue |= m_ifnewer.unmarshall(rpc_request, "ifnewer", basepath);
	hasValue |= m_encrypt.unmarshall(rpc_request, "encrypt", basepath);
	hasValue |= m_decrypt.unmarshall(rpc_request, "decrypt", basepath);
	hasValue |= m_preserveCompression.unmarshall(rpc_request, "preserveCompression", basepath);
	hasValue |= m_DFUServerQueue.unmarshall(rpc_request, "DFUServerQueue", basepath);
	hasValue |= m_ExpireDays.unmarshall(rpc_request, "ExpireDays", basepath);
	return hasValue;
}

bool CCopy::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_sourceLogicalName.unmarshall(ctx, soapval, "sourceLogicalName");
	hasValue |= m_destGroup.unmarshall(ctx, soapval, "destGroup");
	hasValue |= m_destGroupRoxie.unmarshall(ctx, soapval, "destGroupRoxie");
	hasValue |= m_destLogicalName.unmarshall(ctx, soapval, "destLogicalName");
	hasValue |= m_sourceDali.unmarshall(ctx, soapval, "sourceDali");
	hasValue |= m_srcusername.unmarshall(ctx, soapval, "srcusername");
	hasValue |= m_srcpassword.unmarshall(ctx, soapval, "srcpassword");
	hasValue |= m_overwrite.unmarshall(ctx, soapval, "overwrite");
	hasValue |= m_replicate.unmarshall(ctx, soapval, "replicate");
	hasValue |= m_ReplicateOffset.unmarshall(ctx, soapval, "ReplicateOffset");
	hasValue |= m_maxConnections.unmarshall(ctx, soapval, "maxConnections");
	hasValue |= m_throttle.unmarshall(ctx, soapval, "throttle");
	hasValue |= m_transferBufferSize.unmarshall(ctx, soapval, "transferBufferSize");
	hasValue |= m_nosplit.unmarshall(ctx, soapval, "nosplit");
	hasValue |= m_norecover.unmarshall(ctx, soapval, "norecover");
	hasValue |= m_compress.unmarshall(ctx, soapval, "compress");
	hasValue |= m_Wrap.unmarshall(ctx, soapval, "Wrap");
	hasValue |= m_Multicopy.unmarshall(ctx, soapval, "Multicopy");
	hasValue |= m_SourceDiffKeyName.unmarshall(ctx, soapval, "SourceDiffKeyName");
	hasValue |= m_DestDiffKeyName.unmarshall(ctx, soapval, "DestDiffKeyName");
	hasValue |= m_superCopy.unmarshall(ctx, soapval, "superCopy");
	hasValue |= m_push.unmarshall(ctx, soapval, "push");
	hasValue |= m_pull.unmarshall(ctx, soapval, "pull");
	hasValue |= m_ifnewer.unmarshall(ctx, soapval, "ifnewer");
	hasValue |= m_encrypt.unmarshall(ctx, soapval, "encrypt");
	hasValue |= m_decrypt.unmarshall(ctx, soapval, "decrypt");
	hasValue |= m_preserveCompression.unmarshall(ctx, soapval, "preserveCompression");
	hasValue |= m_DFUServerQueue.unmarshall(ctx, soapval, "DFUServerQueue");
	hasValue |= m_ExpireDays.unmarshall(ctx, soapval, "ExpireDays");
	return hasValue;
}

bool CCopy::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_sourceLogicalName.unmarshall(ctx, params, attachments, "sourceLogicalName", basepath);
	hasValue |= m_destGroup.unmarshall(ctx, params, attachments, "destGroup", basepath);
	hasValue |= m_destGroupRoxie.unmarshall(ctx, params, attachments, "destGroupRoxie", basepath);
	hasValue |= m_destLogicalName.unmarshall(ctx, params, attachments, "destLogicalName", basepath);
	hasValue |= m_sourceDali.unmarshall(ctx, params, attachments, "sourceDali", basepath);
	hasValue |= m_srcusername.unmarshall(ctx, params, attachments, "srcusername", basepath);
	hasValue |= m_srcpassword.unmarshall(ctx, params, attachments, "srcpassword", basepath);
	hasValue |= m_overwrite.unmarshall(ctx, params, attachments, "overwrite", basepath);
	hasValue |= m_replicate.unmarshall(ctx, params, attachments, "replicate", basepath);
	hasValue |= m_ReplicateOffset.unmarshall(ctx, params, attachments, "ReplicateOffset", basepath);
	hasValue |= m_maxConnections.unmarshall(ctx, params, attachments, "maxConnections", basepath);
	hasValue |= m_throttle.unmarshall(ctx, params, attachments, "throttle", basepath);
	hasValue |= m_transferBufferSize.unmarshall(ctx, params, attachments, "transferBufferSize", basepath);
	hasValue |= m_nosplit.unmarshall(ctx, params, attachments, "nosplit", basepath);
	hasValue |= m_norecover.unmarshall(ctx, params, attachments, "norecover", basepath);
	hasValue |= m_compress.unmarshall(ctx, params, attachments, "compress", basepath);
	hasValue |= m_Wrap.unmarshall(ctx, params, attachments, "Wrap", basepath);
	hasValue |= m_Multicopy.unmarshall(ctx, params, attachments, "Multicopy", basepath);
	hasValue |= m_SourceDiffKeyName.unmarshall(ctx, params, attachments, "SourceDiffKeyName", basepath);
	hasValue |= m_DestDiffKeyName.unmarshall(ctx, params, attachments, "DestDiffKeyName", basepath);
	hasValue |= m_superCopy.unmarshall(ctx, params, attachments, "superCopy", basepath);
	hasValue |= m_push.unmarshall(ctx, params, attachments, "push", basepath);
	hasValue |= m_pull.unmarshall(ctx, params, attachments, "pull", basepath);
	hasValue |= m_ifnewer.unmarshall(ctx, params, attachments, "ifnewer", basepath);
	hasValue |= m_encrypt.unmarshall(ctx, params, attachments, "encrypt", basepath);
	hasValue |= m_decrypt.unmarshall(ctx, params, attachments, "decrypt", basepath);
	hasValue |= m_preserveCompression.unmarshall(ctx, params, attachments, "preserveCompression", basepath);
	hasValue |= m_DFUServerQueue.unmarshall(ctx, params, attachments, "DFUServerQueue", basepath);
	hasValue |= m_ExpireDays.unmarshall(ctx, params, attachments, "ExpireDays", basepath);
	return hasValue;
}

const char * CCopy::getSourceLogicalName() { return m_sourceLogicalName.query();}
const char * CCopy::getDestGroup() { return m_destGroup.query();}
const char * CCopy::getDestGroupRoxie() { return m_destGroupRoxie.query();}
const char * CCopy::getDestLogicalName() { return m_destLogicalName.query();}
const char * CCopy::getSourceDali() { return m_sourceDali.query();}
const char * CCopy::getSrcusername() { return m_srcusername.query();}
const char * CCopy::getSrcpassword() { return m_srcpassword.query();}
bool CCopy::getOverwrite_isNull(){return m_overwrite.is_nil();}
bool CCopy::getOverwrite() { return m_overwrite;}
bool CCopy::getReplicate_isNull(){return m_replicate.is_nil();}
bool CCopy::getReplicate() { return m_replicate;}
bool CCopy::getReplicateOffset_isNull(){return m_ReplicateOffset.is_nil();}
int CCopy::getReplicateOffset() { return m_ReplicateOffset;}
bool CCopy::getMaxConnections_isNull(){return m_maxConnections.is_nil();}
int CCopy::getMaxConnections() { return m_maxConnections;}
bool CCopy::getThrottle_isNull(){return m_throttle.is_nil();}
int CCopy::getThrottle() { return m_throttle;}
bool CCopy::getTransferBufferSize_isNull(){return m_transferBufferSize.is_nil();}
int CCopy::getTransferBufferSize() { return m_transferBufferSize;}
bool CCopy::getNosplit_isNull(){return m_nosplit.is_nil();}
bool CCopy::getNosplit() { return m_nosplit;}
bool CCopy::getNorecover_isNull(){return m_norecover.is_nil();}
bool CCopy::getNorecover() { return m_norecover;}
bool CCopy::getCompress_isNull(){return m_compress.is_nil();}
bool CCopy::getCompress() { return m_compress;}
bool CCopy::getWrap_isNull(){return m_Wrap.is_nil();}
bool CCopy::getWrap() { return m_Wrap;}
bool CCopy::getMulticopy_isNull(){return m_Multicopy.is_nil();}
bool CCopy::getMulticopy() { return m_Multicopy;}
const char * CCopy::getSourceDiffKeyName() { return m_SourceDiffKeyName.query();}
const char * CCopy::getDestDiffKeyName() { return m_DestDiffKeyName.query();}
bool CCopy::getSuperCopy_isNull(){return m_superCopy.is_nil();}
bool CCopy::getSuperCopy() { return m_superCopy;}
bool CCopy::getPush_isNull(){return m_push.is_nil();}
bool CCopy::getPush() { return m_push;}
bool CCopy::getPull_isNull(){return m_pull.is_nil();}
bool CCopy::getPull() { return m_pull;}
bool CCopy::getIfnewer_isNull(){return m_ifnewer.is_nil();}
bool CCopy::getIfnewer() { return m_ifnewer;}
const char * CCopy::getEncrypt() { return m_encrypt.query();}
const char * CCopy::getDecrypt() { return m_decrypt.query();}
bool CCopy::getPreserveCompression_isNull(){return m_preserveCompression.is_nil();}
bool CCopy::getPreserveCompression() { return m_preserveCompression;}
const char * CCopy::getDFUServerQueue() { return m_DFUServerQueue.query();}
bool CCopy::getExpireDays_isNull(){return m_ExpireDays.is_nil();}
int CCopy::getExpireDays() { return m_ExpireDays;}
void CCopy::setSourceLogicalName(const char * val){ m_sourceLogicalName.set(val); }
void CCopy::setDestGroup(const char * val){ m_destGroup.set(val); }
void CCopy::setDestGroupRoxie(const char * val){ m_destGroupRoxie.set(val); }
void CCopy::setDestLogicalName(const char * val){ m_destLogicalName.set(val); }
void CCopy::setSourceDali(const char * val){ m_sourceDali.set(val); }
void CCopy::setSrcusername(const char * val){ m_srcusername.set(val); }
void CCopy::setSrcpassword(const char * val){ m_srcpassword.set(val); }
void CCopy::setOverwrite_null(){ m_overwrite.Nil(); }void CCopy::setOverwrite(bool val){ m_overwrite=val; }
void CCopy::setReplicate_null(){ m_replicate.Nil(); }void CCopy::setReplicate(bool val){ m_replicate=val; }
void CCopy::setReplicateOffset_null(){ m_ReplicateOffset.Nil(); }void CCopy::setReplicateOffset(int val){ m_ReplicateOffset=val; }
void CCopy::setMaxConnections_null(){ m_maxConnections.Nil(); }void CCopy::setMaxConnections(int val){ m_maxConnections=val; }
void CCopy::setThrottle_null(){ m_throttle.Nil(); }void CCopy::setThrottle(int val){ m_throttle=val; }
void CCopy::setTransferBufferSize_null(){ m_transferBufferSize.Nil(); }void CCopy::setTransferBufferSize(int val){ m_transferBufferSize=val; }
void CCopy::setNosplit_null(){ m_nosplit.Nil(); }void CCopy::setNosplit(bool val){ m_nosplit=val; }
void CCopy::setNorecover_null(){ m_norecover.Nil(); }void CCopy::setNorecover(bool val){ m_norecover=val; }
void CCopy::setCompress_null(){ m_compress.Nil(); }void CCopy::setCompress(bool val){ m_compress=val; }
void CCopy::setWrap_null(){ m_Wrap.Nil(); }void CCopy::setWrap(bool val){ m_Wrap=val; }
void CCopy::setMulticopy_null(){ m_Multicopy.Nil(); }void CCopy::setMulticopy(bool val){ m_Multicopy=val; }
void CCopy::setSourceDiffKeyName(const char * val){ m_SourceDiffKeyName.set(val); }
void CCopy::setDestDiffKeyName(const char * val){ m_DestDiffKeyName.set(val); }
void CCopy::setSuperCopy_null(){ m_superCopy.Nil(); }void CCopy::setSuperCopy(bool val){ m_superCopy=val; }
void CCopy::setPush_null(){ m_push.Nil(); }void CCopy::setPush(bool val){ m_push=val; }
void CCopy::setPull_null(){ m_pull.Nil(); }void CCopy::setPull(bool val){ m_pull=val; }
void CCopy::setIfnewer_null(){ m_ifnewer.Nil(); }void CCopy::setIfnewer(bool val){ m_ifnewer=val; }
void CCopy::setEncrypt(const char * val){ m_encrypt.set(val); }
void CCopy::setDecrypt(const char * val){ m_decrypt.set(val); }
void CCopy::setPreserveCompression_null(){ m_preserveCompression.Nil(); }void CCopy::setPreserveCompression(bool val){ m_preserveCompression=val; }
void CCopy::setDFUServerQueue(const char * val){ m_DFUServerQueue.set(val); }
void CCopy::setExpireDays_null(){ m_ExpireDays.Nil(); }void CCopy::setExpireDays(int val){ m_ExpireDays=val; }
extern "C"  IEspCopy *createCopy(const char *serv){return ((IEspCopy *)new CCopy(serv));}
extern "C"  IClientCopy *createClientCopy(const char *serv){return ((IClientCopy *)new CCopy(serv));}

//=======================================================
// class CCopyResponse Implementation
//=======================================================

CCopyResponse::CCopyResponse(const char *serviceName, IRpcMessageBinding *init)
	: m_result(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("CopyResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CCopyResponse::CCopyResponse(const char *serviceName, const char *bc)
	: m_result(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("CopyResponse");
}

CCopyResponse::CCopyResponse(const char *serviceName, IRpcMessage* rpcmsg)
	: m_result(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("CopyResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CCopyResponse::CCopyResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_result(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("CopyResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CCopyResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		schema.append("<xsd:element name=\"Exceptions\" type=\"tns:ArrayOfEspException\" minOccurs=\"0\" maxOccurs=\"1\"/>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"result\" type=\"xsd:string\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CCopyResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CCopyResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CCopyResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("result");
	form.appendf("  <tr><td><b>result: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CCopyResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CCopyResponse::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
		m_result.marshall(rpc_resp, "result", "", "", "");
	}
}


void CCopyResponse::copy(CCopyResponse &from)
{
	m_result.copy(from.m_result);
}


void CCopyResponse::copy(IConstCopyResponse &ifrom)
{
	setResult(ifrom.getResult());
}


void CCopyResponse::getAttributes(IProperties &attributes)
{
}


void CCopyResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
		m_result.toStr(ctx, buffer, "result", "", true, "", "");
	}
}


void CCopyResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CCopyResponse::serializer(IEspContext* ctx, IConstCopyResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<CopyResponse>");
	// field result
	{
		const char* s = src.getResult();
		if (s && *s)
		{
			buffer.append("<result>");
			encodeUtf8XML(s,buffer);
			buffer.append("</result>");
		}
	}
	if (keepRootTag)
		buffer.append("</CopyResponse>");
}

bool CCopyResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
		hasValue |= m_result.unmarshall(rpc_request, "result", basepath);
	}
	return hasValue;
}

bool CCopyResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_result.unmarshall(ctx, soapval, "result");
	return hasValue;
}

bool CCopyResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_result.unmarshall(ctx, params, attachments, "result", basepath);
	return hasValue;
}

const char * CCopyResponse::getResult() { return m_result.query();}
void CCopyResponse::setResult(const char * val){ m_result.set(val); }
extern "C"  IEspCopyResponse *createCopyResponse(const char *serv){return ((IEspCopyResponse *)new CCopyResponse(serv));}
extern "C"  IClientCopyResponse *createClientCopyResponse(const char *serv){return ((IClientCopyResponse *)new CCopyResponse(serv));}

//=======================================================
// class CEchoDateTime Implementation
//=======================================================

CEchoDateTime::CEchoDateTime(const char *serviceName, IRpcMessageBinding *init)
	: m_dt(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("EchoDateTime");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CEchoDateTime::CEchoDateTime(const char *serviceName, const char *bc)
	: m_dt(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("EchoDateTime");
}

CEchoDateTime::CEchoDateTime(const char *serviceName, IRpcMessage* rpcmsg)
	: m_dt(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("EchoDateTime");
	unserialize(*rpcmsg,NULL,NULL);
}

CEchoDateTime::CEchoDateTime(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_dt(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("EchoDateTime");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CEchoDateTime::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"dt\" type=\"xsd:dateTime\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CEchoDateTime::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CEchoDateTime::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CEchoDateTime::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("dt");
	form.appendf("  <tr><td><b>dt: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CEchoDateTime::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CEchoDateTime::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_dt.marshall(rpc_resp, "dt", "", "", "");
}


void CEchoDateTime::copy(CEchoDateTime &from)
{
	m_dt.copy(from.m_dt);
}


void CEchoDateTime::copy(IConstEchoDateTime &ifrom)
{
	setDt(ifrom.getDt());
}


void CEchoDateTime::getAttributes(IProperties &attributes)
{
}


void CEchoDateTime::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_dt.toStr(ctx, buffer, "dt", "", true, "", "");
}


void CEchoDateTime::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CEchoDateTime::serializer(IEspContext* ctx, IConstEchoDateTime &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<EchoDateTime>");
	// field dt
	{
		const char* s = src.getDt();
		if (s && *s)
		{
			buffer.append("<dt>");
			encodeUtf8XML(s,buffer);
			buffer.append("</dt>");
		}
	}
	if (keepRootTag)
		buffer.append("</EchoDateTime>");
}

bool CEchoDateTime::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_dt.unmarshall(rpc_request, "dt", basepath);
	return hasValue;
}

bool CEchoDateTime::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_dt.unmarshall(ctx, soapval, "dt");
	return hasValue;
}

bool CEchoDateTime::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_dt.unmarshall(ctx, params, attachments, "dt", basepath);
	return hasValue;
}

const char * CEchoDateTime::getDt() { return m_dt.query();}
void CEchoDateTime::setDt(const char * val){ m_dt.set(val); }
extern "C"  IEspEchoDateTime *createEchoDateTime(const char *serv){return ((IEspEchoDateTime *)new CEchoDateTime(serv));}
extern "C"  IClientEchoDateTime *createClientEchoDateTime(const char *serv){return ((IClientEchoDateTime *)new CEchoDateTime(serv));}

//=======================================================
// class CEchoDateTimeResponse Implementation
//=======================================================

CEchoDateTimeResponse::CEchoDateTimeResponse(const char *serviceName, IRpcMessageBinding *init)
	: m_result(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("EchoDateTimeResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CEchoDateTimeResponse::CEchoDateTimeResponse(const char *serviceName, const char *bc)
	: m_result(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("EchoDateTimeResponse");
}

CEchoDateTimeResponse::CEchoDateTimeResponse(const char *serviceName, IRpcMessage* rpcmsg)
	: m_result(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("EchoDateTimeResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CEchoDateTimeResponse::CEchoDateTimeResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_result(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("EchoDateTimeResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CEchoDateTimeResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"result\" type=\"xsd:dateTime\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CEchoDateTimeResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CEchoDateTimeResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CEchoDateTimeResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("result");
	form.appendf("  <tr><td><b>result: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CEchoDateTimeResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CEchoDateTimeResponse::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
		m_result.marshall(rpc_resp, "result", "", "", "");
	}
}


void CEchoDateTimeResponse::copy(CEchoDateTimeResponse &from)
{
	m_result.copy(from.m_result);
}


void CEchoDateTimeResponse::copy(IConstEchoDateTimeResponse &ifrom)
{
	setResult(ifrom.getResult());
}


void CEchoDateTimeResponse::getAttributes(IProperties &attributes)
{
}


void CEchoDateTimeResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
		m_result.toStr(ctx, buffer, "result", "", true, "", "");
	}
}


void CEchoDateTimeResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CEchoDateTimeResponse::serializer(IEspContext* ctx, IConstEchoDateTimeResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<EchoDateTimeResponse>");
	// field result
	{
		const char* s = src.getResult();
		if (s && *s)
		{
			buffer.append("<result>");
			encodeUtf8XML(s,buffer);
			buffer.append("</result>");
		}
	}
	if (keepRootTag)
		buffer.append("</EchoDateTimeResponse>");
}

bool CEchoDateTimeResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
		hasValue |= m_result.unmarshall(rpc_request, "result", basepath);
	}
	return hasValue;
}

bool CEchoDateTimeResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_result.unmarshall(ctx, soapval, "result");
	return hasValue;
}

bool CEchoDateTimeResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_result.unmarshall(ctx, params, attachments, "result", basepath);
	return hasValue;
}

const char * CEchoDateTimeResponse::getResult() { return m_result.query();}
void CEchoDateTimeResponse::setResult(const char * val){ m_result.set(val); }
extern "C"  IEspEchoDateTimeResponse *createEchoDateTimeResponse(const char *serv){return ((IEspEchoDateTimeResponse *)new CEchoDateTimeResponse(serv));}
extern "C"  IClientEchoDateTimeResponse *createClientEchoDateTimeResponse(const char *serv){return ((IClientEchoDateTimeResponse *)new CEchoDateTimeResponse(serv));}

//=======================================================
// class CRename Implementation
//=======================================================

CRename::CRename(const char *serviceName, IRpcMessageBinding *init)
	: m_srcname(nilIgnore),m_dstname(nilIgnore),m_overwrite(nilIgnore),m_DFUServerQueue(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("Rename");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CRename::CRename(const char *serviceName, const char *bc)
	: m_srcname(nilIgnore),m_dstname(nilIgnore),m_overwrite(nilIgnore),m_DFUServerQueue(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("Rename");
}

CRename::CRename(const char *serviceName, IRpcMessage* rpcmsg)
	: m_srcname(nilIgnore),m_dstname(nilIgnore),m_overwrite(nilIgnore),m_DFUServerQueue(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("Rename");
	unserialize(*rpcmsg,NULL,NULL);
}

CRename::CRename(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_srcname(nilIgnore),m_dstname(nilIgnore),m_overwrite(nilIgnore),m_DFUServerQueue(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("Rename");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CRename::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"srcname\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"dstname\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"overwrite\" type=\"xsd:boolean\"/>\n");
		if (!context.suppressed("Rename","DFUServerQueue")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"DFUServerQueue\" type=\"xsd:string\"/>\n");
		}
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CRename::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CRename::getMapInfo(IMapInfo& info, BoolHash& added)
{
	info.addMinVersion("Rename","DFUServerQueue",1.14);
}

StringBuffer &CRename::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("srcname");
	form.appendf("  <tr><td><b>srcname: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("dstname");
	form.appendf("  <tr><td><b>dstname: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("overwrite");
	
	form.appendf("  <tr><td><b>overwrite? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	if (!context.suppressed("Rename","DFUServerQueue")) {
		extfix.clear();
		if (prefix && *prefix)
			extfix.append(prefix).append(".");
		extfix.append("DFUServerQueue");
		form.appendf("  <tr><td><b>DFUServerQueue: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
		form.append("</td></tr>\n");
	}
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CRename::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CRename::serialize(IRpcMessage& rpc_resp)
{
	IEspContext* ctx = rpc_resp.queryContext();
	double clientVer= ctx ? ctx->getClientVersion() : -1; /* no context gets everything */
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_srcname.marshall(rpc_resp, "srcname", "", "", "");
	m_dstname.marshall(rpc_resp, "dstname", "", "", "");
	m_overwrite.marshall(rpc_resp, "overwrite", "", "", "");
	if ((clientVer==-1.0 || clientVer>=1.14))
		m_DFUServerQueue.marshall(rpc_resp, "DFUServerQueue", "", "", "");
}


void CRename::copy(CRename &from)
{
	m_srcname.copy(from.m_srcname);
	m_dstname.copy(from.m_dstname);
	m_overwrite.copy(from.m_overwrite);
	m_DFUServerQueue.copy(from.m_DFUServerQueue);
}


void CRename::copy(IConstRename &ifrom)
{
	setSrcname(ifrom.getSrcname());
	setDstname(ifrom.getDstname());
	setOverwrite(ifrom.getOverwrite());
	setDFUServerQueue(ifrom.getDFUServerQueue());
}


void CRename::getAttributes(IProperties &attributes)
{
}


void CRename::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	double clientVer = ctx ? ctx->getClientVersion() : -1;
	m_srcname.toStr(ctx, buffer, "srcname", "", true, "", "");
	m_dstname.toStr(ctx, buffer, "dstname", "", true, "", "");
	m_overwrite.toStr(ctx, buffer, "overwrite", "", true, "", "");
	if ((clientVer==-1.0 || clientVer>=1.14))
		m_DFUServerQueue.toStr(ctx, buffer, "DFUServerQueue", "", true, "", "");
}


void CRename::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CRename::serializer(IEspContext* ctx, IConstRename &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<Rename>");
	double clientVer = ctx ? ctx->getClientVersion() : -1;
	// field srcname
	{
		const char* s = src.getSrcname();
		if (s && *s)
		{
			buffer.append("<srcname>");
			encodeUtf8XML(s,buffer);
			buffer.append("</srcname>");
		}
	}
	// field dstname
	{
		const char* s = src.getDstname();
		if (s && *s)
		{
			buffer.append("<dstname>");
			encodeUtf8XML(s,buffer);
			buffer.append("</dstname>");
		}
	}
	// field overwrite
	{
		bool b = src.getOverwrite();
		if (b)
			buffer.appendf("<overwrite>1</overwrite>");
	}
	// field DFUServerQueue
	if ((clientVer==-1.0 || clientVer>=1.14))
	{
		const char* s = src.getDFUServerQueue();
		if (s && *s)
		{
			buffer.append("<DFUServerQueue>");
			encodeUtf8XML(s,buffer);
			buffer.append("</DFUServerQueue>");
		}
	}
	if (keepRootTag)
		buffer.append("</Rename>");
}

bool CRename::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_srcname.unmarshall(rpc_request, "srcname", basepath);
	hasValue |= m_dstname.unmarshall(rpc_request, "dstname", basepath);
	hasValue |= m_overwrite.unmarshall(rpc_request, "overwrite", basepath);
	hasValue |= m_DFUServerQueue.unmarshall(rpc_request, "DFUServerQueue", basepath);
	return hasValue;
}

bool CRename::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_srcname.unmarshall(ctx, soapval, "srcname");
	hasValue |= m_dstname.unmarshall(ctx, soapval, "dstname");
	hasValue |= m_overwrite.unmarshall(ctx, soapval, "overwrite");
	hasValue |= m_DFUServerQueue.unmarshall(ctx, soapval, "DFUServerQueue");
	return hasValue;
}

bool CRename::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_srcname.unmarshall(ctx, params, attachments, "srcname", basepath);
	hasValue |= m_dstname.unmarshall(ctx, params, attachments, "dstname", basepath);
	hasValue |= m_overwrite.unmarshall(ctx, params, attachments, "overwrite", basepath);
	hasValue |= m_DFUServerQueue.unmarshall(ctx, params, attachments, "DFUServerQueue", basepath);
	return hasValue;
}

const char * CRename::getSrcname() { return m_srcname.query();}
const char * CRename::getDstname() { return m_dstname.query();}
bool CRename::getOverwrite() { return m_overwrite;}
const char * CRename::getDFUServerQueue() { return m_DFUServerQueue.query();}
void CRename::setSrcname(const char * val){ m_srcname.set(val); }
void CRename::setDstname(const char * val){ m_dstname.set(val); }
void CRename::setOverwrite(bool val){ m_overwrite=val; }
void CRename::setDFUServerQueue(const char * val){ m_DFUServerQueue.set(val); }
extern "C"  IEspRename *createRename(const char *serv){return ((IEspRename *)new CRename(serv));}
extern "C"  IClientRename *createClientRename(const char *serv){return ((IClientRename *)new CRename(serv));}

//=======================================================
// class CRenameResponse Implementation
//=======================================================

CRenameResponse::CRenameResponse(const char *serviceName, IRpcMessageBinding *init)
	: m_wuid(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("RenameResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CRenameResponse::CRenameResponse(const char *serviceName, const char *bc)
	: m_wuid(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("RenameResponse");
}

CRenameResponse::CRenameResponse(const char *serviceName, IRpcMessage* rpcmsg)
	: m_wuid(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("RenameResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CRenameResponse::CRenameResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_wuid(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("RenameResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CRenameResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		schema.append("<xsd:element name=\"Exceptions\" type=\"tns:ArrayOfEspException\" minOccurs=\"0\" maxOccurs=\"1\"/>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"wuid\" type=\"xsd:string\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CRenameResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CRenameResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CRenameResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("wuid");
	form.appendf("  <tr><td><b>wuid: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CRenameResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CRenameResponse::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
		m_wuid.marshall(rpc_resp, "wuid", "", "", "");
	}
}


void CRenameResponse::copy(CRenameResponse &from)
{
	m_wuid.copy(from.m_wuid);
}


void CRenameResponse::copy(IConstRenameResponse &ifrom)
{
	setWuid(ifrom.getWuid());
}


void CRenameResponse::getAttributes(IProperties &attributes)
{
}


void CRenameResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
		m_wuid.toStr(ctx, buffer, "wuid", "", true, "", "");
	}
}


void CRenameResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CRenameResponse::serializer(IEspContext* ctx, IConstRenameResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<RenameResponse>");
	// field wuid
	{
		const char* s = src.getWuid();
		if (s && *s)
		{
			buffer.append("<wuid>");
			encodeUtf8XML(s,buffer);
			buffer.append("</wuid>");
		}
	}
	if (keepRootTag)
		buffer.append("</RenameResponse>");
}

bool CRenameResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
		hasValue |= m_wuid.unmarshall(rpc_request, "wuid", basepath);
	}
	return hasValue;
}

bool CRenameResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_wuid.unmarshall(ctx, soapval, "wuid");
	return hasValue;
}

bool CRenameResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_wuid.unmarshall(ctx, params, attachments, "wuid", basepath);
	return hasValue;
}

const char * CRenameResponse::getWuid() { return m_wuid.query();}
void CRenameResponse::setWuid(const char * val){ m_wuid.set(val); }
extern "C"  IEspRenameResponse *createRenameResponse(const char *serv){return ((IEspRenameResponse *)new CRenameResponse(serv));}
extern "C"  IClientRenameResponse *createClientRenameResponse(const char *serv){return ((IClientRenameResponse *)new CRenameResponse(serv));}

//=======================================================
// class CDFUWUFileRequest Implementation
//=======================================================

CDFUWUFileRequest::CDFUWUFileRequest(const char *serviceName, IRpcMessageBinding *init)
	: m_Wuid(nilIgnore),m_Type(nilIgnore),m_PlainText(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("DFUWUFileRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CDFUWUFileRequest::CDFUWUFileRequest(const char *serviceName, const char *bc)
	: m_Wuid(nilIgnore),m_Type(nilIgnore),m_PlainText(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("DFUWUFileRequest");
}

CDFUWUFileRequest::CDFUWUFileRequest(const char *serviceName, IRpcMessage* rpcmsg)
	: m_Wuid(nilIgnore),m_Type(nilIgnore),m_PlainText(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("DFUWUFileRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CDFUWUFileRequest::CDFUWUFileRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_Wuid(nilIgnore),m_Type(nilIgnore),m_PlainText(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("DFUWUFileRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CDFUWUFileRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Wuid\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Type\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"PlainText\" type=\"xsd:string\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CDFUWUFileRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CDFUWUFileRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CDFUWUFileRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Wuid");
	form.appendf("  <tr><td><b>Wuid: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Type");
	form.appendf("  <tr><td><b>Type: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("PlainText");
	form.appendf("  <tr><td><b>PlainText: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CDFUWUFileRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CDFUWUFileRequest::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_Wuid.marshall(rpc_resp, "Wuid", "", "", "");
	m_Type.marshall(rpc_resp, "Type", "", "", "");
	m_PlainText.marshall(rpc_resp, "PlainText", "", "", "");
}


void CDFUWUFileRequest::copy(CDFUWUFileRequest &from)
{
	m_Wuid.copy(from.m_Wuid);
	m_Type.copy(from.m_Type);
	m_PlainText.copy(from.m_PlainText);
}


void CDFUWUFileRequest::copy(IConstDFUWUFileRequest &ifrom)
{
	setWuid(ifrom.getWuid());
	setType(ifrom.getType());
	setPlainText(ifrom.getPlainText());
}


void CDFUWUFileRequest::getAttributes(IProperties &attributes)
{
}


void CDFUWUFileRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_Wuid.toStr(ctx, buffer, "Wuid", "", true, "", "");
	m_Type.toStr(ctx, buffer, "Type", "", true, "", "");
	m_PlainText.toStr(ctx, buffer, "PlainText", "", true, "", "");
}


void CDFUWUFileRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CDFUWUFileRequest::serializer(IEspContext* ctx, IConstDFUWUFileRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<DFUWUFileRequest>");
	// field Wuid
	{
		const char* s = src.getWuid();
		if (s && *s)
		{
			buffer.append("<Wuid>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Wuid>");
		}
	}
	// field Type
	{
		const char* s = src.getType();
		if (s && *s)
		{
			buffer.append("<Type>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Type>");
		}
	}
	// field PlainText
	{
		const char* s = src.getPlainText();
		if (s && *s)
		{
			buffer.append("<PlainText>");
			encodeUtf8XML(s,buffer);
			buffer.append("</PlainText>");
		}
	}
	if (keepRootTag)
		buffer.append("</DFUWUFileRequest>");
}

bool CDFUWUFileRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_Wuid.unmarshall(rpc_request, "Wuid", basepath);
	hasValue |= m_Type.unmarshall(rpc_request, "Type", basepath);
	hasValue |= m_PlainText.unmarshall(rpc_request, "PlainText", basepath);
	return hasValue;
}

bool CDFUWUFileRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Wuid.unmarshall(ctx, soapval, "Wuid");
	hasValue |= m_Type.unmarshall(ctx, soapval, "Type");
	hasValue |= m_PlainText.unmarshall(ctx, soapval, "PlainText");
	return hasValue;
}

bool CDFUWUFileRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Wuid.unmarshall(ctx, params, attachments, "Wuid", basepath);
	hasValue |= m_Type.unmarshall(ctx, params, attachments, "Type", basepath);
	hasValue |= m_PlainText.unmarshall(ctx, params, attachments, "PlainText", basepath);
	return hasValue;
}

const char * CDFUWUFileRequest::getWuid() { return m_Wuid.query();}
const char * CDFUWUFileRequest::getType() { return m_Type.query();}
const char * CDFUWUFileRequest::getPlainText() { return m_PlainText.query();}
void CDFUWUFileRequest::setWuid(const char * val){ m_Wuid.set(val); }
void CDFUWUFileRequest::setType(const char * val){ m_Type.set(val); }
void CDFUWUFileRequest::setPlainText(const char * val){ m_PlainText.set(val); }
extern "C"  IEspDFUWUFileRequest *createDFUWUFileRequest(const char *serv){return ((IEspDFUWUFileRequest *)new CDFUWUFileRequest(serv));}
extern "C"  IClientDFUWUFileRequest *createClientDFUWUFileRequest(const char *serv){return ((IClientDFUWUFileRequest *)new CDFUWUFileRequest(serv));}

//=======================================================
// class CDFUWUFileResponse Implementation
//=======================================================

CDFUWUFileResponse::CDFUWUFileResponse(const char *serviceName, IRpcMessageBinding *init)
	: m_file(nilIgnore),m_file_mimetype("text/xml")
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("DFUWUFileResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CDFUWUFileResponse::CDFUWUFileResponse(const char *serviceName, const char *bc)
	: m_file(nilIgnore), m_file_mimetype("text/xml")
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("DFUWUFileResponse");
}

CDFUWUFileResponse::CDFUWUFileResponse(const char *serviceName, IRpcMessage* rpcmsg)
	: m_file(nilIgnore), m_file_mimetype("text/xml")
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("DFUWUFileResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CDFUWUFileResponse::CDFUWUFileResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_file(nilIgnore), m_file_mimetype("text/xml")
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("DFUWUFileResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CDFUWUFileResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		schema.append("<xsd:element name=\"Exceptions\" type=\"tns:ArrayOfEspException\" minOccurs=\"0\" maxOccurs=\"1\"/>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"file\" type=\"xsd:string\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CDFUWUFileResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CDFUWUFileResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CDFUWUFileResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("file");
	form.appendf("  <tr><td><b>file: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CDFUWUFileResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CDFUWUFileResponse::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
		m_file.marshall(rpc_resp, "file", "", "", "");
	}
}


void CDFUWUFileResponse::copy(CDFUWUFileResponse &from)
{
	m_file.copy(from.m_file);
}


void CDFUWUFileResponse::copy(IConstDFUWUFileResponse &ifrom)
{
	setFile(ifrom.getFile());
}


void CDFUWUFileResponse::getAttributes(IProperties &attributes)
{
}


void CDFUWUFileResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
		m_file.toStr(ctx, buffer, "file", "", true, "", "");
	}
}


void CDFUWUFileResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CDFUWUFileResponse::serializer(IEspContext* ctx, IConstDFUWUFileResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<DFUWUFileResponse>");
	// field file
	{
		const char* s = src.getFile();
		if (s && *s)
		{
			buffer.append("<file>");
			encodeUtf8XML(s,buffer);
			buffer.append("</file>");
		}
	}
	if (keepRootTag)
		buffer.append("</DFUWUFileResponse>");
}

void CDFUWUFileResponse::appendContent(IEspContext* ctx, MemoryBuffer& buffer, StringBuffer &mimetype)
{
	buffer.clear().append(m_file.getValue().length(), m_file.getValue().str());
	mimetype.set(m_file_mimetype.str());
}

bool CDFUWUFileResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
		hasValue |= m_file.unmarshall(rpc_request, "file", basepath);
	}
	return hasValue;
}

bool CDFUWUFileResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_file.unmarshall(ctx, soapval, "file");
	return hasValue;
}

bool CDFUWUFileResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_file.unmarshall(ctx, params, attachments, "file", basepath);
	return hasValue;
}

const char *CDFUWUFileResponse::getFile_mimetype(){ return m_file_mimetype.str(); }
const char * CDFUWUFileResponse::getFile() { return m_file.query();}
void CDFUWUFileResponse::setFile_mimetype(const char *  val){ m_file_mimetype.set(val); }
void CDFUWUFileResponse::setFile(const char * val){ m_file.set(val); }
extern "C"  IEspDFUWUFileResponse *createDFUWUFileResponse(const char *serv){return ((IEspDFUWUFileResponse *)new CDFUWUFileResponse(serv));}
extern "C"  IClientDFUWUFileResponse *createClientDFUWUFileResponse(const char *serv){return ((IClientDFUWUFileResponse *)new CDFUWUFileResponse(serv));}

//=======================================================
// class CFileListRequest Implementation
//=======================================================

CFileListRequest::CFileListRequest(const char *serviceName, IRpcMessageBinding *init)
	: m_Netaddr(nilIgnore),m_Path(nilIgnore),m_Mask(nilIgnore),m_OS(nilIgnore),m_DirectoryOnly(0, nilIgnore,false)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("FileListRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CFileListRequest::CFileListRequest(const char *serviceName, const char *bc)
	: m_Netaddr(nilIgnore),m_Path(nilIgnore),m_Mask(nilIgnore),m_OS(nilIgnore),m_DirectoryOnly(0, nilIgnore,false)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("FileListRequest");
}

CFileListRequest::CFileListRequest(const char *serviceName, IRpcMessage* rpcmsg)
	: m_Netaddr(nilIgnore),m_Path(nilIgnore),m_Mask(nilIgnore),m_OS(nilIgnore),m_DirectoryOnly(0, nilIgnore,false)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("FileListRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CFileListRequest::CFileListRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_Netaddr(nilIgnore),m_Path(nilIgnore),m_Mask(nilIgnore),m_OS(nilIgnore),m_DirectoryOnly(0, nilIgnore,false)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("FileListRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CFileListRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Netaddr\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Path\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Mask\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"OS\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" default=\"false\" name=\"DirectoryOnly\" type=\"xsd:boolean\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CFileListRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CFileListRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CFileListRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Netaddr");
	form.appendf("  <tr><td><b>Netaddr: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Path");
	form.appendf("  <tr><td><b>Path: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Mask");
	form.appendf("  <tr><td><b>Mask: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("OS");
	form.appendf("  <tr><td><b>OS: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("DirectoryOnly");
	
	form.appendf("  <tr><td><b>DirectoryOnly? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CFileListRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CFileListRequest::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_Netaddr.marshall(rpc_resp, "Netaddr", "", "", "");
	m_Path.marshall(rpc_resp, "Path", "", "", "");
	m_Mask.marshall(rpc_resp, "Mask", "", "", "");
	m_OS.marshall(rpc_resp, "OS", "", "", "");
	m_DirectoryOnly.marshall(rpc_resp, "DirectoryOnly", "", "", "");
}


void CFileListRequest::copy(CFileListRequest &from)
{
	m_Netaddr.copy(from.m_Netaddr);
	m_Path.copy(from.m_Path);
	m_Mask.copy(from.m_Mask);
	m_OS.copy(from.m_OS);
	m_DirectoryOnly.copy(from.m_DirectoryOnly);
}


void CFileListRequest::copy(IConstFileListRequest &ifrom)
{
	setNetaddr(ifrom.getNetaddr());
	setPath(ifrom.getPath());
	setMask(ifrom.getMask());
	setOS(ifrom.getOS());
	setDirectoryOnly(ifrom.getDirectoryOnly());
}


void CFileListRequest::getAttributes(IProperties &attributes)
{
}


void CFileListRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_Netaddr.toStr(ctx, buffer, "Netaddr", "", true, "", "");
	m_Path.toStr(ctx, buffer, "Path", "", true, "", "");
	m_Mask.toStr(ctx, buffer, "Mask", "", true, "", "");
	m_OS.toStr(ctx, buffer, "OS", "", true, "", "");
	m_DirectoryOnly.toStr(ctx, buffer, "DirectoryOnly", "", true, "", "");
}


void CFileListRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CFileListRequest::serializer(IEspContext* ctx, IConstFileListRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<FileListRequest>");
	// field Netaddr
	{
		const char* s = src.getNetaddr();
		if (s && *s)
		{
			buffer.append("<Netaddr>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Netaddr>");
		}
	}
	// field Path
	{
		const char* s = src.getPath();
		if (s && *s)
		{
			buffer.append("<Path>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Path>");
		}
	}
	// field Mask
	{
		const char* s = src.getMask();
		if (s && *s)
		{
			buffer.append("<Mask>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Mask>");
		}
	}
	// field OS
	{
		const char* s = src.getOS();
		if (s && *s)
		{
			buffer.append("<OS>");
			encodeUtf8XML(s,buffer);
			buffer.append("</OS>");
		}
	}
	// field DirectoryOnly
	{
		bool b = src.getDirectoryOnly();
		if (b)
			buffer.appendf("<DirectoryOnly>1</DirectoryOnly>");
	}
	if (keepRootTag)
		buffer.append("</FileListRequest>");
}

bool CFileListRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_Netaddr.unmarshall(rpc_request, "Netaddr", basepath);
	hasValue |= m_Path.unmarshall(rpc_request, "Path", basepath);
	hasValue |= m_Mask.unmarshall(rpc_request, "Mask", basepath);
	hasValue |= m_OS.unmarshall(rpc_request, "OS", basepath);
	hasValue |= m_DirectoryOnly.unmarshall(rpc_request, "DirectoryOnly", basepath);
	return hasValue;
}

bool CFileListRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Netaddr.unmarshall(ctx, soapval, "Netaddr");
	hasValue |= m_Path.unmarshall(ctx, soapval, "Path");
	hasValue |= m_Mask.unmarshall(ctx, soapval, "Mask");
	hasValue |= m_OS.unmarshall(ctx, soapval, "OS");
	hasValue |= m_DirectoryOnly.unmarshall(ctx, soapval, "DirectoryOnly");
	return hasValue;
}

bool CFileListRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Netaddr.unmarshall(ctx, params, attachments, "Netaddr", basepath);
	hasValue |= m_Path.unmarshall(ctx, params, attachments, "Path", basepath);
	hasValue |= m_Mask.unmarshall(ctx, params, attachments, "Mask", basepath);
	hasValue |= m_OS.unmarshall(ctx, params, attachments, "OS", basepath);
	hasValue |= m_DirectoryOnly.unmarshall(ctx, params, attachments, "DirectoryOnly", basepath);
	return hasValue;
}

const char * CFileListRequest::getNetaddr() { return m_Netaddr.query();}
const char * CFileListRequest::getPath() { return m_Path.query();}
const char * CFileListRequest::getMask() { return m_Mask.query();}
const char * CFileListRequest::getOS() { return m_OS.query();}
bool CFileListRequest::getDirectoryOnly() { return m_DirectoryOnly;}
void CFileListRequest::setNetaddr(const char * val){ m_Netaddr.set(val); }
void CFileListRequest::setPath(const char * val){ m_Path.set(val); }
void CFileListRequest::setMask(const char * val){ m_Mask.set(val); }
void CFileListRequest::setOS(const char * val){ m_OS.set(val); }
void CFileListRequest::setDirectoryOnly(bool val){ m_DirectoryOnly=val; }
extern "C"  IEspFileListRequest *createFileListRequest(const char *serv){return ((IEspFileListRequest *)new CFileListRequest(serv));}
extern "C"  IClientFileListRequest *createClientFileListRequest(const char *serv){return ((IClientFileListRequest *)new CFileListRequest(serv));}

//=======================================================
// class CPhysicalFileStruct Implementation
//=======================================================

CPhysicalFileStruct::CPhysicalFileStruct(const char *serviceName, IRpcMessageBinding *init)
	: m_name(nilIgnore),m_isDir(nilIgnore),m_filesize(nilIgnore),m_modifiedtime(nilIgnore),m_Path(nilIgnore),m_Files(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("PhysicalFileStruct");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CPhysicalFileStruct::CPhysicalFileStruct(const char *serviceName, const char *bc)
	: m_name(nilIgnore),m_isDir(nilIgnore),m_filesize(nilIgnore),m_modifiedtime(nilIgnore),m_Path(nilIgnore),m_Files(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("PhysicalFileStruct");
}

StringBuffer &CPhysicalFileStruct::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:complexType name=\"%s\">\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"name\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"isDir\" type=\"xsd:boolean\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"filesize\" type=\"xsd:long\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"modifiedtime\" type=\"xsd:string\"/>\n");
		if (!context.suppressed("PhysicalFileStruct","Path")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"Path\" type=\"xsd:string\"/>\n");
		}
		if (!context.suppressed("PhysicalFileStruct","Files")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"Files\" type=\"tns:ArrayOfPhysicalFileStruct\"/>\n");
		}
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType>\n");
		}
	}
	if (added.getValue("PhysicalFileStruct") && added.getValue("ArrayOfPhysicalFileStruct")==NULL) {
		schema.append("<xsd:complexType name=\"ArrayOfPhysicalFileStruct\">\n");
		schema.append("<xsd:sequence>\n");
		schema.append("<xsd:element minOccurs=\"0\" maxOccurs=\"unbounded\" name=\"PhysicalFileStruct\" type=\"tns:PhysicalFileStruct\"/>\n");
		schema.append("</xsd:sequence>\n");
		schema.append("</xsd:complexType>\n");
		added.setValue("ArrayOfPhysicalFileStruct",1);
	}
	return schema;
}

void CPhysicalFileStruct::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CPhysicalFileStruct::getMapInfo(IMapInfo& info, BoolHash& added)
{
	info.addMinVersion("PhysicalFileStruct","Path",1.13);
	info.addMinVersion("PhysicalFileStruct","Files",1.13);
}

StringBuffer &CPhysicalFileStruct::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("name");
	form.appendf("  <tr><td><b>name: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("isDir");
	
	form.appendf("  <tr><td><b>isDir? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("filesize");
	form.appendf("  <tr><td><b>filesize: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("modifiedtime");
	form.appendf("  <tr><td><b>modifiedtime: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (!context.suppressed("PhysicalFileStruct","Path")) {
		extfix.clear();
		if (prefix && *prefix)
			extfix.append(prefix).append(".");
		extfix.append("Path");
		form.appendf("  <tr><td><b>Path: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
		form.append("</td></tr>\n");
	}
	if (!context.suppressed("PhysicalFileStruct","Files")) {
		extfix.clear();
		if (prefix && *prefix)
			extfix.append(prefix).append(".");
		extfix.append("Files");
		form.appendf("<tr><td><b>Files: </b></td><td>");
		form.appendf("<table><tr><td><textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea></td>", extfix.str());
		form.append("</tr></table>");
		form.append("</td></tr>");
	}
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CPhysicalFileStruct::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CPhysicalFileStruct::serialize(IRpcMessage& rpc_resp)
{
	IEspContext* ctx = rpc_resp.queryContext();
	double clientVer= ctx ? ctx->getClientVersion() : -1; /* no context gets everything */
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_name.marshall(rpc_resp, "name", "", "", "");
	m_isDir.marshall(rpc_resp, "isDir", "", "", "");
	m_filesize.marshall(rpc_resp, "filesize", "", "", "");
	m_modifiedtime.marshall(rpc_resp, "modifiedtime", "", "", "");
	if ((clientVer==-1.0 || clientVer>=1.13))
		m_Path.marshall(rpc_resp, "Path", "", "", "");
	if ((clientVer==-1.0 || clientVer>=1.13))
		m_Files.marshall(rpc_resp, "Files", "PhysicalFileStruct");
}


void CPhysicalFileStruct::copy(CPhysicalFileStruct &from)
{
	m_name.copy(from.m_name);
	m_isDir.copy(from.m_isDir);
	m_filesize.copy(from.m_filesize);
	m_modifiedtime.copy(from.m_modifiedtime);
	m_Path.copy(from.m_Path);
	m_Files.copy(from.m_Files);
}


void CPhysicalFileStruct::copy(IConstPhysicalFileStruct &ifrom)
{
	setName(ifrom.getName());
	setIsDir(ifrom.getIsDir());
	setFilesize(ifrom.getFilesize());
	setModifiedtime(ifrom.getModifiedtime());
	setPath(ifrom.getPath());
	setFiles(ifrom.getFiles());
}


void CPhysicalFileStruct::getAttributes(IProperties &attributes)
{
}


void CPhysicalFileStruct::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	double clientVer = ctx ? ctx->getClientVersion() : -1;
	m_name.toStr(ctx, buffer, "name", "", true, "", "");
	m_isDir.toStr(ctx, buffer, "isDir", "", true, "", "");
	m_filesize.toStr(ctx, buffer, "filesize", "", true, "", "");
	m_modifiedtime.toStr(ctx, buffer, "modifiedtime", "", true, "", "");
	if ((clientVer==-1.0 || clientVer>=1.13))
		m_Path.toStr(ctx, buffer, "Path", "", true, "", "");
	if ((clientVer==-1.0 || clientVer>=1.13))
		m_Files.toStr(ctx, buffer, "Files", "PhysicalFileStruct");
}


void CPhysicalFileStruct::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CPhysicalFileStruct::serializer(IEspContext* ctx, IConstPhysicalFileStruct &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<PhysicalFileStruct>");
	double clientVer = ctx ? ctx->getClientVersion() : -1;
	// field name
	{
		const char* s = src.getName();
		if (s && *s)
		{
			buffer.append("<name>");
			encodeUtf8XML(s,buffer);
			buffer.append("</name>");
		}
	}
	// field isDir
	{
		bool b = src.getIsDir();
		if (b)
			buffer.appendf("<isDir>1</isDir>");
	}
	// field filesize
	{
		//*** default kind: TK_INT; type=int64, name=Filesize
		buffer.append("<filesize>");
		buffer.append(src.getFilesize());
		buffer.append("</filesize>");
	}
	// field modifiedtime
	{
		const char* s = src.getModifiedtime();
		if (s && *s)
		{
			buffer.append("<modifiedtime>");
			encodeUtf8XML(s,buffer);
			buffer.append("</modifiedtime>");
		}
	}
	// field Path
	if ((clientVer==-1.0 || clientVer>=1.13))
	{
		const char* s = src.getPath();
		if (s && *s)
		{
			buffer.append("<Path>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Path>");
		}
	}
	// field Files
	if ((clientVer==-1.0 || clientVer>=1.13))
	{
		IArrayOf<IConstPhysicalFileStruct>& v = src.getFiles();
		int size = v.length();
		if (size>0)
			buffer.append("<Files>");
		for (int i=0;i<size;i++)
		{
			buffer.append("<Item>");
			CPhysicalFileStruct::serializer(ctx,v.item(i),buffer,false);
			buffer.append("</Item>");
		}
		if (size>0)
			buffer.append("</Files>");
	}
	if (keepRootTag)
		buffer.append("</PhysicalFileStruct>");
}

bool CPhysicalFileStruct::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_name.unmarshall(rpc_request, "name", basepath);
	hasValue |= m_isDir.unmarshall(rpc_request, "isDir", basepath);
	hasValue |= m_filesize.unmarshall(rpc_request, "filesize", basepath);
	hasValue |= m_modifiedtime.unmarshall(rpc_request, "modifiedtime", basepath);
	hasValue |= m_Path.unmarshall(rpc_request, "Path", basepath);
	hasValue |= m_Files.unmarshall(rpc_request, "Files", basepath);
	return hasValue;
}

bool CPhysicalFileStruct::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_name.unmarshall(ctx, soapval, "name");
	hasValue |= m_isDir.unmarshall(ctx, soapval, "isDir");
	hasValue |= m_filesize.unmarshall(ctx, soapval, "filesize");
	hasValue |= m_modifiedtime.unmarshall(ctx, soapval, "modifiedtime");
	hasValue |= m_Path.unmarshall(ctx, soapval, "Path");
	hasValue |= m_Files.unmarshall(ctx, soapval, "Files");
	return hasValue;
}

bool CPhysicalFileStruct::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_name.unmarshall(ctx, params, attachments, "name", basepath);
	hasValue |= m_isDir.unmarshall(ctx, params, attachments, "isDir", basepath);
	hasValue |= m_filesize.unmarshall(ctx, params, attachments, "filesize", basepath);
	hasValue |= m_modifiedtime.unmarshall(ctx, params, attachments, "modifiedtime", basepath);
	hasValue |= m_Path.unmarshall(ctx, params, attachments, "Path", basepath);
	hasValue |= m_Files.unmarshall(ctx, params, attachments, "Files", basepath);
	return hasValue;
}

const char * CPhysicalFileStruct::getName() { return m_name.query();}
bool CPhysicalFileStruct::getIsDir() { return m_isDir;}
__int64 CPhysicalFileStruct::getFilesize() { return m_filesize;}
const char * CPhysicalFileStruct::getModifiedtime() { return m_modifiedtime.query();}
const char * CPhysicalFileStruct::getPath() { return m_Path.query();}
IArrayOf<IConstPhysicalFileStruct> & CPhysicalFileStruct::getFiles() { return (IArrayOf<IConstPhysicalFileStruct> &) m_Files; }
void CPhysicalFileStruct::setName(const char * val){ m_name.set(val); }
void CPhysicalFileStruct::setIsDir(bool val){ m_isDir=val; }
void CPhysicalFileStruct::setFilesize(__int64 val){ m_filesize=val; }
void CPhysicalFileStruct::setModifiedtime(const char * val){ m_modifiedtime.set(val); }
void CPhysicalFileStruct::setPath(const char * val){ m_Path.set(val); }
void CPhysicalFileStruct::setFiles(IArrayOf<IEspPhysicalFileStruct> &val)
{
	m_Files->kill();
	IArrayOf<IConstPhysicalFileStruct> &target = m_Files.getValue();
	ForEachItemIn(idx, val)
	{
		IEspPhysicalFileStruct &item = (val).item(idx);
		item.Link();
		target.append(item);
	}
}
void CPhysicalFileStruct::setFiles(IArrayOf<IConstPhysicalFileStruct> &val)
{
	m_Files->kill();
	IArrayOf<IConstPhysicalFileStruct> &target = m_Files.getValue();
	ForEachItemIn(idx, val)
	{
		IConstPhysicalFileStruct &item = val.item(idx);
		item.Link();
		target.append(item);
	}
}
extern "C"  IEspPhysicalFileStruct *createPhysicalFileStruct(const char *serv, const char *msgname){return ((IEspPhysicalFileStruct *)new CPhysicalFileStruct(serv /*, msgname*/));}
extern "C"  IClientPhysicalFileStruct *createClientPhysicalFileStruct(const char *serv, const char *msgname){return ((IClientPhysicalFileStruct *)new CPhysicalFileStruct(serv /*, msgname*/));}

//=======================================================
// class CFileListResponse Implementation
//=======================================================

CFileListResponse::CFileListResponse(const char *serviceName, IRpcMessageBinding *init)
	: m_Netaddr(nilIgnore),m_Path(nilIgnore),m_Mask(nilIgnore),m_OS(nilIgnore),m_DirectoryOnly(0, nilIgnore,false),m_AcceptLanguage(nilIgnore),m_files(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("FileListResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CFileListResponse::CFileListResponse(const char *serviceName, const char *bc)
	: m_Netaddr(nilIgnore),m_Path(nilIgnore),m_Mask(nilIgnore),m_OS(nilIgnore),m_DirectoryOnly(0, nilIgnore,false),m_AcceptLanguage(nilIgnore),m_files(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("FileListResponse");
}

CFileListResponse::CFileListResponse(const char *serviceName, IRpcMessage* rpcmsg)
	: m_Netaddr(nilIgnore),m_Path(nilIgnore),m_Mask(nilIgnore),m_OS(nilIgnore),m_DirectoryOnly(0, nilIgnore,false),m_AcceptLanguage(nilIgnore),m_files(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("FileListResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CFileListResponse::CFileListResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_Netaddr(nilIgnore),m_Path(nilIgnore),m_Mask(nilIgnore),m_OS(nilIgnore),m_DirectoryOnly(0, nilIgnore,false),m_AcceptLanguage(nilIgnore),m_files(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("FileListResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CFileListResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		schema.append("<xsd:element name=\"Exceptions\" type=\"tns:ArrayOfEspException\" minOccurs=\"0\" maxOccurs=\"1\"/>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Netaddr\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Path\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Mask\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"OS\" type=\"xsd:int\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" default=\"false\" name=\"DirectoryOnly\" type=\"xsd:boolean\"/>\n");
		if (!context.suppressed("FileListResponse","AcceptLanguage")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"AcceptLanguage\" type=\"xsd:string\"/>\n");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"files\" type=\"tns:ArrayOfPhysicalFileStruct\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	if (!(flags & 0x10)  || (flags & 0x100))
	{
		CPhysicalFileStruct::getXsdDefinition(context, request, schema, added);
	}
	if (added.getValue("PhysicalFileStruct") && added.getValue("ArrayOfPhysicalFileStruct")==NULL) {
		schema.append("<xsd:complexType name=\"ArrayOfPhysicalFileStruct\">\n");
		schema.append("<xsd:sequence>\n");
		schema.append("<xsd:element minOccurs=\"0\" maxOccurs=\"unbounded\" name=\"PhysicalFileStruct\" type=\"tns:PhysicalFileStruct\"/>\n");
		schema.append("</xsd:sequence>\n");
		schema.append("</xsd:complexType>\n");
		added.setValue("ArrayOfPhysicalFileStruct",1);
	}
	return schema;
}

void CFileListResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CFileListResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
	info.addMinVersion("FileListResponse","AcceptLanguage",1.1);
	if (!added.getValue("PhysicalFileStruct"))
	{
		added.setValue("PhysicalFileStruct",1);
		CPhysicalFileStruct::getMapInfo(info,added);
	}
}

StringBuffer &CFileListResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Netaddr");
	form.appendf("  <tr><td><b>Netaddr: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Path");
	form.appendf("  <tr><td><b>Path: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Mask");
	form.appendf("  <tr><td><b>Mask: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix) extfix.append(prefix).append(".");
		extfix.append("OS");
	form.appendf("  <tr><td><b>OS: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("DirectoryOnly");
	
	form.appendf("  <tr><td><b>DirectoryOnly? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	if (!context.suppressed("FileListResponse","AcceptLanguage")) {
		extfix.clear();
		if (prefix && *prefix)
			extfix.append(prefix).append(".");
		extfix.append("AcceptLanguage");
		form.appendf("  <tr><td><b>AcceptLanguage: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
		form.append("</td></tr>\n");
	}
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("files");
	form.appendf("<tr><td><b>files: </b></td><td>");
	form.appendf("<table><tr><td><textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea></td>", extfix.str());
	form.append("</tr></table>");
	form.append("</td></tr>");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CFileListResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CFileListResponse::serialize(IRpcMessage& rpc_resp)
{
	IEspContext* ctx = rpc_resp.queryContext();
	double clientVer= ctx ? ctx->getClientVersion() : -1; /* no context gets everything */
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
		m_Netaddr.marshall(rpc_resp, "Netaddr", "", "", "");
		m_Path.marshall(rpc_resp, "Path", "", "", "");
		m_Mask.marshall(rpc_resp, "Mask", "", "", "");
		m_OS.marshall(rpc_resp, "OS", "", "", "");
		m_DirectoryOnly.marshall(rpc_resp, "DirectoryOnly", "", "", "");
		if ((clientVer==-1.0 || clientVer>=1.1))
			m_AcceptLanguage.marshall(rpc_resp, "AcceptLanguage", "", "", "");
		m_files.marshall(rpc_resp, "files", "PhysicalFileStruct");
	}
}


void CFileListResponse::copy(CFileListResponse &from)
{
	m_Netaddr.copy(from.m_Netaddr);
	m_Path.copy(from.m_Path);
	m_Mask.copy(from.m_Mask);
	m_OS.copy(from.m_OS);
	m_DirectoryOnly.copy(from.m_DirectoryOnly);
	m_AcceptLanguage.copy(from.m_AcceptLanguage);
	m_files.copy(from.m_files);
}


void CFileListResponse::copy(IConstFileListResponse &ifrom)
{
	setNetaddr(ifrom.getNetaddr());
	setPath(ifrom.getPath());
	setMask(ifrom.getMask());
	setOS(ifrom.getOS());
	setDirectoryOnly(ifrom.getDirectoryOnly());
	setAcceptLanguage(ifrom.getAcceptLanguage());
	setFiles(ifrom.getFiles());
}


void CFileListResponse::getAttributes(IProperties &attributes)
{
}


void CFileListResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
		double clientVer = ctx ? ctx->getClientVersion() : -1;
		m_Netaddr.toStr(ctx, buffer, "Netaddr", "", true, "", "");
		m_Path.toStr(ctx, buffer, "Path", "", true, "", "");
		m_Mask.toStr(ctx, buffer, "Mask", "", true, "", "");
		m_OS.toStr(ctx, buffer, "OS", "", true, "", "");
		m_DirectoryOnly.toStr(ctx, buffer, "DirectoryOnly", "", true, "", "");
		if ((clientVer==-1.0 || clientVer>=1.1))
			m_AcceptLanguage.toStr(ctx, buffer, "AcceptLanguage", "", true, "", "");
		m_files.toStr(ctx, buffer, "files", "PhysicalFileStruct");
	}
}


void CFileListResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CFileListResponse::serializer(IEspContext* ctx, IConstFileListResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<FileListResponse>");
	double clientVer = ctx ? ctx->getClientVersion() : -1;
	// field Netaddr
	{
		const char* s = src.getNetaddr();
		if (s && *s)
		{
			buffer.append("<Netaddr>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Netaddr>");
		}
	}
	// field Path
	{
		const char* s = src.getPath();
		if (s && *s)
		{
			buffer.append("<Path>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Path>");
		}
	}
	// field Mask
	{
		const char* s = src.getMask();
		if (s && *s)
		{
			buffer.append("<Mask>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Mask>");
		}
	}
	// field OS
	{
		int n = src.getOS();
		if (n)
			buffer.appendf("<OS>%d</OS>", n);
	}
	// field DirectoryOnly
	{
		bool b = src.getDirectoryOnly();
		if (b)
			buffer.appendf("<DirectoryOnly>1</DirectoryOnly>");
	}
	// field AcceptLanguage
	if ((clientVer==-1.0 || clientVer>=1.1))
	{
		const char* s = src.getAcceptLanguage();
		if (s && *s)
		{
			buffer.append("<AcceptLanguage>");
			encodeUtf8XML(s,buffer);
			buffer.append("</AcceptLanguage>");
		}
	}
	// field files
	{
		IArrayOf<IConstPhysicalFileStruct>& v = src.getFiles();
		int size = v.length();
		if (size>0)
			buffer.append("<files>");
		for (int i=0;i<size;i++)
		{
			buffer.append("<Item>");
			CPhysicalFileStruct::serializer(ctx,v.item(i),buffer,false);
			buffer.append("</Item>");
		}
		if (size>0)
			buffer.append("</files>");
	}
	if (keepRootTag)
		buffer.append("</FileListResponse>");
}

bool CFileListResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
		hasValue |= m_Netaddr.unmarshall(rpc_request, "Netaddr", basepath);
		hasValue |= m_Path.unmarshall(rpc_request, "Path", basepath);
		hasValue |= m_Mask.unmarshall(rpc_request, "Mask", basepath);
		hasValue |= m_OS.unmarshall(rpc_request, "OS", basepath);
		hasValue |= m_DirectoryOnly.unmarshall(rpc_request, "DirectoryOnly", basepath);
		hasValue |= m_AcceptLanguage.unmarshall(rpc_request, "AcceptLanguage", basepath);
		hasValue |= m_files.unmarshall(rpc_request, "files", basepath);
	}
	return hasValue;
}

bool CFileListResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Netaddr.unmarshall(ctx, soapval, "Netaddr");
	hasValue |= m_Path.unmarshall(ctx, soapval, "Path");
	hasValue |= m_Mask.unmarshall(ctx, soapval, "Mask");
	hasValue |= m_OS.unmarshall(ctx, soapval, "OS");
	hasValue |= m_DirectoryOnly.unmarshall(ctx, soapval, "DirectoryOnly");
	hasValue |= m_AcceptLanguage.unmarshall(ctx, soapval, "AcceptLanguage");
	hasValue |= m_files.unmarshall(ctx, soapval, "files");
	return hasValue;
}

bool CFileListResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Netaddr.unmarshall(ctx, params, attachments, "Netaddr", basepath);
	hasValue |= m_Path.unmarshall(ctx, params, attachments, "Path", basepath);
	hasValue |= m_Mask.unmarshall(ctx, params, attachments, "Mask", basepath);
	hasValue |= m_OS.unmarshall(ctx, params, attachments, "OS", basepath);
	hasValue |= m_DirectoryOnly.unmarshall(ctx, params, attachments, "DirectoryOnly", basepath);
	hasValue |= m_AcceptLanguage.unmarshall(ctx, params, attachments, "AcceptLanguage", basepath);
	hasValue |= m_files.unmarshall(ctx, params, attachments, "files", basepath);
	return hasValue;
}

const char * CFileListResponse::getNetaddr() { return m_Netaddr.query();}
const char * CFileListResponse::getPath() { return m_Path.query();}
const char * CFileListResponse::getMask() { return m_Mask.query();}
int CFileListResponse::getOS() { return m_OS;}
bool CFileListResponse::getDirectoryOnly() { return m_DirectoryOnly;}
const char * CFileListResponse::getAcceptLanguage() { return m_AcceptLanguage.query();}
IArrayOf<IConstPhysicalFileStruct> & CFileListResponse::getFiles() { return (IArrayOf<IConstPhysicalFileStruct> &) m_files; }
void CFileListResponse::setNetaddr(const char * val){ m_Netaddr.set(val); }
void CFileListResponse::setPath(const char * val){ m_Path.set(val); }
void CFileListResponse::setMask(const char * val){ m_Mask.set(val); }
void CFileListResponse::setOS(int val){ m_OS=val; }
void CFileListResponse::setDirectoryOnly(bool val){ m_DirectoryOnly=val; }
void CFileListResponse::setAcceptLanguage(const char * val){ m_AcceptLanguage.set(val); }
void CFileListResponse::setFiles(IArrayOf<IEspPhysicalFileStruct> &val)
{
	m_files->kill();
	IArrayOf<IConstPhysicalFileStruct> &target = m_files.getValue();
	ForEachItemIn(idx, val)
	{
		IEspPhysicalFileStruct &item = (val).item(idx);
		item.Link();
		target.append(item);
	}
}
void CFileListResponse::setFiles(IArrayOf<IConstPhysicalFileStruct> &val)
{
	m_files->kill();
	IArrayOf<IConstPhysicalFileStruct> &target = m_files.getValue();
	ForEachItemIn(idx, val)
	{
		IConstPhysicalFileStruct &item = val.item(idx);
		item.Link();
		target.append(item);
	}
}
extern "C"  IEspFileListResponse *createFileListResponse(const char *serv){return ((IEspFileListResponse *)new CFileListResponse(serv));}
extern "C"  IClientFileListResponse *createClientFileListResponse(const char *serv){return ((IClientFileListResponse *)new CFileListResponse(serv));}

//=======================================================
// class CDropZoneFileSearchRequest Implementation
//=======================================================

CDropZoneFileSearchRequest::CDropZoneFileSearchRequest(const char *serviceName, IRpcMessageBinding *init)
	: m_DropZoneName(nilRemove),m_Server(nilRemove),m_ECLWatchVisibleOnly(0, nilRemove,false),m_NameFilter(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("DropZoneFileSearchRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CDropZoneFileSearchRequest::CDropZoneFileSearchRequest(const char *serviceName, const char *bc)
	: m_DropZoneName(nilRemove),m_Server(nilRemove),m_ECLWatchVisibleOnly(0, nilRemove,false),m_NameFilter(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("DropZoneFileSearchRequest");
}

CDropZoneFileSearchRequest::CDropZoneFileSearchRequest(const char *serviceName, IRpcMessage* rpcmsg)
	: m_DropZoneName(nilRemove),m_Server(nilRemove),m_ECLWatchVisibleOnly(0, nilRemove,false),m_NameFilter(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("DropZoneFileSearchRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CDropZoneFileSearchRequest::CDropZoneFileSearchRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_DropZoneName(nilRemove),m_Server(nilRemove),m_ECLWatchVisibleOnly(0, nilRemove,false),m_NameFilter(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("DropZoneFileSearchRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CDropZoneFileSearchRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"DropZoneName\" type=\"xsd:string\"/>\n");
		if (!context.suppressed("DropZoneFileSearchRequest","Server")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"Server\" type=\"xsd:string\"/>\n");
		}
		if (!context.suppressed("DropZoneFileSearchRequest","ECLWatchVisibleOnly")) {
			schema.append("<xsd:element minOccurs=\"0\" default=\"false\" name=\"ECLWatchVisibleOnly\" type=\"xsd:boolean\"/>\n");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"NameFilter\" type=\"xsd:string\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CDropZoneFileSearchRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CDropZoneFileSearchRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
	info.addMinVersion("DropZoneFileSearchRequest","Server",1.15);
	info.addMinVersion("DropZoneFileSearchRequest","ECLWatchVisibleOnly",1.15);
}

StringBuffer &CDropZoneFileSearchRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("DropZoneName");
	form.appendf("  <tr><td><b>DropZoneName: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (!context.suppressed("DropZoneFileSearchRequest","Server")) {
		extfix.clear();
		if (prefix && *prefix)
			extfix.append(prefix).append(".");
		extfix.append("Server");
		form.appendf("  <tr><td><b>Server: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
		form.append("</td></tr>\n");
	}
	if (!context.suppressed("DropZoneFileSearchRequest","ECLWatchVisibleOnly")) {
		extfix.clear();
		if (prefix && *prefix)
			extfix.append(prefix).append(".");
		extfix.append("ECLWatchVisibleOnly");
		
	form.appendf("  <tr><td><b>ECLWatchVisibleOnly? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	}
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("NameFilter");
	form.appendf("  <tr><td><b>NameFilter: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CDropZoneFileSearchRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CDropZoneFileSearchRequest::serialize(IRpcMessage& rpc_resp)
{
	IEspContext* ctx = rpc_resp.queryContext();
	double clientVer= ctx ? ctx->getClientVersion() : -1; /* no context gets everything */
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_DropZoneName.marshall(rpc_resp, "DropZoneName", "", "", "");
	if ((clientVer==-1.0 || clientVer>=1.15))
		m_Server.marshall(rpc_resp, "Server", "", "", "");
	if ((clientVer==-1.0 || clientVer>=1.15))
		m_ECLWatchVisibleOnly.marshall(rpc_resp, "ECLWatchVisibleOnly", "", "", "");
	m_NameFilter.marshall(rpc_resp, "NameFilter", "", "", "");
}


void CDropZoneFileSearchRequest::copy(CDropZoneFileSearchRequest &from)
{
	m_DropZoneName.copy(from.m_DropZoneName);
	m_Server.copy(from.m_Server);
	m_ECLWatchVisibleOnly.copy(from.m_ECLWatchVisibleOnly);
	m_NameFilter.copy(from.m_NameFilter);
}


void CDropZoneFileSearchRequest::copy(IConstDropZoneFileSearchRequest &ifrom)
{
	setDropZoneName(ifrom.getDropZoneName());
	setServer(ifrom.getServer());
	setECLWatchVisibleOnly(ifrom.getECLWatchVisibleOnly());
	setNameFilter(ifrom.getNameFilter());
}


void CDropZoneFileSearchRequest::getAttributes(IProperties &attributes)
{
}


void CDropZoneFileSearchRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	double clientVer = ctx ? ctx->getClientVersion() : -1;
	m_DropZoneName.toStr(ctx, buffer, "DropZoneName", "", true, "", "");
	if ((clientVer==-1.0 || clientVer>=1.15))
		m_Server.toStr(ctx, buffer, "Server", "", true, "", "");
	if ((clientVer==-1.0 || clientVer>=1.15))
		m_ECLWatchVisibleOnly.toStr(ctx, buffer, "ECLWatchVisibleOnly", "", true, "", "");
	m_NameFilter.toStr(ctx, buffer, "NameFilter", "", true, "", "");
}


void CDropZoneFileSearchRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CDropZoneFileSearchRequest::serializer(IEspContext* ctx, IConstDropZoneFileSearchRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<DropZoneFileSearchRequest>");
	double clientVer = ctx ? ctx->getClientVersion() : -1;
	// field DropZoneName
	{
		const char* s = src.getDropZoneName();
		if (s && *s)
		{
			buffer.append("<DropZoneName>");
			encodeUtf8XML(s,buffer);
			buffer.append("</DropZoneName>");
		}
	}
	// field Server
	if ((clientVer==-1.0 || clientVer>=1.15))
	{
		const char* s = src.getServer();
		if (s && *s)
		{
			buffer.append("<Server>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Server>");
		}
	}
	// field ECLWatchVisibleOnly
	if ((clientVer==-1.0 || clientVer>=1.15))
	{
		bool b = src.getECLWatchVisibleOnly();
		if (b)
			buffer.appendf("<ECLWatchVisibleOnly>1</ECLWatchVisibleOnly>");
	}
	// field NameFilter
	{
		const char* s = src.getNameFilter();
		if (s && *s)
		{
			buffer.append("<NameFilter>");
			encodeUtf8XML(s,buffer);
			buffer.append("</NameFilter>");
		}
	}
	if (keepRootTag)
		buffer.append("</DropZoneFileSearchRequest>");
}

bool CDropZoneFileSearchRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_DropZoneName.unmarshall(rpc_request, "DropZoneName", basepath);
	hasValue |= m_Server.unmarshall(rpc_request, "Server", basepath);
	hasValue |= m_ECLWatchVisibleOnly.unmarshall(rpc_request, "ECLWatchVisibleOnly", basepath);
	hasValue |= m_NameFilter.unmarshall(rpc_request, "NameFilter", basepath);
	return hasValue;
}

bool CDropZoneFileSearchRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_DropZoneName.unmarshall(ctx, soapval, "DropZoneName");
	hasValue |= m_Server.unmarshall(ctx, soapval, "Server");
	hasValue |= m_ECLWatchVisibleOnly.unmarshall(ctx, soapval, "ECLWatchVisibleOnly");
	hasValue |= m_NameFilter.unmarshall(ctx, soapval, "NameFilter");
	return hasValue;
}

bool CDropZoneFileSearchRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_DropZoneName.unmarshall(ctx, params, attachments, "DropZoneName", basepath);
	hasValue |= m_Server.unmarshall(ctx, params, attachments, "Server", basepath);
	hasValue |= m_ECLWatchVisibleOnly.unmarshall(ctx, params, attachments, "ECLWatchVisibleOnly", basepath);
	hasValue |= m_NameFilter.unmarshall(ctx, params, attachments, "NameFilter", basepath);
	return hasValue;
}

const char * CDropZoneFileSearchRequest::getDropZoneName() { return m_DropZoneName.query();}
const char * CDropZoneFileSearchRequest::getServer() { return m_Server.query();}
bool CDropZoneFileSearchRequest::getECLWatchVisibleOnly_isNull(){return m_ECLWatchVisibleOnly.is_nil();}
bool CDropZoneFileSearchRequest::getECLWatchVisibleOnly() { return m_ECLWatchVisibleOnly;}
const char * CDropZoneFileSearchRequest::getNameFilter() { return m_NameFilter.query();}
void CDropZoneFileSearchRequest::setDropZoneName(const char * val){ m_DropZoneName.set(val); }
void CDropZoneFileSearchRequest::setServer(const char * val){ m_Server.set(val); }
void CDropZoneFileSearchRequest::setECLWatchVisibleOnly_null(){ m_ECLWatchVisibleOnly.Nil(); }void CDropZoneFileSearchRequest::setECLWatchVisibleOnly(bool val){ m_ECLWatchVisibleOnly=val; }
void CDropZoneFileSearchRequest::setNameFilter(const char * val){ m_NameFilter.set(val); }
extern "C"  IEspDropZoneFileSearchRequest *createDropZoneFileSearchRequest(const char *serv){return ((IEspDropZoneFileSearchRequest *)new CDropZoneFileSearchRequest(serv));}
extern "C"  IClientDropZoneFileSearchRequest *createClientDropZoneFileSearchRequest(const char *serv){return ((IClientDropZoneFileSearchRequest *)new CDropZoneFileSearchRequest(serv));}

//=======================================================
// class CDropZoneFileSearchResponse Implementation
//=======================================================

CDropZoneFileSearchResponse::CDropZoneFileSearchResponse(const char *serviceName, IRpcMessageBinding *init)
	: m_Files(nilIgnore),m_Warning(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("DropZoneFileSearchResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CDropZoneFileSearchResponse::CDropZoneFileSearchResponse(const char *serviceName, const char *bc)
	: m_Files(nilIgnore),m_Warning(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("DropZoneFileSearchResponse");
}

CDropZoneFileSearchResponse::CDropZoneFileSearchResponse(const char *serviceName, IRpcMessage* rpcmsg)
	: m_Files(nilIgnore),m_Warning(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("DropZoneFileSearchResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CDropZoneFileSearchResponse::CDropZoneFileSearchResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_Files(nilIgnore),m_Warning(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("DropZoneFileSearchResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CDropZoneFileSearchResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		schema.append("<xsd:element name=\"Exceptions\" type=\"tns:ArrayOfEspException\" minOccurs=\"0\" maxOccurs=\"1\"/>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Files\" type=\"tns:ArrayOfPhysicalFileStruct\"/>\n");
		if (!context.suppressed("DropZoneFileSearchResponse","Warning")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"Warning\" type=\"xsd:string\"/>\n");
		}
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	if (!(flags & 0x10)  || (flags & 0x100))
	{
		CPhysicalFileStruct::getXsdDefinition(context, request, schema, added);
	}
	if (added.getValue("PhysicalFileStruct") && added.getValue("ArrayOfPhysicalFileStruct")==NULL) {
		schema.append("<xsd:complexType name=\"ArrayOfPhysicalFileStruct\">\n");
		schema.append("<xsd:sequence>\n");
		schema.append("<xsd:element minOccurs=\"0\" maxOccurs=\"unbounded\" name=\"PhysicalFileStruct\" type=\"tns:PhysicalFileStruct\"/>\n");
		schema.append("</xsd:sequence>\n");
		schema.append("</xsd:complexType>\n");
		added.setValue("ArrayOfPhysicalFileStruct",1);
	}
	return schema;
}

void CDropZoneFileSearchResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CDropZoneFileSearchResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
	info.addMinVersion("DropZoneFileSearchResponse","Warning",1.16);
	if (!added.getValue("PhysicalFileStruct"))
	{
		added.setValue("PhysicalFileStruct",1);
		CPhysicalFileStruct::getMapInfo(info,added);
	}
}

StringBuffer &CDropZoneFileSearchResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Files");
	form.appendf("<tr><td><b>Files: </b></td><td>");
	form.appendf("<table><tr><td><textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea></td>", extfix.str());
	form.append("</tr></table>");
	form.append("</td></tr>");
	if (!context.suppressed("DropZoneFileSearchResponse","Warning")) {
		extfix.clear();
		if (prefix && *prefix)
			extfix.append(prefix).append(".");
		extfix.append("Warning");
		form.appendf("  <tr><td><b>Warning: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
		form.append("</td></tr>\n");
	}
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CDropZoneFileSearchResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CDropZoneFileSearchResponse::serialize(IRpcMessage& rpc_resp)
{
	IEspContext* ctx = rpc_resp.queryContext();
	double clientVer= ctx ? ctx->getClientVersion() : -1; /* no context gets everything */
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
		m_Files.marshall(rpc_resp, "Files", "PhysicalFileStruct");
		if ((clientVer==-1.0 || clientVer>=1.16))
			m_Warning.marshall(rpc_resp, "Warning", "", "", "");
	}
}


void CDropZoneFileSearchResponse::copy(CDropZoneFileSearchResponse &from)
{
	m_Files.copy(from.m_Files);
	m_Warning.copy(from.m_Warning);
}


void CDropZoneFileSearchResponse::copy(IConstDropZoneFileSearchResponse &ifrom)
{
	setFiles(ifrom.getFiles());
	setWarning(ifrom.getWarning());
}


void CDropZoneFileSearchResponse::getAttributes(IProperties &attributes)
{
}


void CDropZoneFileSearchResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
		double clientVer = ctx ? ctx->getClientVersion() : -1;
		m_Files.toStr(ctx, buffer, "Files", "PhysicalFileStruct");
		if ((clientVer==-1.0 || clientVer>=1.16))
			m_Warning.toStr(ctx, buffer, "Warning", "", true, "", "");
	}
}


void CDropZoneFileSearchResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CDropZoneFileSearchResponse::serializer(IEspContext* ctx, IConstDropZoneFileSearchResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<DropZoneFileSearchResponse>");
	double clientVer = ctx ? ctx->getClientVersion() : -1;
	// field Files
	{
		IArrayOf<IConstPhysicalFileStruct>& v = src.getFiles();
		int size = v.length();
		if (size>0)
			buffer.append("<Files>");
		for (int i=0;i<size;i++)
		{
			buffer.append("<Item>");
			CPhysicalFileStruct::serializer(ctx,v.item(i),buffer,false);
			buffer.append("</Item>");
		}
		if (size>0)
			buffer.append("</Files>");
	}
	// field Warning
	if ((clientVer==-1.0 || clientVer>=1.16))
	{
		const char* s = src.getWarning();
		if (s && *s)
		{
			buffer.append("<Warning>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Warning>");
		}
	}
	if (keepRootTag)
		buffer.append("</DropZoneFileSearchResponse>");
}

bool CDropZoneFileSearchResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
		hasValue |= m_Files.unmarshall(rpc_request, "Files", basepath);
		hasValue |= m_Warning.unmarshall(rpc_request, "Warning", basepath);
	}
	return hasValue;
}

bool CDropZoneFileSearchResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Files.unmarshall(ctx, soapval, "Files");
	hasValue |= m_Warning.unmarshall(ctx, soapval, "Warning");
	return hasValue;
}

bool CDropZoneFileSearchResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Files.unmarshall(ctx, params, attachments, "Files", basepath);
	hasValue |= m_Warning.unmarshall(ctx, params, attachments, "Warning", basepath);
	return hasValue;
}

IArrayOf<IConstPhysicalFileStruct> & CDropZoneFileSearchResponse::getFiles() { return (IArrayOf<IConstPhysicalFileStruct> &) m_Files; }
const char * CDropZoneFileSearchResponse::getWarning() { return m_Warning.query();}
void CDropZoneFileSearchResponse::setFiles(IArrayOf<IEspPhysicalFileStruct> &val)
{
	m_Files->kill();
	IArrayOf<IConstPhysicalFileStruct> &target = m_Files.getValue();
	ForEachItemIn(idx, val)
	{
		IEspPhysicalFileStruct &item = (val).item(idx);
		item.Link();
		target.append(item);
	}
}
void CDropZoneFileSearchResponse::setFiles(IArrayOf<IConstPhysicalFileStruct> &val)
{
	m_Files->kill();
	IArrayOf<IConstPhysicalFileStruct> &target = m_Files.getValue();
	ForEachItemIn(idx, val)
	{
		IConstPhysicalFileStruct &item = val.item(idx);
		item.Link();
		target.append(item);
	}
}
void CDropZoneFileSearchResponse::setWarning(const char * val){ m_Warning.set(val); }
extern "C"  IEspDropZoneFileSearchResponse *createDropZoneFileSearchResponse(const char *serv){return ((IEspDropZoneFileSearchResponse *)new CDropZoneFileSearchResponse(serv));}
extern "C"  IClientDropZoneFileSearchResponse *createClientDropZoneFileSearchResponse(const char *serv){return ((IClientDropZoneFileSearchResponse *)new CDropZoneFileSearchResponse(serv));}

//=======================================================
// class COpenSaveRequest Implementation
//=======================================================

COpenSaveRequest::COpenSaveRequest(const char *serviceName, IRpcMessageBinding *init)
	: m_Location(nilIgnore),m_Path(nilIgnore),m_Name(nilIgnore),m_Type(nilIgnore),m_DateTime(nilIgnore),m_BinaryFile(0, nilIgnore,false)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("OpenSaveRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

COpenSaveRequest::COpenSaveRequest(const char *serviceName, const char *bc)
	: m_Location(nilIgnore),m_Path(nilIgnore),m_Name(nilIgnore),m_Type(nilIgnore),m_DateTime(nilIgnore),m_BinaryFile(0, nilIgnore,false)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("OpenSaveRequest");
}

COpenSaveRequest::COpenSaveRequest(const char *serviceName, IRpcMessage* rpcmsg)
	: m_Location(nilIgnore),m_Path(nilIgnore),m_Name(nilIgnore),m_Type(nilIgnore),m_DateTime(nilIgnore),m_BinaryFile(0, nilIgnore,false)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("OpenSaveRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

COpenSaveRequest::COpenSaveRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_Location(nilIgnore),m_Path(nilIgnore),m_Name(nilIgnore),m_Type(nilIgnore),m_DateTime(nilIgnore),m_BinaryFile(0, nilIgnore,false)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("OpenSaveRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &COpenSaveRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Location\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Path\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Name\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Type\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"DateTime\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" default=\"false\" name=\"BinaryFile\" type=\"xsd:boolean\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void COpenSaveRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void COpenSaveRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &COpenSaveRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Location");
	form.appendf("  <tr><td><b>Location: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Path");
	form.appendf("  <tr><td><b>Path: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Name");
	form.appendf("  <tr><td><b>Name: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Type");
	form.appendf("  <tr><td><b>Type: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("DateTime");
	form.appendf("  <tr><td><b>DateTime: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("BinaryFile");
	
	form.appendf("  <tr><td><b>BinaryFile? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &COpenSaveRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void COpenSaveRequest::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_Location.marshall(rpc_resp, "Location", "", "", "");
	m_Path.marshall(rpc_resp, "Path", "", "", "");
	m_Name.marshall(rpc_resp, "Name", "", "", "");
	m_Type.marshall(rpc_resp, "Type", "", "", "");
	m_DateTime.marshall(rpc_resp, "DateTime", "", "", "");
	m_BinaryFile.marshall(rpc_resp, "BinaryFile", "", "", "");
}


void COpenSaveRequest::copy(COpenSaveRequest &from)
{
	m_Location.copy(from.m_Location);
	m_Path.copy(from.m_Path);
	m_Name.copy(from.m_Name);
	m_Type.copy(from.m_Type);
	m_DateTime.copy(from.m_DateTime);
	m_BinaryFile.copy(from.m_BinaryFile);
}


void COpenSaveRequest::copy(IConstOpenSaveRequest &ifrom)
{
	setLocation(ifrom.getLocation());
	setPath(ifrom.getPath());
	setName(ifrom.getName());
	setType(ifrom.getType());
	setDateTime(ifrom.getDateTime());
	setBinaryFile(ifrom.getBinaryFile());
}


void COpenSaveRequest::getAttributes(IProperties &attributes)
{
}


void COpenSaveRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_Location.toStr(ctx, buffer, "Location", "", true, "", "");
	m_Path.toStr(ctx, buffer, "Path", "", true, "", "");
	m_Name.toStr(ctx, buffer, "Name", "", true, "", "");
	m_Type.toStr(ctx, buffer, "Type", "", true, "", "");
	m_DateTime.toStr(ctx, buffer, "DateTime", "", true, "", "");
	m_BinaryFile.toStr(ctx, buffer, "BinaryFile", "", true, "", "");
}


void COpenSaveRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void COpenSaveRequest::serializer(IEspContext* ctx, IConstOpenSaveRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<OpenSaveRequest>");
	// field Location
	{
		const char* s = src.getLocation();
		if (s && *s)
		{
			buffer.append("<Location>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Location>");
		}
	}
	// field Path
	{
		const char* s = src.getPath();
		if (s && *s)
		{
			buffer.append("<Path>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Path>");
		}
	}
	// field Name
	{
		const char* s = src.getName();
		if (s && *s)
		{
			buffer.append("<Name>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Name>");
		}
	}
	// field Type
	{
		const char* s = src.getType();
		if (s && *s)
		{
			buffer.append("<Type>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Type>");
		}
	}
	// field DateTime
	{
		const char* s = src.getDateTime();
		if (s && *s)
		{
			buffer.append("<DateTime>");
			encodeUtf8XML(s,buffer);
			buffer.append("</DateTime>");
		}
	}
	// field BinaryFile
	{
		bool b = src.getBinaryFile();
		if (b)
			buffer.appendf("<BinaryFile>1</BinaryFile>");
	}
	if (keepRootTag)
		buffer.append("</OpenSaveRequest>");
}

bool COpenSaveRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_Location.unmarshall(rpc_request, "Location", basepath);
	hasValue |= m_Path.unmarshall(rpc_request, "Path", basepath);
	hasValue |= m_Name.unmarshall(rpc_request, "Name", basepath);
	hasValue |= m_Type.unmarshall(rpc_request, "Type", basepath);
	hasValue |= m_DateTime.unmarshall(rpc_request, "DateTime", basepath);
	hasValue |= m_BinaryFile.unmarshall(rpc_request, "BinaryFile", basepath);
	return hasValue;
}

bool COpenSaveRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Location.unmarshall(ctx, soapval, "Location");
	hasValue |= m_Path.unmarshall(ctx, soapval, "Path");
	hasValue |= m_Name.unmarshall(ctx, soapval, "Name");
	hasValue |= m_Type.unmarshall(ctx, soapval, "Type");
	hasValue |= m_DateTime.unmarshall(ctx, soapval, "DateTime");
	hasValue |= m_BinaryFile.unmarshall(ctx, soapval, "BinaryFile");
	return hasValue;
}

bool COpenSaveRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Location.unmarshall(ctx, params, attachments, "Location", basepath);
	hasValue |= m_Path.unmarshall(ctx, params, attachments, "Path", basepath);
	hasValue |= m_Name.unmarshall(ctx, params, attachments, "Name", basepath);
	hasValue |= m_Type.unmarshall(ctx, params, attachments, "Type", basepath);
	hasValue |= m_DateTime.unmarshall(ctx, params, attachments, "DateTime", basepath);
	hasValue |= m_BinaryFile.unmarshall(ctx, params, attachments, "BinaryFile", basepath);
	return hasValue;
}

const char * COpenSaveRequest::getLocation() { return m_Location.query();}
const char * COpenSaveRequest::getPath() { return m_Path.query();}
const char * COpenSaveRequest::getName() { return m_Name.query();}
const char * COpenSaveRequest::getType() { return m_Type.query();}
const char * COpenSaveRequest::getDateTime() { return m_DateTime.query();}
bool COpenSaveRequest::getBinaryFile() { return m_BinaryFile;}
void COpenSaveRequest::setLocation(const char * val){ m_Location.set(val); }
void COpenSaveRequest::setPath(const char * val){ m_Path.set(val); }
void COpenSaveRequest::setName(const char * val){ m_Name.set(val); }
void COpenSaveRequest::setType(const char * val){ m_Type.set(val); }
void COpenSaveRequest::setDateTime(const char * val){ m_DateTime.set(val); }
void COpenSaveRequest::setBinaryFile(bool val){ m_BinaryFile=val; }
extern "C"  IEspOpenSaveRequest *createOpenSaveRequest(const char *serv){return ((IEspOpenSaveRequest *)new COpenSaveRequest(serv));}
extern "C"  IClientOpenSaveRequest *createClientOpenSaveRequest(const char *serv){return ((IClientOpenSaveRequest *)new COpenSaveRequest(serv));}

//=======================================================
// class COpenSaveResponse Implementation
//=======================================================

COpenSaveResponse::COpenSaveResponse(const char *serviceName, IRpcMessageBinding *init)
	: m_Location(nilIgnore),m_Path(nilIgnore),m_Name(nilIgnore),m_Type(nilIgnore),m_DateTime(nilIgnore),m_Viewable(1, nilIgnore,false)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("OpenSaveResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

COpenSaveResponse::COpenSaveResponse(const char *serviceName, const char *bc)
	: m_Location(nilIgnore),m_Path(nilIgnore),m_Name(nilIgnore),m_Type(nilIgnore),m_DateTime(nilIgnore),m_Viewable(1, nilIgnore,false)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("OpenSaveResponse");
}

COpenSaveResponse::COpenSaveResponse(const char *serviceName, IRpcMessage* rpcmsg)
	: m_Location(nilIgnore),m_Path(nilIgnore),m_Name(nilIgnore),m_Type(nilIgnore),m_DateTime(nilIgnore),m_Viewable(1, nilIgnore,false)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("OpenSaveResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

COpenSaveResponse::COpenSaveResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_Location(nilIgnore),m_Path(nilIgnore),m_Name(nilIgnore),m_Type(nilIgnore),m_DateTime(nilIgnore),m_Viewable(1, nilIgnore,false)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("OpenSaveResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &COpenSaveResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		schema.append("<xsd:element name=\"Exceptions\" type=\"tns:ArrayOfEspException\" minOccurs=\"0\" maxOccurs=\"1\"/>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Location\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Path\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Name\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Type\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"DateTime\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" default=\"true\" name=\"Viewable\" type=\"xsd:boolean\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void COpenSaveResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void COpenSaveResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &COpenSaveResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Location");
	form.appendf("  <tr><td><b>Location: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Path");
	form.appendf("  <tr><td><b>Path: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Name");
	form.appendf("  <tr><td><b>Name: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Type");
	form.appendf("  <tr><td><b>Type: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("DateTime");
	form.appendf("  <tr><td><b>DateTime: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Viewable");
	
	form.appendf("  <tr><td><b>Viewable? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\" checked=\"1\" /></td></tr>\n", extfix.str());
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &COpenSaveResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void COpenSaveResponse::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
		m_Location.marshall(rpc_resp, "Location", "", "", "");
		m_Path.marshall(rpc_resp, "Path", "", "", "");
		m_Name.marshall(rpc_resp, "Name", "", "", "");
		m_Type.marshall(rpc_resp, "Type", "", "", "");
		m_DateTime.marshall(rpc_resp, "DateTime", "", "", "");
		m_Viewable.marshall(rpc_resp, "Viewable", "", "", "");
	}
}


void COpenSaveResponse::copy(COpenSaveResponse &from)
{
	m_Location.copy(from.m_Location);
	m_Path.copy(from.m_Path);
	m_Name.copy(from.m_Name);
	m_Type.copy(from.m_Type);
	m_DateTime.copy(from.m_DateTime);
	m_Viewable.copy(from.m_Viewable);
}


void COpenSaveResponse::copy(IConstOpenSaveResponse &ifrom)
{
	setLocation(ifrom.getLocation());
	setPath(ifrom.getPath());
	setName(ifrom.getName());
	setType(ifrom.getType());
	setDateTime(ifrom.getDateTime());
	setViewable(ifrom.getViewable());
}


void COpenSaveResponse::getAttributes(IProperties &attributes)
{
}


void COpenSaveResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
		m_Location.toStr(ctx, buffer, "Location", "", true, "", "");
		m_Path.toStr(ctx, buffer, "Path", "", true, "", "");
		m_Name.toStr(ctx, buffer, "Name", "", true, "", "");
		m_Type.toStr(ctx, buffer, "Type", "", true, "", "");
		m_DateTime.toStr(ctx, buffer, "DateTime", "", true, "", "");
		m_Viewable.toStr(ctx, buffer, "Viewable", "", true, "", "");
	}
}


void COpenSaveResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void COpenSaveResponse::serializer(IEspContext* ctx, IConstOpenSaveResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<OpenSaveResponse>");
	// field Location
	{
		const char* s = src.getLocation();
		if (s && *s)
		{
			buffer.append("<Location>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Location>");
		}
	}
	// field Path
	{
		const char* s = src.getPath();
		if (s && *s)
		{
			buffer.append("<Path>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Path>");
		}
	}
	// field Name
	{
		const char* s = src.getName();
		if (s && *s)
		{
			buffer.append("<Name>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Name>");
		}
	}
	// field Type
	{
		const char* s = src.getType();
		if (s && *s)
		{
			buffer.append("<Type>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Type>");
		}
	}
	// field DateTime
	{
		const char* s = src.getDateTime();
		if (s && *s)
		{
			buffer.append("<DateTime>");
			encodeUtf8XML(s,buffer);
			buffer.append("</DateTime>");
		}
	}
	// field Viewable
	{
		bool b = src.getViewable();
		if (b)
			buffer.appendf("<Viewable>1</Viewable>");
	}
	if (keepRootTag)
		buffer.append("</OpenSaveResponse>");
}

bool COpenSaveResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
		hasValue |= m_Location.unmarshall(rpc_request, "Location", basepath);
		hasValue |= m_Path.unmarshall(rpc_request, "Path", basepath);
		hasValue |= m_Name.unmarshall(rpc_request, "Name", basepath);
		hasValue |= m_Type.unmarshall(rpc_request, "Type", basepath);
		hasValue |= m_DateTime.unmarshall(rpc_request, "DateTime", basepath);
		hasValue |= m_Viewable.unmarshall(rpc_request, "Viewable", basepath);
	}
	return hasValue;
}

bool COpenSaveResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Location.unmarshall(ctx, soapval, "Location");
	hasValue |= m_Path.unmarshall(ctx, soapval, "Path");
	hasValue |= m_Name.unmarshall(ctx, soapval, "Name");
	hasValue |= m_Type.unmarshall(ctx, soapval, "Type");
	hasValue |= m_DateTime.unmarshall(ctx, soapval, "DateTime");
	hasValue |= m_Viewable.unmarshall(ctx, soapval, "Viewable");
	return hasValue;
}

bool COpenSaveResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Location.unmarshall(ctx, params, attachments, "Location", basepath);
	hasValue |= m_Path.unmarshall(ctx, params, attachments, "Path", basepath);
	hasValue |= m_Name.unmarshall(ctx, params, attachments, "Name", basepath);
	hasValue |= m_Type.unmarshall(ctx, params, attachments, "Type", basepath);
	hasValue |= m_DateTime.unmarshall(ctx, params, attachments, "DateTime", basepath);
	hasValue |= m_Viewable.unmarshall(ctx, params, attachments, "Viewable", basepath);
	return hasValue;
}

const char * COpenSaveResponse::getLocation() { return m_Location.query();}
const char * COpenSaveResponse::getPath() { return m_Path.query();}
const char * COpenSaveResponse::getName() { return m_Name.query();}
const char * COpenSaveResponse::getType() { return m_Type.query();}
const char * COpenSaveResponse::getDateTime() { return m_DateTime.query();}
bool COpenSaveResponse::getViewable() { return m_Viewable;}
void COpenSaveResponse::setLocation(const char * val){ m_Location.set(val); }
void COpenSaveResponse::setPath(const char * val){ m_Path.set(val); }
void COpenSaveResponse::setName(const char * val){ m_Name.set(val); }
void COpenSaveResponse::setType(const char * val){ m_Type.set(val); }
void COpenSaveResponse::setDateTime(const char * val){ m_DateTime.set(val); }
void COpenSaveResponse::setViewable(bool val){ m_Viewable=val; }
extern "C"  IEspOpenSaveResponse *createOpenSaveResponse(const char *serv){return ((IEspOpenSaveResponse *)new COpenSaveResponse(serv));}
extern "C"  IClientOpenSaveResponse *createClientOpenSaveResponse(const char *serv){return ((IClientOpenSaveResponse *)new COpenSaveResponse(serv));}

//=======================================================
// class CDfuMonitorRequest Implementation
//=======================================================

CDfuMonitorRequest::CDfuMonitorRequest(const char *serviceName, IRpcMessageBinding *init)
	: m_EventName(nilIgnore),m_LogicalName(nilIgnore),m_Ip(nilIgnore),m_Filename(nilIgnore),m_Sub(nilIgnore),m_ShotLimit(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("DfuMonitorRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CDfuMonitorRequest::CDfuMonitorRequest(const char *serviceName, const char *bc)
	: m_EventName(nilIgnore),m_LogicalName(nilIgnore),m_Ip(nilIgnore),m_Filename(nilIgnore),m_Sub(nilIgnore),m_ShotLimit(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("DfuMonitorRequest");
}

CDfuMonitorRequest::CDfuMonitorRequest(const char *serviceName, IRpcMessage* rpcmsg)
	: m_EventName(nilIgnore),m_LogicalName(nilIgnore),m_Ip(nilIgnore),m_Filename(nilIgnore),m_Sub(nilIgnore),m_ShotLimit(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("DfuMonitorRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CDfuMonitorRequest::CDfuMonitorRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_EventName(nilIgnore),m_LogicalName(nilIgnore),m_Ip(nilIgnore),m_Filename(nilIgnore),m_Sub(nilIgnore),m_ShotLimit(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("DfuMonitorRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CDfuMonitorRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"EventName\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"LogicalName\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Ip\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Filename\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Sub\" type=\"xsd:boolean\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"ShotLimit\" type=\"xsd:int\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CDfuMonitorRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CDfuMonitorRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CDfuMonitorRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("EventName");
	form.appendf("  <tr><td><b>EventName: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("LogicalName");
	form.appendf("  <tr><td><b>LogicalName: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Ip");
	form.appendf("  <tr><td><b>Ip: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Filename");
	form.appendf("  <tr><td><b>Filename: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Sub");
	
	form.appendf("  <tr><td><b>Sub? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	extfix.clear();
	if (prefix && *prefix) extfix.append(prefix).append(".");
		extfix.append("ShotLimit");
	form.appendf("  <tr><td><b>ShotLimit: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CDfuMonitorRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CDfuMonitorRequest::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_EventName.marshall(rpc_resp, "EventName", "", "", "");
	m_LogicalName.marshall(rpc_resp, "LogicalName", "", "", "");
	m_Ip.marshall(rpc_resp, "Ip", "", "", "");
	m_Filename.marshall(rpc_resp, "Filename", "", "", "");
	m_Sub.marshall(rpc_resp, "Sub", "", "", "");
	m_ShotLimit.marshall(rpc_resp, "ShotLimit", "", "", "");
}


void CDfuMonitorRequest::copy(CDfuMonitorRequest &from)
{
	m_EventName.copy(from.m_EventName);
	m_LogicalName.copy(from.m_LogicalName);
	m_Ip.copy(from.m_Ip);
	m_Filename.copy(from.m_Filename);
	m_Sub.copy(from.m_Sub);
	m_ShotLimit.copy(from.m_ShotLimit);
}


void CDfuMonitorRequest::copy(IConstDfuMonitorRequest &ifrom)
{
	setEventName(ifrom.getEventName());
	setLogicalName(ifrom.getLogicalName());
	setIp(ifrom.getIp());
	setFilename(ifrom.getFilename());
	setSub(ifrom.getSub());
	setShotLimit(ifrom.getShotLimit());
}


void CDfuMonitorRequest::getAttributes(IProperties &attributes)
{
}


void CDfuMonitorRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_EventName.toStr(ctx, buffer, "EventName", "", true, "", "");
	m_LogicalName.toStr(ctx, buffer, "LogicalName", "", true, "", "");
	m_Ip.toStr(ctx, buffer, "Ip", "", true, "", "");
	m_Filename.toStr(ctx, buffer, "Filename", "", true, "", "");
	m_Sub.toStr(ctx, buffer, "Sub", "", true, "", "");
	m_ShotLimit.toStr(ctx, buffer, "ShotLimit", "", true, "", "");
}


void CDfuMonitorRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CDfuMonitorRequest::serializer(IEspContext* ctx, IConstDfuMonitorRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<DfuMonitorRequest>");
	// field EventName
	{
		const char* s = src.getEventName();
		if (s && *s)
		{
			buffer.append("<EventName>");
			encodeUtf8XML(s,buffer);
			buffer.append("</EventName>");
		}
	}
	// field LogicalName
	{
		const char* s = src.getLogicalName();
		if (s && *s)
		{
			buffer.append("<LogicalName>");
			encodeUtf8XML(s,buffer);
			buffer.append("</LogicalName>");
		}
	}
	// field Ip
	{
		const char* s = src.getIp();
		if (s && *s)
		{
			buffer.append("<Ip>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Ip>");
		}
	}
	// field Filename
	{
		const char* s = src.getFilename();
		if (s && *s)
		{
			buffer.append("<Filename>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Filename>");
		}
	}
	// field Sub
	{
		bool b = src.getSub();
		if (b)
			buffer.appendf("<Sub>1</Sub>");
	}
	// field ShotLimit
	{
		int n = src.getShotLimit();
		if (n)
			buffer.appendf("<ShotLimit>%d</ShotLimit>", n);
	}
	if (keepRootTag)
		buffer.append("</DfuMonitorRequest>");
}

bool CDfuMonitorRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_EventName.unmarshall(rpc_request, "EventName", basepath);
	hasValue |= m_LogicalName.unmarshall(rpc_request, "LogicalName", basepath);
	hasValue |= m_Ip.unmarshall(rpc_request, "Ip", basepath);
	hasValue |= m_Filename.unmarshall(rpc_request, "Filename", basepath);
	hasValue |= m_Sub.unmarshall(rpc_request, "Sub", basepath);
	hasValue |= m_ShotLimit.unmarshall(rpc_request, "ShotLimit", basepath);
	return hasValue;
}

bool CDfuMonitorRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_EventName.unmarshall(ctx, soapval, "EventName");
	hasValue |= m_LogicalName.unmarshall(ctx, soapval, "LogicalName");
	hasValue |= m_Ip.unmarshall(ctx, soapval, "Ip");
	hasValue |= m_Filename.unmarshall(ctx, soapval, "Filename");
	hasValue |= m_Sub.unmarshall(ctx, soapval, "Sub");
	hasValue |= m_ShotLimit.unmarshall(ctx, soapval, "ShotLimit");
	return hasValue;
}

bool CDfuMonitorRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_EventName.unmarshall(ctx, params, attachments, "EventName", basepath);
	hasValue |= m_LogicalName.unmarshall(ctx, params, attachments, "LogicalName", basepath);
	hasValue |= m_Ip.unmarshall(ctx, params, attachments, "Ip", basepath);
	hasValue |= m_Filename.unmarshall(ctx, params, attachments, "Filename", basepath);
	hasValue |= m_Sub.unmarshall(ctx, params, attachments, "Sub", basepath);
	hasValue |= m_ShotLimit.unmarshall(ctx, params, attachments, "ShotLimit", basepath);
	return hasValue;
}

const char * CDfuMonitorRequest::getEventName() { return m_EventName.query();}
const char * CDfuMonitorRequest::getLogicalName() { return m_LogicalName.query();}
const char * CDfuMonitorRequest::getIp() { return m_Ip.query();}
const char * CDfuMonitorRequest::getFilename() { return m_Filename.query();}
bool CDfuMonitorRequest::getSub() { return m_Sub;}
int CDfuMonitorRequest::getShotLimit() { return m_ShotLimit;}
void CDfuMonitorRequest::setEventName(const char * val){ m_EventName.set(val); }
void CDfuMonitorRequest::setLogicalName(const char * val){ m_LogicalName.set(val); }
void CDfuMonitorRequest::setIp(const char * val){ m_Ip.set(val); }
void CDfuMonitorRequest::setFilename(const char * val){ m_Filename.set(val); }
void CDfuMonitorRequest::setSub(bool val){ m_Sub=val; }
void CDfuMonitorRequest::setShotLimit(int val){ m_ShotLimit=val; }
extern "C"  IEspDfuMonitorRequest *createDfuMonitorRequest(const char *serv){return ((IEspDfuMonitorRequest *)new CDfuMonitorRequest(serv));}
extern "C"  IClientDfuMonitorRequest *createClientDfuMonitorRequest(const char *serv){return ((IClientDfuMonitorRequest *)new CDfuMonitorRequest(serv));}

//=======================================================
// class CDfuMonitorResponse Implementation
//=======================================================

CDfuMonitorResponse::CDfuMonitorResponse(const char *serviceName, IRpcMessageBinding *init)
	: m_wuid(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("DfuMonitorResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CDfuMonitorResponse::CDfuMonitorResponse(const char *serviceName, const char *bc)
	: m_wuid(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("DfuMonitorResponse");
}

CDfuMonitorResponse::CDfuMonitorResponse(const char *serviceName, IRpcMessage* rpcmsg)
	: m_wuid(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("DfuMonitorResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CDfuMonitorResponse::CDfuMonitorResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_wuid(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("DfuMonitorResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CDfuMonitorResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		schema.append("<xsd:element name=\"Exceptions\" type=\"tns:ArrayOfEspException\" minOccurs=\"0\" maxOccurs=\"1\"/>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"wuid\" type=\"xsd:string\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CDfuMonitorResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CDfuMonitorResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CDfuMonitorResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("wuid");
	form.appendf("  <tr><td><b>wuid: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CDfuMonitorResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CDfuMonitorResponse::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
		m_wuid.marshall(rpc_resp, "wuid", "", "", "");
	}
}


void CDfuMonitorResponse::copy(CDfuMonitorResponse &from)
{
	m_wuid.copy(from.m_wuid);
}


void CDfuMonitorResponse::copy(IConstDfuMonitorResponse &ifrom)
{
	setWuid(ifrom.getWuid());
}


void CDfuMonitorResponse::getAttributes(IProperties &attributes)
{
}


void CDfuMonitorResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
		m_wuid.toStr(ctx, buffer, "wuid", "", true, "", "");
	}
}


void CDfuMonitorResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CDfuMonitorResponse::serializer(IEspContext* ctx, IConstDfuMonitorResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<DfuMonitorResponse>");
	// field wuid
	{
		const char* s = src.getWuid();
		if (s && *s)
		{
			buffer.append("<wuid>");
			encodeUtf8XML(s,buffer);
			buffer.append("</wuid>");
		}
	}
	if (keepRootTag)
		buffer.append("</DfuMonitorResponse>");
}

bool CDfuMonitorResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
		hasValue |= m_wuid.unmarshall(rpc_request, "wuid", basepath);
	}
	return hasValue;
}

bool CDfuMonitorResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_wuid.unmarshall(ctx, soapval, "wuid");
	return hasValue;
}

bool CDfuMonitorResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_wuid.unmarshall(ctx, params, attachments, "wuid", basepath);
	return hasValue;
}

const char * CDfuMonitorResponse::getWuid() { return m_wuid.query();}
void CDfuMonitorResponse::setWuid(const char * val){ m_wuid.set(val); }
extern "C"  IEspDfuMonitorResponse *createDfuMonitorResponse(const char *serv){return ((IEspDfuMonitorResponse *)new CDfuMonitorResponse(serv));}
extern "C"  IClientDfuMonitorResponse *createClientDfuMonitorResponse(const char *serv){return ((IClientDfuMonitorResponse *)new CDfuMonitorResponse(serv));}

//=======================================================
// class CShowResultRequest Implementation
//=======================================================

CShowResultRequest::CShowResultRequest(const char *serviceName, IRpcMessageBinding *init)
	: m_Result(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ShowResultRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CShowResultRequest::CShowResultRequest(const char *serviceName, const char *bc)
	: m_Result(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ShowResultRequest");
}

CShowResultRequest::CShowResultRequest(const char *serviceName, IRpcMessage* rpcmsg)
	: m_Result(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ShowResultRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CShowResultRequest::CShowResultRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_Result(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ShowResultRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CShowResultRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Result\" type=\"xsd:string\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CShowResultRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CShowResultRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CShowResultRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Result");
	form.appendf("  <tr><td><b>Result: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CShowResultRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CShowResultRequest::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_Result.marshall(rpc_resp, "Result", "", "", "");
}


void CShowResultRequest::copy(CShowResultRequest &from)
{
	m_Result.copy(from.m_Result);
}


void CShowResultRequest::copy(IConstShowResultRequest &ifrom)
{
	setResult(ifrom.getResult());
}


void CShowResultRequest::getAttributes(IProperties &attributes)
{
}


void CShowResultRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_Result.toStr(ctx, buffer, "Result", "", true, "", "");
}


void CShowResultRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CShowResultRequest::serializer(IEspContext* ctx, IConstShowResultRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<ShowResultRequest>");
	// field Result
	{
		const char* s = src.getResult();
		if (s && *s)
		{
			buffer.append("<Result>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Result>");
		}
	}
	if (keepRootTag)
		buffer.append("</ShowResultRequest>");
}

bool CShowResultRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_Result.unmarshall(rpc_request, "Result", basepath);
	return hasValue;
}

bool CShowResultRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Result.unmarshall(ctx, soapval, "Result");
	return hasValue;
}

bool CShowResultRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Result.unmarshall(ctx, params, attachments, "Result", basepath);
	return hasValue;
}

const char * CShowResultRequest::getResult() { return m_Result.query();}
void CShowResultRequest::setResult(const char * val){ m_Result.set(val); }
extern "C"  IEspShowResultRequest *createShowResultRequest(const char *serv){return ((IEspShowResultRequest *)new CShowResultRequest(serv));}
extern "C"  IClientShowResultRequest *createClientShowResultRequest(const char *serv){return ((IClientShowResultRequest *)new CShowResultRequest(serv));}

//=======================================================
// class CShowResultResponse Implementation
//=======================================================

CShowResultResponse::CShowResultResponse(const char *serviceName, IRpcMessageBinding *init)
	: m_Result(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ShowResultResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CShowResultResponse::CShowResultResponse(const char *serviceName, const char *bc)
	: m_Result(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ShowResultResponse");
}

CShowResultResponse::CShowResultResponse(const char *serviceName, IRpcMessage* rpcmsg)
	: m_Result(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ShowResultResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CShowResultResponse::CShowResultResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_Result(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ShowResultResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CShowResultResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		schema.append("<xsd:element name=\"Exceptions\" type=\"tns:ArrayOfEspException\" minOccurs=\"0\" maxOccurs=\"1\"/>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Result\" type=\"xsd:string\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CShowResultResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CShowResultResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CShowResultResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Result");
	form.appendf("  <tr><td><b>Result: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CShowResultResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CShowResultResponse::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
		m_Result.marshall(rpc_resp, "Result", "", "", "");
	}
}


void CShowResultResponse::copy(CShowResultResponse &from)
{
	m_Result.copy(from.m_Result);
}


void CShowResultResponse::copy(IConstShowResultResponse &ifrom)
{
	setResult(ifrom.getResult());
}


void CShowResultResponse::getAttributes(IProperties &attributes)
{
}


void CShowResultResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
		m_Result.toStr(ctx, buffer, "Result", "", true, "", "");
	}
}


void CShowResultResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CShowResultResponse::serializer(IEspContext* ctx, IConstShowResultResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<ShowResultResponse>");
	// field Result
	{
		const char* s = src.getResult();
		if (s && *s)
		{
			buffer.append("<Result>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Result>");
		}
	}
	if (keepRootTag)
		buffer.append("</ShowResultResponse>");
}

bool CShowResultResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
		hasValue |= m_Result.unmarshall(rpc_request, "Result", basepath);
	}
	return hasValue;
}

bool CShowResultResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Result.unmarshall(ctx, soapval, "Result");
	return hasValue;
}

bool CShowResultResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Result.unmarshall(ctx, params, attachments, "Result", basepath);
	return hasValue;
}

const char * CShowResultResponse::getResult() { return m_Result.query();}
void CShowResultResponse::setResult(const char * val){ m_Result.set(val); }
extern "C"  IEspShowResultResponse *createShowResultResponse(const char *serv){return ((IEspShowResultResponse *)new CShowResultResponse(serv));}
extern "C"  IClientShowResultResponse *createClientShowResultResponse(const char *serv){return ((IClientShowResultResponse *)new CShowResultResponse(serv));}

//=======================================================
// class CDropZone Implementation
//=======================================================

CDropZone::CDropZone(const char *serviceName, IRpcMessageBinding *init)
	: m_Name(nilRemove),m_NetAddress(nilRemove),m_Path(nilRemove),m_Computer(nilRemove),m_Linux(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("DropZone");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CDropZone::CDropZone(const char *serviceName, const char *bc)
	: m_Name(nilRemove),m_NetAddress(nilRemove),m_Path(nilRemove),m_Computer(nilRemove),m_Linux(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("DropZone");
}

StringBuffer &CDropZone::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:complexType name=\"%s\">\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Name\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"NetAddress\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Path\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Computer\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Linux\" type=\"xsd:string\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType>\n");
		}
	}
	return schema;
}

void CDropZone::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CDropZone::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CDropZone::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Name");
	form.appendf("  <tr><td><b>Name: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("NetAddress");
	form.appendf("  <tr><td><b>NetAddress: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Path");
	form.appendf("  <tr><td><b>Path: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Computer");
	form.appendf("  <tr><td><b>Computer: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Linux");
	form.appendf("  <tr><td><b>Linux: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CDropZone::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CDropZone::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_Name.marshall(rpc_resp, "Name", "", "", "");
	m_NetAddress.marshall(rpc_resp, "NetAddress", "", "", "");
	m_Path.marshall(rpc_resp, "Path", "", "", "");
	m_Computer.marshall(rpc_resp, "Computer", "", "", "");
	m_Linux.marshall(rpc_resp, "Linux", "", "", "");
}


void CDropZone::copy(CDropZone &from)
{
	m_Name.copy(from.m_Name);
	m_NetAddress.copy(from.m_NetAddress);
	m_Path.copy(from.m_Path);
	m_Computer.copy(from.m_Computer);
	m_Linux.copy(from.m_Linux);
}


void CDropZone::copy(IConstDropZone &ifrom)
{
	setName(ifrom.getName());
	setNetAddress(ifrom.getNetAddress());
	setPath(ifrom.getPath());
	setComputer(ifrom.getComputer());
	setLinux(ifrom.getLinux());
}


void CDropZone::getAttributes(IProperties &attributes)
{
}


void CDropZone::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_Name.toStr(ctx, buffer, "Name", "", true, "", "");
	m_NetAddress.toStr(ctx, buffer, "NetAddress", "", true, "", "");
	m_Path.toStr(ctx, buffer, "Path", "", true, "", "");
	m_Computer.toStr(ctx, buffer, "Computer", "", true, "", "");
	m_Linux.toStr(ctx, buffer, "Linux", "", true, "", "");
}


void CDropZone::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CDropZone::serializer(IEspContext* ctx, IConstDropZone &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<DropZone>");
	// field Name
	{
		const char* s = src.getName();
		if (s && *s)
		{
			buffer.append("<Name>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Name>");
		}
	}
	// field NetAddress
	{
		const char* s = src.getNetAddress();
		if (s && *s)
		{
			buffer.append("<NetAddress>");
			encodeUtf8XML(s,buffer);
			buffer.append("</NetAddress>");
		}
	}
	// field Path
	{
		const char* s = src.getPath();
		if (s && *s)
		{
			buffer.append("<Path>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Path>");
		}
	}
	// field Computer
	{
		const char* s = src.getComputer();
		if (s && *s)
		{
			buffer.append("<Computer>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Computer>");
		}
	}
	// field Linux
	{
		const char* s = src.getLinux();
		if (s && *s)
		{
			buffer.append("<Linux>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Linux>");
		}
	}
	if (keepRootTag)
		buffer.append("</DropZone>");
}

bool CDropZone::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_Name.unmarshall(rpc_request, "Name", basepath);
	hasValue |= m_NetAddress.unmarshall(rpc_request, "NetAddress", basepath);
	hasValue |= m_Path.unmarshall(rpc_request, "Path", basepath);
	hasValue |= m_Computer.unmarshall(rpc_request, "Computer", basepath);
	hasValue |= m_Linux.unmarshall(rpc_request, "Linux", basepath);
	return hasValue;
}

bool CDropZone::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Name.unmarshall(ctx, soapval, "Name");
	hasValue |= m_NetAddress.unmarshall(ctx, soapval, "NetAddress");
	hasValue |= m_Path.unmarshall(ctx, soapval, "Path");
	hasValue |= m_Computer.unmarshall(ctx, soapval, "Computer");
	hasValue |= m_Linux.unmarshall(ctx, soapval, "Linux");
	return hasValue;
}

bool CDropZone::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Name.unmarshall(ctx, params, attachments, "Name", basepath);
	hasValue |= m_NetAddress.unmarshall(ctx, params, attachments, "NetAddress", basepath);
	hasValue |= m_Path.unmarshall(ctx, params, attachments, "Path", basepath);
	hasValue |= m_Computer.unmarshall(ctx, params, attachments, "Computer", basepath);
	hasValue |= m_Linux.unmarshall(ctx, params, attachments, "Linux", basepath);
	return hasValue;
}

const char * CDropZone::getName() { return m_Name.query();}
const char * CDropZone::getNetAddress() { return m_NetAddress.query();}
const char * CDropZone::getPath() { return m_Path.query();}
const char * CDropZone::getComputer() { return m_Computer.query();}
const char * CDropZone::getLinux() { return m_Linux.query();}
void CDropZone::setName(const char * val){ m_Name.set(val); }
void CDropZone::setNetAddress(const char * val){ m_NetAddress.set(val); }
void CDropZone::setPath(const char * val){ m_Path.set(val); }
void CDropZone::setComputer(const char * val){ m_Computer.set(val); }
void CDropZone::setLinux(const char * val){ m_Linux.set(val); }
extern "C"  IEspDropZone *createDropZone(const char *serv, const char *msgname){return ((IEspDropZone *)new CDropZone(serv /*, msgname*/));}
extern "C"  IClientDropZone *createClientDropZone(const char *serv, const char *msgname){return ((IClientDropZone *)new CDropZone(serv /*, msgname*/));}

//=======================================================
// class CDropZoneFilesRequest Implementation
//=======================================================

CDropZoneFilesRequest::CDropZoneFilesRequest(const char *serviceName, IRpcMessageBinding *init)
	: m_DropZoneName(nilIgnore),m_NetAddress(nilIgnore),m_Path(nilIgnore),m_OS(nilIgnore),m_Subfolder(nilIgnore),m_ECLWatchVisibleOnly(0, nilIgnore,false),m_DirectoryOnly(0, nilIgnore,false)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("DropZoneFilesRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CDropZoneFilesRequest::CDropZoneFilesRequest(const char *serviceName, const char *bc)
	: m_DropZoneName(nilIgnore),m_NetAddress(nilIgnore),m_Path(nilIgnore),m_OS(nilIgnore),m_Subfolder(nilIgnore),m_ECLWatchVisibleOnly(0, nilIgnore,false),m_DirectoryOnly(0, nilIgnore,false)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("DropZoneFilesRequest");
}

CDropZoneFilesRequest::CDropZoneFilesRequest(const char *serviceName, IRpcMessage* rpcmsg)
	: m_DropZoneName(nilIgnore),m_NetAddress(nilIgnore),m_Path(nilIgnore),m_OS(nilIgnore),m_Subfolder(nilIgnore),m_ECLWatchVisibleOnly(0, nilIgnore,false),m_DirectoryOnly(0, nilIgnore,false)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("DropZoneFilesRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CDropZoneFilesRequest::CDropZoneFilesRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_DropZoneName(nilIgnore),m_NetAddress(nilIgnore),m_Path(nilIgnore),m_OS(nilIgnore),m_Subfolder(nilIgnore),m_ECLWatchVisibleOnly(0, nilIgnore,false),m_DirectoryOnly(0, nilIgnore,false)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("DropZoneFilesRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CDropZoneFilesRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		if (!context.suppressed("DropZoneFilesRequest","DropZoneName")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"DropZoneName\" type=\"xsd:string\"/>\n");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"NetAddress\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Path\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"OS\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Subfolder\" type=\"xsd:string\"/>\n");
		if (!context.suppressed("DropZoneFilesRequest","ECLWatchVisibleOnly")) {
			schema.append("<xsd:element minOccurs=\"0\" default=\"false\" name=\"ECLWatchVisibleOnly\" type=\"xsd:boolean\"/>\n");
		}
		schema.append("<xsd:element minOccurs=\"0\" default=\"false\" name=\"DirectoryOnly\" type=\"xsd:boolean\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CDropZoneFilesRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CDropZoneFilesRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
	info.addMinVersion("DropZoneFilesRequest","DropZoneName",1.15);
	info.addMinVersion("DropZoneFilesRequest","ECLWatchVisibleOnly",1.15);
}

StringBuffer &CDropZoneFilesRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	if (!context.suppressed("DropZoneFilesRequest","DropZoneName")) {
		extfix.clear();
		if (prefix && *prefix)
			extfix.append(prefix).append(".");
		extfix.append("DropZoneName");
		form.appendf("  <tr><td><b>DropZoneName: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
		form.append("</td></tr>\n");
	}
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("NetAddress");
	form.appendf("  <tr><td><b>NetAddress: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Path");
	form.appendf("  <tr><td><b>Path: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("OS");
	form.appendf("  <tr><td><b>OS: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Subfolder");
	form.appendf("  <tr><td><b>Subfolder: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (!context.suppressed("DropZoneFilesRequest","ECLWatchVisibleOnly")) {
		extfix.clear();
		if (prefix && *prefix)
			extfix.append(prefix).append(".");
		extfix.append("ECLWatchVisibleOnly");
		
	form.appendf("  <tr><td><b>ECLWatchVisibleOnly? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	}
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("DirectoryOnly");
	
	form.appendf("  <tr><td><b>DirectoryOnly? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CDropZoneFilesRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CDropZoneFilesRequest::serialize(IRpcMessage& rpc_resp)
{
	IEspContext* ctx = rpc_resp.queryContext();
	double clientVer= ctx ? ctx->getClientVersion() : -1; /* no context gets everything */
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	if ((clientVer==-1.0 || clientVer>=1.15))
		m_DropZoneName.marshall(rpc_resp, "DropZoneName", "", "", "");
	m_NetAddress.marshall(rpc_resp, "NetAddress", "", "", "");
	m_Path.marshall(rpc_resp, "Path", "", "", "");
	m_OS.marshall(rpc_resp, "OS", "", "", "");
	m_Subfolder.marshall(rpc_resp, "Subfolder", "", "", "");
	if ((clientVer==-1.0 || clientVer>=1.15))
		m_ECLWatchVisibleOnly.marshall(rpc_resp, "ECLWatchVisibleOnly", "", "", "");
	m_DirectoryOnly.marshall(rpc_resp, "DirectoryOnly", "", "", "");
}


void CDropZoneFilesRequest::copy(CDropZoneFilesRequest &from)
{
	m_DropZoneName.copy(from.m_DropZoneName);
	m_NetAddress.copy(from.m_NetAddress);
	m_Path.copy(from.m_Path);
	m_OS.copy(from.m_OS);
	m_Subfolder.copy(from.m_Subfolder);
	m_ECLWatchVisibleOnly.copy(from.m_ECLWatchVisibleOnly);
	m_DirectoryOnly.copy(from.m_DirectoryOnly);
}


void CDropZoneFilesRequest::copy(IConstDropZoneFilesRequest &ifrom)
{
	setDropZoneName(ifrom.getDropZoneName());
	setNetAddress(ifrom.getNetAddress());
	setPath(ifrom.getPath());
	setOS(ifrom.getOS());
	setSubfolder(ifrom.getSubfolder());
	setECLWatchVisibleOnly(ifrom.getECLWatchVisibleOnly());
	setDirectoryOnly(ifrom.getDirectoryOnly());
}


void CDropZoneFilesRequest::getAttributes(IProperties &attributes)
{
}


void CDropZoneFilesRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	double clientVer = ctx ? ctx->getClientVersion() : -1;
	if ((clientVer==-1.0 || clientVer>=1.15))
		m_DropZoneName.toStr(ctx, buffer, "DropZoneName", "", true, "", "");
	m_NetAddress.toStr(ctx, buffer, "NetAddress", "", true, "", "");
	m_Path.toStr(ctx, buffer, "Path", "", true, "", "");
	m_OS.toStr(ctx, buffer, "OS", "", true, "", "");
	m_Subfolder.toStr(ctx, buffer, "Subfolder", "", true, "", "");
	if ((clientVer==-1.0 || clientVer>=1.15))
		m_ECLWatchVisibleOnly.toStr(ctx, buffer, "ECLWatchVisibleOnly", "", true, "", "");
	m_DirectoryOnly.toStr(ctx, buffer, "DirectoryOnly", "", true, "", "");
}


void CDropZoneFilesRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CDropZoneFilesRequest::serializer(IEspContext* ctx, IConstDropZoneFilesRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<DropZoneFilesRequest>");
	double clientVer = ctx ? ctx->getClientVersion() : -1;
	// field DropZoneName
	if ((clientVer==-1.0 || clientVer>=1.15))
	{
		const char* s = src.getDropZoneName();
		if (s && *s)
		{
			buffer.append("<DropZoneName>");
			encodeUtf8XML(s,buffer);
			buffer.append("</DropZoneName>");
		}
	}
	// field NetAddress
	{
		const char* s = src.getNetAddress();
		if (s && *s)
		{
			buffer.append("<NetAddress>");
			encodeUtf8XML(s,buffer);
			buffer.append("</NetAddress>");
		}
	}
	// field Path
	{
		const char* s = src.getPath();
		if (s && *s)
		{
			buffer.append("<Path>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Path>");
		}
	}
	// field OS
	{
		const char* s = src.getOS();
		if (s && *s)
		{
			buffer.append("<OS>");
			encodeUtf8XML(s,buffer);
			buffer.append("</OS>");
		}
	}
	// field Subfolder
	{
		const char* s = src.getSubfolder();
		if (s && *s)
		{
			buffer.append("<Subfolder>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Subfolder>");
		}
	}
	// field ECLWatchVisibleOnly
	if ((clientVer==-1.0 || clientVer>=1.15))
	{
		bool b = src.getECLWatchVisibleOnly();
		if (b)
			buffer.appendf("<ECLWatchVisibleOnly>1</ECLWatchVisibleOnly>");
	}
	// field DirectoryOnly
	{
		bool b = src.getDirectoryOnly();
		if (b)
			buffer.appendf("<DirectoryOnly>1</DirectoryOnly>");
	}
	if (keepRootTag)
		buffer.append("</DropZoneFilesRequest>");
}

bool CDropZoneFilesRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_DropZoneName.unmarshall(rpc_request, "DropZoneName", basepath);
	hasValue |= m_NetAddress.unmarshall(rpc_request, "NetAddress", basepath);
	hasValue |= m_Path.unmarshall(rpc_request, "Path", basepath);
	hasValue |= m_OS.unmarshall(rpc_request, "OS", basepath);
	hasValue |= m_Subfolder.unmarshall(rpc_request, "Subfolder", basepath);
	hasValue |= m_ECLWatchVisibleOnly.unmarshall(rpc_request, "ECLWatchVisibleOnly", basepath);
	hasValue |= m_DirectoryOnly.unmarshall(rpc_request, "DirectoryOnly", basepath);
	return hasValue;
}

bool CDropZoneFilesRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_DropZoneName.unmarshall(ctx, soapval, "DropZoneName");
	hasValue |= m_NetAddress.unmarshall(ctx, soapval, "NetAddress");
	hasValue |= m_Path.unmarshall(ctx, soapval, "Path");
	hasValue |= m_OS.unmarshall(ctx, soapval, "OS");
	hasValue |= m_Subfolder.unmarshall(ctx, soapval, "Subfolder");
	hasValue |= m_ECLWatchVisibleOnly.unmarshall(ctx, soapval, "ECLWatchVisibleOnly");
	hasValue |= m_DirectoryOnly.unmarshall(ctx, soapval, "DirectoryOnly");
	return hasValue;
}

bool CDropZoneFilesRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_DropZoneName.unmarshall(ctx, params, attachments, "DropZoneName", basepath);
	hasValue |= m_NetAddress.unmarshall(ctx, params, attachments, "NetAddress", basepath);
	hasValue |= m_Path.unmarshall(ctx, params, attachments, "Path", basepath);
	hasValue |= m_OS.unmarshall(ctx, params, attachments, "OS", basepath);
	hasValue |= m_Subfolder.unmarshall(ctx, params, attachments, "Subfolder", basepath);
	hasValue |= m_ECLWatchVisibleOnly.unmarshall(ctx, params, attachments, "ECLWatchVisibleOnly", basepath);
	hasValue |= m_DirectoryOnly.unmarshall(ctx, params, attachments, "DirectoryOnly", basepath);
	return hasValue;
}

const char * CDropZoneFilesRequest::getDropZoneName() { return m_DropZoneName.query();}
const char * CDropZoneFilesRequest::getNetAddress() { return m_NetAddress.query();}
const char * CDropZoneFilesRequest::getPath() { return m_Path.query();}
const char * CDropZoneFilesRequest::getOS() { return m_OS.query();}
const char * CDropZoneFilesRequest::getSubfolder() { return m_Subfolder.query();}
bool CDropZoneFilesRequest::getECLWatchVisibleOnly() { return m_ECLWatchVisibleOnly;}
bool CDropZoneFilesRequest::getDirectoryOnly() { return m_DirectoryOnly;}
void CDropZoneFilesRequest::setDropZoneName(const char * val){ m_DropZoneName.set(val); }
void CDropZoneFilesRequest::setNetAddress(const char * val){ m_NetAddress.set(val); }
void CDropZoneFilesRequest::setPath(const char * val){ m_Path.set(val); }
void CDropZoneFilesRequest::setOS(const char * val){ m_OS.set(val); }
void CDropZoneFilesRequest::setSubfolder(const char * val){ m_Subfolder.set(val); }
void CDropZoneFilesRequest::setECLWatchVisibleOnly(bool val){ m_ECLWatchVisibleOnly=val; }
void CDropZoneFilesRequest::setDirectoryOnly(bool val){ m_DirectoryOnly=val; }
extern "C"  IEspDropZoneFilesRequest *createDropZoneFilesRequest(const char *serv){return ((IEspDropZoneFilesRequest *)new CDropZoneFilesRequest(serv));}
extern "C"  IClientDropZoneFilesRequest *createClientDropZoneFilesRequest(const char *serv){return ((IClientDropZoneFilesRequest *)new CDropZoneFilesRequest(serv));}

//=======================================================
// class CDropZoneFilesResponse Implementation
//=======================================================

CDropZoneFilesResponse::CDropZoneFilesResponse(const char *serviceName, IRpcMessageBinding *init)
	: m_DropZoneName(nilRemove),m_NetAddress(nilRemove),m_Path(nilRemove),m_OS(nilRemove),m_ECLWatchVisibleOnly(nilRemove),m_DropZones(nilRemove),m_Files(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("DropZoneFilesResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CDropZoneFilesResponse::CDropZoneFilesResponse(const char *serviceName, const char *bc)
	: m_DropZoneName(nilRemove),m_NetAddress(nilRemove),m_Path(nilRemove),m_OS(nilRemove),m_ECLWatchVisibleOnly(nilRemove),m_DropZones(nilRemove),m_Files(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("DropZoneFilesResponse");
}

CDropZoneFilesResponse::CDropZoneFilesResponse(const char *serviceName, IRpcMessage* rpcmsg)
	: m_DropZoneName(nilRemove),m_NetAddress(nilRemove),m_Path(nilRemove),m_OS(nilRemove),m_ECLWatchVisibleOnly(nilRemove),m_DropZones(nilRemove),m_Files(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("DropZoneFilesResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CDropZoneFilesResponse::CDropZoneFilesResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_DropZoneName(nilRemove),m_NetAddress(nilRemove),m_Path(nilRemove),m_OS(nilRemove),m_ECLWatchVisibleOnly(nilRemove),m_DropZones(nilRemove),m_Files(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("DropZoneFilesResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CDropZoneFilesResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		schema.append("<xsd:element name=\"Exceptions\" type=\"tns:ArrayOfEspException\" minOccurs=\"0\" maxOccurs=\"1\"/>");
		}
		if (!context.suppressed("DropZoneFilesResponse","DropZoneName")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"DropZoneName\" type=\"xsd:string\"/>\n");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"NetAddress\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Path\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"OS\" type=\"xsd:int\"/>\n");
		if (!context.suppressed("DropZoneFilesResponse","ECLWatchVisibleOnly")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"ECLWatchVisibleOnly\" type=\"xsd:boolean\"/>\n");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"DropZones\" type=\"tns:ArrayOfDropZone\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Files\" type=\"tns:ArrayOfPhysicalFileStruct\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	if (!(flags & 0x10)  || (flags & 0x100))
	{
		CDropZone::getXsdDefinition(context, request, schema, added);
		CPhysicalFileStruct::getXsdDefinition(context, request, schema, added);
	}
	if (added.getValue("DropZone") && added.getValue("ArrayOfDropZone")==NULL) {
		schema.append("<xsd:complexType name=\"ArrayOfDropZone\">\n");
		schema.append("<xsd:sequence>\n");
		schema.append("<xsd:element minOccurs=\"0\" maxOccurs=\"unbounded\" name=\"DropZone\" type=\"tns:DropZone\"/>\n");
		schema.append("</xsd:sequence>\n");
		schema.append("</xsd:complexType>\n");
		added.setValue("ArrayOfDropZone",1);
	}
	if (added.getValue("PhysicalFileStruct") && added.getValue("ArrayOfPhysicalFileStruct")==NULL) {
		schema.append("<xsd:complexType name=\"ArrayOfPhysicalFileStruct\">\n");
		schema.append("<xsd:sequence>\n");
		schema.append("<xsd:element minOccurs=\"0\" maxOccurs=\"unbounded\" name=\"PhysicalFileStruct\" type=\"tns:PhysicalFileStruct\"/>\n");
		schema.append("</xsd:sequence>\n");
		schema.append("</xsd:complexType>\n");
		added.setValue("ArrayOfPhysicalFileStruct",1);
	}
	return schema;
}

void CDropZoneFilesResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CDropZoneFilesResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
	info.addMinVersion("DropZoneFilesResponse","DropZoneName",1.15);
	info.addMinVersion("DropZoneFilesResponse","ECLWatchVisibleOnly",1.15);
	if (!added.getValue("DropZone"))
	{
		added.setValue("DropZone",1);
		CDropZone::getMapInfo(info,added);
	}
	if (!added.getValue("PhysicalFileStruct"))
	{
		added.setValue("PhysicalFileStruct",1);
		CPhysicalFileStruct::getMapInfo(info,added);
	}
}

StringBuffer &CDropZoneFilesResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	if (!context.suppressed("DropZoneFilesResponse","DropZoneName")) {
		extfix.clear();
		if (prefix && *prefix)
			extfix.append(prefix).append(".");
		extfix.append("DropZoneName");
		form.appendf("  <tr><td><b>DropZoneName: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
		form.append("</td></tr>\n");
	}
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("NetAddress");
	form.appendf("  <tr><td><b>NetAddress: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Path");
	form.appendf("  <tr><td><b>Path: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix) extfix.append(prefix).append(".");
		extfix.append("OS");
	form.appendf("  <tr><td><b>OS: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
	form.append("</td></tr>\n");
	if (!context.suppressed("DropZoneFilesResponse","ECLWatchVisibleOnly")) {
		extfix.clear();
		if (prefix && *prefix)
			extfix.append(prefix).append(".");
		extfix.append("ECLWatchVisibleOnly");
		
	form.appendf("  <tr><td><b>ECLWatchVisibleOnly? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	}
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("DropZones");
	form.appendf("<tr><td><b>DropZones: </b></td><td>");
	form.appendf("<table><tr><td><textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea></td>", extfix.str());
	form.append("</tr></table>");
	form.append("</td></tr>");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Files");
	form.appendf("<tr><td><b>Files: </b></td><td>");
	form.appendf("<table><tr><td><textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea></td>", extfix.str());
	form.append("</tr></table>");
	form.append("</td></tr>");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CDropZoneFilesResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CDropZoneFilesResponse::serialize(IRpcMessage& rpc_resp)
{
	IEspContext* ctx = rpc_resp.queryContext();
	double clientVer= ctx ? ctx->getClientVersion() : -1; /* no context gets everything */
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
		if ((clientVer==-1.0 || clientVer>=1.15))
			m_DropZoneName.marshall(rpc_resp, "DropZoneName", "", "", "");
		m_NetAddress.marshall(rpc_resp, "NetAddress", "", "", "");
		m_Path.marshall(rpc_resp, "Path", "", "", "");
		m_OS.marshall(rpc_resp, "OS", "", "", "");
		if ((clientVer==-1.0 || clientVer>=1.15))
			m_ECLWatchVisibleOnly.marshall(rpc_resp, "ECLWatchVisibleOnly", "", "", "");
		m_DropZones.marshall(rpc_resp, "DropZones", "DropZone");
		m_Files.marshall(rpc_resp, "Files", "PhysicalFileStruct");
	}
}


void CDropZoneFilesResponse::copy(CDropZoneFilesResponse &from)
{
	m_DropZoneName.copy(from.m_DropZoneName);
	m_NetAddress.copy(from.m_NetAddress);
	m_Path.copy(from.m_Path);
	m_OS.copy(from.m_OS);
	m_ECLWatchVisibleOnly.copy(from.m_ECLWatchVisibleOnly);
	m_DropZones.copy(from.m_DropZones);
	m_Files.copy(from.m_Files);
}


void CDropZoneFilesResponse::copy(IConstDropZoneFilesResponse &ifrom)
{
	setDropZoneName(ifrom.getDropZoneName());
	setNetAddress(ifrom.getNetAddress());
	setPath(ifrom.getPath());
	setOS(ifrom.getOS());
	setECLWatchVisibleOnly(ifrom.getECLWatchVisibleOnly());
	setDropZones(ifrom.getDropZones());
	setFiles(ifrom.getFiles());
}


void CDropZoneFilesResponse::getAttributes(IProperties &attributes)
{
}


void CDropZoneFilesResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
		double clientVer = ctx ? ctx->getClientVersion() : -1;
		if ((clientVer==-1.0 || clientVer>=1.15))
			m_DropZoneName.toStr(ctx, buffer, "DropZoneName", "", true, "", "");
		m_NetAddress.toStr(ctx, buffer, "NetAddress", "", true, "", "");
		m_Path.toStr(ctx, buffer, "Path", "", true, "", "");
		m_OS.toStr(ctx, buffer, "OS", "", true, "", "");
		if ((clientVer==-1.0 || clientVer>=1.15))
			m_ECLWatchVisibleOnly.toStr(ctx, buffer, "ECLWatchVisibleOnly", "", true, "", "");
		m_DropZones.toStr(ctx, buffer, "DropZones", "DropZone");
		m_Files.toStr(ctx, buffer, "Files", "PhysicalFileStruct");
	}
}


void CDropZoneFilesResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CDropZoneFilesResponse::serializer(IEspContext* ctx, IConstDropZoneFilesResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<DropZoneFilesResponse>");
	double clientVer = ctx ? ctx->getClientVersion() : -1;
	// field DropZoneName
	if ((clientVer==-1.0 || clientVer>=1.15))
	{
		const char* s = src.getDropZoneName();
		if (s && *s)
		{
			buffer.append("<DropZoneName>");
			encodeUtf8XML(s,buffer);
			buffer.append("</DropZoneName>");
		}
	}
	// field NetAddress
	{
		const char* s = src.getNetAddress();
		if (s && *s)
		{
			buffer.append("<NetAddress>");
			encodeUtf8XML(s,buffer);
			buffer.append("</NetAddress>");
		}
	}
	// field Path
	{
		const char* s = src.getPath();
		if (s && *s)
		{
			buffer.append("<Path>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Path>");
		}
	}
	// field OS
	{
		int n = src.getOS();
		if (n)
			buffer.appendf("<OS>%d</OS>", n);
	}
	// field ECLWatchVisibleOnly
	if ((clientVer==-1.0 || clientVer>=1.15))
	{
		bool b = src.getECLWatchVisibleOnly();
		if (b)
			buffer.appendf("<ECLWatchVisibleOnly>1</ECLWatchVisibleOnly>");
	}
	// field DropZones
	{
		IArrayOf<IConstDropZone>& v = src.getDropZones();
		int size = v.length();
		if (size>0)
			buffer.append("<DropZones>");
		for (int i=0;i<size;i++)
		{
			buffer.append("<Item>");
			CDropZone::serializer(ctx,v.item(i),buffer,false);
			buffer.append("</Item>");
		}
		if (size>0)
			buffer.append("</DropZones>");
	}
	// field Files
	{
		IArrayOf<IConstPhysicalFileStruct>& v = src.getFiles();
		int size = v.length();
		if (size>0)
			buffer.append("<Files>");
		for (int i=0;i<size;i++)
		{
			buffer.append("<Item>");
			CPhysicalFileStruct::serializer(ctx,v.item(i),buffer,false);
			buffer.append("</Item>");
		}
		if (size>0)
			buffer.append("</Files>");
	}
	if (keepRootTag)
		buffer.append("</DropZoneFilesResponse>");
}

bool CDropZoneFilesResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
		hasValue |= m_DropZoneName.unmarshall(rpc_request, "DropZoneName", basepath);
		hasValue |= m_NetAddress.unmarshall(rpc_request, "NetAddress", basepath);
		hasValue |= m_Path.unmarshall(rpc_request, "Path", basepath);
		hasValue |= m_OS.unmarshall(rpc_request, "OS", basepath);
		hasValue |= m_ECLWatchVisibleOnly.unmarshall(rpc_request, "ECLWatchVisibleOnly", basepath);
		hasValue |= m_DropZones.unmarshall(rpc_request, "DropZones", basepath);
		hasValue |= m_Files.unmarshall(rpc_request, "Files", basepath);
	}
	return hasValue;
}

bool CDropZoneFilesResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_DropZoneName.unmarshall(ctx, soapval, "DropZoneName");
	hasValue |= m_NetAddress.unmarshall(ctx, soapval, "NetAddress");
	hasValue |= m_Path.unmarshall(ctx, soapval, "Path");
	hasValue |= m_OS.unmarshall(ctx, soapval, "OS");
	hasValue |= m_ECLWatchVisibleOnly.unmarshall(ctx, soapval, "ECLWatchVisibleOnly");
	hasValue |= m_DropZones.unmarshall(ctx, soapval, "DropZones");
	hasValue |= m_Files.unmarshall(ctx, soapval, "Files");
	return hasValue;
}

bool CDropZoneFilesResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_DropZoneName.unmarshall(ctx, params, attachments, "DropZoneName", basepath);
	hasValue |= m_NetAddress.unmarshall(ctx, params, attachments, "NetAddress", basepath);
	hasValue |= m_Path.unmarshall(ctx, params, attachments, "Path", basepath);
	hasValue |= m_OS.unmarshall(ctx, params, attachments, "OS", basepath);
	hasValue |= m_ECLWatchVisibleOnly.unmarshall(ctx, params, attachments, "ECLWatchVisibleOnly", basepath);
	hasValue |= m_DropZones.unmarshall(ctx, params, attachments, "DropZones", basepath);
	hasValue |= m_Files.unmarshall(ctx, params, attachments, "Files", basepath);
	return hasValue;
}

const char * CDropZoneFilesResponse::getDropZoneName() { return m_DropZoneName.query();}
const char * CDropZoneFilesResponse::getNetAddress() { return m_NetAddress.query();}
const char * CDropZoneFilesResponse::getPath() { return m_Path.query();}
bool CDropZoneFilesResponse::getOS_isNull(){return m_OS.is_nil();}
int CDropZoneFilesResponse::getOS() { return m_OS;}
bool CDropZoneFilesResponse::getECLWatchVisibleOnly_isNull(){return m_ECLWatchVisibleOnly.is_nil();}
bool CDropZoneFilesResponse::getECLWatchVisibleOnly() { return m_ECLWatchVisibleOnly;}
IArrayOf<IConstDropZone> & CDropZoneFilesResponse::getDropZones() { return (IArrayOf<IConstDropZone> &) m_DropZones; }
IArrayOf<IConstPhysicalFileStruct> & CDropZoneFilesResponse::getFiles() { return (IArrayOf<IConstPhysicalFileStruct> &) m_Files; }
void CDropZoneFilesResponse::setDropZoneName(const char * val){ m_DropZoneName.set(val); }
void CDropZoneFilesResponse::setNetAddress(const char * val){ m_NetAddress.set(val); }
void CDropZoneFilesResponse::setPath(const char * val){ m_Path.set(val); }
void CDropZoneFilesResponse::setOS_null(){ m_OS.Nil(); }void CDropZoneFilesResponse::setOS(int val){ m_OS=val; }
void CDropZoneFilesResponse::setECLWatchVisibleOnly_null(){ m_ECLWatchVisibleOnly.Nil(); }void CDropZoneFilesResponse::setECLWatchVisibleOnly(bool val){ m_ECLWatchVisibleOnly=val; }
void CDropZoneFilesResponse::setDropZones(IArrayOf<IEspDropZone> &val)
{
	m_DropZones->kill();
	IArrayOf<IConstDropZone> &target = m_DropZones.getValue();
	ForEachItemIn(idx, val)
	{
		IEspDropZone &item = (val).item(idx);
		item.Link();
		target.append(item);
	}
}
void CDropZoneFilesResponse::setDropZones(IArrayOf<IConstDropZone> &val)
{
	m_DropZones->kill();
	IArrayOf<IConstDropZone> &target = m_DropZones.getValue();
	ForEachItemIn(idx, val)
	{
		IConstDropZone &item = val.item(idx);
		item.Link();
		target.append(item);
	}
}
void CDropZoneFilesResponse::setFiles(IArrayOf<IEspPhysicalFileStruct> &val)
{
	m_Files->kill();
	IArrayOf<IConstPhysicalFileStruct> &target = m_Files.getValue();
	ForEachItemIn(idx, val)
	{
		IEspPhysicalFileStruct &item = (val).item(idx);
		item.Link();
		target.append(item);
	}
}
void CDropZoneFilesResponse::setFiles(IArrayOf<IConstPhysicalFileStruct> &val)
{
	m_Files->kill();
	IArrayOf<IConstPhysicalFileStruct> &target = m_Files.getValue();
	ForEachItemIn(idx, val)
	{
		IConstPhysicalFileStruct &item = val.item(idx);
		item.Link();
		target.append(item);
	}
}
extern "C"  IEspDropZoneFilesResponse *createDropZoneFilesResponse(const char *serv){return ((IEspDropZoneFilesResponse *)new CDropZoneFilesResponse(serv));}
extern "C"  IClientDropZoneFilesResponse *createClientDropZoneFilesResponse(const char *serv){return ((IClientDropZoneFilesResponse *)new CDropZoneFilesResponse(serv));}

//=======================================================
// class CDeleteDropZoneFilesRequest Implementation
//=======================================================

CDeleteDropZoneFilesRequest::CDeleteDropZoneFilesRequest(const char *serviceName, IRpcMessageBinding *init)
	: m_DropZoneName(nilIgnore),m_NetAddress(nilIgnore),m_Path(nilIgnore),m_OS(nilIgnore),m_Names(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("DeleteDropZoneFilesRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CDeleteDropZoneFilesRequest::CDeleteDropZoneFilesRequest(const char *serviceName, const char *bc)
	: m_DropZoneName(nilIgnore),m_NetAddress(nilIgnore),m_Path(nilIgnore),m_OS(nilIgnore),m_Names(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("DeleteDropZoneFilesRequest");
}

CDeleteDropZoneFilesRequest::CDeleteDropZoneFilesRequest(const char *serviceName, IRpcMessage* rpcmsg)
	: m_DropZoneName(nilIgnore),m_NetAddress(nilIgnore),m_Path(nilIgnore),m_OS(nilIgnore),m_Names(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("DeleteDropZoneFilesRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CDeleteDropZoneFilesRequest::CDeleteDropZoneFilesRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_DropZoneName(nilIgnore),m_NetAddress(nilIgnore),m_Path(nilIgnore),m_OS(nilIgnore),m_Names(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("DeleteDropZoneFilesRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CDeleteDropZoneFilesRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		if (!context.suppressed("DeleteDropZoneFilesRequest","DropZoneName")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"DropZoneName\" type=\"xsd:string\"/>\n");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"NetAddress\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Path\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"OS\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Names\" type=\"tns:EspStringArray\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	if (added.getValue("EspStringArray")==NULL) {
		addEspNativeArray(schema,"string","EspStringArray");
		added.setValue("EspStringArray",1);
	}
	return schema;
}

void CDeleteDropZoneFilesRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CDeleteDropZoneFilesRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
	info.addMinVersion("DeleteDropZoneFilesRequest","DropZoneName",1.15);
}

StringBuffer &CDeleteDropZoneFilesRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	if (!context.suppressed("DeleteDropZoneFilesRequest","DropZoneName")) {
		extfix.clear();
		if (prefix && *prefix)
			extfix.append(prefix).append(".");
		extfix.append("DropZoneName");
		form.appendf("  <tr><td><b>DropZoneName: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
		form.append("</td></tr>\n");
	}
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("NetAddress");
	form.appendf("  <tr><td><b>NetAddress: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Path");
	form.appendf("  <tr><td><b>Path: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("OS");
	form.appendf("  <tr><td><b>OS: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Names");
	form.appendf("<tr><td><b>Names: </b></td><td>");
	form.appendf("<textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea>", extfix.str());
	form.append("</td></tr>");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CDeleteDropZoneFilesRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CDeleteDropZoneFilesRequest::serialize(IRpcMessage& rpc_resp)
{
	IEspContext* ctx = rpc_resp.queryContext();
	double clientVer= ctx ? ctx->getClientVersion() : -1; /* no context gets everything */
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	if ((clientVer==-1.0 || clientVer>=1.15))
		m_DropZoneName.marshall(rpc_resp, "DropZoneName", "", "", "");
	m_NetAddress.marshall(rpc_resp, "NetAddress", "", "", "");
	m_Path.marshall(rpc_resp, "Path", "", "", "");
	m_OS.marshall(rpc_resp, "OS", "", "", "");
	m_Names.marshall(rpc_resp, "Names", "Item");
}


void CDeleteDropZoneFilesRequest::copy(CDeleteDropZoneFilesRequest &from)
{
	m_DropZoneName.copy(from.m_DropZoneName);
	m_NetAddress.copy(from.m_NetAddress);
	m_Path.copy(from.m_Path);
	m_OS.copy(from.m_OS);
	m_Names.copy(from.m_Names);
}


void CDeleteDropZoneFilesRequest::copy(IConstDeleteDropZoneFilesRequest &ifrom)
{
	setDropZoneName(ifrom.getDropZoneName());
	setNetAddress(ifrom.getNetAddress());
	setPath(ifrom.getPath());
	setOS(ifrom.getOS());
	setNames(ifrom.getNames());
}


void CDeleteDropZoneFilesRequest::getAttributes(IProperties &attributes)
{
}


void CDeleteDropZoneFilesRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	double clientVer = ctx ? ctx->getClientVersion() : -1;
	if ((clientVer==-1.0 || clientVer>=1.15))
		m_DropZoneName.toStr(ctx, buffer, "DropZoneName", "", true, "", "");
	m_NetAddress.toStr(ctx, buffer, "NetAddress", "", true, "", "");
	m_Path.toStr(ctx, buffer, "Path", "", true, "", "");
	m_OS.toStr(ctx, buffer, "OS", "", true, "", "");
	m_Names.toStr(ctx, buffer, "Names", "Item");
}


void CDeleteDropZoneFilesRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CDeleteDropZoneFilesRequest::serializer(IEspContext* ctx, IConstDeleteDropZoneFilesRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<DeleteDropZoneFilesRequest>");
	double clientVer = ctx ? ctx->getClientVersion() : -1;
	// field DropZoneName
	if ((clientVer==-1.0 || clientVer>=1.15))
	{
		const char* s = src.getDropZoneName();
		if (s && *s)
		{
			buffer.append("<DropZoneName>");
			encodeUtf8XML(s,buffer);
			buffer.append("</DropZoneName>");
		}
	}
	// field NetAddress
	{
		const char* s = src.getNetAddress();
		if (s && *s)
		{
			buffer.append("<NetAddress>");
			encodeUtf8XML(s,buffer);
			buffer.append("</NetAddress>");
		}
	}
	// field Path
	{
		const char* s = src.getPath();
		if (s && *s)
		{
			buffer.append("<Path>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Path>");
		}
	}
	// field OS
	{
		const char* s = src.getOS();
		if (s && *s)
		{
			buffer.append("<OS>");
			encodeUtf8XML(s,buffer);
			buffer.append("</OS>");
		}
	}
	// field Names
	{
		StringArray& v = src.getNames();
		if (v.length()>0)
			buffer.append("<Names>");
		for (size32_t i=0;i<v.length();i++)
			buffer.appendf("<Item>%s</Item>",v.item(i));
		if (v.length()>0)
			buffer.append("</Names>");
	}
	if (keepRootTag)
		buffer.append("</DeleteDropZoneFilesRequest>");
}

bool CDeleteDropZoneFilesRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_DropZoneName.unmarshall(rpc_request, "DropZoneName", basepath);
	hasValue |= m_NetAddress.unmarshall(rpc_request, "NetAddress", basepath);
	hasValue |= m_Path.unmarshall(rpc_request, "Path", basepath);
	hasValue |= m_OS.unmarshall(rpc_request, "OS", basepath);
	hasValue |= m_Names.unmarshall(rpc_request, "Names", basepath);
	return hasValue;
}

bool CDeleteDropZoneFilesRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_DropZoneName.unmarshall(ctx, soapval, "DropZoneName");
	hasValue |= m_NetAddress.unmarshall(ctx, soapval, "NetAddress");
	hasValue |= m_Path.unmarshall(ctx, soapval, "Path");
	hasValue |= m_OS.unmarshall(ctx, soapval, "OS");
	hasValue |= m_Names.unmarshall(ctx, soapval, "Names");
	return hasValue;
}

bool CDeleteDropZoneFilesRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_DropZoneName.unmarshall(ctx, params, attachments, "DropZoneName", basepath);
	hasValue |= m_NetAddress.unmarshall(ctx, params, attachments, "NetAddress", basepath);
	hasValue |= m_Path.unmarshall(ctx, params, attachments, "Path", basepath);
	hasValue |= m_OS.unmarshall(ctx, params, attachments, "OS", basepath);
	hasValue |= m_Names.unmarshall(ctx, params, attachments, "Names", basepath);
	return hasValue;
}

const char * CDeleteDropZoneFilesRequest::getDropZoneName() { return m_DropZoneName.query();}
const char * CDeleteDropZoneFilesRequest::getNetAddress() { return m_NetAddress.query();}
const char * CDeleteDropZoneFilesRequest::getPath() { return m_Path.query();}
const char * CDeleteDropZoneFilesRequest::getOS() { return m_OS.query();}
StringArray & CDeleteDropZoneFilesRequest::getNames() { return (StringArray &) m_Names; }
void CDeleteDropZoneFilesRequest::setDropZoneName(const char * val){ m_DropZoneName.set(val); }
void CDeleteDropZoneFilesRequest::setNetAddress(const char * val){ m_NetAddress.set(val); }
void CDeleteDropZoneFilesRequest::setPath(const char * val){ m_Path.set(val); }
void CDeleteDropZoneFilesRequest::setOS(const char * val){ m_OS.set(val); }
void CDeleteDropZoneFilesRequest::setNames(StringArray &val){ m_Names->kill();  CloneArray(m_Names.getValue(), val); }
extern "C"  IEspDeleteDropZoneFilesRequest *createDeleteDropZoneFilesRequest(const char *serv){return ((IEspDeleteDropZoneFilesRequest *)new CDeleteDropZoneFilesRequest(serv));}
extern "C"  IClientDeleteDropZoneFilesRequest *createClientDeleteDropZoneFilesRequest(const char *serv){return ((IClientDeleteDropZoneFilesRequest *)new CDeleteDropZoneFilesRequest(serv));}

//=======================================================
// class CDeleteDropZoneFilesResponse Implementation
//=======================================================

CDeleteDropZoneFilesResponse::CDeleteDropZoneFilesResponse(const char *serviceName, IRpcMessageBinding *init)
	: m_DFUActionResults(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("DeleteDropZoneFilesResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CDeleteDropZoneFilesResponse::CDeleteDropZoneFilesResponse(const char *serviceName, const char *bc)
	: m_DFUActionResults(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("DeleteDropZoneFilesResponse");
}

CDeleteDropZoneFilesResponse::CDeleteDropZoneFilesResponse(const char *serviceName, IRpcMessage* rpcmsg)
	: m_DFUActionResults(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("DeleteDropZoneFilesResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CDeleteDropZoneFilesResponse::CDeleteDropZoneFilesResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_DFUActionResults(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("DeleteDropZoneFilesResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CDeleteDropZoneFilesResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		schema.append("<xsd:element name=\"Exceptions\" type=\"tns:ArrayOfEspException\" minOccurs=\"0\" maxOccurs=\"1\"/>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"DFUActionResults\" type=\"tns:ArrayOfDFUActionResult\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	if (!(flags & 0x10)  || (flags & 0x100))
	{
		CDFUActionResult::getXsdDefinition(context, request, schema, added);
	}
	if (added.getValue("DFUActionResult") && added.getValue("ArrayOfDFUActionResult")==NULL) {
		schema.append("<xsd:complexType name=\"ArrayOfDFUActionResult\">\n");
		schema.append("<xsd:sequence>\n");
		schema.append("<xsd:element minOccurs=\"0\" maxOccurs=\"unbounded\" name=\"DFUActionResult\" type=\"tns:DFUActionResult\"/>\n");
		schema.append("</xsd:sequence>\n");
		schema.append("</xsd:complexType>\n");
		added.setValue("ArrayOfDFUActionResult",1);
	}
	return schema;
}

void CDeleteDropZoneFilesResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CDeleteDropZoneFilesResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
	if (!added.getValue("DFUActionResult"))
	{
		added.setValue("DFUActionResult",1);
		CDFUActionResult::getMapInfo(info,added);
	}
}

StringBuffer &CDeleteDropZoneFilesResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("DFUActionResults");
	form.appendf("<tr><td><b>DFUActionResults: </b></td><td>");
	form.appendf("<table><tr><td><textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea></td>", extfix.str());
	form.append("</tr></table>");
	form.append("</td></tr>");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CDeleteDropZoneFilesResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CDeleteDropZoneFilesResponse::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
		m_DFUActionResults.marshall(rpc_resp, "DFUActionResults", "DFUActionResult");
	}
}


void CDeleteDropZoneFilesResponse::copy(CDeleteDropZoneFilesResponse &from)
{
	m_DFUActionResults.copy(from.m_DFUActionResults);
}


void CDeleteDropZoneFilesResponse::copy(IConstDeleteDropZoneFilesResponse &ifrom)
{
	setDFUActionResults(ifrom.getDFUActionResults());
}


void CDeleteDropZoneFilesResponse::getAttributes(IProperties &attributes)
{
}


void CDeleteDropZoneFilesResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
		m_DFUActionResults.toStr(ctx, buffer, "DFUActionResults", "DFUActionResult");
	}
}


void CDeleteDropZoneFilesResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CDeleteDropZoneFilesResponse::serializer(IEspContext* ctx, IConstDeleteDropZoneFilesResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<DeleteDropZoneFilesResponse>");
	// field DFUActionResults
	{
		IArrayOf<IConstDFUActionResult>& v = src.getDFUActionResults();
		int size = v.length();
		if (size>0)
			buffer.append("<DFUActionResults>");
		for (int i=0;i<size;i++)
		{
			buffer.append("<Item>");
			CDFUActionResult::serializer(ctx,v.item(i),buffer,false);
			buffer.append("</Item>");
		}
		if (size>0)
			buffer.append("</DFUActionResults>");
	}
	if (keepRootTag)
		buffer.append("</DeleteDropZoneFilesResponse>");
}

bool CDeleteDropZoneFilesResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
		hasValue |= m_DFUActionResults.unmarshall(rpc_request, "DFUActionResults", basepath);
	}
	return hasValue;
}

bool CDeleteDropZoneFilesResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_DFUActionResults.unmarshall(ctx, soapval, "DFUActionResults");
	return hasValue;
}

bool CDeleteDropZoneFilesResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_DFUActionResults.unmarshall(ctx, params, attachments, "DFUActionResults", basepath);
	return hasValue;
}

IArrayOf<IConstDFUActionResult> & CDeleteDropZoneFilesResponse::getDFUActionResults() { return (IArrayOf<IConstDFUActionResult> &) m_DFUActionResults; }
void CDeleteDropZoneFilesResponse::setDFUActionResults(IArrayOf<IEspDFUActionResult> &val)
{
	m_DFUActionResults->kill();
	IArrayOf<IConstDFUActionResult> &target = m_DFUActionResults.getValue();
	ForEachItemIn(idx, val)
	{
		IEspDFUActionResult &item = (val).item(idx);
		item.Link();
		target.append(item);
	}
}
void CDeleteDropZoneFilesResponse::setDFUActionResults(IArrayOf<IConstDFUActionResult> &val)
{
	m_DFUActionResults->kill();
	IArrayOf<IConstDFUActionResult> &target = m_DFUActionResults.getValue();
	ForEachItemIn(idx, val)
	{
		IConstDFUActionResult &item = val.item(idx);
		item.Link();
		target.append(item);
	}
}
extern "C"  IEspDeleteDropZoneFilesResponse *createDeleteDropZoneFilesResponse(const char *serv){return ((IEspDeleteDropZoneFilesResponse *)new CDeleteDropZoneFilesResponse(serv));}
extern "C"  IClientDeleteDropZoneFilesResponse *createClientDeleteDropZoneFilesResponse(const char *serv){return ((IClientDeleteDropZoneFilesResponse *)new CDeleteDropZoneFilesResponse(serv));}

//=======================================================
// class CUploadFilesResponse Implementation
//=======================================================

CUploadFilesResponse::CUploadFilesResponse(const char *serviceName, IRpcMessageBinding *init)
	: m_UploadFileResults(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("UploadFilesResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CUploadFilesResponse::CUploadFilesResponse(const char *serviceName, const char *bc)
	: m_UploadFileResults(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("UploadFilesResponse");
}

CUploadFilesResponse::CUploadFilesResponse(const char *serviceName, IRpcMessage* rpcmsg)
	: m_UploadFileResults(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("UploadFilesResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CUploadFilesResponse::CUploadFilesResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_UploadFileResults(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("UploadFilesResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CUploadFilesResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		schema.append("<xsd:element name=\"Exceptions\" type=\"tns:ArrayOfEspException\" minOccurs=\"0\" maxOccurs=\"1\"/>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"UploadFileResults\" type=\"tns:ArrayOfDFUActionResult\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	if (!(flags & 0x10)  || (flags & 0x100))
	{
		CDFUActionResult::getXsdDefinition(context, request, schema, added);
	}
	if (added.getValue("DFUActionResult") && added.getValue("ArrayOfDFUActionResult")==NULL) {
		schema.append("<xsd:complexType name=\"ArrayOfDFUActionResult\">\n");
		schema.append("<xsd:sequence>\n");
		schema.append("<xsd:element minOccurs=\"0\" maxOccurs=\"unbounded\" name=\"DFUActionResult\" type=\"tns:DFUActionResult\"/>\n");
		schema.append("</xsd:sequence>\n");
		schema.append("</xsd:complexType>\n");
		added.setValue("ArrayOfDFUActionResult",1);
	}
	return schema;
}

void CUploadFilesResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CUploadFilesResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
	if (!added.getValue("DFUActionResult"))
	{
		added.setValue("DFUActionResult",1);
		CDFUActionResult::getMapInfo(info,added);
	}
}

StringBuffer &CUploadFilesResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("UploadFileResults");
	form.appendf("<tr><td><b>UploadFileResults: </b></td><td>");
	form.appendf("<table><tr><td><textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea></td>", extfix.str());
	form.append("</tr></table>");
	form.append("</td></tr>");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CUploadFilesResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CUploadFilesResponse::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
		m_UploadFileResults.marshall(rpc_resp, "UploadFileResults", "DFUActionResult");
	}
}


void CUploadFilesResponse::copy(CUploadFilesResponse &from)
{
	m_UploadFileResults.copy(from.m_UploadFileResults);
}


void CUploadFilesResponse::copy(IConstUploadFilesResponse &ifrom)
{
	setUploadFileResults(ifrom.getUploadFileResults());
}


void CUploadFilesResponse::getAttributes(IProperties &attributes)
{
}


void CUploadFilesResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
		m_UploadFileResults.toStr(ctx, buffer, "UploadFileResults", "DFUActionResult");
	}
}


void CUploadFilesResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CUploadFilesResponse::serializer(IEspContext* ctx, IConstUploadFilesResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<UploadFilesResponse>");
	// field UploadFileResults
	{
		IArrayOf<IConstDFUActionResult>& v = src.getUploadFileResults();
		int size = v.length();
		if (size>0)
			buffer.append("<UploadFileResults>");
		for (int i=0;i<size;i++)
		{
			buffer.append("<Item>");
			CDFUActionResult::serializer(ctx,v.item(i),buffer,false);
			buffer.append("</Item>");
		}
		if (size>0)
			buffer.append("</UploadFileResults>");
	}
	if (keepRootTag)
		buffer.append("</UploadFilesResponse>");
}

bool CUploadFilesResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
		hasValue |= m_UploadFileResults.unmarshall(rpc_request, "UploadFileResults", basepath);
	}
	return hasValue;
}

bool CUploadFilesResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_UploadFileResults.unmarshall(ctx, soapval, "UploadFileResults");
	return hasValue;
}

bool CUploadFilesResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_UploadFileResults.unmarshall(ctx, params, attachments, "UploadFileResults", basepath);
	return hasValue;
}

IArrayOf<IConstDFUActionResult> & CUploadFilesResponse::getUploadFileResults() { return (IArrayOf<IConstDFUActionResult> &) m_UploadFileResults; }
void CUploadFilesResponse::setUploadFileResults(IArrayOf<IEspDFUActionResult> &val)
{
	m_UploadFileResults->kill();
	IArrayOf<IConstDFUActionResult> &target = m_UploadFileResults.getValue();
	ForEachItemIn(idx, val)
	{
		IEspDFUActionResult &item = (val).item(idx);
		item.Link();
		target.append(item);
	}
}
void CUploadFilesResponse::setUploadFileResults(IArrayOf<IConstDFUActionResult> &val)
{
	m_UploadFileResults->kill();
	IArrayOf<IConstDFUActionResult> &target = m_UploadFileResults.getValue();
	ForEachItemIn(idx, val)
	{
		IConstDFUActionResult &item = val.item(idx);
		item.Link();
		target.append(item);
	}
}
extern "C"  IEspUploadFilesResponse *createUploadFilesResponse(const char *serv){return ((IEspUploadFilesResponse *)new CUploadFilesResponse(serv));}
extern "C"  IClientUploadFilesResponse *createClientUploadFilesResponse(const char *serv){return ((IClientUploadFilesResponse *)new CUploadFilesResponse(serv));}

//=======================================================
// class CGetSprayTargetsRequest Implementation
//=======================================================

CGetSprayTargetsRequest::CGetSprayTargetsRequest(const char *serviceName, IRpcMessageBinding *init)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetSprayTargetsRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CGetSprayTargetsRequest::CGetSprayTargetsRequest(const char *serviceName, const char *bc)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetSprayTargetsRequest");
}

CGetSprayTargetsRequest::CGetSprayTargetsRequest(const char *serviceName, IRpcMessage* rpcmsg)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetSprayTargetsRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CGetSprayTargetsRequest::CGetSprayTargetsRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetSprayTargetsRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CGetSprayTargetsRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType><xsd:all/></xsd:complexType></xsd:element>\n", msgTypeName);
		}
	}
	return schema;
}

void CGetSprayTargetsRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CGetSprayTargetsRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CGetSprayTargetsRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CGetSprayTargetsRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CGetSprayTargetsRequest::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

}


void CGetSprayTargetsRequest::copy(CGetSprayTargetsRequest &from)
{
}


void CGetSprayTargetsRequest::copy(IConstGetSprayTargetsRequest &ifrom)
{
}


void CGetSprayTargetsRequest::getAttributes(IProperties &attributes)
{
}


void CGetSprayTargetsRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
}


void CGetSprayTargetsRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CGetSprayTargetsRequest::serializer(IEspContext* ctx, IConstGetSprayTargetsRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<GetSprayTargetsRequest>");
	if (keepRootTag)
		buffer.append("</GetSprayTargetsRequest>");
}

bool CGetSprayTargetsRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	return hasValue;
}

bool CGetSprayTargetsRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	return hasValue;
}

bool CGetSprayTargetsRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	return hasValue;
}

extern "C"  IEspGetSprayTargetsRequest *createGetSprayTargetsRequest(const char *serv){return ((IEspGetSprayTargetsRequest *)new CGetSprayTargetsRequest(serv));}
extern "C"  IClientGetSprayTargetsRequest *createClientGetSprayTargetsRequest(const char *serv){return ((IClientGetSprayTargetsRequest *)new CGetSprayTargetsRequest(serv));}

//=======================================================
// class CGetSprayTargetsResponse Implementation
//=======================================================

CGetSprayTargetsResponse::CGetSprayTargetsResponse(const char *serviceName, IRpcMessageBinding *init)
	: m_GroupNodes(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetSprayTargetsResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CGetSprayTargetsResponse::CGetSprayTargetsResponse(const char *serviceName, const char *bc)
	: m_GroupNodes(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetSprayTargetsResponse");
}

CGetSprayTargetsResponse::CGetSprayTargetsResponse(const char *serviceName, IRpcMessage* rpcmsg)
	: m_GroupNodes(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetSprayTargetsResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CGetSprayTargetsResponse::CGetSprayTargetsResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_GroupNodes(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetSprayTargetsResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CGetSprayTargetsResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		schema.append("<xsd:element name=\"Exceptions\" type=\"tns:ArrayOfEspException\" minOccurs=\"0\" maxOccurs=\"1\"/>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"GroupNodes\">\n");
		schema.append("<xsd:complexType><xsd:sequence>\n");
		schema.append("<xsd:element minOccurs=\"0\" maxOccurs=\"unbounded\" name=\"GroupNode\" type=\"tns:GroupNode\"/>");
		schema.append("</xsd:sequence></xsd:complexType>");
		schema.append("</xsd:element>");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	if (!(flags & 0x10)  || (flags & 0x100))
	{
		CGroupNode::getXsdDefinition(context, request, schema, added);
	}
	return schema;
}

void CGetSprayTargetsResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CGetSprayTargetsResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
	if (!added.getValue("GroupNode"))
	{
		added.setValue("GroupNode",1);
		CGroupNode::getMapInfo(info,added);
	}
}

StringBuffer &CGetSprayTargetsResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("GroupNodes");
	form.appendf("<tr><td><b>GroupNodes: </b></td><td>");
	form.appendf("<table><tr><td><textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea></td>", extfix.str());
	form.append("</tr></table>");
	form.append("</td></tr>");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CGetSprayTargetsResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CGetSprayTargetsResponse::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
		m_GroupNodes.marshall(rpc_resp, "GroupNodes", "GroupNode");
	}
}


void CGetSprayTargetsResponse::copy(CGetSprayTargetsResponse &from)
{
	m_GroupNodes.copy(from.m_GroupNodes);
}


void CGetSprayTargetsResponse::copy(IConstGetSprayTargetsResponse &ifrom)
{
	setGroupNodes(ifrom.getGroupNodes());
}


void CGetSprayTargetsResponse::getAttributes(IProperties &attributes)
{
}


void CGetSprayTargetsResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
		m_GroupNodes.toStr(ctx, buffer, "GroupNodes", "GroupNode");
	}
}


void CGetSprayTargetsResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CGetSprayTargetsResponse::serializer(IEspContext* ctx, IConstGetSprayTargetsResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<GetSprayTargetsResponse>");
	// field GroupNodes
	{
		IArrayOf<IConstGroupNode>& v = src.getGroupNodes();
		int size = v.length();
		if (size>0)
			buffer.append("<GroupNodes>");
		for (int i=0;i<size;i++)
		{
			buffer.append("<GroupNode>");
			CGroupNode::serializer(ctx,v.item(i),buffer,false);
			buffer.append("</GroupNode>");
		}
		if (size>0)
			buffer.append("</GroupNodes>");
	}
	if (keepRootTag)
		buffer.append("</GetSprayTargetsResponse>");
}

bool CGetSprayTargetsResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
		hasValue |= m_GroupNodes.unmarshall(rpc_request, "GroupNodes", basepath);
	}
	return hasValue;
}

bool CGetSprayTargetsResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_GroupNodes.unmarshall(ctx, soapval, "GroupNodes");
	return hasValue;
}

bool CGetSprayTargetsResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_GroupNodes.unmarshall(ctx, params, attachments, "GroupNodes", basepath);
	return hasValue;
}

IArrayOf<IConstGroupNode> & CGetSprayTargetsResponse::getGroupNodes() { return (IArrayOf<IConstGroupNode> &) m_GroupNodes; }
void CGetSprayTargetsResponse::setGroupNodes(IArrayOf<IEspGroupNode> &val)
{
	m_GroupNodes->kill();
	IArrayOf<IConstGroupNode> &target = m_GroupNodes.getValue();
	ForEachItemIn(idx, val)
	{
		IEspGroupNode &item = (val).item(idx);
		item.Link();
		target.append(item);
	}
}
void CGetSprayTargetsResponse::setGroupNodes(IArrayOf<IConstGroupNode> &val)
{
	m_GroupNodes->kill();
	IArrayOf<IConstGroupNode> &target = m_GroupNodes.getValue();
	ForEachItemIn(idx, val)
	{
		IConstGroupNode &item = val.item(idx);
		item.Link();
		target.append(item);
	}
}
extern "C"  IEspGetSprayTargetsResponse *createGetSprayTargetsResponse(const char *serv){return ((IEspGetSprayTargetsResponse *)new CGetSprayTargetsResponse(serv));}
extern "C"  IClientGetSprayTargetsResponse *createClientGetSprayTargetsResponse(const char *serv){return ((IClientGetSprayTargetsResponse *)new CGetSprayTargetsResponse(serv));}

//=======================================================
// class CGetDFUServerQueuesRequest Implementation
//=======================================================

CGetDFUServerQueuesRequest::CGetDFUServerQueuesRequest(const char *serviceName, IRpcMessageBinding *init)
	: m_DFUServerName(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetDFUServerQueuesRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CGetDFUServerQueuesRequest::CGetDFUServerQueuesRequest(const char *serviceName, const char *bc)
	: m_DFUServerName(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetDFUServerQueuesRequest");
}

CGetDFUServerQueuesRequest::CGetDFUServerQueuesRequest(const char *serviceName, IRpcMessage* rpcmsg)
	: m_DFUServerName(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetDFUServerQueuesRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CGetDFUServerQueuesRequest::CGetDFUServerQueuesRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_DFUServerName(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetDFUServerQueuesRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CGetDFUServerQueuesRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"DFUServerName\" type=\"xsd:string\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CGetDFUServerQueuesRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CGetDFUServerQueuesRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CGetDFUServerQueuesRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("DFUServerName");
	form.appendf("  <tr><td><b>DFUServerName: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CGetDFUServerQueuesRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CGetDFUServerQueuesRequest::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_DFUServerName.marshall(rpc_resp, "DFUServerName", "", "", "");
}


void CGetDFUServerQueuesRequest::copy(CGetDFUServerQueuesRequest &from)
{
	m_DFUServerName.copy(from.m_DFUServerName);
}


void CGetDFUServerQueuesRequest::copy(IConstGetDFUServerQueuesRequest &ifrom)
{
	setDFUServerName(ifrom.getDFUServerName());
}


void CGetDFUServerQueuesRequest::getAttributes(IProperties &attributes)
{
}


void CGetDFUServerQueuesRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_DFUServerName.toStr(ctx, buffer, "DFUServerName", "", true, "", "");
}


void CGetDFUServerQueuesRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CGetDFUServerQueuesRequest::serializer(IEspContext* ctx, IConstGetDFUServerQueuesRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<GetDFUServerQueuesRequest>");
	// field DFUServerName
	{
		const char* s = src.getDFUServerName();
		if (s && *s)
		{
			buffer.append("<DFUServerName>");
			encodeUtf8XML(s,buffer);
			buffer.append("</DFUServerName>");
		}
	}
	if (keepRootTag)
		buffer.append("</GetDFUServerQueuesRequest>");
}

bool CGetDFUServerQueuesRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_DFUServerName.unmarshall(rpc_request, "DFUServerName", basepath);
	return hasValue;
}

bool CGetDFUServerQueuesRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_DFUServerName.unmarshall(ctx, soapval, "DFUServerName");
	return hasValue;
}

bool CGetDFUServerQueuesRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_DFUServerName.unmarshall(ctx, params, attachments, "DFUServerName", basepath);
	return hasValue;
}

const char * CGetDFUServerQueuesRequest::getDFUServerName() { return m_DFUServerName.query();}
void CGetDFUServerQueuesRequest::setDFUServerName(const char * val){ m_DFUServerName.set(val); }
extern "C"  IEspGetDFUServerQueuesRequest *createGetDFUServerQueuesRequest(const char *serv){return ((IEspGetDFUServerQueuesRequest *)new CGetDFUServerQueuesRequest(serv));}
extern "C"  IClientGetDFUServerQueuesRequest *createClientGetDFUServerQueuesRequest(const char *serv){return ((IClientGetDFUServerQueuesRequest *)new CGetDFUServerQueuesRequest(serv));}

//=======================================================
// class CGetDFUServerQueuesResponse Implementation
//=======================================================

CGetDFUServerQueuesResponse::CGetDFUServerQueuesResponse(const char *serviceName, IRpcMessageBinding *init)
	: m_Names(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetDFUServerQueuesResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CGetDFUServerQueuesResponse::CGetDFUServerQueuesResponse(const char *serviceName, const char *bc)
	: m_Names(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetDFUServerQueuesResponse");
}

CGetDFUServerQueuesResponse::CGetDFUServerQueuesResponse(const char *serviceName, IRpcMessage* rpcmsg)
	: m_Names(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetDFUServerQueuesResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CGetDFUServerQueuesResponse::CGetDFUServerQueuesResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_Names(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetDFUServerQueuesResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CGetDFUServerQueuesResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		schema.append("<xsd:element name=\"Exceptions\" type=\"tns:ArrayOfEspException\" minOccurs=\"0\" maxOccurs=\"1\"/>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Names\" type=\"tns:EspStringArray\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	if (added.getValue("EspStringArray")==NULL) {
		addEspNativeArray(schema,"string","EspStringArray");
		added.setValue("EspStringArray",1);
	}
	return schema;
}

void CGetDFUServerQueuesResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CGetDFUServerQueuesResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CGetDFUServerQueuesResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Names");
	form.appendf("<tr><td><b>Names: </b></td><td>");
	form.appendf("<textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea>", extfix.str());
	form.append("</td></tr>");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CGetDFUServerQueuesResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CGetDFUServerQueuesResponse::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
		m_Names.marshall(rpc_resp, "Names", "Item");
	}
}


void CGetDFUServerQueuesResponse::copy(CGetDFUServerQueuesResponse &from)
{
	m_Names.copy(from.m_Names);
}


void CGetDFUServerQueuesResponse::copy(IConstGetDFUServerQueuesResponse &ifrom)
{
	setNames(ifrom.getNames());
}


void CGetDFUServerQueuesResponse::getAttributes(IProperties &attributes)
{
}


void CGetDFUServerQueuesResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
		m_Names.toStr(ctx, buffer, "Names", "Item");
	}
}


void CGetDFUServerQueuesResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CGetDFUServerQueuesResponse::serializer(IEspContext* ctx, IConstGetDFUServerQueuesResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<GetDFUServerQueuesResponse>");
	// field Names
	{
		StringArray& v = src.getNames();
		if (v.length()>0)
			buffer.append("<Names>");
		for (size32_t i=0;i<v.length();i++)
			buffer.appendf("<Item>%s</Item>",v.item(i));
		if (v.length()>0)
			buffer.append("</Names>");
	}
	if (keepRootTag)
		buffer.append("</GetDFUServerQueuesResponse>");
}

bool CGetDFUServerQueuesResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
		hasValue |= m_Names.unmarshall(rpc_request, "Names", basepath);
	}
	return hasValue;
}

bool CGetDFUServerQueuesResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Names.unmarshall(ctx, soapval, "Names");
	return hasValue;
}

bool CGetDFUServerQueuesResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Names.unmarshall(ctx, params, attachments, "Names", basepath);
	return hasValue;
}

StringArray & CGetDFUServerQueuesResponse::getNames() { return (StringArray &) m_Names; }
void CGetDFUServerQueuesResponse::setNames(StringArray &val){ m_Names->kill();  CloneArray(m_Names.getValue(), val); }
extern "C"  IEspGetDFUServerQueuesResponse *createGetDFUServerQueuesResponse(const char *serv){return ((IEspGetDFUServerQueuesResponse *)new CGetDFUServerQueuesResponse(serv));}
extern "C"  IClientGetDFUServerQueuesResponse *createClientGetDFUServerQueuesResponse(const char *serv){return ((IClientGetDFUServerQueuesResponse *)new CGetDFUServerQueuesResponse(serv));}

//=======================================================
// class CFileSprayPingRequest Implementation
//=======================================================

CFileSprayPingRequest::CFileSprayPingRequest(const char *serviceName, IRpcMessageBinding *init)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("FileSprayPingRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CFileSprayPingRequest::CFileSprayPingRequest(const char *serviceName, const char *bc)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("FileSprayPingRequest");
}

CFileSprayPingRequest::CFileSprayPingRequest(const char *serviceName, IRpcMessage* rpcmsg)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("FileSprayPingRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CFileSprayPingRequest::CFileSprayPingRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("FileSprayPingRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CFileSprayPingRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType><xsd:all/></xsd:complexType></xsd:element>\n", msgTypeName);
		}
	}
	return schema;
}

void CFileSprayPingRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CFileSprayPingRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CFileSprayPingRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CFileSprayPingRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CFileSprayPingRequest::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

}


void CFileSprayPingRequest::copy(CFileSprayPingRequest &from)
{
}


void CFileSprayPingRequest::copy(IConstFileSprayPingRequest &ifrom)
{
}


void CFileSprayPingRequest::getAttributes(IProperties &attributes)
{
}


void CFileSprayPingRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
}


void CFileSprayPingRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CFileSprayPingRequest::serializer(IEspContext* ctx, IConstFileSprayPingRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<FileSprayPingRequest>");
	if (keepRootTag)
		buffer.append("</FileSprayPingRequest>");
}

bool CFileSprayPingRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	return hasValue;
}

bool CFileSprayPingRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	return hasValue;
}

bool CFileSprayPingRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	return hasValue;
}

extern "C"  IEspFileSprayPingRequest *createFileSprayPingRequest(const char *serv){return ((IEspFileSprayPingRequest *)new CFileSprayPingRequest(serv));}
extern "C"  IClientFileSprayPingRequest *createClientFileSprayPingRequest(const char *serv){return ((IClientFileSprayPingRequest *)new CFileSprayPingRequest(serv));}

//=======================================================
// class CFileSprayPingResponse Implementation
//=======================================================

CFileSprayPingResponse::CFileSprayPingResponse(const char *serviceName, IRpcMessageBinding *init)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("FileSprayPingResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CFileSprayPingResponse::CFileSprayPingResponse(const char *serviceName, const char *bc)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("FileSprayPingResponse");
}

CFileSprayPingResponse::CFileSprayPingResponse(const char *serviceName, IRpcMessage* rpcmsg)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("FileSprayPingResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CFileSprayPingResponse::CFileSprayPingResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("FileSprayPingResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CFileSprayPingResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType><xsd:all/></xsd:complexType></xsd:element>\n", msgTypeName);
		}
	}
	return schema;
}

void CFileSprayPingResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CFileSprayPingResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CFileSprayPingResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CFileSprayPingResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CFileSprayPingResponse::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
	}
}


void CFileSprayPingResponse::copy(CFileSprayPingResponse &from)
{
}


void CFileSprayPingResponse::copy(IConstFileSprayPingResponse &ifrom)
{
}


void CFileSprayPingResponse::getAttributes(IProperties &attributes)
{
}


void CFileSprayPingResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
	}
}


void CFileSprayPingResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CFileSprayPingResponse::serializer(IEspContext* ctx, IConstFileSprayPingResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<FileSprayPingResponse>");
	if (keepRootTag)
		buffer.append("</FileSprayPingResponse>");
}

bool CFileSprayPingResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
	}
	return hasValue;
}

bool CFileSprayPingResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	return hasValue;
}

bool CFileSprayPingResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	return hasValue;
}

extern "C"  IEspFileSprayPingResponse *createFileSprayPingResponse(const char *serv){return ((IEspFileSprayPingResponse *)new CFileSprayPingResponse(serv));}
extern "C"  IClientFileSprayPingResponse *createClientFileSprayPingResponse(const char *serv){return ((IClientFileSprayPingResponse *)new CFileSprayPingResponse(serv));}

//=======================================================
// class CFileSpraySoapBinding Implementation
//=======================================================

CFileSpraySoapBinding::CFileSpraySoapBinding(http_soap_log_level level):CHttpSoapBinding(NULL, NULL, NULL, level)
{
	init_strings();
	setWsdlVersion(1.17);
}

CFileSpraySoapBinding::CFileSpraySoapBinding(IPropertyTree* cfg, const char *bindname, const char *procname, http_soap_log_level level):CHttpSoapBinding(cfg, bindname, procname, level)
{
	init_strings(); 
	setWsdlVersion(1.17);

}

void CFileSpraySoapBinding::init_strings()
{
}

int CFileSpraySoapBinding::processRequest(IRpcMessage* rpc_call, IRpcMessage* rpc_response)
{
	if(rpc_call == NULL || rpc_response == NULL)
		return -1;

	IEspContext *ctx=rpc_call->queryContext();
	DBGLOG("Client version: %g", ctx->getClientVersion());
	StringBuffer serviceName;
	double clientVer=(ctx) ? ctx->getClientVersion() : 0.0;
	qualifyServiceName(*ctx, ctx->queryServiceName(NULL), NULL, serviceName, NULL);
	CRpcCall* thecall = static_cast<CRpcCall *>(rpc_call);
	CRpcResponse* response = static_cast<CRpcResponse*>(rpc_response);
	CHttpRequest* httprequest = thecall->getHttpReq();
	CHttpResponse* httpresponse = response->getHttpResp();

	Owned<IEspFileSpray> iserv = (IEspFileSpray*)getService();
	if(iserv == NULL)
	{
		response->set_status(SOAP_SERVER_ERROR);
		response->set_err("Service not available");
		DBGLOG("Service not available");
		return -1;
	}
	if (thecall->get_name() == NULL)
	{
		response->set_status(SOAP_CLIENT_ERROR);
		response->set_err("No service method specified");
		ERRLOG("No service method specified");
		return -1;
	}

	IEspContext& context = *rpc_call->queryContext();

	if(!stricmp(thecall->get_name(), "AbortDFUWorkunit")||!stricmp(thecall->get_name(), "AbortDFUWorkunit"))
	{
		Owned<CAbortDFUWorkunit> esp_request = new CAbortDFUWorkunit(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CAbortDFUWorkunitResponse> esp_response = new CAbortDFUWorkunitResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		StringBuffer source;
		source.appendf("FileSpray::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "FileSpray", "AbortDFUWorkunit");
			iserv->onAbortDFUWorkunit(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "FileSpray", "AbortDFUWorkunit");
		response->set_name("AbortDFUWorkunitResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "Copy")||!stricmp(thecall->get_name(), "Copy"))
	{
		Owned<CCopy> esp_request = new CCopy(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CCopyResponse> esp_response = new CCopyResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		StringBuffer source;
		source.appendf("FileSpray::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "FileSpray", "Copy");
			iserv->onCopy(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "FileSpray", "Copy");
		response->set_name("CopyResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "CreateDFUWorkunit")||!stricmp(thecall->get_name(), "CreateDFUWorkunit"))
	{
		Owned<CCreateDFUWorkunit> esp_request = new CCreateDFUWorkunit(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CCreateDFUWorkunitResponse> esp_response = new CCreateDFUWorkunitResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		StringBuffer source;
		source.appendf("FileSpray::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "FileSpray", "CreateDFUWorkunit");
			iserv->onCreateDFUWorkunit(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "FileSpray", "CreateDFUWorkunit");
		response->set_name("CreateDFUWorkunitResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "DFUWUFile")||!stricmp(thecall->get_name(), "DFUWUFileRequest"))
	{
		Owned<CDFUWUFileRequest> esp_request = new CDFUWUFileRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CDFUWUFileResponse> esp_response = new CDFUWUFileResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		StringBuffer source;
		source.appendf("FileSpray::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "FileSpray", "DFUWUFile");
			iserv->onDFUWUFile(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "FileSpray", "DFUWUFile");
		response->set_name("DFUWUFileResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "DFUWUSearch")||!stricmp(thecall->get_name(), "DFUWUSearchRequest"))
	{
		Owned<CDFUWUSearchRequest> esp_request = new CDFUWUSearchRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CDFUWUSearchResponse> esp_response = new CDFUWUSearchResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		StringBuffer source;
		source.appendf("FileSpray::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "FileSpray", "DFUWUSearch");
			iserv->onDFUWUSearch(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "FileSpray", "DFUWUSearch");
		response->set_name("DFUWUSearchResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "DFUWorkunitsAction")||!stricmp(thecall->get_name(), "DFUWorkunitsActionRequest"))
	{
		Owned<CDFUWorkunitsActionRequest> esp_request = new CDFUWorkunitsActionRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CDFUWorkunitsActionResponse> esp_response = new CDFUWorkunitsActionResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		StringBuffer source;
		source.appendf("FileSpray::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "FileSpray", "DFUWorkunitsAction");
			iserv->onDFUWorkunitsAction(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "FileSpray", "DFUWorkunitsAction");
		response->set_name("DFUWorkunitsActionResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "DeleteDFUWorkunit")||!stricmp(thecall->get_name(), "DeleteDFUWorkunit"))
	{
		Owned<CDeleteDFUWorkunit> esp_request = new CDeleteDFUWorkunit(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CDeleteDFUWorkunitResponse> esp_response = new CDeleteDFUWorkunitResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		StringBuffer source;
		source.appendf("FileSpray::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "FileSpray", "DeleteDFUWorkunit");
			iserv->onDeleteDFUWorkunit(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "FileSpray", "DeleteDFUWorkunit");
		response->set_name("DeleteDFUWorkunitResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "DeleteDFUWorkunits")||!stricmp(thecall->get_name(), "DeleteDFUWorkunits"))
	{
		Owned<CDeleteDFUWorkunits> esp_request = new CDeleteDFUWorkunits(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CDeleteDFUWorkunitsResponse> esp_response = new CDeleteDFUWorkunitsResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		StringBuffer source;
		source.appendf("FileSpray::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "FileSpray", "DeleteDFUWorkunits");
			iserv->onDeleteDFUWorkunits(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "FileSpray", "DeleteDFUWorkunits");
		response->set_name("DeleteDFUWorkunitsResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "DeleteDropZoneFiles")||!stricmp(thecall->get_name(), "DeleteDropZoneFilesRequest"))
	{
		Owned<CDeleteDropZoneFilesRequest> esp_request = new CDeleteDropZoneFilesRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CDFUWorkunitsActionResponse> esp_response = new CDFUWorkunitsActionResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		StringBuffer source;
		source.appendf("FileSpray::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "FileSpray", "DeleteDropZoneFiles");
			iserv->onDeleteDropZoneFiles(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "FileSpray", "DeleteDropZoneFiles");
		response->set_name("DFUWorkunitsActionResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "Despray")||!stricmp(thecall->get_name(), "Despray"))
	{
		Owned<CDespray> esp_request = new CDespray(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CDesprayResponse> esp_response = new CDesprayResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		StringBuffer source;
		source.appendf("FileSpray::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "FileSpray", "Despray");
			iserv->onDespray(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "FileSpray", "Despray");
		response->set_name("DesprayResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "DfuMonitor")||!stricmp(thecall->get_name(), "DfuMonitorRequest"))
	{
		Owned<CDfuMonitorRequest> esp_request = new CDfuMonitorRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CDfuMonitorResponse> esp_response = new CDfuMonitorResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		StringBuffer source;
		source.appendf("FileSpray::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "FileSpray", "DfuMonitor");
			iserv->onDfuMonitor(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "FileSpray", "DfuMonitor");
		response->set_name("DfuMonitorResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "DropZoneFileSearch")||!stricmp(thecall->get_name(), "DropZoneFileSearchRequest"))
	{
		Owned<CDropZoneFileSearchRequest> esp_request = new CDropZoneFileSearchRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CDropZoneFileSearchResponse> esp_response = new CDropZoneFileSearchResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		StringBuffer source;
		source.appendf("FileSpray::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			if (clientVer!=-1.0 && clientVer<1.13)
				throw MakeStringException(-1, "Client version is too old, please update your client application.");			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "FileSpray", "DropZoneFileSearch");
			iserv->onDropZoneFileSearch(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "FileSpray", "DropZoneFileSearch");
		response->set_name("DropZoneFileSearchResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "DropZoneFiles")||!stricmp(thecall->get_name(), "DropZoneFilesRequest"))
	{
		Owned<CDropZoneFilesRequest> esp_request = new CDropZoneFilesRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CDropZoneFilesResponse> esp_response = new CDropZoneFilesResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		StringBuffer source;
		source.appendf("FileSpray::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "FileSpray", "DropZoneFiles");
			iserv->onDropZoneFiles(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "FileSpray", "DropZoneFiles");
		response->set_name("DropZoneFilesResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "EchoDateTime")||!stricmp(thecall->get_name(), "EchoDateTime"))
	{
		Owned<CEchoDateTime> esp_request = new CEchoDateTime(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CEchoDateTimeResponse> esp_response = new CEchoDateTimeResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		StringBuffer source;
		source.appendf("FileSpray::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "FileSpray", "EchoDateTime");
			iserv->onEchoDateTime(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "FileSpray", "EchoDateTime");
		response->set_name("EchoDateTimeResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "FileList")||!stricmp(thecall->get_name(), "FileListRequest"))
	{
		Owned<CFileListRequest> esp_request = new CFileListRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CFileListResponse> esp_response = new CFileListResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		StringBuffer source;
		source.appendf("FileSpray::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "FileSpray", "FileList");
			iserv->onFileList(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "FileSpray", "FileList");
		response->set_name("FileListResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "GetDFUExceptions")||!stricmp(thecall->get_name(), "GetDFUExceptions"))
	{
		Owned<CGetDFUExceptions> esp_request = new CGetDFUExceptions(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CGetDFUExceptionsResponse> esp_response = new CGetDFUExceptionsResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		StringBuffer source;
		source.appendf("FileSpray::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "FileSpray", "GetDFUExceptions");
			iserv->onGetDFUExceptions(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "FileSpray", "GetDFUExceptions");
		response->set_name("GetDFUExceptionsResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "GetDFUProgress")||!stricmp(thecall->get_name(), "ProgressRequest"))
	{
		Owned<CProgressRequest> esp_request = new CProgressRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CProgressResponse> esp_response = new CProgressResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		StringBuffer source;
		source.appendf("FileSpray::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "FileSpray", "GetDFUProgress");
			iserv->onGetDFUProgress(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "FileSpray", "GetDFUProgress");
		response->set_name("ProgressResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "GetDFUServerQueues")||!stricmp(thecall->get_name(), "GetDFUServerQueuesRequest"))
	{
		Owned<CGetDFUServerQueuesRequest> esp_request = new CGetDFUServerQueuesRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CGetDFUServerQueuesResponse> esp_response = new CGetDFUServerQueuesResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		StringBuffer source;
		source.appendf("FileSpray::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			if (clientVer!=-1.0 && clientVer<1.14)
				throw MakeStringException(-1, "Client version is too old, please update your client application.");			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "FileSpray", "GetDFUServerQueues");
			iserv->onGetDFUServerQueues(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "FileSpray", "GetDFUServerQueues");
		response->set_name("GetDFUServerQueuesResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "GetDFUWorkunit")||!stricmp(thecall->get_name(), "GetDFUWorkunit"))
	{
		Owned<CGetDFUWorkunit> esp_request = new CGetDFUWorkunit(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CGetDFUWorkunitResponse> esp_response = new CGetDFUWorkunitResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		StringBuffer source;
		source.appendf("FileSpray::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "FileSpray", "GetDFUWorkunit");
			iserv->onGetDFUWorkunit(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "FileSpray", "GetDFUWorkunit");
		response->set_name("GetDFUWorkunitResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "GetDFUWorkunits")||!stricmp(thecall->get_name(), "GetDFUWorkunits"))
	{
		Owned<CGetDFUWorkunits> esp_request = new CGetDFUWorkunits(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CGetDFUWorkunitsResponse> esp_response = new CGetDFUWorkunitsResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		StringBuffer source;
		source.appendf("FileSpray::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "FileSpray", "GetDFUWorkunits");
			iserv->onGetDFUWorkunits(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "FileSpray", "GetDFUWorkunits");
		response->set_name("GetDFUWorkunitsResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "GetSprayTargets")||!stricmp(thecall->get_name(), "GetSprayTargetsRequest"))
	{
		Owned<CGetSprayTargetsRequest> esp_request = new CGetSprayTargetsRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CGetSprayTargetsResponse> esp_response = new CGetSprayTargetsResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		StringBuffer source;
		source.appendf("FileSpray::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "FileSpray", "GetSprayTargets");
			iserv->onGetSprayTargets(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "FileSpray", "GetSprayTargets");
		response->set_name("GetSprayTargetsResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "OpenSave")||!stricmp(thecall->get_name(), "OpenSaveRequest"))
	{
		Owned<COpenSaveRequest> esp_request = new COpenSaveRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<COpenSaveResponse> esp_response = new COpenSaveResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		StringBuffer source;
		source.appendf("FileSpray::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "FileSpray", "OpenSave");
			iserv->onOpenSave(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "FileSpray", "OpenSave");
		response->set_name("OpenSaveResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "Ping")||!stricmp(thecall->get_name(), "FileSprayPingRequest"))
	{
		Owned<CFileSprayPingRequest> esp_request = new CFileSprayPingRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CFileSprayPingResponse> esp_response = new CFileSprayPingResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		StringBuffer source;
		source.appendf("FileSpray::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "FileSpray", "Ping");
			iserv->onPing(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "FileSpray", "Ping");
		response->set_name("FileSprayPingResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "Rename")||!stricmp(thecall->get_name(), "Rename"))
	{
		Owned<CRename> esp_request = new CRename(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CRenameResponse> esp_response = new CRenameResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		StringBuffer source;
		source.appendf("FileSpray::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "FileSpray", "Rename");
			iserv->onRename(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "FileSpray", "Rename");
		response->set_name("RenameResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "Replicate")||!stricmp(thecall->get_name(), "Replicate"))
	{
		Owned<CReplicate> esp_request = new CReplicate(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CReplicateResponse> esp_response = new CReplicateResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		StringBuffer source;
		source.appendf("FileSpray::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "FileSpray", "Replicate");
			iserv->onReplicate(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "FileSpray", "Replicate");
		response->set_name("ReplicateResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "ShowResult")||!stricmp(thecall->get_name(), "ShowResultRequest"))
	{
		Owned<CShowResultRequest> esp_request = new CShowResultRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CShowResultResponse> esp_response = new CShowResultResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		StringBuffer source;
		source.appendf("FileSpray::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "FileSpray", "ShowResult");
			iserv->onShowResult(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "FileSpray", "ShowResult");
		response->set_name("ShowResultResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "SprayFixed")||!stricmp(thecall->get_name(), "SprayFixed"))
	{
		Owned<CSprayFixed> esp_request = new CSprayFixed(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CSprayFixedResponse> esp_response = new CSprayFixedResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		StringBuffer source;
		source.appendf("FileSpray::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "FileSpray", "SprayFixed");
			iserv->onSprayFixed(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "FileSpray", "SprayFixed");
		response->set_name("SprayFixedResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "SprayVariable")||!stricmp(thecall->get_name(), "SprayVariable"))
	{
		Owned<CSprayVariable> esp_request = new CSprayVariable(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CSprayResponse> esp_response = new CSprayResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		StringBuffer source;
		source.appendf("FileSpray::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "FileSpray", "SprayVariable");
			iserv->onSprayVariable(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "FileSpray", "SprayVariable");
		response->set_name("SprayResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "SubmitDFUWorkunit")||!stricmp(thecall->get_name(), "SubmitDFUWorkunit"))
	{
		Owned<CSubmitDFUWorkunit> esp_request = new CSubmitDFUWorkunit(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CSubmitDFUWorkunitResponse> esp_response = new CSubmitDFUWorkunitResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		StringBuffer source;
		source.appendf("FileSpray::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "FileSpray", "SubmitDFUWorkunit");
			iserv->onSubmitDFUWorkunit(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "FileSpray", "SubmitDFUWorkunit");
		response->set_name("SubmitDFUWorkunitResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "UpdateDFUWorkunit")||!stricmp(thecall->get_name(), "UpdateDFUWorkunit"))
	{
		Owned<CUpdateDFUWorkunit> esp_request = new CUpdateDFUWorkunit(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CUpdateDFUWorkunitResponse> esp_response = new CUpdateDFUWorkunitResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		StringBuffer source;
		source.appendf("FileSpray::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "FileSpray", "UpdateDFUWorkunit");
			iserv->onUpdateDFUWorkunit(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "FileSpray", "UpdateDFUWorkunit");
		response->set_name("UpdateDFUWorkunitResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	response->set_status(SOAP_CLIENT_ERROR);
	StringBuffer msg, svcName;
	msg.appendf("Method %s not available in service %s",thecall->get_name(),getServiceName(svcName).str());
	ERRLOG("%s", msg.str());
	response->set_err(msg);
	return -1;
}

int CFileSpraySoapBinding::getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &content, const char *service, const char *method, bool mda)
{
	BoolHash added;
	if (context.getClientVersion()<=0)
		context.setClientVersion(1.17);

	DBGLOG("Client version: %g", context.getClientVersion());
	bool fullservice = (!Utils::strcasecmp(service, "FileSpray"));
	bool allMethods = (method==NULL || *method==0);
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "AbortDFUWorkunit"))) || Utils::strcasecmp(method, "AbortDFUWorkunit")==0)
	{
		CAbortDFUWorkunit::getMapInfo(context.queryMapInfo());
		CAbortDFUWorkunitResponse::getMapInfo(context.queryMapInfo());
		CAbortDFUWorkunit::getXsdDefinition(context, request, "AbortDFUWorkunit", content, added);
		CAbortDFUWorkunitResponse::getXsdDefinition(context, request, content, added);
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "Copy"))) || Utils::strcasecmp(method, "Copy")==0)
	{
		CCopy::getMapInfo(context.queryMapInfo());
		CCopyResponse::getMapInfo(context.queryMapInfo());
		CCopy::getXsdDefinition(context, request, "Copy", content, added);
		CCopyResponse::getXsdDefinition(context, request, content, added);
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "CreateDFUWorkunit"))) || Utils::strcasecmp(method, "CreateDFUWorkunit")==0)
	{
		CCreateDFUWorkunit::getMapInfo(context.queryMapInfo());
		CCreateDFUWorkunitResponse::getMapInfo(context.queryMapInfo());
		CCreateDFUWorkunit::getXsdDefinition(context, request, "CreateDFUWorkunit", content, added);
		CCreateDFUWorkunitResponse::getXsdDefinition(context, request, content, added);
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "DFUWUFile"))) || Utils::strcasecmp(method, "DFUWUFile")==0)
	{
		CDFUWUFileRequest::getMapInfo(context.queryMapInfo());
		CDFUWUFileResponse::getMapInfo(context.queryMapInfo());
		CDFUWUFileRequest::getXsdDefinition(context, request, "DFUWUFileRequest", content, added);
		CDFUWUFileResponse::getXsdDefinition(context, request, content, added);
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "DFUWUSearch"))) || Utils::strcasecmp(method, "DFUWUSearch")==0)
	{
		CDFUWUSearchRequest::getMapInfo(context.queryMapInfo());
		CDFUWUSearchResponse::getMapInfo(context.queryMapInfo());
		CDFUWUSearchRequest::getXsdDefinition(context, request, "DFUWUSearchRequest", content, added);
		CDFUWUSearchResponse::getXsdDefinition(context, request, content, added);
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "DFUWorkunitsAction"))) || Utils::strcasecmp(method, "DFUWorkunitsAction")==0)
	{
		CDFUWorkunitsActionRequest::getMapInfo(context.queryMapInfo());
		CDFUWorkunitsActionResponse::getMapInfo(context.queryMapInfo());
		CDFUWorkunitsActionRequest::getXsdDefinition(context, request, "DFUWorkunitsActionRequest", content, added);
		CDFUWorkunitsActionResponse::getXsdDefinition(context, request, content, added);
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "DeleteDFUWorkunit"))) || Utils::strcasecmp(method, "DeleteDFUWorkunit")==0)
	{
		CDeleteDFUWorkunit::getMapInfo(context.queryMapInfo());
		CDeleteDFUWorkunitResponse::getMapInfo(context.queryMapInfo());
		CDeleteDFUWorkunit::getXsdDefinition(context, request, "DeleteDFUWorkunit", content, added);
		CDeleteDFUWorkunitResponse::getXsdDefinition(context, request, content, added);
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "DeleteDFUWorkunits"))) || Utils::strcasecmp(method, "DeleteDFUWorkunits")==0)
	{
		CDeleteDFUWorkunits::getMapInfo(context.queryMapInfo());
		CDeleteDFUWorkunitsResponse::getMapInfo(context.queryMapInfo());
		CDeleteDFUWorkunits::getXsdDefinition(context, request, "DeleteDFUWorkunits", content, added);
		CDeleteDFUWorkunitsResponse::getXsdDefinition(context, request, content, added);
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "DeleteDropZoneFiles"))) || Utils::strcasecmp(method, "DeleteDropZoneFiles")==0)
	{
		CDeleteDropZoneFilesRequest::getMapInfo(context.queryMapInfo());
		CDFUWorkunitsActionResponse::getMapInfo(context.queryMapInfo());
		CDeleteDropZoneFilesRequest::getXsdDefinition(context, request, "DeleteDropZoneFilesRequest", content, added);
		CDFUWorkunitsActionResponse::getXsdDefinition(context, request, content, added);
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "Despray"))) || Utils::strcasecmp(method, "Despray")==0)
	{
		CDespray::getMapInfo(context.queryMapInfo());
		CDesprayResponse::getMapInfo(context.queryMapInfo());
		CDespray::getXsdDefinition(context, request, "Despray", content, added);
		CDesprayResponse::getXsdDefinition(context, request, content, added);
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "DfuMonitor"))) || Utils::strcasecmp(method, "DfuMonitor")==0)
	{
		CDfuMonitorRequest::getMapInfo(context.queryMapInfo());
		CDfuMonitorResponse::getMapInfo(context.queryMapInfo());
		CDfuMonitorRequest::getXsdDefinition(context, request, "DfuMonitorRequest", content, added);
		CDfuMonitorResponse::getXsdDefinition(context, request, content, added);
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "DropZoneFileSearch"))) || Utils::strcasecmp(method, "DropZoneFileSearch")==0)
	{
		if (context.getClientVersion()>=1.13) {
			CDropZoneFileSearchRequest::getMapInfo(context.queryMapInfo());
			CDropZoneFileSearchResponse::getMapInfo(context.queryMapInfo());
			CDropZoneFileSearchRequest::getXsdDefinition(context, request, "DropZoneFileSearchRequest", content, added);
			CDropZoneFileSearchResponse::getXsdDefinition(context, request, content, added);
		}
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "DropZoneFiles"))) || Utils::strcasecmp(method, "DropZoneFiles")==0)
	{
		CDropZoneFilesRequest::getMapInfo(context.queryMapInfo());
		CDropZoneFilesResponse::getMapInfo(context.queryMapInfo());
		CDropZoneFilesRequest::getXsdDefinition(context, request, "DropZoneFilesRequest", content, added);
		CDropZoneFilesResponse::getXsdDefinition(context, request, content, added);
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "EchoDateTime"))) || Utils::strcasecmp(method, "EchoDateTime")==0)
	{
		CEchoDateTime::getMapInfo(context.queryMapInfo());
		CEchoDateTimeResponse::getMapInfo(context.queryMapInfo());
		CEchoDateTime::getXsdDefinition(context, request, "EchoDateTime", content, added);
		CEchoDateTimeResponse::getXsdDefinition(context, request, content, added);
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "FileList"))) || Utils::strcasecmp(method, "FileList")==0)
	{
		CFileListRequest::getMapInfo(context.queryMapInfo());
		CFileListResponse::getMapInfo(context.queryMapInfo());
		CFileListRequest::getXsdDefinition(context, request, "FileListRequest", content, added);
		CFileListResponse::getXsdDefinition(context, request, content, added);
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "GetDFUExceptions"))) || Utils::strcasecmp(method, "GetDFUExceptions")==0)
	{
		CGetDFUExceptions::getMapInfo(context.queryMapInfo());
		CGetDFUExceptionsResponse::getMapInfo(context.queryMapInfo());
		CGetDFUExceptions::getXsdDefinition(context, request, "GetDFUExceptions", content, added);
		CGetDFUExceptionsResponse::getXsdDefinition(context, request, content, added);
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "GetDFUProgress"))) || Utils::strcasecmp(method, "GetDFUProgress")==0)
	{
		CProgressRequest::getMapInfo(context.queryMapInfo());
		CProgressResponse::getMapInfo(context.queryMapInfo());
		CProgressRequest::getXsdDefinition(context, request, "ProgressRequest", content, added);
		CProgressResponse::getXsdDefinition(context, request, content, added);
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "GetDFUServerQueues"))) || Utils::strcasecmp(method, "GetDFUServerQueues")==0)
	{
		if (context.getClientVersion()>=1.14) {
			CGetDFUServerQueuesRequest::getMapInfo(context.queryMapInfo());
			CGetDFUServerQueuesResponse::getMapInfo(context.queryMapInfo());
			CGetDFUServerQueuesRequest::getXsdDefinition(context, request, "GetDFUServerQueuesRequest", content, added);
			CGetDFUServerQueuesResponse::getXsdDefinition(context, request, content, added);
		}
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "GetDFUWorkunit"))) || Utils::strcasecmp(method, "GetDFUWorkunit")==0)
	{
		CGetDFUWorkunit::getMapInfo(context.queryMapInfo());
		CGetDFUWorkunitResponse::getMapInfo(context.queryMapInfo());
		CGetDFUWorkunit::getXsdDefinition(context, request, "GetDFUWorkunit", content, added);
		CGetDFUWorkunitResponse::getXsdDefinition(context, request, content, added);
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "GetDFUWorkunits"))) || Utils::strcasecmp(method, "GetDFUWorkunits")==0)
	{
		CGetDFUWorkunits::getMapInfo(context.queryMapInfo());
		CGetDFUWorkunitsResponse::getMapInfo(context.queryMapInfo());
		CGetDFUWorkunits::getXsdDefinition(context, request, "GetDFUWorkunits", content, added);
		CGetDFUWorkunitsResponse::getXsdDefinition(context, request, content, added);
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "GetSprayTargets"))) || Utils::strcasecmp(method, "GetSprayTargets")==0)
	{
		CGetSprayTargetsRequest::getMapInfo(context.queryMapInfo());
		CGetSprayTargetsResponse::getMapInfo(context.queryMapInfo());
		CGetSprayTargetsRequest::getXsdDefinition(context, request, "GetSprayTargetsRequest", content, added);
		CGetSprayTargetsResponse::getXsdDefinition(context, request, content, added);
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "OpenSave"))) || Utils::strcasecmp(method, "OpenSave")==0)
	{
		COpenSaveRequest::getMapInfo(context.queryMapInfo());
		COpenSaveResponse::getMapInfo(context.queryMapInfo());
		COpenSaveRequest::getXsdDefinition(context, request, "OpenSaveRequest", content, added);
		COpenSaveResponse::getXsdDefinition(context, request, content, added);
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "Ping"))) || Utils::strcasecmp(method, "Ping")==0)
	{
		CFileSprayPingRequest::getMapInfo(context.queryMapInfo());
		CFileSprayPingResponse::getMapInfo(context.queryMapInfo());
		CFileSprayPingRequest::getXsdDefinition(context, request, "FileSprayPingRequest", content, added);
		CFileSprayPingResponse::getXsdDefinition(context, request, content, added);
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "Rename"))) || Utils::strcasecmp(method, "Rename")==0)
	{
		CRename::getMapInfo(context.queryMapInfo());
		CRenameResponse::getMapInfo(context.queryMapInfo());
		CRename::getXsdDefinition(context, request, "Rename", content, added);
		CRenameResponse::getXsdDefinition(context, request, content, added);
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "Replicate"))) || Utils::strcasecmp(method, "Replicate")==0)
	{
		CReplicate::getMapInfo(context.queryMapInfo());
		CReplicateResponse::getMapInfo(context.queryMapInfo());
		CReplicate::getXsdDefinition(context, request, "Replicate", content, added);
		CReplicateResponse::getXsdDefinition(context, request, content, added);
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "ShowResult"))) || Utils::strcasecmp(method, "ShowResult")==0)
	{
		CShowResultRequest::getMapInfo(context.queryMapInfo());
		CShowResultResponse::getMapInfo(context.queryMapInfo());
		CShowResultRequest::getXsdDefinition(context, request, "ShowResultRequest", content, added);
		CShowResultResponse::getXsdDefinition(context, request, content, added);
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "SprayFixed"))) || Utils::strcasecmp(method, "SprayFixed")==0)
	{
		CSprayFixed::getMapInfo(context.queryMapInfo());
		CSprayFixedResponse::getMapInfo(context.queryMapInfo());
		CSprayFixed::getXsdDefinition(context, request, "SprayFixed", content, added);
		CSprayFixedResponse::getXsdDefinition(context, request, content, added);
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "SprayVariable"))) || Utils::strcasecmp(method, "SprayVariable")==0)
	{
		CSprayVariable::getMapInfo(context.queryMapInfo());
		CSprayResponse::getMapInfo(context.queryMapInfo());
		CSprayVariable::getXsdDefinition(context, request, "SprayVariable", content, added);
		CSprayResponse::getXsdDefinition(context, request, content, added);
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "SubmitDFUWorkunit"))) || Utils::strcasecmp(method, "SubmitDFUWorkunit")==0)
	{
		CSubmitDFUWorkunit::getMapInfo(context.queryMapInfo());
		CSubmitDFUWorkunitResponse::getMapInfo(context.queryMapInfo());
		CSubmitDFUWorkunit::getXsdDefinition(context, request, "SubmitDFUWorkunit", content, added);
		CSubmitDFUWorkunitResponse::getXsdDefinition(context, request, content, added);
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "UpdateDFUWorkunit"))) || Utils::strcasecmp(method, "UpdateDFUWorkunit")==0)
	{
		CUpdateDFUWorkunit::getMapInfo(context.queryMapInfo());
		CUpdateDFUWorkunitResponse::getMapInfo(context.queryMapInfo());
		CUpdateDFUWorkunit::getXsdDefinition(context, request, "UpdateDFUWorkunit", content, added);
		CUpdateDFUWorkunitResponse::getXsdDefinition(context, request, content, added);
	}
	return 0;
}

int CFileSpraySoapBinding::getMethodHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &page, bool bIncludeFormTag)
{
	DBGLOG("Client version: %g", context.getClientVersion());
	if (Utils::strcasecmp(method, "AbortDFUWorkunit")==0)
	{
		CAbortDFUWorkunit::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "Copy")==0)
	{
		CCopy::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "CreateDFUWorkunit")==0)
	{
		CCreateDFUWorkunit::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "DFUWUFile")==0)
	{
		CDFUWUFileRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "DFUWUSearch")==0)
	{
		CDFUWUSearchRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "DFUWorkunitsAction")==0)
	{
		CDFUWorkunitsActionRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "DeleteDFUWorkunit")==0)
	{
		CDeleteDFUWorkunit::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "DeleteDFUWorkunits")==0)
	{
		CDeleteDFUWorkunits::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "DeleteDropZoneFiles")==0)
	{
		CDeleteDropZoneFilesRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "Despray")==0)
	{
		CDespray::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "DfuMonitor")==0)
	{
		CDfuMonitorRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "DropZoneFileSearch")==0)
	{
		CDropZoneFileSearchRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "DropZoneFiles")==0)
	{
		CDropZoneFilesRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "EchoDateTime")==0)
	{
		CEchoDateTime::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "FileList")==0)
	{
		CFileListRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "GetDFUExceptions")==0)
	{
		CGetDFUExceptions::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "GetDFUProgress")==0)
	{
		CProgressRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "GetDFUServerQueues")==0)
	{
		CGetDFUServerQueuesRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "GetDFUWorkunit")==0)
	{
		CGetDFUWorkunit::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "GetDFUWorkunits")==0)
	{
		CGetDFUWorkunits::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "GetSprayTargets")==0)
	{
		CGetSprayTargetsRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "OpenSave")==0)
	{
		COpenSaveRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "Ping")==0)
	{
		CFileSprayPingRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "Rename")==0)
	{
		CRename::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "Replicate")==0)
	{
		CReplicate::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "ShowResult")==0)
	{
		CShowResultRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "SprayFixed")==0)
	{
		CSprayFixed::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "SprayVariable")==0)
	{
		CSprayVariable::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "SubmitDFUWorkunit")==0)
	{
		CSubmitDFUWorkunit::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "UpdateDFUWorkunit")==0)
	{
		CUpdateDFUWorkunit::getHtmlForm(context, request, serv, method, page);
	}
	return 0;
}

int CFileSpraySoapBinding::getQualifiedNames(IEspContext& ctx, MethodInfoArray & methods)
{
	double ver = ctx.getClientVersion();
	if (ver<=0)
		ver = getWsdlVersion();
	const char *servname=ctx.queryServiceName(NULL);
	bool fullservice = (!stricmp(servname, "esp")||!stricmp(servname, "FileSpray"));
	if ((fullservice || isMethodInSubService(ctx, servname, "AbortDFUWorkunit")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("AbortDFUWorkunit", "AbortDFUWorkunit", "AbortDFUWorkunitResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "Copy")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("Copy", "Copy", "CopyResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "CreateDFUWorkunit")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("CreateDFUWorkunit", "CreateDFUWorkunit", "CreateDFUWorkunitResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "DFUWUFile")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("DFUWUFile", "DFUWUFileRequest", "DFUWUFileResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "DFUWUSearch")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("DFUWUSearch", "DFUWUSearchRequest", "DFUWUSearchResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "DFUWorkunitsAction")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("DFUWorkunitsAction", "DFUWorkunitsActionRequest", "DFUWorkunitsActionResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "DeleteDFUWorkunit")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("DeleteDFUWorkunit", "DeleteDFUWorkunit", "DeleteDFUWorkunitResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "DeleteDFUWorkunits")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("DeleteDFUWorkunits", "DeleteDFUWorkunits", "DeleteDFUWorkunitsResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "DeleteDropZoneFiles")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("DeleteDropZoneFiles", "DeleteDropZoneFilesRequest", "DFUWorkunitsActionResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "Despray")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("Despray", "Despray", "DesprayResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "DfuMonitor")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("DfuMonitor", "DfuMonitorRequest", "DfuMonitorResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "DropZoneFileSearch")) && ctx.isMethodAllowed(ver,NULL, NULL, 1.13, -1))
		methods.append(*new CMethodInfo("DropZoneFileSearch", "DropZoneFileSearchRequest", "DropZoneFileSearchResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "DropZoneFiles")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("DropZoneFiles", "DropZoneFilesRequest", "DropZoneFilesResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "EchoDateTime")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("EchoDateTime", "EchoDateTime", "EchoDateTimeResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "FileList")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("FileList", "FileListRequest", "FileListResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "GetDFUExceptions")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("GetDFUExceptions", "GetDFUExceptions", "GetDFUExceptionsResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "GetDFUProgress")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("GetDFUProgress", "ProgressRequest", "ProgressResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "GetDFUServerQueues")) && ctx.isMethodAllowed(ver,NULL, NULL, 1.14, -1))
		methods.append(*new CMethodInfo("GetDFUServerQueues", "GetDFUServerQueuesRequest", "GetDFUServerQueuesResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "GetDFUWorkunit")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("GetDFUWorkunit", "GetDFUWorkunit", "GetDFUWorkunitResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "GetDFUWorkunits")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("GetDFUWorkunits", "GetDFUWorkunits", "GetDFUWorkunitsResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "GetSprayTargets")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("GetSprayTargets", "GetSprayTargetsRequest", "GetSprayTargetsResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "OpenSave")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("OpenSave", "OpenSaveRequest", "OpenSaveResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "Ping")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("Ping", "FileSprayPingRequest", "FileSprayPingResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "Rename")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("Rename", "Rename", "RenameResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "Replicate")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("Replicate", "Replicate", "ReplicateResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "ShowResult")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("ShowResult", "ShowResultRequest", "ShowResultResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "SprayFixed")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("SprayFixed", "SprayFixed", "SprayFixedResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "SprayVariable")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("SprayVariable", "SprayVariable", "SprayResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "SubmitDFUWorkunit")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("SubmitDFUWorkunit", "SubmitDFUWorkunit", "SubmitDFUWorkunitResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "UpdateDFUWorkunit")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("UpdateDFUWorkunit", "UpdateDFUWorkunit", "UpdateDFUWorkunitResponse"));
	return methods.ordinality();
}

StringBuffer & CFileSpraySoapBinding::getServiceName(StringBuffer &resp)
{
	resp.append("FileSpray");
	return resp;
}

bool CFileSpraySoapBinding::isValidServiceName(IEspContext &context, const char *name)
{
	if (!Utils::strcasecmp(name, "FileSpray"))
		return true;
	else
		return (hasSubService(context, name));
}

bool CFileSpraySoapBinding::qualifyMethodName(IEspContext &context, const char *methname, StringBuffer *methQName)
{
	if (!methname || !*methname)
	{
		if (methQName!=NULL)
			methQName->clear();
		return true;
	}
	if (Utils::strcasecmp(methname, "AbortDFUWorkunit")==0)
	{
		if (methQName!=NULL)
			methQName->set("AbortDFUWorkunit");
		return true;
	}
	if (Utils::strcasecmp(methname, "Copy")==0)
	{
		if (methQName!=NULL)
			methQName->set("Copy");
		return true;
	}
	if (Utils::strcasecmp(methname, "CreateDFUWorkunit")==0)
	{
		if (methQName!=NULL)
			methQName->set("CreateDFUWorkunit");
		return true;
	}
	if (Utils::strcasecmp(methname, "DFUWUFile")==0)
	{
		if (methQName!=NULL)
			methQName->set("DFUWUFile");
		return true;
	}
	if (Utils::strcasecmp(methname, "DFUWUSearch")==0)
	{
		if (methQName!=NULL)
			methQName->set("DFUWUSearch");
		return true;
	}
	if (Utils::strcasecmp(methname, "DFUWorkunitsAction")==0)
	{
		if (methQName!=NULL)
			methQName->set("DFUWorkunitsAction");
		return true;
	}
	if (Utils::strcasecmp(methname, "DeleteDFUWorkunit")==0)
	{
		if (methQName!=NULL)
			methQName->set("DeleteDFUWorkunit");
		return true;
	}
	if (Utils::strcasecmp(methname, "DeleteDFUWorkunits")==0)
	{
		if (methQName!=NULL)
			methQName->set("DeleteDFUWorkunits");
		return true;
	}
	if (Utils::strcasecmp(methname, "DeleteDropZoneFiles")==0)
	{
		if (methQName!=NULL)
			methQName->set("DeleteDropZoneFiles");
		return true;
	}
	if (Utils::strcasecmp(methname, "Despray")==0)
	{
		if (methQName!=NULL)
			methQName->set("Despray");
		return true;
	}
	if (Utils::strcasecmp(methname, "DfuMonitor")==0)
	{
		if (methQName!=NULL)
			methQName->set("DfuMonitor");
		return true;
	}
	if (Utils::strcasecmp(methname, "DropZoneFileSearch")==0)
	{
		if (methQName!=NULL)
			methQName->set("DropZoneFileSearch");
		return true;
	}
	if (Utils::strcasecmp(methname, "DropZoneFiles")==0)
	{
		if (methQName!=NULL)
			methQName->set("DropZoneFiles");
		return true;
	}
	if (Utils::strcasecmp(methname, "EchoDateTime")==0)
	{
		if (methQName!=NULL)
			methQName->set("EchoDateTime");
		return true;
	}
	if (Utils::strcasecmp(methname, "FileList")==0)
	{
		if (methQName!=NULL)
			methQName->set("FileList");
		return true;
	}
	if (Utils::strcasecmp(methname, "GetDFUExceptions")==0)
	{
		if (methQName!=NULL)
			methQName->set("GetDFUExceptions");
		return true;
	}
	if (Utils::strcasecmp(methname, "GetDFUProgress")==0)
	{
		if (methQName!=NULL)
			methQName->set("GetDFUProgress");
		return true;
	}
	if (Utils::strcasecmp(methname, "GetDFUServerQueues")==0)
	{
		if (methQName!=NULL)
			methQName->set("GetDFUServerQueues");
		return true;
	}
	if (Utils::strcasecmp(methname, "GetDFUWorkunit")==0)
	{
		if (methQName!=NULL)
			methQName->set("GetDFUWorkunit");
		return true;
	}
	if (Utils::strcasecmp(methname, "GetDFUWorkunits")==0)
	{
		if (methQName!=NULL)
			methQName->set("GetDFUWorkunits");
		return true;
	}
	if (Utils::strcasecmp(methname, "GetSprayTargets")==0)
	{
		if (methQName!=NULL)
			methQName->set("GetSprayTargets");
		return true;
	}
	if (Utils::strcasecmp(methname, "OpenSave")==0)
	{
		if (methQName!=NULL)
			methQName->set("OpenSave");
		return true;
	}
	if (Utils::strcasecmp(methname, "Ping")==0)
	{
		if (methQName!=NULL)
			methQName->set("Ping");
		return true;
	}
	if (Utils::strcasecmp(methname, "Rename")==0)
	{
		if (methQName!=NULL)
			methQName->set("Rename");
		return true;
	}
	if (Utils::strcasecmp(methname, "Replicate")==0)
	{
		if (methQName!=NULL)
			methQName->set("Replicate");
		return true;
	}
	if (Utils::strcasecmp(methname, "ShowResult")==0)
	{
		if (methQName!=NULL)
			methQName->set("ShowResult");
		return true;
	}
	if (Utils::strcasecmp(methname, "SprayFixed")==0)
	{
		if (methQName!=NULL)
			methQName->set("SprayFixed");
		return true;
	}
	if (Utils::strcasecmp(methname, "SprayVariable")==0)
	{
		if (methQName!=NULL)
			methQName->set("SprayVariable");
		return true;
	}
	if (Utils::strcasecmp(methname, "SubmitDFUWorkunit")==0)
	{
		if (methQName!=NULL)
			methQName->set("SubmitDFUWorkunit");
		return true;
	}
	if (Utils::strcasecmp(methname, "UpdateDFUWorkunit")==0)
	{
		if (methQName!=NULL)
			methQName->set("UpdateDFUWorkunit");
		return true;
	}
	return false;
}

bool CFileSpraySoapBinding::qualifyServiceName(IEspContext &context, const char *servname, const char *methname, StringBuffer &servQName, StringBuffer *methQName)
{
	servQName.clear();
	if (!Utils::strcasecmp(servname, "FileSpray"))
	{
		servQName.append("FileSpray");
		return qualifyMethodName(context, methname, methQName);
	}
	return qualifySubServiceName(context, servname, methname, servQName, methQName);
}

int CFileSpraySoapBinding::onGetFile(IEspContext &context, CHttpRequest* request, CHttpResponse* response, const char *pathex)
{
	if(request == NULL || response == NULL)
		return -1;
	StringBuffer mimetype;
	MemoryBuffer content;

	StringBuffer filepath;
	getBaseFilePath(filepath);
	if (strchr("\\/", filepath.charAt(filepath.length()-1))==NULL)
		filepath.append("/");
	filepath.append(pathex);
	response->httpContentFromFile(filepath.str());
	response->send();
	return 0;
}

int CFileSpraySoapBinding::onGetForm(IEspContext &context, CHttpRequest* request, CHttpResponse* response, const char *service, const char *method)
{
	if (context.getClientVersion()<=0)
		context.setClientVersion(1.17);

	if (!stricmp("AbortDFUWorkunit", method)) {
		CAbortDFUWorkunit::getMapInfo(context.queryMapInfo());
		CAbortDFUWorkunitResponse::getMapInfo(context.queryMapInfo());
	}
	if (!stricmp("Copy", method)) {
		CCopy::getMapInfo(context.queryMapInfo());
		CCopyResponse::getMapInfo(context.queryMapInfo());
	}
	if (!stricmp("CreateDFUWorkunit", method)) {
		CCreateDFUWorkunit::getMapInfo(context.queryMapInfo());
		CCreateDFUWorkunitResponse::getMapInfo(context.queryMapInfo());
	}
	if (!stricmp("DFUWUFile", method)) {
		CDFUWUFileRequest::getMapInfo(context.queryMapInfo());
		CDFUWUFileResponse::getMapInfo(context.queryMapInfo());
	}
	if (!stricmp("DFUWUSearch", method)) {
		CDFUWUSearchRequest::getMapInfo(context.queryMapInfo());
		CDFUWUSearchResponse::getMapInfo(context.queryMapInfo());
	}
	if (!stricmp("DFUWorkunitsAction", method)) {
		CDFUWorkunitsActionRequest::getMapInfo(context.queryMapInfo());
		CDFUWorkunitsActionResponse::getMapInfo(context.queryMapInfo());
	}
	if (!stricmp("DeleteDFUWorkunit", method)) {
		CDeleteDFUWorkunit::getMapInfo(context.queryMapInfo());
		CDeleteDFUWorkunitResponse::getMapInfo(context.queryMapInfo());
	}
	if (!stricmp("DeleteDFUWorkunits", method)) {
		CDeleteDFUWorkunits::getMapInfo(context.queryMapInfo());
		CDeleteDFUWorkunitsResponse::getMapInfo(context.queryMapInfo());
	}
	if (!stricmp("DeleteDropZoneFiles", method)) {
		CDeleteDropZoneFilesRequest::getMapInfo(context.queryMapInfo());
		CDFUWorkunitsActionResponse::getMapInfo(context.queryMapInfo());
	}
	if (!stricmp("Despray", method)) {
		CDespray::getMapInfo(context.queryMapInfo());
		CDesprayResponse::getMapInfo(context.queryMapInfo());
	}
	if (!stricmp("DfuMonitor", method)) {
		CDfuMonitorRequest::getMapInfo(context.queryMapInfo());
		CDfuMonitorResponse::getMapInfo(context.queryMapInfo());
	}
	if (!stricmp("DropZoneFileSearch", method)) {
		CDropZoneFileSearchRequest::getMapInfo(context.queryMapInfo());
		CDropZoneFileSearchResponse::getMapInfo(context.queryMapInfo());
	}
	if (!stricmp("DropZoneFiles", method)) {
		CDropZoneFilesRequest::getMapInfo(context.queryMapInfo());
		CDropZoneFilesResponse::getMapInfo(context.queryMapInfo());
	}
	if (!stricmp("EchoDateTime", method)) {
		CEchoDateTime::getMapInfo(context.queryMapInfo());
		CEchoDateTimeResponse::getMapInfo(context.queryMapInfo());
	}
	if (!stricmp("FileList", method)) {
		CFileListRequest::getMapInfo(context.queryMapInfo());
		CFileListResponse::getMapInfo(context.queryMapInfo());
	}
	if (!stricmp("GetDFUExceptions", method)) {
		CGetDFUExceptions::getMapInfo(context.queryMapInfo());
		CGetDFUExceptionsResponse::getMapInfo(context.queryMapInfo());
	}
	if (!stricmp("GetDFUProgress", method)) {
		CProgressRequest::getMapInfo(context.queryMapInfo());
		CProgressResponse::getMapInfo(context.queryMapInfo());
	}
	if (!stricmp("GetDFUServerQueues", method)) {
		CGetDFUServerQueuesRequest::getMapInfo(context.queryMapInfo());
		CGetDFUServerQueuesResponse::getMapInfo(context.queryMapInfo());
	}
	if (!stricmp("GetDFUWorkunit", method)) {
		CGetDFUWorkunit::getMapInfo(context.queryMapInfo());
		CGetDFUWorkunitResponse::getMapInfo(context.queryMapInfo());
	}
	if (!stricmp("GetDFUWorkunits", method)) {
		CGetDFUWorkunits::getMapInfo(context.queryMapInfo());
		CGetDFUWorkunitsResponse::getMapInfo(context.queryMapInfo());
	}
	if (!stricmp("GetSprayTargets", method)) {
		CGetSprayTargetsRequest::getMapInfo(context.queryMapInfo());
		CGetSprayTargetsResponse::getMapInfo(context.queryMapInfo());
	}
	if (!stricmp("OpenSave", method)) {
		COpenSaveRequest::getMapInfo(context.queryMapInfo());
		COpenSaveResponse::getMapInfo(context.queryMapInfo());
	}
	if (!stricmp("Ping", method)) {
		CFileSprayPingRequest::getMapInfo(context.queryMapInfo());
		CFileSprayPingResponse::getMapInfo(context.queryMapInfo());
	}
	if (!stricmp("Rename", method)) {
		CRename::getMapInfo(context.queryMapInfo());
		CRenameResponse::getMapInfo(context.queryMapInfo());
	}
	if (!stricmp("Replicate", method)) {
		CReplicate::getMapInfo(context.queryMapInfo());
		CReplicateResponse::getMapInfo(context.queryMapInfo());
	}
	if (!stricmp("ShowResult", method)) {
		CShowResultRequest::getMapInfo(context.queryMapInfo());
		CShowResultResponse::getMapInfo(context.queryMapInfo());
	}
	if (!stricmp("SprayFixed", method)) {
		CSprayFixed::getMapInfo(context.queryMapInfo());
		CSprayFixedResponse::getMapInfo(context.queryMapInfo());
	}
	if (!stricmp("SprayVariable", method)) {
		CSprayVariable::getMapInfo(context.queryMapInfo());
		CSprayResponse::getMapInfo(context.queryMapInfo());
	}
	if (!stricmp("SubmitDFUWorkunit", method)) {
		CSubmitDFUWorkunit::getMapInfo(context.queryMapInfo());
		CSubmitDFUWorkunitResponse::getMapInfo(context.queryMapInfo());
	}
	if (!stricmp("UpdateDFUWorkunit", method)) {
		CUpdateDFUWorkunit::getMapInfo(context.queryMapInfo());
		CUpdateDFUWorkunitResponse::getMapInfo(context.queryMapInfo());
	}

	return EspHttpBinding::onGetForm(context, request, response, service, method);
}
int CFileSpraySoapBinding::onGetXForm(IEspContext &context, CHttpRequest* request, CHttpResponse* response, const char *service, const char *method)
{
	return EspHttpBinding::onGetXForm(context, request, response, service, method);
}

int CFileSpraySoapBinding::onGetService(IEspContext &context, CHttpRequest* request, CHttpResponse* response, const char *service, const char *method, const char *pathex)
{
	if(request == NULL || response == NULL)
		return -1;
	return onGetQuery(context, request, response, service, method);
}

 IRpcRequestBinding *CFileSpraySoapBinding::createReqBinding(IEspContext &context, IHttpMessage *ireq, const char *service, const char *method)
{
	CHttpRequest *request=static_cast<CHttpRequest*>(ireq);
	IProperties *props = (request) ? request->queryParameters() : NULL;

	if (!stricmp(method, "AbortDFUWorkunit") || !stricmp(method, "AbortDFUWorkunit"))
		return new CAbortDFUWorkunit(&context, "FileSpray", props, NULL);
	if (!stricmp(method, "Copy") || !stricmp(method, "Copy"))
		return new CCopy(&context, "FileSpray", props, NULL);
	if (!stricmp(method, "CreateDFUWorkunit") || !stricmp(method, "CreateDFUWorkunit"))
		return new CCreateDFUWorkunit(&context, "FileSpray", props, NULL);
	if (!stricmp(method, "DFUWUFile") || !stricmp(method, "DFUWUFileRequest"))
		return new CDFUWUFileRequest(&context, "FileSpray", props, NULL);
	if (!stricmp(method, "DFUWUSearch") || !stricmp(method, "DFUWUSearchRequest"))
		return new CDFUWUSearchRequest(&context, "FileSpray", props, NULL);
	if (!stricmp(method, "DFUWorkunitsAction") || !stricmp(method, "DFUWorkunitsActionRequest"))
		return new CDFUWorkunitsActionRequest(&context, "FileSpray", props, NULL);
	if (!stricmp(method, "DeleteDFUWorkunit") || !stricmp(method, "DeleteDFUWorkunit"))
		return new CDeleteDFUWorkunit(&context, "FileSpray", props, NULL);
	if (!stricmp(method, "DeleteDFUWorkunits") || !stricmp(method, "DeleteDFUWorkunits"))
		return new CDeleteDFUWorkunits(&context, "FileSpray", props, NULL);
	if (!stricmp(method, "DeleteDropZoneFiles") || !stricmp(method, "DeleteDropZoneFilesRequest"))
		return new CDeleteDropZoneFilesRequest(&context, "FileSpray", props, NULL);
	if (!stricmp(method, "Despray") || !stricmp(method, "Despray"))
		return new CDespray(&context, "FileSpray", props, NULL);
	if (!stricmp(method, "DfuMonitor") || !stricmp(method, "DfuMonitorRequest"))
		return new CDfuMonitorRequest(&context, "FileSpray", props, NULL);
	if (!stricmp(method, "DropZoneFileSearch") || !stricmp(method, "DropZoneFileSearchRequest"))
		return new CDropZoneFileSearchRequest(&context, "FileSpray", props, NULL);
	if (!stricmp(method, "DropZoneFiles") || !stricmp(method, "DropZoneFilesRequest"))
		return new CDropZoneFilesRequest(&context, "FileSpray", props, NULL);
	if (!stricmp(method, "EchoDateTime") || !stricmp(method, "EchoDateTime"))
		return new CEchoDateTime(&context, "FileSpray", props, NULL);
	if (!stricmp(method, "FileList") || !stricmp(method, "FileListRequest"))
		return new CFileListRequest(&context, "FileSpray", props, NULL);
	if (!stricmp(method, "GetDFUExceptions") || !stricmp(method, "GetDFUExceptions"))
		return new CGetDFUExceptions(&context, "FileSpray", props, NULL);
	if (!stricmp(method, "GetDFUProgress") || !stricmp(method, "ProgressRequest"))
		return new CProgressRequest(&context, "FileSpray", props, NULL);
	if (!stricmp(method, "GetDFUServerQueues") || !stricmp(method, "GetDFUServerQueuesRequest"))
		return new CGetDFUServerQueuesRequest(&context, "FileSpray", props, NULL);
	if (!stricmp(method, "GetDFUWorkunit") || !stricmp(method, "GetDFUWorkunit"))
		return new CGetDFUWorkunit(&context, "FileSpray", props, NULL);
	if (!stricmp(method, "GetDFUWorkunits") || !stricmp(method, "GetDFUWorkunits"))
		return new CGetDFUWorkunits(&context, "FileSpray", props, NULL);
	if (!stricmp(method, "GetSprayTargets") || !stricmp(method, "GetSprayTargetsRequest"))
		return new CGetSprayTargetsRequest(&context, "FileSpray", props, NULL);
	if (!stricmp(method, "OpenSave") || !stricmp(method, "OpenSaveRequest"))
		return new COpenSaveRequest(&context, "FileSpray", props, NULL);
	if (!stricmp(method, "Ping") || !stricmp(method, "FileSprayPingRequest"))
		return new CFileSprayPingRequest(&context, "FileSpray", props, NULL);
	if (!stricmp(method, "Rename") || !stricmp(method, "Rename"))
		return new CRename(&context, "FileSpray", props, NULL);
	if (!stricmp(method, "Replicate") || !stricmp(method, "Replicate"))
		return new CReplicate(&context, "FileSpray", props, NULL);
	if (!stricmp(method, "ShowResult") || !stricmp(method, "ShowResultRequest"))
		return new CShowResultRequest(&context, "FileSpray", props, NULL);
	if (!stricmp(method, "SprayFixed") || !stricmp(method, "SprayFixed"))
		return new CSprayFixed(&context, "FileSpray", props, NULL);
	if (!stricmp(method, "SprayVariable") || !stricmp(method, "SprayVariable"))
		return new CSprayVariable(&context, "FileSpray", props, NULL);
	if (!stricmp(method, "SubmitDFUWorkunit") || !stricmp(method, "SubmitDFUWorkunit"))
		return new CSubmitDFUWorkunit(&context, "FileSpray", props, NULL);
	if (!stricmp(method, "UpdateDFUWorkunit") || !stricmp(method, "UpdateDFUWorkunit"))
		return new CUpdateDFUWorkunit(&context, "FileSpray", props, NULL);
	return NULL;
}

int CFileSpraySoapBinding::onGetInstantQuery(IEspContext &context, CHttpRequest* request, CHttpResponse* response, const char *service, const char *method)
{
	if (context.getClientVersion()<=0)
		context.setClientVersion(1.17);

	if(request == NULL || response == NULL)
		return -1;
	StringBuffer respStr;
	Owned<IEspFileSpray> iserv = (IEspFileSpray*)getService();
	if(iserv == NULL)
	{
		respStr.append("Service not available");
		response->setContent(respStr.str());
		response->setContentType("text/html");
		response->send();
	}
	else
	{
		Owned<CSoapResponseBinding> esp_response;
		StringBuffer source;
		IEspContext& context = *request->queryContext();
		if(!stricmp(method, "AbortDFUWorkunit")||!stricmp(method, "AbortDFUWorkunit"))
		{
			Owned<CAbortDFUWorkunit> esp_request = new CAbortDFUWorkunit(&context, "FileSpray", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			Owned<CAbortDFUWorkunitResponse> esp_response = new CAbortDFUWorkunitResponse("FileSpray");
			StringBuffer source;
			source.appendf("FileSpray::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				iserv->onAbortDFUWorkunit(*request->queryContext(), *esp_request.get(), *esp_response.get());
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "FileSpray", "AbortDFUWorkunit", StringBuffer(getCFD()).append("./smc_xslt/exceptions.xslt").str()))
				return 0;
			if (canRedirect(*request) && esp_response->getRedirectUrl() && *esp_response->getRedirectUrl())
			{
				response->redirect(*request, esp_response->getRedirectUrl());
			}
			else
			{
				IProperties *props=request->queryParameters();
				if (skipXslt(context))
				{
					MemoryBuffer content;
					StringBuffer mimetype;
					esp_response->appendContent(&context,content, mimetype);
					onBeforeSendResponse(context,request,content,service,method);
					response->setContent(content.length(), content.toByteArray());
					response->setContentType(mimetype.str());
				}
				else
				{
					StringBuffer xml;
					StringBuffer sResponse;
					esp_response->serializeStruct(&context, xml, NULL);

					xslTransform(xml.str(), "/esp/xslt/dfu_wuid.xslt", sResponse.clear(), context.queryXslParameters());
					response->setContentType("text/html");
					response->setContent(sResponse.str());
				}
				response->send();
			}
			return 0;
		}
		if(!stricmp(method, "Copy")||!stricmp(method, "Copy"))
		{
			Owned<CCopy> esp_request = new CCopy(&context, "FileSpray", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			CCopyResponse* resp = new CCopyResponse("FileSpray");
			esp_response.setown(resp);
			MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
			source.setf("FileSpray::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				if(accessmap.ordinality()>0)
					onFeaturesAuthorize(context, accessmap, "FileSpray", "Copy");
				iserv->onCopy(context, *esp_request.get(), *resp);
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "FileSpray", "Copy", StringBuffer(getCFD()).append("./smc_xslt/exceptions.xslt").str()))
				return 0;
		}
		if(!stricmp(method, "CreateDFUWorkunit")||!stricmp(method, "CreateDFUWorkunit"))
		{
			Owned<CCreateDFUWorkunit> esp_request = new CCreateDFUWorkunit(&context, "FileSpray", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			Owned<CCreateDFUWorkunitResponse> esp_response = new CCreateDFUWorkunitResponse("FileSpray");
			StringBuffer source;
			source.appendf("FileSpray::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				iserv->onCreateDFUWorkunit(*request->queryContext(), *esp_request.get(), *esp_response.get());
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "FileSpray", "CreateDFUWorkunit", StringBuffer(getCFD()).append("./smc_xslt/exceptions.xslt").str()))
				return 0;
			if (canRedirect(*request) && esp_response->getRedirectUrl() && *esp_response->getRedirectUrl())
			{
				response->redirect(*request, esp_response->getRedirectUrl());
			}
			else
			{
				IProperties *props=request->queryParameters();
				if (skipXslt(context))
				{
					MemoryBuffer content;
					StringBuffer mimetype;
					esp_response->appendContent(&context,content, mimetype);
					onBeforeSendResponse(context,request,content,service,method);
					response->setContent(content.length(), content.toByteArray());
					response->setContentType(mimetype.str());
				}
				else
				{
					StringBuffer xml;
					StringBuffer sResponse;
					esp_response->serializeStruct(&context, xml, NULL);

					xslTransform(xml.str(), "/esp/xslt/dfu_wuid.xslt", sResponse.clear(), context.queryXslParameters());
					response->setContentType("text/html");
					response->setContent(sResponse.str());
				}
				response->send();
			}
			return 0;
		}
		if(!stricmp(method, "DFUWUFile")||!stricmp(method, "DFUWUFileRequest"))
		{
			Owned<CDFUWUFileRequest> esp_request = new CDFUWUFileRequest(&context, "FileSpray", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			CDFUWUFileResponse* resp = new CDFUWUFileResponse("FileSpray");
			esp_response.setown(resp);
			MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
			source.setf("FileSpray::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				if(accessmap.ordinality()>0)
					onFeaturesAuthorize(context, accessmap, "FileSpray", "DFUWUFile");
				iserv->onDFUWUFile(context, *esp_request.get(), *resp);
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "FileSpray", "DFUWUFile", StringBuffer(getCFD()).append("./smc_xslt/exceptions.xslt").str()))
				return 0;
		}
		if(!stricmp(method, "DFUWUSearch")||!stricmp(method, "DFUWUSearchRequest"))
		{
			Owned<CDFUWUSearchRequest> esp_request = new CDFUWUSearchRequest(&context, "FileSpray", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			Owned<CDFUWUSearchResponse> esp_response = new CDFUWUSearchResponse("FileSpray");
			StringBuffer source;
			source.appendf("FileSpray::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				iserv->onDFUWUSearch(*request->queryContext(), *esp_request.get(), *esp_response.get());
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "FileSpray", "DFUWUSearch", StringBuffer(getCFD()).append("./smc_xslt/exceptions.xslt").str()))
				return 0;
			if (canRedirect(*request) && esp_response->getRedirectUrl() && *esp_response->getRedirectUrl())
			{
				response->redirect(*request, esp_response->getRedirectUrl());
			}
			else
			{
				IProperties *props=request->queryParameters();
				if (skipXslt(context))
				{
					MemoryBuffer content;
					StringBuffer mimetype;
					esp_response->appendContent(&context,content, mimetype);
					onBeforeSendResponse(context,request,content,service,method);
					response->setContent(content.length(), content.toByteArray());
					response->setContentType(mimetype.str());
				}
				else
				{
					StringBuffer xml;
					StringBuffer sResponse;
					esp_response->serializeStruct(&context, xml, NULL);

					xslTransform(xml.str(), "/esp/xslt/dfuwu_search.xslt", sResponse.clear(), context.queryXslParameters());
					response->setContentType("text/html");
					response->setContent(sResponse.str());
				}
				response->send();
			}
			return 0;
		}
		if(!stricmp(method, "DFUWorkunitsAction")||!stricmp(method, "DFUWorkunitsActionRequest"))
		{
			Owned<CDFUWorkunitsActionRequest> esp_request = new CDFUWorkunitsActionRequest(&context, "FileSpray", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			Owned<CDFUWorkunitsActionResponse> esp_response = new CDFUWorkunitsActionResponse("FileSpray");
			StringBuffer source;
			source.appendf("FileSpray::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				iserv->onDFUWorkunitsAction(*request->queryContext(), *esp_request.get(), *esp_response.get());
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "FileSpray", "DFUWorkunitsAction", StringBuffer(getCFD()).append("./smc_xslt/exceptions.xslt").str()))
				return 0;
			if (canRedirect(*request) && esp_response->getRedirectUrl() && *esp_response->getRedirectUrl())
			{
				response->redirect(*request, esp_response->getRedirectUrl());
			}
			else
			{
				IProperties *props=request->queryParameters();
				if (skipXslt(context))
				{
					MemoryBuffer content;
					StringBuffer mimetype;
					esp_response->appendContent(&context,content, mimetype);
					onBeforeSendResponse(context,request,content,service,method);
					response->setContent(content.length(), content.toByteArray());
					response->setContentType(mimetype.str());
				}
				else
				{
					StringBuffer xml;
					StringBuffer sResponse;
					esp_response->serializeStruct(&context, xml, NULL);

					xslTransform(xml.str(), "/esp/xslt/dfuwuaction_results.xslt", sResponse.clear(), context.queryXslParameters());
					response->setContentType("text/html");
					response->setContent(sResponse.str());
				}
				response->send();
			}
			return 0;
		}
		if(!stricmp(method, "DeleteDFUWorkunit")||!stricmp(method, "DeleteDFUWorkunit"))
		{
			Owned<CDeleteDFUWorkunit> esp_request = new CDeleteDFUWorkunit(&context, "FileSpray", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			CDeleteDFUWorkunitResponse* resp = new CDeleteDFUWorkunitResponse("FileSpray");
			esp_response.setown(resp);
			MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
			source.setf("FileSpray::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				if(accessmap.ordinality()>0)
					onFeaturesAuthorize(context, accessmap, "FileSpray", "DeleteDFUWorkunit");
				iserv->onDeleteDFUWorkunit(context, *esp_request.get(), *resp);
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "FileSpray", "DeleteDFUWorkunit", StringBuffer(getCFD()).append("./smc_xslt/exceptions.xslt").str()))
				return 0;
		}
		if(!stricmp(method, "DeleteDFUWorkunits")||!stricmp(method, "DeleteDFUWorkunits"))
		{
			Owned<CDeleteDFUWorkunits> esp_request = new CDeleteDFUWorkunits(&context, "FileSpray", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			CDeleteDFUWorkunitsResponse* resp = new CDeleteDFUWorkunitsResponse("FileSpray");
			esp_response.setown(resp);
			MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
			source.setf("FileSpray::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				if(accessmap.ordinality()>0)
					onFeaturesAuthorize(context, accessmap, "FileSpray", "DeleteDFUWorkunits");
				iserv->onDeleteDFUWorkunits(context, *esp_request.get(), *resp);
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "FileSpray", "DeleteDFUWorkunits", StringBuffer(getCFD()).append("./smc_xslt/exceptions.xslt").str()))
				return 0;
		}
		if(!stricmp(method, "DeleteDropZoneFiles")||!stricmp(method, "DeleteDropZoneFilesRequest"))
		{
			Owned<CDeleteDropZoneFilesRequest> esp_request = new CDeleteDropZoneFilesRequest(&context, "FileSpray", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			Owned<CDFUWorkunitsActionResponse> esp_response = new CDFUWorkunitsActionResponse("FileSpray");
			StringBuffer source;
			source.appendf("FileSpray::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				iserv->onDeleteDropZoneFiles(*request->queryContext(), *esp_request.get(), *esp_response.get());
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "FileSpray", "DeleteDropZoneFiles", StringBuffer(getCFD()).append("./smc_xslt/exceptions.xslt").str()))
				return 0;
			if (canRedirect(*request) && esp_response->getRedirectUrl() && *esp_response->getRedirectUrl())
			{
				response->redirect(*request, esp_response->getRedirectUrl());
			}
			else
			{
				IProperties *props=request->queryParameters();
				if (skipXslt(context))
				{
					MemoryBuffer content;
					StringBuffer mimetype;
					esp_response->appendContent(&context,content, mimetype);
					onBeforeSendResponse(context,request,content,service,method);
					response->setContent(content.length(), content.toByteArray());
					response->setContentType(mimetype.str());
				}
				else
				{
					StringBuffer xml;
					StringBuffer sResponse;
					esp_response->serializeStruct(&context, xml, NULL);

					xslTransform(xml.str(), "/esp/xslt/dfuwuaction_results.xslt", sResponse.clear(), context.queryXslParameters());
					response->setContentType("text/html");
					response->setContent(sResponse.str());
				}
				response->send();
			}
			return 0;
		}
		if(!stricmp(method, "Despray")||!stricmp(method, "Despray"))
		{
			Owned<CDespray> esp_request = new CDespray(&context, "FileSpray", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			CDesprayResponse* resp = new CDesprayResponse("FileSpray");
			esp_response.setown(resp);
			MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
			source.setf("FileSpray::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				if(accessmap.ordinality()>0)
					onFeaturesAuthorize(context, accessmap, "FileSpray", "Despray");
				iserv->onDespray(context, *esp_request.get(), *resp);
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "FileSpray", "Despray", StringBuffer(getCFD()).append("./smc_xslt/exceptions.xslt").str()))
				return 0;
		}
		if(!stricmp(method, "DfuMonitor")||!stricmp(method, "DfuMonitorRequest"))
		{
			Owned<CDfuMonitorRequest> esp_request = new CDfuMonitorRequest(&context, "FileSpray", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			CDfuMonitorResponse* resp = new CDfuMonitorResponse("FileSpray");
			esp_response.setown(resp);
			MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
			source.setf("FileSpray::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				if(accessmap.ordinality()>0)
					onFeaturesAuthorize(context, accessmap, "FileSpray", "DfuMonitor");
				iserv->onDfuMonitor(context, *esp_request.get(), *resp);
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "FileSpray", "DfuMonitor", StringBuffer(getCFD()).append("./smc_xslt/exceptions.xslt").str()))
				return 0;
		}
		if(!stricmp(method, "DropZoneFileSearch")||!stricmp(method, "DropZoneFileSearchRequest"))
		{
			Owned<CDropZoneFileSearchRequest> esp_request = new CDropZoneFileSearchRequest(&context, "FileSpray", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			CDropZoneFileSearchResponse* resp = new CDropZoneFileSearchResponse("FileSpray");
			esp_response.setown(resp);
			MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
			source.setf("FileSpray::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				if(accessmap.ordinality()>0)
					onFeaturesAuthorize(context, accessmap, "FileSpray", "DropZoneFileSearch");
				iserv->onDropZoneFileSearch(context, *esp_request.get(), *resp);
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "FileSpray", "DropZoneFileSearch", StringBuffer(getCFD()).append("./smc_xslt/exceptions.xslt").str()))
				return 0;
		}
		if(!stricmp(method, "DropZoneFiles")||!stricmp(method, "DropZoneFilesRequest"))
		{
			Owned<CDropZoneFilesRequest> esp_request = new CDropZoneFilesRequest(&context, "FileSpray", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			Owned<CDropZoneFilesResponse> esp_response = new CDropZoneFilesResponse("FileSpray");
			StringBuffer source;
			source.appendf("FileSpray::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				iserv->onDropZoneFiles(*request->queryContext(), *esp_request.get(), *esp_response.get());
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "FileSpray", "DropZoneFiles", StringBuffer(getCFD()).append("./smc_xslt/exceptions.xslt").str()))
				return 0;
			if (canRedirect(*request) && esp_response->getRedirectUrl() && *esp_response->getRedirectUrl())
			{
				response->redirect(*request, esp_response->getRedirectUrl());
			}
			else
			{
				IProperties *props=request->queryParameters();
				if (skipXslt(context))
				{
					MemoryBuffer content;
					StringBuffer mimetype;
					esp_response->appendContent(&context,content, mimetype);
					onBeforeSendResponse(context,request,content,service,method);
					response->setContent(content.length(), content.toByteArray());
					response->setContentType(mimetype.str());
				}
				else
				{
					StringBuffer xml;
					StringBuffer sResponse;
					esp_response->serializeStruct(&context, xml, NULL);

					xslTransform(xml.str(), "/esp/xslt/dropzonefile.xslt", sResponse.clear(), context.queryXslParameters());
					response->setContentType("text/html");
					response->setContent(sResponse.str());
				}
				response->send();
			}
			return 0;
		}
		if(!stricmp(method, "EchoDateTime")||!stricmp(method, "EchoDateTime"))
		{
			Owned<CEchoDateTime> esp_request = new CEchoDateTime(&context, "FileSpray", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			CEchoDateTimeResponse* resp = new CEchoDateTimeResponse("FileSpray");
			esp_response.setown(resp);
			MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
			source.setf("FileSpray::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				if(accessmap.ordinality()>0)
					onFeaturesAuthorize(context, accessmap, "FileSpray", "EchoDateTime");
				iserv->onEchoDateTime(context, *esp_request.get(), *resp);
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "FileSpray", "EchoDateTime", StringBuffer(getCFD()).append("./smc_xslt/exceptions.xslt").str()))
				return 0;
		}
		if(!stricmp(method, "FileList")||!stricmp(method, "FileListRequest"))
		{
			Owned<CFileListRequest> esp_request = new CFileListRequest(&context, "FileSpray", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			Owned<CFileListResponse> esp_response = new CFileListResponse("FileSpray");
			StringBuffer source;
			source.appendf("FileSpray::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				iserv->onFileList(*request->queryContext(), *esp_request.get(), *esp_response.get());
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "FileSpray", "FileList", StringBuffer(getCFD()).append("./smc_xslt/exceptions.xslt").str()))
				return 0;
			if (canRedirect(*request) && esp_response->getRedirectUrl() && *esp_response->getRedirectUrl())
			{
				response->redirect(*request, esp_response->getRedirectUrl());
			}
			else
			{
				IProperties *props=request->queryParameters();
				if (skipXslt(context))
				{
					MemoryBuffer content;
					StringBuffer mimetype;
					esp_response->appendContent(&context,content, mimetype);
					onBeforeSendResponse(context,request,content,service,method);
					response->setContent(content.length(), content.toByteArray());
					response->setContentType(mimetype.str());
				}
				else
				{
					StringBuffer xml;
					StringBuffer sResponse;
					esp_response->serializeStruct(&context, xml, NULL);

					xslTransform(xml.str(), "/esp/xslt/dfu_filelist.xslt", sResponse.clear(), context.queryXslParameters());
					response->setContentType("text/html");
					response->setContent(sResponse.str());
				}
				response->send();
			}
			return 0;
		}
		if(!stricmp(method, "GetDFUExceptions")||!stricmp(method, "GetDFUExceptions"))
		{
			Owned<CGetDFUExceptions> esp_request = new CGetDFUExceptions(&context, "FileSpray", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			CGetDFUExceptionsResponse* resp = new CGetDFUExceptionsResponse("FileSpray");
			esp_response.setown(resp);
			MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
			source.setf("FileSpray::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				if(accessmap.ordinality()>0)
					onFeaturesAuthorize(context, accessmap, "FileSpray", "GetDFUExceptions");
				iserv->onGetDFUExceptions(context, *esp_request.get(), *resp);
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "FileSpray", "GetDFUExceptions", StringBuffer(getCFD()).append("./smc_xslt/exceptions.xslt").str()))
				return 0;
		}
		if(!stricmp(method, "GetDFUProgress")||!stricmp(method, "ProgressRequest"))
		{
			Owned<CProgressRequest> esp_request = new CProgressRequest(&context, "FileSpray", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			Owned<CProgressResponse> esp_response = new CProgressResponse("FileSpray");
			StringBuffer source;
			source.appendf("FileSpray::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				iserv->onGetDFUProgress(*request->queryContext(), *esp_request.get(), *esp_response.get());
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "FileSpray", "GetDFUProgress", StringBuffer(getCFD()).append("./smc_xslt/exceptions.xslt").str()))
				return 0;
			if (canRedirect(*request) && esp_response->getRedirectUrl() && *esp_response->getRedirectUrl())
			{
				response->redirect(*request, esp_response->getRedirectUrl());
			}
			else
			{
				IProperties *props=request->queryParameters();
				if (skipXslt(context))
				{
					MemoryBuffer content;
					StringBuffer mimetype;
					esp_response->appendContent(&context,content, mimetype);
					onBeforeSendResponse(context,request,content,service,method);
					response->setContent(content.length(), content.toByteArray());
					response->setContentType(mimetype.str());
				}
				else
				{
					StringBuffer xml;
					StringBuffer sResponse;
					esp_response->serializeStruct(&context, xml, NULL);

					xslTransform(xml.str(), "/esp/xslt/dfu_progress.xslt", sResponse.clear(), context.queryXslParameters());
					response->setContentType("text/html");
					response->setContent(sResponse.str());
				}
				response->send();
			}
			return 0;
		}
		if(!stricmp(method, "GetDFUServerQueues")||!stricmp(method, "GetDFUServerQueuesRequest"))
		{
			Owned<CGetDFUServerQueuesRequest> esp_request = new CGetDFUServerQueuesRequest(&context, "FileSpray", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			CGetDFUServerQueuesResponse* resp = new CGetDFUServerQueuesResponse("FileSpray");
			esp_response.setown(resp);
			MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
			source.setf("FileSpray::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				if(accessmap.ordinality()>0)
					onFeaturesAuthorize(context, accessmap, "FileSpray", "GetDFUServerQueues");
				iserv->onGetDFUServerQueues(context, *esp_request.get(), *resp);
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "FileSpray", "GetDFUServerQueues", StringBuffer(getCFD()).append("./smc_xslt/exceptions.xslt").str()))
				return 0;
		}
		if(!stricmp(method, "GetDFUWorkunit")||!stricmp(method, "GetDFUWorkunit"))
		{
			Owned<CGetDFUWorkunit> esp_request = new CGetDFUWorkunit(&context, "FileSpray", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			Owned<CGetDFUWorkunitResponse> esp_response = new CGetDFUWorkunitResponse("FileSpray");
			StringBuffer source;
			source.appendf("FileSpray::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				iserv->onGetDFUWorkunit(*request->queryContext(), *esp_request.get(), *esp_response.get());
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "FileSpray", "GetDFUWorkunit", StringBuffer(getCFD()).append("./smc_xslt/exceptions.xslt").str()))
				return 0;
			if (canRedirect(*request) && esp_response->getRedirectUrl() && *esp_response->getRedirectUrl())
			{
				response->redirect(*request, esp_response->getRedirectUrl());
			}
			else
			{
				IProperties *props=request->queryParameters();
				if (skipXslt(context))
				{
					MemoryBuffer content;
					StringBuffer mimetype;
					esp_response->appendContent(&context,content, mimetype);
					onBeforeSendResponse(context,request,content,service,method);
					response->setContent(content.length(), content.toByteArray());
					response->setContentType(mimetype.str());
				}
				else
				{
					StringBuffer xml;
					StringBuffer sResponse;
					esp_response->serializeStruct(&context, xml, NULL);

					xslTransform(xml.str(), "/esp/xslt/dfu_wuid.xslt", sResponse.clear(), context.queryXslParameters());
					response->setContentType("text/html");
					response->setContent(sResponse.str());
				}
				response->send();
			}
			return 0;
		}
		if(!stricmp(method, "GetDFUWorkunits")||!stricmp(method, "GetDFUWorkunits"))
		{
			Owned<CGetDFUWorkunits> esp_request = new CGetDFUWorkunits(&context, "FileSpray", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			Owned<CGetDFUWorkunitsResponse> esp_response = new CGetDFUWorkunitsResponse("FileSpray");
			StringBuffer source;
			source.appendf("FileSpray::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				iserv->onGetDFUWorkunits(*request->queryContext(), *esp_request.get(), *esp_response.get());
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "FileSpray", "GetDFUWorkunits", StringBuffer(getCFD()).append("./smc_xslt/exceptions.xslt").str()))
				return 0;
			if (canRedirect(*request) && esp_response->getRedirectUrl() && *esp_response->getRedirectUrl())
			{
				response->redirect(*request, esp_response->getRedirectUrl());
			}
			else
			{
				IProperties *props=request->queryParameters();
				if (skipXslt(context))
				{
					MemoryBuffer content;
					StringBuffer mimetype;
					esp_response->appendContent(&context,content, mimetype);
					onBeforeSendResponse(context,request,content,service,method);
					response->setContent(content.length(), content.toByteArray());
					response->setContentType(mimetype.str());
				}
				else
				{
					StringBuffer xml;
					StringBuffer sResponse;
					esp_response->serializeStruct(&context, xml, NULL);

					xslTransform(xml.str(), "/esp/xslt/dfu_workunits.xslt", sResponse.clear(), context.queryXslParameters());
					response->setContentType("text/html");
					response->setContent(sResponse.str());
				}
				response->send();
			}
			return 0;
		}
		if(!stricmp(method, "GetSprayTargets")||!stricmp(method, "GetSprayTargetsRequest"))
		{
			Owned<CGetSprayTargetsRequest> esp_request = new CGetSprayTargetsRequest(&context, "FileSpray", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			CGetSprayTargetsResponse* resp = new CGetSprayTargetsResponse("FileSpray");
			esp_response.setown(resp);
			MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
			source.setf("FileSpray::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				if(accessmap.ordinality()>0)
					onFeaturesAuthorize(context, accessmap, "FileSpray", "GetSprayTargets");
				iserv->onGetSprayTargets(context, *esp_request.get(), *resp);
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "FileSpray", "GetSprayTargets", StringBuffer(getCFD()).append("./smc_xslt/exceptions.xslt").str()))
				return 0;
		}
		if(!stricmp(method, "OpenSave")||!stricmp(method, "OpenSaveRequest"))
		{
			Owned<COpenSaveRequest> esp_request = new COpenSaveRequest(&context, "FileSpray", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			Owned<COpenSaveResponse> esp_response = new COpenSaveResponse("FileSpray");
			StringBuffer source;
			source.appendf("FileSpray::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				iserv->onOpenSave(*request->queryContext(), *esp_request.get(), *esp_response.get());
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "FileSpray", "OpenSave", StringBuffer(getCFD()).append("./smc_xslt/exceptions.xslt").str()))
				return 0;
			if (canRedirect(*request) && esp_response->getRedirectUrl() && *esp_response->getRedirectUrl())
			{
				response->redirect(*request, esp_response->getRedirectUrl());
			}
			else
			{
				IProperties *props=request->queryParameters();
				if (skipXslt(context))
				{
					MemoryBuffer content;
					StringBuffer mimetype;
					esp_response->appendContent(&context,content, mimetype);
					onBeforeSendResponse(context,request,content,service,method);
					response->setContent(content.length(), content.toByteArray());
					response->setContentType(mimetype.str());
				}
				else
				{
					StringBuffer xml;
					StringBuffer sResponse;
					esp_response->serializeStruct(&context, xml, NULL);

					xslTransform(xml.str(), "/esp/xslt/opensave.xslt", sResponse.clear(), context.queryXslParameters());
					response->setContentType("text/html");
					response->setContent(sResponse.str());
				}
				response->send();
			}
			return 0;
		}
		if(!stricmp(method, "Ping")||!stricmp(method, "FileSprayPingRequest"))
		{
			Owned<CFileSprayPingRequest> esp_request = new CFileSprayPingRequest(&context, "FileSpray", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			CFileSprayPingResponse* resp = new CFileSprayPingResponse("FileSpray");
			esp_response.setown(resp);
			MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
			source.setf("FileSpray::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				if(accessmap.ordinality()>0)
					onFeaturesAuthorize(context, accessmap, "FileSpray", "Ping");
				iserv->onPing(context, *esp_request.get(), *resp);
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "FileSpray", "Ping", StringBuffer(getCFD()).append("./smc_xslt/exceptions.xslt").str()))
				return 0;
		}
		if(!stricmp(method, "Rename")||!stricmp(method, "Rename"))
		{
			Owned<CRename> esp_request = new CRename(&context, "FileSpray", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			CRenameResponse* resp = new CRenameResponse("FileSpray");
			esp_response.setown(resp);
			MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
			source.setf("FileSpray::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				if(accessmap.ordinality()>0)
					onFeaturesAuthorize(context, accessmap, "FileSpray", "Rename");
				iserv->onRename(context, *esp_request.get(), *resp);
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "FileSpray", "Rename", StringBuffer(getCFD()).append("./smc_xslt/exceptions.xslt").str()))
				return 0;
		}
		if(!stricmp(method, "Replicate")||!stricmp(method, "Replicate"))
		{
			Owned<CReplicate> esp_request = new CReplicate(&context, "FileSpray", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			CReplicateResponse* resp = new CReplicateResponse("FileSpray");
			esp_response.setown(resp);
			MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
			source.setf("FileSpray::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				if(accessmap.ordinality()>0)
					onFeaturesAuthorize(context, accessmap, "FileSpray", "Replicate");
				iserv->onReplicate(context, *esp_request.get(), *resp);
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "FileSpray", "Replicate", StringBuffer(getCFD()).append("./smc_xslt/exceptions.xslt").str()))
				return 0;
		}
		if(!stricmp(method, "ShowResult")||!stricmp(method, "ShowResultRequest"))
		{
			Owned<CShowResultRequest> esp_request = new CShowResultRequest(&context, "FileSpray", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			Owned<CShowResultResponse> esp_response = new CShowResultResponse("FileSpray");
			StringBuffer source;
			source.appendf("FileSpray::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				iserv->onShowResult(*request->queryContext(), *esp_request.get(), *esp_response.get());
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "FileSpray", "ShowResult", StringBuffer(getCFD()).append("./smc_xslt/exceptions.xslt").str()))
				return 0;
			if (canRedirect(*request) && esp_response->getRedirectUrl() && *esp_response->getRedirectUrl())
			{
				response->redirect(*request, esp_response->getRedirectUrl());
			}
			else
			{
				IProperties *props=request->queryParameters();
				if (skipXslt(context))
				{
					MemoryBuffer content;
					StringBuffer mimetype;
					esp_response->appendContent(&context,content, mimetype);
					onBeforeSendResponse(context,request,content,service,method);
					response->setContent(content.length(), content.toByteArray());
					response->setContentType(mimetype.str());
				}
				else
				{
					StringBuffer xml;
					StringBuffer sResponse;
					esp_response->serializeStruct(&context, xml, NULL);

					xslTransform(xml.str(), "/esp/xslt/showresult.xslt", sResponse.clear(), context.queryXslParameters());
					response->setContentType("text/html");
					response->setContent(sResponse.str());
				}
				response->send();
			}
			return 0;
		}
		if(!stricmp(method, "SprayFixed")||!stricmp(method, "SprayFixed"))
		{
			Owned<CSprayFixed> esp_request = new CSprayFixed(&context, "FileSpray", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			CSprayFixedResponse* resp = new CSprayFixedResponse("FileSpray");
			esp_response.setown(resp);
			MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
			source.setf("FileSpray::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				if(accessmap.ordinality()>0)
					onFeaturesAuthorize(context, accessmap, "FileSpray", "SprayFixed");
				iserv->onSprayFixed(context, *esp_request.get(), *resp);
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "FileSpray", "SprayFixed", StringBuffer(getCFD()).append("./smc_xslt/exceptions.xslt").str()))
				return 0;
		}
		if(!stricmp(method, "SprayVariable")||!stricmp(method, "SprayVariable"))
		{
			Owned<CSprayVariable> esp_request = new CSprayVariable(&context, "FileSpray", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			CSprayResponse* resp = new CSprayResponse("FileSpray");
			esp_response.setown(resp);
			MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
			source.setf("FileSpray::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				if(accessmap.ordinality()>0)
					onFeaturesAuthorize(context, accessmap, "FileSpray", "SprayVariable");
				iserv->onSprayVariable(context, *esp_request.get(), *resp);
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "FileSpray", "SprayVariable", StringBuffer(getCFD()).append("./smc_xslt/exceptions.xslt").str()))
				return 0;
		}
		if(!stricmp(method, "SubmitDFUWorkunit")||!stricmp(method, "SubmitDFUWorkunit"))
		{
			Owned<CSubmitDFUWorkunit> esp_request = new CSubmitDFUWorkunit(&context, "FileSpray", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			Owned<CSubmitDFUWorkunitResponse> esp_response = new CSubmitDFUWorkunitResponse("FileSpray");
			StringBuffer source;
			source.appendf("FileSpray::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				iserv->onSubmitDFUWorkunit(*request->queryContext(), *esp_request.get(), *esp_response.get());
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "FileSpray", "SubmitDFUWorkunit", StringBuffer(getCFD()).append("./smc_xslt/exceptions.xslt").str()))
				return 0;
			if (canRedirect(*request) && esp_response->getRedirectUrl() && *esp_response->getRedirectUrl())
			{
				response->redirect(*request, esp_response->getRedirectUrl());
			}
			else
			{
				IProperties *props=request->queryParameters();
				if (skipXslt(context))
				{
					MemoryBuffer content;
					StringBuffer mimetype;
					esp_response->appendContent(&context,content, mimetype);
					onBeforeSendResponse(context,request,content,service,method);
					response->setContent(content.length(), content.toByteArray());
					response->setContentType(mimetype.str());
				}
				else
				{
					StringBuffer xml;
					StringBuffer sResponse;
					esp_response->serializeStruct(&context, xml, NULL);

					xslTransform(xml.str(), "/esp/xslt/dfu_wuid.xslt", sResponse.clear(), context.queryXslParameters());
					response->setContentType("text/html");
					response->setContent(sResponse.str());
				}
				response->send();
			}
			return 0;
		}
		if(!stricmp(method, "UpdateDFUWorkunit")||!stricmp(method, "UpdateDFUWorkunit"))
		{
			Owned<CUpdateDFUWorkunit> esp_request = new CUpdateDFUWorkunit(&context, "FileSpray", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			Owned<CUpdateDFUWorkunitResponse> esp_response = new CUpdateDFUWorkunitResponse("FileSpray");
			StringBuffer source;
			source.appendf("FileSpray::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				iserv->onUpdateDFUWorkunit(*request->queryContext(), *esp_request.get(), *esp_response.get());
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "FileSpray", "UpdateDFUWorkunit", StringBuffer(getCFD()).append("./smc_xslt/exceptions.xslt").str()))
				return 0;
			if (canRedirect(*request) && esp_response->getRedirectUrl() && *esp_response->getRedirectUrl())
			{
				response->redirect(*request, esp_response->getRedirectUrl());
			}
			else
			{
				IProperties *props=request->queryParameters();
				if (skipXslt(context))
				{
					MemoryBuffer content;
					StringBuffer mimetype;
					esp_response->appendContent(&context,content, mimetype);
					onBeforeSendResponse(context,request,content,service,method);
					response->setContent(content.length(), content.toByteArray());
					response->setContentType(mimetype.str());
				}
				else
				{
					StringBuffer xml;
					StringBuffer sResponse;
					esp_response->serializeStruct(&context, xml, NULL);

					xslTransform(xml.str(), "/esp/xslt/dfu_wuid.xslt", sResponse.clear(), context.queryXslParameters());
					response->setContentType("text/html");
					response->setContent(sResponse.str());
				}
				response->send();
			}
			return 0;
		}

		if (esp_response.get())
		{
			if (canRedirect(*request) && esp_response->getRedirectUrl() && *esp_response->getRedirectUrl())
				response->redirect(*request, esp_response->getRedirectUrl());
			else
			{
				MemoryBuffer content;
				StringBuffer mimetype;
				esp_response->appendContent(&context,content, mimetype);
				onBeforeSendResponse(context,request,content,service,method);
				response->setContent(content.length(), content.toByteArray());
				response->setContentType(mimetype.str());
				response->send();
			}
			return 0;
		}
	}
	return onGetNotFound(context, request,  response, service);
}





//=======================================================
// client util methods
//=======================================================

//------ method AbortDFUWorkunit ---------

IClientAbortDFUWorkunit * CClientFileSpray::createAbortDFUWorkunitRequest()
{
	CAbortDFUWorkunit* request = new CAbortDFUWorkunit("FileSpray");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientAbortDFUWorkunitResponse * CClientFileSpray::AbortDFUWorkunit(IClientAbortDFUWorkunit *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CAbortDFUWorkunit* esprequest = static_cast<CAbortDFUWorkunit*>(request);
	CAbortDFUWorkunitResponse* espresponse = new CAbortDFUWorkunitResponse("FileSpray");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientFileSpray::async_AbortDFUWorkunit(IClientAbortDFUWorkunit *request, IClientFileSprayEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CAbortDFUWorkunit* esprequest = static_cast<CAbortDFUWorkunit*>(request);
	esprequest->setMethod("AbortDFUWorkunit");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientFileSpray::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientAbortDFUWorkunitResponse *CClientFileSpray::AbortDFUWorkunitFn(const char * wuid_)
{
	Owned<IClientAbortDFUWorkunit> req =  createAbortDFUWorkunitRequest();
	req->setWuid(wuid_);
	return AbortDFUWorkunit(req.get());
}

//------ method Copy ---------

IClientCopy * CClientFileSpray::createCopyRequest()
{
	CCopy* request = new CCopy("FileSpray");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientCopyResponse * CClientFileSpray::Copy(IClientCopy *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CCopy* esprequest = static_cast<CCopy*>(request);
	CCopyResponse* espresponse = new CCopyResponse("FileSpray");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientFileSpray::async_Copy(IClientCopy *request, IClientFileSprayEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CCopy* esprequest = static_cast<CCopy*>(request);
	esprequest->setMethod("Copy");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientFileSpray::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientCopyResponse *CClientFileSpray::CopyFn(const char * sourceLogicalName_, const char * destGroup_, const char * destGroupRoxie_, const char * destLogicalName_, const char * sourceDali_, const char * srcusername_, const char * srcpassword_, bool overwrite_, bool replicate_, int ReplicateOffset_, int maxConnections_, int throttle_, int transferBufferSize_, bool nosplit_, bool norecover_, bool compress_, bool Wrap_, bool Multicopy_, const char * SourceDiffKeyName_, const char * DestDiffKeyName_, bool superCopy_, bool push_, bool pull_, bool ifnewer_, const char * encrypt_, const char * decrypt_, bool preserveCompression_, const char * DFUServerQueue_, int ExpireDays_)
{
	Owned<IClientCopy> req =  createCopyRequest();
	req->setSourceLogicalName(sourceLogicalName_);
	req->setDestGroup(destGroup_);
	req->setDestGroupRoxie(destGroupRoxie_);
	req->setDestLogicalName(destLogicalName_);
	req->setSourceDali(sourceDali_);
	req->setSrcusername(srcusername_);
	req->setSrcpassword(srcpassword_);
	req->setOverwrite(overwrite_);
	req->setReplicate(replicate_);
	req->setReplicateOffset(ReplicateOffset_);
	req->setMaxConnections(maxConnections_);
	req->setThrottle(throttle_);
	req->setTransferBufferSize(transferBufferSize_);
	req->setNosplit(nosplit_);
	req->setNorecover(norecover_);
	req->setCompress(compress_);
	req->setWrap(Wrap_);
	req->setMulticopy(Multicopy_);
	req->setSourceDiffKeyName(SourceDiffKeyName_);
	req->setDestDiffKeyName(DestDiffKeyName_);
	req->setSuperCopy(superCopy_);
	req->setPush(push_);
	req->setPull(pull_);
	req->setIfnewer(ifnewer_);
	req->setEncrypt(encrypt_);
	req->setDecrypt(decrypt_);
	req->setPreserveCompression(preserveCompression_);
	req->setDFUServerQueue(DFUServerQueue_);
	req->setExpireDays(ExpireDays_);
	return Copy(req.get());
}

//------ method CreateDFUWorkunit ---------

IClientCreateDFUWorkunit * CClientFileSpray::createCreateDFUWorkunitRequest()
{
	CCreateDFUWorkunit* request = new CCreateDFUWorkunit("FileSpray");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientCreateDFUWorkunitResponse * CClientFileSpray::CreateDFUWorkunit(IClientCreateDFUWorkunit *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CCreateDFUWorkunit* esprequest = static_cast<CCreateDFUWorkunit*>(request);
	CCreateDFUWorkunitResponse* espresponse = new CCreateDFUWorkunitResponse("FileSpray");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientFileSpray::async_CreateDFUWorkunit(IClientCreateDFUWorkunit *request, IClientFileSprayEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CCreateDFUWorkunit* esprequest = static_cast<CCreateDFUWorkunit*>(request);
	esprequest->setMethod("CreateDFUWorkunit");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientFileSpray::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientCreateDFUWorkunitResponse *CClientFileSpray::CreateDFUWorkunitFn(const char * DFUServerQueue_)
{
	Owned<IClientCreateDFUWorkunit> req =  createCreateDFUWorkunitRequest();
	req->setDFUServerQueue(DFUServerQueue_);
	return CreateDFUWorkunit(req.get());
}

//------ method DFUWUFile ---------

IClientDFUWUFileRequest * CClientFileSpray::createDFUWUFileRequest()
{
	CDFUWUFileRequest* request = new CDFUWUFileRequest("FileSpray");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientDFUWUFileResponse * CClientFileSpray::DFUWUFile(IClientDFUWUFileRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CDFUWUFileRequest* esprequest = static_cast<CDFUWUFileRequest*>(request);
	CDFUWUFileResponse* espresponse = new CDFUWUFileResponse("FileSpray");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientFileSpray::async_DFUWUFile(IClientDFUWUFileRequest *request, IClientFileSprayEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CDFUWUFileRequest* esprequest = static_cast<CDFUWUFileRequest*>(request);
	esprequest->setMethod("DFUWUFile");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientFileSpray::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientDFUWUFileResponse *CClientFileSpray::DFUWUFileFn(const char * Wuid_, const char * Type_, const char * PlainText_)
{
	Owned<IClientDFUWUFileRequest> req =  createDFUWUFileRequest();
	req->setWuid(Wuid_);
	req->setType(Type_);
	req->setPlainText(PlainText_);
	return DFUWUFile(req.get());
}

//------ method DFUWUSearch ---------

IClientDFUWUSearchRequest * CClientFileSpray::createDFUWUSearchRequest()
{
	CDFUWUSearchRequest* request = new CDFUWUSearchRequest("FileSpray");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientDFUWUSearchResponse * CClientFileSpray::DFUWUSearch(IClientDFUWUSearchRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CDFUWUSearchRequest* esprequest = static_cast<CDFUWUSearchRequest*>(request);
	CDFUWUSearchResponse* espresponse = new CDFUWUSearchResponse("FileSpray");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientFileSpray::async_DFUWUSearch(IClientDFUWUSearchRequest *request, IClientFileSprayEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CDFUWUSearchRequest* esprequest = static_cast<CDFUWUSearchRequest*>(request);
	esprequest->setMethod("DFUWUSearch");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientFileSpray::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientDFUWUSearchResponse *CClientFileSpray::DFUWUSearchFn()
{
	Owned<IClientDFUWUSearchRequest> req =  createDFUWUSearchRequest();
	return DFUWUSearch(req.get());
}

//------ method DFUWorkunitsAction ---------

IClientDFUWorkunitsActionRequest * CClientFileSpray::createDFUWorkunitsActionRequest()
{
	CDFUWorkunitsActionRequest* request = new CDFUWorkunitsActionRequest("FileSpray");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientDFUWorkunitsActionResponse * CClientFileSpray::DFUWorkunitsAction(IClientDFUWorkunitsActionRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CDFUWorkunitsActionRequest* esprequest = static_cast<CDFUWorkunitsActionRequest*>(request);
	CDFUWorkunitsActionResponse* espresponse = new CDFUWorkunitsActionResponse("FileSpray");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientFileSpray::async_DFUWorkunitsAction(IClientDFUWorkunitsActionRequest *request, IClientFileSprayEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CDFUWorkunitsActionRequest* esprequest = static_cast<CDFUWorkunitsActionRequest*>(request);
	esprequest->setMethod("DFUWorkunitsAction");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientFileSpray::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientDFUWorkunitsActionResponse *CClientFileSpray::DFUWorkunitsActionFn(StringArray &wuids_, CDFUWUActions Type_)
{
	Owned<IClientDFUWorkunitsActionRequest> req =  createDFUWorkunitsActionRequest();
	req->setWuids(wuids_);
	req->setType(Type_);
	return DFUWorkunitsAction(req.get());
}

//------ method DeleteDFUWorkunit ---------

IClientDeleteDFUWorkunit * CClientFileSpray::createDeleteDFUWorkunitRequest()
{
	CDeleteDFUWorkunit* request = new CDeleteDFUWorkunit("FileSpray");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientDeleteDFUWorkunitResponse * CClientFileSpray::DeleteDFUWorkunit(IClientDeleteDFUWorkunit *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CDeleteDFUWorkunit* esprequest = static_cast<CDeleteDFUWorkunit*>(request);
	CDeleteDFUWorkunitResponse* espresponse = new CDeleteDFUWorkunitResponse("FileSpray");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientFileSpray::async_DeleteDFUWorkunit(IClientDeleteDFUWorkunit *request, IClientFileSprayEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CDeleteDFUWorkunit* esprequest = static_cast<CDeleteDFUWorkunit*>(request);
	esprequest->setMethod("DeleteDFUWorkunit");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientFileSpray::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientDeleteDFUWorkunitResponse *CClientFileSpray::DeleteDFUWorkunitFn(const char * wuid_)
{
	Owned<IClientDeleteDFUWorkunit> req =  createDeleteDFUWorkunitRequest();
	req->setWuid(wuid_);
	return DeleteDFUWorkunit(req.get());
}

//------ method DeleteDFUWorkunits ---------

IClientDeleteDFUWorkunits * CClientFileSpray::createDeleteDFUWorkunitsRequest()
{
	CDeleteDFUWorkunits* request = new CDeleteDFUWorkunits("FileSpray");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientDeleteDFUWorkunitsResponse * CClientFileSpray::DeleteDFUWorkunits(IClientDeleteDFUWorkunits *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CDeleteDFUWorkunits* esprequest = static_cast<CDeleteDFUWorkunits*>(request);
	CDeleteDFUWorkunitsResponse* espresponse = new CDeleteDFUWorkunitsResponse("FileSpray");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientFileSpray::async_DeleteDFUWorkunits(IClientDeleteDFUWorkunits *request, IClientFileSprayEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CDeleteDFUWorkunits* esprequest = static_cast<CDeleteDFUWorkunits*>(request);
	esprequest->setMethod("DeleteDFUWorkunits");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientFileSpray::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientDeleteDFUWorkunitsResponse *CClientFileSpray::DeleteDFUWorkunitsFn(StringArray &wuids_)
{
	Owned<IClientDeleteDFUWorkunits> req =  createDeleteDFUWorkunitsRequest();
	req->setWuids(wuids_);
	return DeleteDFUWorkunits(req.get());
}

//------ method DeleteDropZoneFiles ---------

IClientDeleteDropZoneFilesRequest * CClientFileSpray::createDeleteDropZoneFilesRequest()
{
	CDeleteDropZoneFilesRequest* request = new CDeleteDropZoneFilesRequest("FileSpray");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientDFUWorkunitsActionResponse * CClientFileSpray::DeleteDropZoneFiles(IClientDeleteDropZoneFilesRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CDeleteDropZoneFilesRequest* esprequest = static_cast<CDeleteDropZoneFilesRequest*>(request);
	CDFUWorkunitsActionResponse* espresponse = new CDFUWorkunitsActionResponse("FileSpray");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientFileSpray::async_DeleteDropZoneFiles(IClientDeleteDropZoneFilesRequest *request, IClientFileSprayEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CDeleteDropZoneFilesRequest* esprequest = static_cast<CDeleteDropZoneFilesRequest*>(request);
	esprequest->setMethod("DeleteDropZoneFiles");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientFileSpray::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientDFUWorkunitsActionResponse *CClientFileSpray::DeleteDropZoneFilesFn(const char * DropZoneName_, const char * NetAddress_, const char * Path_, const char * OS_, StringArray &Names_)
{
	Owned<IClientDeleteDropZoneFilesRequest> req =  createDeleteDropZoneFilesRequest();
	req->setDropZoneName(DropZoneName_);
	req->setNetAddress(NetAddress_);
	req->setPath(Path_);
	req->setOS(OS_);
	req->setNames(Names_);
	return DeleteDropZoneFiles(req.get());
}

//------ method Despray ---------

IClientDespray * CClientFileSpray::createDesprayRequest()
{
	CDespray* request = new CDespray("FileSpray");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientDesprayResponse * CClientFileSpray::Despray(IClientDespray *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CDespray* esprequest = static_cast<CDespray*>(request);
	CDesprayResponse* espresponse = new CDesprayResponse("FileSpray");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientFileSpray::async_Despray(IClientDespray *request, IClientFileSprayEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CDespray* esprequest = static_cast<CDespray*>(request);
	esprequest->setMethod("Despray");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientFileSpray::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientDesprayResponse *CClientFileSpray::DesprayFn(const char * sourceLogicalName_, const char * destIP_, const char * destPath_, const MemoryBuffer & dstxml_, bool overwrite_, int maxConnections_, int throttle_, int transferBufferSize_, const char * splitprefix_, bool norecover_, bool wrap_, bool multiCopy_, bool SingleConnection_, const char * DFUServerQueue_, bool compress_, const char * encrypt_, const char * decrypt_)
{
	Owned<IClientDespray> req =  createDesprayRequest();
	req->setSourceLogicalName(sourceLogicalName_);
	req->setDestIP(destIP_);
	req->setDestPath(destPath_);
	req->setDstxml(dstxml_);
	req->setOverwrite(overwrite_);
	req->setMaxConnections(maxConnections_);
	req->setThrottle(throttle_);
	req->setTransferBufferSize(transferBufferSize_);
	req->setSplitprefix(splitprefix_);
	req->setNorecover(norecover_);
	req->setWrap(wrap_);
	req->setMultiCopy(multiCopy_);
	req->setSingleConnection(SingleConnection_);
	req->setDFUServerQueue(DFUServerQueue_);
	req->setCompress(compress_);
	req->setEncrypt(encrypt_);
	req->setDecrypt(decrypt_);
	return Despray(req.get());
}

//------ method DfuMonitor ---------

IClientDfuMonitorRequest * CClientFileSpray::createDfuMonitorRequest()
{
	CDfuMonitorRequest* request = new CDfuMonitorRequest("FileSpray");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientDfuMonitorResponse * CClientFileSpray::DfuMonitor(IClientDfuMonitorRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CDfuMonitorRequest* esprequest = static_cast<CDfuMonitorRequest*>(request);
	CDfuMonitorResponse* espresponse = new CDfuMonitorResponse("FileSpray");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientFileSpray::async_DfuMonitor(IClientDfuMonitorRequest *request, IClientFileSprayEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CDfuMonitorRequest* esprequest = static_cast<CDfuMonitorRequest*>(request);
	esprequest->setMethod("DfuMonitor");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientFileSpray::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientDfuMonitorResponse *CClientFileSpray::DfuMonitorFn(const char * EventName_, const char * LogicalName_, const char * Ip_, const char * Filename_, bool Sub_, int ShotLimit_)
{
	Owned<IClientDfuMonitorRequest> req =  createDfuMonitorRequest();
	req->setEventName(EventName_);
	req->setLogicalName(LogicalName_);
	req->setIp(Ip_);
	req->setFilename(Filename_);
	req->setSub(Sub_);
	req->setShotLimit(ShotLimit_);
	return DfuMonitor(req.get());
}

//------ method DropZoneFileSearch ---------

IClientDropZoneFileSearchRequest * CClientFileSpray::createDropZoneFileSearchRequest()
{
	CDropZoneFileSearchRequest* request = new CDropZoneFileSearchRequest("FileSpray");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientDropZoneFileSearchResponse * CClientFileSpray::DropZoneFileSearch(IClientDropZoneFileSearchRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CDropZoneFileSearchRequest* esprequest = static_cast<CDropZoneFileSearchRequest*>(request);
	CDropZoneFileSearchResponse* espresponse = new CDropZoneFileSearchResponse("FileSpray");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientFileSpray::async_DropZoneFileSearch(IClientDropZoneFileSearchRequest *request, IClientFileSprayEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CDropZoneFileSearchRequest* esprequest = static_cast<CDropZoneFileSearchRequest*>(request);
	esprequest->setMethod("DropZoneFileSearch");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientFileSpray::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientDropZoneFileSearchResponse *CClientFileSpray::DropZoneFileSearchFn(const char * DropZoneName_, const char * Server_, bool ECLWatchVisibleOnly_, const char * NameFilter_)
{
	Owned<IClientDropZoneFileSearchRequest> req =  createDropZoneFileSearchRequest();
	req->setDropZoneName(DropZoneName_);
	req->setServer(Server_);
	req->setECLWatchVisibleOnly(ECLWatchVisibleOnly_);
	req->setNameFilter(NameFilter_);
	return DropZoneFileSearch(req.get());
}

//------ method DropZoneFiles ---------

IClientDropZoneFilesRequest * CClientFileSpray::createDropZoneFilesRequest()
{
	CDropZoneFilesRequest* request = new CDropZoneFilesRequest("FileSpray");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientDropZoneFilesResponse * CClientFileSpray::DropZoneFiles(IClientDropZoneFilesRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CDropZoneFilesRequest* esprequest = static_cast<CDropZoneFilesRequest*>(request);
	CDropZoneFilesResponse* espresponse = new CDropZoneFilesResponse("FileSpray");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientFileSpray::async_DropZoneFiles(IClientDropZoneFilesRequest *request, IClientFileSprayEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CDropZoneFilesRequest* esprequest = static_cast<CDropZoneFilesRequest*>(request);
	esprequest->setMethod("DropZoneFiles");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientFileSpray::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientDropZoneFilesResponse *CClientFileSpray::DropZoneFilesFn(const char * DropZoneName_, const char * NetAddress_, const char * Path_, const char * OS_, const char * Subfolder_, bool ECLWatchVisibleOnly_, bool DirectoryOnly_)
{
	Owned<IClientDropZoneFilesRequest> req =  createDropZoneFilesRequest();
	req->setDropZoneName(DropZoneName_);
	req->setNetAddress(NetAddress_);
	req->setPath(Path_);
	req->setOS(OS_);
	req->setSubfolder(Subfolder_);
	req->setECLWatchVisibleOnly(ECLWatchVisibleOnly_);
	req->setDirectoryOnly(DirectoryOnly_);
	return DropZoneFiles(req.get());
}

//------ method EchoDateTime ---------

IClientEchoDateTime * CClientFileSpray::createEchoDateTimeRequest()
{
	CEchoDateTime* request = new CEchoDateTime("FileSpray");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientEchoDateTimeResponse * CClientFileSpray::EchoDateTime(IClientEchoDateTime *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CEchoDateTime* esprequest = static_cast<CEchoDateTime*>(request);
	CEchoDateTimeResponse* espresponse = new CEchoDateTimeResponse("FileSpray");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientFileSpray::async_EchoDateTime(IClientEchoDateTime *request, IClientFileSprayEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CEchoDateTime* esprequest = static_cast<CEchoDateTime*>(request);
	esprequest->setMethod("EchoDateTime");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientFileSpray::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientEchoDateTimeResponse *CClientFileSpray::EchoDateTimeFn(const char * dt_)
{
	Owned<IClientEchoDateTime> req =  createEchoDateTimeRequest();
	req->setDt(dt_);
	return EchoDateTime(req.get());
}

//------ method FileList ---------

IClientFileListRequest * CClientFileSpray::createFileListRequest()
{
	CFileListRequest* request = new CFileListRequest("FileSpray");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientFileListResponse * CClientFileSpray::FileList(IClientFileListRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CFileListRequest* esprequest = static_cast<CFileListRequest*>(request);
	CFileListResponse* espresponse = new CFileListResponse("FileSpray");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientFileSpray::async_FileList(IClientFileListRequest *request, IClientFileSprayEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CFileListRequest* esprequest = static_cast<CFileListRequest*>(request);
	esprequest->setMethod("FileList");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientFileSpray::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientFileListResponse *CClientFileSpray::FileListFn(const char * Netaddr_, const char * Path_, const char * Mask_, const char * OS_, bool DirectoryOnly_)
{
	Owned<IClientFileListRequest> req =  createFileListRequest();
	req->setNetaddr(Netaddr_);
	req->setPath(Path_);
	req->setMask(Mask_);
	req->setOS(OS_);
	req->setDirectoryOnly(DirectoryOnly_);
	return FileList(req.get());
}

//------ method GetDFUExceptions ---------

IClientGetDFUExceptions * CClientFileSpray::createGetDFUExceptionsRequest()
{
	CGetDFUExceptions* request = new CGetDFUExceptions("FileSpray");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientGetDFUExceptionsResponse * CClientFileSpray::GetDFUExceptions(IClientGetDFUExceptions *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CGetDFUExceptions* esprequest = static_cast<CGetDFUExceptions*>(request);
	CGetDFUExceptionsResponse* espresponse = new CGetDFUExceptionsResponse("FileSpray");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientFileSpray::async_GetDFUExceptions(IClientGetDFUExceptions *request, IClientFileSprayEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CGetDFUExceptions* esprequest = static_cast<CGetDFUExceptions*>(request);
	esprequest->setMethod("GetDFUExceptions");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientFileSpray::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientGetDFUExceptionsResponse *CClientFileSpray::GetDFUExceptionsFn(const char * wuid_)
{
	Owned<IClientGetDFUExceptions> req =  createGetDFUExceptionsRequest();
	req->setWuid(wuid_);
	return GetDFUExceptions(req.get());
}

//------ method GetDFUProgress ---------

IClientProgressRequest * CClientFileSpray::createGetDFUProgressRequest()
{
	CProgressRequest* request = new CProgressRequest("FileSpray");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientProgressResponse * CClientFileSpray::GetDFUProgress(IClientProgressRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CProgressRequest* esprequest = static_cast<CProgressRequest*>(request);
	CProgressResponse* espresponse = new CProgressResponse("FileSpray");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientFileSpray::async_GetDFUProgress(IClientProgressRequest *request, IClientFileSprayEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CProgressRequest* esprequest = static_cast<CProgressRequest*>(request);
	esprequest->setMethod("GetDFUProgress");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientFileSpray::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientProgressResponse *CClientFileSpray::GetDFUProgressFn(const char * wuid_)
{
	Owned<IClientProgressRequest> req =  createGetDFUProgressRequest();
	req->setWuid(wuid_);
	return GetDFUProgress(req.get());
}

//------ method GetDFUServerQueues ---------

IClientGetDFUServerQueuesRequest * CClientFileSpray::createGetDFUServerQueuesRequest()
{
	CGetDFUServerQueuesRequest* request = new CGetDFUServerQueuesRequest("FileSpray");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientGetDFUServerQueuesResponse * CClientFileSpray::GetDFUServerQueues(IClientGetDFUServerQueuesRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CGetDFUServerQueuesRequest* esprequest = static_cast<CGetDFUServerQueuesRequest*>(request);
	CGetDFUServerQueuesResponse* espresponse = new CGetDFUServerQueuesResponse("FileSpray");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientFileSpray::async_GetDFUServerQueues(IClientGetDFUServerQueuesRequest *request, IClientFileSprayEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CGetDFUServerQueuesRequest* esprequest = static_cast<CGetDFUServerQueuesRequest*>(request);
	esprequest->setMethod("GetDFUServerQueues");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientFileSpray::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientGetDFUServerQueuesResponse *CClientFileSpray::GetDFUServerQueuesFn(const char * DFUServerName_)
{
	Owned<IClientGetDFUServerQueuesRequest> req =  createGetDFUServerQueuesRequest();
	req->setDFUServerName(DFUServerName_);
	return GetDFUServerQueues(req.get());
}

//------ method GetDFUWorkunit ---------

IClientGetDFUWorkunit * CClientFileSpray::createGetDFUWorkunitRequest()
{
	CGetDFUWorkunit* request = new CGetDFUWorkunit("FileSpray");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientGetDFUWorkunitResponse * CClientFileSpray::GetDFUWorkunit(IClientGetDFUWorkunit *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CGetDFUWorkunit* esprequest = static_cast<CGetDFUWorkunit*>(request);
	CGetDFUWorkunitResponse* espresponse = new CGetDFUWorkunitResponse("FileSpray");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientFileSpray::async_GetDFUWorkunit(IClientGetDFUWorkunit *request, IClientFileSprayEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CGetDFUWorkunit* esprequest = static_cast<CGetDFUWorkunit*>(request);
	esprequest->setMethod("GetDFUWorkunit");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientFileSpray::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientGetDFUWorkunitResponse *CClientFileSpray::GetDFUWorkunitFn(const char * wuid_)
{
	Owned<IClientGetDFUWorkunit> req =  createGetDFUWorkunitRequest();
	req->setWuid(wuid_);
	return GetDFUWorkunit(req.get());
}

//------ method GetDFUWorkunits ---------

IClientGetDFUWorkunits * CClientFileSpray::createGetDFUWorkunitsRequest()
{
	CGetDFUWorkunits* request = new CGetDFUWorkunits("FileSpray");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientGetDFUWorkunitsResponse * CClientFileSpray::GetDFUWorkunits(IClientGetDFUWorkunits *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CGetDFUWorkunits* esprequest = static_cast<CGetDFUWorkunits*>(request);
	CGetDFUWorkunitsResponse* espresponse = new CGetDFUWorkunitsResponse("FileSpray");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientFileSpray::async_GetDFUWorkunits(IClientGetDFUWorkunits *request, IClientFileSprayEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CGetDFUWorkunits* esprequest = static_cast<CGetDFUWorkunits*>(request);
	esprequest->setMethod("GetDFUWorkunits");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientFileSpray::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientGetDFUWorkunitsResponse *CClientFileSpray::GetDFUWorkunitsFn(const char * Wuid_, const char * Owner_, const char * Cluster_, const char * StateReq_, const char * Type_, const char * Jobname_, __int64 PageSize_, int CurrentPage_, __int64 PageStartFrom_, const char * Sortby_, bool Descending_, __int64 CacheHint_)
{
	Owned<IClientGetDFUWorkunits> req =  createGetDFUWorkunitsRequest();
	req->setWuid(Wuid_);
	req->setOwner(Owner_);
	req->setCluster(Cluster_);
	req->setStateReq(StateReq_);
	req->setType(Type_);
	req->setJobname(Jobname_);
	req->setPageSize(PageSize_);
	req->setCurrentPage(CurrentPage_);
	req->setPageStartFrom(PageStartFrom_);
	req->setSortby(Sortby_);
	req->setDescending(Descending_);
	req->setCacheHint(CacheHint_);
	return GetDFUWorkunits(req.get());
}

//------ method GetSprayTargets ---------

IClientGetSprayTargetsRequest * CClientFileSpray::createGetSprayTargetsRequest()
{
	CGetSprayTargetsRequest* request = new CGetSprayTargetsRequest("FileSpray");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientGetSprayTargetsResponse * CClientFileSpray::GetSprayTargets(IClientGetSprayTargetsRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CGetSprayTargetsRequest* esprequest = static_cast<CGetSprayTargetsRequest*>(request);
	CGetSprayTargetsResponse* espresponse = new CGetSprayTargetsResponse("FileSpray");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientFileSpray::async_GetSprayTargets(IClientGetSprayTargetsRequest *request, IClientFileSprayEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CGetSprayTargetsRequest* esprequest = static_cast<CGetSprayTargetsRequest*>(request);
	esprequest->setMethod("GetSprayTargets");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientFileSpray::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientGetSprayTargetsResponse *CClientFileSpray::GetSprayTargetsFn()
{
	Owned<IClientGetSprayTargetsRequest> req =  createGetSprayTargetsRequest();
	return GetSprayTargets(req.get());
}

//------ method OpenSave ---------

IClientOpenSaveRequest * CClientFileSpray::createOpenSaveRequest()
{
	COpenSaveRequest* request = new COpenSaveRequest("FileSpray");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientOpenSaveResponse * CClientFileSpray::OpenSave(IClientOpenSaveRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	COpenSaveRequest* esprequest = static_cast<COpenSaveRequest*>(request);
	COpenSaveResponse* espresponse = new COpenSaveResponse("FileSpray");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientFileSpray::async_OpenSave(IClientOpenSaveRequest *request, IClientFileSprayEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	COpenSaveRequest* esprequest = static_cast<COpenSaveRequest*>(request);
	esprequest->setMethod("OpenSave");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientFileSpray::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientOpenSaveResponse *CClientFileSpray::OpenSaveFn(const char * Location_, const char * Path_, const char * Name_, const char * Type_, const char * DateTime_, bool BinaryFile_)
{
	Owned<IClientOpenSaveRequest> req =  createOpenSaveRequest();
	req->setLocation(Location_);
	req->setPath(Path_);
	req->setName(Name_);
	req->setType(Type_);
	req->setDateTime(DateTime_);
	req->setBinaryFile(BinaryFile_);
	return OpenSave(req.get());
}

//------ method Ping ---------

IClientFileSprayPingRequest * CClientFileSpray::createPingRequest()
{
	CFileSprayPingRequest* request = new CFileSprayPingRequest("FileSpray");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientFileSprayPingResponse * CClientFileSpray::Ping(IClientFileSprayPingRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CFileSprayPingRequest* esprequest = static_cast<CFileSprayPingRequest*>(request);
	CFileSprayPingResponse* espresponse = new CFileSprayPingResponse("FileSpray");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientFileSpray::async_Ping(IClientFileSprayPingRequest *request, IClientFileSprayEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CFileSprayPingRequest* esprequest = static_cast<CFileSprayPingRequest*>(request);
	esprequest->setMethod("Ping");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientFileSpray::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientFileSprayPingResponse *CClientFileSpray::PingFn()
{
	Owned<IClientFileSprayPingRequest> req =  createPingRequest();
	return Ping(req.get());
}

//------ method Rename ---------

IClientRename * CClientFileSpray::createRenameRequest()
{
	CRename* request = new CRename("FileSpray");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientRenameResponse * CClientFileSpray::Rename(IClientRename *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CRename* esprequest = static_cast<CRename*>(request);
	CRenameResponse* espresponse = new CRenameResponse("FileSpray");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientFileSpray::async_Rename(IClientRename *request, IClientFileSprayEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CRename* esprequest = static_cast<CRename*>(request);
	esprequest->setMethod("Rename");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientFileSpray::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientRenameResponse *CClientFileSpray::RenameFn(const char * srcname_, const char * dstname_, bool overwrite_, const char * DFUServerQueue_)
{
	Owned<IClientRename> req =  createRenameRequest();
	req->setSrcname(srcname_);
	req->setDstname(dstname_);
	req->setOverwrite(overwrite_);
	req->setDFUServerQueue(DFUServerQueue_);
	return Rename(req.get());
}

//------ method Replicate ---------

IClientReplicate * CClientFileSpray::createReplicateRequest()
{
	CReplicate* request = new CReplicate("FileSpray");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientReplicateResponse * CClientFileSpray::Replicate(IClientReplicate *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CReplicate* esprequest = static_cast<CReplicate*>(request);
	CReplicateResponse* espresponse = new CReplicateResponse("FileSpray");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientFileSpray::async_Replicate(IClientReplicate *request, IClientFileSprayEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CReplicate* esprequest = static_cast<CReplicate*>(request);
	esprequest->setMethod("Replicate");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientFileSpray::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientReplicateResponse *CClientFileSpray::ReplicateFn(const char * sourceLogicalName_, int replicateOffset_, const char * cluster_, bool repeatLast_, bool onlyRepeated_, const char * DFUServerQueue_)
{
	Owned<IClientReplicate> req =  createReplicateRequest();
	req->setSourceLogicalName(sourceLogicalName_);
	req->setReplicateOffset(replicateOffset_);
	req->setCluster(cluster_);
	req->setRepeatLast(repeatLast_);
	req->setOnlyRepeated(onlyRepeated_);
	req->setDFUServerQueue(DFUServerQueue_);
	return Replicate(req.get());
}

//------ method ShowResult ---------

IClientShowResultRequest * CClientFileSpray::createShowResultRequest()
{
	CShowResultRequest* request = new CShowResultRequest("FileSpray");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientShowResultResponse * CClientFileSpray::ShowResult(IClientShowResultRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CShowResultRequest* esprequest = static_cast<CShowResultRequest*>(request);
	CShowResultResponse* espresponse = new CShowResultResponse("FileSpray");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientFileSpray::async_ShowResult(IClientShowResultRequest *request, IClientFileSprayEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CShowResultRequest* esprequest = static_cast<CShowResultRequest*>(request);
	esprequest->setMethod("ShowResult");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientFileSpray::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientShowResultResponse *CClientFileSpray::ShowResultFn(const char * Result_)
{
	Owned<IClientShowResultRequest> req =  createShowResultRequest();
	req->setResult(Result_);
	return ShowResult(req.get());
}

//------ method SprayFixed ---------

IClientSprayFixed * CClientFileSpray::createSprayFixedRequest()
{
	CSprayFixed* request = new CSprayFixed("FileSpray");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientSprayFixedResponse * CClientFileSpray::SprayFixed(IClientSprayFixed *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CSprayFixed* esprequest = static_cast<CSprayFixed*>(request);
	CSprayFixedResponse* espresponse = new CSprayFixedResponse("FileSpray");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientFileSpray::async_SprayFixed(IClientSprayFixed *request, IClientFileSprayEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CSprayFixed* esprequest = static_cast<CSprayFixed*>(request);
	esprequest->setMethod("SprayFixed");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientFileSpray::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientSprayFixedResponse *CClientFileSpray::SprayFixedFn(const char * sourceIP_, const char * sourcePath_, const MemoryBuffer & srcxml_, const char * sourceFormat_, int sourceRecordSize_, const char * destGroup_, const char * destLogicalName_, bool overwrite_, bool replicate_, int ReplicateOffset_, int maxConnections_, int throttle_, int transferBufferSize_, const char * prefix_, bool nosplit_, bool norecover_, bool compress_, bool push_, bool pull_, const char * encrypt_, const char * decrypt_, bool wrap_, bool failIfNoSourceFile_, bool recordStructurePresent_, bool quotedTerminator_, int expireDays_, const char * DFUServerQueue_)
{
	Owned<IClientSprayFixed> req =  createSprayFixedRequest();
	req->setSourceIP(sourceIP_);
	req->setSourcePath(sourcePath_);
	req->setSrcxml(srcxml_);
	req->setSourceFormat(sourceFormat_);
	req->setSourceRecordSize(sourceRecordSize_);
	req->setDestGroup(destGroup_);
	req->setDestLogicalName(destLogicalName_);
	req->setOverwrite(overwrite_);
	req->setReplicate(replicate_);
	req->setReplicateOffset(ReplicateOffset_);
	req->setMaxConnections(maxConnections_);
	req->setThrottle(throttle_);
	req->setTransferBufferSize(transferBufferSize_);
	req->setPrefix(prefix_);
	req->setNosplit(nosplit_);
	req->setNorecover(norecover_);
	req->setCompress(compress_);
	req->setPush(push_);
	req->setPull(pull_);
	req->setEncrypt(encrypt_);
	req->setDecrypt(decrypt_);
	req->setWrap(wrap_);
	req->setFailIfNoSourceFile(failIfNoSourceFile_);
	req->setRecordStructurePresent(recordStructurePresent_);
	req->setQuotedTerminator(quotedTerminator_);
	req->setExpireDays(expireDays_);
	req->setDFUServerQueue(DFUServerQueue_);
	return SprayFixed(req.get());
}

//------ method SprayVariable ---------

IClientSprayVariable * CClientFileSpray::createSprayVariableRequest()
{
	CSprayVariable* request = new CSprayVariable("FileSpray");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientSprayResponse * CClientFileSpray::SprayVariable(IClientSprayVariable *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CSprayVariable* esprequest = static_cast<CSprayVariable*>(request);
	CSprayResponse* espresponse = new CSprayResponse("FileSpray");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientFileSpray::async_SprayVariable(IClientSprayVariable *request, IClientFileSprayEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CSprayVariable* esprequest = static_cast<CSprayVariable*>(request);
	esprequest->setMethod("SprayVariable");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientFileSpray::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientSprayResponse *CClientFileSpray::SprayVariableFn(const char * sourceIP_, const char * sourcePath_, const MemoryBuffer & srcxml_, int sourceMaxRecordSize_, int sourceFormat_, bool NoSourceCsvSeparator_, const char * sourceCsvSeparate_, const char * sourceCsvTerminate_, const char * sourceCsvQuote_, const char * sourceCsvEscape_, const char * sourceRowTag_, const char * destGroup_, const char * destLogicalName_, bool overwrite_, bool replicate_, int ReplicateOffset_, int maxConnections_, int throttle_, int transferBufferSize_, const char * prefix_, bool nosplit_, bool norecover_, bool compress_, bool push_, bool pull_, const char * encrypt_, const char * decrypt_, bool failIfNoSourceFile_, bool recordStructurePresent_, bool quotedTerminator_, const char * sourceRowPath_, bool isJSON_, int expireDays_, const char * DFUServerQueue_)
{
	Owned<IClientSprayVariable> req =  createSprayVariableRequest();
	req->setSourceIP(sourceIP_);
	req->setSourcePath(sourcePath_);
	req->setSrcxml(srcxml_);
	req->setSourceMaxRecordSize(sourceMaxRecordSize_);
	req->setSourceFormat(sourceFormat_);
	req->setNoSourceCsvSeparator(NoSourceCsvSeparator_);
	req->setSourceCsvSeparate(sourceCsvSeparate_);
	req->setSourceCsvTerminate(sourceCsvTerminate_);
	req->setSourceCsvQuote(sourceCsvQuote_);
	req->setSourceCsvEscape(sourceCsvEscape_);
	req->setSourceRowTag(sourceRowTag_);
	req->setDestGroup(destGroup_);
	req->setDestLogicalName(destLogicalName_);
	req->setOverwrite(overwrite_);
	req->setReplicate(replicate_);
	req->setReplicateOffset(ReplicateOffset_);
	req->setMaxConnections(maxConnections_);
	req->setThrottle(throttle_);
	req->setTransferBufferSize(transferBufferSize_);
	req->setPrefix(prefix_);
	req->setNosplit(nosplit_);
	req->setNorecover(norecover_);
	req->setCompress(compress_);
	req->setPush(push_);
	req->setPull(pull_);
	req->setEncrypt(encrypt_);
	req->setDecrypt(decrypt_);
	req->setFailIfNoSourceFile(failIfNoSourceFile_);
	req->setRecordStructurePresent(recordStructurePresent_);
	req->setQuotedTerminator(quotedTerminator_);
	req->setSourceRowPath(sourceRowPath_);
	req->setIsJSON(isJSON_);
	req->setExpireDays(expireDays_);
	req->setDFUServerQueue(DFUServerQueue_);
	return SprayVariable(req.get());
}

//------ method SubmitDFUWorkunit ---------

IClientSubmitDFUWorkunit * CClientFileSpray::createSubmitDFUWorkunitRequest()
{
	CSubmitDFUWorkunit* request = new CSubmitDFUWorkunit("FileSpray");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientSubmitDFUWorkunitResponse * CClientFileSpray::SubmitDFUWorkunit(IClientSubmitDFUWorkunit *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CSubmitDFUWorkunit* esprequest = static_cast<CSubmitDFUWorkunit*>(request);
	CSubmitDFUWorkunitResponse* espresponse = new CSubmitDFUWorkunitResponse("FileSpray");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientFileSpray::async_SubmitDFUWorkunit(IClientSubmitDFUWorkunit *request, IClientFileSprayEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CSubmitDFUWorkunit* esprequest = static_cast<CSubmitDFUWorkunit*>(request);
	esprequest->setMethod("SubmitDFUWorkunit");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientFileSpray::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientSubmitDFUWorkunitResponse *CClientFileSpray::SubmitDFUWorkunitFn(const char * wuid_)
{
	Owned<IClientSubmitDFUWorkunit> req =  createSubmitDFUWorkunitRequest();
	req->setWuid(wuid_);
	return SubmitDFUWorkunit(req.get());
}

//------ method UpdateDFUWorkunit ---------

IClientUpdateDFUWorkunit * CClientFileSpray::createUpdateDFUWorkunitRequest()
{
	CUpdateDFUWorkunit* request = new CUpdateDFUWorkunit("FileSpray");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientUpdateDFUWorkunitResponse * CClientFileSpray::UpdateDFUWorkunit(IClientUpdateDFUWorkunit *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CUpdateDFUWorkunit* esprequest = static_cast<CUpdateDFUWorkunit*>(request);
	CUpdateDFUWorkunitResponse* espresponse = new CUpdateDFUWorkunitResponse("FileSpray");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientFileSpray::async_UpdateDFUWorkunit(IClientUpdateDFUWorkunit *request, IClientFileSprayEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CUpdateDFUWorkunit* esprequest = static_cast<CUpdateDFUWorkunit*>(request);
	esprequest->setMethod("UpdateDFUWorkunit");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientFileSpray::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientUpdateDFUWorkunitResponse *CClientFileSpray::UpdateDFUWorkunitFn(IConstDFUWorkunit &wu_, const char * ClusterOrig_, const char * JobNameOrig_, bool isProtectedOrig_, int StateOrig_)
{
	Owned<IClientUpdateDFUWorkunit> req =  createUpdateDFUWorkunitRequest();
	req->setWu(wu_);
	req->setClusterOrig(ClusterOrig_);
	req->setJobNameOrig(JobNameOrig_);
	req->setIsProtectedOrig(isProtectedOrig_);
	req->setStateOrig(StateOrig_);
	return UpdateDFUWorkunit(req.get());
}

int CClientFileSpray::transferThunkEvent(void *data)
{
	IRpcResponseBinding *response = (IRpcResponseBinding *)data;
	if (response!=NULL)
	{
		IClientFileSprayEvents *eventSink = (IClientFileSprayEvents *)response->getEventSink();
		response->lock();

		if (stricmp(response->getMethod(), "AbortDFUWorkunit")==0)
		{
			IClientAbortDFUWorkunitResponse* icresp = dynamic_cast<IClientAbortDFUWorkunitResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onAbortDFUWorkunitComplete(icresp, response->queryState());
				else
					eventSink->onAbortDFUWorkunitError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "Copy")==0)
		{
			IClientCopyResponse* icresp = dynamic_cast<IClientCopyResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onCopyComplete(icresp, response->queryState());
				else
					eventSink->onCopyError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "CreateDFUWorkunit")==0)
		{
			IClientCreateDFUWorkunitResponse* icresp = dynamic_cast<IClientCreateDFUWorkunitResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onCreateDFUWorkunitComplete(icresp, response->queryState());
				else
					eventSink->onCreateDFUWorkunitError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "DFUWUFile")==0)
		{
			IClientDFUWUFileResponse* icresp = dynamic_cast<IClientDFUWUFileResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onDFUWUFileComplete(icresp, response->queryState());
				else
					eventSink->onDFUWUFileError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "DFUWUSearch")==0)
		{
			IClientDFUWUSearchResponse* icresp = dynamic_cast<IClientDFUWUSearchResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onDFUWUSearchComplete(icresp, response->queryState());
				else
					eventSink->onDFUWUSearchError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "DFUWorkunitsAction")==0)
		{
			IClientDFUWorkunitsActionResponse* icresp = dynamic_cast<IClientDFUWorkunitsActionResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onDFUWorkunitsActionComplete(icresp, response->queryState());
				else
					eventSink->onDFUWorkunitsActionError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "DeleteDFUWorkunit")==0)
		{
			IClientDeleteDFUWorkunitResponse* icresp = dynamic_cast<IClientDeleteDFUWorkunitResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onDeleteDFUWorkunitComplete(icresp, response->queryState());
				else
					eventSink->onDeleteDFUWorkunitError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "DeleteDFUWorkunits")==0)
		{
			IClientDeleteDFUWorkunitsResponse* icresp = dynamic_cast<IClientDeleteDFUWorkunitsResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onDeleteDFUWorkunitsComplete(icresp, response->queryState());
				else
					eventSink->onDeleteDFUWorkunitsError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "DeleteDropZoneFiles")==0)
		{
			IClientDFUWorkunitsActionResponse* icresp = dynamic_cast<IClientDFUWorkunitsActionResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onDeleteDropZoneFilesComplete(icresp, response->queryState());
				else
					eventSink->onDeleteDropZoneFilesError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "Despray")==0)
		{
			IClientDesprayResponse* icresp = dynamic_cast<IClientDesprayResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onDesprayComplete(icresp, response->queryState());
				else
					eventSink->onDesprayError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "DfuMonitor")==0)
		{
			IClientDfuMonitorResponse* icresp = dynamic_cast<IClientDfuMonitorResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onDfuMonitorComplete(icresp, response->queryState());
				else
					eventSink->onDfuMonitorError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "DropZoneFileSearch")==0)
		{
			IClientDropZoneFileSearchResponse* icresp = dynamic_cast<IClientDropZoneFileSearchResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onDropZoneFileSearchComplete(icresp, response->queryState());
				else
					eventSink->onDropZoneFileSearchError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "DropZoneFiles")==0)
		{
			IClientDropZoneFilesResponse* icresp = dynamic_cast<IClientDropZoneFilesResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onDropZoneFilesComplete(icresp, response->queryState());
				else
					eventSink->onDropZoneFilesError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "EchoDateTime")==0)
		{
			IClientEchoDateTimeResponse* icresp = dynamic_cast<IClientEchoDateTimeResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onEchoDateTimeComplete(icresp, response->queryState());
				else
					eventSink->onEchoDateTimeError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "FileList")==0)
		{
			IClientFileListResponse* icresp = dynamic_cast<IClientFileListResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onFileListComplete(icresp, response->queryState());
				else
					eventSink->onFileListError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "GetDFUExceptions")==0)
		{
			IClientGetDFUExceptionsResponse* icresp = dynamic_cast<IClientGetDFUExceptionsResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onGetDFUExceptionsComplete(icresp, response->queryState());
				else
					eventSink->onGetDFUExceptionsError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "GetDFUProgress")==0)
		{
			IClientProgressResponse* icresp = dynamic_cast<IClientProgressResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onGetDFUProgressComplete(icresp, response->queryState());
				else
					eventSink->onGetDFUProgressError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "GetDFUServerQueues")==0)
		{
			IClientGetDFUServerQueuesResponse* icresp = dynamic_cast<IClientGetDFUServerQueuesResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onGetDFUServerQueuesComplete(icresp, response->queryState());
				else
					eventSink->onGetDFUServerQueuesError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "GetDFUWorkunit")==0)
		{
			IClientGetDFUWorkunitResponse* icresp = dynamic_cast<IClientGetDFUWorkunitResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onGetDFUWorkunitComplete(icresp, response->queryState());
				else
					eventSink->onGetDFUWorkunitError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "GetDFUWorkunits")==0)
		{
			IClientGetDFUWorkunitsResponse* icresp = dynamic_cast<IClientGetDFUWorkunitsResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onGetDFUWorkunitsComplete(icresp, response->queryState());
				else
					eventSink->onGetDFUWorkunitsError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "GetSprayTargets")==0)
		{
			IClientGetSprayTargetsResponse* icresp = dynamic_cast<IClientGetSprayTargetsResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onGetSprayTargetsComplete(icresp, response->queryState());
				else
					eventSink->onGetSprayTargetsError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "OpenSave")==0)
		{
			IClientOpenSaveResponse* icresp = dynamic_cast<IClientOpenSaveResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onOpenSaveComplete(icresp, response->queryState());
				else
					eventSink->onOpenSaveError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "Ping")==0)
		{
			IClientFileSprayPingResponse* icresp = dynamic_cast<IClientFileSprayPingResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onPingComplete(icresp, response->queryState());
				else
					eventSink->onPingError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "Rename")==0)
		{
			IClientRenameResponse* icresp = dynamic_cast<IClientRenameResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onRenameComplete(icresp, response->queryState());
				else
					eventSink->onRenameError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "Replicate")==0)
		{
			IClientReplicateResponse* icresp = dynamic_cast<IClientReplicateResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onReplicateComplete(icresp, response->queryState());
				else
					eventSink->onReplicateError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "ShowResult")==0)
		{
			IClientShowResultResponse* icresp = dynamic_cast<IClientShowResultResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onShowResultComplete(icresp, response->queryState());
				else
					eventSink->onShowResultError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "SprayFixed")==0)
		{
			IClientSprayFixedResponse* icresp = dynamic_cast<IClientSprayFixedResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onSprayFixedComplete(icresp, response->queryState());
				else
					eventSink->onSprayFixedError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "SprayVariable")==0)
		{
			IClientSprayResponse* icresp = dynamic_cast<IClientSprayResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onSprayVariableComplete(icresp, response->queryState());
				else
					eventSink->onSprayVariableError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "SubmitDFUWorkunit")==0)
		{
			IClientSubmitDFUWorkunitResponse* icresp = dynamic_cast<IClientSubmitDFUWorkunitResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onSubmitDFUWorkunitComplete(icresp, response->queryState());
				else
					eventSink->onSubmitDFUWorkunitError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "UpdateDFUWorkunit")==0)
		{
			IClientUpdateDFUWorkunitResponse* icresp = dynamic_cast<IClientUpdateDFUWorkunitResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onUpdateDFUWorkunitComplete(icresp, response->queryState());
				else
					eventSink->onUpdateDFUWorkunitError(icresp,response->queryState());
			}
		}
		response->unlock();
	}
	return 0;
}

static IRpcResponseBinding* createFileSprayResponseObject(IRpcRequestBinding *request)
{
	const char* method = request->getMethod();
	if (stricmp(method, "AbortDFUWorkunit")==0)
		return new CAbortDFUWorkunitResponse("FileSpray", request);
	if (stricmp(method, "Copy")==0)
		return new CCopyResponse("FileSpray", request);
	if (stricmp(method, "CreateDFUWorkunit")==0)
		return new CCreateDFUWorkunitResponse("FileSpray", request);
	if (stricmp(method, "DFUWUFile")==0)
		return new CDFUWUFileResponse("FileSpray", request);
	if (stricmp(method, "DFUWUSearch")==0)
		return new CDFUWUSearchResponse("FileSpray", request);
	if (stricmp(method, "DFUWorkunitsAction")==0)
		return new CDFUWorkunitsActionResponse("FileSpray", request);
	if (stricmp(method, "DeleteDFUWorkunit")==0)
		return new CDeleteDFUWorkunitResponse("FileSpray", request);
	if (stricmp(method, "DeleteDFUWorkunits")==0)
		return new CDeleteDFUWorkunitsResponse("FileSpray", request);
	if (stricmp(method, "DeleteDropZoneFiles")==0)
		return new CDFUWorkunitsActionResponse("FileSpray", request);
	if (stricmp(method, "Despray")==0)
		return new CDesprayResponse("FileSpray", request);
	if (stricmp(method, "DfuMonitor")==0)
		return new CDfuMonitorResponse("FileSpray", request);
	if (stricmp(method, "DropZoneFileSearch")==0)
		return new CDropZoneFileSearchResponse("FileSpray", request);
	if (stricmp(method, "DropZoneFiles")==0)
		return new CDropZoneFilesResponse("FileSpray", request);
	if (stricmp(method, "EchoDateTime")==0)
		return new CEchoDateTimeResponse("FileSpray", request);
	if (stricmp(method, "FileList")==0)
		return new CFileListResponse("FileSpray", request);
	if (stricmp(method, "GetDFUExceptions")==0)
		return new CGetDFUExceptionsResponse("FileSpray", request);
	if (stricmp(method, "GetDFUProgress")==0)
		return new CProgressResponse("FileSpray", request);
	if (stricmp(method, "GetDFUServerQueues")==0)
		return new CGetDFUServerQueuesResponse("FileSpray", request);
	if (stricmp(method, "GetDFUWorkunit")==0)
		return new CGetDFUWorkunitResponse("FileSpray", request);
	if (stricmp(method, "GetDFUWorkunits")==0)
		return new CGetDFUWorkunitsResponse("FileSpray", request);
	if (stricmp(method, "GetSprayTargets")==0)
		return new CGetSprayTargetsResponse("FileSpray", request);
	if (stricmp(method, "OpenSave")==0)
		return new COpenSaveResponse("FileSpray", request);
	if (stricmp(method, "Ping")==0)
		return new CFileSprayPingResponse("FileSpray", request);
	if (stricmp(method, "Rename")==0)
		return new CRenameResponse("FileSpray", request);
	if (stricmp(method, "Replicate")==0)
		return new CReplicateResponse("FileSpray", request);
	if (stricmp(method, "ShowResult")==0)
		return new CShowResultResponse("FileSpray", request);
	if (stricmp(method, "SprayFixed")==0)
		return new CSprayFixedResponse("FileSpray", request);
	if (stricmp(method, "SprayVariable")==0)
		return new CSprayResponse("FileSpray", request);
	if (stricmp(method, "SubmitDFUWorkunit")==0)
		return new CSubmitDFUWorkunitResponse("FileSpray", request);
	if (stricmp(method, "UpdateDFUWorkunit")==0)
		return new CUpdateDFUWorkunitResponse("FileSpray", request);
	return NULL;
}

#ifdef _WIN32
void CClientFileSpray::espWorkerThread(void* data)
#else
void *CClientFileSpray::espWorkerThread(void *data)
#endif
{
	IRpcRequestBinding *request = (IRpcRequestBinding *) data;

	if (request != NULL)
	{
		request->lock();
		IRpcResponseBinding *response=createFileSprayResponseObject(request);
		if (response!=NULL)
		{
			try{
				request->post(*response);
			}
			catch(IException* ex){
				StringBuffer errorStr;
				ex->errorMessage(errorStr);
				ERRLOG("CClientFileSpray::espWorkerThread(%s)--Exception caught while posting async request: %s", request->getMethod(), errorStr.str());
				ex->Release();
			}
			catch(...){
				ERRLOG("Unknown exception caught while posting async request");
			}
		}
#ifdef USE_CLIENT_THREAD
		ThunkToClientThread(request->getThunkHandle(), transferThunkEvent, (void *)response);
#else
		transferThunkEvent((void *)response);
#endif
		request->unlock();
		if(request->queryState()!=NULL)
			request->queryState()->Release();

		if(response!=NULL)
			response->Release();

		request->Release();
	}
#if defined(_WIN32)
#else
	return (void *) 0 ;
#endif
}



extern "C" IClientFileSpray * createFileSprayClient() {  return new CClientFileSpray(); }


#endif //ws_fs_ESPGEN_INCLUDED
