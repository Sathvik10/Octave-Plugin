// *** Source file generated by HIDL Version 1.3 from ws_configmgr.ecm ***
// *** Not to be hand edited (changes will be lost on re-generation) ***

#ifndef ws_configmgr_ESPGEN_INCLUDED
#define ws_configmgr_ESPGEN_INCLUDED

#include "ws_configmgr_esp.ipp"

#ifdef _WIN32
#include "edwin.h"
#include <process.h>
#endif



//=======================================================
// class CStatusMsgType Implementation
//=======================================================

CStatusMsgType::CStatusMsgType(const char *serviceName, IRpcMessageBinding *init)
	: m_MsgLevel(nilIgnore),m_NodeId(nilIgnore),m_NodeName("", nilIgnore),m_Attribute("", nilIgnore),m_Msg(nilIgnore),m_ParentIdList(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("StatusMsgType");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CStatusMsgType::CStatusMsgType(const char *serviceName, const char *bc)
	: m_MsgLevel(nilIgnore),m_NodeId(nilIgnore),m_NodeName("", nilIgnore),m_Attribute("", nilIgnore),m_Msg(nilIgnore),m_ParentIdList(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("StatusMsgType");
}

StringBuffer &CStatusMsgType::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:complexType name=\"%s\">\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"MsgLevel\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"NodeId\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" default=\"\" name=\"NodeName\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" default=\"\" name=\"Attribute\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Msg\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"ParentIdList\">");
		schema.append("<xsd:complexType><xsd:sequence>");
		schema.append("<xsd:element name=\"parentId\" type=\"xsd:string\" minOccurs=\"0\" maxOccurs=\"unbounded\"/>\n");
		schema.append("</xsd:sequence></xsd:complexType>\n");
		schema.append("</xsd:element>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType>\n");
		}
	}
	return schema;
}

void CStatusMsgType::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CStatusMsgType::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CStatusMsgType::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("MsgLevel");
	form.appendf("  <tr><td><b>MsgLevel: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("NodeId");
	form.appendf("  <tr><td><b>NodeId: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("NodeName");
	form.appendf("  <tr><td><b>NodeName: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Attribute");
	form.appendf("  <tr><td><b>Attribute: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Msg");
	form.appendf("  <tr><td><b>Msg: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("ParentIdList");
	form.appendf("<tr><td><b>ParentIdList: </b></td><td>");
	form.appendf("<textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea>", extfix.str());
	form.append("</td></tr>");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CStatusMsgType::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CStatusMsgType::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_MsgLevel.marshall(rpc_resp, "MsgLevel", "", "", "");
	m_NodeId.marshall(rpc_resp, "NodeId", "", "", "");
	m_NodeName.marshall(rpc_resp, "NodeName", "", "", "");
	m_Attribute.marshall(rpc_resp, "Attribute", "", "", "");
	m_Msg.marshall(rpc_resp, "Msg", "", "", "");
	m_ParentIdList.marshall(rpc_resp, "ParentIdList", "parentId");
}


void CStatusMsgType::copy(CStatusMsgType &from)
{
	m_MsgLevel.copy(from.m_MsgLevel);
	m_NodeId.copy(from.m_NodeId);
	m_NodeName.copy(from.m_NodeName);
	m_Attribute.copy(from.m_Attribute);
	m_Msg.copy(from.m_Msg);
	m_ParentIdList.copy(from.m_ParentIdList);
}


void CStatusMsgType::copy(IConstStatusMsgType &ifrom)
{
	setMsgLevel(ifrom.getMsgLevel());
	setNodeId(ifrom.getNodeId());
	setNodeName(ifrom.getNodeName());
	setAttribute(ifrom.getAttribute());
	setMsg(ifrom.getMsg());
	setParentIdList(ifrom.getParentIdList());
}


void CStatusMsgType::getAttributes(IProperties &attributes)
{
}


void CStatusMsgType::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_MsgLevel.toStr(ctx, buffer, "MsgLevel", "", true, "", "");
	m_NodeId.toStr(ctx, buffer, "NodeId", "", true, "", "");
	m_NodeName.toStr(ctx, buffer, "NodeName", "", true, "", "");
	m_Attribute.toStr(ctx, buffer, "Attribute", "", true, "", "");
	m_Msg.toStr(ctx, buffer, "Msg", "", true, "", "");
	m_ParentIdList.toStr(ctx, buffer, "ParentIdList", "parentId");
}


void CStatusMsgType::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CStatusMsgType::serializer(IEspContext* ctx, IConstStatusMsgType &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<StatusMsgType>");
	// field MsgLevel
	{
		const char* s = src.getMsgLevel();
		if (s && *s)
		{
			buffer.append("<MsgLevel>");
			encodeUtf8XML(s,buffer);
			buffer.append("</MsgLevel>");
		}
	}
	// field NodeId
	{
		const char* s = src.getNodeId();
		if (s && *s)
		{
			buffer.append("<NodeId>");
			encodeUtf8XML(s,buffer);
			buffer.append("</NodeId>");
		}
	}
	// field NodeName
	{
		const char* s = src.getNodeName();
		if (s && *s)
		{
			buffer.append("<NodeName>");
			encodeUtf8XML(s,buffer);
			buffer.append("</NodeName>");
		}
	}
	// field Attribute
	{
		const char* s = src.getAttribute();
		if (s && *s)
		{
			buffer.append("<Attribute>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Attribute>");
		}
	}
	// field Msg
	{
		const char* s = src.getMsg();
		if (s && *s)
		{
			buffer.append("<Msg>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Msg>");
		}
	}
	// field ParentIdList
	{
		StringArray& v = src.getParentIdList();
		if (v.length()>0)
			buffer.append("<ParentIdList>");
		for (size32_t i=0;i<v.length();i++)
			buffer.appendf("<parentId>%s</parentId>",v.item(i));
		if (v.length()>0)
			buffer.append("</ParentIdList>");
	}
	if (keepRootTag)
		buffer.append("</StatusMsgType>");
}

bool CStatusMsgType::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_MsgLevel.unmarshall(rpc_request, "MsgLevel", basepath);
	hasValue |= m_NodeId.unmarshall(rpc_request, "NodeId", basepath);
	hasValue |= m_NodeName.unmarshall(rpc_request, "NodeName", basepath);
	hasValue |= m_Attribute.unmarshall(rpc_request, "Attribute", basepath);
	hasValue |= m_Msg.unmarshall(rpc_request, "Msg", basepath);
	hasValue |= m_ParentIdList.unmarshall(rpc_request, "ParentIdList", basepath);
	return hasValue;
}

bool CStatusMsgType::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_MsgLevel.unmarshall(ctx, soapval, "MsgLevel");
	hasValue |= m_NodeId.unmarshall(ctx, soapval, "NodeId");
	hasValue |= m_NodeName.unmarshall(ctx, soapval, "NodeName");
	hasValue |= m_Attribute.unmarshall(ctx, soapval, "Attribute");
	hasValue |= m_Msg.unmarshall(ctx, soapval, "Msg");
	hasValue |= m_ParentIdList.unmarshall(ctx, soapval, "ParentIdList");
	return hasValue;
}

bool CStatusMsgType::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_MsgLevel.unmarshall(ctx, params, attachments, "MsgLevel", basepath);
	hasValue |= m_NodeId.unmarshall(ctx, params, attachments, "NodeId", basepath);
	hasValue |= m_NodeName.unmarshall(ctx, params, attachments, "NodeName", basepath);
	hasValue |= m_Attribute.unmarshall(ctx, params, attachments, "Attribute", basepath);
	hasValue |= m_Msg.unmarshall(ctx, params, attachments, "Msg", basepath);
	hasValue |= m_ParentIdList.unmarshall(ctx, params, attachments, "ParentIdList", basepath);
	return hasValue;
}

const char * CStatusMsgType::getMsgLevel() { return m_MsgLevel.query();}
const char * CStatusMsgType::getNodeId() { return m_NodeId.query();}
const char * CStatusMsgType::getNodeName() { return m_NodeName.query();}
const char * CStatusMsgType::getAttribute() { return m_Attribute.query();}
const char * CStatusMsgType::getMsg() { return m_Msg.query();}
StringArray & CStatusMsgType::getParentIdList() { return (StringArray &) m_ParentIdList; }
void CStatusMsgType::setMsgLevel(const char * val){ m_MsgLevel.set(val); }
void CStatusMsgType::setNodeId(const char * val){ m_NodeId.set(val); }
void CStatusMsgType::setNodeName(const char * val){ m_NodeName.set(val); }
void CStatusMsgType::setAttribute(const char * val){ m_Attribute.set(val); }
void CStatusMsgType::setMsg(const char * val){ m_Msg.set(val); }
void CStatusMsgType::setParentIdList(StringArray &val){ m_ParentIdList->kill();  CloneArray(m_ParentIdList.getValue(), val); }
extern "C"  IEspStatusMsgType *createStatusMsgType(const char *serv, const char *msgname){return ((IEspStatusMsgType *)new CStatusMsgType(serv /*, msgname*/));}
extern "C"  IClientStatusMsgType *createClientStatusMsgType(const char *serv, const char *msgname){return ((IClientStatusMsgType *)new CStatusMsgType(serv /*, msgname*/));}

//=======================================================
// class CStatusType Implementation
//=======================================================

CStatusType::CStatusType(const char *serviceName, IRpcMessageBinding *init)
	: m_Error(0, nilIgnore,false),m_StatusMessages(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("StatusType");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CStatusType::CStatusType(const char *serviceName, const char *bc)
	: m_Error(0, nilIgnore,false),m_StatusMessages(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("StatusType");
}

StringBuffer &CStatusType::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:complexType name=\"%s\">\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" default=\"false\" name=\"Error\" type=\"xsd:boolean\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"StatusMessages\">\n");
		schema.append("<xsd:complexType><xsd:sequence>\n");
		schema.append("<xsd:element minOccurs=\"0\" maxOccurs=\"unbounded\" name=\"StatusMsg\" type=\"tns:StatusMsgType\"/>");
		schema.append("</xsd:sequence></xsd:complexType>");
		schema.append("</xsd:element>");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType>\n");
		}
	}
	if (!(flags & 0x10)  || (flags & 0x100))
	{
		CStatusMsgType::getXsdDefinition(context, request, schema, added);
	}
	return schema;
}

void CStatusType::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CStatusType::getMapInfo(IMapInfo& info, BoolHash& added)
{
	if (!added.getValue("StatusMsgType"))
	{
		added.setValue("StatusMsgType",1);
		CStatusMsgType::getMapInfo(info,added);
	}
}

StringBuffer &CStatusType::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Error");
	
	form.appendf("  <tr><td><b>Error? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("StatusMessages");
	form.appendf("<tr><td><b>StatusMessages: </b></td><td>");
	form.appendf("<table><tr><td><textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea></td>", extfix.str());
	form.append("</tr></table>");
	form.append("</td></tr>");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CStatusType::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CStatusType::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_Error.marshall(rpc_resp, "Error", "", "", "");
	m_StatusMessages.marshall(rpc_resp, "StatusMessages", "StatusMsg");
}


void CStatusType::copy(CStatusType &from)
{
	m_Error.copy(from.m_Error);
	m_StatusMessages.copy(from.m_StatusMessages);
}


void CStatusType::copy(IConstStatusType &ifrom)
{
	setError(ifrom.getError());
	setStatusMessages(ifrom.getStatusMessages());
}


void CStatusType::getAttributes(IProperties &attributes)
{
}


void CStatusType::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_Error.toStr(ctx, buffer, "Error", "", true, "", "");
	m_StatusMessages.toStr(ctx, buffer, "StatusMessages", "StatusMsg");
}


void CStatusType::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CStatusType::serializer(IEspContext* ctx, IConstStatusType &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<StatusType>");
	// field Error
	{
		bool b = src.getError();
		if (b)
			buffer.appendf("<Error>1</Error>");
	}
	// field StatusMessages
	{
		IArrayOf<IConstStatusMsgType>& v = src.getStatusMessages();
		int size = v.length();
		if (size>0)
			buffer.append("<StatusMessages>");
		for (int i=0;i<size;i++)
		{
			buffer.append("<StatusMsg>");
			CStatusMsgType::serializer(ctx,v.item(i),buffer,false);
			buffer.append("</StatusMsg>");
		}
		if (size>0)
			buffer.append("</StatusMessages>");
	}
	if (keepRootTag)
		buffer.append("</StatusType>");
}

bool CStatusType::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_Error.unmarshall(rpc_request, "Error", basepath);
	hasValue |= m_StatusMessages.unmarshall(rpc_request, "StatusMessages", basepath);
	return hasValue;
}

bool CStatusType::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Error.unmarshall(ctx, soapval, "Error");
	hasValue |= m_StatusMessages.unmarshall(ctx, soapval, "StatusMessages");
	return hasValue;
}

bool CStatusType::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Error.unmarshall(ctx, params, attachments, "Error", basepath);
	hasValue |= m_StatusMessages.unmarshall(ctx, params, attachments, "StatusMessages", basepath);
	return hasValue;
}

bool CStatusType::getError() { return m_Error;}
IArrayOf<IConstStatusMsgType> & CStatusType::getStatusMessages() { return (IArrayOf<IConstStatusMsgType> &) m_StatusMessages; }
void CStatusType::setError(bool val){ m_Error=val; }
void CStatusType::setStatusMessages(IArrayOf<IEspStatusMsgType> &val)
{
	m_StatusMessages->kill();
	IArrayOf<IConstStatusMsgType> &target = m_StatusMessages.getValue();
	ForEachItemIn(idx, val)
	{
		IEspStatusMsgType &item = (val).item(idx);
		item.Link();
		target.append(item);
	}
}
void CStatusType::setStatusMessages(IArrayOf<IConstStatusMsgType> &val)
{
	m_StatusMessages->kill();
	IArrayOf<IConstStatusMsgType> &target = m_StatusMessages.getValue();
	ForEachItemIn(idx, val)
	{
		IConstStatusMsgType &item = val.item(idx);
		item.Link();
		target.append(item);
	}
}
extern "C"  IEspStatusType *createStatusType(const char *serv, const char *msgname){return ((IEspStatusType *)new CStatusType(serv /*, msgname*/));}
extern "C"  IClientStatusType *createClientStatusType(const char *serv, const char *msgname){return ((IClientStatusType *)new CStatusType(serv /*, msgname*/));}

//=======================================================
// class CEmptyResponse Implementation
//=======================================================

CEmptyResponse::CEmptyResponse(const char *serviceName, IRpcMessageBinding *init)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("EmptyResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CEmptyResponse::CEmptyResponse(const char *serviceName, const char *bc)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("EmptyResponse");
}

CEmptyResponse::CEmptyResponse(const char *serviceName, IRpcMessage* rpcmsg)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("EmptyResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CEmptyResponse::CEmptyResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("EmptyResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CEmptyResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		schema.append("<xsd:element name=\"Exceptions\" type=\"tns:ArrayOfEspException\" minOccurs=\"0\" maxOccurs=\"1\"/>");
		}
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CEmptyResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CEmptyResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CEmptyResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CEmptyResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CEmptyResponse::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
	}
}


void CEmptyResponse::copy(CEmptyResponse &from)
{
}


void CEmptyResponse::copy(IConstEmptyResponse &ifrom)
{
}


void CEmptyResponse::getAttributes(IProperties &attributes)
{
}


void CEmptyResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
	}
}


void CEmptyResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CEmptyResponse::serializer(IEspContext* ctx, IConstEmptyResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<EmptyResponse>");
	if (keepRootTag)
		buffer.append("</EmptyResponse>");
}

bool CEmptyResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
	}
	return hasValue;
}

bool CEmptyResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	return hasValue;
}

bool CEmptyResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	return hasValue;
}

extern "C"  IEspEmptyResponse *createEmptyResponse(const char *serv){return ((IEspEmptyResponse *)new CEmptyResponse(serv));}
extern "C"  IClientEmptyResponse *createClientEmptyResponse(const char *serv){return ((IClientEmptyResponse *)new CEmptyResponse(serv));}

//=======================================================
// class CStatusResponse Implementation
//=======================================================

CStatusResponse::CStatusResponse(const char *serviceName, IRpcMessageBinding *init)
	: m_EnvironmentModified(nilIgnore),m_Status(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("StatusResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CStatusResponse::CStatusResponse(const char *serviceName, const char *bc)
	: m_EnvironmentModified(nilIgnore),m_Status(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("StatusResponse");
}

CStatusResponse::CStatusResponse(const char *serviceName, IRpcMessage* rpcmsg)
	: m_EnvironmentModified(nilIgnore),m_Status(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("StatusResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CStatusResponse::CStatusResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_EnvironmentModified(nilIgnore),m_Status(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("StatusResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CStatusResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"EnvironmentModified\" type=\"xsd:boolean\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Status\" type=\"tns:StatusType\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	if (!(flags & 0x10)  || (flags & 0x100))
	{
		CStatusType::getXsdDefinition(context, request, schema, added);
	}
	return schema;
}

void CStatusResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CStatusResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
	if (!added.getValue("StatusType"))
	{
		added.setValue("StatusType",1);
		CStatusType::getMapInfo(info,added);
	}
}

StringBuffer &CStatusResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("EnvironmentModified");
	
	form.appendf("  <tr><td><b>EnvironmentModified? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Status");
	form.append("<tr>").append("<td><b>Status: </b></td><td><hr/>");
	CStatusType::getHtmlForm(context, request, serv, method, form, false, extfix.str());
	form.append("<hr/></td></tr>");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CStatusResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CStatusResponse::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
		m_EnvironmentModified.marshall(rpc_resp, "EnvironmentModified", "", "", "");
		m_Status.marshall(rpc_resp, "Status", "", "", "");
	}
}


void CStatusResponse::copy(CStatusResponse &from)
{
	m_EnvironmentModified.copy(from.m_EnvironmentModified);
	m_Status.copy(from.m_Status);
}


void CStatusResponse::copy(IConstStatusResponse &ifrom)
{
	setEnvironmentModified(ifrom.getEnvironmentModified());
	setStatus(ifrom.getStatus());
}


void CStatusResponse::getAttributes(IProperties &attributes)
{
}


void CStatusResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
		m_EnvironmentModified.toStr(ctx, buffer, "EnvironmentModified", "", true, "", "");
		m_Status.toStr(ctx, buffer, "Status", "", false, "", "");
	}
}


void CStatusResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CStatusResponse::serializer(IEspContext* ctx, IConstStatusResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<StatusResponse>");
	// field EnvironmentModified
	{
		bool b = src.getEnvironmentModified();
		if (b)
			buffer.appendf("<EnvironmentModified>1</EnvironmentModified>");
	}
	// field Status
	{
		StringBuffer tmp;
		CStatusType::serializer(ctx,src.getStatus(), tmp, false);
		if (tmp.length()>0)
			buffer.appendf("<Status>%s</Status>",tmp.str());
	}
	if (keepRootTag)
		buffer.append("</StatusResponse>");
}

bool CStatusResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
		hasValue |= m_EnvironmentModified.unmarshall(rpc_request, "EnvironmentModified", basepath);
		hasValue |= m_Status.unmarshall(rpc_request, "Status", basepath);
	}
	return hasValue;
}

bool CStatusResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_EnvironmentModified.unmarshall(ctx, soapval, "EnvironmentModified");
	hasValue |= m_Status.unmarshall(ctx, soapval, "Status");
	return hasValue;
}

bool CStatusResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_EnvironmentModified.unmarshall(ctx, params, attachments, "EnvironmentModified", basepath);
	hasValue |= m_Status.unmarshall(ctx, params, attachments, "Status", basepath);
	return hasValue;
}

bool CStatusResponse::getEnvironmentModified() { return m_EnvironmentModified;}
IConstStatusType & CStatusResponse::getStatus() { return (IConstStatusType &) m_Status.getValue();}
void CStatusResponse::setEnvironmentModified(bool val){ m_EnvironmentModified=val; }
IEspStatusType & CStatusResponse::updateStatus(){ return (IEspStatusType &) m_Status.getValue(); }
void CStatusResponse::setStatus(IConstStatusType &ifrom){ m_Status.copy(ifrom); }
extern "C"  IEspStatusResponse *createStatusResponse(const char *serv){return ((IEspStatusResponse *)new CStatusResponse(serv));}
extern "C"  IClientStatusResponse *createClientStatusResponse(const char *serv){return ((IClientStatusResponse *)new CStatusResponse(serv));}

//=======================================================
// class COpenSessionRequest Implementation
//=======================================================

COpenSessionRequest::COpenSessionRequest(const char *serviceName, IRpcMessageBinding *init)
	: m_Username(nilIgnore),m_SchemaPath("", nilIgnore),m_MasterSchemaFile("", nilIgnore),m_SourcePath("", nilIgnore),m_ActivePath("", nilIgnore),m_PluginPaths("", nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("OpenSessionRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

COpenSessionRequest::COpenSessionRequest(const char *serviceName, const char *bc)
	: m_Username(nilIgnore),m_SchemaPath("", nilIgnore),m_MasterSchemaFile("", nilIgnore),m_SourcePath("", nilIgnore),m_ActivePath("", nilIgnore),m_PluginPaths("", nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("OpenSessionRequest");
}

COpenSessionRequest::COpenSessionRequest(const char *serviceName, IRpcMessage* rpcmsg)
	: m_Username(nilIgnore),m_SchemaPath("", nilIgnore),m_MasterSchemaFile("", nilIgnore),m_SourcePath("", nilIgnore),m_ActivePath("", nilIgnore),m_PluginPaths("", nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("OpenSessionRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

COpenSessionRequest::COpenSessionRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_Username(nilIgnore),m_SchemaPath("", nilIgnore),m_MasterSchemaFile("", nilIgnore),m_SourcePath("", nilIgnore),m_ActivePath("", nilIgnore),m_PluginPaths("", nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("OpenSessionRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &COpenSessionRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Username\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" default=\"\" name=\"SchemaPath\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" default=\"\" name=\"MasterSchemaFile\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" default=\"\" name=\"SourcePath\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" default=\"\" name=\"ActivePath\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" default=\"\" name=\"PluginPaths\" type=\"xsd:string\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void COpenSessionRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void COpenSessionRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &COpenSessionRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Username");
	form.appendf("  <tr><td><b>Username: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("SchemaPath");
	form.appendf("  <tr><td><b>SchemaPath: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("MasterSchemaFile");
	form.appendf("  <tr><td><b>MasterSchemaFile: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("SourcePath");
	form.appendf("  <tr><td><b>SourcePath: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("ActivePath");
	form.appendf("  <tr><td><b>ActivePath: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("PluginPaths");
	form.appendf("  <tr><td><b>PluginPaths: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &COpenSessionRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void COpenSessionRequest::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_Username.marshall(rpc_resp, "Username", "", "", "");
	m_SchemaPath.marshall(rpc_resp, "SchemaPath", "", "", "");
	m_MasterSchemaFile.marshall(rpc_resp, "MasterSchemaFile", "", "", "");
	m_SourcePath.marshall(rpc_resp, "SourcePath", "", "", "");
	m_ActivePath.marshall(rpc_resp, "ActivePath", "", "", "");
	m_PluginPaths.marshall(rpc_resp, "PluginPaths", "", "", "");
}


void COpenSessionRequest::copy(COpenSessionRequest &from)
{
	m_Username.copy(from.m_Username);
	m_SchemaPath.copy(from.m_SchemaPath);
	m_MasterSchemaFile.copy(from.m_MasterSchemaFile);
	m_SourcePath.copy(from.m_SourcePath);
	m_ActivePath.copy(from.m_ActivePath);
	m_PluginPaths.copy(from.m_PluginPaths);
}


void COpenSessionRequest::copy(IConstOpenSessionRequest &ifrom)
{
	setUsername(ifrom.getUsername());
	setSchemaPath(ifrom.getSchemaPath());
	setMasterSchemaFile(ifrom.getMasterSchemaFile());
	setSourcePath(ifrom.getSourcePath());
	setActivePath(ifrom.getActivePath());
	setPluginPaths(ifrom.getPluginPaths());
}


void COpenSessionRequest::getAttributes(IProperties &attributes)
{
}


void COpenSessionRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_Username.toStr(ctx, buffer, "Username", "", true, "", "");
	m_SchemaPath.toStr(ctx, buffer, "SchemaPath", "", true, "", "");
	m_MasterSchemaFile.toStr(ctx, buffer, "MasterSchemaFile", "", true, "", "");
	m_SourcePath.toStr(ctx, buffer, "SourcePath", "", true, "", "");
	m_ActivePath.toStr(ctx, buffer, "ActivePath", "", true, "", "");
	m_PluginPaths.toStr(ctx, buffer, "PluginPaths", "", true, "", "");
}


void COpenSessionRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void COpenSessionRequest::serializer(IEspContext* ctx, IConstOpenSessionRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<OpenSessionRequest>");
	// field Username
	{
		const char* s = src.getUsername();
		if (s && *s)
		{
			buffer.append("<Username>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Username>");
		}
	}
	// field SchemaPath
	{
		const char* s = src.getSchemaPath();
		if (s && *s)
		{
			buffer.append("<SchemaPath>");
			encodeUtf8XML(s,buffer);
			buffer.append("</SchemaPath>");
		}
	}
	// field MasterSchemaFile
	{
		const char* s = src.getMasterSchemaFile();
		if (s && *s)
		{
			buffer.append("<MasterSchemaFile>");
			encodeUtf8XML(s,buffer);
			buffer.append("</MasterSchemaFile>");
		}
	}
	// field SourcePath
	{
		const char* s = src.getSourcePath();
		if (s && *s)
		{
			buffer.append("<SourcePath>");
			encodeUtf8XML(s,buffer);
			buffer.append("</SourcePath>");
		}
	}
	// field ActivePath
	{
		const char* s = src.getActivePath();
		if (s && *s)
		{
			buffer.append("<ActivePath>");
			encodeUtf8XML(s,buffer);
			buffer.append("</ActivePath>");
		}
	}
	// field PluginPaths
	{
		const char* s = src.getPluginPaths();
		if (s && *s)
		{
			buffer.append("<PluginPaths>");
			encodeUtf8XML(s,buffer);
			buffer.append("</PluginPaths>");
		}
	}
	if (keepRootTag)
		buffer.append("</OpenSessionRequest>");
}

bool COpenSessionRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_Username.unmarshall(rpc_request, "Username", basepath);
	hasValue |= m_SchemaPath.unmarshall(rpc_request, "SchemaPath", basepath);
	hasValue |= m_MasterSchemaFile.unmarshall(rpc_request, "MasterSchemaFile", basepath);
	hasValue |= m_SourcePath.unmarshall(rpc_request, "SourcePath", basepath);
	hasValue |= m_ActivePath.unmarshall(rpc_request, "ActivePath", basepath);
	hasValue |= m_PluginPaths.unmarshall(rpc_request, "PluginPaths", basepath);
	return hasValue;
}

bool COpenSessionRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Username.unmarshall(ctx, soapval, "Username");
	hasValue |= m_SchemaPath.unmarshall(ctx, soapval, "SchemaPath");
	hasValue |= m_MasterSchemaFile.unmarshall(ctx, soapval, "MasterSchemaFile");
	hasValue |= m_SourcePath.unmarshall(ctx, soapval, "SourcePath");
	hasValue |= m_ActivePath.unmarshall(ctx, soapval, "ActivePath");
	hasValue |= m_PluginPaths.unmarshall(ctx, soapval, "PluginPaths");
	return hasValue;
}

bool COpenSessionRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Username.unmarshall(ctx, params, attachments, "Username", basepath);
	hasValue |= m_SchemaPath.unmarshall(ctx, params, attachments, "SchemaPath", basepath);
	hasValue |= m_MasterSchemaFile.unmarshall(ctx, params, attachments, "MasterSchemaFile", basepath);
	hasValue |= m_SourcePath.unmarshall(ctx, params, attachments, "SourcePath", basepath);
	hasValue |= m_ActivePath.unmarshall(ctx, params, attachments, "ActivePath", basepath);
	hasValue |= m_PluginPaths.unmarshall(ctx, params, attachments, "PluginPaths", basepath);
	return hasValue;
}

const char * COpenSessionRequest::getUsername() { return m_Username.query();}
const char * COpenSessionRequest::getSchemaPath() { return m_SchemaPath.query();}
const char * COpenSessionRequest::getMasterSchemaFile() { return m_MasterSchemaFile.query();}
const char * COpenSessionRequest::getSourcePath() { return m_SourcePath.query();}
const char * COpenSessionRequest::getActivePath() { return m_ActivePath.query();}
const char * COpenSessionRequest::getPluginPaths() { return m_PluginPaths.query();}
void COpenSessionRequest::setUsername(const char * val){ m_Username.set(val); }
void COpenSessionRequest::setSchemaPath(const char * val){ m_SchemaPath.set(val); }
void COpenSessionRequest::setMasterSchemaFile(const char * val){ m_MasterSchemaFile.set(val); }
void COpenSessionRequest::setSourcePath(const char * val){ m_SourcePath.set(val); }
void COpenSessionRequest::setActivePath(const char * val){ m_ActivePath.set(val); }
void COpenSessionRequest::setPluginPaths(const char * val){ m_PluginPaths.set(val); }
extern "C"  IEspOpenSessionRequest *createOpenSessionRequest(const char *serv){return ((IEspOpenSessionRequest *)new COpenSessionRequest(serv));}
extern "C"  IClientOpenSessionRequest *createClientOpenSessionRequest(const char *serv){return ((IClientOpenSessionRequest *)new COpenSessionRequest(serv));}

//=======================================================
// class COpenSessionResponse Implementation
//=======================================================

COpenSessionResponse::COpenSessionResponse(const char *serviceName, IRpcMessageBinding *init)
	: m_SessionId(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("OpenSessionResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

COpenSessionResponse::COpenSessionResponse(const char *serviceName, const char *bc)
	: m_SessionId(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("OpenSessionResponse");
}

COpenSessionResponse::COpenSessionResponse(const char *serviceName, IRpcMessage* rpcmsg)
	: m_SessionId(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("OpenSessionResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

COpenSessionResponse::COpenSessionResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_SessionId(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("OpenSessionResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &COpenSessionResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		schema.append("<xsd:element name=\"Exceptions\" type=\"tns:ArrayOfEspException\" minOccurs=\"0\" maxOccurs=\"1\"/>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"SessionId\" type=\"xsd:string\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void COpenSessionResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void COpenSessionResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &COpenSessionResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("SessionId");
	form.appendf("  <tr><td><b>SessionId: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &COpenSessionResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void COpenSessionResponse::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
		m_SessionId.marshall(rpc_resp, "SessionId", "", "", "");
	}
}


void COpenSessionResponse::copy(COpenSessionResponse &from)
{
	m_SessionId.copy(from.m_SessionId);
}


void COpenSessionResponse::copy(IConstOpenSessionResponse &ifrom)
{
	setSessionId(ifrom.getSessionId());
}


void COpenSessionResponse::getAttributes(IProperties &attributes)
{
}


void COpenSessionResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
		m_SessionId.toStr(ctx, buffer, "SessionId", "", true, "", "");
	}
}


void COpenSessionResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void COpenSessionResponse::serializer(IEspContext* ctx, IConstOpenSessionResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<OpenSessionResponse>");
	// field SessionId
	{
		const char* s = src.getSessionId();
		if (s && *s)
		{
			buffer.append("<SessionId>");
			encodeUtf8XML(s,buffer);
			buffer.append("</SessionId>");
		}
	}
	if (keepRootTag)
		buffer.append("</OpenSessionResponse>");
}

bool COpenSessionResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
		hasValue |= m_SessionId.unmarshall(rpc_request, "SessionId", basepath);
	}
	return hasValue;
}

bool COpenSessionResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_SessionId.unmarshall(ctx, soapval, "SessionId");
	return hasValue;
}

bool COpenSessionResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_SessionId.unmarshall(ctx, params, attachments, "SessionId", basepath);
	return hasValue;
}

const char * COpenSessionResponse::getSessionId() { return m_SessionId.query();}
void COpenSessionResponse::setSessionId(const char * val){ m_SessionId.set(val); }
extern "C"  IEspOpenSessionResponse *createOpenSessionResponse(const char *serv){return ((IEspOpenSessionResponse *)new COpenSessionResponse(serv));}
extern "C"  IClientOpenSessionResponse *createClientOpenSessionResponse(const char *serv){return ((IClientOpenSessionResponse *)new COpenSessionResponse(serv));}

//=======================================================
// class CCloseSessionRequest Implementation
//=======================================================

CCloseSessionRequest::CCloseSessionRequest(const char *serviceName, IRpcMessageBinding *init)
	: m_SessionId(nilIgnore),m_ForceClose(0, nilIgnore,false)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("CloseSessionRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CCloseSessionRequest::CCloseSessionRequest(const char *serviceName, const char *bc)
	: m_SessionId(nilIgnore),m_ForceClose(0, nilIgnore,false)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("CloseSessionRequest");
}

CCloseSessionRequest::CCloseSessionRequest(const char *serviceName, IRpcMessage* rpcmsg)
	: m_SessionId(nilIgnore),m_ForceClose(0, nilIgnore,false)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("CloseSessionRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CCloseSessionRequest::CCloseSessionRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_SessionId(nilIgnore),m_ForceClose(0, nilIgnore,false)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("CloseSessionRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CCloseSessionRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"SessionId\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" default=\"false\" name=\"ForceClose\" type=\"xsd:boolean\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CCloseSessionRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CCloseSessionRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CCloseSessionRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("SessionId");
	form.appendf("  <tr><td><b>SessionId: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("ForceClose");
	
	form.appendf("  <tr><td><b>ForceClose? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CCloseSessionRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CCloseSessionRequest::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_SessionId.marshall(rpc_resp, "SessionId", "", "", "");
	m_ForceClose.marshall(rpc_resp, "ForceClose", "", "", "");
}


void CCloseSessionRequest::copy(CCloseSessionRequest &from)
{
	m_SessionId.copy(from.m_SessionId);
	m_ForceClose.copy(from.m_ForceClose);
}


void CCloseSessionRequest::copy(IConstCloseSessionRequest &ifrom)
{
	setSessionId(ifrom.getSessionId());
	setForceClose(ifrom.getForceClose());
}


void CCloseSessionRequest::getAttributes(IProperties &attributes)
{
}


void CCloseSessionRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_SessionId.toStr(ctx, buffer, "SessionId", "", true, "", "");
	m_ForceClose.toStr(ctx, buffer, "ForceClose", "", true, "", "");
}


void CCloseSessionRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CCloseSessionRequest::serializer(IEspContext* ctx, IConstCloseSessionRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<CloseSessionRequest>");
	// field SessionId
	{
		const char* s = src.getSessionId();
		if (s && *s)
		{
			buffer.append("<SessionId>");
			encodeUtf8XML(s,buffer);
			buffer.append("</SessionId>");
		}
	}
	// field ForceClose
	{
		bool b = src.getForceClose();
		if (b)
			buffer.appendf("<ForceClose>1</ForceClose>");
	}
	if (keepRootTag)
		buffer.append("</CloseSessionRequest>");
}

bool CCloseSessionRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_SessionId.unmarshall(rpc_request, "SessionId", basepath);
	hasValue |= m_ForceClose.unmarshall(rpc_request, "ForceClose", basepath);
	return hasValue;
}

bool CCloseSessionRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_SessionId.unmarshall(ctx, soapval, "SessionId");
	hasValue |= m_ForceClose.unmarshall(ctx, soapval, "ForceClose");
	return hasValue;
}

bool CCloseSessionRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_SessionId.unmarshall(ctx, params, attachments, "SessionId", basepath);
	hasValue |= m_ForceClose.unmarshall(ctx, params, attachments, "ForceClose", basepath);
	return hasValue;
}

const char * CCloseSessionRequest::getSessionId() { return m_SessionId.query();}
bool CCloseSessionRequest::getForceClose() { return m_ForceClose;}
void CCloseSessionRequest::setSessionId(const char * val){ m_SessionId.set(val); }
void CCloseSessionRequest::setForceClose(bool val){ m_ForceClose=val; }
extern "C"  IEspCloseSessionRequest *createCloseSessionRequest(const char *serv){return ((IEspCloseSessionRequest *)new CCloseSessionRequest(serv));}
extern "C"  IClientCloseSessionRequest *createClientCloseSessionRequest(const char *serv){return ((IClientCloseSessionRequest *)new CCloseSessionRequest(serv));}

//=======================================================
// class CListOpenSessionsRequest Implementation
//=======================================================

CListOpenSessionsRequest::CListOpenSessionsRequest(const char *serviceName, IRpcMessageBinding *init)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ListOpenSessionsRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CListOpenSessionsRequest::CListOpenSessionsRequest(const char *serviceName, const char *bc)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ListOpenSessionsRequest");
}

CListOpenSessionsRequest::CListOpenSessionsRequest(const char *serviceName, IRpcMessage* rpcmsg)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ListOpenSessionsRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CListOpenSessionsRequest::CListOpenSessionsRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ListOpenSessionsRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CListOpenSessionsRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType><xsd:all/></xsd:complexType></xsd:element>\n", msgTypeName);
		}
	}
	return schema;
}

void CListOpenSessionsRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CListOpenSessionsRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CListOpenSessionsRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CListOpenSessionsRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CListOpenSessionsRequest::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

}


void CListOpenSessionsRequest::copy(CListOpenSessionsRequest &from)
{
}


void CListOpenSessionsRequest::copy(IConstListOpenSessionsRequest &ifrom)
{
}


void CListOpenSessionsRequest::getAttributes(IProperties &attributes)
{
}


void CListOpenSessionsRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
}


void CListOpenSessionsRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CListOpenSessionsRequest::serializer(IEspContext* ctx, IConstListOpenSessionsRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<ListOpenSessionsRequest>");
	if (keepRootTag)
		buffer.append("</ListOpenSessionsRequest>");
}

bool CListOpenSessionsRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	return hasValue;
}

bool CListOpenSessionsRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	return hasValue;
}

bool CListOpenSessionsRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	return hasValue;
}

extern "C"  IEspListOpenSessionsRequest *createListOpenSessionsRequest(const char *serv){return ((IEspListOpenSessionsRequest *)new CListOpenSessionsRequest(serv));}
extern "C"  IClientListOpenSessionsRequest *createClientListOpenSessionsRequest(const char *serv){return ((IClientListOpenSessionsRequest *)new CListOpenSessionsRequest(serv));}

//=======================================================
// class COpenSessionInfo Implementation
//=======================================================

COpenSessionInfo::COpenSessionInfo(const char *serviceName, IRpcMessageBinding *init)
	: m_Username(nilIgnore),m_CurEnvironmentFile("", nilIgnore),m_Locked(nilIgnore),m_Modified(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("OpenSessionInfo");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

COpenSessionInfo::COpenSessionInfo(const char *serviceName, const char *bc)
	: m_Username(nilIgnore),m_CurEnvironmentFile("", nilIgnore),m_Locked(nilIgnore),m_Modified(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("OpenSessionInfo");
}

StringBuffer &COpenSessionInfo::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:complexType name=\"%s\">\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Username\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" default=\"\" name=\"CurEnvironmentFile\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Locked\" type=\"xsd:boolean\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Modified\" type=\"xsd:boolean\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType>\n");
		}
	}
	return schema;
}

void COpenSessionInfo::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void COpenSessionInfo::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &COpenSessionInfo::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Username");
	form.appendf("  <tr><td><b>Username: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("CurEnvironmentFile");
	form.appendf("  <tr><td><b>CurEnvironmentFile: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Locked");
	
	form.appendf("  <tr><td><b>Locked? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Modified");
	
	form.appendf("  <tr><td><b>Modified? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &COpenSessionInfo::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void COpenSessionInfo::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_Username.marshall(rpc_resp, "Username", "", "", "");
	m_CurEnvironmentFile.marshall(rpc_resp, "CurEnvironmentFile", "", "", "");
	m_Locked.marshall(rpc_resp, "Locked", "", "", "");
	m_Modified.marshall(rpc_resp, "Modified", "", "", "");
}


void COpenSessionInfo::copy(COpenSessionInfo &from)
{
	m_Username.copy(from.m_Username);
	m_CurEnvironmentFile.copy(from.m_CurEnvironmentFile);
	m_Locked.copy(from.m_Locked);
	m_Modified.copy(from.m_Modified);
}


void COpenSessionInfo::copy(IConstOpenSessionInfo &ifrom)
{
	setUsername(ifrom.getUsername());
	setCurEnvironmentFile(ifrom.getCurEnvironmentFile());
	setLocked(ifrom.getLocked());
	setModified(ifrom.getModified());
}


void COpenSessionInfo::getAttributes(IProperties &attributes)
{
}


void COpenSessionInfo::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_Username.toStr(ctx, buffer, "Username", "", true, "", "");
	m_CurEnvironmentFile.toStr(ctx, buffer, "CurEnvironmentFile", "", true, "", "");
	m_Locked.toStr(ctx, buffer, "Locked", "", true, "", "");
	m_Modified.toStr(ctx, buffer, "Modified", "", true, "", "");
}


void COpenSessionInfo::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void COpenSessionInfo::serializer(IEspContext* ctx, IConstOpenSessionInfo &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<OpenSessionInfo>");
	// field Username
	{
		const char* s = src.getUsername();
		if (s && *s)
		{
			buffer.append("<Username>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Username>");
		}
	}
	// field CurEnvironmentFile
	{
		const char* s = src.getCurEnvironmentFile();
		if (s && *s)
		{
			buffer.append("<CurEnvironmentFile>");
			encodeUtf8XML(s,buffer);
			buffer.append("</CurEnvironmentFile>");
		}
	}
	// field Locked
	{
		bool b = src.getLocked();
		if (b)
			buffer.appendf("<Locked>1</Locked>");
	}
	// field Modified
	{
		bool b = src.getModified();
		if (b)
			buffer.appendf("<Modified>1</Modified>");
	}
	if (keepRootTag)
		buffer.append("</OpenSessionInfo>");
}

bool COpenSessionInfo::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_Username.unmarshall(rpc_request, "Username", basepath);
	hasValue |= m_CurEnvironmentFile.unmarshall(rpc_request, "CurEnvironmentFile", basepath);
	hasValue |= m_Locked.unmarshall(rpc_request, "Locked", basepath);
	hasValue |= m_Modified.unmarshall(rpc_request, "Modified", basepath);
	return hasValue;
}

bool COpenSessionInfo::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Username.unmarshall(ctx, soapval, "Username");
	hasValue |= m_CurEnvironmentFile.unmarshall(ctx, soapval, "CurEnvironmentFile");
	hasValue |= m_Locked.unmarshall(ctx, soapval, "Locked");
	hasValue |= m_Modified.unmarshall(ctx, soapval, "Modified");
	return hasValue;
}

bool COpenSessionInfo::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Username.unmarshall(ctx, params, attachments, "Username", basepath);
	hasValue |= m_CurEnvironmentFile.unmarshall(ctx, params, attachments, "CurEnvironmentFile", basepath);
	hasValue |= m_Locked.unmarshall(ctx, params, attachments, "Locked", basepath);
	hasValue |= m_Modified.unmarshall(ctx, params, attachments, "Modified", basepath);
	return hasValue;
}

const char * COpenSessionInfo::getUsername() { return m_Username.query();}
const char * COpenSessionInfo::getCurEnvironmentFile() { return m_CurEnvironmentFile.query();}
bool COpenSessionInfo::getLocked() { return m_Locked;}
bool COpenSessionInfo::getModified() { return m_Modified;}
void COpenSessionInfo::setUsername(const char * val){ m_Username.set(val); }
void COpenSessionInfo::setCurEnvironmentFile(const char * val){ m_CurEnvironmentFile.set(val); }
void COpenSessionInfo::setLocked(bool val){ m_Locked=val; }
void COpenSessionInfo::setModified(bool val){ m_Modified=val; }
extern "C"  IEspOpenSessionInfo *createOpenSessionInfo(const char *serv, const char *msgname){return ((IEspOpenSessionInfo *)new COpenSessionInfo(serv /*, msgname*/));}
extern "C"  IClientOpenSessionInfo *createClientOpenSessionInfo(const char *serv, const char *msgname){return ((IClientOpenSessionInfo *)new COpenSessionInfo(serv /*, msgname*/));}

//=======================================================
// class CListOpenSessionsResponse Implementation
//=======================================================

CListOpenSessionsResponse::CListOpenSessionsResponse(const char *serviceName, IRpcMessageBinding *init)
	: m_OpenSessions(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ListOpenSessionsResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CListOpenSessionsResponse::CListOpenSessionsResponse(const char *serviceName, const char *bc)
	: m_OpenSessions(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ListOpenSessionsResponse");
}

CListOpenSessionsResponse::CListOpenSessionsResponse(const char *serviceName, IRpcMessage* rpcmsg)
	: m_OpenSessions(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ListOpenSessionsResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CListOpenSessionsResponse::CListOpenSessionsResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_OpenSessions(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ListOpenSessionsResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CListOpenSessionsResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		schema.append("<xsd:element name=\"Exceptions\" type=\"tns:ArrayOfEspException\" minOccurs=\"0\" maxOccurs=\"1\"/>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"OpenSessions\">\n");
		schema.append("<xsd:complexType><xsd:sequence>\n");
		schema.append("<xsd:element minOccurs=\"0\" maxOccurs=\"unbounded\" name=\"SessionInfo\" type=\"tns:OpenSessionInfo\"/>");
		schema.append("</xsd:sequence></xsd:complexType>");
		schema.append("</xsd:element>");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	if (!(flags & 0x10)  || (flags & 0x100))
	{
		COpenSessionInfo::getXsdDefinition(context, request, schema, added);
	}
	return schema;
}

void CListOpenSessionsResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CListOpenSessionsResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
	if (!added.getValue("OpenSessionInfo"))
	{
		added.setValue("OpenSessionInfo",1);
		COpenSessionInfo::getMapInfo(info,added);
	}
}

StringBuffer &CListOpenSessionsResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("OpenSessions");
	form.appendf("<tr><td><b>OpenSessions: </b></td><td>");
	form.appendf("<table><tr><td><textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea></td>", extfix.str());
	form.append("</tr></table>");
	form.append("</td></tr>");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CListOpenSessionsResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CListOpenSessionsResponse::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
		m_OpenSessions.marshall(rpc_resp, "OpenSessions", "SessionInfo");
	}
}


void CListOpenSessionsResponse::copy(CListOpenSessionsResponse &from)
{
	m_OpenSessions.copy(from.m_OpenSessions);
}


void CListOpenSessionsResponse::copy(IConstListOpenSessionsResponse &ifrom)
{
	setOpenSessions(ifrom.getOpenSessions());
}


void CListOpenSessionsResponse::getAttributes(IProperties &attributes)
{
}


void CListOpenSessionsResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
		m_OpenSessions.toStr(ctx, buffer, "OpenSessions", "SessionInfo");
	}
}


void CListOpenSessionsResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CListOpenSessionsResponse::serializer(IEspContext* ctx, IConstListOpenSessionsResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<ListOpenSessionsResponse>");
	// field OpenSessions
	{
		IArrayOf<IConstOpenSessionInfo>& v = src.getOpenSessions();
		int size = v.length();
		if (size>0)
			buffer.append("<OpenSessions>");
		for (int i=0;i<size;i++)
		{
			buffer.append("<SessionInfo>");
			COpenSessionInfo::serializer(ctx,v.item(i),buffer,false);
			buffer.append("</SessionInfo>");
		}
		if (size>0)
			buffer.append("</OpenSessions>");
	}
	if (keepRootTag)
		buffer.append("</ListOpenSessionsResponse>");
}

bool CListOpenSessionsResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
		hasValue |= m_OpenSessions.unmarshall(rpc_request, "OpenSessions", basepath);
	}
	return hasValue;
}

bool CListOpenSessionsResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_OpenSessions.unmarshall(ctx, soapval, "OpenSessions");
	return hasValue;
}

bool CListOpenSessionsResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_OpenSessions.unmarshall(ctx, params, attachments, "OpenSessions", basepath);
	return hasValue;
}

IArrayOf<IConstOpenSessionInfo> & CListOpenSessionsResponse::getOpenSessions() { return (IArrayOf<IConstOpenSessionInfo> &) m_OpenSessions; }
void CListOpenSessionsResponse::setOpenSessions(IArrayOf<IEspOpenSessionInfo> &val)
{
	m_OpenSessions->kill();
	IArrayOf<IConstOpenSessionInfo> &target = m_OpenSessions.getValue();
	ForEachItemIn(idx, val)
	{
		IEspOpenSessionInfo &item = (val).item(idx);
		item.Link();
		target.append(item);
	}
}
void CListOpenSessionsResponse::setOpenSessions(IArrayOf<IConstOpenSessionInfo> &val)
{
	m_OpenSessions->kill();
	IArrayOf<IConstOpenSessionInfo> &target = m_OpenSessions.getValue();
	ForEachItemIn(idx, val)
	{
		IConstOpenSessionInfo &item = val.item(idx);
		item.Link();
		target.append(item);
	}
}
extern "C"  IEspListOpenSessionsResponse *createListOpenSessionsResponse(const char *serv){return ((IEspListOpenSessionsResponse *)new CListOpenSessionsResponse(serv));}
extern "C"  IClientListOpenSessionsResponse *createClientListOpenSessionsResponse(const char *serv){return ((IClientListOpenSessionsResponse *)new CListOpenSessionsResponse(serv));}

//=======================================================
// class CGetNodeRequest Implementation
//=======================================================

CGetNodeRequest::CGetNodeRequest(const char *serviceName, IRpcMessageBinding *init)
	: m_SessionId(nilIgnore),m_NodeId(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetNodeRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CGetNodeRequest::CGetNodeRequest(const char *serviceName, const char *bc)
	: m_SessionId(nilIgnore),m_NodeId(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetNodeRequest");
}

CGetNodeRequest::CGetNodeRequest(const char *serviceName, IRpcMessage* rpcmsg)
	: m_SessionId(nilIgnore),m_NodeId(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetNodeRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CGetNodeRequest::CGetNodeRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_SessionId(nilIgnore),m_NodeId(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetNodeRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CGetNodeRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"SessionId\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"NodeId\" type=\"xsd:string\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CGetNodeRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CGetNodeRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CGetNodeRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("SessionId");
	form.appendf("  <tr><td><b>SessionId: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("NodeId");
	form.appendf("  <tr><td><b>NodeId: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CGetNodeRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CGetNodeRequest::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_SessionId.marshall(rpc_resp, "SessionId", "", "", "");
	m_NodeId.marshall(rpc_resp, "NodeId", "", "", "");
}


void CGetNodeRequest::copy(CGetNodeRequest &from)
{
	m_SessionId.copy(from.m_SessionId);
	m_NodeId.copy(from.m_NodeId);
}


void CGetNodeRequest::copy(IConstGetNodeRequest &ifrom)
{
	setSessionId(ifrom.getSessionId());
	setNodeId(ifrom.getNodeId());
}


void CGetNodeRequest::getAttributes(IProperties &attributes)
{
}


void CGetNodeRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_SessionId.toStr(ctx, buffer, "SessionId", "", true, "", "");
	m_NodeId.toStr(ctx, buffer, "NodeId", "", true, "", "");
}


void CGetNodeRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CGetNodeRequest::serializer(IEspContext* ctx, IConstGetNodeRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<GetNodeRequest>");
	// field SessionId
	{
		const char* s = src.getSessionId();
		if (s && *s)
		{
			buffer.append("<SessionId>");
			encodeUtf8XML(s,buffer);
			buffer.append("</SessionId>");
		}
	}
	// field NodeId
	{
		const char* s = src.getNodeId();
		if (s && *s)
		{
			buffer.append("<NodeId>");
			encodeUtf8XML(s,buffer);
			buffer.append("</NodeId>");
		}
	}
	if (keepRootTag)
		buffer.append("</GetNodeRequest>");
}

bool CGetNodeRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_SessionId.unmarshall(rpc_request, "SessionId", basepath);
	hasValue |= m_NodeId.unmarshall(rpc_request, "NodeId", basepath);
	return hasValue;
}

bool CGetNodeRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_SessionId.unmarshall(ctx, soapval, "SessionId");
	hasValue |= m_NodeId.unmarshall(ctx, soapval, "NodeId");
	return hasValue;
}

bool CGetNodeRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_SessionId.unmarshall(ctx, params, attachments, "SessionId", basepath);
	hasValue |= m_NodeId.unmarshall(ctx, params, attachments, "NodeId", basepath);
	return hasValue;
}

const char * CGetNodeRequest::getSessionId() { return m_SessionId.query();}
const char * CGetNodeRequest::getNodeId() { return m_NodeId.query();}
void CGetNodeRequest::setSessionId(const char * val){ m_SessionId.set(val); }
void CGetNodeRequest::setNodeId(const char * val){ m_NodeId.set(val); }
extern "C"  IEspGetNodeRequest *createGetNodeRequest(const char *serv){return ((IEspGetNodeRequest *)new CGetNodeRequest(serv));}
extern "C"  IClientGetNodeRequest *createClientGetNodeRequest(const char *serv){return ((IClientGetNodeRequest *)new CGetNodeRequest(serv));}

//=======================================================
// class CGetParentsRequest Implementation
//=======================================================

CGetParentsRequest::CGetParentsRequest(const char *serviceName, IRpcMessageBinding *init)
	: m_SessionId(nilIgnore),m_NodeId(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetParentsRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CGetParentsRequest::CGetParentsRequest(const char *serviceName, const char *bc)
	: m_SessionId(nilIgnore),m_NodeId(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetParentsRequest");
}

CGetParentsRequest::CGetParentsRequest(const char *serviceName, IRpcMessage* rpcmsg)
	: m_SessionId(nilIgnore),m_NodeId(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetParentsRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CGetParentsRequest::CGetParentsRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_SessionId(nilIgnore),m_NodeId(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetParentsRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CGetParentsRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"SessionId\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"NodeId\" type=\"xsd:string\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CGetParentsRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CGetParentsRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CGetParentsRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("SessionId");
	form.appendf("  <tr><td><b>SessionId: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("NodeId");
	form.appendf("  <tr><td><b>NodeId: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CGetParentsRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CGetParentsRequest::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_SessionId.marshall(rpc_resp, "SessionId", "", "", "");
	m_NodeId.marshall(rpc_resp, "NodeId", "", "", "");
}


void CGetParentsRequest::copy(CGetParentsRequest &from)
{
	m_SessionId.copy(from.m_SessionId);
	m_NodeId.copy(from.m_NodeId);
}


void CGetParentsRequest::copy(IConstGetParentsRequest &ifrom)
{
	setSessionId(ifrom.getSessionId());
	setNodeId(ifrom.getNodeId());
}


void CGetParentsRequest::getAttributes(IProperties &attributes)
{
}


void CGetParentsRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_SessionId.toStr(ctx, buffer, "SessionId", "", true, "", "");
	m_NodeId.toStr(ctx, buffer, "NodeId", "", true, "", "");
}


void CGetParentsRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CGetParentsRequest::serializer(IEspContext* ctx, IConstGetParentsRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<GetParentsRequest>");
	// field SessionId
	{
		const char* s = src.getSessionId();
		if (s && *s)
		{
			buffer.append("<SessionId>");
			encodeUtf8XML(s,buffer);
			buffer.append("</SessionId>");
		}
	}
	// field NodeId
	{
		const char* s = src.getNodeId();
		if (s && *s)
		{
			buffer.append("<NodeId>");
			encodeUtf8XML(s,buffer);
			buffer.append("</NodeId>");
		}
	}
	if (keepRootTag)
		buffer.append("</GetParentsRequest>");
}

bool CGetParentsRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_SessionId.unmarshall(rpc_request, "SessionId", basepath);
	hasValue |= m_NodeId.unmarshall(rpc_request, "NodeId", basepath);
	return hasValue;
}

bool CGetParentsRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_SessionId.unmarshall(ctx, soapval, "SessionId");
	hasValue |= m_NodeId.unmarshall(ctx, soapval, "NodeId");
	return hasValue;
}

bool CGetParentsRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_SessionId.unmarshall(ctx, params, attachments, "SessionId", basepath);
	hasValue |= m_NodeId.unmarshall(ctx, params, attachments, "NodeId", basepath);
	return hasValue;
}

const char * CGetParentsRequest::getSessionId() { return m_SessionId.query();}
const char * CGetParentsRequest::getNodeId() { return m_NodeId.query();}
void CGetParentsRequest::setSessionId(const char * val){ m_SessionId.set(val); }
void CGetParentsRequest::setNodeId(const char * val){ m_NodeId.set(val); }
extern "C"  IEspGetParentsRequest *createGetParentsRequest(const char *serv){return ((IEspGetParentsRequest *)new CGetParentsRequest(serv));}
extern "C"  IClientGetParentsRequest *createClientGetParentsRequest(const char *serv){return ((IClientGetParentsRequest *)new CGetParentsRequest(serv));}

//=======================================================
// class CRemoveNodeRequest Implementation
//=======================================================

CRemoveNodeRequest::CRemoveNodeRequest(const char *serviceName, IRpcMessageBinding *init)
	: m_SessionId(nilIgnore),m_SessionLockKey(nilIgnore),m_NodeId(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("RemoveNodeRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CRemoveNodeRequest::CRemoveNodeRequest(const char *serviceName, const char *bc)
	: m_SessionId(nilIgnore),m_SessionLockKey(nilIgnore),m_NodeId(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("RemoveNodeRequest");
}

CRemoveNodeRequest::CRemoveNodeRequest(const char *serviceName, IRpcMessage* rpcmsg)
	: m_SessionId(nilIgnore),m_SessionLockKey(nilIgnore),m_NodeId(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("RemoveNodeRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CRemoveNodeRequest::CRemoveNodeRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_SessionId(nilIgnore),m_SessionLockKey(nilIgnore),m_NodeId(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("RemoveNodeRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CRemoveNodeRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"SessionId\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"SessionLockKey\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"NodeId\" type=\"xsd:string\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CRemoveNodeRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CRemoveNodeRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CRemoveNodeRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("SessionId");
	form.appendf("  <tr><td><b>SessionId: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("SessionLockKey");
	form.appendf("  <tr><td><b>SessionLockKey: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("NodeId");
	form.appendf("  <tr><td><b>NodeId: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CRemoveNodeRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CRemoveNodeRequest::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_SessionId.marshall(rpc_resp, "SessionId", "", "", "");
	m_SessionLockKey.marshall(rpc_resp, "SessionLockKey", "", "", "");
	m_NodeId.marshall(rpc_resp, "NodeId", "", "", "");
}


void CRemoveNodeRequest::copy(CRemoveNodeRequest &from)
{
	m_SessionId.copy(from.m_SessionId);
	m_SessionLockKey.copy(from.m_SessionLockKey);
	m_NodeId.copy(from.m_NodeId);
}


void CRemoveNodeRequest::copy(IConstRemoveNodeRequest &ifrom)
{
	setSessionId(ifrom.getSessionId());
	setSessionLockKey(ifrom.getSessionLockKey());
	setNodeId(ifrom.getNodeId());
}


void CRemoveNodeRequest::getAttributes(IProperties &attributes)
{
}


void CRemoveNodeRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_SessionId.toStr(ctx, buffer, "SessionId", "", true, "", "");
	m_SessionLockKey.toStr(ctx, buffer, "SessionLockKey", "", true, "", "");
	m_NodeId.toStr(ctx, buffer, "NodeId", "", true, "", "");
}


void CRemoveNodeRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CRemoveNodeRequest::serializer(IEspContext* ctx, IConstRemoveNodeRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<RemoveNodeRequest>");
	// field SessionId
	{
		const char* s = src.getSessionId();
		if (s && *s)
		{
			buffer.append("<SessionId>");
			encodeUtf8XML(s,buffer);
			buffer.append("</SessionId>");
		}
	}
	// field SessionLockKey
	{
		const char* s = src.getSessionLockKey();
		if (s && *s)
		{
			buffer.append("<SessionLockKey>");
			encodeUtf8XML(s,buffer);
			buffer.append("</SessionLockKey>");
		}
	}
	// field NodeId
	{
		const char* s = src.getNodeId();
		if (s && *s)
		{
			buffer.append("<NodeId>");
			encodeUtf8XML(s,buffer);
			buffer.append("</NodeId>");
		}
	}
	if (keepRootTag)
		buffer.append("</RemoveNodeRequest>");
}

bool CRemoveNodeRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_SessionId.unmarshall(rpc_request, "SessionId", basepath);
	hasValue |= m_SessionLockKey.unmarshall(rpc_request, "SessionLockKey", basepath);
	hasValue |= m_NodeId.unmarshall(rpc_request, "NodeId", basepath);
	return hasValue;
}

bool CRemoveNodeRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_SessionId.unmarshall(ctx, soapval, "SessionId");
	hasValue |= m_SessionLockKey.unmarshall(ctx, soapval, "SessionLockKey");
	hasValue |= m_NodeId.unmarshall(ctx, soapval, "NodeId");
	return hasValue;
}

bool CRemoveNodeRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_SessionId.unmarshall(ctx, params, attachments, "SessionId", basepath);
	hasValue |= m_SessionLockKey.unmarshall(ctx, params, attachments, "SessionLockKey", basepath);
	hasValue |= m_NodeId.unmarshall(ctx, params, attachments, "NodeId", basepath);
	return hasValue;
}

const char * CRemoveNodeRequest::getSessionId() { return m_SessionId.query();}
const char * CRemoveNodeRequest::getSessionLockKey() { return m_SessionLockKey.query();}
const char * CRemoveNodeRequest::getNodeId() { return m_NodeId.query();}
void CRemoveNodeRequest::setSessionId(const char * val){ m_SessionId.set(val); }
void CRemoveNodeRequest::setSessionLockKey(const char * val){ m_SessionLockKey.set(val); }
void CRemoveNodeRequest::setNodeId(const char * val){ m_NodeId.set(val); }
extern "C"  IEspRemoveNodeRequest *createRemoveNodeRequest(const char *serv){return ((IEspRemoveNodeRequest *)new CRemoveNodeRequest(serv));}
extern "C"  IClientRemoveNodeRequest *createClientRemoveNodeRequest(const char *serv){return ((IClientRemoveNodeRequest *)new CRemoveNodeRequest(serv));}

//=======================================================
// class CDependentValueType Implementation
//=======================================================

CDependentValueType::CDependentValueType(const char *serviceName, IRpcMessageBinding *init)
	: m_AttributeName(nilIgnore),m_AttributeValue(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("DependentValueType");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CDependentValueType::CDependentValueType(const char *serviceName, const char *bc)
	: m_AttributeName(nilIgnore),m_AttributeValue(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("DependentValueType");
}

StringBuffer &CDependentValueType::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:complexType name=\"%s\">\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"AttributeName\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"AttributeValue\" type=\"xsd:string\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType>\n");
		}
	}
	return schema;
}

void CDependentValueType::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CDependentValueType::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CDependentValueType::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("AttributeName");
	form.appendf("  <tr><td><b>AttributeName: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("AttributeValue");
	form.appendf("  <tr><td><b>AttributeValue: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CDependentValueType::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CDependentValueType::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_AttributeName.marshall(rpc_resp, "AttributeName", "", "", "");
	m_AttributeValue.marshall(rpc_resp, "AttributeValue", "", "", "");
}


void CDependentValueType::copy(CDependentValueType &from)
{
	m_AttributeName.copy(from.m_AttributeName);
	m_AttributeValue.copy(from.m_AttributeValue);
}


void CDependentValueType::copy(IConstDependentValueType &ifrom)
{
	setAttributeName(ifrom.getAttributeName());
	setAttributeValue(ifrom.getAttributeValue());
}


void CDependentValueType::getAttributes(IProperties &attributes)
{
}


void CDependentValueType::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_AttributeName.toStr(ctx, buffer, "AttributeName", "", true, "", "");
	m_AttributeValue.toStr(ctx, buffer, "AttributeValue", "", true, "", "");
}


void CDependentValueType::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CDependentValueType::serializer(IEspContext* ctx, IConstDependentValueType &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<DependentValueType>");
	// field AttributeName
	{
		const char* s = src.getAttributeName();
		if (s && *s)
		{
			buffer.append("<AttributeName>");
			encodeUtf8XML(s,buffer);
			buffer.append("</AttributeName>");
		}
	}
	// field AttributeValue
	{
		const char* s = src.getAttributeValue();
		if (s && *s)
		{
			buffer.append("<AttributeValue>");
			encodeUtf8XML(s,buffer);
			buffer.append("</AttributeValue>");
		}
	}
	if (keepRootTag)
		buffer.append("</DependentValueType>");
}

bool CDependentValueType::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_AttributeName.unmarshall(rpc_request, "AttributeName", basepath);
	hasValue |= m_AttributeValue.unmarshall(rpc_request, "AttributeValue", basepath);
	return hasValue;
}

bool CDependentValueType::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_AttributeName.unmarshall(ctx, soapval, "AttributeName");
	hasValue |= m_AttributeValue.unmarshall(ctx, soapval, "AttributeValue");
	return hasValue;
}

bool CDependentValueType::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_AttributeName.unmarshall(ctx, params, attachments, "AttributeName", basepath);
	hasValue |= m_AttributeValue.unmarshall(ctx, params, attachments, "AttributeValue", basepath);
	return hasValue;
}

const char * CDependentValueType::getAttributeName() { return m_AttributeName.query();}
const char * CDependentValueType::getAttributeValue() { return m_AttributeValue.query();}
void CDependentValueType::setAttributeName(const char * val){ m_AttributeName.set(val); }
void CDependentValueType::setAttributeValue(const char * val){ m_AttributeValue.set(val); }
extern "C"  IEspDependentValueType *createDependentValueType(const char *serv, const char *msgname){return ((IEspDependentValueType *)new CDependentValueType(serv /*, msgname*/));}
extern "C"  IClientDependentValueType *createClientDependentValueType(const char *serv, const char *msgname){return ((IClientDependentValueType *)new CDependentValueType(serv /*, msgname*/));}

//=======================================================
// class CChoiceType Implementation
//=======================================================

CChoiceType::CChoiceType(const char *serviceName, IRpcMessageBinding *init)
	: m_DisplayName(nilIgnore),m_Value(nilIgnore),m_Desc("", nilIgnore),m_MsgType("", nilIgnore),m_Msg("", nilIgnore),m_Dependencies(nilIgnore),m_OptionalAttributes(nilIgnore),m_RequiredAttributes(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ChoiceType");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CChoiceType::CChoiceType(const char *serviceName, const char *bc)
	: m_DisplayName(nilIgnore),m_Value(nilIgnore),m_Desc("", nilIgnore),m_MsgType("", nilIgnore),m_Msg("", nilIgnore),m_Dependencies(nilIgnore),m_OptionalAttributes(nilIgnore),m_RequiredAttributes(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ChoiceType");
}

StringBuffer &CChoiceType::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:complexType name=\"%s\">\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"DisplayName\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Value\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" default=\"\" name=\"Desc\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" default=\"\" name=\"MsgType\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" default=\"\" name=\"Msg\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Dependencies\">\n");
		schema.append("<xsd:complexType><xsd:sequence>\n");
		schema.append("<xsd:element minOccurs=\"0\" maxOccurs=\"unbounded\" name=\"dependentValue\" type=\"tns:DependentValueType\"/>");
		schema.append("</xsd:sequence></xsd:complexType>");
		schema.append("</xsd:element>");
		schema.append("<xsd:element minOccurs=\"0\" name=\"OptionalAttributes\">");
		schema.append("<xsd:complexType><xsd:sequence>");
		schema.append("<xsd:element name=\"Attribute\" type=\"xsd:string\" minOccurs=\"0\" maxOccurs=\"unbounded\"/>\n");
		schema.append("</xsd:sequence></xsd:complexType>\n");
		schema.append("</xsd:element>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"RequiredAttributes\">");
		schema.append("<xsd:complexType><xsd:sequence>");
		schema.append("<xsd:element name=\"Attribute\" type=\"xsd:string\" minOccurs=\"0\" maxOccurs=\"unbounded\"/>\n");
		schema.append("</xsd:sequence></xsd:complexType>\n");
		schema.append("</xsd:element>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType>\n");
		}
	}
	if (!(flags & 0x10)  || (flags & 0x100))
	{
		CDependentValueType::getXsdDefinition(context, request, schema, added);
	}
	return schema;
}

void CChoiceType::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CChoiceType::getMapInfo(IMapInfo& info, BoolHash& added)
{
	if (!added.getValue("DependentValueType"))
	{
		added.setValue("DependentValueType",1);
		CDependentValueType::getMapInfo(info,added);
	}
}

StringBuffer &CChoiceType::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("DisplayName");
	form.appendf("  <tr><td><b>DisplayName: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Value");
	form.appendf("  <tr><td><b>Value: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Desc");
	form.appendf("  <tr><td><b>Desc: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("MsgType");
	form.appendf("  <tr><td><b>MsgType: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Msg");
	form.appendf("  <tr><td><b>Msg: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Dependencies");
	form.appendf("<tr><td><b>Dependencies: </b></td><td>");
	form.appendf("<table><tr><td><textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea></td>", extfix.str());
	form.append("</tr></table>");
	form.append("</td></tr>");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("OptionalAttributes");
	form.appendf("<tr><td><b>OptionalAttributes: </b></td><td>");
	form.appendf("<textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea>", extfix.str());
	form.append("</td></tr>");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("RequiredAttributes");
	form.appendf("<tr><td><b>RequiredAttributes: </b></td><td>");
	form.appendf("<textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea>", extfix.str());
	form.append("</td></tr>");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CChoiceType::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CChoiceType::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_DisplayName.marshall(rpc_resp, "DisplayName", "", "", "");
	m_Value.marshall(rpc_resp, "Value", "", "", "");
	m_Desc.marshall(rpc_resp, "Desc", "", "", "");
	m_MsgType.marshall(rpc_resp, "MsgType", "", "", "");
	m_Msg.marshall(rpc_resp, "Msg", "", "", "");
	m_Dependencies.marshall(rpc_resp, "Dependencies", "dependentValue");
	m_OptionalAttributes.marshall(rpc_resp, "OptionalAttributes", "Attribute");
	m_RequiredAttributes.marshall(rpc_resp, "RequiredAttributes", "Attribute");
}


void CChoiceType::copy(CChoiceType &from)
{
	m_DisplayName.copy(from.m_DisplayName);
	m_Value.copy(from.m_Value);
	m_Desc.copy(from.m_Desc);
	m_MsgType.copy(from.m_MsgType);
	m_Msg.copy(from.m_Msg);
	m_Dependencies.copy(from.m_Dependencies);
	m_OptionalAttributes.copy(from.m_OptionalAttributes);
	m_RequiredAttributes.copy(from.m_RequiredAttributes);
}


void CChoiceType::copy(IConstChoiceType &ifrom)
{
	setDisplayName(ifrom.getDisplayName());
	setValue(ifrom.getValue());
	setDesc(ifrom.getDesc());
	setMsgType(ifrom.getMsgType());
	setMsg(ifrom.getMsg());
	setDependencies(ifrom.getDependencies());
	setOptionalAttributes(ifrom.getOptionalAttributes());
	setRequiredAttributes(ifrom.getRequiredAttributes());
}


void CChoiceType::getAttributes(IProperties &attributes)
{
}


void CChoiceType::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_DisplayName.toStr(ctx, buffer, "DisplayName", "", true, "", "");
	m_Value.toStr(ctx, buffer, "Value", "", true, "", "");
	m_Desc.toStr(ctx, buffer, "Desc", "", true, "", "");
	m_MsgType.toStr(ctx, buffer, "MsgType", "", true, "", "");
	m_Msg.toStr(ctx, buffer, "Msg", "", true, "", "");
	m_Dependencies.toStr(ctx, buffer, "Dependencies", "dependentValue");
	m_OptionalAttributes.toStr(ctx, buffer, "OptionalAttributes", "Attribute");
	m_RequiredAttributes.toStr(ctx, buffer, "RequiredAttributes", "Attribute");
}


void CChoiceType::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CChoiceType::serializer(IEspContext* ctx, IConstChoiceType &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<ChoiceType>");
	// field DisplayName
	{
		const char* s = src.getDisplayName();
		if (s && *s)
		{
			buffer.append("<DisplayName>");
			encodeUtf8XML(s,buffer);
			buffer.append("</DisplayName>");
		}
	}
	// field Value
	{
		const char* s = src.getValue();
		if (s && *s)
		{
			buffer.append("<Value>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Value>");
		}
	}
	// field Desc
	{
		const char* s = src.getDesc();
		if (s && *s)
		{
			buffer.append("<Desc>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Desc>");
		}
	}
	// field MsgType
	{
		const char* s = src.getMsgType();
		if (s && *s)
		{
			buffer.append("<MsgType>");
			encodeUtf8XML(s,buffer);
			buffer.append("</MsgType>");
		}
	}
	// field Msg
	{
		const char* s = src.getMsg();
		if (s && *s)
		{
			buffer.append("<Msg>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Msg>");
		}
	}
	// field Dependencies
	{
		IArrayOf<IConstDependentValueType>& v = src.getDependencies();
		int size = v.length();
		if (size>0)
			buffer.append("<Dependencies>");
		for (int i=0;i<size;i++)
		{
			buffer.append("<dependentValue>");
			CDependentValueType::serializer(ctx,v.item(i),buffer,false);
			buffer.append("</dependentValue>");
		}
		if (size>0)
			buffer.append("</Dependencies>");
	}
	// field OptionalAttributes
	{
		StringArray& v = src.getOptionalAttributes();
		if (v.length()>0)
			buffer.append("<OptionalAttributes>");
		for (size32_t i=0;i<v.length();i++)
			buffer.appendf("<Attribute>%s</Attribute>",v.item(i));
		if (v.length()>0)
			buffer.append("</OptionalAttributes>");
	}
	// field RequiredAttributes
	{
		StringArray& v = src.getRequiredAttributes();
		if (v.length()>0)
			buffer.append("<RequiredAttributes>");
		for (size32_t i=0;i<v.length();i++)
			buffer.appendf("<Attribute>%s</Attribute>",v.item(i));
		if (v.length()>0)
			buffer.append("</RequiredAttributes>");
	}
	if (keepRootTag)
		buffer.append("</ChoiceType>");
}

bool CChoiceType::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_DisplayName.unmarshall(rpc_request, "DisplayName", basepath);
	hasValue |= m_Value.unmarshall(rpc_request, "Value", basepath);
	hasValue |= m_Desc.unmarshall(rpc_request, "Desc", basepath);
	hasValue |= m_MsgType.unmarshall(rpc_request, "MsgType", basepath);
	hasValue |= m_Msg.unmarshall(rpc_request, "Msg", basepath);
	hasValue |= m_Dependencies.unmarshall(rpc_request, "Dependencies", basepath);
	hasValue |= m_OptionalAttributes.unmarshall(rpc_request, "OptionalAttributes", basepath);
	hasValue |= m_RequiredAttributes.unmarshall(rpc_request, "RequiredAttributes", basepath);
	return hasValue;
}

bool CChoiceType::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_DisplayName.unmarshall(ctx, soapval, "DisplayName");
	hasValue |= m_Value.unmarshall(ctx, soapval, "Value");
	hasValue |= m_Desc.unmarshall(ctx, soapval, "Desc");
	hasValue |= m_MsgType.unmarshall(ctx, soapval, "MsgType");
	hasValue |= m_Msg.unmarshall(ctx, soapval, "Msg");
	hasValue |= m_Dependencies.unmarshall(ctx, soapval, "Dependencies");
	hasValue |= m_OptionalAttributes.unmarshall(ctx, soapval, "OptionalAttributes");
	hasValue |= m_RequiredAttributes.unmarshall(ctx, soapval, "RequiredAttributes");
	return hasValue;
}

bool CChoiceType::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_DisplayName.unmarshall(ctx, params, attachments, "DisplayName", basepath);
	hasValue |= m_Value.unmarshall(ctx, params, attachments, "Value", basepath);
	hasValue |= m_Desc.unmarshall(ctx, params, attachments, "Desc", basepath);
	hasValue |= m_MsgType.unmarshall(ctx, params, attachments, "MsgType", basepath);
	hasValue |= m_Msg.unmarshall(ctx, params, attachments, "Msg", basepath);
	hasValue |= m_Dependencies.unmarshall(ctx, params, attachments, "Dependencies", basepath);
	hasValue |= m_OptionalAttributes.unmarshall(ctx, params, attachments, "OptionalAttributes", basepath);
	hasValue |= m_RequiredAttributes.unmarshall(ctx, params, attachments, "RequiredAttributes", basepath);
	return hasValue;
}

const char * CChoiceType::getDisplayName() { return m_DisplayName.query();}
const char * CChoiceType::getValue() { return m_Value.query();}
const char * CChoiceType::getDesc() { return m_Desc.query();}
const char * CChoiceType::getMsgType() { return m_MsgType.query();}
const char * CChoiceType::getMsg() { return m_Msg.query();}
IArrayOf<IConstDependentValueType> & CChoiceType::getDependencies() { return (IArrayOf<IConstDependentValueType> &) m_Dependencies; }
StringArray & CChoiceType::getOptionalAttributes() { return (StringArray &) m_OptionalAttributes; }
StringArray & CChoiceType::getRequiredAttributes() { return (StringArray &) m_RequiredAttributes; }
void CChoiceType::setDisplayName(const char * val){ m_DisplayName.set(val); }
void CChoiceType::setValue(const char * val){ m_Value.set(val); }
void CChoiceType::setDesc(const char * val){ m_Desc.set(val); }
void CChoiceType::setMsgType(const char * val){ m_MsgType.set(val); }
void CChoiceType::setMsg(const char * val){ m_Msg.set(val); }
void CChoiceType::setDependencies(IArrayOf<IEspDependentValueType> &val)
{
	m_Dependencies->kill();
	IArrayOf<IConstDependentValueType> &target = m_Dependencies.getValue();
	ForEachItemIn(idx, val)
	{
		IEspDependentValueType &item = (val).item(idx);
		item.Link();
		target.append(item);
	}
}
void CChoiceType::setDependencies(IArrayOf<IConstDependentValueType> &val)
{
	m_Dependencies->kill();
	IArrayOf<IConstDependentValueType> &target = m_Dependencies.getValue();
	ForEachItemIn(idx, val)
	{
		IConstDependentValueType &item = val.item(idx);
		item.Link();
		target.append(item);
	}
}
void CChoiceType::setOptionalAttributes(StringArray &val){ m_OptionalAttributes->kill();  CloneArray(m_OptionalAttributes.getValue(), val); }
void CChoiceType::setRequiredAttributes(StringArray &val){ m_RequiredAttributes->kill();  CloneArray(m_RequiredAttributes.getValue(), val); }
extern "C"  IEspChoiceType *createChoiceType(const char *serv, const char *msgname){return ((IEspChoiceType *)new CChoiceType(serv /*, msgname*/));}
extern "C"  IClientChoiceType *createClientChoiceType(const char *serv, const char *msgname){return ((IClientChoiceType *)new CChoiceType(serv /*, msgname*/));}

//=======================================================
// class CLimitsType Implementation
//=======================================================

CLimitsType::CLimitsType(const char *serviceName, IRpcMessageBinding *init)
	: m_MinValid(0, nilIgnore,false),m_MaxValid(0, nilIgnore,false),m_Min(0, nilIgnore,false),m_Max(0, nilIgnore,false),m_hasChoices(0, nilIgnore,false),m_ChoiceList(nilIgnore),m_Regex(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("LimitsType");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CLimitsType::CLimitsType(const char *serviceName, const char *bc)
	: m_MinValid(0, nilIgnore,false),m_MaxValid(0, nilIgnore,false),m_Min(0, nilIgnore,false),m_Max(0, nilIgnore,false),m_hasChoices(0, nilIgnore,false),m_ChoiceList(nilIgnore),m_Regex(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("LimitsType");
}

StringBuffer &CLimitsType::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:complexType name=\"%s\">\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" default=\"false\" name=\"MinValid\" type=\"xsd:boolean\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" default=\"false\" name=\"MaxValid\" type=\"xsd:boolean\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Min\" type=\"xsd:int\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Max\" type=\"xsd:int\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" default=\"false\" name=\"hasChoices\" type=\"xsd:boolean\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"ChoiceList\">\n");
		schema.append("<xsd:complexType><xsd:sequence>\n");
		schema.append("<xsd:element minOccurs=\"0\" maxOccurs=\"unbounded\" name=\"Choice\" type=\"tns:ChoiceType\"/>");
		schema.append("</xsd:sequence></xsd:complexType>");
		schema.append("</xsd:element>");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Regex\">");
		schema.append("<xsd:complexType><xsd:sequence>");
		schema.append("<xsd:element name=\"Expr\" type=\"xsd:string\" minOccurs=\"0\" maxOccurs=\"unbounded\"/>\n");
		schema.append("</xsd:sequence></xsd:complexType>\n");
		schema.append("</xsd:element>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType>\n");
		}
	}
	if (!(flags & 0x10)  || (flags & 0x100))
	{
		CChoiceType::getXsdDefinition(context, request, schema, added);
	}
	return schema;
}

void CLimitsType::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CLimitsType::getMapInfo(IMapInfo& info, BoolHash& added)
{
	if (!added.getValue("ChoiceType"))
	{
		added.setValue("ChoiceType",1);
		CChoiceType::getMapInfo(info,added);
	}
}

StringBuffer &CLimitsType::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("MinValid");
	
	form.appendf("  <tr><td><b>MinValid? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("MaxValid");
	
	form.appendf("  <tr><td><b>MaxValid? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	extfix.clear();
	if (prefix && *prefix) extfix.append(prefix).append(".");
		extfix.append("Min");
	form.appendf("  <tr><td><b>Min: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix) extfix.append(prefix).append(".");
		extfix.append("Max");
	form.appendf("  <tr><td><b>Max: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("hasChoices");
	
	form.appendf("  <tr><td><b>hasChoices? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("ChoiceList");
	form.appendf("<tr><td><b>ChoiceList: </b></td><td>");
	form.appendf("<table><tr><td><textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea></td>", extfix.str());
	form.append("</tr></table>");
	form.append("</td></tr>");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Regex");
	form.appendf("<tr><td><b>Regex: </b></td><td>");
	form.appendf("<textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea>", extfix.str());
	form.append("</td></tr>");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CLimitsType::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CLimitsType::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_MinValid.marshall(rpc_resp, "MinValid", "", "", "");
	m_MaxValid.marshall(rpc_resp, "MaxValid", "", "", "");
	m_Min.marshall(rpc_resp, "Min", "", "", "");
	m_Max.marshall(rpc_resp, "Max", "", "", "");
	m_hasChoices.marshall(rpc_resp, "hasChoices", "", "", "");
	m_ChoiceList.marshall(rpc_resp, "ChoiceList", "Choice");
	m_Regex.marshall(rpc_resp, "Regex", "Expr");
}


void CLimitsType::copy(CLimitsType &from)
{
	m_MinValid.copy(from.m_MinValid);
	m_MaxValid.copy(from.m_MaxValid);
	m_Min.copy(from.m_Min);
	m_Max.copy(from.m_Max);
	m_hasChoices.copy(from.m_hasChoices);
	m_ChoiceList.copy(from.m_ChoiceList);
	m_Regex.copy(from.m_Regex);
}


void CLimitsType::copy(IConstLimitsType &ifrom)
{
	setMinValid(ifrom.getMinValid());
	setMaxValid(ifrom.getMaxValid());
	setMin(ifrom.getMin());
	setMax(ifrom.getMax());
	setHasChoices(ifrom.getHasChoices());
	setChoiceList(ifrom.getChoiceList());
	setRegex(ifrom.getRegex());
}


void CLimitsType::getAttributes(IProperties &attributes)
{
}


void CLimitsType::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_MinValid.toStr(ctx, buffer, "MinValid", "", true, "", "");
	m_MaxValid.toStr(ctx, buffer, "MaxValid", "", true, "", "");
	m_Min.toStr(ctx, buffer, "Min", "", true, "", "");
	m_Max.toStr(ctx, buffer, "Max", "", true, "", "");
	m_hasChoices.toStr(ctx, buffer, "hasChoices", "", true, "", "");
	m_ChoiceList.toStr(ctx, buffer, "ChoiceList", "Choice");
	m_Regex.toStr(ctx, buffer, "Regex", "Expr");
}


void CLimitsType::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CLimitsType::serializer(IEspContext* ctx, IConstLimitsType &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<LimitsType>");
	// field MinValid
	{
		bool b = src.getMinValid();
		if (b)
			buffer.appendf("<MinValid>1</MinValid>");
	}
	// field MaxValid
	{
		bool b = src.getMaxValid();
		if (b)
			buffer.appendf("<MaxValid>1</MaxValid>");
	}
	// field Min
	{
		int n = src.getMin();
		if (n)
			buffer.appendf("<Min>%d</Min>", n);
	}
	// field Max
	{
		int n = src.getMax();
		if (n)
			buffer.appendf("<Max>%d</Max>", n);
	}
	// field hasChoices
	{
		bool b = src.getHasChoices();
		if (b)
			buffer.appendf("<hasChoices>1</hasChoices>");
	}
	// field ChoiceList
	{
		IArrayOf<IConstChoiceType>& v = src.getChoiceList();
		int size = v.length();
		if (size>0)
			buffer.append("<ChoiceList>");
		for (int i=0;i<size;i++)
		{
			buffer.append("<Choice>");
			CChoiceType::serializer(ctx,v.item(i),buffer,false);
			buffer.append("</Choice>");
		}
		if (size>0)
			buffer.append("</ChoiceList>");
	}
	// field Regex
	{
		StringArray& v = src.getRegex();
		if (v.length()>0)
			buffer.append("<Regex>");
		for (size32_t i=0;i<v.length();i++)
			buffer.appendf("<Expr>%s</Expr>",v.item(i));
		if (v.length()>0)
			buffer.append("</Regex>");
	}
	if (keepRootTag)
		buffer.append("</LimitsType>");
}

bool CLimitsType::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_MinValid.unmarshall(rpc_request, "MinValid", basepath);
	hasValue |= m_MaxValid.unmarshall(rpc_request, "MaxValid", basepath);
	hasValue |= m_Min.unmarshall(rpc_request, "Min", basepath);
	hasValue |= m_Max.unmarshall(rpc_request, "Max", basepath);
	hasValue |= m_hasChoices.unmarshall(rpc_request, "hasChoices", basepath);
	hasValue |= m_ChoiceList.unmarshall(rpc_request, "ChoiceList", basepath);
	hasValue |= m_Regex.unmarshall(rpc_request, "Regex", basepath);
	return hasValue;
}

bool CLimitsType::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_MinValid.unmarshall(ctx, soapval, "MinValid");
	hasValue |= m_MaxValid.unmarshall(ctx, soapval, "MaxValid");
	hasValue |= m_Min.unmarshall(ctx, soapval, "Min");
	hasValue |= m_Max.unmarshall(ctx, soapval, "Max");
	hasValue |= m_hasChoices.unmarshall(ctx, soapval, "hasChoices");
	hasValue |= m_ChoiceList.unmarshall(ctx, soapval, "ChoiceList");
	hasValue |= m_Regex.unmarshall(ctx, soapval, "Regex");
	return hasValue;
}

bool CLimitsType::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_MinValid.unmarshall(ctx, params, attachments, "MinValid", basepath);
	hasValue |= m_MaxValid.unmarshall(ctx, params, attachments, "MaxValid", basepath);
	hasValue |= m_Min.unmarshall(ctx, params, attachments, "Min", basepath);
	hasValue |= m_Max.unmarshall(ctx, params, attachments, "Max", basepath);
	hasValue |= m_hasChoices.unmarshall(ctx, params, attachments, "hasChoices", basepath);
	hasValue |= m_ChoiceList.unmarshall(ctx, params, attachments, "ChoiceList", basepath);
	hasValue |= m_Regex.unmarshall(ctx, params, attachments, "Regex", basepath);
	return hasValue;
}

bool CLimitsType::getMinValid() { return m_MinValid;}
bool CLimitsType::getMaxValid() { return m_MaxValid;}
int CLimitsType::getMin() { return m_Min;}
int CLimitsType::getMax() { return m_Max;}
bool CLimitsType::getHasChoices() { return m_hasChoices;}
IArrayOf<IConstChoiceType> & CLimitsType::getChoiceList() { return (IArrayOf<IConstChoiceType> &) m_ChoiceList; }
StringArray & CLimitsType::getRegex() { return (StringArray &) m_Regex; }
void CLimitsType::setMinValid(bool val){ m_MinValid=val; }
void CLimitsType::setMaxValid(bool val){ m_MaxValid=val; }
void CLimitsType::setMin(int val){ m_Min=val; }
void CLimitsType::setMax(int val){ m_Max=val; }
void CLimitsType::setHasChoices(bool val){ m_hasChoices=val; }
void CLimitsType::setChoiceList(IArrayOf<IEspChoiceType> &val)
{
	m_ChoiceList->kill();
	IArrayOf<IConstChoiceType> &target = m_ChoiceList.getValue();
	ForEachItemIn(idx, val)
	{
		IEspChoiceType &item = (val).item(idx);
		item.Link();
		target.append(item);
	}
}
void CLimitsType::setChoiceList(IArrayOf<IConstChoiceType> &val)
{
	m_ChoiceList->kill();
	IArrayOf<IConstChoiceType> &target = m_ChoiceList.getValue();
	ForEachItemIn(idx, val)
	{
		IConstChoiceType &item = val.item(idx);
		item.Link();
		target.append(item);
	}
}
void CLimitsType::setRegex(StringArray &val){ m_Regex->kill();  CloneArray(m_Regex.getValue(), val); }
extern "C"  IEspLimitsType *createLimitsType(const char *serv, const char *msgname){return ((IEspLimitsType *)new CLimitsType(serv /*, msgname*/));}
extern "C"  IClientLimitsType *createClientLimitsType(const char *serv, const char *msgname){return ((IClientLimitsType *)new CLimitsType(serv /*, msgname*/));}

//=======================================================
// class CTypeInfo Implementation
//=======================================================

CTypeInfo::CTypeInfo(const char *serviceName, IRpcMessageBinding *init)
	: m_BaseType(nilIgnore),m_SubType(nilIgnore),m_Limits(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("TypeInfo");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CTypeInfo::CTypeInfo(const char *serviceName, const char *bc)
	: m_BaseType(nilIgnore),m_SubType(nilIgnore),m_Limits(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("TypeInfo");
}

StringBuffer &CTypeInfo::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:complexType name=\"%s\">\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"BaseType\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"SubType\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Limits\" type=\"tns:LimitsType\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType>\n");
		}
	}
	if (!(flags & 0x10)  || (flags & 0x100))
	{
		CLimitsType::getXsdDefinition(context, request, schema, added);
	}
	return schema;
}

void CTypeInfo::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CTypeInfo::getMapInfo(IMapInfo& info, BoolHash& added)
{
	if (!added.getValue("LimitsType"))
	{
		added.setValue("LimitsType",1);
		CLimitsType::getMapInfo(info,added);
	}
}

StringBuffer &CTypeInfo::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("BaseType");
	form.appendf("  <tr><td><b>BaseType: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("SubType");
	form.appendf("  <tr><td><b>SubType: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Limits");
	form.append("<tr>").append("<td><b>Limits: </b></td><td><hr/>");
	CLimitsType::getHtmlForm(context, request, serv, method, form, false, extfix.str());
	form.append("<hr/></td></tr>");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CTypeInfo::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CTypeInfo::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_BaseType.marshall(rpc_resp, "BaseType", "", "", "");
	m_SubType.marshall(rpc_resp, "SubType", "", "", "");
	m_Limits.marshall(rpc_resp, "Limits", "", "", "");
}


void CTypeInfo::copy(CTypeInfo &from)
{
	m_BaseType.copy(from.m_BaseType);
	m_SubType.copy(from.m_SubType);
	m_Limits.copy(from.m_Limits);
}


void CTypeInfo::copy(IConstTypeInfo &ifrom)
{
	setBaseType(ifrom.getBaseType());
	setSubType(ifrom.getSubType());
	setLimits(ifrom.getLimits());
}


void CTypeInfo::getAttributes(IProperties &attributes)
{
}


void CTypeInfo::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_BaseType.toStr(ctx, buffer, "BaseType", "", true, "", "");
	m_SubType.toStr(ctx, buffer, "SubType", "", true, "", "");
	m_Limits.toStr(ctx, buffer, "Limits", "", false, "", "");
}


void CTypeInfo::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CTypeInfo::serializer(IEspContext* ctx, IConstTypeInfo &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<TypeInfo>");
	// field BaseType
	{
		const char* s = src.getBaseType();
		if (s && *s)
		{
			buffer.append("<BaseType>");
			encodeUtf8XML(s,buffer);
			buffer.append("</BaseType>");
		}
	}
	// field SubType
	{
		const char* s = src.getSubType();
		if (s && *s)
		{
			buffer.append("<SubType>");
			encodeUtf8XML(s,buffer);
			buffer.append("</SubType>");
		}
	}
	// field Limits
	{
		StringBuffer tmp;
		CLimitsType::serializer(ctx,src.getLimits(), tmp, false);
		if (tmp.length()>0)
			buffer.appendf("<Limits>%s</Limits>",tmp.str());
	}
	if (keepRootTag)
		buffer.append("</TypeInfo>");
}

bool CTypeInfo::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_BaseType.unmarshall(rpc_request, "BaseType", basepath);
	hasValue |= m_SubType.unmarshall(rpc_request, "SubType", basepath);
	hasValue |= m_Limits.unmarshall(rpc_request, "Limits", basepath);
	return hasValue;
}

bool CTypeInfo::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_BaseType.unmarshall(ctx, soapval, "BaseType");
	hasValue |= m_SubType.unmarshall(ctx, soapval, "SubType");
	hasValue |= m_Limits.unmarshall(ctx, soapval, "Limits");
	return hasValue;
}

bool CTypeInfo::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_BaseType.unmarshall(ctx, params, attachments, "BaseType", basepath);
	hasValue |= m_SubType.unmarshall(ctx, params, attachments, "SubType", basepath);
	hasValue |= m_Limits.unmarshall(ctx, params, attachments, "Limits", basepath);
	return hasValue;
}

const char * CTypeInfo::getBaseType() { return m_BaseType.query();}
const char * CTypeInfo::getSubType() { return m_SubType.query();}
IConstLimitsType & CTypeInfo::getLimits() { return (IConstLimitsType &) m_Limits.getValue();}
void CTypeInfo::setBaseType(const char * val){ m_BaseType.set(val); }
void CTypeInfo::setSubType(const char * val){ m_SubType.set(val); }
IEspLimitsType & CTypeInfo::updateLimits(){ return (IEspLimitsType &) m_Limits.getValue(); }
void CTypeInfo::setLimits(IConstLimitsType &ifrom){ m_Limits.copy(ifrom); }
extern "C"  IEspTypeInfo *createTypeInfo(const char *serv, const char *msgname){return ((IEspTypeInfo *)new CTypeInfo(serv /*, msgname*/));}
extern "C"  IClientTypeInfo *createClientTypeInfo(const char *serv, const char *msgname){return ((IClientTypeInfo *)new CTypeInfo(serv /*, msgname*/));}

//=======================================================
// class CNodeInfoType Implementation
//=======================================================

CNodeInfoType::CNodeInfoType(const char *serviceName, IRpcMessageBinding *init)
	: m_DisplayName("", nilIgnore),m_NodeType("", nilIgnore),m_Name(nilIgnore),m_Class("", nilIgnore),m_Category("", nilIgnore),m_Hidden(0, nilIgnore,false),m_Tooltip("", nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("NodeInfoType");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CNodeInfoType::CNodeInfoType(const char *serviceName, const char *bc)
	: m_DisplayName("", nilIgnore),m_NodeType("", nilIgnore),m_Name(nilIgnore),m_Class("", nilIgnore),m_Category("", nilIgnore),m_Hidden(0, nilIgnore,false),m_Tooltip("", nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("NodeInfoType");
}

StringBuffer &CNodeInfoType::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:complexType name=\"%s\">\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" default=\"\" name=\"DisplayName\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" default=\"\" name=\"NodeType\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Name\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" default=\"\" name=\"Class\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" default=\"\" name=\"Category\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" default=\"false\" name=\"Hidden\" type=\"xsd:boolean\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" default=\"\" name=\"Tooltip\" type=\"xsd:string\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType>\n");
		}
	}
	return schema;
}

void CNodeInfoType::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CNodeInfoType::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CNodeInfoType::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("DisplayName");
	form.appendf("  <tr><td><b>DisplayName: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("NodeType");
	form.appendf("  <tr><td><b>NodeType: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Name");
	form.appendf("  <tr><td><b>Name: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Class");
	form.appendf("  <tr><td><b>Class: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Category");
	form.appendf("  <tr><td><b>Category: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Hidden");
	
	form.appendf("  <tr><td><b>Hidden? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Tooltip");
	form.appendf("  <tr><td><b>Tooltip: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CNodeInfoType::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CNodeInfoType::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_DisplayName.marshall(rpc_resp, "DisplayName", "", "", "");
	m_NodeType.marshall(rpc_resp, "NodeType", "", "", "");
	m_Name.marshall(rpc_resp, "Name", "", "", "");
	m_Class.marshall(rpc_resp, "Class", "", "", "");
	m_Category.marshall(rpc_resp, "Category", "", "", "");
	m_Hidden.marshall(rpc_resp, "Hidden", "", "", "");
	m_Tooltip.marshall(rpc_resp, "Tooltip", "", "", "");
}


void CNodeInfoType::copy(CNodeInfoType &from)
{
	m_DisplayName.copy(from.m_DisplayName);
	m_NodeType.copy(from.m_NodeType);
	m_Name.copy(from.m_Name);
	m_Class.copy(from.m_Class);
	m_Category.copy(from.m_Category);
	m_Hidden.copy(from.m_Hidden);
	m_Tooltip.copy(from.m_Tooltip);
}


void CNodeInfoType::copy(IConstNodeInfoType &ifrom)
{
	setDisplayName(ifrom.getDisplayName());
	setNodeType(ifrom.getNodeType());
	setName(ifrom.getName());
	setClass(ifrom.getClass());
	setCategory(ifrom.getCategory());
	setHidden(ifrom.getHidden());
	setTooltip(ifrom.getTooltip());
}


void CNodeInfoType::getAttributes(IProperties &attributes)
{
}


void CNodeInfoType::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_DisplayName.toStr(ctx, buffer, "DisplayName", "", true, "", "");
	m_NodeType.toStr(ctx, buffer, "NodeType", "", true, "", "");
	m_Name.toStr(ctx, buffer, "Name", "", true, "", "");
	m_Class.toStr(ctx, buffer, "Class", "", true, "", "");
	m_Category.toStr(ctx, buffer, "Category", "", true, "", "");
	m_Hidden.toStr(ctx, buffer, "Hidden", "", true, "", "");
	m_Tooltip.toStr(ctx, buffer, "Tooltip", "", true, "", "");
}


void CNodeInfoType::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CNodeInfoType::serializer(IEspContext* ctx, IConstNodeInfoType &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<NodeInfoType>");
	// field DisplayName
	{
		const char* s = src.getDisplayName();
		if (s && *s)
		{
			buffer.append("<DisplayName>");
			encodeUtf8XML(s,buffer);
			buffer.append("</DisplayName>");
		}
	}
	// field NodeType
	{
		const char* s = src.getNodeType();
		if (s && *s)
		{
			buffer.append("<NodeType>");
			encodeUtf8XML(s,buffer);
			buffer.append("</NodeType>");
		}
	}
	// field Name
	{
		const char* s = src.getName();
		if (s && *s)
		{
			buffer.append("<Name>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Name>");
		}
	}
	// field Class
	{
		const char* s = src.getClass();
		if (s && *s)
		{
			buffer.append("<Class>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Class>");
		}
	}
	// field Category
	{
		const char* s = src.getCategory();
		if (s && *s)
		{
			buffer.append("<Category>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Category>");
		}
	}
	// field Hidden
	{
		bool b = src.getHidden();
		if (b)
			buffer.appendf("<Hidden>1</Hidden>");
	}
	// field Tooltip
	{
		const char* s = src.getTooltip();
		if (s && *s)
		{
			buffer.append("<Tooltip>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Tooltip>");
		}
	}
	if (keepRootTag)
		buffer.append("</NodeInfoType>");
}

bool CNodeInfoType::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_DisplayName.unmarshall(rpc_request, "DisplayName", basepath);
	hasValue |= m_NodeType.unmarshall(rpc_request, "NodeType", basepath);
	hasValue |= m_Name.unmarshall(rpc_request, "Name", basepath);
	hasValue |= m_Class.unmarshall(rpc_request, "Class", basepath);
	hasValue |= m_Category.unmarshall(rpc_request, "Category", basepath);
	hasValue |= m_Hidden.unmarshall(rpc_request, "Hidden", basepath);
	hasValue |= m_Tooltip.unmarshall(rpc_request, "Tooltip", basepath);
	return hasValue;
}

bool CNodeInfoType::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_DisplayName.unmarshall(ctx, soapval, "DisplayName");
	hasValue |= m_NodeType.unmarshall(ctx, soapval, "NodeType");
	hasValue |= m_Name.unmarshall(ctx, soapval, "Name");
	hasValue |= m_Class.unmarshall(ctx, soapval, "Class");
	hasValue |= m_Category.unmarshall(ctx, soapval, "Category");
	hasValue |= m_Hidden.unmarshall(ctx, soapval, "Hidden");
	hasValue |= m_Tooltip.unmarshall(ctx, soapval, "Tooltip");
	return hasValue;
}

bool CNodeInfoType::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_DisplayName.unmarshall(ctx, params, attachments, "DisplayName", basepath);
	hasValue |= m_NodeType.unmarshall(ctx, params, attachments, "NodeType", basepath);
	hasValue |= m_Name.unmarshall(ctx, params, attachments, "Name", basepath);
	hasValue |= m_Class.unmarshall(ctx, params, attachments, "Class", basepath);
	hasValue |= m_Category.unmarshall(ctx, params, attachments, "Category", basepath);
	hasValue |= m_Hidden.unmarshall(ctx, params, attachments, "Hidden", basepath);
	hasValue |= m_Tooltip.unmarshall(ctx, params, attachments, "Tooltip", basepath);
	return hasValue;
}

const char * CNodeInfoType::getDisplayName() { return m_DisplayName.query();}
const char * CNodeInfoType::getNodeType() { return m_NodeType.query();}
const char * CNodeInfoType::getName() { return m_Name.query();}
const char * CNodeInfoType::getClass() { return m_Class.query();}
const char * CNodeInfoType::getCategory() { return m_Category.query();}
bool CNodeInfoType::getHidden() { return m_Hidden;}
const char * CNodeInfoType::getTooltip() { return m_Tooltip.query();}
void CNodeInfoType::setDisplayName(const char * val){ m_DisplayName.set(val); }
void CNodeInfoType::setNodeType(const char * val){ m_NodeType.set(val); }
void CNodeInfoType::setName(const char * val){ m_Name.set(val); }
void CNodeInfoType::setClass(const char * val){ m_Class.set(val); }
void CNodeInfoType::setCategory(const char * val){ m_Category.set(val); }
void CNodeInfoType::setHidden(bool val){ m_Hidden=val; }
void CNodeInfoType::setTooltip(const char * val){ m_Tooltip.set(val); }
extern "C"  IEspNodeInfoType *createNodeInfoType(const char *serv, const char *msgname){return ((IEspNodeInfoType *)new CNodeInfoType(serv /*, msgname*/));}
extern "C"  IClientNodeInfoType *createClientNodeInfoType(const char *serv, const char *msgname){return ((IClientNodeInfoType *)new CNodeInfoType(serv /*, msgname*/));}

//=======================================================
// class CNode Implementation
//=======================================================

CNode::CNode(const char *serviceName, IRpcMessageBinding *init)
	: m_NodeId(nilIgnore),m_NumChildren(0, nilIgnore,false),m_NodeInfo(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("Node");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CNode::CNode(const char *serviceName, const char *bc)
	: m_NodeId(nilIgnore),m_NumChildren(0, nilIgnore,false),m_NodeInfo(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("Node");
}

StringBuffer &CNode::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:complexType name=\"%s\">\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"NodeId\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"NumChildren\" type=\"xsd:int\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"NodeInfo\" type=\"tns:NodeInfoType\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType>\n");
		}
	}
	if (!(flags & 0x10)  || (flags & 0x100))
	{
		CNodeInfoType::getXsdDefinition(context, request, schema, added);
	}
	return schema;
}

void CNode::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CNode::getMapInfo(IMapInfo& info, BoolHash& added)
{
	if (!added.getValue("NodeInfoType"))
	{
		added.setValue("NodeInfoType",1);
		CNodeInfoType::getMapInfo(info,added);
	}
}

StringBuffer &CNode::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("NodeId");
	form.appendf("  <tr><td><b>NodeId: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix) extfix.append(prefix).append(".");
		extfix.append("NumChildren");
	form.appendf("  <tr><td><b>NumChildren: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("NodeInfo");
	form.append("<tr>").append("<td><b>NodeInfo: </b></td><td><hr/>");
	CNodeInfoType::getHtmlForm(context, request, serv, method, form, false, extfix.str());
	form.append("<hr/></td></tr>");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CNode::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CNode::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_NodeId.marshall(rpc_resp, "NodeId", "", "", "");
	m_NumChildren.marshall(rpc_resp, "NumChildren", "", "", "");
	m_NodeInfo.marshall(rpc_resp, "NodeInfo", "", "", "");
}


void CNode::copy(CNode &from)
{
	m_NodeId.copy(from.m_NodeId);
	m_NumChildren.copy(from.m_NumChildren);
	m_NodeInfo.copy(from.m_NodeInfo);
}


void CNode::copy(IConstNode &ifrom)
{
	setNodeId(ifrom.getNodeId());
	setNumChildren(ifrom.getNumChildren());
	setNodeInfo(ifrom.getNodeInfo());
}


void CNode::getAttributes(IProperties &attributes)
{
}


void CNode::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_NodeId.toStr(ctx, buffer, "NodeId", "", true, "", "");
	m_NumChildren.toStr(ctx, buffer, "NumChildren", "", true, "", "");
	m_NodeInfo.toStr(ctx, buffer, "NodeInfo", "", false, "", "");
}


void CNode::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CNode::serializer(IEspContext* ctx, IConstNode &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<Node>");
	// field NodeId
	{
		const char* s = src.getNodeId();
		if (s && *s)
		{
			buffer.append("<NodeId>");
			encodeUtf8XML(s,buffer);
			buffer.append("</NodeId>");
		}
	}
	// field NumChildren
	{
		int n = src.getNumChildren();
		if (n)
			buffer.appendf("<NumChildren>%d</NumChildren>", n);
	}
	// field NodeInfo
	{
		StringBuffer tmp;
		CNodeInfoType::serializer(ctx,src.getNodeInfo(), tmp, false);
		if (tmp.length()>0)
			buffer.appendf("<NodeInfo>%s</NodeInfo>",tmp.str());
	}
	if (keepRootTag)
		buffer.append("</Node>");
}

bool CNode::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_NodeId.unmarshall(rpc_request, "NodeId", basepath);
	hasValue |= m_NumChildren.unmarshall(rpc_request, "NumChildren", basepath);
	hasValue |= m_NodeInfo.unmarshall(rpc_request, "NodeInfo", basepath);
	return hasValue;
}

bool CNode::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_NodeId.unmarshall(ctx, soapval, "NodeId");
	hasValue |= m_NumChildren.unmarshall(ctx, soapval, "NumChildren");
	hasValue |= m_NodeInfo.unmarshall(ctx, soapval, "NodeInfo");
	return hasValue;
}

bool CNode::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_NodeId.unmarshall(ctx, params, attachments, "NodeId", basepath);
	hasValue |= m_NumChildren.unmarshall(ctx, params, attachments, "NumChildren", basepath);
	hasValue |= m_NodeInfo.unmarshall(ctx, params, attachments, "NodeInfo", basepath);
	return hasValue;
}

const char * CNode::getNodeId() { return m_NodeId.query();}
int CNode::getNumChildren() { return m_NumChildren;}
IConstNodeInfoType & CNode::getNodeInfo() { return (IConstNodeInfoType &) m_NodeInfo.getValue();}
void CNode::setNodeId(const char * val){ m_NodeId.set(val); }
void CNode::setNumChildren(int val){ m_NumChildren=val; }
IEspNodeInfoType & CNode::updateNodeInfo(){ return (IEspNodeInfoType &) m_NodeInfo.getValue(); }
void CNode::setNodeInfo(IConstNodeInfoType &ifrom){ m_NodeInfo.copy(ifrom); }
extern "C"  IEspNode *createNode(const char *serv, const char *msgname){return ((IEspNode *)new CNode(serv /*, msgname*/));}
extern "C"  IClientNode *createClientNode(const char *serv, const char *msgname){return ((IClientNode *)new CNode(serv /*, msgname*/));}

//=======================================================
// class CChoiceLimitType Implementation
//=======================================================

CChoiceLimitType::CChoiceLimitType(const char *serviceName, IRpcMessageBinding *init)
	: m_DisplayName(nilIgnore),m_ItemType(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ChoiceLimitType");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CChoiceLimitType::CChoiceLimitType(const char *serviceName, const char *bc)
	: m_DisplayName(nilIgnore),m_ItemType(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ChoiceLimitType");
}

StringBuffer &CChoiceLimitType::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:complexType name=\"%s\">\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"DisplayName\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"ItemType\" type=\"xsd:string\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType>\n");
		}
	}
	return schema;
}

void CChoiceLimitType::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CChoiceLimitType::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CChoiceLimitType::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("DisplayName");
	form.appendf("  <tr><td><b>DisplayName: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("ItemType");
	form.appendf("  <tr><td><b>ItemType: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CChoiceLimitType::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CChoiceLimitType::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_DisplayName.marshall(rpc_resp, "DisplayName", "", "", "");
	m_ItemType.marshall(rpc_resp, "ItemType", "", "", "");
}


void CChoiceLimitType::copy(CChoiceLimitType &from)
{
	m_DisplayName.copy(from.m_DisplayName);
	m_ItemType.copy(from.m_ItemType);
}


void CChoiceLimitType::copy(IConstChoiceLimitType &ifrom)
{
	setDisplayName(ifrom.getDisplayName());
	setItemType(ifrom.getItemType());
}


void CChoiceLimitType::getAttributes(IProperties &attributes)
{
}


void CChoiceLimitType::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_DisplayName.toStr(ctx, buffer, "DisplayName", "", true, "", "");
	m_ItemType.toStr(ctx, buffer, "ItemType", "", true, "", "");
}


void CChoiceLimitType::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CChoiceLimitType::serializer(IEspContext* ctx, IConstChoiceLimitType &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<ChoiceLimitType>");
	// field DisplayName
	{
		const char* s = src.getDisplayName();
		if (s && *s)
		{
			buffer.append("<DisplayName>");
			encodeUtf8XML(s,buffer);
			buffer.append("</DisplayName>");
		}
	}
	// field ItemType
	{
		const char* s = src.getItemType();
		if (s && *s)
		{
			buffer.append("<ItemType>");
			encodeUtf8XML(s,buffer);
			buffer.append("</ItemType>");
		}
	}
	if (keepRootTag)
		buffer.append("</ChoiceLimitType>");
}

bool CChoiceLimitType::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_DisplayName.unmarshall(rpc_request, "DisplayName", basepath);
	hasValue |= m_ItemType.unmarshall(rpc_request, "ItemType", basepath);
	return hasValue;
}

bool CChoiceLimitType::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_DisplayName.unmarshall(ctx, soapval, "DisplayName");
	hasValue |= m_ItemType.unmarshall(ctx, soapval, "ItemType");
	return hasValue;
}

bool CChoiceLimitType::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_DisplayName.unmarshall(ctx, params, attachments, "DisplayName", basepath);
	hasValue |= m_ItemType.unmarshall(ctx, params, attachments, "ItemType", basepath);
	return hasValue;
}

const char * CChoiceLimitType::getDisplayName() { return m_DisplayName.query();}
const char * CChoiceLimitType::getItemType() { return m_ItemType.query();}
void CChoiceLimitType::setDisplayName(const char * val){ m_DisplayName.set(val); }
void CChoiceLimitType::setItemType(const char * val){ m_ItemType.set(val); }
extern "C"  IEspChoiceLimitType *createChoiceLimitType(const char *serv, const char *msgname){return ((IEspChoiceLimitType *)new CChoiceLimitType(serv /*, msgname*/));}
extern "C"  IClientChoiceLimitType *createClientChoiceLimitType(const char *serv, const char *msgname){return ((IClientChoiceLimitType *)new CChoiceLimitType(serv /*, msgname*/));}

//=======================================================
// class CInsertItemType Implementation
//=======================================================

CInsertItemType::CInsertItemType(const char *serviceName, IRpcMessageBinding *init)
	: m_Name("", nilIgnore),m_NodeType("", nilIgnore),m_Class("", nilIgnore),m_Category("", nilIgnore),m_Required(0, nilIgnore,false),m_Tooltip("", nilIgnore),m_ChoiceList(nilIgnore),m_FixedChoices(0, nilIgnore,false)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("InsertItemType");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CInsertItemType::CInsertItemType(const char *serviceName, const char *bc)
	: m_Name("", nilIgnore),m_NodeType("", nilIgnore),m_Class("", nilIgnore),m_Category("", nilIgnore),m_Required(0, nilIgnore,false),m_Tooltip("", nilIgnore),m_ChoiceList(nilIgnore),m_FixedChoices(0, nilIgnore,false)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("InsertItemType");
}

StringBuffer &CInsertItemType::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:complexType name=\"%s\">\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" default=\"\" name=\"Name\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" default=\"\" name=\"NodeType\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" default=\"\" name=\"Class\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" default=\"\" name=\"Category\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" default=\"false\" name=\"Required\" type=\"xsd:boolean\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" default=\"\" name=\"Tooltip\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"ChoiceList\">\n");
		schema.append("<xsd:complexType><xsd:sequence>\n");
		schema.append("<xsd:element minOccurs=\"0\" maxOccurs=\"unbounded\" name=\"ChoiceLimit\" type=\"tns:ChoiceLimitType\"/>");
		schema.append("</xsd:sequence></xsd:complexType>");
		schema.append("</xsd:element>");
		schema.append("<xsd:element minOccurs=\"0\" default=\"false\" name=\"FixedChoices\" type=\"xsd:boolean\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType>\n");
		}
	}
	if (!(flags & 0x10)  || (flags & 0x100))
	{
		CChoiceLimitType::getXsdDefinition(context, request, schema, added);
	}
	return schema;
}

void CInsertItemType::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CInsertItemType::getMapInfo(IMapInfo& info, BoolHash& added)
{
	if (!added.getValue("ChoiceLimitType"))
	{
		added.setValue("ChoiceLimitType",1);
		CChoiceLimitType::getMapInfo(info,added);
	}
}

StringBuffer &CInsertItemType::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Name");
	form.appendf("  <tr><td><b>Name: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("NodeType");
	form.appendf("  <tr><td><b>NodeType: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Class");
	form.appendf("  <tr><td><b>Class: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Category");
	form.appendf("  <tr><td><b>Category: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Required");
	
	form.appendf("  <tr><td><b>Required? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Tooltip");
	form.appendf("  <tr><td><b>Tooltip: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("ChoiceList");
	form.appendf("<tr><td><b>ChoiceList: </b></td><td>");
	form.appendf("<table><tr><td><textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea></td>", extfix.str());
	form.append("</tr></table>");
	form.append("</td></tr>");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("FixedChoices");
	
	form.appendf("  <tr><td><b>FixedChoices? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CInsertItemType::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CInsertItemType::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_Name.marshall(rpc_resp, "Name", "", "", "");
	m_NodeType.marshall(rpc_resp, "NodeType", "", "", "");
	m_Class.marshall(rpc_resp, "Class", "", "", "");
	m_Category.marshall(rpc_resp, "Category", "", "", "");
	m_Required.marshall(rpc_resp, "Required", "", "", "");
	m_Tooltip.marshall(rpc_resp, "Tooltip", "", "", "");
	m_ChoiceList.marshall(rpc_resp, "ChoiceList", "ChoiceLimit");
	m_FixedChoices.marshall(rpc_resp, "FixedChoices", "", "", "");
}


void CInsertItemType::copy(CInsertItemType &from)
{
	m_Name.copy(from.m_Name);
	m_NodeType.copy(from.m_NodeType);
	m_Class.copy(from.m_Class);
	m_Category.copy(from.m_Category);
	m_Required.copy(from.m_Required);
	m_Tooltip.copy(from.m_Tooltip);
	m_ChoiceList.copy(from.m_ChoiceList);
	m_FixedChoices.copy(from.m_FixedChoices);
}


void CInsertItemType::copy(IConstInsertItemType &ifrom)
{
	setName(ifrom.getName());
	setNodeType(ifrom.getNodeType());
	setClass(ifrom.getClass());
	setCategory(ifrom.getCategory());
	setRequired(ifrom.getRequired());
	setTooltip(ifrom.getTooltip());
	setChoiceList(ifrom.getChoiceList());
	setFixedChoices(ifrom.getFixedChoices());
}


void CInsertItemType::getAttributes(IProperties &attributes)
{
}


void CInsertItemType::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_Name.toStr(ctx, buffer, "Name", "", true, "", "");
	m_NodeType.toStr(ctx, buffer, "NodeType", "", true, "", "");
	m_Class.toStr(ctx, buffer, "Class", "", true, "", "");
	m_Category.toStr(ctx, buffer, "Category", "", true, "", "");
	m_Required.toStr(ctx, buffer, "Required", "", true, "", "");
	m_Tooltip.toStr(ctx, buffer, "Tooltip", "", true, "", "");
	m_ChoiceList.toStr(ctx, buffer, "ChoiceList", "ChoiceLimit");
	m_FixedChoices.toStr(ctx, buffer, "FixedChoices", "", true, "", "");
}


void CInsertItemType::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CInsertItemType::serializer(IEspContext* ctx, IConstInsertItemType &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<InsertItemType>");
	// field Name
	{
		const char* s = src.getName();
		if (s && *s)
		{
			buffer.append("<Name>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Name>");
		}
	}
	// field NodeType
	{
		const char* s = src.getNodeType();
		if (s && *s)
		{
			buffer.append("<NodeType>");
			encodeUtf8XML(s,buffer);
			buffer.append("</NodeType>");
		}
	}
	// field Class
	{
		const char* s = src.getClass();
		if (s && *s)
		{
			buffer.append("<Class>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Class>");
		}
	}
	// field Category
	{
		const char* s = src.getCategory();
		if (s && *s)
		{
			buffer.append("<Category>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Category>");
		}
	}
	// field Required
	{
		bool b = src.getRequired();
		if (b)
			buffer.appendf("<Required>1</Required>");
	}
	// field Tooltip
	{
		const char* s = src.getTooltip();
		if (s && *s)
		{
			buffer.append("<Tooltip>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Tooltip>");
		}
	}
	// field ChoiceList
	{
		IArrayOf<IConstChoiceLimitType>& v = src.getChoiceList();
		int size = v.length();
		if (size>0)
			buffer.append("<ChoiceList>");
		for (int i=0;i<size;i++)
		{
			buffer.append("<ChoiceLimit>");
			CChoiceLimitType::serializer(ctx,v.item(i),buffer,false);
			buffer.append("</ChoiceLimit>");
		}
		if (size>0)
			buffer.append("</ChoiceList>");
	}
	// field FixedChoices
	{
		bool b = src.getFixedChoices();
		if (b)
			buffer.appendf("<FixedChoices>1</FixedChoices>");
	}
	if (keepRootTag)
		buffer.append("</InsertItemType>");
}

bool CInsertItemType::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_Name.unmarshall(rpc_request, "Name", basepath);
	hasValue |= m_NodeType.unmarshall(rpc_request, "NodeType", basepath);
	hasValue |= m_Class.unmarshall(rpc_request, "Class", basepath);
	hasValue |= m_Category.unmarshall(rpc_request, "Category", basepath);
	hasValue |= m_Required.unmarshall(rpc_request, "Required", basepath);
	hasValue |= m_Tooltip.unmarshall(rpc_request, "Tooltip", basepath);
	hasValue |= m_ChoiceList.unmarshall(rpc_request, "ChoiceList", basepath);
	hasValue |= m_FixedChoices.unmarshall(rpc_request, "FixedChoices", basepath);
	return hasValue;
}

bool CInsertItemType::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Name.unmarshall(ctx, soapval, "Name");
	hasValue |= m_NodeType.unmarshall(ctx, soapval, "NodeType");
	hasValue |= m_Class.unmarshall(ctx, soapval, "Class");
	hasValue |= m_Category.unmarshall(ctx, soapval, "Category");
	hasValue |= m_Required.unmarshall(ctx, soapval, "Required");
	hasValue |= m_Tooltip.unmarshall(ctx, soapval, "Tooltip");
	hasValue |= m_ChoiceList.unmarshall(ctx, soapval, "ChoiceList");
	hasValue |= m_FixedChoices.unmarshall(ctx, soapval, "FixedChoices");
	return hasValue;
}

bool CInsertItemType::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Name.unmarshall(ctx, params, attachments, "Name", basepath);
	hasValue |= m_NodeType.unmarshall(ctx, params, attachments, "NodeType", basepath);
	hasValue |= m_Class.unmarshall(ctx, params, attachments, "Class", basepath);
	hasValue |= m_Category.unmarshall(ctx, params, attachments, "Category", basepath);
	hasValue |= m_Required.unmarshall(ctx, params, attachments, "Required", basepath);
	hasValue |= m_Tooltip.unmarshall(ctx, params, attachments, "Tooltip", basepath);
	hasValue |= m_ChoiceList.unmarshall(ctx, params, attachments, "ChoiceList", basepath);
	hasValue |= m_FixedChoices.unmarshall(ctx, params, attachments, "FixedChoices", basepath);
	return hasValue;
}

const char * CInsertItemType::getName() { return m_Name.query();}
const char * CInsertItemType::getNodeType() { return m_NodeType.query();}
const char * CInsertItemType::getClass() { return m_Class.query();}
const char * CInsertItemType::getCategory() { return m_Category.query();}
bool CInsertItemType::getRequired() { return m_Required;}
const char * CInsertItemType::getTooltip() { return m_Tooltip.query();}
IArrayOf<IConstChoiceLimitType> & CInsertItemType::getChoiceList() { return (IArrayOf<IConstChoiceLimitType> &) m_ChoiceList; }
bool CInsertItemType::getFixedChoices() { return m_FixedChoices;}
void CInsertItemType::setName(const char * val){ m_Name.set(val); }
void CInsertItemType::setNodeType(const char * val){ m_NodeType.set(val); }
void CInsertItemType::setClass(const char * val){ m_Class.set(val); }
void CInsertItemType::setCategory(const char * val){ m_Category.set(val); }
void CInsertItemType::setRequired(bool val){ m_Required=val; }
void CInsertItemType::setTooltip(const char * val){ m_Tooltip.set(val); }
void CInsertItemType::setChoiceList(IArrayOf<IEspChoiceLimitType> &val)
{
	m_ChoiceList->kill();
	IArrayOf<IConstChoiceLimitType> &target = m_ChoiceList.getValue();
	ForEachItemIn(idx, val)
	{
		IEspChoiceLimitType &item = (val).item(idx);
		item.Link();
		target.append(item);
	}
}
void CInsertItemType::setChoiceList(IArrayOf<IConstChoiceLimitType> &val)
{
	m_ChoiceList->kill();
	IArrayOf<IConstChoiceLimitType> &target = m_ChoiceList.getValue();
	ForEachItemIn(idx, val)
	{
		IConstChoiceLimitType &item = val.item(idx);
		item.Link();
		target.append(item);
	}
}
void CInsertItemType::setFixedChoices(bool val){ m_FixedChoices=val; }
extern "C"  IEspInsertItemType *createInsertItemType(const char *serv, const char *msgname){return ((IEspInsertItemType *)new CInsertItemType(serv /*, msgname*/));}
extern "C"  IClientInsertItemType *createClientInsertItemType(const char *serv, const char *msgname){return ((IClientInsertItemType *)new CInsertItemType(serv /*, msgname*/));}

//=======================================================
// class CAttributeType Implementation
//=======================================================

CAttributeType::CAttributeType(const char *serviceName, IRpcMessageBinding *init)
	: m_DisplayName(nilIgnore),m_Name(nilIgnore),m_Ordinal(nilIgnore),m_Group("", nilIgnore),m_Tooltip("", nilIgnore),m_Type(serviceName, nilIgnore),m_CurrentValue("", nilIgnore),m_ForcedValue("", nilIgnore),m_IsPresentInEnvironment(nilIgnore),m_PresetValue("", nilIgnore),m_Required(1, nilIgnore,false),m_ReadOnly(0, nilIgnore,false),m_Hidden(0, nilIgnore,false),m_Deprecated(0, nilIgnore,false),m_Modifiers(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("AttributeType");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CAttributeType::CAttributeType(const char *serviceName, const char *bc)
	: m_DisplayName(nilIgnore),m_Name(nilIgnore),m_Ordinal(nilIgnore),m_Group("", nilIgnore),m_Tooltip("", nilIgnore),m_Type(serviceName, nilIgnore),m_CurrentValue("", nilIgnore),m_ForcedValue("", nilIgnore),m_IsPresentInEnvironment(nilIgnore),m_PresetValue("", nilIgnore),m_Required(1, nilIgnore,false),m_ReadOnly(0, nilIgnore,false),m_Hidden(0, nilIgnore,false),m_Deprecated(0, nilIgnore,false),m_Modifiers(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("AttributeType");
}

StringBuffer &CAttributeType::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:complexType name=\"%s\">\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"DisplayName\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Name\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Ordinal\" type=\"xsd:unsignedInt\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" default=\"\" name=\"Group\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" default=\"\" name=\"Tooltip\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Type\" type=\"tns:TypeInfo\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" default=\"\" name=\"CurrentValue\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" default=\"\" name=\"ForcedValue\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"IsPresentInEnvironment\" type=\"xsd:boolean\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" default=\"\" name=\"PresetValue\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" default=\"true\" name=\"Required\" type=\"xsd:boolean\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" default=\"false\" name=\"ReadOnly\" type=\"xsd:boolean\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" default=\"false\" name=\"Hidden\" type=\"xsd:boolean\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" default=\"false\" name=\"Deprecated\" type=\"xsd:boolean\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Modifiers\">");
		schema.append("<xsd:complexType><xsd:sequence>");
		schema.append("<xsd:element name=\"Modifier\" type=\"xsd:string\" minOccurs=\"0\" maxOccurs=\"unbounded\"/>\n");
		schema.append("</xsd:sequence></xsd:complexType>\n");
		schema.append("</xsd:element>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType>\n");
		}
	}
	if (!(flags & 0x10)  || (flags & 0x100))
	{
		CTypeInfo::getXsdDefinition(context, request, schema, added);
	}
	return schema;
}

void CAttributeType::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CAttributeType::getMapInfo(IMapInfo& info, BoolHash& added)
{
	if (!added.getValue("TypeInfo"))
	{
		added.setValue("TypeInfo",1);
		CTypeInfo::getMapInfo(info,added);
	}
}

StringBuffer &CAttributeType::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("DisplayName");
	form.appendf("  <tr><td><b>DisplayName: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Name");
	form.appendf("  <tr><td><b>Name: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix) extfix.append(prefix).append(".");
		extfix.append("Ordinal");
	form.appendf("  <tr><td><b>Ordinal: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Group");
	form.appendf("  <tr><td><b>Group: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Tooltip");
	form.appendf("  <tr><td><b>Tooltip: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Type");
	form.append("<tr>").append("<td><b>Type: </b></td><td><hr/>");
	CTypeInfo::getHtmlForm(context, request, serv, method, form, false, extfix.str());
	form.append("<hr/></td></tr>");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("CurrentValue");
	form.appendf("  <tr><td><b>CurrentValue: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("ForcedValue");
	form.appendf("  <tr><td><b>ForcedValue: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("IsPresentInEnvironment");
	
	form.appendf("  <tr><td><b>IsPresentInEnvironment? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("PresetValue");
	form.appendf("  <tr><td><b>PresetValue: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Required");
	
	form.appendf("  <tr><td><b>Required? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\" checked=\"1\" /></td></tr>\n", extfix.str());
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("ReadOnly");
	
	form.appendf("  <tr><td><b>ReadOnly? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Hidden");
	
	form.appendf("  <tr><td><b>Hidden? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Deprecated");
	
	form.appendf("  <tr><td><b>Deprecated? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Modifiers");
	form.appendf("<tr><td><b>Modifiers: </b></td><td>");
	form.appendf("<textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea>", extfix.str());
	form.append("</td></tr>");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CAttributeType::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CAttributeType::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_DisplayName.marshall(rpc_resp, "DisplayName", "", "", "");
	m_Name.marshall(rpc_resp, "Name", "", "", "");
	m_Ordinal.marshall(rpc_resp, "Ordinal", "", "", "");
	m_Group.marshall(rpc_resp, "Group", "", "", "");
	m_Tooltip.marshall(rpc_resp, "Tooltip", "", "", "");
	m_Type.marshall(rpc_resp, "Type", "", "", "");
	m_CurrentValue.marshall(rpc_resp, "CurrentValue", "", "", "");
	m_ForcedValue.marshall(rpc_resp, "ForcedValue", "", "", "");
	m_IsPresentInEnvironment.marshall(rpc_resp, "IsPresentInEnvironment", "", "", "");
	m_PresetValue.marshall(rpc_resp, "PresetValue", "", "", "");
	m_Required.marshall(rpc_resp, "Required", "", "", "");
	m_ReadOnly.marshall(rpc_resp, "ReadOnly", "", "", "");
	m_Hidden.marshall(rpc_resp, "Hidden", "", "", "");
	m_Deprecated.marshall(rpc_resp, "Deprecated", "", "", "");
	m_Modifiers.marshall(rpc_resp, "Modifiers", "Modifier");
}


void CAttributeType::copy(CAttributeType &from)
{
	m_DisplayName.copy(from.m_DisplayName);
	m_Name.copy(from.m_Name);
	m_Ordinal.copy(from.m_Ordinal);
	m_Group.copy(from.m_Group);
	m_Tooltip.copy(from.m_Tooltip);
	m_Type.copy(from.m_Type);
	m_CurrentValue.copy(from.m_CurrentValue);
	m_ForcedValue.copy(from.m_ForcedValue);
	m_IsPresentInEnvironment.copy(from.m_IsPresentInEnvironment);
	m_PresetValue.copy(from.m_PresetValue);
	m_Required.copy(from.m_Required);
	m_ReadOnly.copy(from.m_ReadOnly);
	m_Hidden.copy(from.m_Hidden);
	m_Deprecated.copy(from.m_Deprecated);
	m_Modifiers.copy(from.m_Modifiers);
}


void CAttributeType::copy(IConstAttributeType &ifrom)
{
	setDisplayName(ifrom.getDisplayName());
	setName(ifrom.getName());
	setOrdinal(ifrom.getOrdinal());
	setGroup(ifrom.getGroup());
	setTooltip(ifrom.getTooltip());
	setType(ifrom.getType());
	setCurrentValue(ifrom.getCurrentValue());
	setForcedValue(ifrom.getForcedValue());
	setIsPresentInEnvironment(ifrom.getIsPresentInEnvironment());
	setPresetValue(ifrom.getPresetValue());
	setRequired(ifrom.getRequired());
	setReadOnly(ifrom.getReadOnly());
	setHidden(ifrom.getHidden());
	setDeprecated(ifrom.getDeprecated());
	setModifiers(ifrom.getModifiers());
}


void CAttributeType::getAttributes(IProperties &attributes)
{
}


void CAttributeType::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_DisplayName.toStr(ctx, buffer, "DisplayName", "", true, "", "");
	m_Name.toStr(ctx, buffer, "Name", "", true, "", "");
	m_Ordinal.toStr(ctx, buffer, "Ordinal", "", true, "", "");
	m_Group.toStr(ctx, buffer, "Group", "", true, "", "");
	m_Tooltip.toStr(ctx, buffer, "Tooltip", "", true, "", "");
	m_Type.toStr(ctx, buffer, "Type", "", false, "", "");
	m_CurrentValue.toStr(ctx, buffer, "CurrentValue", "", true, "", "");
	m_ForcedValue.toStr(ctx, buffer, "ForcedValue", "", true, "", "");
	m_IsPresentInEnvironment.toStr(ctx, buffer, "IsPresentInEnvironment", "", true, "", "");
	m_PresetValue.toStr(ctx, buffer, "PresetValue", "", true, "", "");
	m_Required.toStr(ctx, buffer, "Required", "", true, "", "");
	m_ReadOnly.toStr(ctx, buffer, "ReadOnly", "", true, "", "");
	m_Hidden.toStr(ctx, buffer, "Hidden", "", true, "", "");
	m_Deprecated.toStr(ctx, buffer, "Deprecated", "", true, "", "");
	m_Modifiers.toStr(ctx, buffer, "Modifiers", "Modifier");
}


void CAttributeType::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CAttributeType::serializer(IEspContext* ctx, IConstAttributeType &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<AttributeType>");
	// field DisplayName
	{
		const char* s = src.getDisplayName();
		if (s && *s)
		{
			buffer.append("<DisplayName>");
			encodeUtf8XML(s,buffer);
			buffer.append("</DisplayName>");
		}
	}
	// field Name
	{
		const char* s = src.getName();
		if (s && *s)
		{
			buffer.append("<Name>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Name>");
		}
	}
	// field Ordinal
	{
		//*** default kind: TK_UNSIGNED; type=(null), name=Ordinal
		buffer.append("<Ordinal>");
		buffer.append(src.getOrdinal());
		buffer.append("</Ordinal>");
	}
	// field Group
	{
		const char* s = src.getGroup();
		if (s && *s)
		{
			buffer.append("<Group>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Group>");
		}
	}
	// field Tooltip
	{
		const char* s = src.getTooltip();
		if (s && *s)
		{
			buffer.append("<Tooltip>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Tooltip>");
		}
	}
	// field Type
	{
		StringBuffer tmp;
		CTypeInfo::serializer(ctx,src.getType(), tmp, false);
		if (tmp.length()>0)
			buffer.appendf("<Type>%s</Type>",tmp.str());
	}
	// field CurrentValue
	{
		const char* s = src.getCurrentValue();
		if (s && *s)
		{
			buffer.append("<CurrentValue>");
			encodeUtf8XML(s,buffer);
			buffer.append("</CurrentValue>");
		}
	}
	// field ForcedValue
	{
		const char* s = src.getForcedValue();
		if (s && *s)
		{
			buffer.append("<ForcedValue>");
			encodeUtf8XML(s,buffer);
			buffer.append("</ForcedValue>");
		}
	}
	// field IsPresentInEnvironment
	{
		bool b = src.getIsPresentInEnvironment();
		if (b)
			buffer.appendf("<IsPresentInEnvironment>1</IsPresentInEnvironment>");
	}
	// field PresetValue
	{
		const char* s = src.getPresetValue();
		if (s && *s)
		{
			buffer.append("<PresetValue>");
			encodeUtf8XML(s,buffer);
			buffer.append("</PresetValue>");
		}
	}
	// field Required
	{
		bool b = src.getRequired();
		if (b)
			buffer.appendf("<Required>1</Required>");
	}
	// field ReadOnly
	{
		bool b = src.getReadOnly();
		if (b)
			buffer.appendf("<ReadOnly>1</ReadOnly>");
	}
	// field Hidden
	{
		bool b = src.getHidden();
		if (b)
			buffer.appendf("<Hidden>1</Hidden>");
	}
	// field Deprecated
	{
		bool b = src.getDeprecated();
		if (b)
			buffer.appendf("<Deprecated>1</Deprecated>");
	}
	// field Modifiers
	{
		StringArray& v = src.getModifiers();
		if (v.length()>0)
			buffer.append("<Modifiers>");
		for (size32_t i=0;i<v.length();i++)
			buffer.appendf("<Modifier>%s</Modifier>",v.item(i));
		if (v.length()>0)
			buffer.append("</Modifiers>");
	}
	if (keepRootTag)
		buffer.append("</AttributeType>");
}

bool CAttributeType::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_DisplayName.unmarshall(rpc_request, "DisplayName", basepath);
	hasValue |= m_Name.unmarshall(rpc_request, "Name", basepath);
	hasValue |= m_Ordinal.unmarshall(rpc_request, "Ordinal", basepath);
	hasValue |= m_Group.unmarshall(rpc_request, "Group", basepath);
	hasValue |= m_Tooltip.unmarshall(rpc_request, "Tooltip", basepath);
	hasValue |= m_Type.unmarshall(rpc_request, "Type", basepath);
	hasValue |= m_CurrentValue.unmarshall(rpc_request, "CurrentValue", basepath);
	hasValue |= m_ForcedValue.unmarshall(rpc_request, "ForcedValue", basepath);
	hasValue |= m_IsPresentInEnvironment.unmarshall(rpc_request, "IsPresentInEnvironment", basepath);
	hasValue |= m_PresetValue.unmarshall(rpc_request, "PresetValue", basepath);
	hasValue |= m_Required.unmarshall(rpc_request, "Required", basepath);
	hasValue |= m_ReadOnly.unmarshall(rpc_request, "ReadOnly", basepath);
	hasValue |= m_Hidden.unmarshall(rpc_request, "Hidden", basepath);
	hasValue |= m_Deprecated.unmarshall(rpc_request, "Deprecated", basepath);
	hasValue |= m_Modifiers.unmarshall(rpc_request, "Modifiers", basepath);
	return hasValue;
}

bool CAttributeType::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_DisplayName.unmarshall(ctx, soapval, "DisplayName");
	hasValue |= m_Name.unmarshall(ctx, soapval, "Name");
	hasValue |= m_Ordinal.unmarshall(ctx, soapval, "Ordinal");
	hasValue |= m_Group.unmarshall(ctx, soapval, "Group");
	hasValue |= m_Tooltip.unmarshall(ctx, soapval, "Tooltip");
	hasValue |= m_Type.unmarshall(ctx, soapval, "Type");
	hasValue |= m_CurrentValue.unmarshall(ctx, soapval, "CurrentValue");
	hasValue |= m_ForcedValue.unmarshall(ctx, soapval, "ForcedValue");
	hasValue |= m_IsPresentInEnvironment.unmarshall(ctx, soapval, "IsPresentInEnvironment");
	hasValue |= m_PresetValue.unmarshall(ctx, soapval, "PresetValue");
	hasValue |= m_Required.unmarshall(ctx, soapval, "Required");
	hasValue |= m_ReadOnly.unmarshall(ctx, soapval, "ReadOnly");
	hasValue |= m_Hidden.unmarshall(ctx, soapval, "Hidden");
	hasValue |= m_Deprecated.unmarshall(ctx, soapval, "Deprecated");
	hasValue |= m_Modifiers.unmarshall(ctx, soapval, "Modifiers");
	return hasValue;
}

bool CAttributeType::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_DisplayName.unmarshall(ctx, params, attachments, "DisplayName", basepath);
	hasValue |= m_Name.unmarshall(ctx, params, attachments, "Name", basepath);
	hasValue |= m_Ordinal.unmarshall(ctx, params, attachments, "Ordinal", basepath);
	hasValue |= m_Group.unmarshall(ctx, params, attachments, "Group", basepath);
	hasValue |= m_Tooltip.unmarshall(ctx, params, attachments, "Tooltip", basepath);
	hasValue |= m_Type.unmarshall(ctx, params, attachments, "Type", basepath);
	hasValue |= m_CurrentValue.unmarshall(ctx, params, attachments, "CurrentValue", basepath);
	hasValue |= m_ForcedValue.unmarshall(ctx, params, attachments, "ForcedValue", basepath);
	hasValue |= m_IsPresentInEnvironment.unmarshall(ctx, params, attachments, "IsPresentInEnvironment", basepath);
	hasValue |= m_PresetValue.unmarshall(ctx, params, attachments, "PresetValue", basepath);
	hasValue |= m_Required.unmarshall(ctx, params, attachments, "Required", basepath);
	hasValue |= m_ReadOnly.unmarshall(ctx, params, attachments, "ReadOnly", basepath);
	hasValue |= m_Hidden.unmarshall(ctx, params, attachments, "Hidden", basepath);
	hasValue |= m_Deprecated.unmarshall(ctx, params, attachments, "Deprecated", basepath);
	hasValue |= m_Modifiers.unmarshall(ctx, params, attachments, "Modifiers", basepath);
	return hasValue;
}

const char * CAttributeType::getDisplayName() { return m_DisplayName.query();}
const char * CAttributeType::getName() { return m_Name.query();}
unsigned int CAttributeType::getOrdinal() { return m_Ordinal;}
const char * CAttributeType::getGroup() { return m_Group.query();}
const char * CAttributeType::getTooltip() { return m_Tooltip.query();}
IConstTypeInfo & CAttributeType::getType() { return (IConstTypeInfo &) m_Type.getValue();}
const char * CAttributeType::getCurrentValue() { return m_CurrentValue.query();}
const char * CAttributeType::getForcedValue() { return m_ForcedValue.query();}
bool CAttributeType::getIsPresentInEnvironment() { return m_IsPresentInEnvironment;}
const char * CAttributeType::getPresetValue() { return m_PresetValue.query();}
bool CAttributeType::getRequired() { return m_Required;}
bool CAttributeType::getReadOnly() { return m_ReadOnly;}
bool CAttributeType::getHidden() { return m_Hidden;}
bool CAttributeType::getDeprecated() { return m_Deprecated;}
StringArray & CAttributeType::getModifiers() { return (StringArray &) m_Modifiers; }
void CAttributeType::setDisplayName(const char * val){ m_DisplayName.set(val); }
void CAttributeType::setName(const char * val){ m_Name.set(val); }
void CAttributeType::setOrdinal(unsigned int val){ m_Ordinal=val; }
void CAttributeType::setGroup(const char * val){ m_Group.set(val); }
void CAttributeType::setTooltip(const char * val){ m_Tooltip.set(val); }
IEspTypeInfo & CAttributeType::updateType(){ return (IEspTypeInfo &) m_Type.getValue(); }
void CAttributeType::setType(IConstTypeInfo &ifrom){ m_Type.copy(ifrom); }
void CAttributeType::setCurrentValue(const char * val){ m_CurrentValue.set(val); }
void CAttributeType::setForcedValue(const char * val){ m_ForcedValue.set(val); }
void CAttributeType::setIsPresentInEnvironment(bool val){ m_IsPresentInEnvironment=val; }
void CAttributeType::setPresetValue(const char * val){ m_PresetValue.set(val); }
void CAttributeType::setRequired(bool val){ m_Required=val; }
void CAttributeType::setReadOnly(bool val){ m_ReadOnly=val; }
void CAttributeType::setHidden(bool val){ m_Hidden=val; }
void CAttributeType::setDeprecated(bool val){ m_Deprecated=val; }
void CAttributeType::setModifiers(StringArray &val){ m_Modifiers->kill();  CloneArray(m_Modifiers.getValue(), val); }
extern "C"  IEspAttributeType *createAttributeType(const char *serv, const char *msgname){return ((IEspAttributeType *)new CAttributeType(serv /*, msgname*/));}
extern "C"  IClientAttributeType *createClientAttributeType(const char *serv, const char *msgname){return ((IClientAttributeType *)new CAttributeType(serv /*, msgname*/));}

//=======================================================
// class CAttributeValueType Implementation
//=======================================================

CAttributeValueType::CAttributeValueType(const char *serviceName, IRpcMessageBinding *init)
	: m_Name(nilIgnore),m_Value(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("AttributeValueType");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CAttributeValueType::CAttributeValueType(const char *serviceName, const char *bc)
	: m_Name(nilIgnore),m_Value(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("AttributeValueType");
}

StringBuffer &CAttributeValueType::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:complexType name=\"%s\">\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Name\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Value\" type=\"xsd:string\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType>\n");
		}
	}
	return schema;
}

void CAttributeValueType::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CAttributeValueType::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CAttributeValueType::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Name");
	form.appendf("  <tr><td><b>Name: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Value");
	form.appendf("  <tr><td><b>Value: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CAttributeValueType::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CAttributeValueType::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_Name.marshall(rpc_resp, "Name", "", "", "");
	m_Value.marshall(rpc_resp, "Value", "", "", "");
}


void CAttributeValueType::copy(CAttributeValueType &from)
{
	m_Name.copy(from.m_Name);
	m_Value.copy(from.m_Value);
}


void CAttributeValueType::copy(IConstAttributeValueType &ifrom)
{
	setName(ifrom.getName());
	setValue(ifrom.getValue());
}


void CAttributeValueType::getAttributes(IProperties &attributes)
{
}


void CAttributeValueType::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_Name.toStr(ctx, buffer, "Name", "", true, "", "");
	m_Value.toStr(ctx, buffer, "Value", "", true, "", "");
}


void CAttributeValueType::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CAttributeValueType::serializer(IEspContext* ctx, IConstAttributeValueType &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<AttributeValueType>");
	// field Name
	{
		const char* s = src.getName();
		if (s && *s)
		{
			buffer.append("<Name>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Name>");
		}
	}
	// field Value
	{
		const char* s = src.getValue();
		if (s && *s)
		{
			buffer.append("<Value>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Value>");
		}
	}
	if (keepRootTag)
		buffer.append("</AttributeValueType>");
}

bool CAttributeValueType::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_Name.unmarshall(rpc_request, "Name", basepath);
	hasValue |= m_Value.unmarshall(rpc_request, "Value", basepath);
	return hasValue;
}

bool CAttributeValueType::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Name.unmarshall(ctx, soapval, "Name");
	hasValue |= m_Value.unmarshall(ctx, soapval, "Value");
	return hasValue;
}

bool CAttributeValueType::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Name.unmarshall(ctx, params, attachments, "Name", basepath);
	hasValue |= m_Value.unmarshall(ctx, params, attachments, "Value", basepath);
	return hasValue;
}

const char * CAttributeValueType::getName() { return m_Name.query();}
const char * CAttributeValueType::getValue() { return m_Value.query();}
void CAttributeValueType::setName(const char * val){ m_Name.set(val); }
void CAttributeValueType::setValue(const char * val){ m_Value.set(val); }
extern "C"  IEspAttributeValueType *createAttributeValueType(const char *serv, const char *msgname){return ((IEspAttributeValueType *)new CAttributeValueType(serv /*, msgname*/));}
extern "C"  IClientAttributeValueType *createClientAttributeValueType(const char *serv, const char *msgname){return ((IClientAttributeValueType *)new CAttributeValueType(serv /*, msgname*/));}

//=======================================================
// class CGetNodeResponse Implementation
//=======================================================

CGetNodeResponse::CGetNodeResponse(const char *serviceName, IRpcMessageBinding *init)
	: m_NodeId(nilIgnore),m_NodeInfo(serviceName, nilIgnore),m_Attributes(nilIgnore),m_Children(nilIgnore),m_Insertable(nilIgnore),m_Status(serviceName, nilIgnore),m_LocalValueDefined(0, nilIgnore,false),m_Value(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetNodeResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CGetNodeResponse::CGetNodeResponse(const char *serviceName, const char *bc)
	: m_NodeId(nilIgnore),m_NodeInfo(serviceName, nilIgnore),m_Attributes(nilIgnore),m_Children(nilIgnore),m_Insertable(nilIgnore),m_Status(serviceName, nilIgnore),m_LocalValueDefined(0, nilIgnore,false),m_Value(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetNodeResponse");
}

CGetNodeResponse::CGetNodeResponse(const char *serviceName, IRpcMessage* rpcmsg)
	: m_NodeId(nilIgnore),m_NodeInfo(serviceName, nilIgnore),m_Attributes(nilIgnore),m_Children(nilIgnore),m_Insertable(nilIgnore),m_Status(serviceName, nilIgnore),m_LocalValueDefined(0, nilIgnore,false),m_Value(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetNodeResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CGetNodeResponse::CGetNodeResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_NodeId(nilIgnore),m_NodeInfo(serviceName, nilIgnore),m_Attributes(nilIgnore),m_Children(nilIgnore),m_Insertable(nilIgnore),m_Status(serviceName, nilIgnore),m_LocalValueDefined(0, nilIgnore,false),m_Value(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetNodeResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CGetNodeResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		schema.append("<xsd:element name=\"Exceptions\" type=\"tns:ArrayOfEspException\" minOccurs=\"0\" maxOccurs=\"1\"/>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"NodeId\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"NodeInfo\" type=\"tns:NodeInfoType\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Attributes\">\n");
		schema.append("<xsd:complexType><xsd:sequence>\n");
		schema.append("<xsd:element minOccurs=\"0\" maxOccurs=\"unbounded\" name=\"Attribute\" type=\"tns:AttributeType\"/>");
		schema.append("</xsd:sequence></xsd:complexType>");
		schema.append("</xsd:element>");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Children\">\n");
		schema.append("<xsd:complexType><xsd:sequence>\n");
		schema.append("<xsd:element minOccurs=\"0\" maxOccurs=\"unbounded\" name=\"Child\" type=\"tns:Node\"/>");
		schema.append("</xsd:sequence></xsd:complexType>");
		schema.append("</xsd:element>");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Insertable\">\n");
		schema.append("<xsd:complexType><xsd:sequence>\n");
		schema.append("<xsd:element minOccurs=\"0\" maxOccurs=\"unbounded\" name=\"Item\" type=\"tns:InsertItemType\"/>");
		schema.append("</xsd:sequence></xsd:complexType>");
		schema.append("</xsd:element>");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Status\" type=\"tns:StatusType\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" default=\"false\" name=\"LocalValueDefined\" type=\"xsd:boolean\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Value\" type=\"tns:AttributeType\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	if (!(flags & 0x10)  || (flags & 0x100))
	{
		CNodeInfoType::getXsdDefinition(context, request, schema, added);
		CAttributeType::getXsdDefinition(context, request, schema, added);
		CNode::getXsdDefinition(context, request, schema, added);
		CInsertItemType::getXsdDefinition(context, request, schema, added);
		CStatusType::getXsdDefinition(context, request, schema, added);
	}
	return schema;
}

void CGetNodeResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CGetNodeResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
	if (!added.getValue("AttributeType"))
	{
		added.setValue("AttributeType",1);
		CAttributeType::getMapInfo(info,added);
	}
	if (!added.getValue("InsertItemType"))
	{
		added.setValue("InsertItemType",1);
		CInsertItemType::getMapInfo(info,added);
	}
	if (!added.getValue("Node"))
	{
		added.setValue("Node",1);
		CNode::getMapInfo(info,added);
	}
	if (!added.getValue("NodeInfoType"))
	{
		added.setValue("NodeInfoType",1);
		CNodeInfoType::getMapInfo(info,added);
	}
	if (!added.getValue("StatusType"))
	{
		added.setValue("StatusType",1);
		CStatusType::getMapInfo(info,added);
	}
}

StringBuffer &CGetNodeResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("NodeId");
	form.appendf("  <tr><td><b>NodeId: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("NodeInfo");
	form.append("<tr>").append("<td><b>NodeInfo: </b></td><td><hr/>");
	CNodeInfoType::getHtmlForm(context, request, serv, method, form, false, extfix.str());
	form.append("<hr/></td></tr>");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Attributes");
	form.appendf("<tr><td><b>Attributes: </b></td><td>");
	form.appendf("<table><tr><td><textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea></td>", extfix.str());
	form.append("</tr></table>");
	form.append("</td></tr>");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Children");
	form.appendf("<tr><td><b>Children: </b></td><td>");
	form.appendf("<table><tr><td><textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea></td>", extfix.str());
	form.append("</tr></table>");
	form.append("</td></tr>");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Insertable");
	form.appendf("<tr><td><b>Insertable: </b></td><td>");
	form.appendf("<table><tr><td><textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea></td>", extfix.str());
	form.append("</tr></table>");
	form.append("</td></tr>");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Status");
	form.append("<tr>").append("<td><b>Status: </b></td><td><hr/>");
	CStatusType::getHtmlForm(context, request, serv, method, form, false, extfix.str());
	form.append("<hr/></td></tr>");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("LocalValueDefined");
	
	form.appendf("  <tr><td><b>LocalValueDefined? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Value");
	form.append("<tr>").append("<td><b>Value: </b></td><td><hr/>");
	CAttributeType::getHtmlForm(context, request, serv, method, form, false, extfix.str());
	form.append("<hr/></td></tr>");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CGetNodeResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CGetNodeResponse::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
		m_NodeId.marshall(rpc_resp, "NodeId", "", "", "");
		m_NodeInfo.marshall(rpc_resp, "NodeInfo", "", "", "");
		m_Attributes.marshall(rpc_resp, "Attributes", "Attribute");
		m_Children.marshall(rpc_resp, "Children", "Child");
		m_Insertable.marshall(rpc_resp, "Insertable", "Item");
		m_Status.marshall(rpc_resp, "Status", "", "", "");
		m_LocalValueDefined.marshall(rpc_resp, "LocalValueDefined", "", "", "");
		m_Value.marshall(rpc_resp, "Value", "", "", "");
	}
}


void CGetNodeResponse::copy(CGetNodeResponse &from)
{
	m_NodeId.copy(from.m_NodeId);
	m_NodeInfo.copy(from.m_NodeInfo);
	m_Attributes.copy(from.m_Attributes);
	m_Children.copy(from.m_Children);
	m_Insertable.copy(from.m_Insertable);
	m_Status.copy(from.m_Status);
	m_LocalValueDefined.copy(from.m_LocalValueDefined);
	m_Value.copy(from.m_Value);
}


void CGetNodeResponse::copy(IConstGetNodeResponse &ifrom)
{
	setNodeId(ifrom.getNodeId());
	setNodeInfo(ifrom.getNodeInfo());
	setAttributes(ifrom.getAttributes());
	setChildren(ifrom.getChildren());
	setInsertable(ifrom.getInsertable());
	setStatus(ifrom.getStatus());
	setLocalValueDefined(ifrom.getLocalValueDefined());
	setValue(ifrom.getValue());
}


void CGetNodeResponse::getAttributes(IProperties &attributes)
{
}


void CGetNodeResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
		m_NodeId.toStr(ctx, buffer, "NodeId", "", true, "", "");
		m_NodeInfo.toStr(ctx, buffer, "NodeInfo", "", false, "", "");
		m_Attributes.toStr(ctx, buffer, "Attributes", "Attribute");
		m_Children.toStr(ctx, buffer, "Children", "Child");
		m_Insertable.toStr(ctx, buffer, "Insertable", "Item");
		m_Status.toStr(ctx, buffer, "Status", "", false, "", "");
		m_LocalValueDefined.toStr(ctx, buffer, "LocalValueDefined", "", true, "", "");
		m_Value.toStr(ctx, buffer, "Value", "", false, "", "");
	}
}


void CGetNodeResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CGetNodeResponse::serializer(IEspContext* ctx, IConstGetNodeResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<GetNodeResponse>");
	// field NodeId
	{
		const char* s = src.getNodeId();
		if (s && *s)
		{
			buffer.append("<NodeId>");
			encodeUtf8XML(s,buffer);
			buffer.append("</NodeId>");
		}
	}
	// field NodeInfo
	{
		StringBuffer tmp;
		CNodeInfoType::serializer(ctx,src.getNodeInfo(), tmp, false);
		if (tmp.length()>0)
			buffer.appendf("<NodeInfo>%s</NodeInfo>",tmp.str());
	}
	// field Attributes
	{
		IArrayOf<IConstAttributeType>& v = src.getAttributes();
		int size = v.length();
		if (size>0)
			buffer.append("<Attributes>");
		for (int i=0;i<size;i++)
		{
			buffer.append("<Attribute>");
			CAttributeType::serializer(ctx,v.item(i),buffer,false);
			buffer.append("</Attribute>");
		}
		if (size>0)
			buffer.append("</Attributes>");
	}
	// field Children
	{
		IArrayOf<IConstNode>& v = src.getChildren();
		int size = v.length();
		if (size>0)
			buffer.append("<Children>");
		for (int i=0;i<size;i++)
		{
			buffer.append("<Child>");
			CNode::serializer(ctx,v.item(i),buffer,false);
			buffer.append("</Child>");
		}
		if (size>0)
			buffer.append("</Children>");
	}
	// field Insertable
	{
		IArrayOf<IConstInsertItemType>& v = src.getInsertable();
		int size = v.length();
		if (size>0)
			buffer.append("<Insertable>");
		for (int i=0;i<size;i++)
		{
			buffer.append("<Item>");
			CInsertItemType::serializer(ctx,v.item(i),buffer,false);
			buffer.append("</Item>");
		}
		if (size>0)
			buffer.append("</Insertable>");
	}
	// field Status
	{
		StringBuffer tmp;
		CStatusType::serializer(ctx,src.getStatus(), tmp, false);
		if (tmp.length()>0)
			buffer.appendf("<Status>%s</Status>",tmp.str());
	}
	// field LocalValueDefined
	{
		bool b = src.getLocalValueDefined();
		if (b)
			buffer.appendf("<LocalValueDefined>1</LocalValueDefined>");
	}
	// field Value
	{
		StringBuffer tmp;
		CAttributeType::serializer(ctx,src.getValue(), tmp, false);
		if (tmp.length()>0)
			buffer.appendf("<Value>%s</Value>",tmp.str());
	}
	if (keepRootTag)
		buffer.append("</GetNodeResponse>");
}

bool CGetNodeResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
		hasValue |= m_NodeId.unmarshall(rpc_request, "NodeId", basepath);
		hasValue |= m_NodeInfo.unmarshall(rpc_request, "NodeInfo", basepath);
		hasValue |= m_Attributes.unmarshall(rpc_request, "Attributes", basepath);
		hasValue |= m_Children.unmarshall(rpc_request, "Children", basepath);
		hasValue |= m_Insertable.unmarshall(rpc_request, "Insertable", basepath);
		hasValue |= m_Status.unmarshall(rpc_request, "Status", basepath);
		hasValue |= m_LocalValueDefined.unmarshall(rpc_request, "LocalValueDefined", basepath);
		hasValue |= m_Value.unmarshall(rpc_request, "Value", basepath);
	}
	return hasValue;
}

bool CGetNodeResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_NodeId.unmarshall(ctx, soapval, "NodeId");
	hasValue |= m_NodeInfo.unmarshall(ctx, soapval, "NodeInfo");
	hasValue |= m_Attributes.unmarshall(ctx, soapval, "Attributes");
	hasValue |= m_Children.unmarshall(ctx, soapval, "Children");
	hasValue |= m_Insertable.unmarshall(ctx, soapval, "Insertable");
	hasValue |= m_Status.unmarshall(ctx, soapval, "Status");
	hasValue |= m_LocalValueDefined.unmarshall(ctx, soapval, "LocalValueDefined");
	hasValue |= m_Value.unmarshall(ctx, soapval, "Value");
	return hasValue;
}

bool CGetNodeResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_NodeId.unmarshall(ctx, params, attachments, "NodeId", basepath);
	hasValue |= m_NodeInfo.unmarshall(ctx, params, attachments, "NodeInfo", basepath);
	hasValue |= m_Attributes.unmarshall(ctx, params, attachments, "Attributes", basepath);
	hasValue |= m_Children.unmarshall(ctx, params, attachments, "Children", basepath);
	hasValue |= m_Insertable.unmarshall(ctx, params, attachments, "Insertable", basepath);
	hasValue |= m_Status.unmarshall(ctx, params, attachments, "Status", basepath);
	hasValue |= m_LocalValueDefined.unmarshall(ctx, params, attachments, "LocalValueDefined", basepath);
	hasValue |= m_Value.unmarshall(ctx, params, attachments, "Value", basepath);
	return hasValue;
}

const char * CGetNodeResponse::getNodeId() { return m_NodeId.query();}
IConstNodeInfoType & CGetNodeResponse::getNodeInfo() { return (IConstNodeInfoType &) m_NodeInfo.getValue();}
IArrayOf<IConstAttributeType> & CGetNodeResponse::getAttributes() { return (IArrayOf<IConstAttributeType> &) m_Attributes; }
IArrayOf<IConstNode> & CGetNodeResponse::getChildren() { return (IArrayOf<IConstNode> &) m_Children; }
IArrayOf<IConstInsertItemType> & CGetNodeResponse::getInsertable() { return (IArrayOf<IConstInsertItemType> &) m_Insertable; }
IConstStatusType & CGetNodeResponse::getStatus() { return (IConstStatusType &) m_Status.getValue();}
bool CGetNodeResponse::getLocalValueDefined() { return m_LocalValueDefined;}
IConstAttributeType & CGetNodeResponse::getValue() { return (IConstAttributeType &) m_Value.getValue();}
void CGetNodeResponse::setNodeId(const char * val){ m_NodeId.set(val); }
IEspNodeInfoType & CGetNodeResponse::updateNodeInfo(){ return (IEspNodeInfoType &) m_NodeInfo.getValue(); }
void CGetNodeResponse::setNodeInfo(IConstNodeInfoType &ifrom){ m_NodeInfo.copy(ifrom); }
void CGetNodeResponse::setAttributes(IArrayOf<IEspAttributeType> &val)
{
	m_Attributes->kill();
	IArrayOf<IConstAttributeType> &target = m_Attributes.getValue();
	ForEachItemIn(idx, val)
	{
		IEspAttributeType &item = (val).item(idx);
		item.Link();
		target.append(item);
	}
}
void CGetNodeResponse::setAttributes(IArrayOf<IConstAttributeType> &val)
{
	m_Attributes->kill();
	IArrayOf<IConstAttributeType> &target = m_Attributes.getValue();
	ForEachItemIn(idx, val)
	{
		IConstAttributeType &item = val.item(idx);
		item.Link();
		target.append(item);
	}
}
void CGetNodeResponse::setChildren(IArrayOf<IEspNode> &val)
{
	m_Children->kill();
	IArrayOf<IConstNode> &target = m_Children.getValue();
	ForEachItemIn(idx, val)
	{
		IEspNode &item = (val).item(idx);
		item.Link();
		target.append(item);
	}
}
void CGetNodeResponse::setChildren(IArrayOf<IConstNode> &val)
{
	m_Children->kill();
	IArrayOf<IConstNode> &target = m_Children.getValue();
	ForEachItemIn(idx, val)
	{
		IConstNode &item = val.item(idx);
		item.Link();
		target.append(item);
	}
}
void CGetNodeResponse::setInsertable(IArrayOf<IEspInsertItemType> &val)
{
	m_Insertable->kill();
	IArrayOf<IConstInsertItemType> &target = m_Insertable.getValue();
	ForEachItemIn(idx, val)
	{
		IEspInsertItemType &item = (val).item(idx);
		item.Link();
		target.append(item);
	}
}
void CGetNodeResponse::setInsertable(IArrayOf<IConstInsertItemType> &val)
{
	m_Insertable->kill();
	IArrayOf<IConstInsertItemType> &target = m_Insertable.getValue();
	ForEachItemIn(idx, val)
	{
		IConstInsertItemType &item = val.item(idx);
		item.Link();
		target.append(item);
	}
}
IEspStatusType & CGetNodeResponse::updateStatus(){ return (IEspStatusType &) m_Status.getValue(); }
void CGetNodeResponse::setStatus(IConstStatusType &ifrom){ m_Status.copy(ifrom); }
void CGetNodeResponse::setLocalValueDefined(bool val){ m_LocalValueDefined=val; }
IEspAttributeType & CGetNodeResponse::updateValue(){ return (IEspAttributeType &) m_Value.getValue(); }
void CGetNodeResponse::setValue(IConstAttributeType &ifrom){ m_Value.copy(ifrom); }
extern "C"  IEspGetNodeResponse *createGetNodeResponse(const char *serv){return ((IEspGetNodeResponse *)new CGetNodeResponse(serv));}
extern "C"  IClientGetNodeResponse *createClientGetNodeResponse(const char *serv){return ((IClientGetNodeResponse *)new CGetNodeResponse(serv));}

//=======================================================
// class CInsertNodeRequest Implementation
//=======================================================

CInsertNodeRequest::CInsertNodeRequest(const char *serviceName, IRpcMessageBinding *init)
	: m_SessionId(nilIgnore),m_SessionLockKey(nilIgnore),m_ParentNodeId(nilIgnore),m_NodeType(nilIgnore),m_AttributeValues(nilIgnore),m_AllowInvalid(0, nilIgnore,false),m_ForceCreate(0, nilIgnore,false),m_LocalValue("", nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("InsertNodeRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CInsertNodeRequest::CInsertNodeRequest(const char *serviceName, const char *bc)
	: m_SessionId(nilIgnore),m_SessionLockKey(nilIgnore),m_ParentNodeId(nilIgnore),m_NodeType(nilIgnore),m_AttributeValues(nilIgnore),m_AllowInvalid(0, nilIgnore,false),m_ForceCreate(0, nilIgnore,false),m_LocalValue("", nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("InsertNodeRequest");
}

CInsertNodeRequest::CInsertNodeRequest(const char *serviceName, IRpcMessage* rpcmsg)
	: m_SessionId(nilIgnore),m_SessionLockKey(nilIgnore),m_ParentNodeId(nilIgnore),m_NodeType(nilIgnore),m_AttributeValues(nilIgnore),m_AllowInvalid(0, nilIgnore,false),m_ForceCreate(0, nilIgnore,false),m_LocalValue("", nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("InsertNodeRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CInsertNodeRequest::CInsertNodeRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_SessionId(nilIgnore),m_SessionLockKey(nilIgnore),m_ParentNodeId(nilIgnore),m_NodeType(nilIgnore),m_AttributeValues(nilIgnore),m_AllowInvalid(0, nilIgnore,false),m_ForceCreate(0, nilIgnore,false),m_LocalValue("", nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("InsertNodeRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CInsertNodeRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"SessionId\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"SessionLockKey\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"ParentNodeId\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"NodeType\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"AttributeValues\">\n");
		schema.append("<xsd:complexType><xsd:sequence>\n");
		schema.append("<xsd:element minOccurs=\"0\" maxOccurs=\"unbounded\" name=\"Attribute\" type=\"tns:AttributeValueType\"/>");
		schema.append("</xsd:sequence></xsd:complexType>");
		schema.append("</xsd:element>");
		schema.append("<xsd:element minOccurs=\"0\" default=\"false\" name=\"AllowInvalid\" type=\"xsd:boolean\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" default=\"false\" name=\"ForceCreate\" type=\"xsd:boolean\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" default=\"\" name=\"LocalValue\" type=\"xsd:string\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	if (!(flags & 0x10)  || (flags & 0x100))
	{
		CAttributeValueType::getXsdDefinition(context, request, schema, added);
	}
	return schema;
}

void CInsertNodeRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CInsertNodeRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
	if (!added.getValue("AttributeValueType"))
	{
		added.setValue("AttributeValueType",1);
		CAttributeValueType::getMapInfo(info,added);
	}
}

StringBuffer &CInsertNodeRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("SessionId");
	form.appendf("  <tr><td><b>SessionId: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("SessionLockKey");
	form.appendf("  <tr><td><b>SessionLockKey: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("ParentNodeId");
	form.appendf("  <tr><td><b>ParentNodeId: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("NodeType");
	form.appendf("  <tr><td><b>NodeType: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("AttributeValues");
	form.appendf("<tr><td><b>AttributeValues: </b></td><td>");
	form.appendf("<table><tr><td><textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea></td>", extfix.str());
	form.append("</tr></table>");
	form.append("</td></tr>");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("AllowInvalid");
	
	form.appendf("  <tr><td><b>AllowInvalid? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("ForceCreate");
	
	form.appendf("  <tr><td><b>ForceCreate? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("LocalValue");
	form.appendf("  <tr><td><b>LocalValue: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CInsertNodeRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CInsertNodeRequest::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_SessionId.marshall(rpc_resp, "SessionId", "", "", "");
	m_SessionLockKey.marshall(rpc_resp, "SessionLockKey", "", "", "");
	m_ParentNodeId.marshall(rpc_resp, "ParentNodeId", "", "", "");
	m_NodeType.marshall(rpc_resp, "NodeType", "", "", "");
	m_AttributeValues.marshall(rpc_resp, "AttributeValues", "Attribute");
	m_AllowInvalid.marshall(rpc_resp, "AllowInvalid", "", "", "");
	m_ForceCreate.marshall(rpc_resp, "ForceCreate", "", "", "");
	m_LocalValue.marshall(rpc_resp, "LocalValue", "", "", "");
}


void CInsertNodeRequest::copy(CInsertNodeRequest &from)
{
	m_SessionId.copy(from.m_SessionId);
	m_SessionLockKey.copy(from.m_SessionLockKey);
	m_ParentNodeId.copy(from.m_ParentNodeId);
	m_NodeType.copy(from.m_NodeType);
	m_AttributeValues.copy(from.m_AttributeValues);
	m_AllowInvalid.copy(from.m_AllowInvalid);
	m_ForceCreate.copy(from.m_ForceCreate);
	m_LocalValue.copy(from.m_LocalValue);
}


void CInsertNodeRequest::copy(IConstInsertNodeRequest &ifrom)
{
	setSessionId(ifrom.getSessionId());
	setSessionLockKey(ifrom.getSessionLockKey());
	setParentNodeId(ifrom.getParentNodeId());
	setNodeType(ifrom.getNodeType());
	setAttributeValues(ifrom.getAttributeValues());
	setAllowInvalid(ifrom.getAllowInvalid());
	setForceCreate(ifrom.getForceCreate());
	setLocalValue(ifrom.getLocalValue());
}


void CInsertNodeRequest::getAttributes(IProperties &attributes)
{
}


void CInsertNodeRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_SessionId.toStr(ctx, buffer, "SessionId", "", true, "", "");
	m_SessionLockKey.toStr(ctx, buffer, "SessionLockKey", "", true, "", "");
	m_ParentNodeId.toStr(ctx, buffer, "ParentNodeId", "", true, "", "");
	m_NodeType.toStr(ctx, buffer, "NodeType", "", true, "", "");
	m_AttributeValues.toStr(ctx, buffer, "AttributeValues", "Attribute");
	m_AllowInvalid.toStr(ctx, buffer, "AllowInvalid", "", true, "", "");
	m_ForceCreate.toStr(ctx, buffer, "ForceCreate", "", true, "", "");
	m_LocalValue.toStr(ctx, buffer, "LocalValue", "", true, "", "");
}


void CInsertNodeRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CInsertNodeRequest::serializer(IEspContext* ctx, IConstInsertNodeRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<InsertNodeRequest>");
	// field SessionId
	{
		const char* s = src.getSessionId();
		if (s && *s)
		{
			buffer.append("<SessionId>");
			encodeUtf8XML(s,buffer);
			buffer.append("</SessionId>");
		}
	}
	// field SessionLockKey
	{
		const char* s = src.getSessionLockKey();
		if (s && *s)
		{
			buffer.append("<SessionLockKey>");
			encodeUtf8XML(s,buffer);
			buffer.append("</SessionLockKey>");
		}
	}
	// field ParentNodeId
	{
		const char* s = src.getParentNodeId();
		if (s && *s)
		{
			buffer.append("<ParentNodeId>");
			encodeUtf8XML(s,buffer);
			buffer.append("</ParentNodeId>");
		}
	}
	// field NodeType
	{
		const char* s = src.getNodeType();
		if (s && *s)
		{
			buffer.append("<NodeType>");
			encodeUtf8XML(s,buffer);
			buffer.append("</NodeType>");
		}
	}
	// field AttributeValues
	{
		IArrayOf<IConstAttributeValueType>& v = src.getAttributeValues();
		int size = v.length();
		if (size>0)
			buffer.append("<AttributeValues>");
		for (int i=0;i<size;i++)
		{
			buffer.append("<Attribute>");
			CAttributeValueType::serializer(ctx,v.item(i),buffer,false);
			buffer.append("</Attribute>");
		}
		if (size>0)
			buffer.append("</AttributeValues>");
	}
	// field AllowInvalid
	{
		bool b = src.getAllowInvalid();
		if (b)
			buffer.appendf("<AllowInvalid>1</AllowInvalid>");
	}
	// field ForceCreate
	{
		bool b = src.getForceCreate();
		if (b)
			buffer.appendf("<ForceCreate>1</ForceCreate>");
	}
	// field LocalValue
	{
		const char* s = src.getLocalValue();
		if (s && *s)
		{
			buffer.append("<LocalValue>");
			encodeUtf8XML(s,buffer);
			buffer.append("</LocalValue>");
		}
	}
	if (keepRootTag)
		buffer.append("</InsertNodeRequest>");
}

bool CInsertNodeRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_SessionId.unmarshall(rpc_request, "SessionId", basepath);
	hasValue |= m_SessionLockKey.unmarshall(rpc_request, "SessionLockKey", basepath);
	hasValue |= m_ParentNodeId.unmarshall(rpc_request, "ParentNodeId", basepath);
	hasValue |= m_NodeType.unmarshall(rpc_request, "NodeType", basepath);
	hasValue |= m_AttributeValues.unmarshall(rpc_request, "AttributeValues", basepath);
	hasValue |= m_AllowInvalid.unmarshall(rpc_request, "AllowInvalid", basepath);
	hasValue |= m_ForceCreate.unmarshall(rpc_request, "ForceCreate", basepath);
	hasValue |= m_LocalValue.unmarshall(rpc_request, "LocalValue", basepath);
	return hasValue;
}

bool CInsertNodeRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_SessionId.unmarshall(ctx, soapval, "SessionId");
	hasValue |= m_SessionLockKey.unmarshall(ctx, soapval, "SessionLockKey");
	hasValue |= m_ParentNodeId.unmarshall(ctx, soapval, "ParentNodeId");
	hasValue |= m_NodeType.unmarshall(ctx, soapval, "NodeType");
	hasValue |= m_AttributeValues.unmarshall(ctx, soapval, "AttributeValues");
	hasValue |= m_AllowInvalid.unmarshall(ctx, soapval, "AllowInvalid");
	hasValue |= m_ForceCreate.unmarshall(ctx, soapval, "ForceCreate");
	hasValue |= m_LocalValue.unmarshall(ctx, soapval, "LocalValue");
	return hasValue;
}

bool CInsertNodeRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_SessionId.unmarshall(ctx, params, attachments, "SessionId", basepath);
	hasValue |= m_SessionLockKey.unmarshall(ctx, params, attachments, "SessionLockKey", basepath);
	hasValue |= m_ParentNodeId.unmarshall(ctx, params, attachments, "ParentNodeId", basepath);
	hasValue |= m_NodeType.unmarshall(ctx, params, attachments, "NodeType", basepath);
	hasValue |= m_AttributeValues.unmarshall(ctx, params, attachments, "AttributeValues", basepath);
	hasValue |= m_AllowInvalid.unmarshall(ctx, params, attachments, "AllowInvalid", basepath);
	hasValue |= m_ForceCreate.unmarshall(ctx, params, attachments, "ForceCreate", basepath);
	hasValue |= m_LocalValue.unmarshall(ctx, params, attachments, "LocalValue", basepath);
	return hasValue;
}

const char * CInsertNodeRequest::getSessionId() { return m_SessionId.query();}
const char * CInsertNodeRequest::getSessionLockKey() { return m_SessionLockKey.query();}
const char * CInsertNodeRequest::getParentNodeId() { return m_ParentNodeId.query();}
const char * CInsertNodeRequest::getNodeType() { return m_NodeType.query();}
IArrayOf<IConstAttributeValueType> & CInsertNodeRequest::getAttributeValues() { return (IArrayOf<IConstAttributeValueType> &) m_AttributeValues; }
bool CInsertNodeRequest::getAllowInvalid() { return m_AllowInvalid;}
bool CInsertNodeRequest::getForceCreate() { return m_ForceCreate;}
const char * CInsertNodeRequest::getLocalValue() { return m_LocalValue.query();}
void CInsertNodeRequest::setSessionId(const char * val){ m_SessionId.set(val); }
void CInsertNodeRequest::setSessionLockKey(const char * val){ m_SessionLockKey.set(val); }
void CInsertNodeRequest::setParentNodeId(const char * val){ m_ParentNodeId.set(val); }
void CInsertNodeRequest::setNodeType(const char * val){ m_NodeType.set(val); }
void CInsertNodeRequest::setAttributeValues(IArrayOf<IEspAttributeValueType> &val)
{
	m_AttributeValues->kill();
	IArrayOf<IConstAttributeValueType> &target = m_AttributeValues.getValue();
	ForEachItemIn(idx, val)
	{
		IEspAttributeValueType &item = (val).item(idx);
		item.Link();
		target.append(item);
	}
}
void CInsertNodeRequest::setAttributeValues(IArrayOf<IConstAttributeValueType> &val)
{
	m_AttributeValues->kill();
	IArrayOf<IConstAttributeValueType> &target = m_AttributeValues.getValue();
	ForEachItemIn(idx, val)
	{
		IConstAttributeValueType &item = val.item(idx);
		item.Link();
		target.append(item);
	}
}
void CInsertNodeRequest::setAllowInvalid(bool val){ m_AllowInvalid=val; }
void CInsertNodeRequest::setForceCreate(bool val){ m_ForceCreate=val; }
void CInsertNodeRequest::setLocalValue(const char * val){ m_LocalValue.set(val); }
extern "C"  IEspInsertNodeRequest *createInsertNodeRequest(const char *serv){return ((IEspInsertNodeRequest *)new CInsertNodeRequest(serv));}
extern "C"  IClientInsertNodeRequest *createClientInsertNodeRequest(const char *serv){return ((IClientInsertNodeRequest *)new CInsertNodeRequest(serv));}

//=======================================================
// class CGetCreateNodeInfoRequest Implementation
//=======================================================

CGetCreateNodeInfoRequest::CGetCreateNodeInfoRequest(const char *serviceName, IRpcMessageBinding *init)
	: m_SessionId(nilIgnore),m_ParentNodeId(nilIgnore),m_NodeType(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetCreateNodeInfoRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CGetCreateNodeInfoRequest::CGetCreateNodeInfoRequest(const char *serviceName, const char *bc)
	: m_SessionId(nilIgnore),m_ParentNodeId(nilIgnore),m_NodeType(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetCreateNodeInfoRequest");
}

CGetCreateNodeInfoRequest::CGetCreateNodeInfoRequest(const char *serviceName, IRpcMessage* rpcmsg)
	: m_SessionId(nilIgnore),m_ParentNodeId(nilIgnore),m_NodeType(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetCreateNodeInfoRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CGetCreateNodeInfoRequest::CGetCreateNodeInfoRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_SessionId(nilIgnore),m_ParentNodeId(nilIgnore),m_NodeType(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetCreateNodeInfoRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CGetCreateNodeInfoRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"SessionId\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"ParentNodeId\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"NodeType\" type=\"xsd:string\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CGetCreateNodeInfoRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CGetCreateNodeInfoRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CGetCreateNodeInfoRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("SessionId");
	form.appendf("  <tr><td><b>SessionId: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("ParentNodeId");
	form.appendf("  <tr><td><b>ParentNodeId: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("NodeType");
	form.appendf("  <tr><td><b>NodeType: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CGetCreateNodeInfoRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CGetCreateNodeInfoRequest::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_SessionId.marshall(rpc_resp, "SessionId", "", "", "");
	m_ParentNodeId.marshall(rpc_resp, "ParentNodeId", "", "", "");
	m_NodeType.marshall(rpc_resp, "NodeType", "", "", "");
}


void CGetCreateNodeInfoRequest::copy(CGetCreateNodeInfoRequest &from)
{
	m_SessionId.copy(from.m_SessionId);
	m_ParentNodeId.copy(from.m_ParentNodeId);
	m_NodeType.copy(from.m_NodeType);
}


void CGetCreateNodeInfoRequest::copy(IConstGetCreateNodeInfoRequest &ifrom)
{
	setSessionId(ifrom.getSessionId());
	setParentNodeId(ifrom.getParentNodeId());
	setNodeType(ifrom.getNodeType());
}


void CGetCreateNodeInfoRequest::getAttributes(IProperties &attributes)
{
}


void CGetCreateNodeInfoRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_SessionId.toStr(ctx, buffer, "SessionId", "", true, "", "");
	m_ParentNodeId.toStr(ctx, buffer, "ParentNodeId", "", true, "", "");
	m_NodeType.toStr(ctx, buffer, "NodeType", "", true, "", "");
}


void CGetCreateNodeInfoRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CGetCreateNodeInfoRequest::serializer(IEspContext* ctx, IConstGetCreateNodeInfoRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<GetCreateNodeInfoRequest>");
	// field SessionId
	{
		const char* s = src.getSessionId();
		if (s && *s)
		{
			buffer.append("<SessionId>");
			encodeUtf8XML(s,buffer);
			buffer.append("</SessionId>");
		}
	}
	// field ParentNodeId
	{
		const char* s = src.getParentNodeId();
		if (s && *s)
		{
			buffer.append("<ParentNodeId>");
			encodeUtf8XML(s,buffer);
			buffer.append("</ParentNodeId>");
		}
	}
	// field NodeType
	{
		const char* s = src.getNodeType();
		if (s && *s)
		{
			buffer.append("<NodeType>");
			encodeUtf8XML(s,buffer);
			buffer.append("</NodeType>");
		}
	}
	if (keepRootTag)
		buffer.append("</GetCreateNodeInfoRequest>");
}

bool CGetCreateNodeInfoRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_SessionId.unmarshall(rpc_request, "SessionId", basepath);
	hasValue |= m_ParentNodeId.unmarshall(rpc_request, "ParentNodeId", basepath);
	hasValue |= m_NodeType.unmarshall(rpc_request, "NodeType", basepath);
	return hasValue;
}

bool CGetCreateNodeInfoRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_SessionId.unmarshall(ctx, soapval, "SessionId");
	hasValue |= m_ParentNodeId.unmarshall(ctx, soapval, "ParentNodeId");
	hasValue |= m_NodeType.unmarshall(ctx, soapval, "NodeType");
	return hasValue;
}

bool CGetCreateNodeInfoRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_SessionId.unmarshall(ctx, params, attachments, "SessionId", basepath);
	hasValue |= m_ParentNodeId.unmarshall(ctx, params, attachments, "ParentNodeId", basepath);
	hasValue |= m_NodeType.unmarshall(ctx, params, attachments, "NodeType", basepath);
	return hasValue;
}

const char * CGetCreateNodeInfoRequest::getSessionId() { return m_SessionId.query();}
const char * CGetCreateNodeInfoRequest::getParentNodeId() { return m_ParentNodeId.query();}
const char * CGetCreateNodeInfoRequest::getNodeType() { return m_NodeType.query();}
void CGetCreateNodeInfoRequest::setSessionId(const char * val){ m_SessionId.set(val); }
void CGetCreateNodeInfoRequest::setParentNodeId(const char * val){ m_ParentNodeId.set(val); }
void CGetCreateNodeInfoRequest::setNodeType(const char * val){ m_NodeType.set(val); }
extern "C"  IEspGetCreateNodeInfoRequest *createGetCreateNodeInfoRequest(const char *serv){return ((IEspGetCreateNodeInfoRequest *)new CGetCreateNodeInfoRequest(serv));}
extern "C"  IClientGetCreateNodeInfoRequest *createClientGetCreateNodeInfoRequest(const char *serv){return ((IClientGetCreateNodeInfoRequest *)new CGetCreateNodeInfoRequest(serv));}

//=======================================================
// class CGetCreateNodeInfoResponse Implementation
//=======================================================

CGetCreateNodeInfoResponse::CGetCreateNodeInfoResponse(const char *serviceName, IRpcMessageBinding *init)
	: m_NodeInfo(serviceName, nilIgnore),m_Attributes(nilIgnore),m_LocalValueDefined(0, nilIgnore,false),m_Value(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetCreateNodeInfoResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CGetCreateNodeInfoResponse::CGetCreateNodeInfoResponse(const char *serviceName, const char *bc)
	: m_NodeInfo(serviceName, nilIgnore),m_Attributes(nilIgnore),m_LocalValueDefined(0, nilIgnore,false),m_Value(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetCreateNodeInfoResponse");
}

CGetCreateNodeInfoResponse::CGetCreateNodeInfoResponse(const char *serviceName, IRpcMessage* rpcmsg)
	: m_NodeInfo(serviceName, nilIgnore),m_Attributes(nilIgnore),m_LocalValueDefined(0, nilIgnore,false),m_Value(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetCreateNodeInfoResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CGetCreateNodeInfoResponse::CGetCreateNodeInfoResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_NodeInfo(serviceName, nilIgnore),m_Attributes(nilIgnore),m_LocalValueDefined(0, nilIgnore,false),m_Value(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetCreateNodeInfoResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CGetCreateNodeInfoResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		schema.append("<xsd:element name=\"Exceptions\" type=\"tns:ArrayOfEspException\" minOccurs=\"0\" maxOccurs=\"1\"/>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"NodeInfo\" type=\"tns:NodeInfoType\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Attributes\">\n");
		schema.append("<xsd:complexType><xsd:sequence>\n");
		schema.append("<xsd:element minOccurs=\"0\" maxOccurs=\"unbounded\" name=\"Attribute\" type=\"tns:AttributeType\"/>");
		schema.append("</xsd:sequence></xsd:complexType>");
		schema.append("</xsd:element>");
		schema.append("<xsd:element minOccurs=\"0\" default=\"false\" name=\"LocalValueDefined\" type=\"xsd:boolean\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Value\" type=\"tns:AttributeType\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	if (!(flags & 0x10)  || (flags & 0x100))
	{
		CNodeInfoType::getXsdDefinition(context, request, schema, added);
		CAttributeType::getXsdDefinition(context, request, schema, added);
	}
	return schema;
}

void CGetCreateNodeInfoResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CGetCreateNodeInfoResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
	if (!added.getValue("AttributeType"))
	{
		added.setValue("AttributeType",1);
		CAttributeType::getMapInfo(info,added);
	}
	if (!added.getValue("NodeInfoType"))
	{
		added.setValue("NodeInfoType",1);
		CNodeInfoType::getMapInfo(info,added);
	}
}

StringBuffer &CGetCreateNodeInfoResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("NodeInfo");
	form.append("<tr>").append("<td><b>NodeInfo: </b></td><td><hr/>");
	CNodeInfoType::getHtmlForm(context, request, serv, method, form, false, extfix.str());
	form.append("<hr/></td></tr>");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Attributes");
	form.appendf("<tr><td><b>Attributes: </b></td><td>");
	form.appendf("<table><tr><td><textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea></td>", extfix.str());
	form.append("</tr></table>");
	form.append("</td></tr>");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("LocalValueDefined");
	
	form.appendf("  <tr><td><b>LocalValueDefined? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Value");
	form.append("<tr>").append("<td><b>Value: </b></td><td><hr/>");
	CAttributeType::getHtmlForm(context, request, serv, method, form, false, extfix.str());
	form.append("<hr/></td></tr>");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CGetCreateNodeInfoResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CGetCreateNodeInfoResponse::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
		m_NodeInfo.marshall(rpc_resp, "NodeInfo", "", "", "");
		m_Attributes.marshall(rpc_resp, "Attributes", "Attribute");
		m_LocalValueDefined.marshall(rpc_resp, "LocalValueDefined", "", "", "");
		m_Value.marshall(rpc_resp, "Value", "", "", "");
	}
}


void CGetCreateNodeInfoResponse::copy(CGetCreateNodeInfoResponse &from)
{
	m_NodeInfo.copy(from.m_NodeInfo);
	m_Attributes.copy(from.m_Attributes);
	m_LocalValueDefined.copy(from.m_LocalValueDefined);
	m_Value.copy(from.m_Value);
}


void CGetCreateNodeInfoResponse::copy(IConstGetCreateNodeInfoResponse &ifrom)
{
	setNodeInfo(ifrom.getNodeInfo());
	setAttributes(ifrom.getAttributes());
	setLocalValueDefined(ifrom.getLocalValueDefined());
	setValue(ifrom.getValue());
}


void CGetCreateNodeInfoResponse::getAttributes(IProperties &attributes)
{
}


void CGetCreateNodeInfoResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
		m_NodeInfo.toStr(ctx, buffer, "NodeInfo", "", false, "", "");
		m_Attributes.toStr(ctx, buffer, "Attributes", "Attribute");
		m_LocalValueDefined.toStr(ctx, buffer, "LocalValueDefined", "", true, "", "");
		m_Value.toStr(ctx, buffer, "Value", "", false, "", "");
	}
}


void CGetCreateNodeInfoResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CGetCreateNodeInfoResponse::serializer(IEspContext* ctx, IConstGetCreateNodeInfoResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<GetCreateNodeInfoResponse>");
	// field NodeInfo
	{
		StringBuffer tmp;
		CNodeInfoType::serializer(ctx,src.getNodeInfo(), tmp, false);
		if (tmp.length()>0)
			buffer.appendf("<NodeInfo>%s</NodeInfo>",tmp.str());
	}
	// field Attributes
	{
		IArrayOf<IConstAttributeType>& v = src.getAttributes();
		int size = v.length();
		if (size>0)
			buffer.append("<Attributes>");
		for (int i=0;i<size;i++)
		{
			buffer.append("<Attribute>");
			CAttributeType::serializer(ctx,v.item(i),buffer,false);
			buffer.append("</Attribute>");
		}
		if (size>0)
			buffer.append("</Attributes>");
	}
	// field LocalValueDefined
	{
		bool b = src.getLocalValueDefined();
		if (b)
			buffer.appendf("<LocalValueDefined>1</LocalValueDefined>");
	}
	// field Value
	{
		StringBuffer tmp;
		CAttributeType::serializer(ctx,src.getValue(), tmp, false);
		if (tmp.length()>0)
			buffer.appendf("<Value>%s</Value>",tmp.str());
	}
	if (keepRootTag)
		buffer.append("</GetCreateNodeInfoResponse>");
}

bool CGetCreateNodeInfoResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
		hasValue |= m_NodeInfo.unmarshall(rpc_request, "NodeInfo", basepath);
		hasValue |= m_Attributes.unmarshall(rpc_request, "Attributes", basepath);
		hasValue |= m_LocalValueDefined.unmarshall(rpc_request, "LocalValueDefined", basepath);
		hasValue |= m_Value.unmarshall(rpc_request, "Value", basepath);
	}
	return hasValue;
}

bool CGetCreateNodeInfoResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_NodeInfo.unmarshall(ctx, soapval, "NodeInfo");
	hasValue |= m_Attributes.unmarshall(ctx, soapval, "Attributes");
	hasValue |= m_LocalValueDefined.unmarshall(ctx, soapval, "LocalValueDefined");
	hasValue |= m_Value.unmarshall(ctx, soapval, "Value");
	return hasValue;
}

bool CGetCreateNodeInfoResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_NodeInfo.unmarshall(ctx, params, attachments, "NodeInfo", basepath);
	hasValue |= m_Attributes.unmarshall(ctx, params, attachments, "Attributes", basepath);
	hasValue |= m_LocalValueDefined.unmarshall(ctx, params, attachments, "LocalValueDefined", basepath);
	hasValue |= m_Value.unmarshall(ctx, params, attachments, "Value", basepath);
	return hasValue;
}

IConstNodeInfoType & CGetCreateNodeInfoResponse::getNodeInfo() { return (IConstNodeInfoType &) m_NodeInfo.getValue();}
IArrayOf<IConstAttributeType> & CGetCreateNodeInfoResponse::getAttributes() { return (IArrayOf<IConstAttributeType> &) m_Attributes; }
bool CGetCreateNodeInfoResponse::getLocalValueDefined() { return m_LocalValueDefined;}
IConstAttributeType & CGetCreateNodeInfoResponse::getValue() { return (IConstAttributeType &) m_Value.getValue();}
IEspNodeInfoType & CGetCreateNodeInfoResponse::updateNodeInfo(){ return (IEspNodeInfoType &) m_NodeInfo.getValue(); }
void CGetCreateNodeInfoResponse::setNodeInfo(IConstNodeInfoType &ifrom){ m_NodeInfo.copy(ifrom); }
void CGetCreateNodeInfoResponse::setAttributes(IArrayOf<IEspAttributeType> &val)
{
	m_Attributes->kill();
	IArrayOf<IConstAttributeType> &target = m_Attributes.getValue();
	ForEachItemIn(idx, val)
	{
		IEspAttributeType &item = (val).item(idx);
		item.Link();
		target.append(item);
	}
}
void CGetCreateNodeInfoResponse::setAttributes(IArrayOf<IConstAttributeType> &val)
{
	m_Attributes->kill();
	IArrayOf<IConstAttributeType> &target = m_Attributes.getValue();
	ForEachItemIn(idx, val)
	{
		IConstAttributeType &item = val.item(idx);
		item.Link();
		target.append(item);
	}
}
void CGetCreateNodeInfoResponse::setLocalValueDefined(bool val){ m_LocalValueDefined=val; }
IEspAttributeType & CGetCreateNodeInfoResponse::updateValue(){ return (IEspAttributeType &) m_Value.getValue(); }
void CGetCreateNodeInfoResponse::setValue(IConstAttributeType &ifrom){ m_Value.copy(ifrom); }
extern "C"  IEspGetCreateNodeInfoResponse *createGetCreateNodeInfoResponse(const char *serv){return ((IEspGetCreateNodeInfoResponse *)new CGetCreateNodeInfoResponse(serv));}
extern "C"  IClientGetCreateNodeInfoResponse *createClientGetCreateNodeInfoResponse(const char *serv){return ((IClientGetCreateNodeInfoResponse *)new CGetCreateNodeInfoResponse(serv));}

//=======================================================
// class CSetValuesRequest Implementation
//=======================================================

CSetValuesRequest::CSetValuesRequest(const char *serviceName, IRpcMessageBinding *init)
	: m_SessionId(nilIgnore),m_SessionLockKey(nilIgnore),m_NodeId(nilIgnore),m_AttributeValues(nilIgnore),m_AllowInvalid(0, nilIgnore,false),m_ForceCreate(0, nilIgnore,false),m_LocalValue("", nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("SetValuesRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CSetValuesRequest::CSetValuesRequest(const char *serviceName, const char *bc)
	: m_SessionId(nilIgnore),m_SessionLockKey(nilIgnore),m_NodeId(nilIgnore),m_AttributeValues(nilIgnore),m_AllowInvalid(0, nilIgnore,false),m_ForceCreate(0, nilIgnore,false),m_LocalValue("", nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("SetValuesRequest");
}

CSetValuesRequest::CSetValuesRequest(const char *serviceName, IRpcMessage* rpcmsg)
	: m_SessionId(nilIgnore),m_SessionLockKey(nilIgnore),m_NodeId(nilIgnore),m_AttributeValues(nilIgnore),m_AllowInvalid(0, nilIgnore,false),m_ForceCreate(0, nilIgnore,false),m_LocalValue("", nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("SetValuesRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CSetValuesRequest::CSetValuesRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_SessionId(nilIgnore),m_SessionLockKey(nilIgnore),m_NodeId(nilIgnore),m_AttributeValues(nilIgnore),m_AllowInvalid(0, nilIgnore,false),m_ForceCreate(0, nilIgnore,false),m_LocalValue("", nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("SetValuesRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CSetValuesRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"SessionId\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"SessionLockKey\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"NodeId\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"AttributeValues\">\n");
		schema.append("<xsd:complexType><xsd:sequence>\n");
		schema.append("<xsd:element minOccurs=\"0\" maxOccurs=\"unbounded\" name=\"Attribute\" type=\"tns:AttributeValueType\"/>");
		schema.append("</xsd:sequence></xsd:complexType>");
		schema.append("</xsd:element>");
		schema.append("<xsd:element minOccurs=\"0\" default=\"false\" name=\"AllowInvalid\" type=\"xsd:boolean\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" default=\"false\" name=\"ForceCreate\" type=\"xsd:boolean\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" default=\"\" name=\"LocalValue\" type=\"xsd:string\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	if (!(flags & 0x10)  || (flags & 0x100))
	{
		CAttributeValueType::getXsdDefinition(context, request, schema, added);
	}
	return schema;
}

void CSetValuesRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CSetValuesRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
	if (!added.getValue("AttributeValueType"))
	{
		added.setValue("AttributeValueType",1);
		CAttributeValueType::getMapInfo(info,added);
	}
}

StringBuffer &CSetValuesRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("SessionId");
	form.appendf("  <tr><td><b>SessionId: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("SessionLockKey");
	form.appendf("  <tr><td><b>SessionLockKey: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("NodeId");
	form.appendf("  <tr><td><b>NodeId: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("AttributeValues");
	form.appendf("<tr><td><b>AttributeValues: </b></td><td>");
	form.appendf("<table><tr><td><textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea></td>", extfix.str());
	form.append("</tr></table>");
	form.append("</td></tr>");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("AllowInvalid");
	
	form.appendf("  <tr><td><b>AllowInvalid? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("ForceCreate");
	
	form.appendf("  <tr><td><b>ForceCreate? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("LocalValue");
	form.appendf("  <tr><td><b>LocalValue: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CSetValuesRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CSetValuesRequest::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_SessionId.marshall(rpc_resp, "SessionId", "", "", "");
	m_SessionLockKey.marshall(rpc_resp, "SessionLockKey", "", "", "");
	m_NodeId.marshall(rpc_resp, "NodeId", "", "", "");
	m_AttributeValues.marshall(rpc_resp, "AttributeValues", "Attribute");
	m_AllowInvalid.marshall(rpc_resp, "AllowInvalid", "", "", "");
	m_ForceCreate.marshall(rpc_resp, "ForceCreate", "", "", "");
	m_LocalValue.marshall(rpc_resp, "LocalValue", "", "", "");
}


void CSetValuesRequest::copy(CSetValuesRequest &from)
{
	m_SessionId.copy(from.m_SessionId);
	m_SessionLockKey.copy(from.m_SessionLockKey);
	m_NodeId.copy(from.m_NodeId);
	m_AttributeValues.copy(from.m_AttributeValues);
	m_AllowInvalid.copy(from.m_AllowInvalid);
	m_ForceCreate.copy(from.m_ForceCreate);
	m_LocalValue.copy(from.m_LocalValue);
}


void CSetValuesRequest::copy(IConstSetValuesRequest &ifrom)
{
	setSessionId(ifrom.getSessionId());
	setSessionLockKey(ifrom.getSessionLockKey());
	setNodeId(ifrom.getNodeId());
	setAttributeValues(ifrom.getAttributeValues());
	setAllowInvalid(ifrom.getAllowInvalid());
	setForceCreate(ifrom.getForceCreate());
	setLocalValue(ifrom.getLocalValue());
}


void CSetValuesRequest::getAttributes(IProperties &attributes)
{
}


void CSetValuesRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_SessionId.toStr(ctx, buffer, "SessionId", "", true, "", "");
	m_SessionLockKey.toStr(ctx, buffer, "SessionLockKey", "", true, "", "");
	m_NodeId.toStr(ctx, buffer, "NodeId", "", true, "", "");
	m_AttributeValues.toStr(ctx, buffer, "AttributeValues", "Attribute");
	m_AllowInvalid.toStr(ctx, buffer, "AllowInvalid", "", true, "", "");
	m_ForceCreate.toStr(ctx, buffer, "ForceCreate", "", true, "", "");
	m_LocalValue.toStr(ctx, buffer, "LocalValue", "", true, "", "");
}


void CSetValuesRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CSetValuesRequest::serializer(IEspContext* ctx, IConstSetValuesRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<SetValuesRequest>");
	// field SessionId
	{
		const char* s = src.getSessionId();
		if (s && *s)
		{
			buffer.append("<SessionId>");
			encodeUtf8XML(s,buffer);
			buffer.append("</SessionId>");
		}
	}
	// field SessionLockKey
	{
		const char* s = src.getSessionLockKey();
		if (s && *s)
		{
			buffer.append("<SessionLockKey>");
			encodeUtf8XML(s,buffer);
			buffer.append("</SessionLockKey>");
		}
	}
	// field NodeId
	{
		const char* s = src.getNodeId();
		if (s && *s)
		{
			buffer.append("<NodeId>");
			encodeUtf8XML(s,buffer);
			buffer.append("</NodeId>");
		}
	}
	// field AttributeValues
	{
		IArrayOf<IConstAttributeValueType>& v = src.getAttributeValues();
		int size = v.length();
		if (size>0)
			buffer.append("<AttributeValues>");
		for (int i=0;i<size;i++)
		{
			buffer.append("<Attribute>");
			CAttributeValueType::serializer(ctx,v.item(i),buffer,false);
			buffer.append("</Attribute>");
		}
		if (size>0)
			buffer.append("</AttributeValues>");
	}
	// field AllowInvalid
	{
		bool b = src.getAllowInvalid();
		if (b)
			buffer.appendf("<AllowInvalid>1</AllowInvalid>");
	}
	// field ForceCreate
	{
		bool b = src.getForceCreate();
		if (b)
			buffer.appendf("<ForceCreate>1</ForceCreate>");
	}
	// field LocalValue
	{
		const char* s = src.getLocalValue();
		if (s && *s)
		{
			buffer.append("<LocalValue>");
			encodeUtf8XML(s,buffer);
			buffer.append("</LocalValue>");
		}
	}
	if (keepRootTag)
		buffer.append("</SetValuesRequest>");
}

bool CSetValuesRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_SessionId.unmarshall(rpc_request, "SessionId", basepath);
	hasValue |= m_SessionLockKey.unmarshall(rpc_request, "SessionLockKey", basepath);
	hasValue |= m_NodeId.unmarshall(rpc_request, "NodeId", basepath);
	hasValue |= m_AttributeValues.unmarshall(rpc_request, "AttributeValues", basepath);
	hasValue |= m_AllowInvalid.unmarshall(rpc_request, "AllowInvalid", basepath);
	hasValue |= m_ForceCreate.unmarshall(rpc_request, "ForceCreate", basepath);
	hasValue |= m_LocalValue.unmarshall(rpc_request, "LocalValue", basepath);
	return hasValue;
}

bool CSetValuesRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_SessionId.unmarshall(ctx, soapval, "SessionId");
	hasValue |= m_SessionLockKey.unmarshall(ctx, soapval, "SessionLockKey");
	hasValue |= m_NodeId.unmarshall(ctx, soapval, "NodeId");
	hasValue |= m_AttributeValues.unmarshall(ctx, soapval, "AttributeValues");
	hasValue |= m_AllowInvalid.unmarshall(ctx, soapval, "AllowInvalid");
	hasValue |= m_ForceCreate.unmarshall(ctx, soapval, "ForceCreate");
	hasValue |= m_LocalValue.unmarshall(ctx, soapval, "LocalValue");
	return hasValue;
}

bool CSetValuesRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_SessionId.unmarshall(ctx, params, attachments, "SessionId", basepath);
	hasValue |= m_SessionLockKey.unmarshall(ctx, params, attachments, "SessionLockKey", basepath);
	hasValue |= m_NodeId.unmarshall(ctx, params, attachments, "NodeId", basepath);
	hasValue |= m_AttributeValues.unmarshall(ctx, params, attachments, "AttributeValues", basepath);
	hasValue |= m_AllowInvalid.unmarshall(ctx, params, attachments, "AllowInvalid", basepath);
	hasValue |= m_ForceCreate.unmarshall(ctx, params, attachments, "ForceCreate", basepath);
	hasValue |= m_LocalValue.unmarshall(ctx, params, attachments, "LocalValue", basepath);
	return hasValue;
}

const char * CSetValuesRequest::getSessionId() { return m_SessionId.query();}
const char * CSetValuesRequest::getSessionLockKey() { return m_SessionLockKey.query();}
const char * CSetValuesRequest::getNodeId() { return m_NodeId.query();}
IArrayOf<IConstAttributeValueType> & CSetValuesRequest::getAttributeValues() { return (IArrayOf<IConstAttributeValueType> &) m_AttributeValues; }
bool CSetValuesRequest::getAllowInvalid() { return m_AllowInvalid;}
bool CSetValuesRequest::getForceCreate() { return m_ForceCreate;}
const char * CSetValuesRequest::getLocalValue() { return m_LocalValue.query();}
void CSetValuesRequest::setSessionId(const char * val){ m_SessionId.set(val); }
void CSetValuesRequest::setSessionLockKey(const char * val){ m_SessionLockKey.set(val); }
void CSetValuesRequest::setNodeId(const char * val){ m_NodeId.set(val); }
void CSetValuesRequest::setAttributeValues(IArrayOf<IEspAttributeValueType> &val)
{
	m_AttributeValues->kill();
	IArrayOf<IConstAttributeValueType> &target = m_AttributeValues.getValue();
	ForEachItemIn(idx, val)
	{
		IEspAttributeValueType &item = (val).item(idx);
		item.Link();
		target.append(item);
	}
}
void CSetValuesRequest::setAttributeValues(IArrayOf<IConstAttributeValueType> &val)
{
	m_AttributeValues->kill();
	IArrayOf<IConstAttributeValueType> &target = m_AttributeValues.getValue();
	ForEachItemIn(idx, val)
	{
		IConstAttributeValueType &item = val.item(idx);
		item.Link();
		target.append(item);
	}
}
void CSetValuesRequest::setAllowInvalid(bool val){ m_AllowInvalid=val; }
void CSetValuesRequest::setForceCreate(bool val){ m_ForceCreate=val; }
void CSetValuesRequest::setLocalValue(const char * val){ m_LocalValue.set(val); }
extern "C"  IEspSetValuesRequest *createSetValuesRequest(const char *serv){return ((IEspSetValuesRequest *)new CSetValuesRequest(serv));}
extern "C"  IClientSetValuesRequest *createClientSetValuesRequest(const char *serv){return ((IClientSetValuesRequest *)new CSetValuesRequest(serv));}

//=======================================================
// class CGetParentsResponse Implementation
//=======================================================

CGetParentsResponse::CGetParentsResponse(const char *serviceName, IRpcMessageBinding *init)
	: m_ParentIdList(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetParentsResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CGetParentsResponse::CGetParentsResponse(const char *serviceName, const char *bc)
	: m_ParentIdList(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetParentsResponse");
}

CGetParentsResponse::CGetParentsResponse(const char *serviceName, IRpcMessage* rpcmsg)
	: m_ParentIdList(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetParentsResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CGetParentsResponse::CGetParentsResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_ParentIdList(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetParentsResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CGetParentsResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		schema.append("<xsd:element name=\"Exceptions\" type=\"tns:ArrayOfEspException\" minOccurs=\"0\" maxOccurs=\"1\"/>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"ParentIdList\">");
		schema.append("<xsd:complexType><xsd:sequence>");
		schema.append("<xsd:element name=\"parentId\" type=\"xsd:string\" minOccurs=\"0\" maxOccurs=\"unbounded\"/>\n");
		schema.append("</xsd:sequence></xsd:complexType>\n");
		schema.append("</xsd:element>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CGetParentsResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CGetParentsResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CGetParentsResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("ParentIdList");
	form.appendf("<tr><td><b>ParentIdList: </b></td><td>");
	form.appendf("<textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea>", extfix.str());
	form.append("</td></tr>");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CGetParentsResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CGetParentsResponse::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
		m_ParentIdList.marshall(rpc_resp, "ParentIdList", "parentId");
	}
}


void CGetParentsResponse::copy(CGetParentsResponse &from)
{
	m_ParentIdList.copy(from.m_ParentIdList);
}


void CGetParentsResponse::copy(IConstGetParentsResponse &ifrom)
{
	setParentIdList(ifrom.getParentIdList());
}


void CGetParentsResponse::getAttributes(IProperties &attributes)
{
}


void CGetParentsResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
		m_ParentIdList.toStr(ctx, buffer, "ParentIdList", "parentId");
	}
}


void CGetParentsResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CGetParentsResponse::serializer(IEspContext* ctx, IConstGetParentsResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<GetParentsResponse>");
	// field ParentIdList
	{
		StringArray& v = src.getParentIdList();
		if (v.length()>0)
			buffer.append("<ParentIdList>");
		for (size32_t i=0;i<v.length();i++)
			buffer.appendf("<parentId>%s</parentId>",v.item(i));
		if (v.length()>0)
			buffer.append("</ParentIdList>");
	}
	if (keepRootTag)
		buffer.append("</GetParentsResponse>");
}

bool CGetParentsResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
		hasValue |= m_ParentIdList.unmarshall(rpc_request, "ParentIdList", basepath);
	}
	return hasValue;
}

bool CGetParentsResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_ParentIdList.unmarshall(ctx, soapval, "ParentIdList");
	return hasValue;
}

bool CGetParentsResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_ParentIdList.unmarshall(ctx, params, attachments, "ParentIdList", basepath);
	return hasValue;
}

StringArray & CGetParentsResponse::getParentIdList() { return (StringArray &) m_ParentIdList; }
void CGetParentsResponse::setParentIdList(StringArray &val){ m_ParentIdList->kill();  CloneArray(m_ParentIdList.getValue(), val); }
extern "C"  IEspGetParentsResponse *createGetParentsResponse(const char *serv){return ((IEspGetParentsResponse *)new CGetParentsResponse(serv));}
extern "C"  IClientGetParentsResponse *createClientGetParentsResponse(const char *serv){return ((IClientGetParentsResponse *)new CGetParentsResponse(serv));}

//=======================================================
// class CGetNodeCopyRequest Implementation
//=======================================================

CGetNodeCopyRequest::CGetNodeCopyRequest(const char *serviceName, IRpcMessageBinding *init)
	: m_SessionId(nilIgnore),m_NodeId(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetNodeCopyRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CGetNodeCopyRequest::CGetNodeCopyRequest(const char *serviceName, const char *bc)
	: m_SessionId(nilIgnore),m_NodeId(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetNodeCopyRequest");
}

CGetNodeCopyRequest::CGetNodeCopyRequest(const char *serviceName, IRpcMessage* rpcmsg)
	: m_SessionId(nilIgnore),m_NodeId(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetNodeCopyRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CGetNodeCopyRequest::CGetNodeCopyRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_SessionId(nilIgnore),m_NodeId(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetNodeCopyRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CGetNodeCopyRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"SessionId\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"NodeId\" type=\"xsd:string\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CGetNodeCopyRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CGetNodeCopyRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CGetNodeCopyRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("SessionId");
	form.appendf("  <tr><td><b>SessionId: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("NodeId");
	form.appendf("  <tr><td><b>NodeId: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CGetNodeCopyRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CGetNodeCopyRequest::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_SessionId.marshall(rpc_resp, "SessionId", "", "", "");
	m_NodeId.marshall(rpc_resp, "NodeId", "", "", "");
}


void CGetNodeCopyRequest::copy(CGetNodeCopyRequest &from)
{
	m_SessionId.copy(from.m_SessionId);
	m_NodeId.copy(from.m_NodeId);
}


void CGetNodeCopyRequest::copy(IConstGetNodeCopyRequest &ifrom)
{
	setSessionId(ifrom.getSessionId());
	setNodeId(ifrom.getNodeId());
}


void CGetNodeCopyRequest::getAttributes(IProperties &attributes)
{
}


void CGetNodeCopyRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_SessionId.toStr(ctx, buffer, "SessionId", "", true, "", "");
	m_NodeId.toStr(ctx, buffer, "NodeId", "", true, "", "");
}


void CGetNodeCopyRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CGetNodeCopyRequest::serializer(IEspContext* ctx, IConstGetNodeCopyRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<GetNodeCopyRequest>");
	// field SessionId
	{
		const char* s = src.getSessionId();
		if (s && *s)
		{
			buffer.append("<SessionId>");
			encodeUtf8XML(s,buffer);
			buffer.append("</SessionId>");
		}
	}
	// field NodeId
	{
		const char* s = src.getNodeId();
		if (s && *s)
		{
			buffer.append("<NodeId>");
			encodeUtf8XML(s,buffer);
			buffer.append("</NodeId>");
		}
	}
	if (keepRootTag)
		buffer.append("</GetNodeCopyRequest>");
}

bool CGetNodeCopyRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_SessionId.unmarshall(rpc_request, "SessionId", basepath);
	hasValue |= m_NodeId.unmarshall(rpc_request, "NodeId", basepath);
	return hasValue;
}

bool CGetNodeCopyRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_SessionId.unmarshall(ctx, soapval, "SessionId");
	hasValue |= m_NodeId.unmarshall(ctx, soapval, "NodeId");
	return hasValue;
}

bool CGetNodeCopyRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_SessionId.unmarshall(ctx, params, attachments, "SessionId", basepath);
	hasValue |= m_NodeId.unmarshall(ctx, params, attachments, "NodeId", basepath);
	return hasValue;
}

const char * CGetNodeCopyRequest::getSessionId() { return m_SessionId.query();}
const char * CGetNodeCopyRequest::getNodeId() { return m_NodeId.query();}
void CGetNodeCopyRequest::setSessionId(const char * val){ m_SessionId.set(val); }
void CGetNodeCopyRequest::setNodeId(const char * val){ m_NodeId.set(val); }
extern "C"  IEspGetNodeCopyRequest *createGetNodeCopyRequest(const char *serv){return ((IEspGetNodeCopyRequest *)new CGetNodeCopyRequest(serv));}
extern "C"  IClientGetNodeCopyRequest *createClientGetNodeCopyRequest(const char *serv){return ((IClientGetNodeCopyRequest *)new CGetNodeCopyRequest(serv));}

//=======================================================
// class CGetNodeCopyResponse Implementation
//=======================================================

CGetNodeCopyResponse::CGetNodeCopyResponse(const char *serviceName, IRpcMessageBinding *init)
	: m_ValidInsertPath("", nilIgnore),m_NodeCopy("", nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetNodeCopyResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CGetNodeCopyResponse::CGetNodeCopyResponse(const char *serviceName, const char *bc)
	: m_ValidInsertPath("", nilIgnore),m_NodeCopy("", nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetNodeCopyResponse");
}

CGetNodeCopyResponse::CGetNodeCopyResponse(const char *serviceName, IRpcMessage* rpcmsg)
	: m_ValidInsertPath("", nilIgnore),m_NodeCopy("", nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetNodeCopyResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CGetNodeCopyResponse::CGetNodeCopyResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_ValidInsertPath("", nilIgnore),m_NodeCopy("", nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetNodeCopyResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CGetNodeCopyResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" default=\"\" name=\"ValidInsertPath\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" default=\"\" name=\"NodeCopy\" type=\"xsd:string\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CGetNodeCopyResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CGetNodeCopyResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CGetNodeCopyResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("ValidInsertPath");
	form.appendf("  <tr><td><b>ValidInsertPath: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("NodeCopy");
	form.appendf("  <tr><td><b>NodeCopy: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CGetNodeCopyResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CGetNodeCopyResponse::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
		m_ValidInsertPath.marshall(rpc_resp, "ValidInsertPath", "", "", "");
		m_NodeCopy.marshall(rpc_resp, "NodeCopy", "", "", "");
	}
}


void CGetNodeCopyResponse::copy(CGetNodeCopyResponse &from)
{
	m_ValidInsertPath.copy(from.m_ValidInsertPath);
	m_NodeCopy.copy(from.m_NodeCopy);
}


void CGetNodeCopyResponse::copy(IConstGetNodeCopyResponse &ifrom)
{
	setValidInsertPath(ifrom.getValidInsertPath());
	setNodeCopy(ifrom.getNodeCopy());
}


void CGetNodeCopyResponse::getAttributes(IProperties &attributes)
{
}


void CGetNodeCopyResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
		m_ValidInsertPath.toStr(ctx, buffer, "ValidInsertPath", "", true, "", "");
		m_NodeCopy.toStr(ctx, buffer, "NodeCopy", "", true, "", "");
	}
}


void CGetNodeCopyResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CGetNodeCopyResponse::serializer(IEspContext* ctx, IConstGetNodeCopyResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<GetNodeCopyResponse>");
	// field ValidInsertPath
	{
		const char* s = src.getValidInsertPath();
		if (s && *s)
		{
			buffer.append("<ValidInsertPath>");
			encodeUtf8XML(s,buffer);
			buffer.append("</ValidInsertPath>");
		}
	}
	// field NodeCopy
	{
		const char* s = src.getNodeCopy();
		if (s && *s)
		{
			buffer.append("<NodeCopy>");
			encodeUtf8XML(s,buffer);
			buffer.append("</NodeCopy>");
		}
	}
	if (keepRootTag)
		buffer.append("</GetNodeCopyResponse>");
}

bool CGetNodeCopyResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
		hasValue |= m_ValidInsertPath.unmarshall(rpc_request, "ValidInsertPath", basepath);
		hasValue |= m_NodeCopy.unmarshall(rpc_request, "NodeCopy", basepath);
	}
	return hasValue;
}

bool CGetNodeCopyResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_ValidInsertPath.unmarshall(ctx, soapval, "ValidInsertPath");
	hasValue |= m_NodeCopy.unmarshall(ctx, soapval, "NodeCopy");
	return hasValue;
}

bool CGetNodeCopyResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_ValidInsertPath.unmarshall(ctx, params, attachments, "ValidInsertPath", basepath);
	hasValue |= m_NodeCopy.unmarshall(ctx, params, attachments, "NodeCopy", basepath);
	return hasValue;
}

const char * CGetNodeCopyResponse::getValidInsertPath() { return m_ValidInsertPath.query();}
const char * CGetNodeCopyResponse::getNodeCopy() { return m_NodeCopy.query();}
void CGetNodeCopyResponse::setValidInsertPath(const char * val){ m_ValidInsertPath.set(val); }
void CGetNodeCopyResponse::setNodeCopy(const char * val){ m_NodeCopy.set(val); }
extern "C"  IEspGetNodeCopyResponse *createGetNodeCopyResponse(const char *serv){return ((IEspGetNodeCopyResponse *)new CGetNodeCopyResponse(serv));}
extern "C"  IClientGetNodeCopyResponse *createClientGetNodeCopyResponse(const char *serv){return ((IClientGetNodeCopyResponse *)new CGetNodeCopyResponse(serv));}

//=======================================================
// class CPasteNodeCopyRequest Implementation
//=======================================================

CPasteNodeCopyRequest::CPasteNodeCopyRequest(const char *serviceName, IRpcMessageBinding *init)
	: m_SessionId(nilIgnore),m_SessionLockKey(nilIgnore),m_ParentNodeId(nilIgnore),m_NodeCopy(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("PasteNodeCopyRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CPasteNodeCopyRequest::CPasteNodeCopyRequest(const char *serviceName, const char *bc)
	: m_SessionId(nilIgnore),m_SessionLockKey(nilIgnore),m_ParentNodeId(nilIgnore),m_NodeCopy(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("PasteNodeCopyRequest");
}

CPasteNodeCopyRequest::CPasteNodeCopyRequest(const char *serviceName, IRpcMessage* rpcmsg)
	: m_SessionId(nilIgnore),m_SessionLockKey(nilIgnore),m_ParentNodeId(nilIgnore),m_NodeCopy(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("PasteNodeCopyRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CPasteNodeCopyRequest::CPasteNodeCopyRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_SessionId(nilIgnore),m_SessionLockKey(nilIgnore),m_ParentNodeId(nilIgnore),m_NodeCopy(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("PasteNodeCopyRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CPasteNodeCopyRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"SessionId\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"SessionLockKey\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"ParentNodeId\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"NodeCopy\" type=\"xsd:string\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CPasteNodeCopyRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CPasteNodeCopyRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CPasteNodeCopyRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("SessionId");
	form.appendf("  <tr><td><b>SessionId: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("SessionLockKey");
	form.appendf("  <tr><td><b>SessionLockKey: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("ParentNodeId");
	form.appendf("  <tr><td><b>ParentNodeId: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("NodeCopy");
	form.appendf("  <tr><td><b>NodeCopy: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CPasteNodeCopyRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CPasteNodeCopyRequest::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_SessionId.marshall(rpc_resp, "SessionId", "", "", "");
	m_SessionLockKey.marshall(rpc_resp, "SessionLockKey", "", "", "");
	m_ParentNodeId.marshall(rpc_resp, "ParentNodeId", "", "", "");
	m_NodeCopy.marshall(rpc_resp, "NodeCopy", "", "", "");
}


void CPasteNodeCopyRequest::copy(CPasteNodeCopyRequest &from)
{
	m_SessionId.copy(from.m_SessionId);
	m_SessionLockKey.copy(from.m_SessionLockKey);
	m_ParentNodeId.copy(from.m_ParentNodeId);
	m_NodeCopy.copy(from.m_NodeCopy);
}


void CPasteNodeCopyRequest::copy(IConstPasteNodeCopyRequest &ifrom)
{
	setSessionId(ifrom.getSessionId());
	setSessionLockKey(ifrom.getSessionLockKey());
	setParentNodeId(ifrom.getParentNodeId());
	setNodeCopy(ifrom.getNodeCopy());
}


void CPasteNodeCopyRequest::getAttributes(IProperties &attributes)
{
}


void CPasteNodeCopyRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_SessionId.toStr(ctx, buffer, "SessionId", "", true, "", "");
	m_SessionLockKey.toStr(ctx, buffer, "SessionLockKey", "", true, "", "");
	m_ParentNodeId.toStr(ctx, buffer, "ParentNodeId", "", true, "", "");
	m_NodeCopy.toStr(ctx, buffer, "NodeCopy", "", true, "", "");
}


void CPasteNodeCopyRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CPasteNodeCopyRequest::serializer(IEspContext* ctx, IConstPasteNodeCopyRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<PasteNodeCopyRequest>");
	// field SessionId
	{
		const char* s = src.getSessionId();
		if (s && *s)
		{
			buffer.append("<SessionId>");
			encodeUtf8XML(s,buffer);
			buffer.append("</SessionId>");
		}
	}
	// field SessionLockKey
	{
		const char* s = src.getSessionLockKey();
		if (s && *s)
		{
			buffer.append("<SessionLockKey>");
			encodeUtf8XML(s,buffer);
			buffer.append("</SessionLockKey>");
		}
	}
	// field ParentNodeId
	{
		const char* s = src.getParentNodeId();
		if (s && *s)
		{
			buffer.append("<ParentNodeId>");
			encodeUtf8XML(s,buffer);
			buffer.append("</ParentNodeId>");
		}
	}
	// field NodeCopy
	{
		const char* s = src.getNodeCopy();
		if (s && *s)
		{
			buffer.append("<NodeCopy>");
			encodeUtf8XML(s,buffer);
			buffer.append("</NodeCopy>");
		}
	}
	if (keepRootTag)
		buffer.append("</PasteNodeCopyRequest>");
}

bool CPasteNodeCopyRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_SessionId.unmarshall(rpc_request, "SessionId", basepath);
	hasValue |= m_SessionLockKey.unmarshall(rpc_request, "SessionLockKey", basepath);
	hasValue |= m_ParentNodeId.unmarshall(rpc_request, "ParentNodeId", basepath);
	hasValue |= m_NodeCopy.unmarshall(rpc_request, "NodeCopy", basepath);
	return hasValue;
}

bool CPasteNodeCopyRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_SessionId.unmarshall(ctx, soapval, "SessionId");
	hasValue |= m_SessionLockKey.unmarshall(ctx, soapval, "SessionLockKey");
	hasValue |= m_ParentNodeId.unmarshall(ctx, soapval, "ParentNodeId");
	hasValue |= m_NodeCopy.unmarshall(ctx, soapval, "NodeCopy");
	return hasValue;
}

bool CPasteNodeCopyRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_SessionId.unmarshall(ctx, params, attachments, "SessionId", basepath);
	hasValue |= m_SessionLockKey.unmarshall(ctx, params, attachments, "SessionLockKey", basepath);
	hasValue |= m_ParentNodeId.unmarshall(ctx, params, attachments, "ParentNodeId", basepath);
	hasValue |= m_NodeCopy.unmarshall(ctx, params, attachments, "NodeCopy", basepath);
	return hasValue;
}

const char * CPasteNodeCopyRequest::getSessionId() { return m_SessionId.query();}
const char * CPasteNodeCopyRequest::getSessionLockKey() { return m_SessionLockKey.query();}
const char * CPasteNodeCopyRequest::getParentNodeId() { return m_ParentNodeId.query();}
const char * CPasteNodeCopyRequest::getNodeCopy() { return m_NodeCopy.query();}
void CPasteNodeCopyRequest::setSessionId(const char * val){ m_SessionId.set(val); }
void CPasteNodeCopyRequest::setSessionLockKey(const char * val){ m_SessionLockKey.set(val); }
void CPasteNodeCopyRequest::setParentNodeId(const char * val){ m_ParentNodeId.set(val); }
void CPasteNodeCopyRequest::setNodeCopy(const char * val){ m_NodeCopy.set(val); }
extern "C"  IEspPasteNodeCopyRequest *createPasteNodeCopyRequest(const char *serv){return ((IEspPasteNodeCopyRequest *)new CPasteNodeCopyRequest(serv));}
extern "C"  IClientPasteNodeCopyRequest *createClientPasteNodeCopyRequest(const char *serv){return ((IClientPasteNodeCopyRequest *)new CPasteNodeCopyRequest(serv));}

//=======================================================
// class CPasteNodeCopyResponse Implementation
//=======================================================

CPasteNodeCopyResponse::CPasteNodeCopyResponse(const char *serviceName, IRpcMessageBinding *init)
	: m_NodeInserted(0, nilIgnore,false),m_Status(serviceName, nilIgnore),m_NewNodeId("", nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("PasteNodeCopyResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CPasteNodeCopyResponse::CPasteNodeCopyResponse(const char *serviceName, const char *bc)
	: m_NodeInserted(0, nilIgnore,false),m_Status(serviceName, nilIgnore),m_NewNodeId("", nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("PasteNodeCopyResponse");
}

CPasteNodeCopyResponse::CPasteNodeCopyResponse(const char *serviceName, IRpcMessage* rpcmsg)
	: m_NodeInserted(0, nilIgnore,false),m_Status(serviceName, nilIgnore),m_NewNodeId("", nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("PasteNodeCopyResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CPasteNodeCopyResponse::CPasteNodeCopyResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_NodeInserted(0, nilIgnore,false),m_Status(serviceName, nilIgnore),m_NewNodeId("", nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("PasteNodeCopyResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CPasteNodeCopyResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" default=\"false\" name=\"NodeInserted\" type=\"xsd:boolean\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Status\" type=\"tns:StatusType\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" default=\"\" name=\"NewNodeId\" type=\"xsd:string\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	if (!(flags & 0x10)  || (flags & 0x100))
	{
		CStatusType::getXsdDefinition(context, request, schema, added);
	}
	return schema;
}

void CPasteNodeCopyResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CPasteNodeCopyResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
	if (!added.getValue("StatusType"))
	{
		added.setValue("StatusType",1);
		CStatusType::getMapInfo(info,added);
	}
}

StringBuffer &CPasteNodeCopyResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("NodeInserted");
	
	form.appendf("  <tr><td><b>NodeInserted? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Status");
	form.append("<tr>").append("<td><b>Status: </b></td><td><hr/>");
	CStatusType::getHtmlForm(context, request, serv, method, form, false, extfix.str());
	form.append("<hr/></td></tr>");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("NewNodeId");
	form.appendf("  <tr><td><b>NewNodeId: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CPasteNodeCopyResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CPasteNodeCopyResponse::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
		m_NodeInserted.marshall(rpc_resp, "NodeInserted", "", "", "");
		m_Status.marshall(rpc_resp, "Status", "", "", "");
		m_NewNodeId.marshall(rpc_resp, "NewNodeId", "", "", "");
	}
}


void CPasteNodeCopyResponse::copy(CPasteNodeCopyResponse &from)
{
	m_NodeInserted.copy(from.m_NodeInserted);
	m_Status.copy(from.m_Status);
	m_NewNodeId.copy(from.m_NewNodeId);
}


void CPasteNodeCopyResponse::copy(IConstPasteNodeCopyResponse &ifrom)
{
	setNodeInserted(ifrom.getNodeInserted());
	setStatus(ifrom.getStatus());
	setNewNodeId(ifrom.getNewNodeId());
}


void CPasteNodeCopyResponse::getAttributes(IProperties &attributes)
{
}


void CPasteNodeCopyResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
		m_NodeInserted.toStr(ctx, buffer, "NodeInserted", "", true, "", "");
		m_Status.toStr(ctx, buffer, "Status", "", false, "", "");
		m_NewNodeId.toStr(ctx, buffer, "NewNodeId", "", true, "", "");
	}
}


void CPasteNodeCopyResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CPasteNodeCopyResponse::serializer(IEspContext* ctx, IConstPasteNodeCopyResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<PasteNodeCopyResponse>");
	// field NodeInserted
	{
		bool b = src.getNodeInserted();
		if (b)
			buffer.appendf("<NodeInserted>1</NodeInserted>");
	}
	// field Status
	{
		StringBuffer tmp;
		CStatusType::serializer(ctx,src.getStatus(), tmp, false);
		if (tmp.length()>0)
			buffer.appendf("<Status>%s</Status>",tmp.str());
	}
	// field NewNodeId
	{
		const char* s = src.getNewNodeId();
		if (s && *s)
		{
			buffer.append("<NewNodeId>");
			encodeUtf8XML(s,buffer);
			buffer.append("</NewNodeId>");
		}
	}
	if (keepRootTag)
		buffer.append("</PasteNodeCopyResponse>");
}

bool CPasteNodeCopyResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
		hasValue |= m_NodeInserted.unmarshall(rpc_request, "NodeInserted", basepath);
		hasValue |= m_Status.unmarshall(rpc_request, "Status", basepath);
		hasValue |= m_NewNodeId.unmarshall(rpc_request, "NewNodeId", basepath);
	}
	return hasValue;
}

bool CPasteNodeCopyResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_NodeInserted.unmarshall(ctx, soapval, "NodeInserted");
	hasValue |= m_Status.unmarshall(ctx, soapval, "Status");
	hasValue |= m_NewNodeId.unmarshall(ctx, soapval, "NewNodeId");
	return hasValue;
}

bool CPasteNodeCopyResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_NodeInserted.unmarshall(ctx, params, attachments, "NodeInserted", basepath);
	hasValue |= m_Status.unmarshall(ctx, params, attachments, "Status", basepath);
	hasValue |= m_NewNodeId.unmarshall(ctx, params, attachments, "NewNodeId", basepath);
	return hasValue;
}

bool CPasteNodeCopyResponse::getNodeInserted() { return m_NodeInserted;}
IConstStatusType & CPasteNodeCopyResponse::getStatus() { return (IConstStatusType &) m_Status.getValue();}
const char * CPasteNodeCopyResponse::getNewNodeId() { return m_NewNodeId.query();}
void CPasteNodeCopyResponse::setNodeInserted(bool val){ m_NodeInserted=val; }
IEspStatusType & CPasteNodeCopyResponse::updateStatus(){ return (IEspStatusType &) m_Status.getValue(); }
void CPasteNodeCopyResponse::setStatus(IConstStatusType &ifrom){ m_Status.copy(ifrom); }
void CPasteNodeCopyResponse::setNewNodeId(const char * val){ m_NewNodeId.set(val); }
extern "C"  IEspPasteNodeCopyResponse *createPasteNodeCopyResponse(const char *serv){return ((IEspPasteNodeCopyResponse *)new CPasteNodeCopyResponse(serv));}
extern "C"  IClientPasteNodeCopyResponse *createClientPasteNodeCopyResponse(const char *serv){return ((IClientPasteNodeCopyResponse *)new CPasteNodeCopyResponse(serv));}

//=======================================================
// class CEnvironmentFileType Implementation
//=======================================================

CEnvironmentFileType::CEnvironmentFileType(const char *serviceName, IRpcMessageBinding *init)
	: m_Filename(nilIgnore),m_IsActive(0, nilIgnore,false)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("EnvironmentFileType");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CEnvironmentFileType::CEnvironmentFileType(const char *serviceName, const char *bc)
	: m_Filename(nilIgnore),m_IsActive(0, nilIgnore,false)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("EnvironmentFileType");
}

StringBuffer &CEnvironmentFileType::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:complexType name=\"%s\">\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Filename\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" default=\"false\" name=\"IsActive\" type=\"xsd:boolean\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType>\n");
		}
	}
	return schema;
}

void CEnvironmentFileType::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CEnvironmentFileType::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CEnvironmentFileType::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Filename");
	form.appendf("  <tr><td><b>Filename: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("IsActive");
	
	form.appendf("  <tr><td><b>IsActive? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CEnvironmentFileType::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CEnvironmentFileType::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_Filename.marshall(rpc_resp, "Filename", "", "", "");
	m_IsActive.marshall(rpc_resp, "IsActive", "", "", "");
}


void CEnvironmentFileType::copy(CEnvironmentFileType &from)
{
	m_Filename.copy(from.m_Filename);
	m_IsActive.copy(from.m_IsActive);
}


void CEnvironmentFileType::copy(IConstEnvironmentFileType &ifrom)
{
	setFilename(ifrom.getFilename());
	setIsActive(ifrom.getIsActive());
}


void CEnvironmentFileType::getAttributes(IProperties &attributes)
{
}


void CEnvironmentFileType::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_Filename.toStr(ctx, buffer, "Filename", "", true, "", "");
	m_IsActive.toStr(ctx, buffer, "IsActive", "", true, "", "");
}


void CEnvironmentFileType::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CEnvironmentFileType::serializer(IEspContext* ctx, IConstEnvironmentFileType &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<EnvironmentFileType>");
	// field Filename
	{
		const char* s = src.getFilename();
		if (s && *s)
		{
			buffer.append("<Filename>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Filename>");
		}
	}
	// field IsActive
	{
		bool b = src.getIsActive();
		if (b)
			buffer.appendf("<IsActive>1</IsActive>");
	}
	if (keepRootTag)
		buffer.append("</EnvironmentFileType>");
}

bool CEnvironmentFileType::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_Filename.unmarshall(rpc_request, "Filename", basepath);
	hasValue |= m_IsActive.unmarshall(rpc_request, "IsActive", basepath);
	return hasValue;
}

bool CEnvironmentFileType::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Filename.unmarshall(ctx, soapval, "Filename");
	hasValue |= m_IsActive.unmarshall(ctx, soapval, "IsActive");
	return hasValue;
}

bool CEnvironmentFileType::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Filename.unmarshall(ctx, params, attachments, "Filename", basepath);
	hasValue |= m_IsActive.unmarshall(ctx, params, attachments, "IsActive", basepath);
	return hasValue;
}

const char * CEnvironmentFileType::getFilename() { return m_Filename.query();}
bool CEnvironmentFileType::getIsActive() { return m_IsActive;}
void CEnvironmentFileType::setFilename(const char * val){ m_Filename.set(val); }
void CEnvironmentFileType::setIsActive(bool val){ m_IsActive=val; }
extern "C"  IEspEnvironmentFileType *createEnvironmentFileType(const char *serv, const char *msgname){return ((IEspEnvironmentFileType *)new CEnvironmentFileType(serv /*, msgname*/));}
extern "C"  IClientEnvironmentFileType *createClientEnvironmentFileType(const char *serv, const char *msgname){return ((IClientEnvironmentFileType *)new CEnvironmentFileType(serv /*, msgname*/));}

//=======================================================
// class CGetEnvironmentFileListRequest Implementation
//=======================================================

CGetEnvironmentFileListRequest::CGetEnvironmentFileListRequest(const char *serviceName, IRpcMessageBinding *init)
	: m_SessionId(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetEnvironmentFileListRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CGetEnvironmentFileListRequest::CGetEnvironmentFileListRequest(const char *serviceName, const char *bc)
	: m_SessionId(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetEnvironmentFileListRequest");
}

CGetEnvironmentFileListRequest::CGetEnvironmentFileListRequest(const char *serviceName, IRpcMessage* rpcmsg)
	: m_SessionId(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetEnvironmentFileListRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CGetEnvironmentFileListRequest::CGetEnvironmentFileListRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_SessionId(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetEnvironmentFileListRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CGetEnvironmentFileListRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"SessionId\" type=\"xsd:string\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CGetEnvironmentFileListRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CGetEnvironmentFileListRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CGetEnvironmentFileListRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("SessionId");
	form.appendf("  <tr><td><b>SessionId: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CGetEnvironmentFileListRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CGetEnvironmentFileListRequest::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_SessionId.marshall(rpc_resp, "SessionId", "", "", "");
}


void CGetEnvironmentFileListRequest::copy(CGetEnvironmentFileListRequest &from)
{
	m_SessionId.copy(from.m_SessionId);
}


void CGetEnvironmentFileListRequest::copy(IConstGetEnvironmentFileListRequest &ifrom)
{
	setSessionId(ifrom.getSessionId());
}


void CGetEnvironmentFileListRequest::getAttributes(IProperties &attributes)
{
}


void CGetEnvironmentFileListRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_SessionId.toStr(ctx, buffer, "SessionId", "", true, "", "");
}


void CGetEnvironmentFileListRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CGetEnvironmentFileListRequest::serializer(IEspContext* ctx, IConstGetEnvironmentFileListRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<GetEnvironmentFileListRequest>");
	// field SessionId
	{
		const char* s = src.getSessionId();
		if (s && *s)
		{
			buffer.append("<SessionId>");
			encodeUtf8XML(s,buffer);
			buffer.append("</SessionId>");
		}
	}
	if (keepRootTag)
		buffer.append("</GetEnvironmentFileListRequest>");
}

bool CGetEnvironmentFileListRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_SessionId.unmarshall(rpc_request, "SessionId", basepath);
	return hasValue;
}

bool CGetEnvironmentFileListRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_SessionId.unmarshall(ctx, soapval, "SessionId");
	return hasValue;
}

bool CGetEnvironmentFileListRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_SessionId.unmarshall(ctx, params, attachments, "SessionId", basepath);
	return hasValue;
}

const char * CGetEnvironmentFileListRequest::getSessionId() { return m_SessionId.query();}
void CGetEnvironmentFileListRequest::setSessionId(const char * val){ m_SessionId.set(val); }
extern "C"  IEspGetEnvironmentFileListRequest *createGetEnvironmentFileListRequest(const char *serv){return ((IEspGetEnvironmentFileListRequest *)new CGetEnvironmentFileListRequest(serv));}
extern "C"  IClientGetEnvironmentFileListRequest *createClientGetEnvironmentFileListRequest(const char *serv){return ((IClientGetEnvironmentFileListRequest *)new CGetEnvironmentFileListRequest(serv));}

//=======================================================
// class CLockSessionRequest Implementation
//=======================================================

CLockSessionRequest::CLockSessionRequest(const char *serviceName, IRpcMessageBinding *init)
	: m_SessionId(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("LockSessionRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CLockSessionRequest::CLockSessionRequest(const char *serviceName, const char *bc)
	: m_SessionId(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("LockSessionRequest");
}

CLockSessionRequest::CLockSessionRequest(const char *serviceName, IRpcMessage* rpcmsg)
	: m_SessionId(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("LockSessionRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CLockSessionRequest::CLockSessionRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_SessionId(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("LockSessionRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CLockSessionRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"SessionId\" type=\"xsd:string\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CLockSessionRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CLockSessionRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CLockSessionRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("SessionId");
	form.appendf("  <tr><td><b>SessionId: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CLockSessionRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CLockSessionRequest::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_SessionId.marshall(rpc_resp, "SessionId", "", "", "");
}


void CLockSessionRequest::copy(CLockSessionRequest &from)
{
	m_SessionId.copy(from.m_SessionId);
}


void CLockSessionRequest::copy(IConstLockSessionRequest &ifrom)
{
	setSessionId(ifrom.getSessionId());
}


void CLockSessionRequest::getAttributes(IProperties &attributes)
{
}


void CLockSessionRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_SessionId.toStr(ctx, buffer, "SessionId", "", true, "", "");
}


void CLockSessionRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CLockSessionRequest::serializer(IEspContext* ctx, IConstLockSessionRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<LockSessionRequest>");
	// field SessionId
	{
		const char* s = src.getSessionId();
		if (s && *s)
		{
			buffer.append("<SessionId>");
			encodeUtf8XML(s,buffer);
			buffer.append("</SessionId>");
		}
	}
	if (keepRootTag)
		buffer.append("</LockSessionRequest>");
}

bool CLockSessionRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_SessionId.unmarshall(rpc_request, "SessionId", basepath);
	return hasValue;
}

bool CLockSessionRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_SessionId.unmarshall(ctx, soapval, "SessionId");
	return hasValue;
}

bool CLockSessionRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_SessionId.unmarshall(ctx, params, attachments, "SessionId", basepath);
	return hasValue;
}

const char * CLockSessionRequest::getSessionId() { return m_SessionId.query();}
void CLockSessionRequest::setSessionId(const char * val){ m_SessionId.set(val); }
extern "C"  IEspLockSessionRequest *createLockSessionRequest(const char *serv){return ((IEspLockSessionRequest *)new CLockSessionRequest(serv));}
extern "C"  IClientLockSessionRequest *createClientLockSessionRequest(const char *serv){return ((IClientLockSessionRequest *)new CLockSessionRequest(serv));}

//=======================================================
// class CGetEnvironmentListResponse Implementation
//=======================================================

CGetEnvironmentListResponse::CGetEnvironmentListResponse(const char *serviceName, IRpcMessageBinding *init)
	: m_EnvironmentFiles(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetEnvironmentListResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CGetEnvironmentListResponse::CGetEnvironmentListResponse(const char *serviceName, const char *bc)
	: m_EnvironmentFiles(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetEnvironmentListResponse");
}

CGetEnvironmentListResponse::CGetEnvironmentListResponse(const char *serviceName, IRpcMessage* rpcmsg)
	: m_EnvironmentFiles(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetEnvironmentListResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CGetEnvironmentListResponse::CGetEnvironmentListResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_EnvironmentFiles(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetEnvironmentListResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CGetEnvironmentListResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		schema.append("<xsd:element name=\"Exceptions\" type=\"tns:ArrayOfEspException\" minOccurs=\"0\" maxOccurs=\"1\"/>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"EnvironmentFiles\">\n");
		schema.append("<xsd:complexType><xsd:sequence>\n");
		schema.append("<xsd:element minOccurs=\"0\" maxOccurs=\"unbounded\" name=\"EnvironmentFile\" type=\"tns:EnvironmentFileType\"/>");
		schema.append("</xsd:sequence></xsd:complexType>");
		schema.append("</xsd:element>");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	if (!(flags & 0x10)  || (flags & 0x100))
	{
		CEnvironmentFileType::getXsdDefinition(context, request, schema, added);
	}
	return schema;
}

void CGetEnvironmentListResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CGetEnvironmentListResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
	if (!added.getValue("EnvironmentFileType"))
	{
		added.setValue("EnvironmentFileType",1);
		CEnvironmentFileType::getMapInfo(info,added);
	}
}

StringBuffer &CGetEnvironmentListResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("EnvironmentFiles");
	form.appendf("<tr><td><b>EnvironmentFiles: </b></td><td>");
	form.appendf("<table><tr><td><textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea></td>", extfix.str());
	form.append("</tr></table>");
	form.append("</td></tr>");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CGetEnvironmentListResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CGetEnvironmentListResponse::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
		m_EnvironmentFiles.marshall(rpc_resp, "EnvironmentFiles", "EnvironmentFile");
	}
}


void CGetEnvironmentListResponse::copy(CGetEnvironmentListResponse &from)
{
	m_EnvironmentFiles.copy(from.m_EnvironmentFiles);
}


void CGetEnvironmentListResponse::copy(IConstGetEnvironmentListResponse &ifrom)
{
	setEnvironmentFiles(ifrom.getEnvironmentFiles());
}


void CGetEnvironmentListResponse::getAttributes(IProperties &attributes)
{
}


void CGetEnvironmentListResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
		m_EnvironmentFiles.toStr(ctx, buffer, "EnvironmentFiles", "EnvironmentFile");
	}
}


void CGetEnvironmentListResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CGetEnvironmentListResponse::serializer(IEspContext* ctx, IConstGetEnvironmentListResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<GetEnvironmentListResponse>");
	// field EnvironmentFiles
	{
		IArrayOf<IConstEnvironmentFileType>& v = src.getEnvironmentFiles();
		int size = v.length();
		if (size>0)
			buffer.append("<EnvironmentFiles>");
		for (int i=0;i<size;i++)
		{
			buffer.append("<EnvironmentFile>");
			CEnvironmentFileType::serializer(ctx,v.item(i),buffer,false);
			buffer.append("</EnvironmentFile>");
		}
		if (size>0)
			buffer.append("</EnvironmentFiles>");
	}
	if (keepRootTag)
		buffer.append("</GetEnvironmentListResponse>");
}

bool CGetEnvironmentListResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
		hasValue |= m_EnvironmentFiles.unmarshall(rpc_request, "EnvironmentFiles", basepath);
	}
	return hasValue;
}

bool CGetEnvironmentListResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_EnvironmentFiles.unmarshall(ctx, soapval, "EnvironmentFiles");
	return hasValue;
}

bool CGetEnvironmentListResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_EnvironmentFiles.unmarshall(ctx, params, attachments, "EnvironmentFiles", basepath);
	return hasValue;
}

IArrayOf<IConstEnvironmentFileType> & CGetEnvironmentListResponse::getEnvironmentFiles() { return (IArrayOf<IConstEnvironmentFileType> &) m_EnvironmentFiles; }
void CGetEnvironmentListResponse::setEnvironmentFiles(IArrayOf<IEspEnvironmentFileType> &val)
{
	m_EnvironmentFiles->kill();
	IArrayOf<IConstEnvironmentFileType> &target = m_EnvironmentFiles.getValue();
	ForEachItemIn(idx, val)
	{
		IEspEnvironmentFileType &item = (val).item(idx);
		item.Link();
		target.append(item);
	}
}
void CGetEnvironmentListResponse::setEnvironmentFiles(IArrayOf<IConstEnvironmentFileType> &val)
{
	m_EnvironmentFiles->kill();
	IArrayOf<IConstEnvironmentFileType> &target = m_EnvironmentFiles.getValue();
	ForEachItemIn(idx, val)
	{
		IConstEnvironmentFileType &item = val.item(idx);
		item.Link();
		target.append(item);
	}
}
extern "C"  IEspGetEnvironmentListResponse *createGetEnvironmentListResponse(const char *serv){return ((IEspGetEnvironmentListResponse *)new CGetEnvironmentListResponse(serv));}
extern "C"  IClientGetEnvironmentListResponse *createClientGetEnvironmentListResponse(const char *serv){return ((IClientGetEnvironmentListResponse *)new CGetEnvironmentListResponse(serv));}

//=======================================================
// class COpenEnvironmentFileRequest Implementation
//=======================================================

COpenEnvironmentFileRequest::COpenEnvironmentFileRequest(const char *serviceName, IRpcMessageBinding *init)
	: m_SessionId(nilIgnore),m_Filename(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("OpenEnvironmentFileRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

COpenEnvironmentFileRequest::COpenEnvironmentFileRequest(const char *serviceName, const char *bc)
	: m_SessionId(nilIgnore),m_Filename(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("OpenEnvironmentFileRequest");
}

COpenEnvironmentFileRequest::COpenEnvironmentFileRequest(const char *serviceName, IRpcMessage* rpcmsg)
	: m_SessionId(nilIgnore),m_Filename(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("OpenEnvironmentFileRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

COpenEnvironmentFileRequest::COpenEnvironmentFileRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_SessionId(nilIgnore),m_Filename(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("OpenEnvironmentFileRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &COpenEnvironmentFileRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"SessionId\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Filename\" type=\"xsd:string\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void COpenEnvironmentFileRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void COpenEnvironmentFileRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &COpenEnvironmentFileRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("SessionId");
	form.appendf("  <tr><td><b>SessionId: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Filename");
	form.appendf("  <tr><td><b>Filename: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &COpenEnvironmentFileRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void COpenEnvironmentFileRequest::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_SessionId.marshall(rpc_resp, "SessionId", "", "", "");
	m_Filename.marshall(rpc_resp, "Filename", "", "", "");
}


void COpenEnvironmentFileRequest::copy(COpenEnvironmentFileRequest &from)
{
	m_SessionId.copy(from.m_SessionId);
	m_Filename.copy(from.m_Filename);
}


void COpenEnvironmentFileRequest::copy(IConstOpenEnvironmentFileRequest &ifrom)
{
	setSessionId(ifrom.getSessionId());
	setFilename(ifrom.getFilename());
}


void COpenEnvironmentFileRequest::getAttributes(IProperties &attributes)
{
}


void COpenEnvironmentFileRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_SessionId.toStr(ctx, buffer, "SessionId", "", true, "", "");
	m_Filename.toStr(ctx, buffer, "Filename", "", true, "", "");
}


void COpenEnvironmentFileRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void COpenEnvironmentFileRequest::serializer(IEspContext* ctx, IConstOpenEnvironmentFileRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<OpenEnvironmentFileRequest>");
	// field SessionId
	{
		const char* s = src.getSessionId();
		if (s && *s)
		{
			buffer.append("<SessionId>");
			encodeUtf8XML(s,buffer);
			buffer.append("</SessionId>");
		}
	}
	// field Filename
	{
		const char* s = src.getFilename();
		if (s && *s)
		{
			buffer.append("<Filename>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Filename>");
		}
	}
	if (keepRootTag)
		buffer.append("</OpenEnvironmentFileRequest>");
}

bool COpenEnvironmentFileRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_SessionId.unmarshall(rpc_request, "SessionId", basepath);
	hasValue |= m_Filename.unmarshall(rpc_request, "Filename", basepath);
	return hasValue;
}

bool COpenEnvironmentFileRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_SessionId.unmarshall(ctx, soapval, "SessionId");
	hasValue |= m_Filename.unmarshall(ctx, soapval, "Filename");
	return hasValue;
}

bool COpenEnvironmentFileRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_SessionId.unmarshall(ctx, params, attachments, "SessionId", basepath);
	hasValue |= m_Filename.unmarshall(ctx, params, attachments, "Filename", basepath);
	return hasValue;
}

const char * COpenEnvironmentFileRequest::getSessionId() { return m_SessionId.query();}
const char * COpenEnvironmentFileRequest::getFilename() { return m_Filename.query();}
void COpenEnvironmentFileRequest::setSessionId(const char * val){ m_SessionId.set(val); }
void COpenEnvironmentFileRequest::setFilename(const char * val){ m_Filename.set(val); }
extern "C"  IEspOpenEnvironmentFileRequest *createOpenEnvironmentFileRequest(const char *serv){return ((IEspOpenEnvironmentFileRequest *)new COpenEnvironmentFileRequest(serv));}
extern "C"  IClientOpenEnvironmentFileRequest *createClientOpenEnvironmentFileRequest(const char *serv){return ((IClientOpenEnvironmentFileRequest *)new COpenEnvironmentFileRequest(serv));}

//=======================================================
// class COpenEnvironmentFileResponse Implementation
//=======================================================

COpenEnvironmentFileResponse::COpenEnvironmentFileResponse(const char *serviceName, IRpcMessageBinding *init)
	: m_RootNodeId(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("OpenEnvironmentFileResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

COpenEnvironmentFileResponse::COpenEnvironmentFileResponse(const char *serviceName, const char *bc)
	: m_RootNodeId(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("OpenEnvironmentFileResponse");
}

COpenEnvironmentFileResponse::COpenEnvironmentFileResponse(const char *serviceName, IRpcMessage* rpcmsg)
	: m_RootNodeId(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("OpenEnvironmentFileResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

COpenEnvironmentFileResponse::COpenEnvironmentFileResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_RootNodeId(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("OpenEnvironmentFileResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &COpenEnvironmentFileResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		schema.append("<xsd:element name=\"Exceptions\" type=\"tns:ArrayOfEspException\" minOccurs=\"0\" maxOccurs=\"1\"/>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"RootNodeId\" type=\"xsd:string\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void COpenEnvironmentFileResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void COpenEnvironmentFileResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &COpenEnvironmentFileResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("RootNodeId");
	form.appendf("  <tr><td><b>RootNodeId: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &COpenEnvironmentFileResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void COpenEnvironmentFileResponse::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
		m_RootNodeId.marshall(rpc_resp, "RootNodeId", "", "", "");
	}
}


void COpenEnvironmentFileResponse::copy(COpenEnvironmentFileResponse &from)
{
	m_RootNodeId.copy(from.m_RootNodeId);
}


void COpenEnvironmentFileResponse::copy(IConstOpenEnvironmentFileResponse &ifrom)
{
	setRootNodeId(ifrom.getRootNodeId());
}


void COpenEnvironmentFileResponse::getAttributes(IProperties &attributes)
{
}


void COpenEnvironmentFileResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
		m_RootNodeId.toStr(ctx, buffer, "RootNodeId", "", true, "", "");
	}
}


void COpenEnvironmentFileResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void COpenEnvironmentFileResponse::serializer(IEspContext* ctx, IConstOpenEnvironmentFileResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<OpenEnvironmentFileResponse>");
	// field RootNodeId
	{
		const char* s = src.getRootNodeId();
		if (s && *s)
		{
			buffer.append("<RootNodeId>");
			encodeUtf8XML(s,buffer);
			buffer.append("</RootNodeId>");
		}
	}
	if (keepRootTag)
		buffer.append("</OpenEnvironmentFileResponse>");
}

bool COpenEnvironmentFileResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
		hasValue |= m_RootNodeId.unmarshall(rpc_request, "RootNodeId", basepath);
	}
	return hasValue;
}

bool COpenEnvironmentFileResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_RootNodeId.unmarshall(ctx, soapval, "RootNodeId");
	return hasValue;
}

bool COpenEnvironmentFileResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_RootNodeId.unmarshall(ctx, params, attachments, "RootNodeId", basepath);
	return hasValue;
}

const char * COpenEnvironmentFileResponse::getRootNodeId() { return m_RootNodeId.query();}
void COpenEnvironmentFileResponse::setRootNodeId(const char * val){ m_RootNodeId.set(val); }
extern "C"  IEspOpenEnvironmentFileResponse *createOpenEnvironmentFileResponse(const char *serv){return ((IEspOpenEnvironmentFileResponse *)new COpenEnvironmentFileResponse(serv));}
extern "C"  IClientOpenEnvironmentFileResponse *createClientOpenEnvironmentFileResponse(const char *serv){return ((IClientOpenEnvironmentFileResponse *)new COpenEnvironmentFileResponse(serv));}

//=======================================================
// class CCloseEnvironmentFileRequest Implementation
//=======================================================

CCloseEnvironmentFileRequest::CCloseEnvironmentFileRequest(const char *serviceName, IRpcMessageBinding *init)
	: m_SessionId(nilIgnore),m_SessionLockKey(nilIgnore),m_DiscardChanges(0, nilIgnore,false)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("CloseEnvironmentFileRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CCloseEnvironmentFileRequest::CCloseEnvironmentFileRequest(const char *serviceName, const char *bc)
	: m_SessionId(nilIgnore),m_SessionLockKey(nilIgnore),m_DiscardChanges(0, nilIgnore,false)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("CloseEnvironmentFileRequest");
}

CCloseEnvironmentFileRequest::CCloseEnvironmentFileRequest(const char *serviceName, IRpcMessage* rpcmsg)
	: m_SessionId(nilIgnore),m_SessionLockKey(nilIgnore),m_DiscardChanges(0, nilIgnore,false)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("CloseEnvironmentFileRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CCloseEnvironmentFileRequest::CCloseEnvironmentFileRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_SessionId(nilIgnore),m_SessionLockKey(nilIgnore),m_DiscardChanges(0, nilIgnore,false)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("CloseEnvironmentFileRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CCloseEnvironmentFileRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"SessionId\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"SessionLockKey\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" default=\"false\" name=\"DiscardChanges\" type=\"xsd:boolean\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CCloseEnvironmentFileRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CCloseEnvironmentFileRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CCloseEnvironmentFileRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("SessionId");
	form.appendf("  <tr><td><b>SessionId: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("SessionLockKey");
	form.appendf("  <tr><td><b>SessionLockKey: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("DiscardChanges");
	
	form.appendf("  <tr><td><b>DiscardChanges? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CCloseEnvironmentFileRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CCloseEnvironmentFileRequest::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_SessionId.marshall(rpc_resp, "SessionId", "", "", "");
	m_SessionLockKey.marshall(rpc_resp, "SessionLockKey", "", "", "");
	m_DiscardChanges.marshall(rpc_resp, "DiscardChanges", "", "", "");
}


void CCloseEnvironmentFileRequest::copy(CCloseEnvironmentFileRequest &from)
{
	m_SessionId.copy(from.m_SessionId);
	m_SessionLockKey.copy(from.m_SessionLockKey);
	m_DiscardChanges.copy(from.m_DiscardChanges);
}


void CCloseEnvironmentFileRequest::copy(IConstCloseEnvironmentFileRequest &ifrom)
{
	setSessionId(ifrom.getSessionId());
	setSessionLockKey(ifrom.getSessionLockKey());
	setDiscardChanges(ifrom.getDiscardChanges());
}


void CCloseEnvironmentFileRequest::getAttributes(IProperties &attributes)
{
}


void CCloseEnvironmentFileRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_SessionId.toStr(ctx, buffer, "SessionId", "", true, "", "");
	m_SessionLockKey.toStr(ctx, buffer, "SessionLockKey", "", true, "", "");
	m_DiscardChanges.toStr(ctx, buffer, "DiscardChanges", "", true, "", "");
}


void CCloseEnvironmentFileRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CCloseEnvironmentFileRequest::serializer(IEspContext* ctx, IConstCloseEnvironmentFileRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<CloseEnvironmentFileRequest>");
	// field SessionId
	{
		const char* s = src.getSessionId();
		if (s && *s)
		{
			buffer.append("<SessionId>");
			encodeUtf8XML(s,buffer);
			buffer.append("</SessionId>");
		}
	}
	// field SessionLockKey
	{
		const char* s = src.getSessionLockKey();
		if (s && *s)
		{
			buffer.append("<SessionLockKey>");
			encodeUtf8XML(s,buffer);
			buffer.append("</SessionLockKey>");
		}
	}
	// field DiscardChanges
	{
		bool b = src.getDiscardChanges();
		if (b)
			buffer.appendf("<DiscardChanges>1</DiscardChanges>");
	}
	if (keepRootTag)
		buffer.append("</CloseEnvironmentFileRequest>");
}

bool CCloseEnvironmentFileRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_SessionId.unmarshall(rpc_request, "SessionId", basepath);
	hasValue |= m_SessionLockKey.unmarshall(rpc_request, "SessionLockKey", basepath);
	hasValue |= m_DiscardChanges.unmarshall(rpc_request, "DiscardChanges", basepath);
	return hasValue;
}

bool CCloseEnvironmentFileRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_SessionId.unmarshall(ctx, soapval, "SessionId");
	hasValue |= m_SessionLockKey.unmarshall(ctx, soapval, "SessionLockKey");
	hasValue |= m_DiscardChanges.unmarshall(ctx, soapval, "DiscardChanges");
	return hasValue;
}

bool CCloseEnvironmentFileRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_SessionId.unmarshall(ctx, params, attachments, "SessionId", basepath);
	hasValue |= m_SessionLockKey.unmarshall(ctx, params, attachments, "SessionLockKey", basepath);
	hasValue |= m_DiscardChanges.unmarshall(ctx, params, attachments, "DiscardChanges", basepath);
	return hasValue;
}

const char * CCloseEnvironmentFileRequest::getSessionId() { return m_SessionId.query();}
const char * CCloseEnvironmentFileRequest::getSessionLockKey() { return m_SessionLockKey.query();}
bool CCloseEnvironmentFileRequest::getDiscardChanges() { return m_DiscardChanges;}
void CCloseEnvironmentFileRequest::setSessionId(const char * val){ m_SessionId.set(val); }
void CCloseEnvironmentFileRequest::setSessionLockKey(const char * val){ m_SessionLockKey.set(val); }
void CCloseEnvironmentFileRequest::setDiscardChanges(bool val){ m_DiscardChanges=val; }
extern "C"  IEspCloseEnvironmentFileRequest *createCloseEnvironmentFileRequest(const char *serv){return ((IEspCloseEnvironmentFileRequest *)new CCloseEnvironmentFileRequest(serv));}
extern "C"  IClientCloseEnvironmentFileRequest *createClientCloseEnvironmentFileRequest(const char *serv){return ((IClientCloseEnvironmentFileRequest *)new CCloseEnvironmentFileRequest(serv));}

//=======================================================
// class CSaveEnvironmentFileRequest Implementation
//=======================================================

CSaveEnvironmentFileRequest::CSaveEnvironmentFileRequest(const char *serviceName, IRpcMessageBinding *init)
	: m_SessionId(nilIgnore),m_SessionLockKey(nilIgnore),m_Filename("", nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("SaveEnvironmentFileRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CSaveEnvironmentFileRequest::CSaveEnvironmentFileRequest(const char *serviceName, const char *bc)
	: m_SessionId(nilIgnore),m_SessionLockKey(nilIgnore),m_Filename("", nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("SaveEnvironmentFileRequest");
}

CSaveEnvironmentFileRequest::CSaveEnvironmentFileRequest(const char *serviceName, IRpcMessage* rpcmsg)
	: m_SessionId(nilIgnore),m_SessionLockKey(nilIgnore),m_Filename("", nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("SaveEnvironmentFileRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CSaveEnvironmentFileRequest::CSaveEnvironmentFileRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_SessionId(nilIgnore),m_SessionLockKey(nilIgnore),m_Filename("", nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("SaveEnvironmentFileRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CSaveEnvironmentFileRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"SessionId\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"SessionLockKey\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" default=\"\" name=\"Filename\" type=\"xsd:string\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CSaveEnvironmentFileRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CSaveEnvironmentFileRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CSaveEnvironmentFileRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("SessionId");
	form.appendf("  <tr><td><b>SessionId: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("SessionLockKey");
	form.appendf("  <tr><td><b>SessionLockKey: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Filename");
	form.appendf("  <tr><td><b>Filename: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CSaveEnvironmentFileRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CSaveEnvironmentFileRequest::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_SessionId.marshall(rpc_resp, "SessionId", "", "", "");
	m_SessionLockKey.marshall(rpc_resp, "SessionLockKey", "", "", "");
	m_Filename.marshall(rpc_resp, "Filename", "", "", "");
}


void CSaveEnvironmentFileRequest::copy(CSaveEnvironmentFileRequest &from)
{
	m_SessionId.copy(from.m_SessionId);
	m_SessionLockKey.copy(from.m_SessionLockKey);
	m_Filename.copy(from.m_Filename);
}


void CSaveEnvironmentFileRequest::copy(IConstSaveEnvironmentFileRequest &ifrom)
{
	setSessionId(ifrom.getSessionId());
	setSessionLockKey(ifrom.getSessionLockKey());
	setFilename(ifrom.getFilename());
}


void CSaveEnvironmentFileRequest::getAttributes(IProperties &attributes)
{
}


void CSaveEnvironmentFileRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_SessionId.toStr(ctx, buffer, "SessionId", "", true, "", "");
	m_SessionLockKey.toStr(ctx, buffer, "SessionLockKey", "", true, "", "");
	m_Filename.toStr(ctx, buffer, "Filename", "", true, "", "");
}


void CSaveEnvironmentFileRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CSaveEnvironmentFileRequest::serializer(IEspContext* ctx, IConstSaveEnvironmentFileRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<SaveEnvironmentFileRequest>");
	// field SessionId
	{
		const char* s = src.getSessionId();
		if (s && *s)
		{
			buffer.append("<SessionId>");
			encodeUtf8XML(s,buffer);
			buffer.append("</SessionId>");
		}
	}
	// field SessionLockKey
	{
		const char* s = src.getSessionLockKey();
		if (s && *s)
		{
			buffer.append("<SessionLockKey>");
			encodeUtf8XML(s,buffer);
			buffer.append("</SessionLockKey>");
		}
	}
	// field Filename
	{
		const char* s = src.getFilename();
		if (s && *s)
		{
			buffer.append("<Filename>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Filename>");
		}
	}
	if (keepRootTag)
		buffer.append("</SaveEnvironmentFileRequest>");
}

bool CSaveEnvironmentFileRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_SessionId.unmarshall(rpc_request, "SessionId", basepath);
	hasValue |= m_SessionLockKey.unmarshall(rpc_request, "SessionLockKey", basepath);
	hasValue |= m_Filename.unmarshall(rpc_request, "Filename", basepath);
	return hasValue;
}

bool CSaveEnvironmentFileRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_SessionId.unmarshall(ctx, soapval, "SessionId");
	hasValue |= m_SessionLockKey.unmarshall(ctx, soapval, "SessionLockKey");
	hasValue |= m_Filename.unmarshall(ctx, soapval, "Filename");
	return hasValue;
}

bool CSaveEnvironmentFileRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_SessionId.unmarshall(ctx, params, attachments, "SessionId", basepath);
	hasValue |= m_SessionLockKey.unmarshall(ctx, params, attachments, "SessionLockKey", basepath);
	hasValue |= m_Filename.unmarshall(ctx, params, attachments, "Filename", basepath);
	return hasValue;
}

const char * CSaveEnvironmentFileRequest::getSessionId() { return m_SessionId.query();}
const char * CSaveEnvironmentFileRequest::getSessionLockKey() { return m_SessionLockKey.query();}
const char * CSaveEnvironmentFileRequest::getFilename() { return m_Filename.query();}
void CSaveEnvironmentFileRequest::setSessionId(const char * val){ m_SessionId.set(val); }
void CSaveEnvironmentFileRequest::setSessionLockKey(const char * val){ m_SessionLockKey.set(val); }
void CSaveEnvironmentFileRequest::setFilename(const char * val){ m_Filename.set(val); }
extern "C"  IEspSaveEnvironmentFileRequest *createSaveEnvironmentFileRequest(const char *serv){return ((IEspSaveEnvironmentFileRequest *)new CSaveEnvironmentFileRequest(serv));}
extern "C"  IClientSaveEnvironmentFileRequest *createClientSaveEnvironmentFileRequest(const char *serv){return ((IClientSaveEnvironmentFileRequest *)new CSaveEnvironmentFileRequest(serv));}

//=======================================================
// class CLockSessionResponse Implementation
//=======================================================

CLockSessionResponse::CLockSessionResponse(const char *serviceName, IRpcMessageBinding *init)
	: m_SessionLockKey(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("LockSessionResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CLockSessionResponse::CLockSessionResponse(const char *serviceName, const char *bc)
	: m_SessionLockKey(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("LockSessionResponse");
}

CLockSessionResponse::CLockSessionResponse(const char *serviceName, IRpcMessage* rpcmsg)
	: m_SessionLockKey(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("LockSessionResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CLockSessionResponse::CLockSessionResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_SessionLockKey(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("LockSessionResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CLockSessionResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		schema.append("<xsd:element name=\"Exceptions\" type=\"tns:ArrayOfEspException\" minOccurs=\"0\" maxOccurs=\"1\"/>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"SessionLockKey\" type=\"xsd:string\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CLockSessionResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CLockSessionResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CLockSessionResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("SessionLockKey");
	form.appendf("  <tr><td><b>SessionLockKey: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CLockSessionResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CLockSessionResponse::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
		m_SessionLockKey.marshall(rpc_resp, "SessionLockKey", "", "", "");
	}
}


void CLockSessionResponse::copy(CLockSessionResponse &from)
{
	m_SessionLockKey.copy(from.m_SessionLockKey);
}


void CLockSessionResponse::copy(IConstLockSessionResponse &ifrom)
{
	setSessionLockKey(ifrom.getSessionLockKey());
}


void CLockSessionResponse::getAttributes(IProperties &attributes)
{
}


void CLockSessionResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
		m_SessionLockKey.toStr(ctx, buffer, "SessionLockKey", "", true, "", "");
	}
}


void CLockSessionResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CLockSessionResponse::serializer(IEspContext* ctx, IConstLockSessionResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<LockSessionResponse>");
	// field SessionLockKey
	{
		const char* s = src.getSessionLockKey();
		if (s && *s)
		{
			buffer.append("<SessionLockKey>");
			encodeUtf8XML(s,buffer);
			buffer.append("</SessionLockKey>");
		}
	}
	if (keepRootTag)
		buffer.append("</LockSessionResponse>");
}

bool CLockSessionResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
		hasValue |= m_SessionLockKey.unmarshall(rpc_request, "SessionLockKey", basepath);
	}
	return hasValue;
}

bool CLockSessionResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_SessionLockKey.unmarshall(ctx, soapval, "SessionLockKey");
	return hasValue;
}

bool CLockSessionResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_SessionLockKey.unmarshall(ctx, params, attachments, "SessionLockKey", basepath);
	return hasValue;
}

const char * CLockSessionResponse::getSessionLockKey() { return m_SessionLockKey.query();}
void CLockSessionResponse::setSessionLockKey(const char * val){ m_SessionLockKey.set(val); }
extern "C"  IEspLockSessionResponse *createLockSessionResponse(const char *serv){return ((IEspLockSessionResponse *)new CLockSessionResponse(serv));}
extern "C"  IClientLockSessionResponse *createClientLockSessionResponse(const char *serv){return ((IClientLockSessionResponse *)new CLockSessionResponse(serv));}

//=======================================================
// class CUnlockSessionRequest Implementation
//=======================================================

CUnlockSessionRequest::CUnlockSessionRequest(const char *serviceName, IRpcMessageBinding *init)
	: m_SessionId(nilIgnore),m_SessionLockKey(nilIgnore),m_RejectIfModified(1, nilIgnore,false)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("UnlockSessionRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CUnlockSessionRequest::CUnlockSessionRequest(const char *serviceName, const char *bc)
	: m_SessionId(nilIgnore),m_SessionLockKey(nilIgnore),m_RejectIfModified(1, nilIgnore,false)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("UnlockSessionRequest");
}

CUnlockSessionRequest::CUnlockSessionRequest(const char *serviceName, IRpcMessage* rpcmsg)
	: m_SessionId(nilIgnore),m_SessionLockKey(nilIgnore),m_RejectIfModified(1, nilIgnore,false)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("UnlockSessionRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CUnlockSessionRequest::CUnlockSessionRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_SessionId(nilIgnore),m_SessionLockKey(nilIgnore),m_RejectIfModified(1, nilIgnore,false)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("UnlockSessionRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CUnlockSessionRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"SessionId\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"SessionLockKey\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" default=\"true\" name=\"RejectIfModified\" type=\"xsd:boolean\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CUnlockSessionRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CUnlockSessionRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CUnlockSessionRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("SessionId");
	form.appendf("  <tr><td><b>SessionId: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("SessionLockKey");
	form.appendf("  <tr><td><b>SessionLockKey: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("RejectIfModified");
	
	form.appendf("  <tr><td><b>RejectIfModified? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\" checked=\"1\" /></td></tr>\n", extfix.str());
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CUnlockSessionRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CUnlockSessionRequest::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_SessionId.marshall(rpc_resp, "SessionId", "", "", "");
	m_SessionLockKey.marshall(rpc_resp, "SessionLockKey", "", "", "");
	m_RejectIfModified.marshall(rpc_resp, "RejectIfModified", "", "", "");
}


void CUnlockSessionRequest::copy(CUnlockSessionRequest &from)
{
	m_SessionId.copy(from.m_SessionId);
	m_SessionLockKey.copy(from.m_SessionLockKey);
	m_RejectIfModified.copy(from.m_RejectIfModified);
}


void CUnlockSessionRequest::copy(IConstUnlockSessionRequest &ifrom)
{
	setSessionId(ifrom.getSessionId());
	setSessionLockKey(ifrom.getSessionLockKey());
	setRejectIfModified(ifrom.getRejectIfModified());
}


void CUnlockSessionRequest::getAttributes(IProperties &attributes)
{
}


void CUnlockSessionRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_SessionId.toStr(ctx, buffer, "SessionId", "", true, "", "");
	m_SessionLockKey.toStr(ctx, buffer, "SessionLockKey", "", true, "", "");
	m_RejectIfModified.toStr(ctx, buffer, "RejectIfModified", "", true, "", "");
}


void CUnlockSessionRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CUnlockSessionRequest::serializer(IEspContext* ctx, IConstUnlockSessionRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<UnlockSessionRequest>");
	// field SessionId
	{
		const char* s = src.getSessionId();
		if (s && *s)
		{
			buffer.append("<SessionId>");
			encodeUtf8XML(s,buffer);
			buffer.append("</SessionId>");
		}
	}
	// field SessionLockKey
	{
		const char* s = src.getSessionLockKey();
		if (s && *s)
		{
			buffer.append("<SessionLockKey>");
			encodeUtf8XML(s,buffer);
			buffer.append("</SessionLockKey>");
		}
	}
	// field RejectIfModified
	{
		bool b = src.getRejectIfModified();
		if (b)
			buffer.appendf("<RejectIfModified>1</RejectIfModified>");
	}
	if (keepRootTag)
		buffer.append("</UnlockSessionRequest>");
}

bool CUnlockSessionRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_SessionId.unmarshall(rpc_request, "SessionId", basepath);
	hasValue |= m_SessionLockKey.unmarshall(rpc_request, "SessionLockKey", basepath);
	hasValue |= m_RejectIfModified.unmarshall(rpc_request, "RejectIfModified", basepath);
	return hasValue;
}

bool CUnlockSessionRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_SessionId.unmarshall(ctx, soapval, "SessionId");
	hasValue |= m_SessionLockKey.unmarshall(ctx, soapval, "SessionLockKey");
	hasValue |= m_RejectIfModified.unmarshall(ctx, soapval, "RejectIfModified");
	return hasValue;
}

bool CUnlockSessionRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_SessionId.unmarshall(ctx, params, attachments, "SessionId", basepath);
	hasValue |= m_SessionLockKey.unmarshall(ctx, params, attachments, "SessionLockKey", basepath);
	hasValue |= m_RejectIfModified.unmarshall(ctx, params, attachments, "RejectIfModified", basepath);
	return hasValue;
}

const char * CUnlockSessionRequest::getSessionId() { return m_SessionId.query();}
const char * CUnlockSessionRequest::getSessionLockKey() { return m_SessionLockKey.query();}
bool CUnlockSessionRequest::getRejectIfModified() { return m_RejectIfModified;}
void CUnlockSessionRequest::setSessionId(const char * val){ m_SessionId.set(val); }
void CUnlockSessionRequest::setSessionLockKey(const char * val){ m_SessionLockKey.set(val); }
void CUnlockSessionRequest::setRejectIfModified(bool val){ m_RejectIfModified=val; }
extern "C"  IEspUnlockSessionRequest *createUnlockSessionRequest(const char *serv){return ((IEspUnlockSessionRequest *)new CUnlockSessionRequest(serv));}
extern "C"  IClientUnlockSessionRequest *createClientUnlockSessionRequest(const char *serv){return ((IClientUnlockSessionRequest *)new CUnlockSessionRequest(serv));}

//=======================================================
// class CValidateEnvironmentRequest Implementation
//=======================================================

CValidateEnvironmentRequest::CValidateEnvironmentRequest(const char *serviceName, IRpcMessageBinding *init)
	: m_SessionId(nilIgnore),m_IncludeHiddenNodes(0, nilIgnore,false)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ValidateEnvironmentRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CValidateEnvironmentRequest::CValidateEnvironmentRequest(const char *serviceName, const char *bc)
	: m_SessionId(nilIgnore),m_IncludeHiddenNodes(0, nilIgnore,false)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ValidateEnvironmentRequest");
}

CValidateEnvironmentRequest::CValidateEnvironmentRequest(const char *serviceName, IRpcMessage* rpcmsg)
	: m_SessionId(nilIgnore),m_IncludeHiddenNodes(0, nilIgnore,false)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ValidateEnvironmentRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CValidateEnvironmentRequest::CValidateEnvironmentRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_SessionId(nilIgnore),m_IncludeHiddenNodes(0, nilIgnore,false)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ValidateEnvironmentRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CValidateEnvironmentRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"SessionId\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" default=\"false\" name=\"IncludeHiddenNodes\" type=\"xsd:boolean\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CValidateEnvironmentRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CValidateEnvironmentRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CValidateEnvironmentRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("SessionId");
	form.appendf("  <tr><td><b>SessionId: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("IncludeHiddenNodes");
	
	form.appendf("  <tr><td><b>IncludeHiddenNodes? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CValidateEnvironmentRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CValidateEnvironmentRequest::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_SessionId.marshall(rpc_resp, "SessionId", "", "", "");
	m_IncludeHiddenNodes.marshall(rpc_resp, "IncludeHiddenNodes", "", "", "");
}


void CValidateEnvironmentRequest::copy(CValidateEnvironmentRequest &from)
{
	m_SessionId.copy(from.m_SessionId);
	m_IncludeHiddenNodes.copy(from.m_IncludeHiddenNodes);
}


void CValidateEnvironmentRequest::copy(IConstValidateEnvironmentRequest &ifrom)
{
	setSessionId(ifrom.getSessionId());
	setIncludeHiddenNodes(ifrom.getIncludeHiddenNodes());
}


void CValidateEnvironmentRequest::getAttributes(IProperties &attributes)
{
}


void CValidateEnvironmentRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_SessionId.toStr(ctx, buffer, "SessionId", "", true, "", "");
	m_IncludeHiddenNodes.toStr(ctx, buffer, "IncludeHiddenNodes", "", true, "", "");
}


void CValidateEnvironmentRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CValidateEnvironmentRequest::serializer(IEspContext* ctx, IConstValidateEnvironmentRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<ValidateEnvironmentRequest>");
	// field SessionId
	{
		const char* s = src.getSessionId();
		if (s && *s)
		{
			buffer.append("<SessionId>");
			encodeUtf8XML(s,buffer);
			buffer.append("</SessionId>");
		}
	}
	// field IncludeHiddenNodes
	{
		bool b = src.getIncludeHiddenNodes();
		if (b)
			buffer.appendf("<IncludeHiddenNodes>1</IncludeHiddenNodes>");
	}
	if (keepRootTag)
		buffer.append("</ValidateEnvironmentRequest>");
}

bool CValidateEnvironmentRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_SessionId.unmarshall(rpc_request, "SessionId", basepath);
	hasValue |= m_IncludeHiddenNodes.unmarshall(rpc_request, "IncludeHiddenNodes", basepath);
	return hasValue;
}

bool CValidateEnvironmentRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_SessionId.unmarshall(ctx, soapval, "SessionId");
	hasValue |= m_IncludeHiddenNodes.unmarshall(ctx, soapval, "IncludeHiddenNodes");
	return hasValue;
}

bool CValidateEnvironmentRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_SessionId.unmarshall(ctx, params, attachments, "SessionId", basepath);
	hasValue |= m_IncludeHiddenNodes.unmarshall(ctx, params, attachments, "IncludeHiddenNodes", basepath);
	return hasValue;
}

const char * CValidateEnvironmentRequest::getSessionId() { return m_SessionId.query();}
bool CValidateEnvironmentRequest::getIncludeHiddenNodes() { return m_IncludeHiddenNodes;}
void CValidateEnvironmentRequest::setSessionId(const char * val){ m_SessionId.set(val); }
void CValidateEnvironmentRequest::setIncludeHiddenNodes(bool val){ m_IncludeHiddenNodes=val; }
extern "C"  IEspValidateEnvironmentRequest *createValidateEnvironmentRequest(const char *serv){return ((IEspValidateEnvironmentRequest *)new CValidateEnvironmentRequest(serv));}
extern "C"  IClientValidateEnvironmentRequest *createClientValidateEnvironmentRequest(const char *serv){return ((IClientValidateEnvironmentRequest *)new CValidateEnvironmentRequest(serv));}

//=======================================================
// class CGetTreeRequest Implementation
//=======================================================

CGetTreeRequest::CGetTreeRequest(const char *serviceName, IRpcMessageBinding *init)
	: m_SessionId(nilIgnore),m_NodeId(nilIgnore),m_IncludeAttributes(nilIgnore),m_NumLevels(1, nilIgnore,false)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetTreeRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CGetTreeRequest::CGetTreeRequest(const char *serviceName, const char *bc)
	: m_SessionId(nilIgnore),m_NodeId(nilIgnore),m_IncludeAttributes(nilIgnore),m_NumLevels(1, nilIgnore,false)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetTreeRequest");
}

CGetTreeRequest::CGetTreeRequest(const char *serviceName, IRpcMessage* rpcmsg)
	: m_SessionId(nilIgnore),m_NodeId(nilIgnore),m_IncludeAttributes(nilIgnore),m_NumLevels(1, nilIgnore,false)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetTreeRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CGetTreeRequest::CGetTreeRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_SessionId(nilIgnore),m_NodeId(nilIgnore),m_IncludeAttributes(nilIgnore),m_NumLevels(1, nilIgnore,false)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetTreeRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CGetTreeRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"SessionId\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"NodeId\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"IncludeAttributes\" type=\"xsd:boolean\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" default=\"1\" name=\"NumLevels\" type=\"xsd:int\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CGetTreeRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CGetTreeRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CGetTreeRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("SessionId");
	form.appendf("  <tr><td><b>SessionId: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("NodeId");
	form.appendf("  <tr><td><b>NodeId: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("IncludeAttributes");
	
	form.appendf("  <tr><td><b>IncludeAttributes? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	extfix.clear();
	if (prefix && *prefix) extfix.append(prefix).append(".");
		extfix.append("NumLevels");
	form.appendf("  <tr><td><b>NumLevels: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"	 value=\"1\"/>", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CGetTreeRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CGetTreeRequest::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_SessionId.marshall(rpc_resp, "SessionId", "", "", "");
	m_NodeId.marshall(rpc_resp, "NodeId", "", "", "");
	m_IncludeAttributes.marshall(rpc_resp, "IncludeAttributes", "", "", "");
	m_NumLevels.marshall(rpc_resp, "NumLevels", "", "", "");
}


void CGetTreeRequest::copy(CGetTreeRequest &from)
{
	m_SessionId.copy(from.m_SessionId);
	m_NodeId.copy(from.m_NodeId);
	m_IncludeAttributes.copy(from.m_IncludeAttributes);
	m_NumLevels.copy(from.m_NumLevels);
}


void CGetTreeRequest::copy(IConstGetTreeRequest &ifrom)
{
	setSessionId(ifrom.getSessionId());
	setNodeId(ifrom.getNodeId());
	setIncludeAttributes(ifrom.getIncludeAttributes());
	setNumLevels(ifrom.getNumLevels());
}


void CGetTreeRequest::getAttributes(IProperties &attributes)
{
}


void CGetTreeRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_SessionId.toStr(ctx, buffer, "SessionId", "", true, "", "");
	m_NodeId.toStr(ctx, buffer, "NodeId", "", true, "", "");
	m_IncludeAttributes.toStr(ctx, buffer, "IncludeAttributes", "", true, "", "");
	m_NumLevels.toStr(ctx, buffer, "NumLevels", "", true, "", "");
}


void CGetTreeRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CGetTreeRequest::serializer(IEspContext* ctx, IConstGetTreeRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<GetTreeRequest>");
	// field SessionId
	{
		const char* s = src.getSessionId();
		if (s && *s)
		{
			buffer.append("<SessionId>");
			encodeUtf8XML(s,buffer);
			buffer.append("</SessionId>");
		}
	}
	// field NodeId
	{
		const char* s = src.getNodeId();
		if (s && *s)
		{
			buffer.append("<NodeId>");
			encodeUtf8XML(s,buffer);
			buffer.append("</NodeId>");
		}
	}
	// field IncludeAttributes
	{
		bool b = src.getIncludeAttributes();
		if (b)
			buffer.appendf("<IncludeAttributes>1</IncludeAttributes>");
	}
	// field NumLevels
	{
		int n = src.getNumLevels();
		if (n)
			buffer.appendf("<NumLevels>%d</NumLevels>", n);
	}
	if (keepRootTag)
		buffer.append("</GetTreeRequest>");
}

bool CGetTreeRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_SessionId.unmarshall(rpc_request, "SessionId", basepath);
	hasValue |= m_NodeId.unmarshall(rpc_request, "NodeId", basepath);
	hasValue |= m_IncludeAttributes.unmarshall(rpc_request, "IncludeAttributes", basepath);
	hasValue |= m_NumLevels.unmarshall(rpc_request, "NumLevels", basepath);
	return hasValue;
}

bool CGetTreeRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_SessionId.unmarshall(ctx, soapval, "SessionId");
	hasValue |= m_NodeId.unmarshall(ctx, soapval, "NodeId");
	hasValue |= m_IncludeAttributes.unmarshall(ctx, soapval, "IncludeAttributes");
	hasValue |= m_NumLevels.unmarshall(ctx, soapval, "NumLevels");
	return hasValue;
}

bool CGetTreeRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_SessionId.unmarshall(ctx, params, attachments, "SessionId", basepath);
	hasValue |= m_NodeId.unmarshall(ctx, params, attachments, "NodeId", basepath);
	hasValue |= m_IncludeAttributes.unmarshall(ctx, params, attachments, "IncludeAttributes", basepath);
	hasValue |= m_NumLevels.unmarshall(ctx, params, attachments, "NumLevels", basepath);
	return hasValue;
}

const char * CGetTreeRequest::getSessionId() { return m_SessionId.query();}
const char * CGetTreeRequest::getNodeId() { return m_NodeId.query();}
bool CGetTreeRequest::getIncludeAttributes() { return m_IncludeAttributes;}
int CGetTreeRequest::getNumLevels() { return m_NumLevels;}
void CGetTreeRequest::setSessionId(const char * val){ m_SessionId.set(val); }
void CGetTreeRequest::setNodeId(const char * val){ m_NodeId.set(val); }
void CGetTreeRequest::setIncludeAttributes(bool val){ m_IncludeAttributes=val; }
void CGetTreeRequest::setNumLevels(int val){ m_NumLevels=val; }
extern "C"  IEspGetTreeRequest *createGetTreeRequest(const char *serv){return ((IEspGetTreeRequest *)new CGetTreeRequest(serv));}
extern "C"  IClientGetTreeRequest *createClientGetTreeRequest(const char *serv){return ((IClientGetTreeRequest *)new CGetTreeRequest(serv));}

//=======================================================
// class CTreeElementType Implementation
//=======================================================

CTreeElementType::CTreeElementType(const char *serviceName, IRpcMessageBinding *init)
	: m_NodeId(nilIgnore),m_NodeInfo(serviceName, nilIgnore),m_Attributes(nilIgnore),m_Children(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("TreeElementType");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CTreeElementType::CTreeElementType(const char *serviceName, const char *bc)
	: m_NodeId(nilIgnore),m_NodeInfo(serviceName, nilIgnore),m_Attributes(nilIgnore),m_Children(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("TreeElementType");
}

StringBuffer &CTreeElementType::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:complexType name=\"%s\">\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"NodeId\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"NodeInfo\" type=\"tns:NodeInfoType\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Attributes\">\n");
		schema.append("<xsd:complexType><xsd:sequence>\n");
		schema.append("<xsd:element minOccurs=\"0\" maxOccurs=\"unbounded\" name=\"attribute\" type=\"tns:AttributeType\"/>");
		schema.append("</xsd:sequence></xsd:complexType>");
		schema.append("</xsd:element>");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Children\">\n");
		schema.append("<xsd:complexType><xsd:sequence>\n");
		schema.append("<xsd:element minOccurs=\"0\" maxOccurs=\"unbounded\" name=\"Element\" type=\"tns:TreeElementType\"/>");
		schema.append("</xsd:sequence></xsd:complexType>");
		schema.append("</xsd:element>");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType>\n");
		}
	}
	if (!(flags & 0x10)  || (flags & 0x100))
	{
		CNodeInfoType::getXsdDefinition(context, request, schema, added);
		CAttributeType::getXsdDefinition(context, request, schema, added);
	}
	return schema;
}

void CTreeElementType::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CTreeElementType::getMapInfo(IMapInfo& info, BoolHash& added)
{
	if (!added.getValue("AttributeType"))
	{
		added.setValue("AttributeType",1);
		CAttributeType::getMapInfo(info,added);
	}
	if (!added.getValue("NodeInfoType"))
	{
		added.setValue("NodeInfoType",1);
		CNodeInfoType::getMapInfo(info,added);
	}
}

StringBuffer &CTreeElementType::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("NodeId");
	form.appendf("  <tr><td><b>NodeId: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("NodeInfo");
	form.append("<tr>").append("<td><b>NodeInfo: </b></td><td><hr/>");
	CNodeInfoType::getHtmlForm(context, request, serv, method, form, false, extfix.str());
	form.append("<hr/></td></tr>");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Attributes");
	form.appendf("<tr><td><b>Attributes: </b></td><td>");
	form.appendf("<table><tr><td><textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea></td>", extfix.str());
	form.append("</tr></table>");
	form.append("</td></tr>");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Children");
	form.appendf("<tr><td><b>Children: </b></td><td>");
	form.appendf("<table><tr><td><textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea></td>", extfix.str());
	form.append("</tr></table>");
	form.append("</td></tr>");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CTreeElementType::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CTreeElementType::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_NodeId.marshall(rpc_resp, "NodeId", "", "", "");
	m_NodeInfo.marshall(rpc_resp, "NodeInfo", "", "", "");
	m_Attributes.marshall(rpc_resp, "Attributes", "attribute");
	m_Children.marshall(rpc_resp, "Children", "Element");
}


void CTreeElementType::copy(CTreeElementType &from)
{
	m_NodeId.copy(from.m_NodeId);
	m_NodeInfo.copy(from.m_NodeInfo);
	m_Attributes.copy(from.m_Attributes);
	m_Children.copy(from.m_Children);
}


void CTreeElementType::copy(IConstTreeElementType &ifrom)
{
	setNodeId(ifrom.getNodeId());
	setNodeInfo(ifrom.getNodeInfo());
	setAttributes(ifrom.getAttributes());
	setChildren(ifrom.getChildren());
}


void CTreeElementType::getAttributes(IProperties &attributes)
{
}


void CTreeElementType::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_NodeId.toStr(ctx, buffer, "NodeId", "", true, "", "");
	m_NodeInfo.toStr(ctx, buffer, "NodeInfo", "", false, "", "");
	m_Attributes.toStr(ctx, buffer, "Attributes", "attribute");
	m_Children.toStr(ctx, buffer, "Children", "Element");
}


void CTreeElementType::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CTreeElementType::serializer(IEspContext* ctx, IConstTreeElementType &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<TreeElementType>");
	// field NodeId
	{
		const char* s = src.getNodeId();
		if (s && *s)
		{
			buffer.append("<NodeId>");
			encodeUtf8XML(s,buffer);
			buffer.append("</NodeId>");
		}
	}
	// field NodeInfo
	{
		StringBuffer tmp;
		CNodeInfoType::serializer(ctx,src.getNodeInfo(), tmp, false);
		if (tmp.length()>0)
			buffer.appendf("<NodeInfo>%s</NodeInfo>",tmp.str());
	}
	// field Attributes
	{
		IArrayOf<IConstAttributeType>& v = src.getAttributes();
		int size = v.length();
		if (size>0)
			buffer.append("<Attributes>");
		for (int i=0;i<size;i++)
		{
			buffer.append("<attribute>");
			CAttributeType::serializer(ctx,v.item(i),buffer,false);
			buffer.append("</attribute>");
		}
		if (size>0)
			buffer.append("</Attributes>");
	}
	// field Children
	{
		IArrayOf<IConstTreeElementType>& v = src.getChildren();
		int size = v.length();
		if (size>0)
			buffer.append("<Children>");
		for (int i=0;i<size;i++)
		{
			buffer.append("<Element>");
			CTreeElementType::serializer(ctx,v.item(i),buffer,false);
			buffer.append("</Element>");
		}
		if (size>0)
			buffer.append("</Children>");
	}
	if (keepRootTag)
		buffer.append("</TreeElementType>");
}

bool CTreeElementType::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_NodeId.unmarshall(rpc_request, "NodeId", basepath);
	hasValue |= m_NodeInfo.unmarshall(rpc_request, "NodeInfo", basepath);
	hasValue |= m_Attributes.unmarshall(rpc_request, "Attributes", basepath);
	hasValue |= m_Children.unmarshall(rpc_request, "Children", basepath);
	return hasValue;
}

bool CTreeElementType::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_NodeId.unmarshall(ctx, soapval, "NodeId");
	hasValue |= m_NodeInfo.unmarshall(ctx, soapval, "NodeInfo");
	hasValue |= m_Attributes.unmarshall(ctx, soapval, "Attributes");
	hasValue |= m_Children.unmarshall(ctx, soapval, "Children");
	return hasValue;
}

bool CTreeElementType::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_NodeId.unmarshall(ctx, params, attachments, "NodeId", basepath);
	hasValue |= m_NodeInfo.unmarshall(ctx, params, attachments, "NodeInfo", basepath);
	hasValue |= m_Attributes.unmarshall(ctx, params, attachments, "Attributes", basepath);
	hasValue |= m_Children.unmarshall(ctx, params, attachments, "Children", basepath);
	return hasValue;
}

const char * CTreeElementType::getNodeId() { return m_NodeId.query();}
IConstNodeInfoType & CTreeElementType::getNodeInfo() { return (IConstNodeInfoType &) m_NodeInfo.getValue();}
IArrayOf<IConstAttributeType> & CTreeElementType::getAttributes() { return (IArrayOf<IConstAttributeType> &) m_Attributes; }
IArrayOf<IConstTreeElementType> & CTreeElementType::getChildren() { return (IArrayOf<IConstTreeElementType> &) m_Children; }
void CTreeElementType::setNodeId(const char * val){ m_NodeId.set(val); }
IEspNodeInfoType & CTreeElementType::updateNodeInfo(){ return (IEspNodeInfoType &) m_NodeInfo.getValue(); }
void CTreeElementType::setNodeInfo(IConstNodeInfoType &ifrom){ m_NodeInfo.copy(ifrom); }
void CTreeElementType::setAttributes(IArrayOf<IEspAttributeType> &val)
{
	m_Attributes->kill();
	IArrayOf<IConstAttributeType> &target = m_Attributes.getValue();
	ForEachItemIn(idx, val)
	{
		IEspAttributeType &item = (val).item(idx);
		item.Link();
		target.append(item);
	}
}
void CTreeElementType::setAttributes(IArrayOf<IConstAttributeType> &val)
{
	m_Attributes->kill();
	IArrayOf<IConstAttributeType> &target = m_Attributes.getValue();
	ForEachItemIn(idx, val)
	{
		IConstAttributeType &item = val.item(idx);
		item.Link();
		target.append(item);
	}
}
void CTreeElementType::setChildren(IArrayOf<IEspTreeElementType> &val)
{
	m_Children->kill();
	IArrayOf<IConstTreeElementType> &target = m_Children.getValue();
	ForEachItemIn(idx, val)
	{
		IEspTreeElementType &item = (val).item(idx);
		item.Link();
		target.append(item);
	}
}
void CTreeElementType::setChildren(IArrayOf<IConstTreeElementType> &val)
{
	m_Children->kill();
	IArrayOf<IConstTreeElementType> &target = m_Children.getValue();
	ForEachItemIn(idx, val)
	{
		IConstTreeElementType &item = val.item(idx);
		item.Link();
		target.append(item);
	}
}
extern "C"  IEspTreeElementType *createTreeElementType(const char *serv, const char *msgname){return ((IEspTreeElementType *)new CTreeElementType(serv /*, msgname*/));}
extern "C"  IClientTreeElementType *createClientTreeElementType(const char *serv, const char *msgname){return ((IClientTreeElementType *)new CTreeElementType(serv /*, msgname*/));}

//=======================================================
// class CGetTreeResponse Implementation
//=======================================================

CGetTreeResponse::CGetTreeResponse(const char *serviceName, IRpcMessageBinding *init)
	: m_Tree(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetTreeResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CGetTreeResponse::CGetTreeResponse(const char *serviceName, const char *bc)
	: m_Tree(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetTreeResponse");
}

CGetTreeResponse::CGetTreeResponse(const char *serviceName, IRpcMessage* rpcmsg)
	: m_Tree(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetTreeResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CGetTreeResponse::CGetTreeResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_Tree(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetTreeResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CGetTreeResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		schema.append("<xsd:element name=\"Exceptions\" type=\"tns:ArrayOfEspException\" minOccurs=\"0\" maxOccurs=\"1\"/>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Tree\" type=\"tns:TreeElementType\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	if (!(flags & 0x10)  || (flags & 0x100))
	{
		CTreeElementType::getXsdDefinition(context, request, schema, added);
	}
	return schema;
}

void CGetTreeResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CGetTreeResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
	if (!added.getValue("TreeElementType"))
	{
		added.setValue("TreeElementType",1);
		CTreeElementType::getMapInfo(info,added);
	}
}

StringBuffer &CGetTreeResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Tree");
	form.append("<tr>").append("<td><b>Tree: </b></td><td><hr/>");
	CTreeElementType::getHtmlForm(context, request, serv, method, form, false, extfix.str());
	form.append("<hr/></td></tr>");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CGetTreeResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CGetTreeResponse::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
		m_Tree.marshall(rpc_resp, "Tree", "", "", "");
	}
}


void CGetTreeResponse::copy(CGetTreeResponse &from)
{
	m_Tree.copy(from.m_Tree);
}


void CGetTreeResponse::copy(IConstGetTreeResponse &ifrom)
{
	setTree(ifrom.getTree());
}


void CGetTreeResponse::getAttributes(IProperties &attributes)
{
}


void CGetTreeResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
		m_Tree.toStr(ctx, buffer, "Tree", "", false, "", "");
	}
}


void CGetTreeResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CGetTreeResponse::serializer(IEspContext* ctx, IConstGetTreeResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<GetTreeResponse>");
	// field Tree
	{
		StringBuffer tmp;
		CTreeElementType::serializer(ctx,src.getTree(), tmp, false);
		if (tmp.length()>0)
			buffer.appendf("<Tree>%s</Tree>",tmp.str());
	}
	if (keepRootTag)
		buffer.append("</GetTreeResponse>");
}

bool CGetTreeResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
		hasValue |= m_Tree.unmarshall(rpc_request, "Tree", basepath);
	}
	return hasValue;
}

bool CGetTreeResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Tree.unmarshall(ctx, soapval, "Tree");
	return hasValue;
}

bool CGetTreeResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Tree.unmarshall(ctx, params, attachments, "Tree", basepath);
	return hasValue;
}

IConstTreeElementType & CGetTreeResponse::getTree() { return (IConstTreeElementType &) m_Tree.getValue();}
IEspTreeElementType & CGetTreeResponse::updateTree(){ return (IEspTreeElementType &) m_Tree.getValue(); }
void CGetTreeResponse::setTree(IConstTreeElementType &ifrom){ m_Tree.copy(ifrom); }
extern "C"  IEspGetTreeResponse *createGetTreeResponse(const char *serv){return ((IEspGetTreeResponse *)new CGetTreeResponse(serv));}
extern "C"  IClientGetTreeResponse *createClientGetTreeResponse(const char *serv){return ((IClientGetTreeResponse *)new CGetTreeResponse(serv));}

//=======================================================
// class CFetchNodesRequest Implementation
//=======================================================

CFetchNodesRequest::CFetchNodesRequest(const char *serviceName, IRpcMessageBinding *init)
	: m_SessionId(nilIgnore),m_StartingNodeId("", nilIgnore),m_Path(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("FetchNodesRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CFetchNodesRequest::CFetchNodesRequest(const char *serviceName, const char *bc)
	: m_SessionId(nilIgnore),m_StartingNodeId("", nilIgnore),m_Path(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("FetchNodesRequest");
}

CFetchNodesRequest::CFetchNodesRequest(const char *serviceName, IRpcMessage* rpcmsg)
	: m_SessionId(nilIgnore),m_StartingNodeId("", nilIgnore),m_Path(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("FetchNodesRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CFetchNodesRequest::CFetchNodesRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_SessionId(nilIgnore),m_StartingNodeId("", nilIgnore),m_Path(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("FetchNodesRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CFetchNodesRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"SessionId\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" default=\"\" name=\"StartingNodeId\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Path\" type=\"xsd:string\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CFetchNodesRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CFetchNodesRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CFetchNodesRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("SessionId");
	form.appendf("  <tr><td><b>SessionId: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("StartingNodeId");
	form.appendf("  <tr><td><b>StartingNodeId: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Path");
	form.appendf("  <tr><td><b>Path: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CFetchNodesRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CFetchNodesRequest::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_SessionId.marshall(rpc_resp, "SessionId", "", "", "");
	m_StartingNodeId.marshall(rpc_resp, "StartingNodeId", "", "", "");
	m_Path.marshall(rpc_resp, "Path", "", "", "");
}


void CFetchNodesRequest::copy(CFetchNodesRequest &from)
{
	m_SessionId.copy(from.m_SessionId);
	m_StartingNodeId.copy(from.m_StartingNodeId);
	m_Path.copy(from.m_Path);
}


void CFetchNodesRequest::copy(IConstFetchNodesRequest &ifrom)
{
	setSessionId(ifrom.getSessionId());
	setStartingNodeId(ifrom.getStartingNodeId());
	setPath(ifrom.getPath());
}


void CFetchNodesRequest::getAttributes(IProperties &attributes)
{
}


void CFetchNodesRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_SessionId.toStr(ctx, buffer, "SessionId", "", true, "", "");
	m_StartingNodeId.toStr(ctx, buffer, "StartingNodeId", "", true, "", "");
	m_Path.toStr(ctx, buffer, "Path", "", true, "", "");
}


void CFetchNodesRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CFetchNodesRequest::serializer(IEspContext* ctx, IConstFetchNodesRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<FetchNodesRequest>");
	// field SessionId
	{
		const char* s = src.getSessionId();
		if (s && *s)
		{
			buffer.append("<SessionId>");
			encodeUtf8XML(s,buffer);
			buffer.append("</SessionId>");
		}
	}
	// field StartingNodeId
	{
		const char* s = src.getStartingNodeId();
		if (s && *s)
		{
			buffer.append("<StartingNodeId>");
			encodeUtf8XML(s,buffer);
			buffer.append("</StartingNodeId>");
		}
	}
	// field Path
	{
		const char* s = src.getPath();
		if (s && *s)
		{
			buffer.append("<Path>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Path>");
		}
	}
	if (keepRootTag)
		buffer.append("</FetchNodesRequest>");
}

bool CFetchNodesRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_SessionId.unmarshall(rpc_request, "SessionId", basepath);
	hasValue |= m_StartingNodeId.unmarshall(rpc_request, "StartingNodeId", basepath);
	hasValue |= m_Path.unmarshall(rpc_request, "Path", basepath);
	return hasValue;
}

bool CFetchNodesRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_SessionId.unmarshall(ctx, soapval, "SessionId");
	hasValue |= m_StartingNodeId.unmarshall(ctx, soapval, "StartingNodeId");
	hasValue |= m_Path.unmarshall(ctx, soapval, "Path");
	return hasValue;
}

bool CFetchNodesRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_SessionId.unmarshall(ctx, params, attachments, "SessionId", basepath);
	hasValue |= m_StartingNodeId.unmarshall(ctx, params, attachments, "StartingNodeId", basepath);
	hasValue |= m_Path.unmarshall(ctx, params, attachments, "Path", basepath);
	return hasValue;
}

const char * CFetchNodesRequest::getSessionId() { return m_SessionId.query();}
const char * CFetchNodesRequest::getStartingNodeId() { return m_StartingNodeId.query();}
const char * CFetchNodesRequest::getPath() { return m_Path.query();}
void CFetchNodesRequest::setSessionId(const char * val){ m_SessionId.set(val); }
void CFetchNodesRequest::setStartingNodeId(const char * val){ m_StartingNodeId.set(val); }
void CFetchNodesRequest::setPath(const char * val){ m_Path.set(val); }
extern "C"  IEspFetchNodesRequest *createFetchNodesRequest(const char *serv){return ((IEspFetchNodesRequest *)new CFetchNodesRequest(serv));}
extern "C"  IClientFetchNodesRequest *createClientFetchNodesRequest(const char *serv){return ((IClientFetchNodesRequest *)new CFetchNodesRequest(serv));}

//=======================================================
// class CFetchNodesResponse Implementation
//=======================================================

CFetchNodesResponse::CFetchNodesResponse(const char *serviceName, IRpcMessageBinding *init)
	: m_NodeIds(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("FetchNodesResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CFetchNodesResponse::CFetchNodesResponse(const char *serviceName, const char *bc)
	: m_NodeIds(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("FetchNodesResponse");
}

CFetchNodesResponse::CFetchNodesResponse(const char *serviceName, IRpcMessage* rpcmsg)
	: m_NodeIds(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("FetchNodesResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CFetchNodesResponse::CFetchNodesResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_NodeIds(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("FetchNodesResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CFetchNodesResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		schema.append("<xsd:element name=\"Exceptions\" type=\"tns:ArrayOfEspException\" minOccurs=\"0\" maxOccurs=\"1\"/>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"NodeIds\">");
		schema.append("<xsd:complexType><xsd:sequence>");
		schema.append("<xsd:element name=\"nodeId\" type=\"xsd:string\" minOccurs=\"0\" maxOccurs=\"unbounded\"/>\n");
		schema.append("</xsd:sequence></xsd:complexType>\n");
		schema.append("</xsd:element>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CFetchNodesResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CFetchNodesResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CFetchNodesResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("NodeIds");
	form.appendf("<tr><td><b>NodeIds: </b></td><td>");
	form.appendf("<textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea>", extfix.str());
	form.append("</td></tr>");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CFetchNodesResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CFetchNodesResponse::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
		m_NodeIds.marshall(rpc_resp, "NodeIds", "nodeId");
	}
}


void CFetchNodesResponse::copy(CFetchNodesResponse &from)
{
	m_NodeIds.copy(from.m_NodeIds);
}


void CFetchNodesResponse::copy(IConstFetchNodesResponse &ifrom)
{
	setNodeIds(ifrom.getNodeIds());
}


void CFetchNodesResponse::getAttributes(IProperties &attributes)
{
}


void CFetchNodesResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
		m_NodeIds.toStr(ctx, buffer, "NodeIds", "nodeId");
	}
}


void CFetchNodesResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CFetchNodesResponse::serializer(IEspContext* ctx, IConstFetchNodesResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<FetchNodesResponse>");
	// field NodeIds
	{
		StringArray& v = src.getNodeIds();
		if (v.length()>0)
			buffer.append("<NodeIds>");
		for (size32_t i=0;i<v.length();i++)
			buffer.appendf("<nodeId>%s</nodeId>",v.item(i));
		if (v.length()>0)
			buffer.append("</NodeIds>");
	}
	if (keepRootTag)
		buffer.append("</FetchNodesResponse>");
}

bool CFetchNodesResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
		hasValue |= m_NodeIds.unmarshall(rpc_request, "NodeIds", basepath);
	}
	return hasValue;
}

bool CFetchNodesResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_NodeIds.unmarshall(ctx, soapval, "NodeIds");
	return hasValue;
}

bool CFetchNodesResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_NodeIds.unmarshall(ctx, params, attachments, "NodeIds", basepath);
	return hasValue;
}

StringArray & CFetchNodesResponse::getNodeIds() { return (StringArray &) m_NodeIds; }
void CFetchNodesResponse::setNodeIds(StringArray &val){ m_NodeIds->kill();  CloneArray(m_NodeIds.getValue(), val); }
extern "C"  IEspFetchNodesResponse *createFetchNodesResponse(const char *serv){return ((IEspFetchNodesResponse *)new CFetchNodesResponse(serv));}
extern "C"  IClientFetchNodesResponse *createClientFetchNodesResponse(const char *serv){return ((IClientFetchNodesResponse *)new CFetchNodesResponse(serv));}

//=======================================================
// class CWizardTestRequest Implementation
//=======================================================

CWizardTestRequest::CWizardTestRequest(const char *serviceName, IRpcMessageBinding *init)
	: m_SessionId(nilIgnore),m_FqFilename(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("WizardTestRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CWizardTestRequest::CWizardTestRequest(const char *serviceName, const char *bc)
	: m_SessionId(nilIgnore),m_FqFilename(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("WizardTestRequest");
}

CWizardTestRequest::CWizardTestRequest(const char *serviceName, IRpcMessage* rpcmsg)
	: m_SessionId(nilIgnore),m_FqFilename(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("WizardTestRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CWizardTestRequest::CWizardTestRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_SessionId(nilIgnore),m_FqFilename(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("WizardTestRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CWizardTestRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"SessionId\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"FqFilename\" type=\"xsd:string\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CWizardTestRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CWizardTestRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CWizardTestRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("SessionId");
	form.appendf("  <tr><td><b>SessionId: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("FqFilename");
	form.appendf("  <tr><td><b>FqFilename: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CWizardTestRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CWizardTestRequest::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_SessionId.marshall(rpc_resp, "SessionId", "", "", "");
	m_FqFilename.marshall(rpc_resp, "FqFilename", "", "", "");
}


void CWizardTestRequest::copy(CWizardTestRequest &from)
{
	m_SessionId.copy(from.m_SessionId);
	m_FqFilename.copy(from.m_FqFilename);
}


void CWizardTestRequest::copy(IConstWizardTestRequest &ifrom)
{
	setSessionId(ifrom.getSessionId());
	setFqFilename(ifrom.getFqFilename());
}


void CWizardTestRequest::getAttributes(IProperties &attributes)
{
}


void CWizardTestRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_SessionId.toStr(ctx, buffer, "SessionId", "", true, "", "");
	m_FqFilename.toStr(ctx, buffer, "FqFilename", "", true, "", "");
}


void CWizardTestRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CWizardTestRequest::serializer(IEspContext* ctx, IConstWizardTestRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<WizardTestRequest>");
	// field SessionId
	{
		const char* s = src.getSessionId();
		if (s && *s)
		{
			buffer.append("<SessionId>");
			encodeUtf8XML(s,buffer);
			buffer.append("</SessionId>");
		}
	}
	// field FqFilename
	{
		const char* s = src.getFqFilename();
		if (s && *s)
		{
			buffer.append("<FqFilename>");
			encodeUtf8XML(s,buffer);
			buffer.append("</FqFilename>");
		}
	}
	if (keepRootTag)
		buffer.append("</WizardTestRequest>");
}

bool CWizardTestRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_SessionId.unmarshall(rpc_request, "SessionId", basepath);
	hasValue |= m_FqFilename.unmarshall(rpc_request, "FqFilename", basepath);
	return hasValue;
}

bool CWizardTestRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_SessionId.unmarshall(ctx, soapval, "SessionId");
	hasValue |= m_FqFilename.unmarshall(ctx, soapval, "FqFilename");
	return hasValue;
}

bool CWizardTestRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_SessionId.unmarshall(ctx, params, attachments, "SessionId", basepath);
	hasValue |= m_FqFilename.unmarshall(ctx, params, attachments, "FqFilename", basepath);
	return hasValue;
}

const char * CWizardTestRequest::getSessionId() { return m_SessionId.query();}
const char * CWizardTestRequest::getFqFilename() { return m_FqFilename.query();}
void CWizardTestRequest::setSessionId(const char * val){ m_SessionId.set(val); }
void CWizardTestRequest::setFqFilename(const char * val){ m_FqFilename.set(val); }
extern "C"  IEspWizardTestRequest *createWizardTestRequest(const char *serv){return ((IEspWizardTestRequest *)new CWizardTestRequest(serv));}
extern "C"  IClientWizardTestRequest *createClientWizardTestRequest(const char *serv){return ((IClientWizardTestRequest *)new CWizardTestRequest(serv));}

//=======================================================
// class Cws_configmgrPingRequest Implementation
//=======================================================

Cws_configmgrPingRequest::Cws_configmgrPingRequest(const char *serviceName, IRpcMessageBinding *init)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ws_configmgrPingRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

Cws_configmgrPingRequest::Cws_configmgrPingRequest(const char *serviceName, const char *bc)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ws_configmgrPingRequest");
}

Cws_configmgrPingRequest::Cws_configmgrPingRequest(const char *serviceName, IRpcMessage* rpcmsg)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ws_configmgrPingRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

Cws_configmgrPingRequest::Cws_configmgrPingRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ws_configmgrPingRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &Cws_configmgrPingRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType><xsd:all/></xsd:complexType></xsd:element>\n", msgTypeName);
		}
	}
	return schema;
}

void Cws_configmgrPingRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void Cws_configmgrPingRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &Cws_configmgrPingRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &Cws_configmgrPingRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void Cws_configmgrPingRequest::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

}


void Cws_configmgrPingRequest::copy(Cws_configmgrPingRequest &from)
{
}


void Cws_configmgrPingRequest::copy(IConstws_configmgrPingRequest &ifrom)
{
}


void Cws_configmgrPingRequest::getAttributes(IProperties &attributes)
{
}


void Cws_configmgrPingRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
}


void Cws_configmgrPingRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void Cws_configmgrPingRequest::serializer(IEspContext* ctx, IConstws_configmgrPingRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<ws_configmgrPingRequest>");
	if (keepRootTag)
		buffer.append("</ws_configmgrPingRequest>");
}

bool Cws_configmgrPingRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	return hasValue;
}

bool Cws_configmgrPingRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	return hasValue;
}

bool Cws_configmgrPingRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	return hasValue;
}

extern "C"  IEspws_configmgrPingRequest *createws_configmgrPingRequest(const char *serv){return ((IEspws_configmgrPingRequest *)new Cws_configmgrPingRequest(serv));}
extern "C"  IClientws_configmgrPingRequest *createClientws_configmgrPingRequest(const char *serv){return ((IClientws_configmgrPingRequest *)new Cws_configmgrPingRequest(serv));}

//=======================================================
// class Cws_configmgrPingResponse Implementation
//=======================================================

Cws_configmgrPingResponse::Cws_configmgrPingResponse(const char *serviceName, IRpcMessageBinding *init)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ws_configmgrPingResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

Cws_configmgrPingResponse::Cws_configmgrPingResponse(const char *serviceName, const char *bc)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ws_configmgrPingResponse");
}

Cws_configmgrPingResponse::Cws_configmgrPingResponse(const char *serviceName, IRpcMessage* rpcmsg)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ws_configmgrPingResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

Cws_configmgrPingResponse::Cws_configmgrPingResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ws_configmgrPingResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &Cws_configmgrPingResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType><xsd:all/></xsd:complexType></xsd:element>\n", msgTypeName);
		}
	}
	return schema;
}

void Cws_configmgrPingResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void Cws_configmgrPingResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &Cws_configmgrPingResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &Cws_configmgrPingResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void Cws_configmgrPingResponse::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
	}
}


void Cws_configmgrPingResponse::copy(Cws_configmgrPingResponse &from)
{
}


void Cws_configmgrPingResponse::copy(IConstws_configmgrPingResponse &ifrom)
{
}


void Cws_configmgrPingResponse::getAttributes(IProperties &attributes)
{
}


void Cws_configmgrPingResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
	}
}


void Cws_configmgrPingResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void Cws_configmgrPingResponse::serializer(IEspContext* ctx, IConstws_configmgrPingResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<ws_configmgrPingResponse>");
	if (keepRootTag)
		buffer.append("</ws_configmgrPingResponse>");
}

bool Cws_configmgrPingResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
	}
	return hasValue;
}

bool Cws_configmgrPingResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	return hasValue;
}

bool Cws_configmgrPingResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	return hasValue;
}

extern "C"  IEspws_configmgrPingResponse *createws_configmgrPingResponse(const char *serv){return ((IEspws_configmgrPingResponse *)new Cws_configmgrPingResponse(serv));}
extern "C"  IClientws_configmgrPingResponse *createClientws_configmgrPingResponse(const char *serv){return ((IClientws_configmgrPingResponse *)new Cws_configmgrPingResponse(serv));}

//=======================================================
// class Cws_configmgrSoapBinding Implementation
//=======================================================

Cws_configmgrSoapBinding::Cws_configmgrSoapBinding(http_soap_log_level level):CHttpSoapBinding(NULL, NULL, NULL, level)
{
	init_strings();
	setWsdlVersion(2);
}

Cws_configmgrSoapBinding::Cws_configmgrSoapBinding(IPropertyTree* cfg, const char *bindname, const char *procname, http_soap_log_level level):CHttpSoapBinding(cfg, bindname, procname, level)
{
	init_strings(); 
	setWsdlVersion(2);

}

void Cws_configmgrSoapBinding::init_strings()
{
	addMethodDescription("CloseEnvironmentFile", "Close an open environment file");
	addMethodDescription("CloseSession", "Close a previously open session");
	addMethodDescription("FetchNodes", "Fetch nodes matching the indicated path");
	addMethodDescription("GetCreateNodeInfo", "Get information to insert a new node");
	addMethodDescription("GetEnvironmentFileList", "Get a list of environment files available");
	addMethodDescription("GetNode", "Get an environment node");
	addMethodDescription("GetNodeCopy", "Get a copy of a node for paste operations");
	addMethodDescription("GetNodeTree", "Return the tree of nodes beneath the indicated node for the indicated number of levels");
	addMethodDescription("GetOpenSessions", "Return a list of open sessions");
	addMethodDescription("GetParents", "Returns the nodes parents all the way to the root");
	addMethodDescription("InsertNode", "Insert a new node into the environment");
	addMethodDescription("InsertNodeCopy", "Paste the copy of a node to an environment");
	addMethodDescription("LockSession", "Lock a session's open environment for modification");
	addMethodDescription("OpenEnvironmentFile", "Open an environment file");
	addMethodDescription("OpenSession", "Open a session with the configuration manager service");
	addMethodDescription("RemoveNode", "Remove a node from the environment");
	addMethodDescription("SaveEnvironmentFile", "Save a modifed environment file, or save to a new environment file");
	addMethodDescription("SetValues", "Set one or more of a node's attribute values,and/or the node's local value");
	addMethodDescription("UnlockSession", "Unlock a previously locked session");
	addMethodDescription("ValidateEnvironment", "Validate the environment");
}

int Cws_configmgrSoapBinding::processRequest(IRpcMessage* rpc_call, IRpcMessage* rpc_response)
{
	if(rpc_call == NULL || rpc_response == NULL)
		return -1;

	IEspContext *ctx=rpc_call->queryContext();
	DBGLOG("Client version: %g", ctx->getClientVersion());
	StringBuffer serviceName;
	double clientVer=(ctx) ? ctx->getClientVersion() : 0.0;
	qualifyServiceName(*ctx, ctx->queryServiceName(NULL), NULL, serviceName, NULL);
	CRpcCall* thecall = static_cast<CRpcCall *>(rpc_call);
	CRpcResponse* response = static_cast<CRpcResponse*>(rpc_response);
	CHttpRequest* httprequest = thecall->getHttpReq();
	CHttpResponse* httpresponse = response->getHttpResp();

	Owned<IEspws_configmgr> iserv = (IEspws_configmgr*)getService();
	if(iserv == NULL)
	{
		response->set_status(SOAP_SERVER_ERROR);
		response->set_err("Service not available");
		DBGLOG("Service not available");
		return -1;
	}
	if (thecall->get_name() == NULL)
	{
		response->set_status(SOAP_CLIENT_ERROR);
		response->set_err("No service method specified");
		ERRLOG("No service method specified");
		return -1;
	}

	IEspContext& context = *rpc_call->queryContext();

	if(!stricmp(thecall->get_name(), "CloseEnvironmentFile")||!stricmp(thecall->get_name(), "CloseEnvironmentFileRequest"))
	{
		Owned<CCloseEnvironmentFileRequest> esp_request = new CCloseEnvironmentFileRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CEmptyResponse> esp_response = new CEmptyResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		StringBuffer source;
		source.appendf("ws_configmgr::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "ws_configmgr", "CloseEnvironmentFile");
			iserv->onCloseEnvironmentFile(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "ws_configmgr", "CloseEnvironmentFile");
		response->set_name("EmptyResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "CloseSession")||!stricmp(thecall->get_name(), "CloseSessionRequest"))
	{
		Owned<CCloseSessionRequest> esp_request = new CCloseSessionRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CEmptyResponse> esp_response = new CEmptyResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		StringBuffer source;
		source.appendf("ws_configmgr::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "ws_configmgr", "CloseSession");
			iserv->onCloseSession(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "ws_configmgr", "CloseSession");
		response->set_name("EmptyResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "FetchNodes")||!stricmp(thecall->get_name(), "FetchNodesRequest"))
	{
		Owned<CFetchNodesRequest> esp_request = new CFetchNodesRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CFetchNodesResponse> esp_response = new CFetchNodesResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		StringBuffer source;
		source.appendf("ws_configmgr::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "ws_configmgr", "FetchNodes");
			iserv->onFetchNodes(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "ws_configmgr", "FetchNodes");
		response->set_name("FetchNodesResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "GetCreateNodeInfo")||!stricmp(thecall->get_name(), "GetCreateNodeInfoRequest"))
	{
		Owned<CGetCreateNodeInfoRequest> esp_request = new CGetCreateNodeInfoRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CGetCreateNodeInfoResponse> esp_response = new CGetCreateNodeInfoResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		StringBuffer source;
		source.appendf("ws_configmgr::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "ws_configmgr", "GetCreateNodeInfo");
			iserv->onGetCreateNodeInfo(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "ws_configmgr", "GetCreateNodeInfo");
		response->set_name("GetCreateNodeInfoResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "GetEnvironmentFileList")||!stricmp(thecall->get_name(), "GetEnvironmentFileListRequest"))
	{
		Owned<CGetEnvironmentFileListRequest> esp_request = new CGetEnvironmentFileListRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CGetEnvironmentListResponse> esp_response = new CGetEnvironmentListResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		StringBuffer source;
		source.appendf("ws_configmgr::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "ws_configmgr", "GetEnvironmentFileList");
			iserv->onGetEnvironmentFileList(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "ws_configmgr", "GetEnvironmentFileList");
		response->set_name("GetEnvironmentListResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "GetNode")||!stricmp(thecall->get_name(), "GetNodeRequest"))
	{
		Owned<CGetNodeRequest> esp_request = new CGetNodeRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CGetNodeResponse> esp_response = new CGetNodeResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		StringBuffer source;
		source.appendf("ws_configmgr::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "ws_configmgr", "GetNode");
			iserv->onGetNode(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "ws_configmgr", "GetNode");
		response->set_name("GetNodeResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "GetNodeCopy")||!stricmp(thecall->get_name(), "GetNodeCopyRequest"))
	{
		Owned<CGetNodeCopyRequest> esp_request = new CGetNodeCopyRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CGetNodeCopyResponse> esp_response = new CGetNodeCopyResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		StringBuffer source;
		source.appendf("ws_configmgr::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "ws_configmgr", "GetNodeCopy");
			iserv->onGetNodeCopy(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "ws_configmgr", "GetNodeCopy");
		response->set_name("GetNodeCopyResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "GetNodeTree")||!stricmp(thecall->get_name(), "GetTreeRequest"))
	{
		Owned<CGetTreeRequest> esp_request = new CGetTreeRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CGetTreeResponse> esp_response = new CGetTreeResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		StringBuffer source;
		source.appendf("ws_configmgr::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "ws_configmgr", "GetNodeTree");
			iserv->onGetNodeTree(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "ws_configmgr", "GetNodeTree");
		response->set_name("GetTreeResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "GetOpenSessions")||!stricmp(thecall->get_name(), "ListOpenSessionsRequest"))
	{
		Owned<CListOpenSessionsRequest> esp_request = new CListOpenSessionsRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CListOpenSessionsResponse> esp_response = new CListOpenSessionsResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		StringBuffer source;
		source.appendf("ws_configmgr::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "ws_configmgr", "GetOpenSessions");
			iserv->onGetOpenSessions(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "ws_configmgr", "GetOpenSessions");
		response->set_name("ListOpenSessionsResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "GetParents")||!stricmp(thecall->get_name(), "GetParentsRequest"))
	{
		Owned<CGetParentsRequest> esp_request = new CGetParentsRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CGetParentsResponse> esp_response = new CGetParentsResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		StringBuffer source;
		source.appendf("ws_configmgr::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "ws_configmgr", "GetParents");
			iserv->onGetParents(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "ws_configmgr", "GetParents");
		response->set_name("GetParentsResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "InsertNode")||!stricmp(thecall->get_name(), "InsertNodeRequest"))
	{
		Owned<CInsertNodeRequest> esp_request = new CInsertNodeRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CGetNodeResponse> esp_response = new CGetNodeResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		StringBuffer source;
		source.appendf("ws_configmgr::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "ws_configmgr", "InsertNode");
			iserv->onInsertNode(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "ws_configmgr", "InsertNode");
		response->set_name("GetNodeResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "InsertNodeCopy")||!stricmp(thecall->get_name(), "PasteNodeCopyRequest"))
	{
		Owned<CPasteNodeCopyRequest> esp_request = new CPasteNodeCopyRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CPasteNodeCopyResponse> esp_response = new CPasteNodeCopyResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		StringBuffer source;
		source.appendf("ws_configmgr::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "ws_configmgr", "InsertNodeCopy");
			iserv->onInsertNodeCopy(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "ws_configmgr", "InsertNodeCopy");
		response->set_name("PasteNodeCopyResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "LockSession")||!stricmp(thecall->get_name(), "LockSessionRequest"))
	{
		Owned<CLockSessionRequest> esp_request = new CLockSessionRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CLockSessionResponse> esp_response = new CLockSessionResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		StringBuffer source;
		source.appendf("ws_configmgr::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "ws_configmgr", "LockSession");
			iserv->onLockSession(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "ws_configmgr", "LockSession");
		response->set_name("LockSessionResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "OpenEnvironmentFile")||!stricmp(thecall->get_name(), "OpenEnvironmentFileRequest"))
	{
		Owned<COpenEnvironmentFileRequest> esp_request = new COpenEnvironmentFileRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<COpenEnvironmentFileResponse> esp_response = new COpenEnvironmentFileResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		StringBuffer source;
		source.appendf("ws_configmgr::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "ws_configmgr", "OpenEnvironmentFile");
			iserv->onOpenEnvironmentFile(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "ws_configmgr", "OpenEnvironmentFile");
		response->set_name("OpenEnvironmentFileResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "OpenSession")||!stricmp(thecall->get_name(), "OpenSessionRequest"))
	{
		Owned<COpenSessionRequest> esp_request = new COpenSessionRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<COpenSessionResponse> esp_response = new COpenSessionResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		StringBuffer source;
		source.appendf("ws_configmgr::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "ws_configmgr", "OpenSession");
			iserv->onOpenSession(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "ws_configmgr", "OpenSession");
		response->set_name("OpenSessionResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "Ping")||!stricmp(thecall->get_name(), "ws_configmgrPingRequest"))
	{
		Owned<Cws_configmgrPingRequest> esp_request = new Cws_configmgrPingRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<Cws_configmgrPingResponse> esp_response = new Cws_configmgrPingResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		StringBuffer source;
		source.appendf("ws_configmgr::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "ws_configmgr", "Ping");
			iserv->onPing(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "ws_configmgr", "Ping");
		response->set_name("ws_configmgrPingResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "RemoveNode")||!stricmp(thecall->get_name(), "RemoveNodeRequest"))
	{
		Owned<CRemoveNodeRequest> esp_request = new CRemoveNodeRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CStatusResponse> esp_response = new CStatusResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		StringBuffer source;
		source.appendf("ws_configmgr::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "ws_configmgr", "RemoveNode");
			iserv->onRemoveNode(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "ws_configmgr", "RemoveNode");
		response->set_name("StatusResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "SaveEnvironmentFile")||!stricmp(thecall->get_name(), "SaveEnvironmentFileRequest"))
	{
		Owned<CSaveEnvironmentFileRequest> esp_request = new CSaveEnvironmentFileRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CEmptyResponse> esp_response = new CEmptyResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		StringBuffer source;
		source.appendf("ws_configmgr::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "ws_configmgr", "SaveEnvironmentFile");
			iserv->onSaveEnvironmentFile(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "ws_configmgr", "SaveEnvironmentFile");
		response->set_name("EmptyResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "SetValues")||!stricmp(thecall->get_name(), "SetValuesRequest"))
	{
		Owned<CSetValuesRequest> esp_request = new CSetValuesRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CStatusResponse> esp_response = new CStatusResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		StringBuffer source;
		source.appendf("ws_configmgr::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "ws_configmgr", "SetValues");
			iserv->onSetValues(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "ws_configmgr", "SetValues");
		response->set_name("StatusResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "UnlockSession")||!stricmp(thecall->get_name(), "UnlockSessionRequest"))
	{
		Owned<CUnlockSessionRequest> esp_request = new CUnlockSessionRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CEmptyResponse> esp_response = new CEmptyResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		StringBuffer source;
		source.appendf("ws_configmgr::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "ws_configmgr", "UnlockSession");
			iserv->onUnlockSession(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "ws_configmgr", "UnlockSession");
		response->set_name("EmptyResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "ValidateEnvironment")||!stricmp(thecall->get_name(), "ValidateEnvironmentRequest"))
	{
		Owned<CValidateEnvironmentRequest> esp_request = new CValidateEnvironmentRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CStatusResponse> esp_response = new CStatusResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		StringBuffer source;
		source.appendf("ws_configmgr::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "ws_configmgr", "ValidateEnvironment");
			iserv->onValidateEnvironment(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "ws_configmgr", "ValidateEnvironment");
		response->set_name("StatusResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	response->set_status(SOAP_CLIENT_ERROR);
	StringBuffer msg, svcName;
	msg.appendf("Method %s not available in service %s",thecall->get_name(),getServiceName(svcName).str());
	ERRLOG("%s", msg.str());
	response->set_err(msg);
	return -1;
}

int Cws_configmgrSoapBinding::getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &content, const char *service, const char *method, bool mda)
{
	BoolHash added;
	if (context.getClientVersion()<=0)
		context.setClientVersion(2);

	DBGLOG("Client version: %g", context.getClientVersion());
	bool fullservice = (!Utils::strcasecmp(service, "ws_configmgr"));
	bool allMethods = (method==NULL || *method==0);
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "CloseEnvironmentFile"))) || Utils::strcasecmp(method, "CloseEnvironmentFile")==0)
	{
		CCloseEnvironmentFileRequest::getMapInfo(context.queryMapInfo());
		CEmptyResponse::getMapInfo(context.queryMapInfo());
		CCloseEnvironmentFileRequest::getXsdDefinition(context, request, "CloseEnvironmentFileRequest", content, added);
		CEmptyResponse::getXsdDefinition(context, request, content, added);
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "CloseSession"))) || Utils::strcasecmp(method, "CloseSession")==0)
	{
		CCloseSessionRequest::getMapInfo(context.queryMapInfo());
		CEmptyResponse::getMapInfo(context.queryMapInfo());
		CCloseSessionRequest::getXsdDefinition(context, request, "CloseSessionRequest", content, added);
		CEmptyResponse::getXsdDefinition(context, request, content, added);
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "FetchNodes"))) || Utils::strcasecmp(method, "FetchNodes")==0)
	{
		CFetchNodesRequest::getMapInfo(context.queryMapInfo());
		CFetchNodesResponse::getMapInfo(context.queryMapInfo());
		CFetchNodesRequest::getXsdDefinition(context, request, "FetchNodesRequest", content, added);
		CFetchNodesResponse::getXsdDefinition(context, request, content, added);
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "GetCreateNodeInfo"))) || Utils::strcasecmp(method, "GetCreateNodeInfo")==0)
	{
		CGetCreateNodeInfoRequest::getMapInfo(context.queryMapInfo());
		CGetCreateNodeInfoResponse::getMapInfo(context.queryMapInfo());
		CGetCreateNodeInfoRequest::getXsdDefinition(context, request, "GetCreateNodeInfoRequest", content, added);
		CGetCreateNodeInfoResponse::getXsdDefinition(context, request, content, added);
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "GetEnvironmentFileList"))) || Utils::strcasecmp(method, "GetEnvironmentFileList")==0)
	{
		CGetEnvironmentFileListRequest::getMapInfo(context.queryMapInfo());
		CGetEnvironmentListResponse::getMapInfo(context.queryMapInfo());
		CGetEnvironmentFileListRequest::getXsdDefinition(context, request, "GetEnvironmentFileListRequest", content, added);
		CGetEnvironmentListResponse::getXsdDefinition(context, request, content, added);
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "GetNode"))) || Utils::strcasecmp(method, "GetNode")==0)
	{
		CGetNodeRequest::getMapInfo(context.queryMapInfo());
		CGetNodeResponse::getMapInfo(context.queryMapInfo());
		CGetNodeRequest::getXsdDefinition(context, request, "GetNodeRequest", content, added);
		CGetNodeResponse::getXsdDefinition(context, request, content, added);
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "GetNodeCopy"))) || Utils::strcasecmp(method, "GetNodeCopy")==0)
	{
		CGetNodeCopyRequest::getMapInfo(context.queryMapInfo());
		CGetNodeCopyResponse::getMapInfo(context.queryMapInfo());
		CGetNodeCopyRequest::getXsdDefinition(context, request, "GetNodeCopyRequest", content, added);
		CGetNodeCopyResponse::getXsdDefinition(context, request, content, added);
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "GetNodeTree"))) || Utils::strcasecmp(method, "GetNodeTree")==0)
	{
		CGetTreeRequest::getMapInfo(context.queryMapInfo());
		CGetTreeResponse::getMapInfo(context.queryMapInfo());
		CGetTreeRequest::getXsdDefinition(context, request, "GetTreeRequest", content, added);
		CGetTreeResponse::getXsdDefinition(context, request, content, added);
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "GetOpenSessions"))) || Utils::strcasecmp(method, "GetOpenSessions")==0)
	{
		CListOpenSessionsRequest::getMapInfo(context.queryMapInfo());
		CListOpenSessionsResponse::getMapInfo(context.queryMapInfo());
		CListOpenSessionsRequest::getXsdDefinition(context, request, "ListOpenSessionsRequest", content, added);
		CListOpenSessionsResponse::getXsdDefinition(context, request, content, added);
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "GetParents"))) || Utils::strcasecmp(method, "GetParents")==0)
	{
		CGetParentsRequest::getMapInfo(context.queryMapInfo());
		CGetParentsResponse::getMapInfo(context.queryMapInfo());
		CGetParentsRequest::getXsdDefinition(context, request, "GetParentsRequest", content, added);
		CGetParentsResponse::getXsdDefinition(context, request, content, added);
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "InsertNode"))) || Utils::strcasecmp(method, "InsertNode")==0)
	{
		CInsertNodeRequest::getMapInfo(context.queryMapInfo());
		CGetNodeResponse::getMapInfo(context.queryMapInfo());
		CInsertNodeRequest::getXsdDefinition(context, request, "InsertNodeRequest", content, added);
		CGetNodeResponse::getXsdDefinition(context, request, content, added);
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "InsertNodeCopy"))) || Utils::strcasecmp(method, "InsertNodeCopy")==0)
	{
		CPasteNodeCopyRequest::getMapInfo(context.queryMapInfo());
		CPasteNodeCopyResponse::getMapInfo(context.queryMapInfo());
		CPasteNodeCopyRequest::getXsdDefinition(context, request, "PasteNodeCopyRequest", content, added);
		CPasteNodeCopyResponse::getXsdDefinition(context, request, content, added);
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "LockSession"))) || Utils::strcasecmp(method, "LockSession")==0)
	{
		CLockSessionRequest::getMapInfo(context.queryMapInfo());
		CLockSessionResponse::getMapInfo(context.queryMapInfo());
		CLockSessionRequest::getXsdDefinition(context, request, "LockSessionRequest", content, added);
		CLockSessionResponse::getXsdDefinition(context, request, content, added);
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "OpenEnvironmentFile"))) || Utils::strcasecmp(method, "OpenEnvironmentFile")==0)
	{
		COpenEnvironmentFileRequest::getMapInfo(context.queryMapInfo());
		COpenEnvironmentFileResponse::getMapInfo(context.queryMapInfo());
		COpenEnvironmentFileRequest::getXsdDefinition(context, request, "OpenEnvironmentFileRequest", content, added);
		COpenEnvironmentFileResponse::getXsdDefinition(context, request, content, added);
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "OpenSession"))) || Utils::strcasecmp(method, "OpenSession")==0)
	{
		COpenSessionRequest::getMapInfo(context.queryMapInfo());
		COpenSessionResponse::getMapInfo(context.queryMapInfo());
		COpenSessionRequest::getXsdDefinition(context, request, "OpenSessionRequest", content, added);
		COpenSessionResponse::getXsdDefinition(context, request, content, added);
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "Ping"))) || Utils::strcasecmp(method, "Ping")==0)
	{
		Cws_configmgrPingRequest::getMapInfo(context.queryMapInfo());
		Cws_configmgrPingResponse::getMapInfo(context.queryMapInfo());
		Cws_configmgrPingRequest::getXsdDefinition(context, request, "ws_configmgrPingRequest", content, added);
		Cws_configmgrPingResponse::getXsdDefinition(context, request, content, added);
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "RemoveNode"))) || Utils::strcasecmp(method, "RemoveNode")==0)
	{
		CRemoveNodeRequest::getMapInfo(context.queryMapInfo());
		CStatusResponse::getMapInfo(context.queryMapInfo());
		CRemoveNodeRequest::getXsdDefinition(context, request, "RemoveNodeRequest", content, added);
		CStatusResponse::getXsdDefinition(context, request, content, added);
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "SaveEnvironmentFile"))) || Utils::strcasecmp(method, "SaveEnvironmentFile")==0)
	{
		CSaveEnvironmentFileRequest::getMapInfo(context.queryMapInfo());
		CEmptyResponse::getMapInfo(context.queryMapInfo());
		CSaveEnvironmentFileRequest::getXsdDefinition(context, request, "SaveEnvironmentFileRequest", content, added);
		CEmptyResponse::getXsdDefinition(context, request, content, added);
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "SetValues"))) || Utils::strcasecmp(method, "SetValues")==0)
	{
		CSetValuesRequest::getMapInfo(context.queryMapInfo());
		CStatusResponse::getMapInfo(context.queryMapInfo());
		CSetValuesRequest::getXsdDefinition(context, request, "SetValuesRequest", content, added);
		CStatusResponse::getXsdDefinition(context, request, content, added);
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "UnlockSession"))) || Utils::strcasecmp(method, "UnlockSession")==0)
	{
		CUnlockSessionRequest::getMapInfo(context.queryMapInfo());
		CEmptyResponse::getMapInfo(context.queryMapInfo());
		CUnlockSessionRequest::getXsdDefinition(context, request, "UnlockSessionRequest", content, added);
		CEmptyResponse::getXsdDefinition(context, request, content, added);
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "ValidateEnvironment"))) || Utils::strcasecmp(method, "ValidateEnvironment")==0)
	{
		CValidateEnvironmentRequest::getMapInfo(context.queryMapInfo());
		CStatusResponse::getMapInfo(context.queryMapInfo());
		CValidateEnvironmentRequest::getXsdDefinition(context, request, "ValidateEnvironmentRequest", content, added);
		CStatusResponse::getXsdDefinition(context, request, content, added);
	}
	return 0;
}

int Cws_configmgrSoapBinding::getMethodHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &page, bool bIncludeFormTag)
{
	DBGLOG("Client version: %g", context.getClientVersion());
	if (Utils::strcasecmp(method, "CloseEnvironmentFile")==0)
	{
		CCloseEnvironmentFileRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "CloseSession")==0)
	{
		CCloseSessionRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "FetchNodes")==0)
	{
		CFetchNodesRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "GetCreateNodeInfo")==0)
	{
		CGetCreateNodeInfoRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "GetEnvironmentFileList")==0)
	{
		CGetEnvironmentFileListRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "GetNode")==0)
	{
		CGetNodeRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "GetNodeCopy")==0)
	{
		CGetNodeCopyRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "GetNodeTree")==0)
	{
		CGetTreeRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "GetOpenSessions")==0)
	{
		CListOpenSessionsRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "GetParents")==0)
	{
		CGetParentsRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "InsertNode")==0)
	{
		CInsertNodeRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "InsertNodeCopy")==0)
	{
		CPasteNodeCopyRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "LockSession")==0)
	{
		CLockSessionRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "OpenEnvironmentFile")==0)
	{
		COpenEnvironmentFileRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "OpenSession")==0)
	{
		COpenSessionRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "Ping")==0)
	{
		Cws_configmgrPingRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "RemoveNode")==0)
	{
		CRemoveNodeRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "SaveEnvironmentFile")==0)
	{
		CSaveEnvironmentFileRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "SetValues")==0)
	{
		CSetValuesRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "UnlockSession")==0)
	{
		CUnlockSessionRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "ValidateEnvironment")==0)
	{
		CValidateEnvironmentRequest::getHtmlForm(context, request, serv, method, page);
	}
	return 0;
}

int Cws_configmgrSoapBinding::getQualifiedNames(IEspContext& ctx, MethodInfoArray & methods)
{
	double ver = ctx.getClientVersion();
	if (ver<=0)
		ver = getWsdlVersion();
	const char *servname=ctx.queryServiceName(NULL);
	bool fullservice = (!stricmp(servname, "esp")||!stricmp(servname, "ws_configmgr"));
	if ((fullservice || isMethodInSubService(ctx, servname, "CloseEnvironmentFile")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("CloseEnvironmentFile", "CloseEnvironmentFileRequest", "EmptyResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "CloseSession")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("CloseSession", "CloseSessionRequest", "EmptyResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "FetchNodes")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("FetchNodes", "FetchNodesRequest", "FetchNodesResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "GetCreateNodeInfo")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("GetCreateNodeInfo", "GetCreateNodeInfoRequest", "GetCreateNodeInfoResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "GetEnvironmentFileList")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("GetEnvironmentFileList", "GetEnvironmentFileListRequest", "GetEnvironmentListResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "GetNode")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("GetNode", "GetNodeRequest", "GetNodeResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "GetNodeCopy")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("GetNodeCopy", "GetNodeCopyRequest", "GetNodeCopyResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "GetNodeTree")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("GetNodeTree", "GetTreeRequest", "GetTreeResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "GetOpenSessions")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("GetOpenSessions", "ListOpenSessionsRequest", "ListOpenSessionsResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "GetParents")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("GetParents", "GetParentsRequest", "GetParentsResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "InsertNode")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("InsertNode", "InsertNodeRequest", "GetNodeResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "InsertNodeCopy")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("InsertNodeCopy", "PasteNodeCopyRequest", "PasteNodeCopyResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "LockSession")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("LockSession", "LockSessionRequest", "LockSessionResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "OpenEnvironmentFile")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("OpenEnvironmentFile", "OpenEnvironmentFileRequest", "OpenEnvironmentFileResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "OpenSession")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("OpenSession", "OpenSessionRequest", "OpenSessionResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "Ping")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("Ping", "ws_configmgrPingRequest", "ws_configmgrPingResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "RemoveNode")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("RemoveNode", "RemoveNodeRequest", "StatusResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "SaveEnvironmentFile")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("SaveEnvironmentFile", "SaveEnvironmentFileRequest", "EmptyResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "SetValues")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("SetValues", "SetValuesRequest", "StatusResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "UnlockSession")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("UnlockSession", "UnlockSessionRequest", "EmptyResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "ValidateEnvironment")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("ValidateEnvironment", "ValidateEnvironmentRequest", "StatusResponse"));
	return methods.ordinality();
}

StringBuffer & Cws_configmgrSoapBinding::getServiceName(StringBuffer &resp)
{
	resp.append("ws_configmgr");
	return resp;
}

bool Cws_configmgrSoapBinding::isValidServiceName(IEspContext &context, const char *name)
{
	if (!Utils::strcasecmp(name, "ws_configmgr"))
		return true;
	else
		return (hasSubService(context, name));
}

bool Cws_configmgrSoapBinding::qualifyMethodName(IEspContext &context, const char *methname, StringBuffer *methQName)
{
	if (!methname || !*methname)
	{
		if (methQName!=NULL)
			methQName->clear();
		return true;
	}
	if (Utils::strcasecmp(methname, "CloseEnvironmentFile")==0)
	{
		if (methQName!=NULL)
			methQName->set("CloseEnvironmentFile");
		return true;
	}
	if (Utils::strcasecmp(methname, "CloseSession")==0)
	{
		if (methQName!=NULL)
			methQName->set("CloseSession");
		return true;
	}
	if (Utils::strcasecmp(methname, "FetchNodes")==0)
	{
		if (methQName!=NULL)
			methQName->set("FetchNodes");
		return true;
	}
	if (Utils::strcasecmp(methname, "GetCreateNodeInfo")==0)
	{
		if (methQName!=NULL)
			methQName->set("GetCreateNodeInfo");
		return true;
	}
	if (Utils::strcasecmp(methname, "GetEnvironmentFileList")==0)
	{
		if (methQName!=NULL)
			methQName->set("GetEnvironmentFileList");
		return true;
	}
	if (Utils::strcasecmp(methname, "GetNode")==0)
	{
		if (methQName!=NULL)
			methQName->set("GetNode");
		return true;
	}
	if (Utils::strcasecmp(methname, "GetNodeCopy")==0)
	{
		if (methQName!=NULL)
			methQName->set("GetNodeCopy");
		return true;
	}
	if (Utils::strcasecmp(methname, "GetNodeTree")==0)
	{
		if (methQName!=NULL)
			methQName->set("GetNodeTree");
		return true;
	}
	if (Utils::strcasecmp(methname, "GetOpenSessions")==0)
	{
		if (methQName!=NULL)
			methQName->set("GetOpenSessions");
		return true;
	}
	if (Utils::strcasecmp(methname, "GetParents")==0)
	{
		if (methQName!=NULL)
			methQName->set("GetParents");
		return true;
	}
	if (Utils::strcasecmp(methname, "InsertNode")==0)
	{
		if (methQName!=NULL)
			methQName->set("InsertNode");
		return true;
	}
	if (Utils::strcasecmp(methname, "InsertNodeCopy")==0)
	{
		if (methQName!=NULL)
			methQName->set("InsertNodeCopy");
		return true;
	}
	if (Utils::strcasecmp(methname, "LockSession")==0)
	{
		if (methQName!=NULL)
			methQName->set("LockSession");
		return true;
	}
	if (Utils::strcasecmp(methname, "OpenEnvironmentFile")==0)
	{
		if (methQName!=NULL)
			methQName->set("OpenEnvironmentFile");
		return true;
	}
	if (Utils::strcasecmp(methname, "OpenSession")==0)
	{
		if (methQName!=NULL)
			methQName->set("OpenSession");
		return true;
	}
	if (Utils::strcasecmp(methname, "Ping")==0)
	{
		if (methQName!=NULL)
			methQName->set("Ping");
		return true;
	}
	if (Utils::strcasecmp(methname, "RemoveNode")==0)
	{
		if (methQName!=NULL)
			methQName->set("RemoveNode");
		return true;
	}
	if (Utils::strcasecmp(methname, "SaveEnvironmentFile")==0)
	{
		if (methQName!=NULL)
			methQName->set("SaveEnvironmentFile");
		return true;
	}
	if (Utils::strcasecmp(methname, "SetValues")==0)
	{
		if (methQName!=NULL)
			methQName->set("SetValues");
		return true;
	}
	if (Utils::strcasecmp(methname, "UnlockSession")==0)
	{
		if (methQName!=NULL)
			methQName->set("UnlockSession");
		return true;
	}
	if (Utils::strcasecmp(methname, "ValidateEnvironment")==0)
	{
		if (methQName!=NULL)
			methQName->set("ValidateEnvironment");
		return true;
	}
	return false;
}

bool Cws_configmgrSoapBinding::qualifyServiceName(IEspContext &context, const char *servname, const char *methname, StringBuffer &servQName, StringBuffer *methQName)
{
	servQName.clear();
	if (!Utils::strcasecmp(servname, "ws_configmgr"))
	{
		servQName.append("ws_configmgr");
		return qualifyMethodName(context, methname, methQName);
	}
	return qualifySubServiceName(context, servname, methname, servQName, methQName);
}

int Cws_configmgrSoapBinding::onGetFile(IEspContext &context, CHttpRequest* request, CHttpResponse* response, const char *pathex)
{
	if(request == NULL || response == NULL)
		return -1;
	StringBuffer mimetype;
	MemoryBuffer content;

	StringBuffer filepath;
	getBaseFilePath(filepath);
	if (strchr("\\/", filepath.charAt(filepath.length()-1))==NULL)
		filepath.append("/");
	filepath.append(pathex);
	response->httpContentFromFile(filepath.str());
	response->send();
	return 0;
}

int Cws_configmgrSoapBinding::onGetForm(IEspContext &context, CHttpRequest* request, CHttpResponse* response, const char *service, const char *method)
{
	if (context.getClientVersion()<=0)
		context.setClientVersion(2);

	if (!stricmp("CloseEnvironmentFile", method)) {
		CCloseEnvironmentFileRequest::getMapInfo(context.queryMapInfo());
		CEmptyResponse::getMapInfo(context.queryMapInfo());
	}
	if (!stricmp("CloseSession", method)) {
		CCloseSessionRequest::getMapInfo(context.queryMapInfo());
		CEmptyResponse::getMapInfo(context.queryMapInfo());
	}
	if (!stricmp("FetchNodes", method)) {
		CFetchNodesRequest::getMapInfo(context.queryMapInfo());
		CFetchNodesResponse::getMapInfo(context.queryMapInfo());
	}
	if (!stricmp("GetCreateNodeInfo", method)) {
		CGetCreateNodeInfoRequest::getMapInfo(context.queryMapInfo());
		CGetCreateNodeInfoResponse::getMapInfo(context.queryMapInfo());
	}
	if (!stricmp("GetEnvironmentFileList", method)) {
		CGetEnvironmentFileListRequest::getMapInfo(context.queryMapInfo());
		CGetEnvironmentListResponse::getMapInfo(context.queryMapInfo());
	}
	if (!stricmp("GetNode", method)) {
		CGetNodeRequest::getMapInfo(context.queryMapInfo());
		CGetNodeResponse::getMapInfo(context.queryMapInfo());
	}
	if (!stricmp("GetNodeCopy", method)) {
		CGetNodeCopyRequest::getMapInfo(context.queryMapInfo());
		CGetNodeCopyResponse::getMapInfo(context.queryMapInfo());
	}
	if (!stricmp("GetNodeTree", method)) {
		CGetTreeRequest::getMapInfo(context.queryMapInfo());
		CGetTreeResponse::getMapInfo(context.queryMapInfo());
	}
	if (!stricmp("GetOpenSessions", method)) {
		CListOpenSessionsRequest::getMapInfo(context.queryMapInfo());
		CListOpenSessionsResponse::getMapInfo(context.queryMapInfo());
	}
	if (!stricmp("GetParents", method)) {
		CGetParentsRequest::getMapInfo(context.queryMapInfo());
		CGetParentsResponse::getMapInfo(context.queryMapInfo());
	}
	if (!stricmp("InsertNode", method)) {
		CInsertNodeRequest::getMapInfo(context.queryMapInfo());
		CGetNodeResponse::getMapInfo(context.queryMapInfo());
	}
	if (!stricmp("InsertNodeCopy", method)) {
		CPasteNodeCopyRequest::getMapInfo(context.queryMapInfo());
		CPasteNodeCopyResponse::getMapInfo(context.queryMapInfo());
	}
	if (!stricmp("LockSession", method)) {
		CLockSessionRequest::getMapInfo(context.queryMapInfo());
		CLockSessionResponse::getMapInfo(context.queryMapInfo());
	}
	if (!stricmp("OpenEnvironmentFile", method)) {
		COpenEnvironmentFileRequest::getMapInfo(context.queryMapInfo());
		COpenEnvironmentFileResponse::getMapInfo(context.queryMapInfo());
	}
	if (!stricmp("OpenSession", method)) {
		COpenSessionRequest::getMapInfo(context.queryMapInfo());
		COpenSessionResponse::getMapInfo(context.queryMapInfo());
	}
	if (!stricmp("Ping", method)) {
		Cws_configmgrPingRequest::getMapInfo(context.queryMapInfo());
		Cws_configmgrPingResponse::getMapInfo(context.queryMapInfo());
	}
	if (!stricmp("RemoveNode", method)) {
		CRemoveNodeRequest::getMapInfo(context.queryMapInfo());
		CStatusResponse::getMapInfo(context.queryMapInfo());
	}
	if (!stricmp("SaveEnvironmentFile", method)) {
		CSaveEnvironmentFileRequest::getMapInfo(context.queryMapInfo());
		CEmptyResponse::getMapInfo(context.queryMapInfo());
	}
	if (!stricmp("SetValues", method)) {
		CSetValuesRequest::getMapInfo(context.queryMapInfo());
		CStatusResponse::getMapInfo(context.queryMapInfo());
	}
	if (!stricmp("UnlockSession", method)) {
		CUnlockSessionRequest::getMapInfo(context.queryMapInfo());
		CEmptyResponse::getMapInfo(context.queryMapInfo());
	}
	if (!stricmp("ValidateEnvironment", method)) {
		CValidateEnvironmentRequest::getMapInfo(context.queryMapInfo());
		CStatusResponse::getMapInfo(context.queryMapInfo());
	}

	return EspHttpBinding::onGetForm(context, request, response, service, method);
}
int Cws_configmgrSoapBinding::onGetXForm(IEspContext &context, CHttpRequest* request, CHttpResponse* response, const char *service, const char *method)
{
	return EspHttpBinding::onGetXForm(context, request, response, service, method);
}

int Cws_configmgrSoapBinding::onGetService(IEspContext &context, CHttpRequest* request, CHttpResponse* response, const char *service, const char *method, const char *pathex)
{
	if(request == NULL || response == NULL)
		return -1;
	return onGetQuery(context, request, response, service, method);
}

 IRpcRequestBinding *Cws_configmgrSoapBinding::createReqBinding(IEspContext &context, IHttpMessage *ireq, const char *service, const char *method)
{
	CHttpRequest *request=static_cast<CHttpRequest*>(ireq);
	IProperties *props = (request) ? request->queryParameters() : NULL;

	if (!stricmp(method, "CloseEnvironmentFile") || !stricmp(method, "CloseEnvironmentFileRequest"))
		return new CCloseEnvironmentFileRequest(&context, "ws_configmgr", props, NULL);
	if (!stricmp(method, "CloseSession") || !stricmp(method, "CloseSessionRequest"))
		return new CCloseSessionRequest(&context, "ws_configmgr", props, NULL);
	if (!stricmp(method, "FetchNodes") || !stricmp(method, "FetchNodesRequest"))
		return new CFetchNodesRequest(&context, "ws_configmgr", props, NULL);
	if (!stricmp(method, "GetCreateNodeInfo") || !stricmp(method, "GetCreateNodeInfoRequest"))
		return new CGetCreateNodeInfoRequest(&context, "ws_configmgr", props, NULL);
	if (!stricmp(method, "GetEnvironmentFileList") || !stricmp(method, "GetEnvironmentFileListRequest"))
		return new CGetEnvironmentFileListRequest(&context, "ws_configmgr", props, NULL);
	if (!stricmp(method, "GetNode") || !stricmp(method, "GetNodeRequest"))
		return new CGetNodeRequest(&context, "ws_configmgr", props, NULL);
	if (!stricmp(method, "GetNodeCopy") || !stricmp(method, "GetNodeCopyRequest"))
		return new CGetNodeCopyRequest(&context, "ws_configmgr", props, NULL);
	if (!stricmp(method, "GetNodeTree") || !stricmp(method, "GetTreeRequest"))
		return new CGetTreeRequest(&context, "ws_configmgr", props, NULL);
	if (!stricmp(method, "GetOpenSessions") || !stricmp(method, "ListOpenSessionsRequest"))
		return new CListOpenSessionsRequest(&context, "ws_configmgr", props, NULL);
	if (!stricmp(method, "GetParents") || !stricmp(method, "GetParentsRequest"))
		return new CGetParentsRequest(&context, "ws_configmgr", props, NULL);
	if (!stricmp(method, "InsertNode") || !stricmp(method, "InsertNodeRequest"))
		return new CInsertNodeRequest(&context, "ws_configmgr", props, NULL);
	if (!stricmp(method, "InsertNodeCopy") || !stricmp(method, "PasteNodeCopyRequest"))
		return new CPasteNodeCopyRequest(&context, "ws_configmgr", props, NULL);
	if (!stricmp(method, "LockSession") || !stricmp(method, "LockSessionRequest"))
		return new CLockSessionRequest(&context, "ws_configmgr", props, NULL);
	if (!stricmp(method, "OpenEnvironmentFile") || !stricmp(method, "OpenEnvironmentFileRequest"))
		return new COpenEnvironmentFileRequest(&context, "ws_configmgr", props, NULL);
	if (!stricmp(method, "OpenSession") || !stricmp(method, "OpenSessionRequest"))
		return new COpenSessionRequest(&context, "ws_configmgr", props, NULL);
	if (!stricmp(method, "Ping") || !stricmp(method, "ws_configmgrPingRequest"))
		return new Cws_configmgrPingRequest(&context, "ws_configmgr", props, NULL);
	if (!stricmp(method, "RemoveNode") || !stricmp(method, "RemoveNodeRequest"))
		return new CRemoveNodeRequest(&context, "ws_configmgr", props, NULL);
	if (!stricmp(method, "SaveEnvironmentFile") || !stricmp(method, "SaveEnvironmentFileRequest"))
		return new CSaveEnvironmentFileRequest(&context, "ws_configmgr", props, NULL);
	if (!stricmp(method, "SetValues") || !stricmp(method, "SetValuesRequest"))
		return new CSetValuesRequest(&context, "ws_configmgr", props, NULL);
	if (!stricmp(method, "UnlockSession") || !stricmp(method, "UnlockSessionRequest"))
		return new CUnlockSessionRequest(&context, "ws_configmgr", props, NULL);
	if (!stricmp(method, "ValidateEnvironment") || !stricmp(method, "ValidateEnvironmentRequest"))
		return new CValidateEnvironmentRequest(&context, "ws_configmgr", props, NULL);
	return NULL;
}

int Cws_configmgrSoapBinding::onGetInstantQuery(IEspContext &context, CHttpRequest* request, CHttpResponse* response, const char *service, const char *method)
{
	if (context.getClientVersion()<=0)
		context.setClientVersion(2);

	if(request == NULL || response == NULL)
		return -1;
	StringBuffer respStr;
	Owned<IEspws_configmgr> iserv = (IEspws_configmgr*)getService();
	if(iserv == NULL)
	{
		respStr.append("Service not available");
		response->setContent(respStr.str());
		response->setContentType("text/html");
		response->send();
	}
	else
	{
		Owned<CSoapResponseBinding> esp_response;
		StringBuffer source;
		IEspContext& context = *request->queryContext();
		if(!stricmp(method, "CloseEnvironmentFile")||!stricmp(method, "CloseEnvironmentFileRequest"))
		{
			Owned<CCloseEnvironmentFileRequest> esp_request = new CCloseEnvironmentFileRequest(&context, "ws_configmgr", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			CEmptyResponse* resp = new CEmptyResponse("ws_configmgr");
			esp_response.setown(resp);
			MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
			source.setf("ws_configmgr::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				if(accessmap.ordinality()>0)
					onFeaturesAuthorize(context, accessmap, "ws_configmgr", "CloseEnvironmentFile");
				iserv->onCloseEnvironmentFile(context, *esp_request.get(), *resp);
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "ws_configmgr", "CloseEnvironmentFile", StringBuffer(getCFD()).append("xslt/exceptions.xslt").str()))
				return 0;
		}
		if(!stricmp(method, "CloseSession")||!stricmp(method, "CloseSessionRequest"))
		{
			Owned<CCloseSessionRequest> esp_request = new CCloseSessionRequest(&context, "ws_configmgr", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			CEmptyResponse* resp = new CEmptyResponse("ws_configmgr");
			esp_response.setown(resp);
			MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
			source.setf("ws_configmgr::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				if(accessmap.ordinality()>0)
					onFeaturesAuthorize(context, accessmap, "ws_configmgr", "CloseSession");
				iserv->onCloseSession(context, *esp_request.get(), *resp);
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "ws_configmgr", "CloseSession", StringBuffer(getCFD()).append("xslt/exceptions.xslt").str()))
				return 0;
		}
		if(!stricmp(method, "FetchNodes")||!stricmp(method, "FetchNodesRequest"))
		{
			Owned<CFetchNodesRequest> esp_request = new CFetchNodesRequest(&context, "ws_configmgr", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			CFetchNodesResponse* resp = new CFetchNodesResponse("ws_configmgr");
			esp_response.setown(resp);
			MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
			source.setf("ws_configmgr::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				if(accessmap.ordinality()>0)
					onFeaturesAuthorize(context, accessmap, "ws_configmgr", "FetchNodes");
				iserv->onFetchNodes(context, *esp_request.get(), *resp);
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "ws_configmgr", "FetchNodes", StringBuffer(getCFD()).append("xslt/exceptions.xslt").str()))
				return 0;
		}
		if(!stricmp(method, "GetCreateNodeInfo")||!stricmp(method, "GetCreateNodeInfoRequest"))
		{
			Owned<CGetCreateNodeInfoRequest> esp_request = new CGetCreateNodeInfoRequest(&context, "ws_configmgr", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			CGetCreateNodeInfoResponse* resp = new CGetCreateNodeInfoResponse("ws_configmgr");
			esp_response.setown(resp);
			MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
			source.setf("ws_configmgr::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				if(accessmap.ordinality()>0)
					onFeaturesAuthorize(context, accessmap, "ws_configmgr", "GetCreateNodeInfo");
				iserv->onGetCreateNodeInfo(context, *esp_request.get(), *resp);
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "ws_configmgr", "GetCreateNodeInfo", StringBuffer(getCFD()).append("xslt/exceptions.xslt").str()))
				return 0;
		}
		if(!stricmp(method, "GetEnvironmentFileList")||!stricmp(method, "GetEnvironmentFileListRequest"))
		{
			Owned<CGetEnvironmentFileListRequest> esp_request = new CGetEnvironmentFileListRequest(&context, "ws_configmgr", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			CGetEnvironmentListResponse* resp = new CGetEnvironmentListResponse("ws_configmgr");
			esp_response.setown(resp);
			MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
			source.setf("ws_configmgr::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				if(accessmap.ordinality()>0)
					onFeaturesAuthorize(context, accessmap, "ws_configmgr", "GetEnvironmentFileList");
				iserv->onGetEnvironmentFileList(context, *esp_request.get(), *resp);
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "ws_configmgr", "GetEnvironmentFileList", StringBuffer(getCFD()).append("xslt/exceptions.xslt").str()))
				return 0;
		}
		if(!stricmp(method, "GetNode")||!stricmp(method, "GetNodeRequest"))
		{
			Owned<CGetNodeRequest> esp_request = new CGetNodeRequest(&context, "ws_configmgr", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			CGetNodeResponse* resp = new CGetNodeResponse("ws_configmgr");
			esp_response.setown(resp);
			MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
			source.setf("ws_configmgr::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				if(accessmap.ordinality()>0)
					onFeaturesAuthorize(context, accessmap, "ws_configmgr", "GetNode");
				iserv->onGetNode(context, *esp_request.get(), *resp);
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "ws_configmgr", "GetNode", StringBuffer(getCFD()).append("xslt/exceptions.xslt").str()))
				return 0;
		}
		if(!stricmp(method, "GetNodeCopy")||!stricmp(method, "GetNodeCopyRequest"))
		{
			Owned<CGetNodeCopyRequest> esp_request = new CGetNodeCopyRequest(&context, "ws_configmgr", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			CGetNodeCopyResponse* resp = new CGetNodeCopyResponse("ws_configmgr");
			esp_response.setown(resp);
			MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
			source.setf("ws_configmgr::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				if(accessmap.ordinality()>0)
					onFeaturesAuthorize(context, accessmap, "ws_configmgr", "GetNodeCopy");
				iserv->onGetNodeCopy(context, *esp_request.get(), *resp);
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "ws_configmgr", "GetNodeCopy", StringBuffer(getCFD()).append("xslt/exceptions.xslt").str()))
				return 0;
		}
		if(!stricmp(method, "GetNodeTree")||!stricmp(method, "GetTreeRequest"))
		{
			Owned<CGetTreeRequest> esp_request = new CGetTreeRequest(&context, "ws_configmgr", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			CGetTreeResponse* resp = new CGetTreeResponse("ws_configmgr");
			esp_response.setown(resp);
			MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
			source.setf("ws_configmgr::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				if(accessmap.ordinality()>0)
					onFeaturesAuthorize(context, accessmap, "ws_configmgr", "GetNodeTree");
				iserv->onGetNodeTree(context, *esp_request.get(), *resp);
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "ws_configmgr", "GetNodeTree", StringBuffer(getCFD()).append("xslt/exceptions.xslt").str()))
				return 0;
		}
		if(!stricmp(method, "GetOpenSessions")||!stricmp(method, "ListOpenSessionsRequest"))
		{
			Owned<CListOpenSessionsRequest> esp_request = new CListOpenSessionsRequest(&context, "ws_configmgr", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			CListOpenSessionsResponse* resp = new CListOpenSessionsResponse("ws_configmgr");
			esp_response.setown(resp);
			MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
			source.setf("ws_configmgr::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				if(accessmap.ordinality()>0)
					onFeaturesAuthorize(context, accessmap, "ws_configmgr", "GetOpenSessions");
				iserv->onGetOpenSessions(context, *esp_request.get(), *resp);
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "ws_configmgr", "GetOpenSessions", StringBuffer(getCFD()).append("xslt/exceptions.xslt").str()))
				return 0;
		}
		if(!stricmp(method, "GetParents")||!stricmp(method, "GetParentsRequest"))
		{
			Owned<CGetParentsRequest> esp_request = new CGetParentsRequest(&context, "ws_configmgr", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			CGetParentsResponse* resp = new CGetParentsResponse("ws_configmgr");
			esp_response.setown(resp);
			MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
			source.setf("ws_configmgr::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				if(accessmap.ordinality()>0)
					onFeaturesAuthorize(context, accessmap, "ws_configmgr", "GetParents");
				iserv->onGetParents(context, *esp_request.get(), *resp);
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "ws_configmgr", "GetParents", StringBuffer(getCFD()).append("xslt/exceptions.xslt").str()))
				return 0;
		}
		if(!stricmp(method, "InsertNode")||!stricmp(method, "InsertNodeRequest"))
		{
			Owned<CInsertNodeRequest> esp_request = new CInsertNodeRequest(&context, "ws_configmgr", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			CGetNodeResponse* resp = new CGetNodeResponse("ws_configmgr");
			esp_response.setown(resp);
			MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
			source.setf("ws_configmgr::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				if(accessmap.ordinality()>0)
					onFeaturesAuthorize(context, accessmap, "ws_configmgr", "InsertNode");
				iserv->onInsertNode(context, *esp_request.get(), *resp);
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "ws_configmgr", "InsertNode", StringBuffer(getCFD()).append("xslt/exceptions.xslt").str()))
				return 0;
		}
		if(!stricmp(method, "InsertNodeCopy")||!stricmp(method, "PasteNodeCopyRequest"))
		{
			Owned<CPasteNodeCopyRequest> esp_request = new CPasteNodeCopyRequest(&context, "ws_configmgr", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			CPasteNodeCopyResponse* resp = new CPasteNodeCopyResponse("ws_configmgr");
			esp_response.setown(resp);
			MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
			source.setf("ws_configmgr::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				if(accessmap.ordinality()>0)
					onFeaturesAuthorize(context, accessmap, "ws_configmgr", "InsertNodeCopy");
				iserv->onInsertNodeCopy(context, *esp_request.get(), *resp);
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "ws_configmgr", "InsertNodeCopy", StringBuffer(getCFD()).append("xslt/exceptions.xslt").str()))
				return 0;
		}
		if(!stricmp(method, "LockSession")||!stricmp(method, "LockSessionRequest"))
		{
			Owned<CLockSessionRequest> esp_request = new CLockSessionRequest(&context, "ws_configmgr", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			CLockSessionResponse* resp = new CLockSessionResponse("ws_configmgr");
			esp_response.setown(resp);
			MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
			source.setf("ws_configmgr::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				if(accessmap.ordinality()>0)
					onFeaturesAuthorize(context, accessmap, "ws_configmgr", "LockSession");
				iserv->onLockSession(context, *esp_request.get(), *resp);
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "ws_configmgr", "LockSession", StringBuffer(getCFD()).append("xslt/exceptions.xslt").str()))
				return 0;
		}
		if(!stricmp(method, "OpenEnvironmentFile")||!stricmp(method, "OpenEnvironmentFileRequest"))
		{
			Owned<COpenEnvironmentFileRequest> esp_request = new COpenEnvironmentFileRequest(&context, "ws_configmgr", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			COpenEnvironmentFileResponse* resp = new COpenEnvironmentFileResponse("ws_configmgr");
			esp_response.setown(resp);
			MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
			source.setf("ws_configmgr::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				if(accessmap.ordinality()>0)
					onFeaturesAuthorize(context, accessmap, "ws_configmgr", "OpenEnvironmentFile");
				iserv->onOpenEnvironmentFile(context, *esp_request.get(), *resp);
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "ws_configmgr", "OpenEnvironmentFile", StringBuffer(getCFD()).append("xslt/exceptions.xslt").str()))
				return 0;
		}
		if(!stricmp(method, "OpenSession")||!stricmp(method, "OpenSessionRequest"))
		{
			Owned<COpenSessionRequest> esp_request = new COpenSessionRequest(&context, "ws_configmgr", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			COpenSessionResponse* resp = new COpenSessionResponse("ws_configmgr");
			esp_response.setown(resp);
			MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
			source.setf("ws_configmgr::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				if(accessmap.ordinality()>0)
					onFeaturesAuthorize(context, accessmap, "ws_configmgr", "OpenSession");
				iserv->onOpenSession(context, *esp_request.get(), *resp);
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "ws_configmgr", "OpenSession", StringBuffer(getCFD()).append("xslt/exceptions.xslt").str()))
				return 0;
		}
		if(!stricmp(method, "Ping")||!stricmp(method, "ws_configmgrPingRequest"))
		{
			Owned<Cws_configmgrPingRequest> esp_request = new Cws_configmgrPingRequest(&context, "ws_configmgr", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			Cws_configmgrPingResponse* resp = new Cws_configmgrPingResponse("ws_configmgr");
			esp_response.setown(resp);
			MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
			source.setf("ws_configmgr::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				if(accessmap.ordinality()>0)
					onFeaturesAuthorize(context, accessmap, "ws_configmgr", "Ping");
				iserv->onPing(context, *esp_request.get(), *resp);
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "ws_configmgr", "Ping", StringBuffer(getCFD()).append("xslt/exceptions.xslt").str()))
				return 0;
		}
		if(!stricmp(method, "RemoveNode")||!stricmp(method, "RemoveNodeRequest"))
		{
			Owned<CRemoveNodeRequest> esp_request = new CRemoveNodeRequest(&context, "ws_configmgr", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			CStatusResponse* resp = new CStatusResponse("ws_configmgr");
			esp_response.setown(resp);
			MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
			source.setf("ws_configmgr::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				if(accessmap.ordinality()>0)
					onFeaturesAuthorize(context, accessmap, "ws_configmgr", "RemoveNode");
				iserv->onRemoveNode(context, *esp_request.get(), *resp);
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "ws_configmgr", "RemoveNode", StringBuffer(getCFD()).append("xslt/exceptions.xslt").str()))
				return 0;
		}
		if(!stricmp(method, "SaveEnvironmentFile")||!stricmp(method, "SaveEnvironmentFileRequest"))
		{
			Owned<CSaveEnvironmentFileRequest> esp_request = new CSaveEnvironmentFileRequest(&context, "ws_configmgr", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			CEmptyResponse* resp = new CEmptyResponse("ws_configmgr");
			esp_response.setown(resp);
			MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
			source.setf("ws_configmgr::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				if(accessmap.ordinality()>0)
					onFeaturesAuthorize(context, accessmap, "ws_configmgr", "SaveEnvironmentFile");
				iserv->onSaveEnvironmentFile(context, *esp_request.get(), *resp);
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "ws_configmgr", "SaveEnvironmentFile", StringBuffer(getCFD()).append("xslt/exceptions.xslt").str()))
				return 0;
		}
		if(!stricmp(method, "SetValues")||!stricmp(method, "SetValuesRequest"))
		{
			Owned<CSetValuesRequest> esp_request = new CSetValuesRequest(&context, "ws_configmgr", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			CStatusResponse* resp = new CStatusResponse("ws_configmgr");
			esp_response.setown(resp);
			MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
			source.setf("ws_configmgr::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				if(accessmap.ordinality()>0)
					onFeaturesAuthorize(context, accessmap, "ws_configmgr", "SetValues");
				iserv->onSetValues(context, *esp_request.get(), *resp);
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "ws_configmgr", "SetValues", StringBuffer(getCFD()).append("xslt/exceptions.xslt").str()))
				return 0;
		}
		if(!stricmp(method, "UnlockSession")||!stricmp(method, "UnlockSessionRequest"))
		{
			Owned<CUnlockSessionRequest> esp_request = new CUnlockSessionRequest(&context, "ws_configmgr", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			CEmptyResponse* resp = new CEmptyResponse("ws_configmgr");
			esp_response.setown(resp);
			MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
			source.setf("ws_configmgr::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				if(accessmap.ordinality()>0)
					onFeaturesAuthorize(context, accessmap, "ws_configmgr", "UnlockSession");
				iserv->onUnlockSession(context, *esp_request.get(), *resp);
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "ws_configmgr", "UnlockSession", StringBuffer(getCFD()).append("xslt/exceptions.xslt").str()))
				return 0;
		}
		if(!stricmp(method, "ValidateEnvironment")||!stricmp(method, "ValidateEnvironmentRequest"))
		{
			Owned<CValidateEnvironmentRequest> esp_request = new CValidateEnvironmentRequest(&context, "ws_configmgr", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			CStatusResponse* resp = new CStatusResponse("ws_configmgr");
			esp_response.setown(resp);
			MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
			source.setf("ws_configmgr::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				if(accessmap.ordinality()>0)
					onFeaturesAuthorize(context, accessmap, "ws_configmgr", "ValidateEnvironment");
				iserv->onValidateEnvironment(context, *esp_request.get(), *resp);
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "ws_configmgr", "ValidateEnvironment", StringBuffer(getCFD()).append("xslt/exceptions.xslt").str()))
				return 0;
		}

		if (esp_response.get())
		{
			if (canRedirect(*request) && esp_response->getRedirectUrl() && *esp_response->getRedirectUrl())
				response->redirect(*request, esp_response->getRedirectUrl());
			else
			{
				MemoryBuffer content;
				StringBuffer mimetype;
				esp_response->appendContent(&context,content, mimetype);
				onBeforeSendResponse(context,request,content,service,method);
				response->setContent(content.length(), content.toByteArray());
				response->setContentType(mimetype.str());
				response->send();
			}
			return 0;
		}
	}
	return onGetNotFound(context, request,  response, service);
}





//=======================================================
// client util methods
//=======================================================

//------ method CloseEnvironmentFile ---------

IClientCloseEnvironmentFileRequest * CClientws_configmgr::createCloseEnvironmentFileRequest()
{
	CCloseEnvironmentFileRequest* request = new CCloseEnvironmentFileRequest("ws_configmgr");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientEmptyResponse * CClientws_configmgr::CloseEnvironmentFile(IClientCloseEnvironmentFileRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CCloseEnvironmentFileRequest* esprequest = static_cast<CCloseEnvironmentFileRequest*>(request);
	CEmptyResponse* espresponse = new CEmptyResponse("ws_configmgr");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientws_configmgr::async_CloseEnvironmentFile(IClientCloseEnvironmentFileRequest *request, IClientws_configmgrEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CCloseEnvironmentFileRequest* esprequest = static_cast<CCloseEnvironmentFileRequest*>(request);
	esprequest->setMethod("CloseEnvironmentFile");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientws_configmgr::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientEmptyResponse *CClientws_configmgr::CloseEnvironmentFileFn(const char * SessionId_, const char * SessionLockKey_, bool DiscardChanges_)
{
	Owned<IClientCloseEnvironmentFileRequest> req =  createCloseEnvironmentFileRequest();
	req->setSessionId(SessionId_);
	req->setSessionLockKey(SessionLockKey_);
	req->setDiscardChanges(DiscardChanges_);
	return CloseEnvironmentFile(req.get());
}

//------ method CloseSession ---------

IClientCloseSessionRequest * CClientws_configmgr::createCloseSessionRequest()
{
	CCloseSessionRequest* request = new CCloseSessionRequest("ws_configmgr");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientEmptyResponse * CClientws_configmgr::CloseSession(IClientCloseSessionRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CCloseSessionRequest* esprequest = static_cast<CCloseSessionRequest*>(request);
	CEmptyResponse* espresponse = new CEmptyResponse("ws_configmgr");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientws_configmgr::async_CloseSession(IClientCloseSessionRequest *request, IClientws_configmgrEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CCloseSessionRequest* esprequest = static_cast<CCloseSessionRequest*>(request);
	esprequest->setMethod("CloseSession");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientws_configmgr::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientEmptyResponse *CClientws_configmgr::CloseSessionFn(const char * SessionId_, bool ForceClose_)
{
	Owned<IClientCloseSessionRequest> req =  createCloseSessionRequest();
	req->setSessionId(SessionId_);
	req->setForceClose(ForceClose_);
	return CloseSession(req.get());
}

//------ method FetchNodes ---------

IClientFetchNodesRequest * CClientws_configmgr::createFetchNodesRequest()
{
	CFetchNodesRequest* request = new CFetchNodesRequest("ws_configmgr");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientFetchNodesResponse * CClientws_configmgr::FetchNodes(IClientFetchNodesRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CFetchNodesRequest* esprequest = static_cast<CFetchNodesRequest*>(request);
	CFetchNodesResponse* espresponse = new CFetchNodesResponse("ws_configmgr");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientws_configmgr::async_FetchNodes(IClientFetchNodesRequest *request, IClientws_configmgrEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CFetchNodesRequest* esprequest = static_cast<CFetchNodesRequest*>(request);
	esprequest->setMethod("FetchNodes");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientws_configmgr::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientFetchNodesResponse *CClientws_configmgr::FetchNodesFn(const char * SessionId_, const char * StartingNodeId_, const char * Path_)
{
	Owned<IClientFetchNodesRequest> req =  createFetchNodesRequest();
	req->setSessionId(SessionId_);
	req->setStartingNodeId(StartingNodeId_);
	req->setPath(Path_);
	return FetchNodes(req.get());
}

//------ method GetCreateNodeInfo ---------

IClientGetCreateNodeInfoRequest * CClientws_configmgr::createGetCreateNodeInfoRequest()
{
	CGetCreateNodeInfoRequest* request = new CGetCreateNodeInfoRequest("ws_configmgr");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientGetCreateNodeInfoResponse * CClientws_configmgr::GetCreateNodeInfo(IClientGetCreateNodeInfoRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CGetCreateNodeInfoRequest* esprequest = static_cast<CGetCreateNodeInfoRequest*>(request);
	CGetCreateNodeInfoResponse* espresponse = new CGetCreateNodeInfoResponse("ws_configmgr");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientws_configmgr::async_GetCreateNodeInfo(IClientGetCreateNodeInfoRequest *request, IClientws_configmgrEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CGetCreateNodeInfoRequest* esprequest = static_cast<CGetCreateNodeInfoRequest*>(request);
	esprequest->setMethod("GetCreateNodeInfo");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientws_configmgr::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientGetCreateNodeInfoResponse *CClientws_configmgr::GetCreateNodeInfoFn(const char * SessionId_, const char * ParentNodeId_, const char * NodeType_)
{
	Owned<IClientGetCreateNodeInfoRequest> req =  createGetCreateNodeInfoRequest();
	req->setSessionId(SessionId_);
	req->setParentNodeId(ParentNodeId_);
	req->setNodeType(NodeType_);
	return GetCreateNodeInfo(req.get());
}

//------ method GetEnvironmentFileList ---------

IClientGetEnvironmentFileListRequest * CClientws_configmgr::createGetEnvironmentFileListRequest()
{
	CGetEnvironmentFileListRequest* request = new CGetEnvironmentFileListRequest("ws_configmgr");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientGetEnvironmentListResponse * CClientws_configmgr::GetEnvironmentFileList(IClientGetEnvironmentFileListRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CGetEnvironmentFileListRequest* esprequest = static_cast<CGetEnvironmentFileListRequest*>(request);
	CGetEnvironmentListResponse* espresponse = new CGetEnvironmentListResponse("ws_configmgr");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientws_configmgr::async_GetEnvironmentFileList(IClientGetEnvironmentFileListRequest *request, IClientws_configmgrEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CGetEnvironmentFileListRequest* esprequest = static_cast<CGetEnvironmentFileListRequest*>(request);
	esprequest->setMethod("GetEnvironmentFileList");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientws_configmgr::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientGetEnvironmentListResponse *CClientws_configmgr::GetEnvironmentFileListFn(const char * SessionId_)
{
	Owned<IClientGetEnvironmentFileListRequest> req =  createGetEnvironmentFileListRequest();
	req->setSessionId(SessionId_);
	return GetEnvironmentFileList(req.get());
}

//------ method GetNode ---------

IClientGetNodeRequest * CClientws_configmgr::createGetNodeRequest()
{
	CGetNodeRequest* request = new CGetNodeRequest("ws_configmgr");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientGetNodeResponse * CClientws_configmgr::GetNode(IClientGetNodeRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CGetNodeRequest* esprequest = static_cast<CGetNodeRequest*>(request);
	CGetNodeResponse* espresponse = new CGetNodeResponse("ws_configmgr");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientws_configmgr::async_GetNode(IClientGetNodeRequest *request, IClientws_configmgrEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CGetNodeRequest* esprequest = static_cast<CGetNodeRequest*>(request);
	esprequest->setMethod("GetNode");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientws_configmgr::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientGetNodeResponse *CClientws_configmgr::GetNodeFn(const char * SessionId_, const char * NodeId_)
{
	Owned<IClientGetNodeRequest> req =  createGetNodeRequest();
	req->setSessionId(SessionId_);
	req->setNodeId(NodeId_);
	return GetNode(req.get());
}

//------ method GetNodeCopy ---------

IClientGetNodeCopyRequest * CClientws_configmgr::createGetNodeCopyRequest()
{
	CGetNodeCopyRequest* request = new CGetNodeCopyRequest("ws_configmgr");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientGetNodeCopyResponse * CClientws_configmgr::GetNodeCopy(IClientGetNodeCopyRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CGetNodeCopyRequest* esprequest = static_cast<CGetNodeCopyRequest*>(request);
	CGetNodeCopyResponse* espresponse = new CGetNodeCopyResponse("ws_configmgr");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientws_configmgr::async_GetNodeCopy(IClientGetNodeCopyRequest *request, IClientws_configmgrEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CGetNodeCopyRequest* esprequest = static_cast<CGetNodeCopyRequest*>(request);
	esprequest->setMethod("GetNodeCopy");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientws_configmgr::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientGetNodeCopyResponse *CClientws_configmgr::GetNodeCopyFn(const char * SessionId_, const char * NodeId_)
{
	Owned<IClientGetNodeCopyRequest> req =  createGetNodeCopyRequest();
	req->setSessionId(SessionId_);
	req->setNodeId(NodeId_);
	return GetNodeCopy(req.get());
}

//------ method GetNodeTree ---------

IClientGetTreeRequest * CClientws_configmgr::createGetNodeTreeRequest()
{
	CGetTreeRequest* request = new CGetTreeRequest("ws_configmgr");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientGetTreeResponse * CClientws_configmgr::GetNodeTree(IClientGetTreeRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CGetTreeRequest* esprequest = static_cast<CGetTreeRequest*>(request);
	CGetTreeResponse* espresponse = new CGetTreeResponse("ws_configmgr");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientws_configmgr::async_GetNodeTree(IClientGetTreeRequest *request, IClientws_configmgrEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CGetTreeRequest* esprequest = static_cast<CGetTreeRequest*>(request);
	esprequest->setMethod("GetNodeTree");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientws_configmgr::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientGetTreeResponse *CClientws_configmgr::GetNodeTreeFn(const char * SessionId_, const char * NodeId_, bool IncludeAttributes_, int NumLevels_)
{
	Owned<IClientGetTreeRequest> req =  createGetNodeTreeRequest();
	req->setSessionId(SessionId_);
	req->setNodeId(NodeId_);
	req->setIncludeAttributes(IncludeAttributes_);
	req->setNumLevels(NumLevels_);
	return GetNodeTree(req.get());
}

//------ method GetOpenSessions ---------

IClientListOpenSessionsRequest * CClientws_configmgr::createGetOpenSessionsRequest()
{
	CListOpenSessionsRequest* request = new CListOpenSessionsRequest("ws_configmgr");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientListOpenSessionsResponse * CClientws_configmgr::GetOpenSessions(IClientListOpenSessionsRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CListOpenSessionsRequest* esprequest = static_cast<CListOpenSessionsRequest*>(request);
	CListOpenSessionsResponse* espresponse = new CListOpenSessionsResponse("ws_configmgr");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientws_configmgr::async_GetOpenSessions(IClientListOpenSessionsRequest *request, IClientws_configmgrEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CListOpenSessionsRequest* esprequest = static_cast<CListOpenSessionsRequest*>(request);
	esprequest->setMethod("GetOpenSessions");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientws_configmgr::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientListOpenSessionsResponse *CClientws_configmgr::GetOpenSessionsFn()
{
	Owned<IClientListOpenSessionsRequest> req =  createGetOpenSessionsRequest();
	return GetOpenSessions(req.get());
}

//------ method GetParents ---------

IClientGetParentsRequest * CClientws_configmgr::createGetParentsRequest()
{
	CGetParentsRequest* request = new CGetParentsRequest("ws_configmgr");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientGetParentsResponse * CClientws_configmgr::GetParents(IClientGetParentsRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CGetParentsRequest* esprequest = static_cast<CGetParentsRequest*>(request);
	CGetParentsResponse* espresponse = new CGetParentsResponse("ws_configmgr");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientws_configmgr::async_GetParents(IClientGetParentsRequest *request, IClientws_configmgrEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CGetParentsRequest* esprequest = static_cast<CGetParentsRequest*>(request);
	esprequest->setMethod("GetParents");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientws_configmgr::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientGetParentsResponse *CClientws_configmgr::GetParentsFn(const char * SessionId_, const char * NodeId_)
{
	Owned<IClientGetParentsRequest> req =  createGetParentsRequest();
	req->setSessionId(SessionId_);
	req->setNodeId(NodeId_);
	return GetParents(req.get());
}

//------ method InsertNode ---------

IClientInsertNodeRequest * CClientws_configmgr::createInsertNodeRequest()
{
	CInsertNodeRequest* request = new CInsertNodeRequest("ws_configmgr");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientGetNodeResponse * CClientws_configmgr::InsertNode(IClientInsertNodeRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CInsertNodeRequest* esprequest = static_cast<CInsertNodeRequest*>(request);
	CGetNodeResponse* espresponse = new CGetNodeResponse("ws_configmgr");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientws_configmgr::async_InsertNode(IClientInsertNodeRequest *request, IClientws_configmgrEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CInsertNodeRequest* esprequest = static_cast<CInsertNodeRequest*>(request);
	esprequest->setMethod("InsertNode");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientws_configmgr::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientGetNodeResponse *CClientws_configmgr::InsertNodeFn(const char * SessionId_, const char * SessionLockKey_, const char * ParentNodeId_, const char * NodeType_, IArrayOf<IConstAttributeValueType> &AttributeValues_, bool AllowInvalid_, bool ForceCreate_, const char * LocalValue_)
{
	Owned<IClientInsertNodeRequest> req =  createInsertNodeRequest();
	req->setSessionId(SessionId_);
	req->setSessionLockKey(SessionLockKey_);
	req->setParentNodeId(ParentNodeId_);
	req->setNodeType(NodeType_);
	req->setAttributeValues(AttributeValues_);
	req->setAllowInvalid(AllowInvalid_);
	req->setForceCreate(ForceCreate_);
	req->setLocalValue(LocalValue_);
	return InsertNode(req.get());
}

//------ method InsertNodeCopy ---------

IClientPasteNodeCopyRequest * CClientws_configmgr::createInsertNodeCopyRequest()
{
	CPasteNodeCopyRequest* request = new CPasteNodeCopyRequest("ws_configmgr");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientPasteNodeCopyResponse * CClientws_configmgr::InsertNodeCopy(IClientPasteNodeCopyRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CPasteNodeCopyRequest* esprequest = static_cast<CPasteNodeCopyRequest*>(request);
	CPasteNodeCopyResponse* espresponse = new CPasteNodeCopyResponse("ws_configmgr");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientws_configmgr::async_InsertNodeCopy(IClientPasteNodeCopyRequest *request, IClientws_configmgrEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CPasteNodeCopyRequest* esprequest = static_cast<CPasteNodeCopyRequest*>(request);
	esprequest->setMethod("InsertNodeCopy");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientws_configmgr::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientPasteNodeCopyResponse *CClientws_configmgr::InsertNodeCopyFn(const char * SessionId_, const char * SessionLockKey_, const char * ParentNodeId_, const char * NodeCopy_)
{
	Owned<IClientPasteNodeCopyRequest> req =  createInsertNodeCopyRequest();
	req->setSessionId(SessionId_);
	req->setSessionLockKey(SessionLockKey_);
	req->setParentNodeId(ParentNodeId_);
	req->setNodeCopy(NodeCopy_);
	return InsertNodeCopy(req.get());
}

//------ method LockSession ---------

IClientLockSessionRequest * CClientws_configmgr::createLockSessionRequest()
{
	CLockSessionRequest* request = new CLockSessionRequest("ws_configmgr");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientLockSessionResponse * CClientws_configmgr::LockSession(IClientLockSessionRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CLockSessionRequest* esprequest = static_cast<CLockSessionRequest*>(request);
	CLockSessionResponse* espresponse = new CLockSessionResponse("ws_configmgr");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientws_configmgr::async_LockSession(IClientLockSessionRequest *request, IClientws_configmgrEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CLockSessionRequest* esprequest = static_cast<CLockSessionRequest*>(request);
	esprequest->setMethod("LockSession");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientws_configmgr::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientLockSessionResponse *CClientws_configmgr::LockSessionFn(const char * SessionId_)
{
	Owned<IClientLockSessionRequest> req =  createLockSessionRequest();
	req->setSessionId(SessionId_);
	return LockSession(req.get());
}

//------ method OpenEnvironmentFile ---------

IClientOpenEnvironmentFileRequest * CClientws_configmgr::createOpenEnvironmentFileRequest()
{
	COpenEnvironmentFileRequest* request = new COpenEnvironmentFileRequest("ws_configmgr");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientOpenEnvironmentFileResponse * CClientws_configmgr::OpenEnvironmentFile(IClientOpenEnvironmentFileRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	COpenEnvironmentFileRequest* esprequest = static_cast<COpenEnvironmentFileRequest*>(request);
	COpenEnvironmentFileResponse* espresponse = new COpenEnvironmentFileResponse("ws_configmgr");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientws_configmgr::async_OpenEnvironmentFile(IClientOpenEnvironmentFileRequest *request, IClientws_configmgrEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	COpenEnvironmentFileRequest* esprequest = static_cast<COpenEnvironmentFileRequest*>(request);
	esprequest->setMethod("OpenEnvironmentFile");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientws_configmgr::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientOpenEnvironmentFileResponse *CClientws_configmgr::OpenEnvironmentFileFn(const char * SessionId_, const char * Filename_)
{
	Owned<IClientOpenEnvironmentFileRequest> req =  createOpenEnvironmentFileRequest();
	req->setSessionId(SessionId_);
	req->setFilename(Filename_);
	return OpenEnvironmentFile(req.get());
}

//------ method OpenSession ---------

IClientOpenSessionRequest * CClientws_configmgr::createOpenSessionRequest()
{
	COpenSessionRequest* request = new COpenSessionRequest("ws_configmgr");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientOpenSessionResponse * CClientws_configmgr::OpenSession(IClientOpenSessionRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	COpenSessionRequest* esprequest = static_cast<COpenSessionRequest*>(request);
	COpenSessionResponse* espresponse = new COpenSessionResponse("ws_configmgr");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientws_configmgr::async_OpenSession(IClientOpenSessionRequest *request, IClientws_configmgrEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	COpenSessionRequest* esprequest = static_cast<COpenSessionRequest*>(request);
	esprequest->setMethod("OpenSession");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientws_configmgr::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientOpenSessionResponse *CClientws_configmgr::OpenSessionFn(const char * Username_, const char * SchemaPath_, const char * MasterSchemaFile_, const char * SourcePath_, const char * ActivePath_, const char * PluginPaths_)
{
	Owned<IClientOpenSessionRequest> req =  createOpenSessionRequest();
	req->setUsername(Username_);
	req->setSchemaPath(SchemaPath_);
	req->setMasterSchemaFile(MasterSchemaFile_);
	req->setSourcePath(SourcePath_);
	req->setActivePath(ActivePath_);
	req->setPluginPaths(PluginPaths_);
	return OpenSession(req.get());
}

//------ method Ping ---------

IClientws_configmgrPingRequest * CClientws_configmgr::createPingRequest()
{
	Cws_configmgrPingRequest* request = new Cws_configmgrPingRequest("ws_configmgr");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientws_configmgrPingResponse * CClientws_configmgr::Ping(IClientws_configmgrPingRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	Cws_configmgrPingRequest* esprequest = static_cast<Cws_configmgrPingRequest*>(request);
	Cws_configmgrPingResponse* espresponse = new Cws_configmgrPingResponse("ws_configmgr");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientws_configmgr::async_Ping(IClientws_configmgrPingRequest *request, IClientws_configmgrEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	Cws_configmgrPingRequest* esprequest = static_cast<Cws_configmgrPingRequest*>(request);
	esprequest->setMethod("Ping");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientws_configmgr::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientws_configmgrPingResponse *CClientws_configmgr::PingFn()
{
	Owned<IClientws_configmgrPingRequest> req =  createPingRequest();
	return Ping(req.get());
}

//------ method RemoveNode ---------

IClientRemoveNodeRequest * CClientws_configmgr::createRemoveNodeRequest()
{
	CRemoveNodeRequest* request = new CRemoveNodeRequest("ws_configmgr");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientStatusResponse * CClientws_configmgr::RemoveNode(IClientRemoveNodeRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CRemoveNodeRequest* esprequest = static_cast<CRemoveNodeRequest*>(request);
	CStatusResponse* espresponse = new CStatusResponse("ws_configmgr");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientws_configmgr::async_RemoveNode(IClientRemoveNodeRequest *request, IClientws_configmgrEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CRemoveNodeRequest* esprequest = static_cast<CRemoveNodeRequest*>(request);
	esprequest->setMethod("RemoveNode");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientws_configmgr::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientStatusResponse *CClientws_configmgr::RemoveNodeFn(const char * SessionId_, const char * SessionLockKey_, const char * NodeId_)
{
	Owned<IClientRemoveNodeRequest> req =  createRemoveNodeRequest();
	req->setSessionId(SessionId_);
	req->setSessionLockKey(SessionLockKey_);
	req->setNodeId(NodeId_);
	return RemoveNode(req.get());
}

//------ method SaveEnvironmentFile ---------

IClientSaveEnvironmentFileRequest * CClientws_configmgr::createSaveEnvironmentFileRequest()
{
	CSaveEnvironmentFileRequest* request = new CSaveEnvironmentFileRequest("ws_configmgr");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientEmptyResponse * CClientws_configmgr::SaveEnvironmentFile(IClientSaveEnvironmentFileRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CSaveEnvironmentFileRequest* esprequest = static_cast<CSaveEnvironmentFileRequest*>(request);
	CEmptyResponse* espresponse = new CEmptyResponse("ws_configmgr");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientws_configmgr::async_SaveEnvironmentFile(IClientSaveEnvironmentFileRequest *request, IClientws_configmgrEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CSaveEnvironmentFileRequest* esprequest = static_cast<CSaveEnvironmentFileRequest*>(request);
	esprequest->setMethod("SaveEnvironmentFile");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientws_configmgr::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientEmptyResponse *CClientws_configmgr::SaveEnvironmentFileFn(const char * SessionId_, const char * SessionLockKey_, const char * Filename_)
{
	Owned<IClientSaveEnvironmentFileRequest> req =  createSaveEnvironmentFileRequest();
	req->setSessionId(SessionId_);
	req->setSessionLockKey(SessionLockKey_);
	req->setFilename(Filename_);
	return SaveEnvironmentFile(req.get());
}

//------ method SetValues ---------

IClientSetValuesRequest * CClientws_configmgr::createSetValuesRequest()
{
	CSetValuesRequest* request = new CSetValuesRequest("ws_configmgr");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientStatusResponse * CClientws_configmgr::SetValues(IClientSetValuesRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CSetValuesRequest* esprequest = static_cast<CSetValuesRequest*>(request);
	CStatusResponse* espresponse = new CStatusResponse("ws_configmgr");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientws_configmgr::async_SetValues(IClientSetValuesRequest *request, IClientws_configmgrEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CSetValuesRequest* esprequest = static_cast<CSetValuesRequest*>(request);
	esprequest->setMethod("SetValues");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientws_configmgr::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientStatusResponse *CClientws_configmgr::SetValuesFn(const char * SessionId_, const char * SessionLockKey_, const char * NodeId_, IArrayOf<IConstAttributeValueType> &AttributeValues_, bool AllowInvalid_, bool ForceCreate_, const char * LocalValue_)
{
	Owned<IClientSetValuesRequest> req =  createSetValuesRequest();
	req->setSessionId(SessionId_);
	req->setSessionLockKey(SessionLockKey_);
	req->setNodeId(NodeId_);
	req->setAttributeValues(AttributeValues_);
	req->setAllowInvalid(AllowInvalid_);
	req->setForceCreate(ForceCreate_);
	req->setLocalValue(LocalValue_);
	return SetValues(req.get());
}

//------ method UnlockSession ---------

IClientUnlockSessionRequest * CClientws_configmgr::createUnlockSessionRequest()
{
	CUnlockSessionRequest* request = new CUnlockSessionRequest("ws_configmgr");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientEmptyResponse * CClientws_configmgr::UnlockSession(IClientUnlockSessionRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CUnlockSessionRequest* esprequest = static_cast<CUnlockSessionRequest*>(request);
	CEmptyResponse* espresponse = new CEmptyResponse("ws_configmgr");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientws_configmgr::async_UnlockSession(IClientUnlockSessionRequest *request, IClientws_configmgrEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CUnlockSessionRequest* esprequest = static_cast<CUnlockSessionRequest*>(request);
	esprequest->setMethod("UnlockSession");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientws_configmgr::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientEmptyResponse *CClientws_configmgr::UnlockSessionFn(const char * SessionId_, const char * SessionLockKey_, bool RejectIfModified_)
{
	Owned<IClientUnlockSessionRequest> req =  createUnlockSessionRequest();
	req->setSessionId(SessionId_);
	req->setSessionLockKey(SessionLockKey_);
	req->setRejectIfModified(RejectIfModified_);
	return UnlockSession(req.get());
}

//------ method ValidateEnvironment ---------

IClientValidateEnvironmentRequest * CClientws_configmgr::createValidateEnvironmentRequest()
{
	CValidateEnvironmentRequest* request = new CValidateEnvironmentRequest("ws_configmgr");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientStatusResponse * CClientws_configmgr::ValidateEnvironment(IClientValidateEnvironmentRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CValidateEnvironmentRequest* esprequest = static_cast<CValidateEnvironmentRequest*>(request);
	CStatusResponse* espresponse = new CStatusResponse("ws_configmgr");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientws_configmgr::async_ValidateEnvironment(IClientValidateEnvironmentRequest *request, IClientws_configmgrEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CValidateEnvironmentRequest* esprequest = static_cast<CValidateEnvironmentRequest*>(request);
	esprequest->setMethod("ValidateEnvironment");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientws_configmgr::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientStatusResponse *CClientws_configmgr::ValidateEnvironmentFn(const char * SessionId_, bool IncludeHiddenNodes_)
{
	Owned<IClientValidateEnvironmentRequest> req =  createValidateEnvironmentRequest();
	req->setSessionId(SessionId_);
	req->setIncludeHiddenNodes(IncludeHiddenNodes_);
	return ValidateEnvironment(req.get());
}

int CClientws_configmgr::transferThunkEvent(void *data)
{
	IRpcResponseBinding *response = (IRpcResponseBinding *)data;
	if (response!=NULL)
	{
		IClientws_configmgrEvents *eventSink = (IClientws_configmgrEvents *)response->getEventSink();
		response->lock();

		if (stricmp(response->getMethod(), "CloseEnvironmentFile")==0)
		{
			IClientEmptyResponse* icresp = dynamic_cast<IClientEmptyResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onCloseEnvironmentFileComplete(icresp, response->queryState());
				else
					eventSink->onCloseEnvironmentFileError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "CloseSession")==0)
		{
			IClientEmptyResponse* icresp = dynamic_cast<IClientEmptyResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onCloseSessionComplete(icresp, response->queryState());
				else
					eventSink->onCloseSessionError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "FetchNodes")==0)
		{
			IClientFetchNodesResponse* icresp = dynamic_cast<IClientFetchNodesResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onFetchNodesComplete(icresp, response->queryState());
				else
					eventSink->onFetchNodesError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "GetCreateNodeInfo")==0)
		{
			IClientGetCreateNodeInfoResponse* icresp = dynamic_cast<IClientGetCreateNodeInfoResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onGetCreateNodeInfoComplete(icresp, response->queryState());
				else
					eventSink->onGetCreateNodeInfoError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "GetEnvironmentFileList")==0)
		{
			IClientGetEnvironmentListResponse* icresp = dynamic_cast<IClientGetEnvironmentListResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onGetEnvironmentFileListComplete(icresp, response->queryState());
				else
					eventSink->onGetEnvironmentFileListError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "GetNode")==0)
		{
			IClientGetNodeResponse* icresp = dynamic_cast<IClientGetNodeResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onGetNodeComplete(icresp, response->queryState());
				else
					eventSink->onGetNodeError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "GetNodeCopy")==0)
		{
			IClientGetNodeCopyResponse* icresp = dynamic_cast<IClientGetNodeCopyResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onGetNodeCopyComplete(icresp, response->queryState());
				else
					eventSink->onGetNodeCopyError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "GetNodeTree")==0)
		{
			IClientGetTreeResponse* icresp = dynamic_cast<IClientGetTreeResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onGetNodeTreeComplete(icresp, response->queryState());
				else
					eventSink->onGetNodeTreeError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "GetOpenSessions")==0)
		{
			IClientListOpenSessionsResponse* icresp = dynamic_cast<IClientListOpenSessionsResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onGetOpenSessionsComplete(icresp, response->queryState());
				else
					eventSink->onGetOpenSessionsError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "GetParents")==0)
		{
			IClientGetParentsResponse* icresp = dynamic_cast<IClientGetParentsResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onGetParentsComplete(icresp, response->queryState());
				else
					eventSink->onGetParentsError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "InsertNode")==0)
		{
			IClientGetNodeResponse* icresp = dynamic_cast<IClientGetNodeResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onInsertNodeComplete(icresp, response->queryState());
				else
					eventSink->onInsertNodeError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "InsertNodeCopy")==0)
		{
			IClientPasteNodeCopyResponse* icresp = dynamic_cast<IClientPasteNodeCopyResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onInsertNodeCopyComplete(icresp, response->queryState());
				else
					eventSink->onInsertNodeCopyError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "LockSession")==0)
		{
			IClientLockSessionResponse* icresp = dynamic_cast<IClientLockSessionResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onLockSessionComplete(icresp, response->queryState());
				else
					eventSink->onLockSessionError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "OpenEnvironmentFile")==0)
		{
			IClientOpenEnvironmentFileResponse* icresp = dynamic_cast<IClientOpenEnvironmentFileResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onOpenEnvironmentFileComplete(icresp, response->queryState());
				else
					eventSink->onOpenEnvironmentFileError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "OpenSession")==0)
		{
			IClientOpenSessionResponse* icresp = dynamic_cast<IClientOpenSessionResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onOpenSessionComplete(icresp, response->queryState());
				else
					eventSink->onOpenSessionError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "Ping")==0)
		{
			IClientws_configmgrPingResponse* icresp = dynamic_cast<IClientws_configmgrPingResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onPingComplete(icresp, response->queryState());
				else
					eventSink->onPingError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "RemoveNode")==0)
		{
			IClientStatusResponse* icresp = dynamic_cast<IClientStatusResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onRemoveNodeComplete(icresp, response->queryState());
				else
					eventSink->onRemoveNodeError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "SaveEnvironmentFile")==0)
		{
			IClientEmptyResponse* icresp = dynamic_cast<IClientEmptyResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onSaveEnvironmentFileComplete(icresp, response->queryState());
				else
					eventSink->onSaveEnvironmentFileError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "SetValues")==0)
		{
			IClientStatusResponse* icresp = dynamic_cast<IClientStatusResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onSetValuesComplete(icresp, response->queryState());
				else
					eventSink->onSetValuesError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "UnlockSession")==0)
		{
			IClientEmptyResponse* icresp = dynamic_cast<IClientEmptyResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onUnlockSessionComplete(icresp, response->queryState());
				else
					eventSink->onUnlockSessionError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "ValidateEnvironment")==0)
		{
			IClientStatusResponse* icresp = dynamic_cast<IClientStatusResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onValidateEnvironmentComplete(icresp, response->queryState());
				else
					eventSink->onValidateEnvironmentError(icresp,response->queryState());
			}
		}
		response->unlock();
	}
	return 0;
}

static IRpcResponseBinding* createws_configmgrResponseObject(IRpcRequestBinding *request)
{
	const char* method = request->getMethod();
	if (stricmp(method, "CloseEnvironmentFile")==0)
		return new CEmptyResponse("ws_configmgr", request);
	if (stricmp(method, "CloseSession")==0)
		return new CEmptyResponse("ws_configmgr", request);
	if (stricmp(method, "FetchNodes")==0)
		return new CFetchNodesResponse("ws_configmgr", request);
	if (stricmp(method, "GetCreateNodeInfo")==0)
		return new CGetCreateNodeInfoResponse("ws_configmgr", request);
	if (stricmp(method, "GetEnvironmentFileList")==0)
		return new CGetEnvironmentListResponse("ws_configmgr", request);
	if (stricmp(method, "GetNode")==0)
		return new CGetNodeResponse("ws_configmgr", request);
	if (stricmp(method, "GetNodeCopy")==0)
		return new CGetNodeCopyResponse("ws_configmgr", request);
	if (stricmp(method, "GetNodeTree")==0)
		return new CGetTreeResponse("ws_configmgr", request);
	if (stricmp(method, "GetOpenSessions")==0)
		return new CListOpenSessionsResponse("ws_configmgr", request);
	if (stricmp(method, "GetParents")==0)
		return new CGetParentsResponse("ws_configmgr", request);
	if (stricmp(method, "InsertNode")==0)
		return new CGetNodeResponse("ws_configmgr", request);
	if (stricmp(method, "InsertNodeCopy")==0)
		return new CPasteNodeCopyResponse("ws_configmgr", request);
	if (stricmp(method, "LockSession")==0)
		return new CLockSessionResponse("ws_configmgr", request);
	if (stricmp(method, "OpenEnvironmentFile")==0)
		return new COpenEnvironmentFileResponse("ws_configmgr", request);
	if (stricmp(method, "OpenSession")==0)
		return new COpenSessionResponse("ws_configmgr", request);
	if (stricmp(method, "Ping")==0)
		return new Cws_configmgrPingResponse("ws_configmgr", request);
	if (stricmp(method, "RemoveNode")==0)
		return new CStatusResponse("ws_configmgr", request);
	if (stricmp(method, "SaveEnvironmentFile")==0)
		return new CEmptyResponse("ws_configmgr", request);
	if (stricmp(method, "SetValues")==0)
		return new CStatusResponse("ws_configmgr", request);
	if (stricmp(method, "UnlockSession")==0)
		return new CEmptyResponse("ws_configmgr", request);
	if (stricmp(method, "ValidateEnvironment")==0)
		return new CStatusResponse("ws_configmgr", request);
	return NULL;
}

#ifdef _WIN32
void CClientws_configmgr::espWorkerThread(void* data)
#else
void *CClientws_configmgr::espWorkerThread(void *data)
#endif
{
	IRpcRequestBinding *request = (IRpcRequestBinding *) data;

	if (request != NULL)
	{
		request->lock();
		IRpcResponseBinding *response=createws_configmgrResponseObject(request);
		if (response!=NULL)
		{
			try{
				request->post(*response);
			}
			catch(IException* ex){
				StringBuffer errorStr;
				ex->errorMessage(errorStr);
				ERRLOG("CClientws_configmgr::espWorkerThread(%s)--Exception caught while posting async request: %s", request->getMethod(), errorStr.str());
				ex->Release();
			}
			catch(...){
				ERRLOG("Unknown exception caught while posting async request");
			}
		}
#ifdef USE_CLIENT_THREAD
		ThunkToClientThread(request->getThunkHandle(), transferThunkEvent, (void *)response);
#else
		transferThunkEvent((void *)response);
#endif
		request->unlock();
		if(request->queryState()!=NULL)
			request->queryState()->Release();

		if(response!=NULL)
			response->Release();

		request->Release();
	}
#if defined(_WIN32)
#else
	return (void *) 0 ;
#endif
}



extern "C" IClientws_configmgr * createws_configmgrClient() {  return new CClientws_configmgr(); }


#endif //ws_configmgr_ESPGEN_INCLUDED
