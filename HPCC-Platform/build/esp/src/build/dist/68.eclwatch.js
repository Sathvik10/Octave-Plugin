(function(){
(this||window)["webpackJsonp"].registerAbsMids({
	"dojo/i18n!dojox/form/nls/Uploader":"./node_modules/dojo-webpack-plugin/loaders/dojo/i18n/index.js!./node_modules/dojox/form/nls/Uploader.js",
	"dojox/form/nls/Uploader":"./node_modules/dojo-webpack-plugin/loaders/dojo/i18nRootModifier/index.js?bundledLocales=bs%7Ces%7Chr%7Chu%7Cpt%7Csr%7Czh%7Czh-tw!./node_modules/dojox/form/nls/Uploader.js",
	"dojo/text!dojox/form/resources/Uploader.html":"./node_modules/dojo-webpack-plugin/loaders/dojo/text/index.js!./node_modules/dojox/form/resources/Uploader.html",
	"dojo/text!dojox/form/resources/UploaderFileList.html":"./node_modules/dojo-webpack-plugin/loaders/dojo/text/index.js!./node_modules/dojox/form/resources/UploaderFileList.html",
	"dojo/_base/NodeList":"./node_modules/dojo/_base/NodeList.js",
	"dojo/_base/browser":"./node_modules/dojo/_base/browser.js",
	"dojo/_base/unload":"./node_modules/dojo/_base/unload.js",
	"dojo/_firebug/firebug":"./node_modules/dojo/_firebug/firebug.js",
	"dojo/main":"./node_modules/dojo/main.js",
	"dojox/embed/Flash":"./node_modules/dojox/embed/Flash.js",
	"dojox/form/Uploader":"./node_modules/dojox/form/Uploader.js",
	"dojox/form/nls/bs/Uploader":"./node_modules/dojox/form/nls/bs/Uploader.js",
	"dojox/form/nls/es/Uploader":"./node_modules/dojox/form/nls/es/Uploader.js",
	"dojox/form/nls/hr/Uploader":"./node_modules/dojox/form/nls/hr/Uploader.js",
	"dojox/form/nls/hu/Uploader":"./node_modules/dojox/form/nls/hu/Uploader.js",
	"dojox/form/nls/pt/Uploader":"./node_modules/dojox/form/nls/pt/Uploader.js",
	"dojox/form/nls/sr/Uploader":"./node_modules/dojox/form/nls/sr/Uploader.js",
	"dojox/form/nls/zh-tw/Uploader":"./node_modules/dojox/form/nls/zh-tw/Uploader.js",
	"dojox/form/nls/zh/Uploader":"./node_modules/dojox/form/nls/zh/Uploader.js",
	"dojox/form/uploader/FileList":"./node_modules/dojox/form/uploader/FileList.js",
	"dojox/form/uploader/_Base":"./node_modules/dojox/form/uploader/_Base.js",
	"dojox/form/uploader/_Flash":"./node_modules/dojox/form/uploader/_Flash.js",
	"dojox/form/uploader/_HTML5":"./node_modules/dojox/form/uploader/_HTML5.js",
	"dojox/form/uploader/_IFrame":"./node_modules/dojox/form/uploader/_IFrame.js"
})
})(),(window["webpackJsonp"] = window["webpackJsonp"] || []).push([[68],{

/***/ "./node_modules/dojo-webpack-plugin/loaders/dojo/i18n/index.js!./node_modules/dojox/form/nls/Uploader.js":
/*!******************************************************************************************************!*\
  !*** ./node_modules/dojo-webpack-plugin/loaders/dojo/i18n!./node_modules/dojox/form/nls/Uploader.js ***!
  \******************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ./node_modules/dojox/form/nls/bs/Uploader.js?absMid=dojox/form/nls/bs/Uploader */ "./node_modules/dojox/form/nls/bs/Uploader.js");
__webpack_require__(/*! ./node_modules/dojox/form/nls/es/Uploader.js?absMid=dojox/form/nls/es/Uploader */ "./node_modules/dojox/form/nls/es/Uploader.js");
__webpack_require__(/*! ./node_modules/dojox/form/nls/hr/Uploader.js?absMid=dojox/form/nls/hr/Uploader */ "./node_modules/dojox/form/nls/hr/Uploader.js");
__webpack_require__(/*! ./node_modules/dojox/form/nls/hu/Uploader.js?absMid=dojox/form/nls/hu/Uploader */ "./node_modules/dojox/form/nls/hu/Uploader.js");
__webpack_require__(/*! ./node_modules/dojox/form/nls/pt/Uploader.js?absMid=dojox/form/nls/pt/Uploader */ "./node_modules/dojox/form/nls/pt/Uploader.js");
__webpack_require__(/*! ./node_modules/dojox/form/nls/sr/Uploader.js?absMid=dojox/form/nls/sr/Uploader */ "./node_modules/dojox/form/nls/sr/Uploader.js");
__webpack_require__(/*! ./node_modules/dojox/form/nls/zh/Uploader.js?absMid=dojox/form/nls/zh/Uploader */ "./node_modules/dojox/form/nls/zh/Uploader.js");
__webpack_require__(/*! ./node_modules/dojox/form/nls/zh-tw/Uploader.js?absMid=dojox/form/nls/zh-tw/Uploader */ "./node_modules/dojox/form/nls/zh-tw/Uploader.js");
__webpack_require__(/*! dojo/i18nRootModifier?absMid=dojox/form/nls/Uploader&bundledLocales=bs|es|hr|hu|pt|sr|zh|zh-tw!dojox/form/nls/Uploader */ "./node_modules/dojo-webpack-plugin/loaders/dojo/i18nRootModifier/index.js?bundledLocales=bs%7Ces%7Chr%7Chu%7Cpt%7Csr%7Czh%7Czh-tw!./node_modules/dojox/form/nls/Uploader.js");
var req = __webpack_require__.dj.c();
module.exports = __webpack_require__(/*! ./node_modules/dojo-webpack-plugin/loaders/dojo/i18n/runner.js */ "./node_modules/dojo-webpack-plugin/loaders/dojo/i18n/runner.js")("dojox/form/nls/Uploader", req);

/***/ }),

/***/ "./node_modules/dojo-webpack-plugin/loaders/dojo/i18nRootModifier/index.js?bundledLocales=bs%7Ces%7Chr%7Chu%7Cpt%7Csr%7Czh%7Czh-tw!./node_modules/dojox/form/nls/Uploader.js":
/*!**************************************************************************************************************************************************************************!*\
  !*** ./node_modules/dojo-webpack-plugin/loaders/dojo/i18nRootModifier?bundledLocales=bs%7Ces%7Chr%7Chu%7Cpt%7Csr%7Czh%7Czh-tw!./node_modules/dojox/form/nls/Uploader.js ***!
  \**************************************************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

!(module.exports = {
 "root": {
  "label": "Select Files..."
 },
 "bs": true,
 "mk": false,
 "sr": true,
 "zh": true,
 "zh-tw": true,
 "uk": false,
 "tr": false,
 "th": false,
 "sv": false,
 "sl": false,
 "sk": false,
 "ru": false,
 "ro": false,
 "pt": true,
 "pl": false,
 "nl": false,
 "nb": false,
 "ko": false,
 "kk": false,
 "ja": false,
 "it": false,
 "id": false,
 "hu": true,
 "hr": true,
 "he": false,
 "fr": false,
 "fi": false,
 "es": true,
 "el": false,
 "eu": false,
 "de": false,
 "da": false,
 "cs": false,
 "ca": false,
 "bg": false
})

/***/ }),

/***/ "./node_modules/dojo-webpack-plugin/loaders/dojo/text/index.js!./node_modules/dojox/form/resources/Uploader.html":
/*!**************************************************************************************************************!*\
  !*** ./node_modules/dojo-webpack-plugin/loaders/dojo/text!./node_modules/dojox/form/resources/Uploader.html ***!
  \**************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "<span class=\"dijit dijitReset dijitInline\"\n\t><span class=\"dijitReset dijitInline dijitButtonNode\"\n\t\tdata-dojo-attach-event=\"ondijitclick:_onClick\"\n\t\t><span class=\"dijitReset dijitStretch dijitButtonContents\"\n\t\t\tdata-dojo-attach-point=\"titleNode,focusNode\"\n\t\t\trole=\"button\" aria-labelledby=\"${id}_label\"\n\t\t\t><span class=\"dijitReset dijitInline dijitIcon\" data-dojo-attach-point=\"iconNode\"></span\n\t\t\t><span class=\"dijitReset dijitToggleButtonIconChar\">&#x25CF;</span\n\t\t\t><span class=\"dijitReset dijitInline dijitButtonText\"\n\t\t\t\tid=\"${id}_label\"\n\t\t\t\tdata-dojo-attach-point=\"containerNode\"\n\t\t\t></span\n\t\t></span\n\t></span\n\t> \n\t<input ${!nameAttrSetting} type=\"${type}\" value=\"${value}\" class=\"dijitOffScreen\" tabIndex=\"-1\" data-dojo-attach-point=\"valueNode\" />\n</span>\n"

/***/ }),

/***/ "./node_modules/dojo-webpack-plugin/loaders/dojo/text/index.js!./node_modules/dojox/form/resources/UploaderFileList.html":
/*!**********************************************************************************************************************!*\
  !*** ./node_modules/dojo-webpack-plugin/loaders/dojo/text!./node_modules/dojox/form/resources/UploaderFileList.html ***!
  \**********************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "<div class=\"dojoxUploaderFileList\">\n\t<div data-dojo-attach-point=\"progressNode\" class=\"dojoxUploaderFileListProgress\">\n\t\t<div data-dojo-attach-point=\"percentBarNode\" class=\"dojoxUploaderFileListProgressBar\"></div>\n\t\t<div data-dojo-attach-point=\"percentTextNode\" class=\"dojoxUploaderFileListPercentText\">0%</div>\n\t</div>\n\t<table class=\"dojoxUploaderFileListTable\">\n\t\t<thead>\n\t\t\t<tr class=\"dojoxUploaderFileListHeader\">\n\t\t\t\t<th class=\"dojoxUploaderIndex\">${headerIndex}</th>\n\t\t\t\t<th class=\"dojoxUploaderIcon\">${headerType}</th>\n\t\t\t\t<th class=\"dojoxUploaderFileName\">${headerFilename}</th>\n\t\t\t\t<th class=\"dojoxUploaderFileSize\" data-dojo-attach-point=\"sizeHeader\">${headerFilesize}</th>\n\t\t\t</tr>\n\t\t</thead>\n\t\t<tbody class=\"dojoxUploaderFileListContent\" data-dojo-attach-point=\"listNode\"></tbody>\n\t</table>\n<div>"

/***/ }),

/***/ "./node_modules/dojo/_base/NodeList.js":
/*!*********************************************!*\
  !*** ./node_modules/dojo/_base/NodeList.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./kernel */ "./node_modules/dojo/_base/kernel.js"), __webpack_require__(/*! ../query */ "./node_modules/dojo/query.js"), __webpack_require__(/*! ./array */ "./node_modules/dojo/_base/array.js"), __webpack_require__(/*! ./html */ "./node_modules/dojo/_base/html.js"), __webpack_require__(/*! ../NodeList-dom */ "./node_modules/dojo/NodeList-dom.js")], __WEBPACK_AMD_DEFINE_RESULT__ = (function(dojo, query, array){
	// module:
	//		dojo/_base/NodeList

	/*=====
	return {
		// summary:
		//		This module extends dojo/NodeList with the legacy connect(), coords(),
		//		blur(), focus(), change(), click(), error(), keydown(), keypress(),
		//		keyup(), load(), mousedown(), mouseenter(), mouseleave(), mousemove(),
		//		mouseout(), mouseover(), mouseup(), and submit() methods.
	};
	=====*/
 
	var NodeList = query.NodeList,
		nlp = NodeList.prototype;

	nlp.connect = NodeList._adaptAsForEach(function(){
		// don't bind early to dojo.connect since we no longer explicitly depend on it
		return dojo.connect.apply(this, arguments);
	});
	/*=====
	nlp.connect = function(methodName, objOrFunc, funcName){
		// summary:
		//		Attach event handlers to every item of the NodeList. Uses dojo.connect()
		//		so event properties are normalized.
		//
		//		Application must manually require() "dojo/_base/connect" before using this method.
		// methodName: String
		//		the name of the method to attach to. For DOM events, this should be
		//		the lower-case name of the event
		// objOrFunc: Object|Function|String
		//		if 2 arguments are passed (methodName, objOrFunc), objOrFunc should
		//		reference a function or be the name of the function in the global
		//		namespace to attach. If 3 arguments are provided
		//		(methodName, objOrFunc, funcName), objOrFunc must be the scope to
		//		locate the bound function in
		// funcName: String?
		//		optional. A string naming the function in objOrFunc to bind to the
		//		event. May also be a function reference.
		// example:
		//		add an onclick handler to every button on the page
		//		|	query("div:nth-child(odd)").connect("onclick", function(e){
		//		|		console.log("clicked!");
		//		|	});
		// example:
		//		attach foo.bar() to every odd div's onmouseover
		//		|	query("div:nth-child(odd)").connect("onmouseover", foo, "bar");

		return null;	// NodeList
	};
	=====*/

	nlp.coords = NodeList._adaptAsMap(dojo.coords);
	/*=====
	nlp.coords = function(){
		// summary:
		//		Deprecated: Use position() for border-box x/y/w/h
		//		or marginBox() for margin-box w/h/l/t.
		//		Returns the box objects of all elements in a node list as
		//		an Array (*not* a NodeList). Acts like `domGeom.coords`, though assumes
		//		the node passed is each node in this list.

		return []; // Array
	};
	=====*/

	NodeList.events = [
		// summary:
		//		list of all DOM events used in NodeList
		"blur", "focus", "change", "click", "error", "keydown", "keypress",
		"keyup", "load", "mousedown", "mouseenter", "mouseleave", "mousemove",
		"mouseout", "mouseover", "mouseup", "submit"
	];

	// FIXME: pseudo-doc the above automatically generated on-event functions

	// syntactic sugar for DOM events
	array.forEach(NodeList.events, function(evt){
			var _oe = "on" + evt;
			nlp[_oe] = function(a, b){
				return this.connect(_oe, a, b);
			};
				// FIXME: should these events trigger publishes?
				/*
				return (a ? this.connect(_oe, a, b) :
							this.forEach(function(n){
								// FIXME:
								//		listeners get buried by
								//		addEventListener and can't be dug back
								//		out to be triggered externally.
								// see:
								//		http://developer.mozilla.org/en/docs/DOM:element

								console.log(n, evt, _oe);

								// FIXME: need synthetic event support!
								var _e = { target: n, faux: true, type: evt };
								// dojo._event_listener._synthesizeEvent({}, { target: n, faux: true, type: evt });
								try{ n[evt](_e); }catch(e){ console.log(e); }
								try{ n[_oe](_e); }catch(e){ console.log(e); }
							})
				);
				*/
		}
	);

	dojo.NodeList = NodeList;
	return NodeList;
}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ "./node_modules/dojo/_base/browser.js":
/*!********************************************!*\
  !*** ./node_modules/dojo/_base/browser.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;if(require.has){
	require.has.add("config-selectorEngine", "acme");
}
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	__webpack_require__(/*! ../ready */ "./node_modules/dojo/ready.js"),
	__webpack_require__(/*! ./kernel */ "./node_modules/dojo/_base/kernel.js"),
	__webpack_require__(/*! ./connect */ "./node_modules/dojo/_base/connect.js"), // until we decide if connect is going back into non-browser environments
	__webpack_require__(/*! ./unload */ "./node_modules/dojo/_base/unload.js"),
	__webpack_require__(/*! ./window */ "./node_modules/dojo/_base/window.js"),
	__webpack_require__(/*! ./event */ "./node_modules/dojo/_base/event.js"),
	__webpack_require__(/*! ./html */ "./node_modules/dojo/_base/html.js"),
	__webpack_require__(/*! ./NodeList */ "./node_modules/dojo/_base/NodeList.js"),
	__webpack_require__(/*! ../query */ "./node_modules/dojo/query.js"),
	__webpack_require__(/*! ./xhr */ "./node_modules/dojo/_base/xhr.js"),
	__webpack_require__(/*! ./fx */ "./node_modules/dojo/_base/fx.js")], __WEBPACK_AMD_DEFINE_RESULT__ = (function(dojo){

	// module:
	//		dojo/_base/browser

	/*=====
	return {
		// summary:
		//		This module causes the browser-only base modules to be loaded.
	};
	=====*/

	return dojo;
}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ "./node_modules/dojo/_base/unload.js":
/*!*******************************************!*\
  !*** ./node_modules/dojo/_base/unload.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./kernel */ "./node_modules/dojo/_base/kernel.js"), __webpack_require__(/*! ./lang */ "./node_modules/dojo/_base/lang.js"), __webpack_require__(/*! ../on */ "./node_modules/dojo/on.js")], __WEBPACK_AMD_DEFINE_RESULT__ = (function(dojo, lang, on){

// module:
//		dojo/unload

var win = window;

var unload = {
	// summary:
	//		This module contains the document and window unload detection API.
	//		This module is deprecated.  Use on(window, "unload", func)
	//		and on(window, "beforeunload", func) instead.

	addOnWindowUnload: function(/*Object|Function?*/ obj, /*String|Function?*/ functionName){
		// summary:
		//		Registers a function to be triggered when window.onunload fires.
		//		Deprecated, use on(window, "unload", lang.hitch(obj, functionName)) instead.
		// description:
		//		The first time that addOnWindowUnload is called Dojo
		//		will register a page listener to trigger your unload
		//		handler with. Note that registering these handlers may
		//		destroy "fastback" page caching in browsers that support
		//		it. Be careful trying to modify the DOM or access
		//		JavaScript properties during this phase of page unloading:
		//		they may not always be available. Consider
		//		addOnUnload() if you need to modify the DOM or do
		//		heavy JavaScript work since it fires at the equivalent of
		//		the page's "onbeforeunload" event.
		// example:
		//	|	var afunc = function() {console.log("global function");};
		//	|	require(["dojo/_base/unload"], function(unload) {
		//	|		var foo = {bar: function(){ console.log("bar unloading...");}, 
		//	|		           data: "mydata"};
		//	|		unload.addOnWindowUnload(afunc);
		//	|		unload.addOnWindowUnload(foo, "bar");
		//	|		unload.addOnWindowUnload(foo, function(){console.log("", this.data);});
		//	|	});

		if (!dojo.windowUnloaded){
			on(win, "unload", (dojo.windowUnloaded = function(){
				// summary:
				//		signal fired by impending window destruction. You may use
				//		dojo.addOnWindowUnload() to register a listener for this
				//		event. NOTE: if you wish to dojo.connect() to this method
				//		to perform page/application cleanup, be aware that this
				//		event WILL NOT fire if no handler has been registered with
				//		addOnWindowUnload(). This behavior started in Dojo 1.3.
				//		Previous versions always triggered windowUnloaded(). See
				//		addOnWindowUnload for more info.
			}));
		}
		on(win, "unload", lang.hitch(obj, functionName));
	},

	addOnUnload: function(/*Object?|Function?*/ obj, /*String|Function?*/ functionName){
		// summary:
		//		Registers a function to be triggered when the page unloads.
		//		Deprecated, use on(window, "beforeunload", lang.hitch(obj, functionName)) instead.
		// description:
		//		The first time that addOnUnload is called Dojo will
		//		register a page listener to trigger your unload handler
		//		with.
		//
		//		In a browser environment, the functions will be triggered
		//		during the window.onbeforeunload event. Be careful of doing
		//		too much work in an unload handler. onbeforeunload can be
		//		triggered if a link to download a file is clicked, or if
		//		the link is a javascript: link. In these cases, the
		//		onbeforeunload event fires, but the document is not
		//		actually destroyed. So be careful about doing destructive
		//		operations in a dojo.addOnUnload callback.
		//
		//		Further note that calling dojo.addOnUnload will prevent
		//		browsers from using a "fast back" cache to make page
		//		loading via back button instantaneous.
		// example:
		//	|	var afunc = function() {console.log("global function");};
		//	|	require(["dojo/_base/unload"], function(unload) {
		//	|		var foo = {bar: function(){ console.log("bar unloading...");}, 
		//	|		           data: "mydata"};
		//	|		unload.addOnUnload(afunc);
		//	|		unload.addOnUnload(foo, "bar");
		//	|		unload.addOnUnload(foo, function(){console.log("", this.data);});
		//	|	});

		on(win, "beforeunload", lang.hitch(obj, functionName));
	}
};

dojo.addOnWindowUnload = unload.addOnWindowUnload;
dojo.addOnUnload = unload.addOnUnload;

return unload;

}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ "./node_modules/dojo/_firebug/firebug.js":
/*!***********************************************!*\
  !*** ./node_modules/dojo/_firebug/firebug.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function(){

	// module:
	//		dojo/_firebug/firebug
	// summary:
	//		This file used to contain code for a "firebug lite" console.  Now it just fixes IE's console.log()
	//		command to insert spaces.


	var isNewIE = (/Trident/.test(window.navigator.userAgent));
	if(isNewIE){
		// Fixing IE's console
		// IE doesn't insert space between arguments. How annoying.
		var calls = ["log", "info", "debug", "warn", "error"];
		for(var i=0;i<calls.length;i++){
			var m = calls[i];
			if(!console[m] ||console[m]._fake){
				// IE9 doesn't have console.debug method, a fake one is added later
				continue;
			}
			var n = "_"+calls[i];
			console[n] = console[m];
			console[m] = (function(){
				var type = n;
				return function(){
					console[type](Array.prototype.join.call(arguments, " "));
				};
			})();
		}
		// clear the console on load. This is more than a convenience - too many logs crashes it.
		// If closed it throws an error
		try{ console.clear(); }catch(e){}
	}

	// There used to be code here for adding a "firebug lite" console, but it's no longer needed on any
	// of the browsers we support, because they all have built-in consoles.

}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ "./node_modules/dojo/main.js":
/*!***********************************!*\
  !*** ./node_modules/dojo/main.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	__webpack_require__(/*! ./_base/kernel */ "./node_modules/dojo/_base/kernel.js"),	// kernel.isAsync
	__webpack_require__(/*! ./has */ "./node_modules/dojo/has.js"),
	__webpack_require__.dj.c(module.i),
	__webpack_require__(/*! ./sniff */ "./node_modules/dojo/sniff.js"),
	__webpack_require__(/*! ./_base/lang */ "./node_modules/dojo/_base/lang.js"),
	__webpack_require__(/*! ./_base/array */ "./node_modules/dojo/_base/array.js"),
	__webpack_require__(/*! ./_base/config */ "./node_modules/dojo/_base/config.js"),
	__webpack_require__(/*! ./ready */ "./node_modules/dojo/ready.js"),
	__webpack_require__(/*! ./_base/declare */ "./node_modules/dojo/_base/declare.js"),
	__webpack_require__(/*! ./_base/connect */ "./node_modules/dojo/_base/connect.js"),
	__webpack_require__(/*! ./_base/Deferred */ "./node_modules/dojo/_base/Deferred.js"),
	__webpack_require__(/*! ./_base/json */ "./node_modules/dojo/_base/json.js"),
	__webpack_require__(/*! ./_base/Color */ "./node_modules/dojo/_base/Color.js"),
	__webpack_require__.dj.h("dojo-firebug?./node_modules/dojo/_firebug/firebug.js"),
	__webpack_require__(/*! ./_base/browser */ "./node_modules/dojo/_base/browser.js"),
	__webpack_require__(/*! ./node_modules/dojo-webpack-plugin/lib/NoModule.js */ "./node_modules/dojo-webpack-plugin/lib/NoModule.js")
], __WEBPACK_AMD_DEFINE_RESULT__ = (function(kernel, has, require, sniff, lang, array, config, ready){
	// module:
	//		dojo/main
	// summary:
	//		This is the package main module for the dojo package; it loads dojo base appropriate for the execution environment.

	// Load code to fix IE's console
	if(config.isDebug){
		Promise.resolve(/*! AMD require */).then(function() {[__webpack_require__(/*! ./_firebug/firebug */ "./node_modules/dojo/_firebug/firebug.js")];}).catch(__webpack_require__.oe);
	}

	// dojoConfig.require is deprecated; use the loader configuration property deps
	has.add("dojo-config-require", 1);
	if(has("dojo-config-require")){
		var deps= config.require;
		if(deps){
			// config.require may be dot notation
			deps= array.map(lang.isArray(deps) ? deps : [deps], function(item){ return item.replace(/\./g, "/"); });
			if(kernel.isAsync){
				require(deps);
			}else{
				// this is a bit janky; in 1.6- dojo is defined before these requires are applied; but in 1.7+
				// dojo isn't defined until returning from this module; this is only a problem in sync mode
				// since we're in sync mode, we know we've got our loader with its priority ready queue
				ready(1, function(){require(deps);});
			}
		}
	}

	return kernel;
}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ "./node_modules/dojox/embed/Flash.js":
/*!*******************************************!*\
  !*** ./node_modules/dojox/embed/Flash.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	__webpack_require__(/*! dojo/_base/lang */ "./node_modules/dojo/_base/lang.js"),
	__webpack_require__(/*! dojo/_base/unload */ "./node_modules/dojo/_base/unload.js"),
	__webpack_require__(/*! dojo/_base/array */ "./node_modules/dojo/_base/array.js"),
	__webpack_require__(/*! dojo/query */ "./node_modules/dojo/query.js"),
	__webpack_require__(/*! dojo/has */ "./node_modules/dojo/has.js"),
	__webpack_require__(/*! dojo/dom */ "./node_modules/dojo/dom.js"),
	__webpack_require__(/*! dojo/on */ "./node_modules/dojo/on.js"),
	__webpack_require__(/*! dojo/window */ "./node_modules/dojo/window.js"),
	__webpack_require__(/*! dojo/string */ "./node_modules/dojo/string.js")
], __WEBPACK_AMD_DEFINE_RESULT__ = (function(lang,unload,array,query,has,dom,on,win,stringUtil) {

	// module:
	//		dojox/embed/Flash
	// summary:
	//		Base functionality to insert a flash movie into
	//		a document on the fly.
	// example:
	//	|	var movie=new Flash({ args }, containerNode);


	var fMarkup, fVersion;
	var minimumVersion = 9; // anything below this will throw an error (may overwrite)
	var keyBase = "dojox-embed-flash-", keyCount=0;
	var _baseKwArgs = {
		expressInstall: false,
		width: 320,
		height: 240,
		swLiveConnect: "true",
		allowScriptAccess: "sameDomain",
		allowNetworking:"all",
		style: null,
		redirect: null
	};

	function prep(kwArgs){
		kwArgs = lang.delegate(_baseKwArgs, kwArgs);

		if(!("path" in kwArgs)){
			console.error("dojox.embed.Flash(ctor):: no path reference to a Flash movie was provided.");
			return null;
		}

		if(!("id" in kwArgs)){
			kwArgs.id = (keyBase + keyCount++);
		}
		return kwArgs;
	}

	if(has('ie')) {
		fMarkup = function(kwArgs){
			kwArgs = prep(kwArgs);
			if(!kwArgs){ return null; }

			var p;
			var path = kwArgs.path;
			if(kwArgs.vars){
				var a = [];
				for(p in kwArgs.vars){
					a.push(encodeURIComponent(p) + '=' + encodeURIComponent(kwArgs.vars[p]));
				}
				kwArgs.params.FlashVars = a.join("&");
				delete kwArgs.vars;
			}
			var s = '<object id="' + stringUtil.escape(String(kwArgs.id)) + '" '
				+ 'classid="clsid:D27CDB6E-AE6D-11cf-96B8-444553540000" '
				+ 'width="' + stringUtil.escape(String(kwArgs.width)) + '" '
				+ 'height="' + stringUtil.escape(String(kwArgs.height)) + '"'
				+ ((kwArgs.style)?' style="' + stringUtil.escape(String(kwArgs.style)) + '"':'')
				+ '>'
				+ '<param name="movie" value="' + stringUtil.escape(String(path)) + '" />';
			if(kwArgs.params){
				for(p in kwArgs.params){
					s += '<param name="' + stringUtil.escape(p) + '" value="' + stringUtil.escape(String(kwArgs.params[p])) + '" />';
				}
			}
			s += '</object>';
			return { id: kwArgs.id, markup: s };
		};

		fVersion = (function(){
			var testVersion = 10, testObj = null;
			while(!testObj && testVersion > 7){
				try {
					testObj = new ActiveXObject("ShockwaveFlash.ShockwaveFlash." + testVersion--);
				}catch(e){ }
			}
			if(testObj){
				var v = testObj.GetVariable("$version").split(" ")[1].split(",");
				return {
					major: (v[0]!=null) ? parseInt(v[0]) : 0,
					minor: (v[1]!=null) ? parseInt(v[1]) : 0,
					rev: (v[2]!=null) ? parseInt(v[2]) : 0
				};
			}
			return { major: 0, minor: 0, rev: 0 };
		})();

		//	attach some cleanup for IE, thanks to deconcept :)
		unload.addOnWindowUnload(function(){
			console.warn('***************UNLOAD');
			var dummy = function(){};
			var objs = query("object").
				reverse().
				style("display", "none").
				forEach(function(i){
					for(var p in i){
						if((p != "FlashVars") && typeof i[p] == "function"){
							try{
								i[p] = dummy;
							}catch(e){}
						}
					}
				});
		});

	} else {
		//	*** Sane browsers branch ******************************************************************
		fMarkup = function(kwArgs){
			kwArgs = prep(kwArgs);
			if(!kwArgs){ return null; }

			var p;
			var path = kwArgs.path;
			if(kwArgs.vars){
				var a = [];
				for(p in kwArgs.vars){
					a.push(encodeURIComponent(p) + '=' + encodeURIComponent(kwArgs.vars[p]));
				}
				kwArgs.params.flashVars = a.join("&");
				delete kwArgs.vars;
			}
			var s = '<embed type="application/x-shockwave-flash" '
				+ 'src="' + stringUtil.escape(String(path)) + '" '
				+ 'id="' + stringUtil.escape(String(kwArgs.id)) + '" '
				+ 'width="' + stringUtil.escape(String(kwArgs.width)) + '" '
				+ 'height="' + stringUtil.escape(String(kwArgs.height)) + '"'
				+ ((kwArgs.style)?' style="' + stringUtil.escape(String(kwArgs.style)) + '" ':'')

				+ 'pluginspage="' + window.location.protocol + '//www.adobe.com/go/getflashplayer" ';
			if(kwArgs.params){
				for(p in kwArgs.params){
					s += ' ' + stringUtil.escape(p) + '="' + stringUtil.escape(String(kwArgs.params[p])) + '"';
				}
			}
			s += ' />';
			return { id: kwArgs.id, markup: s };
		};

		fVersion=(function(){
			var plugin = navigator.plugins["Shockwave Flash"];
			if(plugin && plugin.description){
				var v = plugin.description.replace(/([a-zA-Z]|\s)+/, "").replace(/(\s+r|\s+b[0-9]+)/, ".").split(".");
				return {
					major: (v[0]!=null) ? parseInt(v[0]) : 0,
					minor: (v[1]!=null) ? parseInt(v[1]) : 0,
					rev: (v[2]!=null) ? parseInt(v[2]) : 0
				};
			}
			return { major: 0, minor: 0, rev: 0 };
		})();
	}


/*=====
var __flashArgs = {
	// path: String
	//		The URL of the movie to embed.
	// id: String?
	//		A unique key that will be used as the id of the created markup.  If you don't
	//		provide this, a unique key will be generated.
	// width: Number?
	//		The width of the embedded movie; the default value is 320px.
	// height: Number?
	//		The height of the embedded movie; the default value is 240px
	// minimumVersion: Number?
	//		The minimum targeted version of the Flash Player (defaults to 9)
	// style: String?
	//		Any CSS style information (i.e. style="background-color:transparent") you want
	//		to define on the markup.
	// params: Object?
	//		A set of key/value pairs that you want to define in the resultant markup.
	// vars: Object?
	//		A set of key/value pairs that the Flash movie will interpret as FlashVars.
	// expressInstall: Boolean?
	//		Whether or not to include any kind of expressInstall info. Default is false.
	// redirect: String?
	//		A url to redirect the browser to if the current Flash version is not supported.
};
=====*/

	//	the main entry point
	var Flash = function(/*__flashArgs*/ kwArgs, /*DOMNode*/ node){
		// summary:
		//		Create a wrapper object around a Flash movie; this is the DojoX equivilent
		//		to SWFObject.
		//
		// description:
		//		Creates a wrapper object around a Flash movie.  Wrapper object will
		//		insert the movie reference in node; when the browser first starts
		//		grabbing the movie, onReady will be fired; when the movie has finished
		//		loading, it will fire onLoad.
		//
		//		If your movie uses ExternalInterface, you should use the onLoad event
		//		to do any kind of proxy setup (see dojox.embed.Flash.proxy); this seems
		//		to be the only consistent time calling EI methods are stable (since the
		//		Flash movie will shoot several methods into the window object before
		//		EI callbacks can be used properly).
		//
		// kwArgs: __flashArgs
		//		The various arguments that will be used to help define the Flash movie.
		// node: DomNode
		//		The node where the embed object will be placed
		//
		// example:
		//		Embed a flash movie in a document using the new operator, and get a reference to it.
		//	|	var movie = new dojox.embed.Flash({
		//	|		path: "path/to/my/movie.swf",
		//	|		width: 400,
		//	|		height: 300
		//	|	}, myWrapperNode, "testLoaded");
		//
		// example:
		//		Embed a flash movie in a document without using the new operator.
		//	|	var movie = dojox.embed.Flash({
		//	|		path: "path/to/my/movie.swf",
		//	|		width: 400,
		//	|		height: 300,
		//	|		style: "position:absolute;top:0;left:0"
		//	|	}, myWrapperNode, "testLoaded");

		// File can only be run from a server, due to SWF dependency.
		if(location.href.toLowerCase().indexOf("file://")>-1){
			throw new Error("dojox.embed.Flash can't be run directly from a file. To instatiate the required SWF correctly it must be run from a server, like localHost.");
		}

		// available: Number
		//		If there is a flash player available, and if so what version.
		this.available = fVersion.major;

		// minimumVersion: Number
		//		The minimum version of Flash required to run this movie.
		this.minimumVersion = kwArgs.minimumVersion || minimumVersion;

		// id: String
		//		The id of the DOMNode to be used for this movie.  Can be used with dojo.byId to get a reference.
		this.id = null;

		// movie: FlashObject
		//		A reference to the movie itself.
		this.movie = null;

		// domNode: DOMNode
		//		A reference to the DOMNode that contains this movie.
		this.domNode = null;
		if(node){
			node = dom.byId(node);
		}
		// setTimeout Fixes #8743 - creating double SWFs
		// also allows time for code to attach to onError
		setTimeout(lang.hitch(this, function(){
			if(kwArgs.expressInstall || this.available && this.available >= this.minimumVersion){
				if(kwArgs && node){
					this.init(kwArgs, node);
				}else{
					this.onError("embed.Flash was not provided with the proper arguments.");
				}
			}else{
				if(!this.available){
					this.onError("Flash is not installed.");
				}else{
					this.onError("Flash version detected: "+this.available+" is out of date. Minimum required: "+this.minimumVersion);
				}
			}
		}), 100);
	};

	lang.extend(Flash, {
		onReady: function(/*HTMLObject*/ movie){
			// summary:
			//		Stub function for you to attach to when the movie reference is first
			//		pushed into the document.
		},
		onLoad: function(/*HTMLObject*/ movie){
			// summary:
			//		Stub function for you to attach to when the movie has finished downloading
			//		and is ready to be manipulated.
		},
		onError: function(msg){

		},
		_onload: function(){
			// summary:
			//	Internal. Cleans up before calling onLoad.
			clearInterval(this._poller);
			delete this._poller;
			delete this._pollCount;
			delete this._pollMax;
			this.onLoad(this.movie);
		},
		init: function(/*__flashArgs*/ kwArgs, /*DOMNode?*/ node){
			// summary:
			//		Initialize (i.e. place and load) the movie based on kwArgs.
			this.destroy();		//	ensure we are clean first.
			node = dom.byId(node || this.domNode);
			if(!node){ throw new Error("dojox.embed.Flash: no domNode reference has been passed."); }

			// vars to help determine load status
			var p = 0, testLoaded=false;
			this._poller = null; this._pollCount = 0; this._pollMax = 15; this.pollTime = 100;

			if(Flash.initialized){

				this.id = Flash.place(kwArgs, node);
				this.domNode = node;

				setTimeout(lang.hitch(this, function(){
					this.movie = this.byId(this.id, kwArgs.doc);
					this.onReady(this.movie);

					this._poller = setInterval(lang.hitch(this, function(){

						// catch errors if not quite ready.
						try{
							p = this.movie.PercentLoaded();
						}catch(e){
							console.warn("this.movie.PercentLoaded() failed", e, this.movie);
						}

						if(p == 100){
							// if percent = 100, movie is fully loaded and we're communicating
							this._onload();

						}else if(p==0 && this._pollCount++ > this._pollMax){
							// after several attempts, we're not past zero.
							clearInterval(this._poller);
							throw new Error("Building SWF failed.");
						}
					}), this.pollTime);
				}), 1);
			}
		},
		_destroy: function(){
			// summary:
			//		Kill the movie and reset all the properties of this object.
			try{
				this.domNode.removeChild(this.movie);
			}catch(e){}
			this.id = this.movie = this.domNode = null;
		},
		destroy: function(){
			// summary:
			//		Public interface for destroying all the properties in this object.
			//		Will also clean all proxied methods.
			if(!this.movie){ return; }

			//	remove any proxy functions
			var test = lang.delegate({
				id: true,
				movie: true,
				domNode: true,
				onReady: true,
				onLoad: true
			});
			for(var p in this){
				if(!test[p]){
					delete this[p];
				}
			}

			//	poll the movie
			if(this._poller){
				//	wait until onLoad to destroy
				on(this, "Load", this, "_destroy");
			} else {
				this._destroy();
			}
		},
		byId: function (movieName, doc){
			// summary:
			//		Gets Flash movie by id.
			// description:
			//		Probably includes methods for outdated
			//		browsers, but this should catch all cases.
			// movieName: String
			//		The name of the SWF
			// doc: Object
			//		The document, if not current window
			//		(not fully supported)
			// example:
			//	|	var movie = dojox.embed.Flash.byId("myId");

			doc = doc || document;
			if(doc.embeds[movieName]){
				return doc.embeds[movieName];
			}
			if(doc[movieName]){
				return doc[movieName];
			}
			if(window[movieName]){
				return window[movieName];
			}
			if(document[movieName]){
				return document[movieName];
			}
			return null;
		}
	});

	//	expose information through the constructor function itself.
	lang.mixin(Flash, {
		// summary:
		//		A singleton object used internally to get information
		//		about the Flash player available in a browser, and
		//		as the factory for generating and placing markup in a
		//		document.
		//
		// minSupported: Number
		//		The minimum supported version of the Flash Player, defaults to 8.
		// available: Number
		//		Used as both a detection (i.e. if(dojox.embed.Flash.available){ })
		//		and as a variable holding the major version of the player installed.
		// supported: Boolean
		//		Whether or not the Flash Player installed is supported by dojox.embed.
		// version: Object
		//		The version of the installed Flash Player; takes the form of
		//		{ major, minor, rev }.  To get the major version, you'd do this:
		//		var v=dojox.embed.Flash.version.major;
		// initialized: Boolean
		//		Whether or not the Flash engine is available for use.
		// onInitialize: Function
		//		A stub you can connect to if you are looking to fire code when the
		//		engine becomes available.  A note: DO NOT use this event to
		//		place a movie in a document; it will usually fire before DOMContentLoaded
		//		is fired, and you will get an error.  Use dojo.addOnLoad instead.
		minSupported : 8,
		available: fVersion.major,
		supported: (fVersion.major >= fVersion.required),
		minimumRequired: fVersion.required,
		version: fVersion,
		initialized: false,
		onInitialize: function(){
			Flash.initialized = true;
		},
		__ie_markup__: function(kwArgs){
			return fMarkup(kwArgs);
		},
		proxy: function(/*Flash*/ obj, /*Array|String*/ methods){
			// summary:
			//		Create the set of passed methods on the Flash object
			//		so that you can call that object directly, as opposed to having to
			//		delve into the internal movie to do this.  Intended to make working
			//		with Flash movies that use ExternalInterface much easier to use.
			//
			// example:
			//		Create "setMessage" and "getMessage" methods on foo.
			//	|	var foo = new Flash(args, someNode);
			//	|	dojo.connect(foo, "onLoad", lang.hitch(foo, function(){
			//	|		Flash.proxy(this, [ "setMessage", "getMessage" ]);
			//	|		this.setMessage("Flash.proxy is pretty cool...");
			//	|		console.log(this.getMessage());
			//	|	}));
			array.forEach((methods instanceof Array ? methods : [ methods ]), function(item){
				this[item] = lang.hitch(this, function(){
					return (function(){
						return eval(this.movie.CallFunction(
							'<invoke name="' + item + '" returntype="javascript">'
							+ '<arguments>'
							+ array.map(arguments, function(item){
								// FIXME:
								//		investigate if __flash__toXML will
								//		accept direct application via map()
								//		(e.g., does it ignore args past the
								//		first? or does it blow up?)
								return __flash__toXML(item);
							}).join("")
							+ '</arguments>'
							+ '</invoke>'
						));
					}).apply(this, arguments||[]);
				});
			}, obj);
		}
	});

	Flash.place = function(kwArgs, node){
		var o = fMarkup(kwArgs);
		node = dom.byId(node);
		if(!node){
			node = win.doc.createElement("div");
			node.id = o.id+"-container";
			win.body().appendChild(node);
		}
		if(o){
			node.innerHTML = o.markup;
			return o.id;
		}
		return null;
	}
	Flash.onInitialize();

	lang.setObject("dojox.embed.Flash", Flash);

	return Flash;
}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ "./node_modules/dojox/form/Uploader.js":
/*!*********************************************!*\
  !*** ./node_modules/dojox/form/Uploader.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	__webpack_require__(/*! dojo/_base/kernel */ "./node_modules/dojo/_base/kernel.js"),
	__webpack_require__(/*! dojo/_base/declare */ "./node_modules/dojo/_base/declare.js"),
	__webpack_require__(/*! dojo/_base/lang */ "./node_modules/dojo/_base/lang.js"),
	__webpack_require__(/*! dojo/_base/array */ "./node_modules/dojo/_base/array.js"),
	__webpack_require__(/*! dojo/_base/connect */ "./node_modules/dojo/_base/connect.js"),
	__webpack_require__(/*! dojo/_base/window */ "./node_modules/dojo/_base/window.js"),
	__webpack_require__(/*! dojo/dom-style */ "./node_modules/dojo/dom-style.js"),
	__webpack_require__(/*! dojo/dom-class */ "./node_modules/dojo/dom-class.js"),
	__webpack_require__(/*! dojo/dom-geometry */ "./node_modules/dojo/dom-geometry.js"),
	__webpack_require__(/*! dojo/dom-attr */ "./node_modules/dojo/dom-attr.js"),
	__webpack_require__(/*! dojo/dom-construct */ "./node_modules/dojo/dom-construct.js"),
	__webpack_require__(/*! dojo/dom-form */ "./node_modules/dojo/dom-form.js"),
	__webpack_require__(/*! dijit */ "./node_modules/dijit/main.js"),
	__webpack_require__(/*! dijit/form/Button */ "./node_modules/dijit/form/Button.js"),
	__webpack_require__(/*! ./uploader/_Base */ "./node_modules/dojox/form/uploader/_Base.js"),
	__webpack_require__(/*! ./uploader/_HTML5 */ "./node_modules/dojox/form/uploader/_HTML5.js"),
	__webpack_require__(/*! ./uploader/_IFrame */ "./node_modules/dojox/form/uploader/_IFrame.js"),
	__webpack_require__(/*! ./uploader/_Flash */ "./node_modules/dojox/form/uploader/_Flash.js"),
	__webpack_require__(/*! dojo/i18n!./nls/Uploader */ "./node_modules/dojo-webpack-plugin/loaders/dojo/i18n/index.js!./node_modules/dojox/form/nls/Uploader.js"),
	__webpack_require__(/*! dojo/text!./resources/Uploader.html */ "./node_modules/dojo-webpack-plugin/loaders/dojo/text/index.js!./node_modules/dojox/form/resources/Uploader.html")
], __WEBPACK_AMD_DEFINE_RESULT__ = (function(kernel, declare, lang, array, connect, win, domStyle, domClass, domGeometry, domAttr, domConstruct,
		   domForm, dijit, Button, Base, HTML5, IFrame, Flash, res, template){

	// TODO:
	//		i18n
	//		label via innerHTML
	//		Doc and or test what can be extended.
	//		Doc custom file events
	//		Use new FileReader() for thumbnails
	//		flashFieldName should default to Flash
	//		get('value'); and set warning
	//		Make it so URL can change (current set to Flash on build)
	//

	return declare("dojox.form.Uploader", [Base, Button, HTML5, IFrame, Flash], {
		// summary:
		//		A widget that creates a stylable file-input button, with optional multi-file selection,
		//		using only HTML elements. Non-HTML5 browsers have fallback options of Flash or an iframe.
		//
		// description:
		//		A bare-bones, stylable file-input button, with optional multi-file selection. The list
		//		of files is not displayed, that is for you to handle by connecting to the onChange
		//		event, or use the dojox.form.uploader.FileList.
		//
		//		Uploader without plugins does not have any ability to upload - it is for use in forms
		//		where you handle the upload either by a standard POST or with Ajax using an iFrame. This
		//		class is for convenience of multiple files only. No progress events are available.
		//
		//		If the browser supports a file-input with the "multiple" attribute, that will be used.
		//		If the browser does not support "multiple" (ergo, IE) multiple inputs are used,
		//		one for each selection.
		//
		//		Version: 1.6
	
	
		// uploadOnSelect: Boolean
		//		If true, uploads immediately after a file has been selected. If false,
		//		waits for upload() to be called.
		uploadOnSelect:false,
	
		// tabIndex: Number|String
		//		The tab order in the DOM.
		tabIndex:0,
	
		// multiple: Boolean
		//		If true and flash mode, multiple files may be selected from the dialog.
		multiple:false,
	
		// label: String
		//		The text used in the button that when clicked, opens a system Browse Dialog.
		label:res.label,
	
		// url: String
		//		The url targeted for upload. An absolute URL is preferred. Relative URLs are
		//		changed to absolute.
		url:"",
	
		// name: String
		//		The name attribute needs to end with square brackets: [] as this is the standard way
		//		of handling an attribute "array". This requires a slightly different technique on the
		//		server.
		name:"uploadedfile",
	
		// flashFieldName: String
		//		If set, this will be the name of the field of the flash uploaded files that the server
		//		is expecting. If not set, "Flash" is appended to the "name" property.
		flashFieldName:"",
		
		//	force: String
		//		options: form, html5, iframe, flash
		//		Empty string defaults to html5 if available, and iframe if not.
		// 		Use "flash" to always use Flash (and hopefully force the user to download the plugin
		//		if they don't have it).
		//		Use "iframe" to always use an iframe, and never flash nor html5. Sometimes preferred
		//		for consistent results.
		//		Use "form" to not use ajax and post to a page.
		force:"",
	
		// uploadType: String [readonly]
		//		The type of uploader being used. As an alternative to determining the upload type on the
		//		server based on the fieldName, this property could be sent to the server to help
		//		determine what type of parsing should be used.
		//		This is set based on the force property and what features are available in the browser.
		uploadType:"",
	
		// showInput: String [const]
		//		Position to show an input which shows selected filename(s). Possible
		//		values are "before", "after", which specifies where the input should
		//		be placed with reference to the containerNode which contains the
		//		label). By default, this is empty string (no such input will be
		//		shown). Specify showInput="before" to mimic the look&feel of a
		//		native file input element.
		showInput: "",
		
		//	focusedClass: String
		//		The class applied to the button when it is focused (via TAB key)
		focusedClass:"dijitButtonHover",
	
		_nameIndex:0,
	
		templateString: template,
	
		baseClass: 'dijitUploader '+Button.prototype.baseClass,
	
		postMixInProperties: function(){
			this._inputs = [];
			this._cons = [];
			this.force = this.force.toLowerCase();
			if(this.supports("multiple")){
				this.uploadType = this.force === 'form' ? 'form' : 'html5';
			}else{
				this.uploadType = this.force === 'flash' ? 'flash' : 'iframe';
			}
			
			this.inherited(arguments);
		},
		buildRendering: function(){
			this.inherited(arguments);
			domStyle.set(this.domNode, {
				overflow:"hidden",
				position:"relative"
			});
			this._buildDisplay();
			//change the button node not occupy tabIndex: the real file input
			//will have tabIndex set
			domAttr.set(this.titleNode, 'tabIndex', -1);
		},
		_buildDisplay: function(){
			if(this.showInput){
				this.displayInput = domConstruct.create('input', {
					  'class':'dijitUploadDisplayInput',
					  'tabIndex':-1, 'autocomplete':'off',
					  'role':'presentation'},
					this.containerNode, this.showInput);
				//schedule the attachpoint to be cleaned up on destroy
				this._attachPoints.push('displayInput');
				this.connect(this,'onChange', function(files){
					var i=0,l=files.length, f, r=[];
					while((f=files[i++])){
						if(f && f.name){
							r.push(f.name);
						}
					}
					this.displayInput.value = r.join(', ');
				});
				this.connect(this,'reset', function(){
					this.displayInput.value = '';
				});
			}
		},
	
		startup: function(){
			if(this._buildInitialized){
				return;
			}
			this._buildInitialized = true;
			this._getButtonStyle(this.domNode);
			this._setButtonStyle();
			this.inherited(arguments);
		},
	
		/*************************
		 *	   Public Events	 *
		 *************************/
	
		onChange: function(/*Array*/ fileArray){
			// summary:
			//		stub to connect
			//		Fires when files are selected
			//		Event is an array of last files selected
		},
	
		onBegin: function(/*Array*/ dataArray){
			// summary:
			//		Fires when upload begins
		},
	
		onProgress: function(/*Object*/ customEvent){
			// summary:
			//		Stub to connect
			//		Fires on upload progress. Event is a normalized object of common properties
			//		from HTML5 uploaders and the Flash uploader. Will not fire for IFrame.
			// customEvent:
			//		- bytesLoaded: Number:
			//			Amount of bytes uploaded so far of entire payload (all files)
			//		- bytesTotal: Number:
			//			Amount of bytes of entire payload (all files)
			//		- type: String:
			//			Type of event (progress or load)
			//		- timeStamp: Number:
			//			Timestamp of when event occurred
		},
	
		onComplete: function(/*Object*/ customEvent){
			// summary:
			//		stub to connect
			//		Fires when all files have uploaded
			//		Event is an array of all files
			this.reset();
		},
	
		onCancel: function(){
			// summary:
			//		Stub to connect
			//		Fires when dialog box has been closed
			//		without a file selection
		},
	
		onAbort: function(){
			// summary:
			//		Stub to connect
			//		Fires when upload in progress was canceled
		},
	
		onError: function(/*Object or String*/ evtObject){
			// summary:
			//		Fires on errors
	
			// FIXME: Unsure of a standard form of error events
		},
	
		/*************************
		 *	   Public Methods	 *
		 *************************/
	
		upload: function(/*Object?*/ formData){				
			// summary:
			//		When called, begins file upload. Only supported with plugins.
			formData = formData || {};
			formData.uploadType = this.uploadType;
			this.inherited(arguments);
		},
	
		submit: function(/*form Node?*/ form){
			// summary:
			//		If Uploader is in a form, and other data should be sent along with the files, use
			//		this instead of form submit.
			form = !!form ? form.tagName ? form : this.getForm() : this.getForm();
			var data = domForm.toObject(form);
			data.uploadType = this.uploadType;
			this.upload(data);
		},
	
		reset: function(){
			// summary:
			//		Resets entire input, clearing all files.
			//		NOTE:
			//		Removing individual files is not yet supported, because the HTML5 uploaders can't
			//		be edited.
			//		TODO:
			//		Add this ability by effectively, not uploading them
			//
			delete this._files;
			this._disconnectButton();
			array.forEach(this._inputs, domConstruct.destroy);
			this._inputs = [];
			this._nameIndex = 0;
			this._createInput();
		},
	
		getFileList: function(){
			// summary:
			//		Returns a list of selected files.
	
			var fileArray = [];
			if(this.supports("multiple")){
				array.forEach(this._files, function(f, i){
					fileArray.push({
						index:i,
						name:f.name,
						size:f.size,
						type:f.type
					});
				}, this);
			}else{
				array.forEach(this._inputs, function(n, i){
					if(n.value){
						fileArray.push({
							index:i,
							name:n.value.substring(n.value.lastIndexOf("\\")+1),
							size:0,
							type:n.value.substring(n.value.lastIndexOf(".")+1)
						});
					}
				}, this);
	
			}
			return fileArray; // Array
		},
	
		/*********************************************
		 *	   Private Property. Get off my lawn.	 *
		 *********************************************/
	
		_getValueAttr: function(){
			// summary:
			//		Internal. To get disabled use: uploader.get("disabled");
			return this.getFileList();
		},
	
		_setValueAttr: function(disabled){
			console.error("Uploader value is read only");
		},
	
		_setDisabledAttr: function(disabled){
			// summary:
			//		Internal. To set disabled use: uploader.set("disabled", true);
			if(this.disabled == disabled || !this.inputNode){ return; }
			this.inherited(arguments);
			domStyle.set(this.inputNode, "display", disabled ? "none" : "");
		},
	
		_getButtonStyle: function(node){
			this.btnSize = {w:domStyle.get(node,'width'), h:domStyle.get(node,'height')};
		},
	
		_setButtonStyle: function(){
			this.inputNodeFontSize = Math.max(2, Math.max(Math.ceil(this.btnSize.w / 60), Math.ceil(this.btnSize.h / 15)));
			this._createInput();
		},
	
		_getFileFieldName: function(){
			var name;
			if(this.supports("multiple") && this.multiple){
				name = this.name+"s[]";
			}else{
				// <=IE8
				name = this.name + (this.multiple ? this._nameIndex : "");
			}
			return name;
		},
	
		_createInput: function(){
			if(this._inputs.length){
				domStyle.set(this.inputNode, {
					top:"500px"
				});
				this._disconnectButton();
				this._nameIndex++;
			}
			var name = this._getFileFieldName();
			// reset focusNode to the inputNode, so when the button is clicked,
			// the focus is properly moved to the input element
			this.focusNode = this.inputNode = domConstruct.create("input", {type:"file", name:name, "aria-labelledby":this.id+"_label"}, this.domNode, "first");
			if(this.supports("multiple") && this.multiple){
				domAttr.set(this.inputNode, "multiple", true);
			}
			this._inputs.push(this.inputNode);
	
			domStyle.set(this.inputNode, {
				position:"absolute",
				fontSize:this.inputNodeFontSize+"em",
				top:"-3px",
				right:"-3px",
				opacity:0
			});
			this._connectButton();
		},
	
		_connectButton: function(){
			this._cons.push(connect.connect(this.inputNode, "change", this, function(evt){
				this._files = this.inputNode.files;
				this.onChange(this.getFileList(evt));
				if(!this.supports("multiple") && this.multiple) this._createInput();
			}));
	
			if(this.tabIndex > -1){
				this.inputNode.tabIndex = this.tabIndex;
	
				this._cons.push(connect.connect(this.inputNode, "focus", this, function(){
					domClass.add(this.domNode, this.focusedClass);
				}));
				this._cons.push(connect.connect(this.inputNode, "blur", this, function(){
					domClass.remove(this.domNode, this.focusedClass);
				}));
			}
		},
	
		_disconnectButton: function(){
			array.forEach(this._cons, connect.disconnect);
			this._cons.splice(0,this._cons.length);
		}
	});

}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ "./node_modules/dojox/form/nls/bs/Uploader.js":
/*!****************************************************!*\
  !*** ./node_modules/dojox/form/nls/bs/Uploader.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

!(module.exports = {      
//begin v1.x content
	label: "Izbor datoteka..."
//end v1.x content
});



/***/ }),

/***/ "./node_modules/dojox/form/nls/es/Uploader.js":
/*!****************************************************!*\
  !*** ./node_modules/dojox/form/nls/es/Uploader.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

!(module.exports = {
	label: "Seleccionar archivos..."
});


/***/ }),

/***/ "./node_modules/dojox/form/nls/hr/Uploader.js":
/*!****************************************************!*\
  !*** ./node_modules/dojox/form/nls/hr/Uploader.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

!(module.exports = {
	label: "Izaberite datoteke..."
});


/***/ }),

/***/ "./node_modules/dojox/form/nls/hu/Uploader.js":
/*!****************************************************!*\
  !*** ./node_modules/dojox/form/nls/hu/Uploader.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

!(module.exports = {
	label: "Fájlok kiválasztása..."
});


/***/ }),

/***/ "./node_modules/dojox/form/nls/pt/Uploader.js":
/*!****************************************************!*\
  !*** ./node_modules/dojox/form/nls/pt/Uploader.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

!(module.exports = {
	label: "Selecione Arquivos..."
});


/***/ }),

/***/ "./node_modules/dojox/form/nls/sr/Uploader.js":
/*!****************************************************!*\
  !*** ./node_modules/dojox/form/nls/sr/Uploader.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

!(module.exports = {      
//begin v1.x content
	label: "Izaberi datoteke..."
//end v1.x content
});



/***/ }),

/***/ "./node_modules/dojox/form/nls/zh-tw/Uploader.js":
/*!*******************************************************!*\
  !*** ./node_modules/dojox/form/nls/zh-tw/Uploader.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

!(module.exports = {
	label: "選取檔案..."
});


/***/ }),

/***/ "./node_modules/dojox/form/nls/zh/Uploader.js":
/*!****************************************************!*\
  !*** ./node_modules/dojox/form/nls/zh/Uploader.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

!(module.exports = {
	label: "选择文件..."
});


/***/ }),

/***/ "./node_modules/dojox/form/uploader/FileList.js":
/*!******************************************************!*\
  !*** ./node_modules/dojox/form/uploader/FileList.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	__webpack_require__(/*! dojo/_base/fx */ "./node_modules/dojo/_base/fx.js"),
	__webpack_require__(/*! dojo/dom-style */ "./node_modules/dojo/dom-style.js"),
	__webpack_require__(/*! dojo/dom-class */ "./node_modules/dojo/dom-class.js"),
	__webpack_require__(/*! dojo/_base/declare */ "./node_modules/dojo/_base/declare.js"),
	__webpack_require__(/*! dojo/_base/lang */ "./node_modules/dojo/_base/lang.js"),
	__webpack_require__(/*! dojo/_base/array */ "./node_modules/dojo/_base/array.js"),
	__webpack_require__(/*! dijit/_base/manager */ "./node_modules/dijit/_base/manager.js"),
	__webpack_require__(/*! dojox/form/uploader/_Base */ "./node_modules/dojox/form/uploader/_Base.js"),
	__webpack_require__(/*! dojo/text!../resources/UploaderFileList.html */ "./node_modules/dojo-webpack-plugin/loaders/dojo/text/index.js!./node_modules/dojox/form/resources/UploaderFileList.html")
], __WEBPACK_AMD_DEFINE_RESULT__ = (function(fx, domStyle, domClass, declare, lang, arrayUtil, manager, Base, template){

return declare("dojox.form.uploader.FileList", Base, {
	// summary:
	//		A simple widget that provides a list of the files currently selected by
	//		dojox/form/Uploader
	// description:
	//		There is a required CSS file: resources/UploaderFileList.css.
	//		This is a very simple widget, and not beautifully styled. It is here mainly for test
	//		cases, but could very easily be used, extended, modified, or copied.

	// uploaderId: String
	//		The id of the dojox.form.Uploader to connect to.
	uploaderId:"",

	// uploader: dojox.form.Uploader
	//		The dojox.form.Uploader to connect to. Use either this property of unploaderId. This
	//		property is populated if uploaderId is used.
	uploader:null,

	// headerIndex: String
	//		The label for the index column.
	headerIndex:"#",

	// headerType: String
	//		The label for the file type column.
	headerType:"Type",

	// headerFilename: String
	//		The label for the file name column.
	headerFilename:"File Name",

	// headerFilesize: String
	//		The label for the file size column.
	headerFilesize:"Size",

	_upCheckCnt:0,
	rowAmt:0,

	templateString:template,

	postCreate: function(){
		this.setUploader();
		this.hideProgress();
	},

	reset: function(){
		// summary:
		//		Clears all rows of items. Happens automatically if Uploader is reset, but you
		//		could call this directly.

		for(var i=0;i<this.rowAmt;i++){
			this.listNode.deleteRow(0);
		}
		this.rowAmt = 0;
	},

	setUploader: function(){
		// summary:
		//		Connects to the Uploader based on the uploader or the uploaderId properties.

		if(!this.uploaderId && !this.uploader){
			console.warn("uploaderId not passed to UploaderFileList");
		}else if(this.uploaderId && !this.uploader){
			this.uploader = manager.byId(this.uploaderId);
		}else if(this._upCheckCnt>4){
			console.warn("uploader not found for ID ", this.uploaderId);
			return;
		}
		if(this.uploader){
			this.connect(this.uploader, "onChange", "_onUploaderChange");
			this.connect(this.uploader, "reset", "reset");
			this.connect(this.uploader, "onBegin", function(){
				this.showProgress(true);
			});
			this.connect(this.uploader, "onProgress", "_progress");
			this.connect(this.uploader, "onComplete", function(){
				setTimeout(lang.hitch(this, function(){
					this.hideProgress(true);
				}), 1250);
			});
			if(!(this._fileSizeAvail = {'html5':1,'flash':1}[this.uploader.uploadType])){
				//if uploadType is neither html5 nor flash, file size is not available
				//hide the size header
				this.sizeHeader.style.display="none";
			}
		}else{
			this._upCheckCnt++;
			setTimeout(lang.hitch(this, "setUploader"), 250);
		}
	},

	hideProgress: function(/*Boolean*/ animate){
		var o = animate ? {
			ani:true,
			endDisp:"none",
			beg:15,
			end:0
		} : {
			endDisp:"none",
			ani:false
		};
		this._hideShowProgress(o);
	},

	showProgress: function(/*Boolean*/ animate){
		var o = animate ? {
			ani:true,
			endDisp:"block",
			beg:0,
			end:15
		} : {
			endDisp:"block",
			ani:false
		};
		this._hideShowProgress(o);
	},

	_progress: function(/*Object*/ customEvent){
		this.percentTextNode.innerHTML = customEvent.percent;
		domStyle.set(this.percentBarNode, "width", customEvent.percent);
	},

	_hideShowProgress: function(o){
		var node = this.progressNode;
		var onEnd = function(){
			domStyle.set(node, "display", o.endDisp);
		};
		if(o.ani){
			domStyle.set(node, "display", "block");
			fx.animateProperty({
				node: node,
				properties:{
					height:{
						start:o.beg,
						end:o.end,
						units:"px"
					}
				},
				onEnd:onEnd
			}).play();
		}else{
			onEnd();
		}
	},

	_onUploaderChange: function(fileArray){
		this.reset();
		arrayUtil.forEach(fileArray, function(f, i){
			this._addRow(i+1, this.getFileType(f.name), f.name, f.size);
		}, this)
	},

	_addRow: function(index, type, name, size){

		var c, r = this.listNode.insertRow(-1);
		c = r.insertCell(-1);
		domClass.add(c, "dojoxUploaderIndex");
		c.innerHTML = index;

		c = r.insertCell(-1);
		domClass.add(c, "dojoxUploaderIcon");
		c.innerHTML = type;

		c = r.insertCell(-1);
		domClass.add(c, "dojoxUploaderFileName");
		c.innerHTML = name;
		if(this._fileSizeAvail){
			c = r.insertCell(-1);
			domClass.add(c, "dojoxUploaderSize");
			c.innerHTML = this.convertBytes(size).value;
		}

		this.rowAmt++;
	}
});
}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ "./node_modules/dojox/form/uploader/_Base.js":
/*!***************************************************!*\
  !*** ./node_modules/dojox/form/uploader/_Base.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	__webpack_require__(/*! dojo/dom-form */ "./node_modules/dojo/dom-form.js"),
	__webpack_require__(/*! dojo/dom-style */ "./node_modules/dojo/dom-style.js"),
	__webpack_require__(/*! dojo/dom-construct */ "./node_modules/dojo/dom-construct.js"),
	__webpack_require__(/*! dojo/dom-attr */ "./node_modules/dojo/dom-attr.js"),
	__webpack_require__(/*! dojo/has */ "./node_modules/dojo/has.js"),
	__webpack_require__(/*! dojo/_base/declare */ "./node_modules/dojo/_base/declare.js"),
	__webpack_require__(/*! dojo/_base/event */ "./node_modules/dojo/_base/event.js"),
	__webpack_require__(/*! dijit/_Widget */ "./node_modules/dijit/_Widget.js"),
	__webpack_require__(/*! dijit/_TemplatedMixin */ "./node_modules/dijit/_TemplatedMixin.js"),
	__webpack_require__(/*! dijit/_WidgetsInTemplateMixin */ "./node_modules/dijit/_WidgetsInTemplateMixin.js")
], __WEBPACK_AMD_DEFINE_RESULT__ = (function(domForm, domStyle, domConstruct, domAttr, has, declare, event, Widget, TemplatedMixin, WidgetsInTemplateMixin){

has.add('FormData', function(){return !!window.FormData;});
has.add('xhr-sendAsBinary', function(){var xhr=window.XMLHttpRequest && new window.XMLHttpRequest(); return xhr && !!xhr.sendAsBinary;});
has.add('file-multiple', function(){return !!({'true':1,'false':1}[domAttr.get(document.createElement('input',{type:"file"}), 'multiple')]);});


return declare("dojox.form.uploader._Base", [Widget, TemplatedMixin, WidgetsInTemplateMixin], {
	// summary:
	//		The Base class used for dojox/form/Uploader and dojox/form/uploader/FileList.
	//
	//		Should not be used as a standalone. To be mixed in with other classes.
	//
	getForm: function(){
		// summary:
		//		Finds the parent form of the Uploader, if it exists.

		if(!this.form){
			var n = this.domNode;
			while(n && n.tagName && n !== document.body){
				if(n.tagName.toLowerCase() == "form"){
					this.form = n;
					break;
				}
				n = n.parentNode;
			}
		}
		return this.form // Node;
	},

	getUrl: function(){
		// summary:
		//		Finds the URL to upload to, whether it be the action in the parent form, this.url or
		//		this.uploadUrl

		if(this.uploadUrl) this.url = this.uploadUrl;
		if(this.url) return this.url;
		if(this.getForm()) this.url = this.form.action;
		return this.url; // String
	},


	connectForm: function(){
		// summary:
		//		Internal. Connects to form if there is one.

		this.url = this.getUrl();
		if(!this._fcon && !!this.getForm()){
			this._fcon = true;
			this.connect(this.form, "onsubmit", function(evt){
				console.log('SUBMIT')
				event.stop(evt);
				this.submit(this.form);
			});
		}
	},

	supports: function(what){
		// summary:
		//		Does feature testing for uploader capabilities. (No browser sniffing - yay)

		switch(what){
			case "multiple":
				if(this.force == "flash" || this.force == "iframe") return false;
				return has("file-multiple");
			case "FormData":
				return has(what);
			case "sendAsBinary":
				return has("xhr-sendAsBinary");
		}
		return false; // Boolean
	},
	getMimeType: function(){
		// summary:
		//		Returns the mime type that should be used in an HTML5 upload form. Return result
		//		may change as the current use is very generic.
		return "application/octet-stream"; //image/gif
	},
	getFileType: function(/*String*/ name){
		// summary:
		//		Gets the extension of a file
		return name.substring(name.lastIndexOf(".")+1).toUpperCase(); // String
	},
	convertBytes: function(bytes){
		// summary:
		//		Converts bytes. Returns an object with all conversions. The "value" property is
		//		considered the most likely desired result.

		var kb = Math.round(bytes/1024*100000)/100000;
		var mb = Math.round(bytes/1048576*100000)/100000;
		var gb = Math.round(bytes/1073741824*100000)/100000;
		var value = bytes;
		if(kb>1) value = kb.toFixed(1)+" kb";
		if(mb>1) value = mb.toFixed(1)+" mb";
		if(gb>1) value = gb.toFixed(1)+" gb";
		return {
			kb:kb,
			mb:mb,
			gb:gb,
			bytes:bytes,
			value: value
		}; // Object
	}
});
}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ "./node_modules/dojox/form/uploader/_Flash.js":
/*!****************************************************!*\
  !*** ./node_modules/dojox/form/uploader/_Flash.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	__webpack_require__(/*! dojo/dom-form */ "./node_modules/dojo/dom-form.js"),
	__webpack_require__(/*! dojo/dom-style */ "./node_modules/dojo/dom-style.js"),
	__webpack_require__(/*! dojo/dom-construct */ "./node_modules/dojo/dom-construct.js"),
	__webpack_require__(/*! dojo/dom-attr */ "./node_modules/dojo/dom-attr.js"),
	__webpack_require__(/*! dojo/_base/declare */ "./node_modules/dojo/_base/declare.js"),
	__webpack_require__(/*! dojo/_base/config */ "./node_modules/dojo/_base/config.js"),
	__webpack_require__(/*! dojo/_base/connect */ "./node_modules/dojo/_base/connect.js"),
	__webpack_require__(/*! dojo/_base/lang */ "./node_modules/dojo/_base/lang.js"),
	__webpack_require__(/*! dojo/_base/array */ "./node_modules/dojo/_base/array.js"),
	__webpack_require__(/*! dojox/embed/Flash */ "./node_modules/dojox/embed/Flash.js")
], __WEBPACK_AMD_DEFINE_RESULT__ = (function(domForm, domStyle, domConstruct, domAttr, declare, config, connect, lang, arrayUtil, embedFlash){


	return declare("dojox.form.uploader._Flash", [], {
		// summary:
		//		A mixin for dojox/form/Uploader that utilizes a Flash SWF for handling to upload in IE.
		//		All other browsers will use the HTML5 plugin, unless force="flash" is used, then Flash
		//		will be used in all browsers. force="flash"	is provided because Flash has some features
		//		that HTML5 does not yet have. But it is still not recommended because of the many problems
		//		that Firefox and Webkit have with the Flash plugin.
		//
		// description:
		//		All properties and methods listed here are specific to the Flash version only.
		//
		//
		// swfPath:String
		//		Path to SWF. Can be overwritten or provided in djConfig.
		swfPath:config.uploaderPath || require.toUrl("dojox/form/resources/uploader.swf"),

		// preventCache: Boolean
		//		If true, then flash request is sent with a value that changes with each request (timestamp)
		preventCache: true,
	
		// skipServerCheck: Boolean
		//		If true, will not verify that the server was sent the correct format.
		//		This can be safely set to true. The purpose of the server side check
		//		is mainly to show the dev if they've implemented the different returns
		//		correctly.
		skipServerCheck:true,
	
		// serverTimeout:Number (milliseconds)
		//		The amount of time given to the uploaded file
		//		to wait for a server response. After this amount
		//		of time, the onComplete is fired but with a 'server timeout'
		//		error in the returned item.
		serverTimeout: 2000,
	
		// isDebug: Boolean
		//		If true, outputs traces from the SWF to console. What exactly gets passed
		//		is very relative, and depends upon what traces have been left in the DEFT SWF.
		isDebug:false,
	
		// devMode: Boolean.
		//		Re-implemented. devMode increases the logging, adding style tracing from the SWF.
		devMode:false,
	
		// deferredUploading: Number (1 - X)
		//		(Flash only) throttles the upload to a certain amount of files at a time.
		//		By default, Flash uploads file one at a time to the server, but in parallel.
		//		Firefox will try to queue all files at once, leading to problems. Set this
		//		to the amount to upload in parallel at a time.
		//		Generally, 1 should work fine, but you can experiment with queuing more than
		//		one at a time.
		//		This is of course ignored if selectMultipleFiles equals false.
		deferredUploading:0,
	
		postMixInProperties: function(){
			if(this.uploadType === 'flash'){
				this._files = [];
				this._fileMap = {};
				this._createInput = this._createFlashUploader;
				this.getFileList = this.getFlashFileList;
				this.reset = this.flashReset;
				this.upload = this.uploadFlash;
				this.fieldname = "flashUploadFiles"; ///////////////////// this.name
			}
			this.inherited(arguments);
		},
	
		/*************************
		 *	   Public Events	 *
		 *************************/
	
		onReady: function(/*dojox/form/FileUploader*/ uploader){
			// summary:
			//		Stub - Fired when embedFlash has created the
			//		Flash object, but it has not necessarilly finished
			//		downloading, and is ready to be communicated with.
		},
	
		onLoad: function(/*dojox/form/FileUploader*/ uploader){
			// summary:
			//		Stub - SWF has been downloaded 100%.
		},
	
		onFileChange: function(fileArray){
			// summary:
			//		Stub - Flash-specific event. Fires on each selection of files
			//		and only provides the files selected on that event - not all files
			//		selected, as with HTML5
		},
	
		onFileProgress: function(fileArray){
			// summary:
			//		Stub - Flash-specific event. Fires on progress of upload
			//		and only provides a file-specific event
		},
	
	
		/*************************
		 *	   Public Methods	 *
		 *************************/
	
		getFlashFileList: function(){
			// summary:
			//		Returns list of currently selected files
			return this._files; // Array
		},
	
		flashReset: function(){
			this.flashMovie.reset();
			this._files = [];
			this._fileMap = {};
		},
	
		/*************************
		 *	   Private Methods	 *
		 *************************/
	
		uploadFlash: function(/*Object ? */ formData){
			// summary:
			//		Uploads selected files. Alias "upload()" should be used instead.
			// tags:
			//		private
			this.onBegin(this.getFileList());
			formData = formData || {};
			formData.returnType = "F";
			formData.uploadType = this.uploadType;
			console.log('flas upload', formData);
			this.flashMovie.doUpload(formData);
		},
	
		_change: function(fileArray){
			this._files = this._files.concat(fileArray);
			arrayUtil.forEach(fileArray, function(f){
				f.bytesLoaded = 0;
				f.bytesTotal = f.size;
				this._fileMap[f.name+"_"+f.size] = f;
			}, this);
			this.onChange(this._files);
			this.onFileChange(fileArray);
		},
		_complete: function(fileArray){
			var o = this._getCustomEvent();
			o.type = "load";
			this.onComplete(fileArray);
		},
		_progress: function(f){
			this._fileMap[f.name+"_"+f.bytesTotal].bytesLoaded = f.bytesLoaded;
			var o = this._getCustomEvent();
			this.onFileProgress(f);
			this.onProgress(o);
		},
		_error: function(err){
			this.onError(err);
		},
		_onFlashBlur: function(fileArray){
			//console.log("UploaderFlash._onFlashBlur");
		},
	
		_getCustomEvent: function(){
			var o = {
				bytesLoaded:0,
				bytesTotal:0,
				type:"progress",
				timeStamp:new Date().getTime()
			};
	
	
			for(var nm in this._fileMap){
				o.bytesTotal += this._fileMap[nm].bytesTotal;
				o.bytesLoaded += this._fileMap[nm].bytesLoaded;
			}
			o.decimal = o.bytesLoaded / o.bytesTotal;
			o.percent = Math.ceil((o.bytesLoaded / o.bytesTotal)*100)+"%";
			return o; // Object
		},
	
		_connectFlash: function(){
			// summary:
			//		Subscribing to published topics coming from the
			//		Flash uploader.
	
			// Sacrificing some readability for compactness. this.id
			// will be on the beginning of the topic, so more than
			// one uploader can be on a page and can have unique calls.
	
			this._subs = [];
			this._cons = [];
	
			var doSub = lang.hitch(this, function(s, funcStr){
				this._subs.push(connect.subscribe(this.id + s, this, funcStr));
			});
	
			doSub("/filesSelected", "_change");
			doSub("/filesUploaded", "_complete");
			doSub("/filesProgress", "_progress");
			doSub("/filesError", "_error");
			doSub("/filesCanceled", "onCancel");
			doSub("/stageBlur", "_onFlashBlur");
	
			this.connect(this.domNode, "focus", function(){
				// TODO: some kind of indicator that the Flash button is in focus
				this.flashMovie.focus();
				this.flashMovie.doFocus();
			});
			if(this.tabIndex>=0){
				domAttr.set(this.domNode, "tabIndex", this.tabIndex);
			}
		},
		_createFlashUploader: function(){
			// summary:
			//		Internal. Creates Flash Uploader
	
			var w = this.btnSize.w;
			var h = this.btnSize.h;
			if(!w){
				// FIXME: Commit this
				setTimeout(dojo.hitch(this, function(){
					this._getButtonStyle(this.domNode);
					this._createFlashUploader();
				}), 200);
				return;
			}
			var url = this.getUrl();
			if(url){
				if(url.toLowerCase().indexOf("http")<0 && url.indexOf("/")!=0){
					// Appears to be a relative path. Attempt to
					// convert it to absolute, so it will better
					// target the SWF.
					var loc = window.location.href.split("/");
					loc.pop();
					loc = loc.join("/")+"/";
					url = loc+url;
				}
			}else{
				console.warn("Warning: no uploadUrl provided.");
			}
	
			this.inputNode = domConstruct.create("div", {className:"dojoxFlashNode"}, this.domNode, "first");
			domStyle.set(this.inputNode, {
				position:"absolute",
				top:"-2px",
				width:w+"px",
				height:h+"px",
				opacity:0
			});
	
	
	
			var args = {
				expressInstall:true,
				path: (this.swfPath.uri || this.swfPath) + ((this.preventCache)?("?cb_" + (new Date().getTime())):""),
				width: w,
				height: h,
				allowScriptAccess:"always",
				allowNetworking:"all",
				vars: {
					uploadDataFieldName: this.flashFieldName || this.name+"Flash",
					uploadUrl: url,
					uploadOnSelect: this.uploadOnSelect,
					deferredUploading:this.deferredUploading || 0,
					selectMultipleFiles: this.multiple,
					id: this.id,
					isDebug: this.isDebug,
					noReturnCheck: this.skipServerCheck,
					serverTimeout:this.serverTimeout
				},
				params: {
					scale:"noscale",
					//wmode:"transparent",
					wmode:"opaque",
					allowScriptAccess:"always",
					allowNetworking:"all"
				}
	
			};
	
			this.flashObject = new embedFlash(args, this.inputNode);
			this.flashObject.onError = lang.hitch(function(msg){
				console.error("Flash Error: " + msg);
			});
			this.flashObject.onReady = lang.hitch(this, function(){
				this.onReady(this);
			});
			this.flashObject.onLoad = lang.hitch(this, function(mov){
				this.flashMovie = mov;
				this.flashReady = true;
	
				this.onLoad(this);
			});
			this._connectFlash();
		}
	});
}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ "./node_modules/dojox/form/uploader/_HTML5.js":
/*!****************************************************!*\
  !*** ./node_modules/dojox/form/uploader/_HTML5.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	__webpack_require__(/*! dojo/_base/declare */ "./node_modules/dojo/_base/declare.js"),
	__webpack_require__(/*! dojo/_base/lang */ "./node_modules/dojo/_base/lang.js"),
	__webpack_require__(/*! dojo/_base/array */ "./node_modules/dojo/_base/array.js"),
	__webpack_require__(/*! dojo */ "./node_modules/dojo/main.js"),
	__webpack_require__(/*! dojo/request */ "./node_modules/dojo/request.js"),
	__webpack_require__(/*! dojo/has */ "./node_modules/dojo/has.js")
], __WEBPACK_AMD_DEFINE_RESULT__ = (function(declare, lang, arrayUtil, dojo, request, has){
	return declare("dojox.form.uploader._HTML5", [], {
		// summary:
		//		A mixin for dojox/form/Uploader that adds HTML5 multiple-file upload capabilities and
		//		progress events.
		//
		// description:
		//		Note that this does not add these capabilities to browsers that don't support them.
		//		For IE8 or older browsers, _IFrame or _Flash mixins will be used.
		//
		
		// debug message:
		errMsg:"Error uploading files. Try checking permissions",
	
		// Overwrites "form" and could possibly be overwritten again by iframe or flash plugin.
		uploadType:"html5",
		
		postMixInProperties: function(){
			this.inherited(arguments);
			if(this.uploadType === "html5"){ }
		},
	
		postCreate: function(){
			this.connectForm();
			this.inherited(arguments);
			if(this.uploadOnSelect){
				this.connect(this, "onChange", function(data){
					this.upload(data[0]);
				});
			}
		},
	
		_drop: function(e){
			dojo.stopEvent(e);
			var dt = e.dataTransfer;
			this._files = dt.files;
			this.onChange(this.getFileList());
		},
		/*************************
		 *	   Public Methods	 *
		 *************************/
	
		upload: function(/*Object ? */ formData){
			// summary:
			//		See: dojox.form.Uploader.upload
				
			this.onBegin(this.getFileList());
			this.uploadWithFormData(formData);
		},
	
		addDropTarget: function(node, /*Boolean?*/ onlyConnectDrop){
			// summary:
			//		Add a dom node which will act as the drop target area so user
			//		can drop files to this node.
			// description:
			//		If onlyConnectDrop is true, dragenter/dragover/dragleave events
			//		won't be connected to dojo.stopEvent, and they need to be
			//		canceled by user code to allow DnD files to happen.
			//		This API is only available in HTML5 plugin (only HTML5 allows
			//		DnD files).
			if(!onlyConnectDrop){
				this.connect(node, 'dragenter', dojo.stopEvent);
				this.connect(node, 'dragover', dojo.stopEvent);
				this.connect(node, 'dragleave', dojo.stopEvent);
			}
			this.connect(node, 'drop', '_drop');
		},
		
		uploadWithFormData: function(/*Object*/ data){
			// summary:
			//		Used with WebKit and Firefox 4+
			//		Upload files using the much friendlier FormData browser object.
			// tags:
			//		private
	
			if(!this.getUrl()){
				console.error("No upload url found.", this); return;
			}
			var fd = new FormData(), fieldName=this._getFileFieldName();
			arrayUtil.forEach(this._files, function(f, i){
				fd.append(fieldName, f);
			}, this);
	
			if(data){
				data.uploadType = this.uploadType;
				for(var nm in data){
					fd.append(nm, data[nm]);
				}
			}

			var self = this;
			var deferred = request(
				this.getUrl(),
				{
					method: "POST",
					data: fd,
					handleAs: "json",
					uploadProgress: true,
					headers: {
						Accept: "application/json"
					}
				},
				true
			);

			deferred.promise.response
				.otherwise(function (error){
					console.error(error);
					console.error(error.response.text);
					self.onError(error);
				})
			;
	
			function onProgressHandler(event){
				self._xhrProgress(event);

				if(event.type !== "load"){
					return;
				}

				self.onComplete(deferred.response.data);

				// Disconnect event handlers when done
				deferred.response.xhr.removeEventListener("load", onProgressHandler, false);
				deferred.response.xhr.upload.removeEventListener("progress", onProgressHandler, false);

				deferred = null;
			}

			if(has("native-xhr2")){
				// Use addEventListener directly to pass the raw events to Uploader#_xhrProgress
				deferred.response.xhr.addEventListener("load", onProgressHandler, false);
				deferred.response.xhr.upload.addEventListener("progress", onProgressHandler, false);
			}else{
				// If the browser doesn't have upload events, notify when the upload is complete
				deferred.promise.then(function(data){
					self.onComplete(data);
				});
			}
		},
	
		_xhrProgress: function(evt){
			if(evt.lengthComputable){
				var o = {
					bytesLoaded:evt.loaded,
					bytesTotal:evt.total,
					type:evt.type,
					timeStamp:evt.timeStamp
				};
				if(evt.type == "load"){
					// 100%
					o.percent = "100%";
					o.decimal = 1;
				}else{
					o.decimal = evt.loaded / evt.total;
					o.percent = Math.ceil((evt.loaded / evt.total)*100)+"%";
				}
				this.onProgress(o);
			}
		}
	});

}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ "./node_modules/dojox/form/uploader/_IFrame.js":
/*!*****************************************************!*\
  !*** ./node_modules/dojox/form/uploader/_IFrame.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	__webpack_require__(/*! dojo/query */ "./node_modules/dojo/query.js"),
	__webpack_require__(/*! dojo/dom-construct */ "./node_modules/dojo/dom-construct.js"),
	__webpack_require__(/*! dojo/_base/declare */ "./node_modules/dojo/_base/declare.js"),
	__webpack_require__(/*! dojo/_base/lang */ "./node_modules/dojo/_base/lang.js"),
	__webpack_require__(/*! dojo/_base/array */ "./node_modules/dojo/_base/array.js"),
	__webpack_require__(/*! dojo/dom-form */ "./node_modules/dojo/dom-form.js"),
	__webpack_require__(/*! dojo/request/iframe */ "./node_modules/dojo/request/iframe.js")
], __WEBPACK_AMD_DEFINE_RESULT__ = (function(query, domConstruct, declare, lang, arrayUtil, domForm, request){
	

	return declare("dojox.form.uploader._IFrame", [], {
		// summary:
		//		A mixin for dojox/form/Uploader that adds Ajax upload capabilities via an iframe.
		//
		// description:
		//		Only supported by IE, due to the specific iFrame hack used.  Progress events are not
		//		supported.
		//		
		//
	
		postMixInProperties: function(){
			this.inherited(arguments);
			if(this.uploadType === "iframe"){
				this.uploadType = "iframe";
				this.upload = this.uploadIFrame;
			}
		},
	
		uploadIFrame: function(data){
			// summary:
			//		Internal. You could use this, but you should use upload() or submit();
			//		which can also handle the post data.
	
			var
				formObject = {},
				sendForm,
				form = this.getForm(),
				url = this.getUrl(),
				self = this;
			data = data || {};
			data.uploadType = this.uploadType;
			
			// create a temp form for which to send data
			//enctype can't be changed once a form element is created
			sendForm = domConstruct.place('<form enctype="multipart/form-data" method="post"></form>', this.domNode);
			arrayUtil.forEach(this._inputs, function(n, i){
				// don't send blank inputs
				if(n.value !== ''){
					sendForm.appendChild(n);
					formObject[n.name] = n.value;
				}
			}, this);
			
			
			// add any extra data as form inputs		
			if(data){
				//formObject = domForm.toObject(form);
				for(nm in data){
					if(formObject[nm] === undefined){
						domConstruct.create('input', {name:nm, value:data[nm], type:'hidden'}, sendForm);
					}
				}
			}
	
			
			request.post(url, {
				form: sendForm,
				handleAs: "json",
				content: data
			}).then(function(result){
				domConstruct.destroy(sendForm);
				if(result["ERROR"] || result["error"]){
					self.onError(result);
				}else{
					self.onComplete(result);
				}
			}, function(err){
				console.error('error parsing server result', err);
				domConstruct.destroy(sendForm); 
				self.onError(err);
			});
		}
	});
}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ })

}]);