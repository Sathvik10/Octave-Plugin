// *** Source file generated by HIDL Version 1.3 from ws_smc.ecm ***
// *** Not to be hand edited (changes will be lost on re-generation) ***

#ifndef ws_smc_ESPGEN_INCLUDED
#define ws_smc_ESPGEN_INCLUDED

#include "ws_smc_esp.ipp"

#ifdef _WIN32
#include "edwin.h"
#include <process.h>
#endif



//=======================================================
// class CActiveWorkunit Implementation
//=======================================================

CActiveWorkunit::CActiveWorkunit(const char *serviceName, IRpcMessageBinding *init)
	: m_Wuid(nilIgnore),m_State(nilIgnore),m_StateID(nilIgnore),m_Owner(nilIgnore),m_Jobname(nilIgnore),m_Server(nilIgnore),m_Instance(nilIgnore),m_Priority(nilIgnore),m_Extra(nilIgnore),m_GraphName(nilIgnore),m_Duration(nilIgnore),m_GID(nilIgnore),m_QueueName(nilIgnore),m_MemoryBlocked(nilIgnore),m_IsPausing(0, nilIgnore,false),m_Warning(nilIgnore),m_ClusterName(nilIgnore),m_ClusterType(nilIgnore),m_ClusterQueueName(nilIgnore),m_TargetClusterName(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ActiveWorkunit");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CActiveWorkunit::CActiveWorkunit(const char *serviceName, const char *bc)
	: m_Wuid(nilIgnore),m_State(nilIgnore),m_StateID(nilIgnore),m_Owner(nilIgnore),m_Jobname(nilIgnore),m_Server(nilIgnore),m_Instance(nilIgnore),m_Priority(nilIgnore),m_Extra(nilIgnore),m_GraphName(nilIgnore),m_Duration(nilIgnore),m_GID(nilIgnore),m_QueueName(nilIgnore),m_MemoryBlocked(nilIgnore),m_IsPausing(0, nilIgnore,false),m_Warning(nilIgnore),m_ClusterName(nilIgnore),m_ClusterType(nilIgnore),m_ClusterQueueName(nilIgnore),m_TargetClusterName(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ActiveWorkunit");
}

StringBuffer &CActiveWorkunit::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:complexType name=\"%s\">\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Wuid\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"State\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"StateID\" type=\"xsd:int\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Owner\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Jobname\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Server\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Instance\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Priority\" type=\"xsd:string\"/>\n");
		if (!context.suppressed("ActiveWorkunit","Extra")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"Extra\" type=\"xsd:string\"/>\n");
		}
		if (!context.suppressed("ActiveWorkunit","GraphName")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"GraphName\" type=\"xsd:string\"/>\n");
		}
		if (!context.suppressed("ActiveWorkunit","Duration")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"Duration\" type=\"xsd:string\"/>\n");
		}
		if (!context.suppressed("ActiveWorkunit","GID")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"GID\" type=\"xsd:string\"/>\n");
		}
		if (!context.suppressed("ActiveWorkunit","QueueName")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"QueueName\" type=\"xsd:string\"/>\n");
		}
		if (!context.suppressed("ActiveWorkunit","MemoryBlocked")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"MemoryBlocked\" type=\"xsd:int\"/>\n");
		}
		if (!context.suppressed("ActiveWorkunit","IsPausing")) {
			schema.append("<xsd:element minOccurs=\"0\" default=\"false\" name=\"IsPausing\" type=\"xsd:boolean\"/>\n");
		}
		if (!context.suppressed("ActiveWorkunit","Warning")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"Warning\" type=\"xsd:string\"/>\n");
		}
		if (!context.suppressed("ActiveWorkunit","ClusterName")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"ClusterName\" type=\"xsd:string\"/>\n");
		}
		if (!context.suppressed("ActiveWorkunit","ClusterType")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"ClusterType\" type=\"xsd:string\"/>\n");
		}
		if (!context.suppressed("ActiveWorkunit","ClusterQueueName")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"ClusterQueueName\" type=\"xsd:string\"/>\n");
		}
		if (!context.suppressed("ActiveWorkunit","TargetClusterName")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"TargetClusterName\" type=\"xsd:string\"/>\n");
		}
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType>\n");
		}
	}
	return schema;
}

void CActiveWorkunit::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CActiveWorkunit::getMapInfo(IMapInfo& info, BoolHash& added)
{
	info.addMinVersion("ActiveWorkunit","Extra",1.01);
	info.addMinVersion("ActiveWorkunit","GraphName",1.02);
	info.addMinVersion("ActiveWorkunit","Duration",1.02);
	info.addMinVersion("ActiveWorkunit","GID",1.02);
	info.addMinVersion("ActiveWorkunit","QueueName",1.03);
	info.addMinVersion("ActiveWorkunit","MemoryBlocked",1.04);
	info.addMinVersion("ActiveWorkunit","IsPausing",1.09);
	info.addMinVersion("ActiveWorkunit","Warning",1.1);
	info.addMinVersion("ActiveWorkunit","ClusterName",1.15);
	info.addMinVersion("ActiveWorkunit","ClusterType",1.15);
	info.addMinVersion("ActiveWorkunit","ClusterQueueName",1.15);
	info.addMinVersion("ActiveWorkunit","TargetClusterName",1.16);
}

StringBuffer &CActiveWorkunit::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Wuid");
	form.appendf("  <tr><td><b>Wuid: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("State");
	form.appendf("  <tr><td><b>State: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix) extfix.append(prefix).append(".");
		extfix.append("StateID");
	form.appendf("  <tr><td><b>StateID: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Owner");
	form.appendf("  <tr><td><b>Owner: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Jobname");
	form.appendf("  <tr><td><b>Jobname: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Server");
	form.appendf("  <tr><td><b>Server: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Instance");
	form.appendf("  <tr><td><b>Instance: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Priority");
	form.appendf("  <tr><td><b>Priority: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (!context.suppressed("ActiveWorkunit","Extra")) {
		extfix.clear();
		if (prefix && *prefix)
			extfix.append(prefix).append(".");
		extfix.append("Extra");
		form.appendf("  <tr><td><b>Extra: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
		form.append("</td></tr>\n");
	}
	if (!context.suppressed("ActiveWorkunit","GraphName")) {
		extfix.clear();
		if (prefix && *prefix)
			extfix.append(prefix).append(".");
		extfix.append("GraphName");
		form.appendf("  <tr><td><b>GraphName: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
		form.append("</td></tr>\n");
	}
	if (!context.suppressed("ActiveWorkunit","Duration")) {
		extfix.clear();
		if (prefix && *prefix)
			extfix.append(prefix).append(".");
		extfix.append("Duration");
		form.appendf("  <tr><td><b>Duration: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
		form.append("</td></tr>\n");
	}
	if (!context.suppressed("ActiveWorkunit","GID")) {
		extfix.clear();
		if (prefix && *prefix)
			extfix.append(prefix).append(".");
		extfix.append("GID");
		form.appendf("  <tr><td><b>GID: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
		form.append("</td></tr>\n");
	}
	if (!context.suppressed("ActiveWorkunit","QueueName")) {
		extfix.clear();
		if (prefix && *prefix)
			extfix.append(prefix).append(".");
		extfix.append("QueueName");
		form.appendf("  <tr><td><b>QueueName: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
		form.append("</td></tr>\n");
	}
	if (!context.suppressed("ActiveWorkunit","MemoryBlocked")) {
		extfix.clear();
		if (prefix && *prefix) extfix.append(prefix).append(".");
			extfix.append("MemoryBlocked");
		form.appendf("  <tr><td><b>MemoryBlocked: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
		form.append("</td></tr>\n");
	}
	if (!context.suppressed("ActiveWorkunit","IsPausing")) {
		extfix.clear();
		if (prefix && *prefix)
			extfix.append(prefix).append(".");
		extfix.append("IsPausing");
		
	form.appendf("  <tr><td><b>IsPausing? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	}
	if (!context.suppressed("ActiveWorkunit","Warning")) {
		extfix.clear();
		if (prefix && *prefix)
			extfix.append(prefix).append(".");
		extfix.append("Warning");
		form.appendf("  <tr><td><b>Warning: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
		form.append("</td></tr>\n");
	}
	if (!context.suppressed("ActiveWorkunit","ClusterName")) {
		extfix.clear();
		if (prefix && *prefix)
			extfix.append(prefix).append(".");
		extfix.append("ClusterName");
		form.appendf("  <tr><td><b>ClusterName: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
		form.append("</td></tr>\n");
	}
	if (!context.suppressed("ActiveWorkunit","ClusterType")) {
		extfix.clear();
		if (prefix && *prefix)
			extfix.append(prefix).append(".");
		extfix.append("ClusterType");
		form.appendf("  <tr><td><b>ClusterType: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
		form.append("</td></tr>\n");
	}
	if (!context.suppressed("ActiveWorkunit","ClusterQueueName")) {
		extfix.clear();
		if (prefix && *prefix)
			extfix.append(prefix).append(".");
		extfix.append("ClusterQueueName");
		form.appendf("  <tr><td><b>ClusterQueueName: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
		form.append("</td></tr>\n");
	}
	if (!context.suppressed("ActiveWorkunit","TargetClusterName")) {
		extfix.clear();
		if (prefix && *prefix)
			extfix.append(prefix).append(".");
		extfix.append("TargetClusterName");
		form.appendf("  <tr><td><b>TargetClusterName: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
		form.append("</td></tr>\n");
	}
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CActiveWorkunit::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CActiveWorkunit::serialize(IRpcMessage& rpc_resp)
{
	IEspContext* ctx = rpc_resp.queryContext();
	double clientVer= ctx ? ctx->getClientVersion() : -1; /* no context gets everything */
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_Wuid.marshall(rpc_resp, "Wuid", "", "", "");
	m_State.marshall(rpc_resp, "State", "", "", "");
	m_StateID.marshall(rpc_resp, "StateID", "", "", "");
	m_Owner.marshall(rpc_resp, "Owner", "", "", "");
	m_Jobname.marshall(rpc_resp, "Jobname", "", "", "");
	m_Server.marshall(rpc_resp, "Server", "", "", "");
	m_Instance.marshall(rpc_resp, "Instance", "", "", "");
	m_Priority.marshall(rpc_resp, "Priority", "", "", "");
	if ((clientVer==-1.0 || clientVer>=1.01))
		m_Extra.marshall(rpc_resp, "Extra", "", "", "");
	if ((clientVer==-1.0 || clientVer>=1.02))
		m_GraphName.marshall(rpc_resp, "GraphName", "", "", "");
	if ((clientVer==-1.0 || clientVer>=1.02))
		m_Duration.marshall(rpc_resp, "Duration", "", "", "");
	if ((clientVer==-1.0 || clientVer>=1.02))
		m_GID.marshall(rpc_resp, "GID", "", "", "");
	if ((clientVer==-1.0 || clientVer>=1.03))
		m_QueueName.marshall(rpc_resp, "QueueName", "", "", "");
	if ((clientVer==-1.0 || clientVer>=1.04))
		m_MemoryBlocked.marshall(rpc_resp, "MemoryBlocked", "", "", "");
	if ((clientVer==-1.0 || clientVer>=1.09))
		m_IsPausing.marshall(rpc_resp, "IsPausing", "", "", "");
	if ((clientVer==-1.0 || clientVer>=1.1))
		m_Warning.marshall(rpc_resp, "Warning", "", "", "");
	if ((clientVer==-1.0 || clientVer>=1.15))
		m_ClusterName.marshall(rpc_resp, "ClusterName", "", "", "");
	if ((clientVer==-1.0 || clientVer>=1.15))
		m_ClusterType.marshall(rpc_resp, "ClusterType", "", "", "");
	if ((clientVer==-1.0 || clientVer>=1.15))
		m_ClusterQueueName.marshall(rpc_resp, "ClusterQueueName", "", "", "");
	if ((clientVer==-1.0 || clientVer>=1.16))
		m_TargetClusterName.marshall(rpc_resp, "TargetClusterName", "", "", "");
}


void CActiveWorkunit::copy(CActiveWorkunit &from)
{
	m_Wuid.copy(from.m_Wuid);
	m_State.copy(from.m_State);
	m_StateID.copy(from.m_StateID);
	m_Owner.copy(from.m_Owner);
	m_Jobname.copy(from.m_Jobname);
	m_Server.copy(from.m_Server);
	m_Instance.copy(from.m_Instance);
	m_Priority.copy(from.m_Priority);
	m_Extra.copy(from.m_Extra);
	m_GraphName.copy(from.m_GraphName);
	m_Duration.copy(from.m_Duration);
	m_GID.copy(from.m_GID);
	m_QueueName.copy(from.m_QueueName);
	m_MemoryBlocked.copy(from.m_MemoryBlocked);
	m_IsPausing.copy(from.m_IsPausing);
	m_Warning.copy(from.m_Warning);
	m_ClusterName.copy(from.m_ClusterName);
	m_ClusterType.copy(from.m_ClusterType);
	m_ClusterQueueName.copy(from.m_ClusterQueueName);
	m_TargetClusterName.copy(from.m_TargetClusterName);
}


void CActiveWorkunit::copy(IConstActiveWorkunit &ifrom)
{
	setWuid(ifrom.getWuid());
	setState(ifrom.getState());
	setStateID(ifrom.getStateID());
	setOwner(ifrom.getOwner());
	setJobname(ifrom.getJobname());
	setServer(ifrom.getServer());
	setInstance(ifrom.getInstance());
	setPriority(ifrom.getPriority());
	setExtra(ifrom.getExtra());
	setGraphName(ifrom.getGraphName());
	setDuration(ifrom.getDuration());
	setGID(ifrom.getGID());
	setQueueName(ifrom.getQueueName());
	setMemoryBlocked(ifrom.getMemoryBlocked());
	setIsPausing(ifrom.getIsPausing());
	setWarning(ifrom.getWarning());
	setClusterName(ifrom.getClusterName());
	setClusterType(ifrom.getClusterType());
	setClusterQueueName(ifrom.getClusterQueueName());
	setTargetClusterName(ifrom.getTargetClusterName());
}


void CActiveWorkunit::getAttributes(IProperties &attributes)
{
}


void CActiveWorkunit::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	double clientVer = ctx ? ctx->getClientVersion() : -1;
	m_Wuid.toStr(ctx, buffer, "Wuid", "", true, "", "");
	m_State.toStr(ctx, buffer, "State", "", true, "", "");
	m_StateID.toStr(ctx, buffer, "StateID", "", true, "", "");
	m_Owner.toStr(ctx, buffer, "Owner", "", true, "", "");
	m_Jobname.toStr(ctx, buffer, "Jobname", "", true, "", "");
	m_Server.toStr(ctx, buffer, "Server", "", true, "", "");
	m_Instance.toStr(ctx, buffer, "Instance", "", true, "", "");
	m_Priority.toStr(ctx, buffer, "Priority", "", true, "", "");
	if ((clientVer==-1.0 || clientVer>=1.01))
		m_Extra.toStr(ctx, buffer, "Extra", "", true, "", "");
	if ((clientVer==-1.0 || clientVer>=1.02))
		m_GraphName.toStr(ctx, buffer, "GraphName", "", true, "", "");
	if ((clientVer==-1.0 || clientVer>=1.02))
		m_Duration.toStr(ctx, buffer, "Duration", "", true, "", "");
	if ((clientVer==-1.0 || clientVer>=1.02))
		m_GID.toStr(ctx, buffer, "GID", "", true, "", "");
	if ((clientVer==-1.0 || clientVer>=1.03))
		m_QueueName.toStr(ctx, buffer, "QueueName", "", true, "", "");
	if ((clientVer==-1.0 || clientVer>=1.04))
		m_MemoryBlocked.toStr(ctx, buffer, "MemoryBlocked", "", true, "", "");
	if ((clientVer==-1.0 || clientVer>=1.09))
		m_IsPausing.toStr(ctx, buffer, "IsPausing", "", true, "", "");
	if ((clientVer==-1.0 || clientVer>=1.1))
		m_Warning.toStr(ctx, buffer, "Warning", "", true, "", "");
	if ((clientVer==-1.0 || clientVer>=1.15))
		m_ClusterName.toStr(ctx, buffer, "ClusterName", "", true, "", "");
	if ((clientVer==-1.0 || clientVer>=1.15))
		m_ClusterType.toStr(ctx, buffer, "ClusterType", "", true, "", "");
	if ((clientVer==-1.0 || clientVer>=1.15))
		m_ClusterQueueName.toStr(ctx, buffer, "ClusterQueueName", "", true, "", "");
	if ((clientVer==-1.0 || clientVer>=1.16))
		m_TargetClusterName.toStr(ctx, buffer, "TargetClusterName", "", true, "", "");
}


void CActiveWorkunit::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CActiveWorkunit::serializer(IEspContext* ctx, IConstActiveWorkunit &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<ActiveWorkunit>");
	double clientVer = ctx ? ctx->getClientVersion() : -1;
	// field Wuid
	{
		const char* s = src.getWuid();
		if (s && *s)
		{
			buffer.append("<Wuid>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Wuid>");
		}
	}
	// field State
	{
		const char* s = src.getState();
		if (s && *s)
		{
			buffer.append("<State>");
			encodeUtf8XML(s,buffer);
			buffer.append("</State>");
		}
	}
	// field StateID
	{
		int n = src.getStateID();
		if (n)
			buffer.appendf("<StateID>%d</StateID>", n);
	}
	// field Owner
	{
		const char* s = src.getOwner();
		if (s && *s)
		{
			buffer.append("<Owner>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Owner>");
		}
	}
	// field Jobname
	{
		const char* s = src.getJobname();
		if (s && *s)
		{
			buffer.append("<Jobname>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Jobname>");
		}
	}
	// field Server
	{
		const char* s = src.getServer();
		if (s && *s)
		{
			buffer.append("<Server>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Server>");
		}
	}
	// field Instance
	{
		const char* s = src.getInstance();
		if (s && *s)
		{
			buffer.append("<Instance>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Instance>");
		}
	}
	// field Priority
	{
		const char* s = src.getPriority();
		if (s && *s)
		{
			buffer.append("<Priority>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Priority>");
		}
	}
	// field Extra
	if ((clientVer==-1.0 || clientVer>=1.01))
	{
		const char* s = src.getExtra();
		if (s && *s)
		{
			buffer.append("<Extra>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Extra>");
		}
	}
	// field GraphName
	if ((clientVer==-1.0 || clientVer>=1.02))
	{
		const char* s = src.getGraphName();
		if (s && *s)
		{
			buffer.append("<GraphName>");
			encodeUtf8XML(s,buffer);
			buffer.append("</GraphName>");
		}
	}
	// field Duration
	if ((clientVer==-1.0 || clientVer>=1.02))
	{
		const char* s = src.getDuration();
		if (s && *s)
		{
			buffer.append("<Duration>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Duration>");
		}
	}
	// field GID
	if ((clientVer==-1.0 || clientVer>=1.02))
	{
		const char* s = src.getGID();
		if (s && *s)
		{
			buffer.append("<GID>");
			encodeUtf8XML(s,buffer);
			buffer.append("</GID>");
		}
	}
	// field QueueName
	if ((clientVer==-1.0 || clientVer>=1.03))
	{
		const char* s = src.getQueueName();
		if (s && *s)
		{
			buffer.append("<QueueName>");
			encodeUtf8XML(s,buffer);
			buffer.append("</QueueName>");
		}
	}
	// field MemoryBlocked
	if ((clientVer==-1.0 || clientVer>=1.04))
	{
		int n = src.getMemoryBlocked();
		if (n)
			buffer.appendf("<MemoryBlocked>%d</MemoryBlocked>", n);
	}
	// field IsPausing
	if ((clientVer==-1.0 || clientVer>=1.09))
	{
		bool b = src.getIsPausing();
		if (b)
			buffer.appendf("<IsPausing>1</IsPausing>");
	}
	// field Warning
	if ((clientVer==-1.0 || clientVer>=1.1))
	{
		const char* s = src.getWarning();
		if (s && *s)
		{
			buffer.append("<Warning>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Warning>");
		}
	}
	// field ClusterName
	if ((clientVer==-1.0 || clientVer>=1.15))
	{
		const char* s = src.getClusterName();
		if (s && *s)
		{
			buffer.append("<ClusterName>");
			encodeUtf8XML(s,buffer);
			buffer.append("</ClusterName>");
		}
	}
	// field ClusterType
	if ((clientVer==-1.0 || clientVer>=1.15))
	{
		const char* s = src.getClusterType();
		if (s && *s)
		{
			buffer.append("<ClusterType>");
			encodeUtf8XML(s,buffer);
			buffer.append("</ClusterType>");
		}
	}
	// field ClusterQueueName
	if ((clientVer==-1.0 || clientVer>=1.15))
	{
		const char* s = src.getClusterQueueName();
		if (s && *s)
		{
			buffer.append("<ClusterQueueName>");
			encodeUtf8XML(s,buffer);
			buffer.append("</ClusterQueueName>");
		}
	}
	// field TargetClusterName
	if ((clientVer==-1.0 || clientVer>=1.16))
	{
		const char* s = src.getTargetClusterName();
		if (s && *s)
		{
			buffer.append("<TargetClusterName>");
			encodeUtf8XML(s,buffer);
			buffer.append("</TargetClusterName>");
		}
	}
	if (keepRootTag)
		buffer.append("</ActiveWorkunit>");
}

bool CActiveWorkunit::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_Wuid.unmarshall(rpc_request, "Wuid", basepath);
	hasValue |= m_State.unmarshall(rpc_request, "State", basepath);
	hasValue |= m_StateID.unmarshall(rpc_request, "StateID", basepath);
	hasValue |= m_Owner.unmarshall(rpc_request, "Owner", basepath);
	hasValue |= m_Jobname.unmarshall(rpc_request, "Jobname", basepath);
	hasValue |= m_Server.unmarshall(rpc_request, "Server", basepath);
	hasValue |= m_Instance.unmarshall(rpc_request, "Instance", basepath);
	hasValue |= m_Priority.unmarshall(rpc_request, "Priority", basepath);
	hasValue |= m_Extra.unmarshall(rpc_request, "Extra", basepath);
	hasValue |= m_GraphName.unmarshall(rpc_request, "GraphName", basepath);
	hasValue |= m_Duration.unmarshall(rpc_request, "Duration", basepath);
	hasValue |= m_GID.unmarshall(rpc_request, "GID", basepath);
	hasValue |= m_QueueName.unmarshall(rpc_request, "QueueName", basepath);
	hasValue |= m_MemoryBlocked.unmarshall(rpc_request, "MemoryBlocked", basepath);
	hasValue |= m_IsPausing.unmarshall(rpc_request, "IsPausing", basepath);
	hasValue |= m_Warning.unmarshall(rpc_request, "Warning", basepath);
	hasValue |= m_ClusterName.unmarshall(rpc_request, "ClusterName", basepath);
	hasValue |= m_ClusterType.unmarshall(rpc_request, "ClusterType", basepath);
	hasValue |= m_ClusterQueueName.unmarshall(rpc_request, "ClusterQueueName", basepath);
	hasValue |= m_TargetClusterName.unmarshall(rpc_request, "TargetClusterName", basepath);
	return hasValue;
}

bool CActiveWorkunit::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Wuid.unmarshall(ctx, soapval, "Wuid");
	hasValue |= m_State.unmarshall(ctx, soapval, "State");
	hasValue |= m_StateID.unmarshall(ctx, soapval, "StateID");
	hasValue |= m_Owner.unmarshall(ctx, soapval, "Owner");
	hasValue |= m_Jobname.unmarshall(ctx, soapval, "Jobname");
	hasValue |= m_Server.unmarshall(ctx, soapval, "Server");
	hasValue |= m_Instance.unmarshall(ctx, soapval, "Instance");
	hasValue |= m_Priority.unmarshall(ctx, soapval, "Priority");
	hasValue |= m_Extra.unmarshall(ctx, soapval, "Extra");
	hasValue |= m_GraphName.unmarshall(ctx, soapval, "GraphName");
	hasValue |= m_Duration.unmarshall(ctx, soapval, "Duration");
	hasValue |= m_GID.unmarshall(ctx, soapval, "GID");
	hasValue |= m_QueueName.unmarshall(ctx, soapval, "QueueName");
	hasValue |= m_MemoryBlocked.unmarshall(ctx, soapval, "MemoryBlocked");
	hasValue |= m_IsPausing.unmarshall(ctx, soapval, "IsPausing");
	hasValue |= m_Warning.unmarshall(ctx, soapval, "Warning");
	hasValue |= m_ClusterName.unmarshall(ctx, soapval, "ClusterName");
	hasValue |= m_ClusterType.unmarshall(ctx, soapval, "ClusterType");
	hasValue |= m_ClusterQueueName.unmarshall(ctx, soapval, "ClusterQueueName");
	hasValue |= m_TargetClusterName.unmarshall(ctx, soapval, "TargetClusterName");
	return hasValue;
}

bool CActiveWorkunit::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Wuid.unmarshall(ctx, params, attachments, "Wuid", basepath);
	hasValue |= m_State.unmarshall(ctx, params, attachments, "State", basepath);
	hasValue |= m_StateID.unmarshall(ctx, params, attachments, "StateID", basepath);
	hasValue |= m_Owner.unmarshall(ctx, params, attachments, "Owner", basepath);
	hasValue |= m_Jobname.unmarshall(ctx, params, attachments, "Jobname", basepath);
	hasValue |= m_Server.unmarshall(ctx, params, attachments, "Server", basepath);
	hasValue |= m_Instance.unmarshall(ctx, params, attachments, "Instance", basepath);
	hasValue |= m_Priority.unmarshall(ctx, params, attachments, "Priority", basepath);
	hasValue |= m_Extra.unmarshall(ctx, params, attachments, "Extra", basepath);
	hasValue |= m_GraphName.unmarshall(ctx, params, attachments, "GraphName", basepath);
	hasValue |= m_Duration.unmarshall(ctx, params, attachments, "Duration", basepath);
	hasValue |= m_GID.unmarshall(ctx, params, attachments, "GID", basepath);
	hasValue |= m_QueueName.unmarshall(ctx, params, attachments, "QueueName", basepath);
	hasValue |= m_MemoryBlocked.unmarshall(ctx, params, attachments, "MemoryBlocked", basepath);
	hasValue |= m_IsPausing.unmarshall(ctx, params, attachments, "IsPausing", basepath);
	hasValue |= m_Warning.unmarshall(ctx, params, attachments, "Warning", basepath);
	hasValue |= m_ClusterName.unmarshall(ctx, params, attachments, "ClusterName", basepath);
	hasValue |= m_ClusterType.unmarshall(ctx, params, attachments, "ClusterType", basepath);
	hasValue |= m_ClusterQueueName.unmarshall(ctx, params, attachments, "ClusterQueueName", basepath);
	hasValue |= m_TargetClusterName.unmarshall(ctx, params, attachments, "TargetClusterName", basepath);
	return hasValue;
}

const char * CActiveWorkunit::getWuid() { return m_Wuid.query();}
const char * CActiveWorkunit::getState() { return m_State.query();}
int CActiveWorkunit::getStateID() { return m_StateID;}
const char * CActiveWorkunit::getOwner() { return m_Owner.query();}
const char * CActiveWorkunit::getJobname() { return m_Jobname.query();}
const char * CActiveWorkunit::getServer() { return m_Server.query();}
const char * CActiveWorkunit::getInstance() { return m_Instance.query();}
const char * CActiveWorkunit::getPriority() { return m_Priority.query();}
const char * CActiveWorkunit::getExtra() { return m_Extra.query();}
const char * CActiveWorkunit::getGraphName() { return m_GraphName.query();}
const char * CActiveWorkunit::getDuration() { return m_Duration.query();}
const char * CActiveWorkunit::getGID() { return m_GID.query();}
const char * CActiveWorkunit::getQueueName() { return m_QueueName.query();}
int CActiveWorkunit::getMemoryBlocked() { return m_MemoryBlocked;}
bool CActiveWorkunit::getIsPausing() { return m_IsPausing;}
const char * CActiveWorkunit::getWarning() { return m_Warning.query();}
const char * CActiveWorkunit::getClusterName() { return m_ClusterName.query();}
const char * CActiveWorkunit::getClusterType() { return m_ClusterType.query();}
const char * CActiveWorkunit::getClusterQueueName() { return m_ClusterQueueName.query();}
const char * CActiveWorkunit::getTargetClusterName() { return m_TargetClusterName.query();}
void CActiveWorkunit::setWuid(const char * val){ m_Wuid.set(val); }
void CActiveWorkunit::setState(const char * val){ m_State.set(val); }
void CActiveWorkunit::setStateID(int val){ m_StateID=val; }
void CActiveWorkunit::setOwner(const char * val){ m_Owner.set(val); }
void CActiveWorkunit::setJobname(const char * val){ m_Jobname.set(val); }
void CActiveWorkunit::setServer(const char * val){ m_Server.set(val); }
void CActiveWorkunit::setInstance(const char * val){ m_Instance.set(val); }
void CActiveWorkunit::setPriority(const char * val){ m_Priority.set(val); }
void CActiveWorkunit::setExtra(const char * val){ m_Extra.set(val); }
void CActiveWorkunit::setGraphName(const char * val){ m_GraphName.set(val); }
void CActiveWorkunit::setDuration(const char * val){ m_Duration.set(val); }
void CActiveWorkunit::setGID(const char * val){ m_GID.set(val); }
void CActiveWorkunit::setQueueName(const char * val){ m_QueueName.set(val); }
void CActiveWorkunit::setMemoryBlocked(int val){ m_MemoryBlocked=val; }
void CActiveWorkunit::setIsPausing(bool val){ m_IsPausing=val; }
void CActiveWorkunit::setWarning(const char * val){ m_Warning.set(val); }
void CActiveWorkunit::setClusterName(const char * val){ m_ClusterName.set(val); }
void CActiveWorkunit::setClusterType(const char * val){ m_ClusterType.set(val); }
void CActiveWorkunit::setClusterQueueName(const char * val){ m_ClusterQueueName.set(val); }
void CActiveWorkunit::setTargetClusterName(const char * val){ m_TargetClusterName.set(val); }
extern "C"  IEspActiveWorkunit *createActiveWorkunit(const char *serv, const char *msgname){return ((IEspActiveWorkunit *)new CActiveWorkunit(serv /*, msgname*/));}
extern "C"  IClientActiveWorkunit *createClientActiveWorkunit(const char *serv, const char *msgname){return ((IClientActiveWorkunit *)new CActiveWorkunit(serv /*, msgname*/));}

//=======================================================
// class CTargetCluster Implementation
//=======================================================

CTargetCluster::CTargetCluster(const char *serviceName, IRpcMessageBinding *init)
	: m_ClusterName(nilIgnore),m_QueueName(nilIgnore),m_QueueStatus(nilIgnore),m_StatusDetails(nilIgnore),m_Warning(nilIgnore),m_ClusterType(nilIgnore),m_ClusterSize(nilIgnore),m_ClusterStatus(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("TargetCluster");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CTargetCluster::CTargetCluster(const char *serviceName, const char *bc)
	: m_ClusterName(nilIgnore),m_QueueName(nilIgnore),m_QueueStatus(nilIgnore),m_StatusDetails(nilIgnore),m_Warning(nilIgnore),m_ClusterType(nilIgnore),m_ClusterSize(nilIgnore),m_ClusterStatus(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("TargetCluster");
}

StringBuffer &CTargetCluster::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:complexType name=\"%s\">\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"ClusterName\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"QueueName\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"QueueStatus\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"StatusDetails\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Warning\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"ClusterType\" type=\"xsd:int\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"ClusterSize\" type=\"xsd:int\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"ClusterStatus\" type=\"xsd:int\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType>\n");
		}
	}
	return schema;
}

void CTargetCluster::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CTargetCluster::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CTargetCluster::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("ClusterName");
	form.appendf("  <tr><td><b>ClusterName: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("QueueName");
	form.appendf("  <tr><td><b>QueueName: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("QueueStatus");
	form.appendf("  <tr><td><b>QueueStatus: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("StatusDetails");
	form.appendf("  <tr><td><b>StatusDetails: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Warning");
	form.appendf("  <tr><td><b>Warning: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix) extfix.append(prefix).append(".");
		extfix.append("ClusterType");
	form.appendf("  <tr><td><b>ClusterType: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix) extfix.append(prefix).append(".");
		extfix.append("ClusterSize");
	form.appendf("  <tr><td><b>ClusterSize: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix) extfix.append(prefix).append(".");
		extfix.append("ClusterStatus");
	form.appendf("  <tr><td><b>ClusterStatus: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CTargetCluster::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CTargetCluster::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_ClusterName.marshall(rpc_resp, "ClusterName", "", "", "");
	m_QueueName.marshall(rpc_resp, "QueueName", "", "", "");
	m_QueueStatus.marshall(rpc_resp, "QueueStatus", "", "", "");
	m_StatusDetails.marshall(rpc_resp, "StatusDetails", "", "", "");
	m_Warning.marshall(rpc_resp, "Warning", "", "", "");
	m_ClusterType.marshall(rpc_resp, "ClusterType", "", "", "");
	m_ClusterSize.marshall(rpc_resp, "ClusterSize", "", "", "");
	m_ClusterStatus.marshall(rpc_resp, "ClusterStatus", "", "", "");
}


void CTargetCluster::copy(CTargetCluster &from)
{
	m_ClusterName.copy(from.m_ClusterName);
	m_QueueName.copy(from.m_QueueName);
	m_QueueStatus.copy(from.m_QueueStatus);
	m_StatusDetails.copy(from.m_StatusDetails);
	m_Warning.copy(from.m_Warning);
	m_ClusterType.copy(from.m_ClusterType);
	m_ClusterSize.copy(from.m_ClusterSize);
	m_ClusterStatus.copy(from.m_ClusterStatus);
}


void CTargetCluster::copy(IConstTargetCluster &ifrom)
{
	setClusterName(ifrom.getClusterName());
	setQueueName(ifrom.getQueueName());
	setQueueStatus(ifrom.getQueueStatus());
	setStatusDetails(ifrom.getStatusDetails());
	setWarning(ifrom.getWarning());
	setClusterType(ifrom.getClusterType());
	setClusterSize(ifrom.getClusterSize());
	setClusterStatus(ifrom.getClusterStatus());
}


void CTargetCluster::getAttributes(IProperties &attributes)
{
}


void CTargetCluster::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_ClusterName.toStr(ctx, buffer, "ClusterName", "", true, "", "");
	m_QueueName.toStr(ctx, buffer, "QueueName", "", true, "", "");
	m_QueueStatus.toStr(ctx, buffer, "QueueStatus", "", true, "", "");
	m_StatusDetails.toStr(ctx, buffer, "StatusDetails", "", true, "", "");
	m_Warning.toStr(ctx, buffer, "Warning", "", true, "", "");
	m_ClusterType.toStr(ctx, buffer, "ClusterType", "", true, "", "");
	m_ClusterSize.toStr(ctx, buffer, "ClusterSize", "", true, "", "");
	m_ClusterStatus.toStr(ctx, buffer, "ClusterStatus", "", true, "", "");
}


void CTargetCluster::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CTargetCluster::serializer(IEspContext* ctx, IConstTargetCluster &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<TargetCluster>");
	// field ClusterName
	{
		const char* s = src.getClusterName();
		if (s && *s)
		{
			buffer.append("<ClusterName>");
			encodeUtf8XML(s,buffer);
			buffer.append("</ClusterName>");
		}
	}
	// field QueueName
	{
		const char* s = src.getQueueName();
		if (s && *s)
		{
			buffer.append("<QueueName>");
			encodeUtf8XML(s,buffer);
			buffer.append("</QueueName>");
		}
	}
	// field QueueStatus
	{
		const char* s = src.getQueueStatus();
		if (s && *s)
		{
			buffer.append("<QueueStatus>");
			encodeUtf8XML(s,buffer);
			buffer.append("</QueueStatus>");
		}
	}
	// field StatusDetails
	{
		const char* s = src.getStatusDetails();
		if (s && *s)
		{
			buffer.append("<StatusDetails>");
			encodeUtf8XML(s,buffer);
			buffer.append("</StatusDetails>");
		}
	}
	// field Warning
	{
		const char* s = src.getWarning();
		if (s && *s)
		{
			buffer.append("<Warning>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Warning>");
		}
	}
	// field ClusterType
	{
		int n = src.getClusterType();
		if (n)
			buffer.appendf("<ClusterType>%d</ClusterType>", n);
	}
	// field ClusterSize
	{
		int n = src.getClusterSize();
		if (n)
			buffer.appendf("<ClusterSize>%d</ClusterSize>", n);
	}
	// field ClusterStatus
	{
		int n = src.getClusterStatus();
		if (n)
			buffer.appendf("<ClusterStatus>%d</ClusterStatus>", n);
	}
	if (keepRootTag)
		buffer.append("</TargetCluster>");
}

bool CTargetCluster::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_ClusterName.unmarshall(rpc_request, "ClusterName", basepath);
	hasValue |= m_QueueName.unmarshall(rpc_request, "QueueName", basepath);
	hasValue |= m_QueueStatus.unmarshall(rpc_request, "QueueStatus", basepath);
	hasValue |= m_StatusDetails.unmarshall(rpc_request, "StatusDetails", basepath);
	hasValue |= m_Warning.unmarshall(rpc_request, "Warning", basepath);
	hasValue |= m_ClusterType.unmarshall(rpc_request, "ClusterType", basepath);
	hasValue |= m_ClusterSize.unmarshall(rpc_request, "ClusterSize", basepath);
	hasValue |= m_ClusterStatus.unmarshall(rpc_request, "ClusterStatus", basepath);
	return hasValue;
}

bool CTargetCluster::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_ClusterName.unmarshall(ctx, soapval, "ClusterName");
	hasValue |= m_QueueName.unmarshall(ctx, soapval, "QueueName");
	hasValue |= m_QueueStatus.unmarshall(ctx, soapval, "QueueStatus");
	hasValue |= m_StatusDetails.unmarshall(ctx, soapval, "StatusDetails");
	hasValue |= m_Warning.unmarshall(ctx, soapval, "Warning");
	hasValue |= m_ClusterType.unmarshall(ctx, soapval, "ClusterType");
	hasValue |= m_ClusterSize.unmarshall(ctx, soapval, "ClusterSize");
	hasValue |= m_ClusterStatus.unmarshall(ctx, soapval, "ClusterStatus");
	return hasValue;
}

bool CTargetCluster::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_ClusterName.unmarshall(ctx, params, attachments, "ClusterName", basepath);
	hasValue |= m_QueueName.unmarshall(ctx, params, attachments, "QueueName", basepath);
	hasValue |= m_QueueStatus.unmarshall(ctx, params, attachments, "QueueStatus", basepath);
	hasValue |= m_StatusDetails.unmarshall(ctx, params, attachments, "StatusDetails", basepath);
	hasValue |= m_Warning.unmarshall(ctx, params, attachments, "Warning", basepath);
	hasValue |= m_ClusterType.unmarshall(ctx, params, attachments, "ClusterType", basepath);
	hasValue |= m_ClusterSize.unmarshall(ctx, params, attachments, "ClusterSize", basepath);
	hasValue |= m_ClusterStatus.unmarshall(ctx, params, attachments, "ClusterStatus", basepath);
	return hasValue;
}

const char * CTargetCluster::getClusterName() { return m_ClusterName.query();}
const char * CTargetCluster::getQueueName() { return m_QueueName.query();}
const char * CTargetCluster::getQueueStatus() { return m_QueueStatus.query();}
const char * CTargetCluster::getStatusDetails() { return m_StatusDetails.query();}
const char * CTargetCluster::getWarning() { return m_Warning.query();}
int CTargetCluster::getClusterType() { return m_ClusterType;}
int CTargetCluster::getClusterSize() { return m_ClusterSize;}
int CTargetCluster::getClusterStatus() { return m_ClusterStatus;}
void CTargetCluster::setClusterName(const char * val){ m_ClusterName.set(val); }
void CTargetCluster::setQueueName(const char * val){ m_QueueName.set(val); }
void CTargetCluster::setQueueStatus(const char * val){ m_QueueStatus.set(val); }
void CTargetCluster::setStatusDetails(const char * val){ m_StatusDetails.set(val); }
void CTargetCluster::setWarning(const char * val){ m_Warning.set(val); }
void CTargetCluster::setClusterType(int val){ m_ClusterType=val; }
void CTargetCluster::setClusterSize(int val){ m_ClusterSize=val; }
void CTargetCluster::setClusterStatus(int val){ m_ClusterStatus=val; }
extern "C"  IEspTargetCluster *createTargetCluster(const char *serv, const char *msgname){return ((IEspTargetCluster *)new CTargetCluster(serv /*, msgname*/));}
extern "C"  IClientTargetCluster *createClientTargetCluster(const char *serv, const char *msgname){return ((IClientTargetCluster *)new CTargetCluster(serv /*, msgname*/));}

//=======================================================
// class CThorCluster Implementation
//=======================================================

CThorCluster::CThorCluster(const char *serviceName, IRpcMessageBinding *init)
	: m_ClusterName(nilIgnore),m_QueueName(nilIgnore),m_QueueStatus(nilIgnore),m_QueueAvailable(nilIgnore),m_JobsRunning(nilIgnore),m_JobsInQueue(nilIgnore),m_QueueStatus2(nilIgnore),m_ThorLCR(nilIgnore),m_ClusterSize(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ThorCluster");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CThorCluster::CThorCluster(const char *serviceName, const char *bc)
	: m_ClusterName(nilIgnore),m_QueueName(nilIgnore),m_QueueStatus(nilIgnore),m_QueueAvailable(nilIgnore),m_JobsRunning(nilIgnore),m_JobsInQueue(nilIgnore),m_QueueStatus2(nilIgnore),m_ThorLCR(nilIgnore),m_ClusterSize(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ThorCluster");
}

StringBuffer &CThorCluster::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:complexType name=\"%s\">\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"ClusterName\" type=\"xsd:string\"/>\n");
		if (!context.suppressed("ThorCluster","QueueName")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"QueueName\" type=\"xsd:string\"/>\n");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"QueueStatus\" type=\"xsd:string\"/>\n");
		if (!context.suppressed("ThorCluster","QueueAvailable")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"QueueAvailable\" type=\"xsd:int\"/>\n");
		}
		if (!context.suppressed("ThorCluster","JobsRunning")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"JobsRunning\" type=\"xsd:int\"/>\n");
		}
		if (!context.suppressed("ThorCluster","JobsInQueue")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"JobsInQueue\" type=\"xsd:int\"/>\n");
		}
		if (!context.suppressed("ThorCluster","QueueStatus2")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"QueueStatus2\" type=\"xsd:int\"/>\n");
		}
		if (!context.suppressed("ThorCluster","ThorLCR")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"ThorLCR\" type=\"xsd:string\"/>\n");
		}
		if (!context.suppressed("ThorCluster","ClusterSize")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"ClusterSize\" type=\"xsd:int\"/>\n");
		}
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType>\n");
		}
	}
	return schema;
}

void CThorCluster::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CThorCluster::getMapInfo(IMapInfo& info, BoolHash& added)
{
	info.addMinVersion("ThorCluster","QueueName",1.03);
	info.addMinVersion("ThorCluster","QueueAvailable",1.05);
	info.addMinVersion("ThorCluster","JobsRunning",1.05);
	info.addMinVersion("ThorCluster","JobsInQueue",1.05);
	info.addMinVersion("ThorCluster","QueueStatus2",1.07);
	info.addMinVersion("ThorCluster","ThorLCR",1.09);
	info.addMinVersion("ThorCluster","ClusterSize",1.11);
}

StringBuffer &CThorCluster::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("ClusterName");
	form.appendf("  <tr><td><b>ClusterName: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (!context.suppressed("ThorCluster","QueueName")) {
		extfix.clear();
		if (prefix && *prefix)
			extfix.append(prefix).append(".");
		extfix.append("QueueName");
		form.appendf("  <tr><td><b>QueueName: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
		form.append("</td></tr>\n");
	}
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("QueueStatus");
	form.appendf("  <tr><td><b>QueueStatus: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (!context.suppressed("ThorCluster","QueueAvailable")) {
		extfix.clear();
		if (prefix && *prefix) extfix.append(prefix).append(".");
			extfix.append("QueueAvailable");
		form.appendf("  <tr><td><b>QueueAvailable: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
		form.append("</td></tr>\n");
	}
	if (!context.suppressed("ThorCluster","JobsRunning")) {
		extfix.clear();
		if (prefix && *prefix) extfix.append(prefix).append(".");
			extfix.append("JobsRunning");
		form.appendf("  <tr><td><b>JobsRunning: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
		form.append("</td></tr>\n");
	}
	if (!context.suppressed("ThorCluster","JobsInQueue")) {
		extfix.clear();
		if (prefix && *prefix) extfix.append(prefix).append(".");
			extfix.append("JobsInQueue");
		form.appendf("  <tr><td><b>JobsInQueue: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
		form.append("</td></tr>\n");
	}
	if (!context.suppressed("ThorCluster","QueueStatus2")) {
		extfix.clear();
		if (prefix && *prefix) extfix.append(prefix).append(".");
			extfix.append("QueueStatus2");
		form.appendf("  <tr><td><b>QueueStatus2: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
		form.append("</td></tr>\n");
	}
	if (!context.suppressed("ThorCluster","ThorLCR")) {
		extfix.clear();
		if (prefix && *prefix)
			extfix.append(prefix).append(".");
		extfix.append("ThorLCR");
		form.appendf("  <tr><td><b>ThorLCR: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
		form.append("</td></tr>\n");
	}
	if (!context.suppressed("ThorCluster","ClusterSize")) {
		extfix.clear();
		if (prefix && *prefix) extfix.append(prefix).append(".");
			extfix.append("ClusterSize");
		form.appendf("  <tr><td><b>ClusterSize: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
		form.append("</td></tr>\n");
	}
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CThorCluster::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CThorCluster::serialize(IRpcMessage& rpc_resp)
{
	IEspContext* ctx = rpc_resp.queryContext();
	double clientVer= ctx ? ctx->getClientVersion() : -1; /* no context gets everything */
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_ClusterName.marshall(rpc_resp, "ClusterName", "", "", "");
	if ((clientVer==-1.0 || clientVer>=1.03))
		m_QueueName.marshall(rpc_resp, "QueueName", "", "", "");
	m_QueueStatus.marshall(rpc_resp, "QueueStatus", "", "", "");
	if ((clientVer==-1.0 || clientVer>=1.05))
		m_QueueAvailable.marshall(rpc_resp, "QueueAvailable", "", "", "");
	if ((clientVer==-1.0 || clientVer>=1.05))
		m_JobsRunning.marshall(rpc_resp, "JobsRunning", "", "", "");
	if ((clientVer==-1.0 || clientVer>=1.05))
		m_JobsInQueue.marshall(rpc_resp, "JobsInQueue", "", "", "");
	if ((clientVer==-1.0 || clientVer>=1.07))
		m_QueueStatus2.marshall(rpc_resp, "QueueStatus2", "", "", "");
	if ((clientVer==-1.0 || clientVer>=1.09))
		m_ThorLCR.marshall(rpc_resp, "ThorLCR", "", "", "");
	if ((clientVer==-1.0 || clientVer>=1.11))
		m_ClusterSize.marshall(rpc_resp, "ClusterSize", "", "", "");
}


void CThorCluster::copy(CThorCluster &from)
{
	m_ClusterName.copy(from.m_ClusterName);
	m_QueueName.copy(from.m_QueueName);
	m_QueueStatus.copy(from.m_QueueStatus);
	m_QueueAvailable.copy(from.m_QueueAvailable);
	m_JobsRunning.copy(from.m_JobsRunning);
	m_JobsInQueue.copy(from.m_JobsInQueue);
	m_QueueStatus2.copy(from.m_QueueStatus2);
	m_ThorLCR.copy(from.m_ThorLCR);
	m_ClusterSize.copy(from.m_ClusterSize);
}


void CThorCluster::copy(IConstThorCluster &ifrom)
{
	setClusterName(ifrom.getClusterName());
	setQueueName(ifrom.getQueueName());
	setQueueStatus(ifrom.getQueueStatus());
	setQueueAvailable(ifrom.getQueueAvailable());
	setJobsRunning(ifrom.getJobsRunning());
	setJobsInQueue(ifrom.getJobsInQueue());
	setQueueStatus2(ifrom.getQueueStatus2());
	setThorLCR(ifrom.getThorLCR());
	setClusterSize(ifrom.getClusterSize());
}


void CThorCluster::getAttributes(IProperties &attributes)
{
}


void CThorCluster::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	double clientVer = ctx ? ctx->getClientVersion() : -1;
	m_ClusterName.toStr(ctx, buffer, "ClusterName", "", true, "", "");
	if ((clientVer==-1.0 || clientVer>=1.03))
		m_QueueName.toStr(ctx, buffer, "QueueName", "", true, "", "");
	m_QueueStatus.toStr(ctx, buffer, "QueueStatus", "", true, "", "");
	if ((clientVer==-1.0 || clientVer>=1.05))
		m_QueueAvailable.toStr(ctx, buffer, "QueueAvailable", "", true, "", "");
	if ((clientVer==-1.0 || clientVer>=1.05))
		m_JobsRunning.toStr(ctx, buffer, "JobsRunning", "", true, "", "");
	if ((clientVer==-1.0 || clientVer>=1.05))
		m_JobsInQueue.toStr(ctx, buffer, "JobsInQueue", "", true, "", "");
	if ((clientVer==-1.0 || clientVer>=1.07))
		m_QueueStatus2.toStr(ctx, buffer, "QueueStatus2", "", true, "", "");
	if ((clientVer==-1.0 || clientVer>=1.09))
		m_ThorLCR.toStr(ctx, buffer, "ThorLCR", "", true, "", "");
	if ((clientVer==-1.0 || clientVer>=1.11))
		m_ClusterSize.toStr(ctx, buffer, "ClusterSize", "", true, "", "");
}


void CThorCluster::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CThorCluster::serializer(IEspContext* ctx, IConstThorCluster &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<ThorCluster>");
	double clientVer = ctx ? ctx->getClientVersion() : -1;
	// field ClusterName
	{
		const char* s = src.getClusterName();
		if (s && *s)
		{
			buffer.append("<ClusterName>");
			encodeUtf8XML(s,buffer);
			buffer.append("</ClusterName>");
		}
	}
	// field QueueName
	if ((clientVer==-1.0 || clientVer>=1.03))
	{
		const char* s = src.getQueueName();
		if (s && *s)
		{
			buffer.append("<QueueName>");
			encodeUtf8XML(s,buffer);
			buffer.append("</QueueName>");
		}
	}
	// field QueueStatus
	{
		const char* s = src.getQueueStatus();
		if (s && *s)
		{
			buffer.append("<QueueStatus>");
			encodeUtf8XML(s,buffer);
			buffer.append("</QueueStatus>");
		}
	}
	// field QueueAvailable
	if ((clientVer==-1.0 || clientVer>=1.05))
	{
		int n = src.getQueueAvailable();
		if (n)
			buffer.appendf("<QueueAvailable>%d</QueueAvailable>", n);
	}
	// field JobsRunning
	if ((clientVer==-1.0 || clientVer>=1.05))
	{
		int n = src.getJobsRunning();
		if (n)
			buffer.appendf("<JobsRunning>%d</JobsRunning>", n);
	}
	// field JobsInQueue
	if ((clientVer==-1.0 || clientVer>=1.05))
	{
		int n = src.getJobsInQueue();
		if (n)
			buffer.appendf("<JobsInQueue>%d</JobsInQueue>", n);
	}
	// field QueueStatus2
	if ((clientVer==-1.0 || clientVer>=1.07))
	{
		int n = src.getQueueStatus2();
		if (n)
			buffer.appendf("<QueueStatus2>%d</QueueStatus2>", n);
	}
	// field ThorLCR
	if ((clientVer==-1.0 || clientVer>=1.09))
	{
		const char* s = src.getThorLCR();
		if (s && *s)
		{
			buffer.append("<ThorLCR>");
			encodeUtf8XML(s,buffer);
			buffer.append("</ThorLCR>");
		}
	}
	// field ClusterSize
	if ((clientVer==-1.0 || clientVer>=1.11))
	{
		int n = src.getClusterSize();
		if (n)
			buffer.appendf("<ClusterSize>%d</ClusterSize>", n);
	}
	if (keepRootTag)
		buffer.append("</ThorCluster>");
}

bool CThorCluster::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_ClusterName.unmarshall(rpc_request, "ClusterName", basepath);
	hasValue |= m_QueueName.unmarshall(rpc_request, "QueueName", basepath);
	hasValue |= m_QueueStatus.unmarshall(rpc_request, "QueueStatus", basepath);
	hasValue |= m_QueueAvailable.unmarshall(rpc_request, "QueueAvailable", basepath);
	hasValue |= m_JobsRunning.unmarshall(rpc_request, "JobsRunning", basepath);
	hasValue |= m_JobsInQueue.unmarshall(rpc_request, "JobsInQueue", basepath);
	hasValue |= m_QueueStatus2.unmarshall(rpc_request, "QueueStatus2", basepath);
	hasValue |= m_ThorLCR.unmarshall(rpc_request, "ThorLCR", basepath);
	hasValue |= m_ClusterSize.unmarshall(rpc_request, "ClusterSize", basepath);
	return hasValue;
}

bool CThorCluster::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_ClusterName.unmarshall(ctx, soapval, "ClusterName");
	hasValue |= m_QueueName.unmarshall(ctx, soapval, "QueueName");
	hasValue |= m_QueueStatus.unmarshall(ctx, soapval, "QueueStatus");
	hasValue |= m_QueueAvailable.unmarshall(ctx, soapval, "QueueAvailable");
	hasValue |= m_JobsRunning.unmarshall(ctx, soapval, "JobsRunning");
	hasValue |= m_JobsInQueue.unmarshall(ctx, soapval, "JobsInQueue");
	hasValue |= m_QueueStatus2.unmarshall(ctx, soapval, "QueueStatus2");
	hasValue |= m_ThorLCR.unmarshall(ctx, soapval, "ThorLCR");
	hasValue |= m_ClusterSize.unmarshall(ctx, soapval, "ClusterSize");
	return hasValue;
}

bool CThorCluster::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_ClusterName.unmarshall(ctx, params, attachments, "ClusterName", basepath);
	hasValue |= m_QueueName.unmarshall(ctx, params, attachments, "QueueName", basepath);
	hasValue |= m_QueueStatus.unmarshall(ctx, params, attachments, "QueueStatus", basepath);
	hasValue |= m_QueueAvailable.unmarshall(ctx, params, attachments, "QueueAvailable", basepath);
	hasValue |= m_JobsRunning.unmarshall(ctx, params, attachments, "JobsRunning", basepath);
	hasValue |= m_JobsInQueue.unmarshall(ctx, params, attachments, "JobsInQueue", basepath);
	hasValue |= m_QueueStatus2.unmarshall(ctx, params, attachments, "QueueStatus2", basepath);
	hasValue |= m_ThorLCR.unmarshall(ctx, params, attachments, "ThorLCR", basepath);
	hasValue |= m_ClusterSize.unmarshall(ctx, params, attachments, "ClusterSize", basepath);
	return hasValue;
}

const char * CThorCluster::getClusterName() { return m_ClusterName.query();}
const char * CThorCluster::getQueueName() { return m_QueueName.query();}
const char * CThorCluster::getQueueStatus() { return m_QueueStatus.query();}
int CThorCluster::getQueueAvailable() { return m_QueueAvailable;}
int CThorCluster::getJobsRunning() { return m_JobsRunning;}
int CThorCluster::getJobsInQueue() { return m_JobsInQueue;}
int CThorCluster::getQueueStatus2() { return m_QueueStatus2;}
const char * CThorCluster::getThorLCR() { return m_ThorLCR.query();}
int CThorCluster::getClusterSize() { return m_ClusterSize;}
void CThorCluster::setClusterName(const char * val){ m_ClusterName.set(val); }
void CThorCluster::setQueueName(const char * val){ m_QueueName.set(val); }
void CThorCluster::setQueueStatus(const char * val){ m_QueueStatus.set(val); }
void CThorCluster::setQueueAvailable(int val){ m_QueueAvailable=val; }
void CThorCluster::setJobsRunning(int val){ m_JobsRunning=val; }
void CThorCluster::setJobsInQueue(int val){ m_JobsInQueue=val; }
void CThorCluster::setQueueStatus2(int val){ m_QueueStatus2=val; }
void CThorCluster::setThorLCR(const char * val){ m_ThorLCR.set(val); }
void CThorCluster::setClusterSize(int val){ m_ClusterSize=val; }
extern "C"  IEspThorCluster *createThorCluster(const char *serv, const char *msgname){return ((IEspThorCluster *)new CThorCluster(serv /*, msgname*/));}
extern "C"  IClientThorCluster *createClientThorCluster(const char *serv, const char *msgname){return ((IClientThorCluster *)new CThorCluster(serv /*, msgname*/));}

//=======================================================
// class CHThorCluster Implementation
//=======================================================

CHThorCluster::CHThorCluster(const char *serviceName, IRpcMessageBinding *init)
	: m_ClusterName(nilIgnore),m_QueueName(nilIgnore),m_QueueStatus(nilIgnore),m_JobsRunning(nilIgnore),m_JobsInQueue(nilIgnore),m_QueueStatus2(nilIgnore),m_ClusterSize(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("HThorCluster");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CHThorCluster::CHThorCluster(const char *serviceName, const char *bc)
	: m_ClusterName(nilIgnore),m_QueueName(nilIgnore),m_QueueStatus(nilIgnore),m_JobsRunning(nilIgnore),m_JobsInQueue(nilIgnore),m_QueueStatus2(nilIgnore),m_ClusterSize(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("HThorCluster");
}

StringBuffer &CHThorCluster::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:complexType name=\"%s\">\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"ClusterName\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"QueueName\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"QueueStatus\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"JobsRunning\" type=\"xsd:int\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"JobsInQueue\" type=\"xsd:int\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"QueueStatus2\" type=\"xsd:int\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"ClusterSize\" type=\"xsd:int\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType>\n");
		}
	}
	return schema;
}

void CHThorCluster::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CHThorCluster::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CHThorCluster::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("ClusterName");
	form.appendf("  <tr><td><b>ClusterName: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("QueueName");
	form.appendf("  <tr><td><b>QueueName: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("QueueStatus");
	form.appendf("  <tr><td><b>QueueStatus: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix) extfix.append(prefix).append(".");
		extfix.append("JobsRunning");
	form.appendf("  <tr><td><b>JobsRunning: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix) extfix.append(prefix).append(".");
		extfix.append("JobsInQueue");
	form.appendf("  <tr><td><b>JobsInQueue: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix) extfix.append(prefix).append(".");
		extfix.append("QueueStatus2");
	form.appendf("  <tr><td><b>QueueStatus2: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix) extfix.append(prefix).append(".");
		extfix.append("ClusterSize");
	form.appendf("  <tr><td><b>ClusterSize: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CHThorCluster::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CHThorCluster::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_ClusterName.marshall(rpc_resp, "ClusterName", "", "", "");
	m_QueueName.marshall(rpc_resp, "QueueName", "", "", "");
	m_QueueStatus.marshall(rpc_resp, "QueueStatus", "", "", "");
	m_JobsRunning.marshall(rpc_resp, "JobsRunning", "", "", "");
	m_JobsInQueue.marshall(rpc_resp, "JobsInQueue", "", "", "");
	m_QueueStatus2.marshall(rpc_resp, "QueueStatus2", "", "", "");
	m_ClusterSize.marshall(rpc_resp, "ClusterSize", "", "", "");
}


void CHThorCluster::copy(CHThorCluster &from)
{
	m_ClusterName.copy(from.m_ClusterName);
	m_QueueName.copy(from.m_QueueName);
	m_QueueStatus.copy(from.m_QueueStatus);
	m_JobsRunning.copy(from.m_JobsRunning);
	m_JobsInQueue.copy(from.m_JobsInQueue);
	m_QueueStatus2.copy(from.m_QueueStatus2);
	m_ClusterSize.copy(from.m_ClusterSize);
}


void CHThorCluster::copy(IConstHThorCluster &ifrom)
{
	setClusterName(ifrom.getClusterName());
	setQueueName(ifrom.getQueueName());
	setQueueStatus(ifrom.getQueueStatus());
	setJobsRunning(ifrom.getJobsRunning());
	setJobsInQueue(ifrom.getJobsInQueue());
	setQueueStatus2(ifrom.getQueueStatus2());
	setClusterSize(ifrom.getClusterSize());
}


void CHThorCluster::getAttributes(IProperties &attributes)
{
}


void CHThorCluster::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_ClusterName.toStr(ctx, buffer, "ClusterName", "", true, "", "");
	m_QueueName.toStr(ctx, buffer, "QueueName", "", true, "", "");
	m_QueueStatus.toStr(ctx, buffer, "QueueStatus", "", true, "", "");
	m_JobsRunning.toStr(ctx, buffer, "JobsRunning", "", true, "", "");
	m_JobsInQueue.toStr(ctx, buffer, "JobsInQueue", "", true, "", "");
	m_QueueStatus2.toStr(ctx, buffer, "QueueStatus2", "", true, "", "");
	m_ClusterSize.toStr(ctx, buffer, "ClusterSize", "", true, "", "");
}


void CHThorCluster::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CHThorCluster::serializer(IEspContext* ctx, IConstHThorCluster &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<HThorCluster>");
	// field ClusterName
	{
		const char* s = src.getClusterName();
		if (s && *s)
		{
			buffer.append("<ClusterName>");
			encodeUtf8XML(s,buffer);
			buffer.append("</ClusterName>");
		}
	}
	// field QueueName
	{
		const char* s = src.getQueueName();
		if (s && *s)
		{
			buffer.append("<QueueName>");
			encodeUtf8XML(s,buffer);
			buffer.append("</QueueName>");
		}
	}
	// field QueueStatus
	{
		const char* s = src.getQueueStatus();
		if (s && *s)
		{
			buffer.append("<QueueStatus>");
			encodeUtf8XML(s,buffer);
			buffer.append("</QueueStatus>");
		}
	}
	// field JobsRunning
	{
		int n = src.getJobsRunning();
		if (n)
			buffer.appendf("<JobsRunning>%d</JobsRunning>", n);
	}
	// field JobsInQueue
	{
		int n = src.getJobsInQueue();
		if (n)
			buffer.appendf("<JobsInQueue>%d</JobsInQueue>", n);
	}
	// field QueueStatus2
	{
		int n = src.getQueueStatus2();
		if (n)
			buffer.appendf("<QueueStatus2>%d</QueueStatus2>", n);
	}
	// field ClusterSize
	{
		int n = src.getClusterSize();
		if (n)
			buffer.appendf("<ClusterSize>%d</ClusterSize>", n);
	}
	if (keepRootTag)
		buffer.append("</HThorCluster>");
}

bool CHThorCluster::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_ClusterName.unmarshall(rpc_request, "ClusterName", basepath);
	hasValue |= m_QueueName.unmarshall(rpc_request, "QueueName", basepath);
	hasValue |= m_QueueStatus.unmarshall(rpc_request, "QueueStatus", basepath);
	hasValue |= m_JobsRunning.unmarshall(rpc_request, "JobsRunning", basepath);
	hasValue |= m_JobsInQueue.unmarshall(rpc_request, "JobsInQueue", basepath);
	hasValue |= m_QueueStatus2.unmarshall(rpc_request, "QueueStatus2", basepath);
	hasValue |= m_ClusterSize.unmarshall(rpc_request, "ClusterSize", basepath);
	return hasValue;
}

bool CHThorCluster::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_ClusterName.unmarshall(ctx, soapval, "ClusterName");
	hasValue |= m_QueueName.unmarshall(ctx, soapval, "QueueName");
	hasValue |= m_QueueStatus.unmarshall(ctx, soapval, "QueueStatus");
	hasValue |= m_JobsRunning.unmarshall(ctx, soapval, "JobsRunning");
	hasValue |= m_JobsInQueue.unmarshall(ctx, soapval, "JobsInQueue");
	hasValue |= m_QueueStatus2.unmarshall(ctx, soapval, "QueueStatus2");
	hasValue |= m_ClusterSize.unmarshall(ctx, soapval, "ClusterSize");
	return hasValue;
}

bool CHThorCluster::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_ClusterName.unmarshall(ctx, params, attachments, "ClusterName", basepath);
	hasValue |= m_QueueName.unmarshall(ctx, params, attachments, "QueueName", basepath);
	hasValue |= m_QueueStatus.unmarshall(ctx, params, attachments, "QueueStatus", basepath);
	hasValue |= m_JobsRunning.unmarshall(ctx, params, attachments, "JobsRunning", basepath);
	hasValue |= m_JobsInQueue.unmarshall(ctx, params, attachments, "JobsInQueue", basepath);
	hasValue |= m_QueueStatus2.unmarshall(ctx, params, attachments, "QueueStatus2", basepath);
	hasValue |= m_ClusterSize.unmarshall(ctx, params, attachments, "ClusterSize", basepath);
	return hasValue;
}

const char * CHThorCluster::getClusterName() { return m_ClusterName.query();}
const char * CHThorCluster::getQueueName() { return m_QueueName.query();}
const char * CHThorCluster::getQueueStatus() { return m_QueueStatus.query();}
int CHThorCluster::getJobsRunning() { return m_JobsRunning;}
int CHThorCluster::getJobsInQueue() { return m_JobsInQueue;}
int CHThorCluster::getQueueStatus2() { return m_QueueStatus2;}
int CHThorCluster::getClusterSize() { return m_ClusterSize;}
void CHThorCluster::setClusterName(const char * val){ m_ClusterName.set(val); }
void CHThorCluster::setQueueName(const char * val){ m_QueueName.set(val); }
void CHThorCluster::setQueueStatus(const char * val){ m_QueueStatus.set(val); }
void CHThorCluster::setJobsRunning(int val){ m_JobsRunning=val; }
void CHThorCluster::setJobsInQueue(int val){ m_JobsInQueue=val; }
void CHThorCluster::setQueueStatus2(int val){ m_QueueStatus2=val; }
void CHThorCluster::setClusterSize(int val){ m_ClusterSize=val; }
extern "C"  IEspHThorCluster *createHThorCluster(const char *serv, const char *msgname){return ((IEspHThorCluster *)new CHThorCluster(serv /*, msgname*/));}
extern "C"  IClientHThorCluster *createClientHThorCluster(const char *serv, const char *msgname){return ((IClientHThorCluster *)new CHThorCluster(serv /*, msgname*/));}

//=======================================================
// class CRoxieCluster Implementation
//=======================================================

CRoxieCluster::CRoxieCluster(const char *serviceName, IRpcMessageBinding *init)
	: m_ClusterName(nilIgnore),m_QueueName(nilIgnore),m_QueueStatus(nilIgnore),m_JobsRunning(nilIgnore),m_JobsInQueue(nilIgnore),m_QueueStatus2(nilIgnore),m_ClusterSize(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("RoxieCluster");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CRoxieCluster::CRoxieCluster(const char *serviceName, const char *bc)
	: m_ClusterName(nilIgnore),m_QueueName(nilIgnore),m_QueueStatus(nilIgnore),m_JobsRunning(nilIgnore),m_JobsInQueue(nilIgnore),m_QueueStatus2(nilIgnore),m_ClusterSize(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("RoxieCluster");
}

StringBuffer &CRoxieCluster::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:complexType name=\"%s\">\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"ClusterName\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"QueueName\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"QueueStatus\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"JobsRunning\" type=\"xsd:int\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"JobsInQueue\" type=\"xsd:int\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"QueueStatus2\" type=\"xsd:int\"/>\n");
		if (!context.suppressed("RoxieCluster","ClusterSize")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"ClusterSize\" type=\"xsd:int\"/>\n");
		}
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType>\n");
		}
	}
	return schema;
}

void CRoxieCluster::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CRoxieCluster::getMapInfo(IMapInfo& info, BoolHash& added)
{
	info.addMinVersion("RoxieCluster","ClusterSize",1.11);
}

StringBuffer &CRoxieCluster::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("ClusterName");
	form.appendf("  <tr><td><b>ClusterName: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("QueueName");
	form.appendf("  <tr><td><b>QueueName: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("QueueStatus");
	form.appendf("  <tr><td><b>QueueStatus: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix) extfix.append(prefix).append(".");
		extfix.append("JobsRunning");
	form.appendf("  <tr><td><b>JobsRunning: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix) extfix.append(prefix).append(".");
		extfix.append("JobsInQueue");
	form.appendf("  <tr><td><b>JobsInQueue: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix) extfix.append(prefix).append(".");
		extfix.append("QueueStatus2");
	form.appendf("  <tr><td><b>QueueStatus2: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
	form.append("</td></tr>\n");
	if (!context.suppressed("RoxieCluster","ClusterSize")) {
		extfix.clear();
		if (prefix && *prefix) extfix.append(prefix).append(".");
			extfix.append("ClusterSize");
		form.appendf("  <tr><td><b>ClusterSize: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
		form.append("</td></tr>\n");
	}
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CRoxieCluster::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CRoxieCluster::serialize(IRpcMessage& rpc_resp)
{
	IEspContext* ctx = rpc_resp.queryContext();
	double clientVer= ctx ? ctx->getClientVersion() : -1; /* no context gets everything */
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_ClusterName.marshall(rpc_resp, "ClusterName", "", "", "");
	m_QueueName.marshall(rpc_resp, "QueueName", "", "", "");
	m_QueueStatus.marshall(rpc_resp, "QueueStatus", "", "", "");
	m_JobsRunning.marshall(rpc_resp, "JobsRunning", "", "", "");
	m_JobsInQueue.marshall(rpc_resp, "JobsInQueue", "", "", "");
	m_QueueStatus2.marshall(rpc_resp, "QueueStatus2", "", "", "");
	if ((clientVer==-1.0 || clientVer>=1.11))
		m_ClusterSize.marshall(rpc_resp, "ClusterSize", "", "", "");
}


void CRoxieCluster::copy(CRoxieCluster &from)
{
	m_ClusterName.copy(from.m_ClusterName);
	m_QueueName.copy(from.m_QueueName);
	m_QueueStatus.copy(from.m_QueueStatus);
	m_JobsRunning.copy(from.m_JobsRunning);
	m_JobsInQueue.copy(from.m_JobsInQueue);
	m_QueueStatus2.copy(from.m_QueueStatus2);
	m_ClusterSize.copy(from.m_ClusterSize);
}


void CRoxieCluster::copy(IConstRoxieCluster &ifrom)
{
	setClusterName(ifrom.getClusterName());
	setQueueName(ifrom.getQueueName());
	setQueueStatus(ifrom.getQueueStatus());
	setJobsRunning(ifrom.getJobsRunning());
	setJobsInQueue(ifrom.getJobsInQueue());
	setQueueStatus2(ifrom.getQueueStatus2());
	setClusterSize(ifrom.getClusterSize());
}


void CRoxieCluster::getAttributes(IProperties &attributes)
{
}


void CRoxieCluster::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	double clientVer = ctx ? ctx->getClientVersion() : -1;
	m_ClusterName.toStr(ctx, buffer, "ClusterName", "", true, "", "");
	m_QueueName.toStr(ctx, buffer, "QueueName", "", true, "", "");
	m_QueueStatus.toStr(ctx, buffer, "QueueStatus", "", true, "", "");
	m_JobsRunning.toStr(ctx, buffer, "JobsRunning", "", true, "", "");
	m_JobsInQueue.toStr(ctx, buffer, "JobsInQueue", "", true, "", "");
	m_QueueStatus2.toStr(ctx, buffer, "QueueStatus2", "", true, "", "");
	if ((clientVer==-1.0 || clientVer>=1.11))
		m_ClusterSize.toStr(ctx, buffer, "ClusterSize", "", true, "", "");
}


void CRoxieCluster::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CRoxieCluster::serializer(IEspContext* ctx, IConstRoxieCluster &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<RoxieCluster>");
	double clientVer = ctx ? ctx->getClientVersion() : -1;
	// field ClusterName
	{
		const char* s = src.getClusterName();
		if (s && *s)
		{
			buffer.append("<ClusterName>");
			encodeUtf8XML(s,buffer);
			buffer.append("</ClusterName>");
		}
	}
	// field QueueName
	{
		const char* s = src.getQueueName();
		if (s && *s)
		{
			buffer.append("<QueueName>");
			encodeUtf8XML(s,buffer);
			buffer.append("</QueueName>");
		}
	}
	// field QueueStatus
	{
		const char* s = src.getQueueStatus();
		if (s && *s)
		{
			buffer.append("<QueueStatus>");
			encodeUtf8XML(s,buffer);
			buffer.append("</QueueStatus>");
		}
	}
	// field JobsRunning
	{
		int n = src.getJobsRunning();
		if (n)
			buffer.appendf("<JobsRunning>%d</JobsRunning>", n);
	}
	// field JobsInQueue
	{
		int n = src.getJobsInQueue();
		if (n)
			buffer.appendf("<JobsInQueue>%d</JobsInQueue>", n);
	}
	// field QueueStatus2
	{
		int n = src.getQueueStatus2();
		if (n)
			buffer.appendf("<QueueStatus2>%d</QueueStatus2>", n);
	}
	// field ClusterSize
	if ((clientVer==-1.0 || clientVer>=1.11))
	{
		int n = src.getClusterSize();
		if (n)
			buffer.appendf("<ClusterSize>%d</ClusterSize>", n);
	}
	if (keepRootTag)
		buffer.append("</RoxieCluster>");
}

bool CRoxieCluster::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_ClusterName.unmarshall(rpc_request, "ClusterName", basepath);
	hasValue |= m_QueueName.unmarshall(rpc_request, "QueueName", basepath);
	hasValue |= m_QueueStatus.unmarshall(rpc_request, "QueueStatus", basepath);
	hasValue |= m_JobsRunning.unmarshall(rpc_request, "JobsRunning", basepath);
	hasValue |= m_JobsInQueue.unmarshall(rpc_request, "JobsInQueue", basepath);
	hasValue |= m_QueueStatus2.unmarshall(rpc_request, "QueueStatus2", basepath);
	hasValue |= m_ClusterSize.unmarshall(rpc_request, "ClusterSize", basepath);
	return hasValue;
}

bool CRoxieCluster::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_ClusterName.unmarshall(ctx, soapval, "ClusterName");
	hasValue |= m_QueueName.unmarshall(ctx, soapval, "QueueName");
	hasValue |= m_QueueStatus.unmarshall(ctx, soapval, "QueueStatus");
	hasValue |= m_JobsRunning.unmarshall(ctx, soapval, "JobsRunning");
	hasValue |= m_JobsInQueue.unmarshall(ctx, soapval, "JobsInQueue");
	hasValue |= m_QueueStatus2.unmarshall(ctx, soapval, "QueueStatus2");
	hasValue |= m_ClusterSize.unmarshall(ctx, soapval, "ClusterSize");
	return hasValue;
}

bool CRoxieCluster::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_ClusterName.unmarshall(ctx, params, attachments, "ClusterName", basepath);
	hasValue |= m_QueueName.unmarshall(ctx, params, attachments, "QueueName", basepath);
	hasValue |= m_QueueStatus.unmarshall(ctx, params, attachments, "QueueStatus", basepath);
	hasValue |= m_JobsRunning.unmarshall(ctx, params, attachments, "JobsRunning", basepath);
	hasValue |= m_JobsInQueue.unmarshall(ctx, params, attachments, "JobsInQueue", basepath);
	hasValue |= m_QueueStatus2.unmarshall(ctx, params, attachments, "QueueStatus2", basepath);
	hasValue |= m_ClusterSize.unmarshall(ctx, params, attachments, "ClusterSize", basepath);
	return hasValue;
}

const char * CRoxieCluster::getClusterName() { return m_ClusterName.query();}
const char * CRoxieCluster::getQueueName() { return m_QueueName.query();}
const char * CRoxieCluster::getQueueStatus() { return m_QueueStatus.query();}
int CRoxieCluster::getJobsRunning() { return m_JobsRunning;}
int CRoxieCluster::getJobsInQueue() { return m_JobsInQueue;}
int CRoxieCluster::getQueueStatus2() { return m_QueueStatus2;}
int CRoxieCluster::getClusterSize() { return m_ClusterSize;}
void CRoxieCluster::setClusterName(const char * val){ m_ClusterName.set(val); }
void CRoxieCluster::setQueueName(const char * val){ m_QueueName.set(val); }
void CRoxieCluster::setQueueStatus(const char * val){ m_QueueStatus.set(val); }
void CRoxieCluster::setJobsRunning(int val){ m_JobsRunning=val; }
void CRoxieCluster::setJobsInQueue(int val){ m_JobsInQueue=val; }
void CRoxieCluster::setQueueStatus2(int val){ m_QueueStatus2=val; }
void CRoxieCluster::setClusterSize(int val){ m_ClusterSize=val; }
extern "C"  IEspRoxieCluster *createRoxieCluster(const char *serv, const char *msgname){return ((IEspRoxieCluster *)new CRoxieCluster(serv /*, msgname*/));}
extern "C"  IClientRoxieCluster *createClientRoxieCluster(const char *serv, const char *msgname){return ((IClientRoxieCluster *)new CRoxieCluster(serv /*, msgname*/));}

//=======================================================
// class CDFUJob Implementation
//=======================================================

CDFUJob::CDFUJob(const char *serviceName, IRpcMessageBinding *init)
	: m_TimeStarted(nilIgnore),m_Done(nilIgnore),m_Total(nilIgnore),m_Command(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("DFUJob");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CDFUJob::CDFUJob(const char *serviceName, const char *bc)
	: m_TimeStarted(nilIgnore),m_Done(nilIgnore),m_Total(nilIgnore),m_Command(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("DFUJob");
}

StringBuffer &CDFUJob::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:complexType name=\"%s\">\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"TimeStarted\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Done\" type=\"xsd:int\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Total\" type=\"xsd:int\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Command\" type=\"xsd:string\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType>\n");
		}
	}
	return schema;
}

void CDFUJob::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CDFUJob::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CDFUJob::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("TimeStarted");
	form.appendf("  <tr><td><b>TimeStarted: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix) extfix.append(prefix).append(".");
		extfix.append("Done");
	form.appendf("  <tr><td><b>Done: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix) extfix.append(prefix).append(".");
		extfix.append("Total");
	form.appendf("  <tr><td><b>Total: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Command");
	form.appendf("  <tr><td><b>Command: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CDFUJob::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CDFUJob::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_TimeStarted.marshall(rpc_resp, "TimeStarted", "", "", "");
	m_Done.marshall(rpc_resp, "Done", "", "", "");
	m_Total.marshall(rpc_resp, "Total", "", "", "");
	m_Command.marshall(rpc_resp, "Command", "", "", "");
}


void CDFUJob::copy(CDFUJob &from)
{
	m_TimeStarted.copy(from.m_TimeStarted);
	m_Done.copy(from.m_Done);
	m_Total.copy(from.m_Total);
	m_Command.copy(from.m_Command);
}


void CDFUJob::copy(IConstDFUJob &ifrom)
{
	setTimeStarted(ifrom.getTimeStarted());
	setDone(ifrom.getDone());
	setTotal(ifrom.getTotal());
	setCommand(ifrom.getCommand());
}


void CDFUJob::getAttributes(IProperties &attributes)
{
}


void CDFUJob::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_TimeStarted.toStr(ctx, buffer, "TimeStarted", "", true, "", "");
	m_Done.toStr(ctx, buffer, "Done", "", true, "", "");
	m_Total.toStr(ctx, buffer, "Total", "", true, "", "");
	m_Command.toStr(ctx, buffer, "Command", "", true, "", "");
}


void CDFUJob::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CDFUJob::serializer(IEspContext* ctx, IConstDFUJob &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<DFUJob>");
	// field TimeStarted
	{
		const char* s = src.getTimeStarted();
		if (s && *s)
		{
			buffer.append("<TimeStarted>");
			encodeUtf8XML(s,buffer);
			buffer.append("</TimeStarted>");
		}
	}
	// field Done
	{
		int n = src.getDone();
		if (n)
			buffer.appendf("<Done>%d</Done>", n);
	}
	// field Total
	{
		int n = src.getTotal();
		if (n)
			buffer.appendf("<Total>%d</Total>", n);
	}
	// field Command
	{
		const char* s = src.getCommand();
		if (s && *s)
		{
			buffer.append("<Command>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Command>");
		}
	}
	if (keepRootTag)
		buffer.append("</DFUJob>");
}

bool CDFUJob::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_TimeStarted.unmarshall(rpc_request, "TimeStarted", basepath);
	hasValue |= m_Done.unmarshall(rpc_request, "Done", basepath);
	hasValue |= m_Total.unmarshall(rpc_request, "Total", basepath);
	hasValue |= m_Command.unmarshall(rpc_request, "Command", basepath);
	return hasValue;
}

bool CDFUJob::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_TimeStarted.unmarshall(ctx, soapval, "TimeStarted");
	hasValue |= m_Done.unmarshall(ctx, soapval, "Done");
	hasValue |= m_Total.unmarshall(ctx, soapval, "Total");
	hasValue |= m_Command.unmarshall(ctx, soapval, "Command");
	return hasValue;
}

bool CDFUJob::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_TimeStarted.unmarshall(ctx, params, attachments, "TimeStarted", basepath);
	hasValue |= m_Done.unmarshall(ctx, params, attachments, "Done", basepath);
	hasValue |= m_Total.unmarshall(ctx, params, attachments, "Total", basepath);
	hasValue |= m_Command.unmarshall(ctx, params, attachments, "Command", basepath);
	return hasValue;
}

const char * CDFUJob::getTimeStarted() { return m_TimeStarted.query();}
int CDFUJob::getDone() { return m_Done;}
int CDFUJob::getTotal() { return m_Total;}
const char * CDFUJob::getCommand() { return m_Command.query();}
void CDFUJob::setTimeStarted(const char * val){ m_TimeStarted.set(val); }
void CDFUJob::setDone(int val){ m_Done=val; }
void CDFUJob::setTotal(int val){ m_Total=val; }
void CDFUJob::setCommand(const char * val){ m_Command.set(val); }
extern "C"  IEspDFUJob *createDFUJob(const char *serv, const char *msgname){return ((IEspDFUJob *)new CDFUJob(serv /*, msgname*/));}
extern "C"  IClientDFUJob *createClientDFUJob(const char *serv, const char *msgname){return ((IClientDFUJob *)new CDFUJob(serv /*, msgname*/));}

//=======================================================
// class CServerJobQueue Implementation
//=======================================================

CServerJobQueue::CServerJobQueue(const char *serviceName, IRpcMessageBinding *init)
	: m_QueueName(nilIgnore),m_QueueNames(nilIgnore),m_Queues(nilIgnore),m_ServerName(nilIgnore),m_ServerType(nilIgnore),m_QueueStatus(nilIgnore),m_StatusDetails(nilIgnore),m_NetworkAddress(nilIgnore),m_Port(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ServerJobQueue");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CServerJobQueue::CServerJobQueue(const char *serviceName, const char *bc)
	: m_QueueName(nilIgnore),m_QueueNames(nilIgnore),m_Queues(nilIgnore),m_ServerName(nilIgnore),m_ServerType(nilIgnore),m_QueueStatus(nilIgnore),m_StatusDetails(nilIgnore),m_NetworkAddress(nilIgnore),m_Port(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ServerJobQueue");
}

StringBuffer &CServerJobQueue::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:complexType name=\"%s\">\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"QueueName\" type=\"xsd:string\"/>\n");
		if (!context.suppressed("ServerJobQueue","QueueNames")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"QueueNames\">");
			schema.append("<xsd:complexType><xsd:sequence>");
			schema.append("<xsd:element name=\"QueueName\" type=\"xsd:string\" minOccurs=\"0\" maxOccurs=\"unbounded\"/>\n");
			schema.append("</xsd:sequence></xsd:complexType>\n");
			schema.append("</xsd:element>\n");
		}
		if (!context.suppressed("ServerJobQueue","Queues")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"Queues\" type=\"tns:ArrayOfServerJobQueue\"/>\n");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"ServerName\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"ServerType\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"QueueStatus\" type=\"xsd:string\"/>\n");
		if (!context.suppressed("ServerJobQueue","StatusDetails")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"StatusDetails\" type=\"xsd:string\"/>\n");
		}
		if (!context.suppressed("ServerJobQueue","NetworkAddress")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"NetworkAddress\" type=\"xsd:string\"/>\n");
		}
		if (!context.suppressed("ServerJobQueue","Port")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"Port\" type=\"xsd:int\"/>\n");
		}
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType>\n");
		}
	}
	if (added.getValue("ServerJobQueue") && added.getValue("ArrayOfServerJobQueue")==NULL) {
		schema.append("<xsd:complexType name=\"ArrayOfServerJobQueue\">\n");
		schema.append("<xsd:sequence>\n");
		schema.append("<xsd:element minOccurs=\"0\" maxOccurs=\"unbounded\" name=\"ServerJobQueue\" type=\"tns:ServerJobQueue\"/>\n");
		schema.append("</xsd:sequence>\n");
		schema.append("</xsd:complexType>\n");
		added.setValue("ArrayOfServerJobQueue",1);
	}
	return schema;
}

void CServerJobQueue::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CServerJobQueue::getMapInfo(IMapInfo& info, BoolHash& added)
{
	info.addMinVersion("ServerJobQueue","QueueNames",1.2);
	info.addDeprVersion("ServerJobQueue","QueueNames",1.21);
	info.addMinVersion("ServerJobQueue","Queues",1.21);
	info.addMinVersion("ServerJobQueue","StatusDetails",1.17);
	info.addMinVersion("ServerJobQueue","NetworkAddress",1.19);
	info.addMinVersion("ServerJobQueue","Port",1.19);
}

StringBuffer &CServerJobQueue::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("QueueName");
	form.appendf("  <tr><td><b>QueueName: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (!context.suppressed("ServerJobQueue","QueueNames")) {
		extfix.clear();
		if (prefix && *prefix)
			extfix.append(prefix).append(".");
		extfix.append("QueueNames");
		form.appendf("<tr><td><b>QueueNames: </b></td><td>");
		form.appendf("<textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea>", extfix.str());
		form.append("</td></tr>");
	}
	if (!context.suppressed("ServerJobQueue","Queues")) {
		extfix.clear();
		if (prefix && *prefix)
			extfix.append(prefix).append(".");
		extfix.append("Queues");
		form.appendf("<tr><td><b>Queues: </b></td><td>");
		form.appendf("<table><tr><td><textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea></td>", extfix.str());
		form.append("</tr></table>");
		form.append("</td></tr>");
	}
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("ServerName");
	form.appendf("  <tr><td><b>ServerName: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("ServerType");
	form.appendf("  <tr><td><b>ServerType: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("QueueStatus");
	form.appendf("  <tr><td><b>QueueStatus: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (!context.suppressed("ServerJobQueue","StatusDetails")) {
		extfix.clear();
		if (prefix && *prefix)
			extfix.append(prefix).append(".");
		extfix.append("StatusDetails");
		form.appendf("  <tr><td><b>StatusDetails: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
		form.append("</td></tr>\n");
	}
	if (!context.suppressed("ServerJobQueue","NetworkAddress")) {
		extfix.clear();
		if (prefix && *prefix)
			extfix.append(prefix).append(".");
		extfix.append("NetworkAddress");
		form.appendf("  <tr><td><b>NetworkAddress: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
		form.append("</td></tr>\n");
	}
	if (!context.suppressed("ServerJobQueue","Port")) {
		extfix.clear();
		if (prefix && *prefix) extfix.append(prefix).append(".");
			extfix.append("Port");
		form.appendf("  <tr><td><b>Port: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
		form.append("</td></tr>\n");
	}
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CServerJobQueue::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CServerJobQueue::serialize(IRpcMessage& rpc_resp)
{
	IEspContext* ctx = rpc_resp.queryContext();
	double clientVer= ctx ? ctx->getClientVersion() : -1; /* no context gets everything */
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_QueueName.marshall(rpc_resp, "QueueName", "", "", "");
	if ((clientVer==-1.0 || (clientVer>=1.2 && clientVer<1.21)))
		m_QueueNames.marshall(rpc_resp, "QueueNames", "QueueName");
	if ((clientVer==-1.0 || clientVer>=1.21))
		m_Queues.marshall(rpc_resp, "Queues", "ServerJobQueue");
	m_ServerName.marshall(rpc_resp, "ServerName", "", "", "");
	m_ServerType.marshall(rpc_resp, "ServerType", "", "", "");
	m_QueueStatus.marshall(rpc_resp, "QueueStatus", "", "", "");
	if ((clientVer==-1.0 || clientVer>=1.17))
		m_StatusDetails.marshall(rpc_resp, "StatusDetails", "", "", "");
	if ((clientVer==-1.0 || clientVer>=1.19))
		m_NetworkAddress.marshall(rpc_resp, "NetworkAddress", "", "", "");
	if ((clientVer==-1.0 || clientVer>=1.19))
		m_Port.marshall(rpc_resp, "Port", "", "", "");
}


void CServerJobQueue::copy(CServerJobQueue &from)
{
	m_QueueName.copy(from.m_QueueName);
	m_QueueNames.copy(from.m_QueueNames);
	m_Queues.copy(from.m_Queues);
	m_ServerName.copy(from.m_ServerName);
	m_ServerType.copy(from.m_ServerType);
	m_QueueStatus.copy(from.m_QueueStatus);
	m_StatusDetails.copy(from.m_StatusDetails);
	m_NetworkAddress.copy(from.m_NetworkAddress);
	m_Port.copy(from.m_Port);
}


void CServerJobQueue::copy(IConstServerJobQueue &ifrom)
{
	setQueueName(ifrom.getQueueName());
	setQueueNames(ifrom.getQueueNames());
	setQueues(ifrom.getQueues());
	setServerName(ifrom.getServerName());
	setServerType(ifrom.getServerType());
	setQueueStatus(ifrom.getQueueStatus());
	setStatusDetails(ifrom.getStatusDetails());
	setNetworkAddress(ifrom.getNetworkAddress());
	setPort(ifrom.getPort());
}


void CServerJobQueue::getAttributes(IProperties &attributes)
{
}


void CServerJobQueue::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	double clientVer = ctx ? ctx->getClientVersion() : -1;
	m_QueueName.toStr(ctx, buffer, "QueueName", "", true, "", "");
	if ((clientVer==-1.0 || (clientVer>=1.2 && clientVer<1.21)))
		m_QueueNames.toStr(ctx, buffer, "QueueNames", "QueueName");
	if ((clientVer==-1.0 || clientVer>=1.21))
		m_Queues.toStr(ctx, buffer, "Queues", "ServerJobQueue");
	m_ServerName.toStr(ctx, buffer, "ServerName", "", true, "", "");
	m_ServerType.toStr(ctx, buffer, "ServerType", "", true, "", "");
	m_QueueStatus.toStr(ctx, buffer, "QueueStatus", "", true, "", "");
	if ((clientVer==-1.0 || clientVer>=1.17))
		m_StatusDetails.toStr(ctx, buffer, "StatusDetails", "", true, "", "");
	if ((clientVer==-1.0 || clientVer>=1.19))
		m_NetworkAddress.toStr(ctx, buffer, "NetworkAddress", "", true, "", "");
	if ((clientVer==-1.0 || clientVer>=1.19))
		m_Port.toStr(ctx, buffer, "Port", "", true, "", "");
}


void CServerJobQueue::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CServerJobQueue::serializer(IEspContext* ctx, IConstServerJobQueue &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<ServerJobQueue>");
	double clientVer = ctx ? ctx->getClientVersion() : -1;
	// field QueueName
	{
		const char* s = src.getQueueName();
		if (s && *s)
		{
			buffer.append("<QueueName>");
			encodeUtf8XML(s,buffer);
			buffer.append("</QueueName>");
		}
	}
	// field QueueNames
	if ((clientVer==-1.0 || (clientVer>=1.2 && clientVer<1.21)))
	{
		StringArray& v = src.getQueueNames();
		if (v.length()>0)
			buffer.append("<QueueNames>");
		for (size32_t i=0;i<v.length();i++)
			buffer.appendf("<QueueName>%s</QueueName>",v.item(i));
		if (v.length()>0)
			buffer.append("</QueueNames>");
	}
	// field Queues
	if ((clientVer==-1.0 || clientVer>=1.21))
	{
		IArrayOf<IConstServerJobQueue>& v = src.getQueues();
		int size = v.length();
		if (size>0)
			buffer.append("<Queues>");
		for (int i=0;i<size;i++)
		{
			buffer.append("<Item>");
			CServerJobQueue::serializer(ctx,v.item(i),buffer,false);
			buffer.append("</Item>");
		}
		if (size>0)
			buffer.append("</Queues>");
	}
	// field ServerName
	{
		const char* s = src.getServerName();
		if (s && *s)
		{
			buffer.append("<ServerName>");
			encodeUtf8XML(s,buffer);
			buffer.append("</ServerName>");
		}
	}
	// field ServerType
	{
		const char* s = src.getServerType();
		if (s && *s)
		{
			buffer.append("<ServerType>");
			encodeUtf8XML(s,buffer);
			buffer.append("</ServerType>");
		}
	}
	// field QueueStatus
	{
		const char* s = src.getQueueStatus();
		if (s && *s)
		{
			buffer.append("<QueueStatus>");
			encodeUtf8XML(s,buffer);
			buffer.append("</QueueStatus>");
		}
	}
	// field StatusDetails
	if ((clientVer==-1.0 || clientVer>=1.17))
	{
		const char* s = src.getStatusDetails();
		if (s && *s)
		{
			buffer.append("<StatusDetails>");
			encodeUtf8XML(s,buffer);
			buffer.append("</StatusDetails>");
		}
	}
	// field NetworkAddress
	if ((clientVer==-1.0 || clientVer>=1.19))
	{
		const char* s = src.getNetworkAddress();
		if (s && *s)
		{
			buffer.append("<NetworkAddress>");
			encodeUtf8XML(s,buffer);
			buffer.append("</NetworkAddress>");
		}
	}
	// field Port
	if ((clientVer==-1.0 || clientVer>=1.19))
	{
		int n = src.getPort();
		if (n)
			buffer.appendf("<Port>%d</Port>", n);
	}
	if (keepRootTag)
		buffer.append("</ServerJobQueue>");
}

bool CServerJobQueue::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_QueueName.unmarshall(rpc_request, "QueueName", basepath);
	hasValue |= m_QueueNames.unmarshall(rpc_request, "QueueNames", basepath);
	hasValue |= m_Queues.unmarshall(rpc_request, "Queues", basepath);
	hasValue |= m_ServerName.unmarshall(rpc_request, "ServerName", basepath);
	hasValue |= m_ServerType.unmarshall(rpc_request, "ServerType", basepath);
	hasValue |= m_QueueStatus.unmarshall(rpc_request, "QueueStatus", basepath);
	hasValue |= m_StatusDetails.unmarshall(rpc_request, "StatusDetails", basepath);
	hasValue |= m_NetworkAddress.unmarshall(rpc_request, "NetworkAddress", basepath);
	hasValue |= m_Port.unmarshall(rpc_request, "Port", basepath);
	return hasValue;
}

bool CServerJobQueue::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_QueueName.unmarshall(ctx, soapval, "QueueName");
	hasValue |= m_QueueNames.unmarshall(ctx, soapval, "QueueNames");
	hasValue |= m_Queues.unmarshall(ctx, soapval, "Queues");
	hasValue |= m_ServerName.unmarshall(ctx, soapval, "ServerName");
	hasValue |= m_ServerType.unmarshall(ctx, soapval, "ServerType");
	hasValue |= m_QueueStatus.unmarshall(ctx, soapval, "QueueStatus");
	hasValue |= m_StatusDetails.unmarshall(ctx, soapval, "StatusDetails");
	hasValue |= m_NetworkAddress.unmarshall(ctx, soapval, "NetworkAddress");
	hasValue |= m_Port.unmarshall(ctx, soapval, "Port");
	return hasValue;
}

bool CServerJobQueue::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_QueueName.unmarshall(ctx, params, attachments, "QueueName", basepath);
	hasValue |= m_QueueNames.unmarshall(ctx, params, attachments, "QueueNames", basepath);
	hasValue |= m_Queues.unmarshall(ctx, params, attachments, "Queues", basepath);
	hasValue |= m_ServerName.unmarshall(ctx, params, attachments, "ServerName", basepath);
	hasValue |= m_ServerType.unmarshall(ctx, params, attachments, "ServerType", basepath);
	hasValue |= m_QueueStatus.unmarshall(ctx, params, attachments, "QueueStatus", basepath);
	hasValue |= m_StatusDetails.unmarshall(ctx, params, attachments, "StatusDetails", basepath);
	hasValue |= m_NetworkAddress.unmarshall(ctx, params, attachments, "NetworkAddress", basepath);
	hasValue |= m_Port.unmarshall(ctx, params, attachments, "Port", basepath);
	return hasValue;
}

const char * CServerJobQueue::getQueueName() { return m_QueueName.query();}
StringArray & CServerJobQueue::getQueueNames() { return (StringArray &) m_QueueNames; }
IArrayOf<IConstServerJobQueue> & CServerJobQueue::getQueues() { return (IArrayOf<IConstServerJobQueue> &) m_Queues; }
const char * CServerJobQueue::getServerName() { return m_ServerName.query();}
const char * CServerJobQueue::getServerType() { return m_ServerType.query();}
const char * CServerJobQueue::getQueueStatus() { return m_QueueStatus.query();}
const char * CServerJobQueue::getStatusDetails() { return m_StatusDetails.query();}
const char * CServerJobQueue::getNetworkAddress() { return m_NetworkAddress.query();}
int CServerJobQueue::getPort() { return m_Port;}
void CServerJobQueue::setQueueName(const char * val){ m_QueueName.set(val); }
void CServerJobQueue::setQueueNames(StringArray &val){ m_QueueNames->kill();  CloneArray(m_QueueNames.getValue(), val); }
void CServerJobQueue::setQueues(IArrayOf<IEspServerJobQueue> &val)
{
	m_Queues->kill();
	IArrayOf<IConstServerJobQueue> &target = m_Queues.getValue();
	ForEachItemIn(idx, val)
	{
		IEspServerJobQueue &item = (val).item(idx);
		item.Link();
		target.append(item);
	}
}
void CServerJobQueue::setQueues(IArrayOf<IConstServerJobQueue> &val)
{
	m_Queues->kill();
	IArrayOf<IConstServerJobQueue> &target = m_Queues.getValue();
	ForEachItemIn(idx, val)
	{
		IConstServerJobQueue &item = val.item(idx);
		item.Link();
		target.append(item);
	}
}
void CServerJobQueue::setServerName(const char * val){ m_ServerName.set(val); }
void CServerJobQueue::setServerType(const char * val){ m_ServerType.set(val); }
void CServerJobQueue::setQueueStatus(const char * val){ m_QueueStatus.set(val); }
void CServerJobQueue::setStatusDetails(const char * val){ m_StatusDetails.set(val); }
void CServerJobQueue::setNetworkAddress(const char * val){ m_NetworkAddress.set(val); }
void CServerJobQueue::setPort(int val){ m_Port=val; }
extern "C"  IEspServerJobQueue *createServerJobQueue(const char *serv, const char *msgname){return ((IEspServerJobQueue *)new CServerJobQueue(serv /*, msgname*/));}
extern "C"  IClientServerJobQueue *createClientServerJobQueue(const char *serv, const char *msgname){return ((IClientServerJobQueue *)new CServerJobQueue(serv /*, msgname*/));}

//=======================================================
// class CStatusServerInfo Implementation
//=======================================================

CStatusServerInfo::CStatusServerInfo(const char *serviceName, IRpcMessageBinding *init)
	: m_TargetClusterInfo(serviceName, nilRemove),m_ServerInfo(serviceName, nilRemove),m_Workunits(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("StatusServerInfo");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CStatusServerInfo::CStatusServerInfo(const char *serviceName, const char *bc)
	: m_TargetClusterInfo(serviceName, nilRemove),m_ServerInfo(serviceName, nilRemove),m_Workunits(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("StatusServerInfo");
}

StringBuffer &CStatusServerInfo::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:complexType name=\"%s\">\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"TargetClusterInfo\" type=\"tns:TargetCluster\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"ServerInfo\" type=\"tns:ServerJobQueue\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Workunits\" type=\"tns:ArrayOfActiveWorkunit\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType>\n");
		}
	}
	if (!(flags & 0x10)  || (flags & 0x100))
	{
		CTargetCluster::getXsdDefinition(context, request, schema, added);
		CServerJobQueue::getXsdDefinition(context, request, schema, added);
		CActiveWorkunit::getXsdDefinition(context, request, schema, added);
	}
	if (added.getValue("ActiveWorkunit") && added.getValue("ArrayOfActiveWorkunit")==NULL) {
		schema.append("<xsd:complexType name=\"ArrayOfActiveWorkunit\">\n");
		schema.append("<xsd:sequence>\n");
		schema.append("<xsd:element minOccurs=\"0\" maxOccurs=\"unbounded\" name=\"ActiveWorkunit\" type=\"tns:ActiveWorkunit\"/>\n");
		schema.append("</xsd:sequence>\n");
		schema.append("</xsd:complexType>\n");
		added.setValue("ArrayOfActiveWorkunit",1);
	}
	return schema;
}

void CStatusServerInfo::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CStatusServerInfo::getMapInfo(IMapInfo& info, BoolHash& added)
{
	if (!added.getValue("ActiveWorkunit"))
	{
		added.setValue("ActiveWorkunit",1);
		CActiveWorkunit::getMapInfo(info,added);
	}
	if (!added.getValue("ServerJobQueue"))
	{
		added.setValue("ServerJobQueue",1);
		CServerJobQueue::getMapInfo(info,added);
	}
	if (!added.getValue("TargetCluster"))
	{
		added.setValue("TargetCluster",1);
		CTargetCluster::getMapInfo(info,added);
	}
}

StringBuffer &CStatusServerInfo::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("TargetClusterInfo");
	form.append("<tr>").append("<td><b>TargetClusterInfo: </b></td><td><hr/>");
	CTargetCluster::getHtmlForm(context, request, serv, method, form, false, extfix.str());
	form.append("<hr/></td></tr>");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("ServerInfo");
	form.append("<tr>").append("<td><b>ServerInfo: </b></td><td><hr/>");
	CServerJobQueue::getHtmlForm(context, request, serv, method, form, false, extfix.str());
	form.append("<hr/></td></tr>");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Workunits");
	form.appendf("<tr><td><b>Workunits: </b></td><td>");
	form.appendf("<table><tr><td><textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea></td>", extfix.str());
	form.append("</tr></table>");
	form.append("</td></tr>");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CStatusServerInfo::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CStatusServerInfo::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_TargetClusterInfo.marshall(rpc_resp, "TargetClusterInfo", "", "", "");
	m_ServerInfo.marshall(rpc_resp, "ServerInfo", "", "", "");
	m_Workunits.marshall(rpc_resp, "Workunits", "ActiveWorkunit");
}


void CStatusServerInfo::copy(CStatusServerInfo &from)
{
	m_TargetClusterInfo.copy(from.m_TargetClusterInfo);
	m_ServerInfo.copy(from.m_ServerInfo);
	m_Workunits.copy(from.m_Workunits);
}


void CStatusServerInfo::copy(IConstStatusServerInfo &ifrom)
{
	setTargetClusterInfo(ifrom.getTargetClusterInfo());
	setServerInfo(ifrom.getServerInfo());
	setWorkunits(ifrom.getWorkunits());
}


void CStatusServerInfo::getAttributes(IProperties &attributes)
{
}


void CStatusServerInfo::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_TargetClusterInfo.toStr(ctx, buffer, "TargetClusterInfo", "", false, "", "");
	m_ServerInfo.toStr(ctx, buffer, "ServerInfo", "", false, "", "");
	m_Workunits.toStr(ctx, buffer, "Workunits", "ActiveWorkunit");
}


void CStatusServerInfo::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CStatusServerInfo::serializer(IEspContext* ctx, IConstStatusServerInfo &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<StatusServerInfo>");
	// field TargetClusterInfo
	{
		StringBuffer tmp;
		CTargetCluster::serializer(ctx,src.getTargetClusterInfo(), tmp, false);
		if (tmp.length()>0)
			buffer.appendf("<TargetClusterInfo>%s</TargetClusterInfo>",tmp.str());
	}
	// field ServerInfo
	{
		StringBuffer tmp;
		CServerJobQueue::serializer(ctx,src.getServerInfo(), tmp, false);
		if (tmp.length()>0)
			buffer.appendf("<ServerInfo>%s</ServerInfo>",tmp.str());
	}
	// field Workunits
	{
		IArrayOf<IConstActiveWorkunit>& v = src.getWorkunits();
		int size = v.length();
		if (size>0)
			buffer.append("<Workunits>");
		for (int i=0;i<size;i++)
		{
			buffer.append("<Item>");
			CActiveWorkunit::serializer(ctx,v.item(i),buffer,false);
			buffer.append("</Item>");
		}
		if (size>0)
			buffer.append("</Workunits>");
	}
	if (keepRootTag)
		buffer.append("</StatusServerInfo>");
}

bool CStatusServerInfo::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_TargetClusterInfo.unmarshall(rpc_request, "TargetClusterInfo", basepath);
	hasValue |= m_ServerInfo.unmarshall(rpc_request, "ServerInfo", basepath);
	hasValue |= m_Workunits.unmarshall(rpc_request, "Workunits", basepath);
	return hasValue;
}

bool CStatusServerInfo::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_TargetClusterInfo.unmarshall(ctx, soapval, "TargetClusterInfo");
	hasValue |= m_ServerInfo.unmarshall(ctx, soapval, "ServerInfo");
	hasValue |= m_Workunits.unmarshall(ctx, soapval, "Workunits");
	return hasValue;
}

bool CStatusServerInfo::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_TargetClusterInfo.unmarshall(ctx, params, attachments, "TargetClusterInfo", basepath);
	hasValue |= m_ServerInfo.unmarshall(ctx, params, attachments, "ServerInfo", basepath);
	hasValue |= m_Workunits.unmarshall(ctx, params, attachments, "Workunits", basepath);
	return hasValue;
}

IConstTargetCluster & CStatusServerInfo::getTargetClusterInfo() { return (IConstTargetCluster &) m_TargetClusterInfo.getValue();}
IConstServerJobQueue & CStatusServerInfo::getServerInfo() { return (IConstServerJobQueue &) m_ServerInfo.getValue();}
IArrayOf<IConstActiveWorkunit> & CStatusServerInfo::getWorkunits() { return (IArrayOf<IConstActiveWorkunit> &) m_Workunits; }
IEspTargetCluster & CStatusServerInfo::updateTargetClusterInfo(){ return (IEspTargetCluster &) m_TargetClusterInfo.getValue(); }
void CStatusServerInfo::setTargetClusterInfo(IConstTargetCluster &ifrom){ m_TargetClusterInfo.copy(ifrom); }
IEspServerJobQueue & CStatusServerInfo::updateServerInfo(){ return (IEspServerJobQueue &) m_ServerInfo.getValue(); }
void CStatusServerInfo::setServerInfo(IConstServerJobQueue &ifrom){ m_ServerInfo.copy(ifrom); }
void CStatusServerInfo::setWorkunits(IArrayOf<IEspActiveWorkunit> &val)
{
	m_Workunits->kill();
	IArrayOf<IConstActiveWorkunit> &target = m_Workunits.getValue();
	ForEachItemIn(idx, val)
	{
		IEspActiveWorkunit &item = (val).item(idx);
		item.Link();
		target.append(item);
	}
}
void CStatusServerInfo::setWorkunits(IArrayOf<IConstActiveWorkunit> &val)
{
	m_Workunits->kill();
	IArrayOf<IConstActiveWorkunit> &target = m_Workunits.getValue();
	ForEachItemIn(idx, val)
	{
		IConstActiveWorkunit &item = val.item(idx);
		item.Link();
		target.append(item);
	}
}
extern "C"  IEspStatusServerInfo *createStatusServerInfo(const char *serv, const char *msgname){return ((IEspStatusServerInfo *)new CStatusServerInfo(serv /*, msgname*/));}
extern "C"  IClientStatusServerInfo *createClientStatusServerInfo(const char *serv, const char *msgname){return ((IClientStatusServerInfo *)new CStatusServerInfo(serv /*, msgname*/));}

//=======================================================
// class CActivityRequest Implementation
//=======================================================

CActivityRequest::CActivityRequest(const char *serviceName, IRpcMessageBinding *init)
	: m_ChatURL(nilRemove),m_BannerContent(nilRemove),m_BannerColor(nilRemove),m_BannerSize(nilRemove),m_BannerScroll(nilRemove),m_BannerAction(0, nilRemove,false),m_EnableChatURL(nilRemove),m_FromSubmitBtn(0, nilRemove,false),m_SortBy(nilRemove),m_Descending(0, nilRemove,false)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ActivityRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CActivityRequest::CActivityRequest(const char *serviceName, const char *bc)
	: m_ChatURL(nilRemove),m_BannerContent(nilRemove),m_BannerColor(nilRemove),m_BannerSize(nilRemove),m_BannerScroll(nilRemove),m_BannerAction(0, nilRemove,false),m_EnableChatURL(nilRemove),m_FromSubmitBtn(0, nilRemove,false),m_SortBy(nilRemove),m_Descending(0, nilRemove,false)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ActivityRequest");
}

CActivityRequest::CActivityRequest(const char *serviceName, IRpcMessage* rpcmsg)
	: m_ChatURL(nilRemove),m_BannerContent(nilRemove),m_BannerColor(nilRemove),m_BannerSize(nilRemove),m_BannerScroll(nilRemove),m_BannerAction(0, nilRemove,false),m_EnableChatURL(nilRemove),m_FromSubmitBtn(0, nilRemove,false),m_SortBy(nilRemove),m_Descending(0, nilRemove,false)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ActivityRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CActivityRequest::CActivityRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_ChatURL(nilRemove),m_BannerContent(nilRemove),m_BannerColor(nilRemove),m_BannerSize(nilRemove),m_BannerScroll(nilRemove),m_BannerAction(0, nilRemove,false),m_EnableChatURL(nilRemove),m_FromSubmitBtn(0, nilRemove,false),m_SortBy(nilRemove),m_Descending(0, nilRemove,false)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ActivityRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CActivityRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"ChatURL\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"BannerContent\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"BannerColor\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"BannerSize\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"BannerScroll\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"BannerAction\" type=\"xsd:int\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"EnableChatURL\" type=\"xsd:boolean\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" default=\"false\" name=\"FromSubmitBtn\" type=\"xsd:boolean\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"SortBy\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" default=\"false\" name=\"Descending\" type=\"xsd:boolean\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CActivityRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CActivityRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CActivityRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("ChatURL");
	form.appendf("  <tr><td><b>ChatURL: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("BannerContent");
	form.appendf("  <tr><td><b>BannerContent: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("BannerColor");
	form.appendf("  <tr><td><b>BannerColor: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("BannerSize");
	form.appendf("  <tr><td><b>BannerSize: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("BannerScroll");
	form.appendf("  <tr><td><b>BannerScroll: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix) extfix.append(prefix).append(".");
		extfix.append("BannerAction");
	form.appendf("  <tr><td><b>BannerAction: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("EnableChatURL");
	
	form.appendf("  <tr><td><b>EnableChatURL? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("FromSubmitBtn");
	
	form.appendf("  <tr><td><b>FromSubmitBtn? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("SortBy");
	form.appendf("  <tr><td><b>SortBy: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Descending");
	
	form.appendf("  <tr><td><b>Descending? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CActivityRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CActivityRequest::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_ChatURL.marshall(rpc_resp, "ChatURL", "", "", "");
	m_BannerContent.marshall(rpc_resp, "BannerContent", "", "", "");
	m_BannerColor.marshall(rpc_resp, "BannerColor", "", "", "");
	m_BannerSize.marshall(rpc_resp, "BannerSize", "", "", "");
	m_BannerScroll.marshall(rpc_resp, "BannerScroll", "", "", "");
	m_BannerAction.marshall(rpc_resp, "BannerAction", "", "", "");
	m_EnableChatURL.marshall(rpc_resp, "EnableChatURL", "", "", "");
	m_FromSubmitBtn.marshall(rpc_resp, "FromSubmitBtn", "", "", "");
	m_SortBy.marshall(rpc_resp, "SortBy", "", "", "");
	m_Descending.marshall(rpc_resp, "Descending", "", "", "");
}


void CActivityRequest::copy(CActivityRequest &from)
{
	m_ChatURL.copy(from.m_ChatURL);
	m_BannerContent.copy(from.m_BannerContent);
	m_BannerColor.copy(from.m_BannerColor);
	m_BannerSize.copy(from.m_BannerSize);
	m_BannerScroll.copy(from.m_BannerScroll);
	m_BannerAction.copy(from.m_BannerAction);
	m_EnableChatURL.copy(from.m_EnableChatURL);
	m_FromSubmitBtn.copy(from.m_FromSubmitBtn);
	m_SortBy.copy(from.m_SortBy);
	m_Descending.copy(from.m_Descending);
}


void CActivityRequest::copy(IConstActivityRequest &ifrom)
{
	setChatURL(ifrom.getChatURL());
	setBannerContent(ifrom.getBannerContent());
	setBannerColor(ifrom.getBannerColor());
	setBannerSize(ifrom.getBannerSize());
	setBannerScroll(ifrom.getBannerScroll());
	setBannerAction(ifrom.getBannerAction());
	setEnableChatURL(ifrom.getEnableChatURL());
	setFromSubmitBtn(ifrom.getFromSubmitBtn());
	setSortBy(ifrom.getSortBy());
	setDescending(ifrom.getDescending());
}


void CActivityRequest::getAttributes(IProperties &attributes)
{
}


void CActivityRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_ChatURL.toStr(ctx, buffer, "ChatURL", "", true, "", "");
	m_BannerContent.toStr(ctx, buffer, "BannerContent", "", true, "", "");
	m_BannerColor.toStr(ctx, buffer, "BannerColor", "", true, "", "");
	m_BannerSize.toStr(ctx, buffer, "BannerSize", "", true, "", "");
	m_BannerScroll.toStr(ctx, buffer, "BannerScroll", "", true, "", "");
	m_BannerAction.toStr(ctx, buffer, "BannerAction", "", true, "", "");
	m_EnableChatURL.toStr(ctx, buffer, "EnableChatURL", "", true, "", "");
	m_FromSubmitBtn.toStr(ctx, buffer, "FromSubmitBtn", "", true, "", "");
	m_SortBy.toStr(ctx, buffer, "SortBy", "", true, "", "");
	m_Descending.toStr(ctx, buffer, "Descending", "", true, "", "");
}


void CActivityRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CActivityRequest::serializer(IEspContext* ctx, IConstActivityRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<ActivityRequest>");
	// field ChatURL
	{
		const char* s = src.getChatURL();
		if (s && *s)
		{
			buffer.append("<ChatURL>");
			encodeUtf8XML(s,buffer);
			buffer.append("</ChatURL>");
		}
	}
	// field BannerContent
	{
		const char* s = src.getBannerContent();
		if (s && *s)
		{
			buffer.append("<BannerContent>");
			encodeUtf8XML(s,buffer);
			buffer.append("</BannerContent>");
		}
	}
	// field BannerColor
	{
		const char* s = src.getBannerColor();
		if (s && *s)
		{
			buffer.append("<BannerColor>");
			encodeUtf8XML(s,buffer);
			buffer.append("</BannerColor>");
		}
	}
	// field BannerSize
	{
		const char* s = src.getBannerSize();
		if (s && *s)
		{
			buffer.append("<BannerSize>");
			encodeUtf8XML(s,buffer);
			buffer.append("</BannerSize>");
		}
	}
	// field BannerScroll
	{
		const char* s = src.getBannerScroll();
		if (s && *s)
		{
			buffer.append("<BannerScroll>");
			encodeUtf8XML(s,buffer);
			buffer.append("</BannerScroll>");
		}
	}
	// field BannerAction
	{
		int n = src.getBannerAction();
		if (n)
			buffer.appendf("<BannerAction>%d</BannerAction>", n);
	}
	// field EnableChatURL
	{
		bool b = src.getEnableChatURL();
		if (b)
			buffer.appendf("<EnableChatURL>1</EnableChatURL>");
	}
	// field FromSubmitBtn
	{
		bool b = src.getFromSubmitBtn();
		if (b)
			buffer.appendf("<FromSubmitBtn>1</FromSubmitBtn>");
	}
	// field SortBy
	{
		const char* s = src.getSortBy();
		if (s && *s)
		{
			buffer.append("<SortBy>");
			encodeUtf8XML(s,buffer);
			buffer.append("</SortBy>");
		}
	}
	// field Descending
	{
		bool b = src.getDescending();
		if (b)
			buffer.appendf("<Descending>1</Descending>");
	}
	if (keepRootTag)
		buffer.append("</ActivityRequest>");
}

bool CActivityRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_ChatURL.unmarshall(rpc_request, "ChatURL", basepath);
	hasValue |= m_BannerContent.unmarshall(rpc_request, "BannerContent", basepath);
	hasValue |= m_BannerColor.unmarshall(rpc_request, "BannerColor", basepath);
	hasValue |= m_BannerSize.unmarshall(rpc_request, "BannerSize", basepath);
	hasValue |= m_BannerScroll.unmarshall(rpc_request, "BannerScroll", basepath);
	hasValue |= m_BannerAction.unmarshall(rpc_request, "BannerAction", basepath);
	hasValue |= m_EnableChatURL.unmarshall(rpc_request, "EnableChatURL", basepath);
	hasValue |= m_FromSubmitBtn.unmarshall(rpc_request, "FromSubmitBtn", basepath);
	hasValue |= m_SortBy.unmarshall(rpc_request, "SortBy", basepath);
	hasValue |= m_Descending.unmarshall(rpc_request, "Descending", basepath);
	return hasValue;
}

bool CActivityRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_ChatURL.unmarshall(ctx, soapval, "ChatURL");
	hasValue |= m_BannerContent.unmarshall(ctx, soapval, "BannerContent");
	hasValue |= m_BannerColor.unmarshall(ctx, soapval, "BannerColor");
	hasValue |= m_BannerSize.unmarshall(ctx, soapval, "BannerSize");
	hasValue |= m_BannerScroll.unmarshall(ctx, soapval, "BannerScroll");
	hasValue |= m_BannerAction.unmarshall(ctx, soapval, "BannerAction");
	hasValue |= m_EnableChatURL.unmarshall(ctx, soapval, "EnableChatURL");
	hasValue |= m_FromSubmitBtn.unmarshall(ctx, soapval, "FromSubmitBtn");
	hasValue |= m_SortBy.unmarshall(ctx, soapval, "SortBy");
	hasValue |= m_Descending.unmarshall(ctx, soapval, "Descending");
	return hasValue;
}

bool CActivityRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_ChatURL.unmarshall(ctx, params, attachments, "ChatURL", basepath);
	hasValue |= m_BannerContent.unmarshall(ctx, params, attachments, "BannerContent", basepath);
	hasValue |= m_BannerColor.unmarshall(ctx, params, attachments, "BannerColor", basepath);
	hasValue |= m_BannerSize.unmarshall(ctx, params, attachments, "BannerSize", basepath);
	hasValue |= m_BannerScroll.unmarshall(ctx, params, attachments, "BannerScroll", basepath);
	hasValue |= m_BannerAction.unmarshall(ctx, params, attachments, "BannerAction", basepath);
	hasValue |= m_EnableChatURL.unmarshall(ctx, params, attachments, "EnableChatURL", basepath);
	hasValue |= m_FromSubmitBtn.unmarshall(ctx, params, attachments, "FromSubmitBtn", basepath);
	hasValue |= m_SortBy.unmarshall(ctx, params, attachments, "SortBy", basepath);
	hasValue |= m_Descending.unmarshall(ctx, params, attachments, "Descending", basepath);
	return hasValue;
}

const char * CActivityRequest::getChatURL() { return m_ChatURL.query();}
const char * CActivityRequest::getBannerContent() { return m_BannerContent.query();}
const char * CActivityRequest::getBannerColor() { return m_BannerColor.query();}
const char * CActivityRequest::getBannerSize() { return m_BannerSize.query();}
const char * CActivityRequest::getBannerScroll() { return m_BannerScroll.query();}
bool CActivityRequest::getBannerAction_isNull(){return m_BannerAction.is_nil();}
int CActivityRequest::getBannerAction() { return m_BannerAction;}
bool CActivityRequest::getEnableChatURL_isNull(){return m_EnableChatURL.is_nil();}
bool CActivityRequest::getEnableChatURL() { return m_EnableChatURL;}
bool CActivityRequest::getFromSubmitBtn_isNull(){return m_FromSubmitBtn.is_nil();}
bool CActivityRequest::getFromSubmitBtn() { return m_FromSubmitBtn;}
const char * CActivityRequest::getSortBy() { return m_SortBy.query();}
bool CActivityRequest::getDescending_isNull(){return m_Descending.is_nil();}
bool CActivityRequest::getDescending() { return m_Descending;}
void CActivityRequest::setChatURL(const char * val){ m_ChatURL.set(val); }
void CActivityRequest::setBannerContent(const char * val){ m_BannerContent.set(val); }
void CActivityRequest::setBannerColor(const char * val){ m_BannerColor.set(val); }
void CActivityRequest::setBannerSize(const char * val){ m_BannerSize.set(val); }
void CActivityRequest::setBannerScroll(const char * val){ m_BannerScroll.set(val); }
void CActivityRequest::setBannerAction_null(){ m_BannerAction.Nil(); }void CActivityRequest::setBannerAction(int val){ m_BannerAction=val; }
void CActivityRequest::setEnableChatURL_null(){ m_EnableChatURL.Nil(); }void CActivityRequest::setEnableChatURL(bool val){ m_EnableChatURL=val; }
void CActivityRequest::setFromSubmitBtn_null(){ m_FromSubmitBtn.Nil(); }void CActivityRequest::setFromSubmitBtn(bool val){ m_FromSubmitBtn=val; }
void CActivityRequest::setSortBy(const char * val){ m_SortBy.set(val); }
void CActivityRequest::setDescending_null(){ m_Descending.Nil(); }void CActivityRequest::setDescending(bool val){ m_Descending=val; }
extern "C"  IEspActivityRequest *createActivityRequest(const char *serv){return ((IEspActivityRequest *)new CActivityRequest(serv));}
extern "C"  IClientActivityRequest *createClientActivityRequest(const char *serv){return ((IClientActivityRequest *)new CActivityRequest(serv));}

//=======================================================
// class CActivityResponse Implementation
//=======================================================

CActivityResponse::CActivityResponse(const char *serviceName, IRpcMessageBinding *init)
	: m_Build(nilIgnore),m_ThorClusters(nilIgnore),m_RoxieClusters(nilIgnore),m_HThorClusters(nilIgnore),m_ThorClusterList(nilIgnore),m_RoxieClusterList(nilIgnore),m_HThorClusterList(nilIgnore),m_DFUJobs(nilIgnore),m_Running(nilIgnore),m_BannerContent(nilIgnore),m_BannerColor(nilIgnore),m_BannerSize(nilIgnore),m_BannerScroll(nilIgnore),m_ChatURL(nilIgnore),m_ShowBanner(0, nilIgnore,false),m_ShowChatURL(0, nilIgnore,false),m_SortBy(nilIgnore),m_Descending(0, nilIgnore,false),m_SuperUser(0, nilIgnore,false),m_AccessRight(nilIgnore),m_ServerJobQueues(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ActivityResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CActivityResponse::CActivityResponse(const char *serviceName, const char *bc)
	: m_Build(nilIgnore),m_ThorClusters(nilIgnore),m_RoxieClusters(nilIgnore),m_HThorClusters(nilIgnore),m_ThorClusterList(nilIgnore),m_RoxieClusterList(nilIgnore),m_HThorClusterList(nilIgnore),m_DFUJobs(nilIgnore),m_Running(nilIgnore),m_BannerContent(nilIgnore),m_BannerColor(nilIgnore),m_BannerSize(nilIgnore),m_BannerScroll(nilIgnore),m_ChatURL(nilIgnore),m_ShowBanner(0, nilIgnore,false),m_ShowChatURL(0, nilIgnore,false),m_SortBy(nilIgnore),m_Descending(0, nilIgnore,false),m_SuperUser(0, nilIgnore,false),m_AccessRight(nilIgnore),m_ServerJobQueues(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ActivityResponse");
}

CActivityResponse::CActivityResponse(const char *serviceName, IRpcMessage* rpcmsg)
	: m_Build(nilIgnore),m_ThorClusters(nilIgnore),m_RoxieClusters(nilIgnore),m_HThorClusters(nilIgnore),m_ThorClusterList(nilIgnore),m_RoxieClusterList(nilIgnore),m_HThorClusterList(nilIgnore),m_DFUJobs(nilIgnore),m_Running(nilIgnore),m_BannerContent(nilIgnore),m_BannerColor(nilIgnore),m_BannerSize(nilIgnore),m_BannerScroll(nilIgnore),m_ChatURL(nilIgnore),m_ShowBanner(0, nilIgnore,false),m_ShowChatURL(0, nilIgnore,false),m_SortBy(nilIgnore),m_Descending(0, nilIgnore,false),m_SuperUser(0, nilIgnore,false),m_AccessRight(nilIgnore),m_ServerJobQueues(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ActivityResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CActivityResponse::CActivityResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_Build(nilIgnore),m_ThorClusters(nilIgnore),m_RoxieClusters(nilIgnore),m_HThorClusters(nilIgnore),m_ThorClusterList(nilIgnore),m_RoxieClusterList(nilIgnore),m_HThorClusterList(nilIgnore),m_DFUJobs(nilIgnore),m_Running(nilIgnore),m_BannerContent(nilIgnore),m_BannerColor(nilIgnore),m_BannerSize(nilIgnore),m_BannerScroll(nilIgnore),m_ChatURL(nilIgnore),m_ShowBanner(0, nilIgnore,false),m_ShowChatURL(0, nilIgnore,false),m_SortBy(nilIgnore),m_Descending(0, nilIgnore,false),m_SuperUser(0, nilIgnore,false),m_AccessRight(nilIgnore),m_ServerJobQueues(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ActivityResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CActivityResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		schema.append("<xsd:element name=\"Exceptions\" type=\"tns:ArrayOfEspException\" minOccurs=\"0\" maxOccurs=\"1\"/>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Build\" type=\"xsd:string\"/>\n");
		if (!context.suppressed("ActivityResponse","ThorClusters")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"ThorClusters\" type=\"tns:ArrayOfThorCluster\"/>\n");
		}
		if (!context.suppressed("ActivityResponse","RoxieClusters")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"RoxieClusters\" type=\"tns:ArrayOfRoxieCluster\"/>\n");
		}
		if (!context.suppressed("ActivityResponse","HThorClusters")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"HThorClusters\" type=\"tns:ArrayOfHThorCluster\"/>\n");
		}
		if (!context.suppressed("ActivityResponse","ThorClusterList")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"ThorClusterList\" type=\"tns:ArrayOfTargetCluster\"/>\n");
		}
		if (!context.suppressed("ActivityResponse","RoxieClusterList")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"RoxieClusterList\" type=\"tns:ArrayOfTargetCluster\"/>\n");
		}
		if (!context.suppressed("ActivityResponse","HThorClusterList")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"HThorClusterList\" type=\"tns:ArrayOfTargetCluster\"/>\n");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"DFUJobs\" type=\"tns:ArrayOfDFUJob\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Running\" type=\"tns:ArrayOfActiveWorkunit\"/>\n");
		if (!context.suppressed("ActivityResponse","BannerContent")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"BannerContent\" type=\"xsd:string\"/>\n");
		}
		if (!context.suppressed("ActivityResponse","BannerColor")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"BannerColor\" type=\"xsd:string\"/>\n");
		}
		if (!context.suppressed("ActivityResponse","BannerSize")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"BannerSize\" type=\"xsd:string\"/>\n");
		}
		if (!context.suppressed("ActivityResponse","BannerScroll")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"BannerScroll\" type=\"xsd:string\"/>\n");
		}
		if (!context.suppressed("ActivityResponse","ChatURL")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"ChatURL\" type=\"xsd:string\"/>\n");
		}
		if (!context.suppressed("ActivityResponse","ShowBanner")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"ShowBanner\" type=\"xsd:int\"/>\n");
		}
		if (!context.suppressed("ActivityResponse","ShowChatURL")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"ShowChatURL\" type=\"xsd:int\"/>\n");
		}
		if (!context.suppressed("ActivityResponse","SortBy")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"SortBy\" type=\"xsd:string\"/>\n");
		}
		if (!context.suppressed("ActivityResponse","Descending")) {
			schema.append("<xsd:element minOccurs=\"0\" default=\"false\" name=\"Descending\" type=\"xsd:boolean\"/>\n");
		}
		if (!context.suppressed("ActivityResponse","SuperUser")) {
			schema.append("<xsd:element minOccurs=\"0\" default=\"false\" name=\"SuperUser\" type=\"xsd:boolean\"/>\n");
		}
		if (!context.suppressed("ActivityResponse","AccessRight")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"AccessRight\" type=\"xsd:string\"/>\n");
		}
		if (!context.suppressed("ActivityResponse","ServerJobQueues")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"ServerJobQueues\" type=\"tns:ArrayOfServerJobQueue\"/>\n");
		}
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	if (!(flags & 0x10)  || (flags & 0x100))
	{
		if (!context.suppressed("ActivityResponse","ThorClusters"))
			CThorCluster::getXsdDefinition(context, request, schema, added);
		if (!context.suppressed("ActivityResponse","RoxieClusters"))
			CRoxieCluster::getXsdDefinition(context, request, schema, added);
		if (!context.suppressed("ActivityResponse","HThorClusters"))
			CHThorCluster::getXsdDefinition(context, request, schema, added);
		if (!context.suppressed("ActivityResponse","ThorClusterList"))
			CTargetCluster::getXsdDefinition(context, request, schema, added);
		if (!context.suppressed("ActivityResponse","RoxieClusterList"))
			CTargetCluster::getXsdDefinition(context, request, schema, added);
		if (!context.suppressed("ActivityResponse","HThorClusterList"))
			CTargetCluster::getXsdDefinition(context, request, schema, added);
		CDFUJob::getXsdDefinition(context, request, schema, added);
		CActiveWorkunit::getXsdDefinition(context, request, schema, added);
		if (!context.suppressed("ActivityResponse","ServerJobQueues"))
			CServerJobQueue::getXsdDefinition(context, request, schema, added);
	}
	if (added.getValue("ActiveWorkunit") && added.getValue("ArrayOfActiveWorkunit")==NULL) {
		schema.append("<xsd:complexType name=\"ArrayOfActiveWorkunit\">\n");
		schema.append("<xsd:sequence>\n");
		schema.append("<xsd:element minOccurs=\"0\" maxOccurs=\"unbounded\" name=\"ActiveWorkunit\" type=\"tns:ActiveWorkunit\"/>\n");
		schema.append("</xsd:sequence>\n");
		schema.append("</xsd:complexType>\n");
		added.setValue("ArrayOfActiveWorkunit",1);
	}
	if (added.getValue("DFUJob") && added.getValue("ArrayOfDFUJob")==NULL) {
		schema.append("<xsd:complexType name=\"ArrayOfDFUJob\">\n");
		schema.append("<xsd:sequence>\n");
		schema.append("<xsd:element minOccurs=\"0\" maxOccurs=\"unbounded\" name=\"DFUJob\" type=\"tns:DFUJob\"/>\n");
		schema.append("</xsd:sequence>\n");
		schema.append("</xsd:complexType>\n");
		added.setValue("ArrayOfDFUJob",1);
	}
	if (added.getValue("HThorCluster") && added.getValue("ArrayOfHThorCluster")==NULL) {
		schema.append("<xsd:complexType name=\"ArrayOfHThorCluster\">\n");
		schema.append("<xsd:sequence>\n");
		schema.append("<xsd:element minOccurs=\"0\" maxOccurs=\"unbounded\" name=\"HThorCluster\" type=\"tns:HThorCluster\"/>\n");
		schema.append("</xsd:sequence>\n");
		schema.append("</xsd:complexType>\n");
		added.setValue("ArrayOfHThorCluster",1);
	}
	if (added.getValue("RoxieCluster") && added.getValue("ArrayOfRoxieCluster")==NULL) {
		schema.append("<xsd:complexType name=\"ArrayOfRoxieCluster\">\n");
		schema.append("<xsd:sequence>\n");
		schema.append("<xsd:element minOccurs=\"0\" maxOccurs=\"unbounded\" name=\"RoxieCluster\" type=\"tns:RoxieCluster\"/>\n");
		schema.append("</xsd:sequence>\n");
		schema.append("</xsd:complexType>\n");
		added.setValue("ArrayOfRoxieCluster",1);
	}
	if (added.getValue("ServerJobQueue") && added.getValue("ArrayOfServerJobQueue")==NULL) {
		schema.append("<xsd:complexType name=\"ArrayOfServerJobQueue\">\n");
		schema.append("<xsd:sequence>\n");
		schema.append("<xsd:element minOccurs=\"0\" maxOccurs=\"unbounded\" name=\"ServerJobQueue\" type=\"tns:ServerJobQueue\"/>\n");
		schema.append("</xsd:sequence>\n");
		schema.append("</xsd:complexType>\n");
		added.setValue("ArrayOfServerJobQueue",1);
	}
	if (added.getValue("TargetCluster") && added.getValue("ArrayOfTargetCluster")==NULL) {
		schema.append("<xsd:complexType name=\"ArrayOfTargetCluster\">\n");
		schema.append("<xsd:sequence>\n");
		schema.append("<xsd:element minOccurs=\"0\" maxOccurs=\"unbounded\" name=\"TargetCluster\" type=\"tns:TargetCluster\"/>\n");
		schema.append("</xsd:sequence>\n");
		schema.append("</xsd:complexType>\n");
		added.setValue("ArrayOfTargetCluster",1);
	}
	if (added.getValue("ThorCluster") && added.getValue("ArrayOfThorCluster")==NULL) {
		schema.append("<xsd:complexType name=\"ArrayOfThorCluster\">\n");
		schema.append("<xsd:sequence>\n");
		schema.append("<xsd:element minOccurs=\"0\" maxOccurs=\"unbounded\" name=\"ThorCluster\" type=\"tns:ThorCluster\"/>\n");
		schema.append("</xsd:sequence>\n");
		schema.append("</xsd:complexType>\n");
		added.setValue("ArrayOfThorCluster",1);
	}
	return schema;
}

void CActivityResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CActivityResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
	info.addDeprVersion("ActivityResponse","ThorClusters",1.16);
	info.addMinVersion("ActivityResponse","RoxieClusters",1.07);
	info.addDeprVersion("ActivityResponse","RoxieClusters",1.16);
	info.addMinVersion("ActivityResponse","HThorClusters",1.12);
	info.addDeprVersion("ActivityResponse","HThorClusters",1.16);
	info.addMinVersion("ActivityResponse","ThorClusterList",1.16);
	info.addMinVersion("ActivityResponse","RoxieClusterList",1.16);
	info.addMinVersion("ActivityResponse","HThorClusterList",1.16);
	info.addMinVersion("ActivityResponse","BannerContent",1.06);
	info.addMinVersion("ActivityResponse","BannerColor",1.06);
	info.addMinVersion("ActivityResponse","BannerSize",1.06);
	info.addMinVersion("ActivityResponse","BannerScroll",1.08);
	info.addMinVersion("ActivityResponse","ChatURL",1.06);
	info.addMinVersion("ActivityResponse","ShowBanner",1.06);
	info.addMinVersion("ActivityResponse","ShowChatURL",1.06);
	info.addMinVersion("ActivityResponse","SortBy",1.11);
	info.addMinVersion("ActivityResponse","Descending",1.11);
	info.addMinVersion("ActivityResponse","SuperUser",1.12);
	info.addMinVersion("ActivityResponse","AccessRight",1.12);
	info.addMinVersion("ActivityResponse","ServerJobQueues",1.14);
	if (!added.getValue("ActiveWorkunit"))
	{
		added.setValue("ActiveWorkunit",1);
		CActiveWorkunit::getMapInfo(info,added);
	}
	if (!added.getValue("DFUJob"))
	{
		added.setValue("DFUJob",1);
		CDFUJob::getMapInfo(info,added);
	}
	if (!added.getValue("HThorCluster"))
	{
		added.setValue("HThorCluster",1);
		CHThorCluster::getMapInfo(info,added);
	}
	if (!added.getValue("RoxieCluster"))
	{
		added.setValue("RoxieCluster",1);
		CRoxieCluster::getMapInfo(info,added);
	}
	if (!added.getValue("ServerJobQueue"))
	{
		added.setValue("ServerJobQueue",1);
		CServerJobQueue::getMapInfo(info,added);
	}
	if (!added.getValue("TargetCluster"))
	{
		added.setValue("TargetCluster",1);
		CTargetCluster::getMapInfo(info,added);
	}
	if (!added.getValue("ThorCluster"))
	{
		added.setValue("ThorCluster",1);
		CThorCluster::getMapInfo(info,added);
	}
}

StringBuffer &CActivityResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Build");
	form.appendf("  <tr><td><b>Build: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (!context.suppressed("ActivityResponse","ThorClusters")) {
		extfix.clear();
		if (prefix && *prefix)
			extfix.append(prefix).append(".");
		extfix.append("ThorClusters");
		form.appendf("<tr><td><b>ThorClusters: </b></td><td>");
		form.appendf("<table><tr><td><textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea></td>", extfix.str());
		form.append("</tr></table>");
		form.append("</td></tr>");
	}
	if (!context.suppressed("ActivityResponse","RoxieClusters")) {
		extfix.clear();
		if (prefix && *prefix)
			extfix.append(prefix).append(".");
		extfix.append("RoxieClusters");
		form.appendf("<tr><td><b>RoxieClusters: </b></td><td>");
		form.appendf("<table><tr><td><textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea></td>", extfix.str());
		form.append("</tr></table>");
		form.append("</td></tr>");
	}
	if (!context.suppressed("ActivityResponse","HThorClusters")) {
		extfix.clear();
		if (prefix && *prefix)
			extfix.append(prefix).append(".");
		extfix.append("HThorClusters");
		form.appendf("<tr><td><b>HThorClusters: </b></td><td>");
		form.appendf("<table><tr><td><textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea></td>", extfix.str());
		form.append("</tr></table>");
		form.append("</td></tr>");
	}
	if (!context.suppressed("ActivityResponse","ThorClusterList")) {
		extfix.clear();
		if (prefix && *prefix)
			extfix.append(prefix).append(".");
		extfix.append("ThorClusterList");
		form.appendf("<tr><td><b>ThorClusterList: </b></td><td>");
		form.appendf("<table><tr><td><textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea></td>", extfix.str());
		form.append("</tr></table>");
		form.append("</td></tr>");
	}
	if (!context.suppressed("ActivityResponse","RoxieClusterList")) {
		extfix.clear();
		if (prefix && *prefix)
			extfix.append(prefix).append(".");
		extfix.append("RoxieClusterList");
		form.appendf("<tr><td><b>RoxieClusterList: </b></td><td>");
		form.appendf("<table><tr><td><textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea></td>", extfix.str());
		form.append("</tr></table>");
		form.append("</td></tr>");
	}
	if (!context.suppressed("ActivityResponse","HThorClusterList")) {
		extfix.clear();
		if (prefix && *prefix)
			extfix.append(prefix).append(".");
		extfix.append("HThorClusterList");
		form.appendf("<tr><td><b>HThorClusterList: </b></td><td>");
		form.appendf("<table><tr><td><textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea></td>", extfix.str());
		form.append("</tr></table>");
		form.append("</td></tr>");
	}
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("DFUJobs");
	form.appendf("<tr><td><b>DFUJobs: </b></td><td>");
	form.appendf("<table><tr><td><textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea></td>", extfix.str());
	form.append("</tr></table>");
	form.append("</td></tr>");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Running");
	form.appendf("<tr><td><b>Running: </b></td><td>");
	form.appendf("<table><tr><td><textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea></td>", extfix.str());
	form.append("</tr></table>");
	form.append("</td></tr>");
	if (!context.suppressed("ActivityResponse","BannerContent")) {
		extfix.clear();
		if (prefix && *prefix)
			extfix.append(prefix).append(".");
		extfix.append("BannerContent");
		form.appendf("  <tr><td><b>BannerContent: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
		form.append("</td></tr>\n");
	}
	if (!context.suppressed("ActivityResponse","BannerColor")) {
		extfix.clear();
		if (prefix && *prefix)
			extfix.append(prefix).append(".");
		extfix.append("BannerColor");
		form.appendf("  <tr><td><b>BannerColor: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
		form.append("</td></tr>\n");
	}
	if (!context.suppressed("ActivityResponse","BannerSize")) {
		extfix.clear();
		if (prefix && *prefix)
			extfix.append(prefix).append(".");
		extfix.append("BannerSize");
		form.appendf("  <tr><td><b>BannerSize: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
		form.append("</td></tr>\n");
	}
	if (!context.suppressed("ActivityResponse","BannerScroll")) {
		extfix.clear();
		if (prefix && *prefix)
			extfix.append(prefix).append(".");
		extfix.append("BannerScroll");
		form.appendf("  <tr><td><b>BannerScroll: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
		form.append("</td></tr>\n");
	}
	if (!context.suppressed("ActivityResponse","ChatURL")) {
		extfix.clear();
		if (prefix && *prefix)
			extfix.append(prefix).append(".");
		extfix.append("ChatURL");
		form.appendf("  <tr><td><b>ChatURL: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
		form.append("</td></tr>\n");
	}
	if (!context.suppressed("ActivityResponse","ShowBanner")) {
		extfix.clear();
		if (prefix && *prefix) extfix.append(prefix).append(".");
			extfix.append("ShowBanner");
		form.appendf("  <tr><td><b>ShowBanner: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
		form.append("</td></tr>\n");
	}
	if (!context.suppressed("ActivityResponse","ShowChatURL")) {
		extfix.clear();
		if (prefix && *prefix) extfix.append(prefix).append(".");
			extfix.append("ShowChatURL");
		form.appendf("  <tr><td><b>ShowChatURL: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
		form.append("</td></tr>\n");
	}
	if (!context.suppressed("ActivityResponse","SortBy")) {
		extfix.clear();
		if (prefix && *prefix)
			extfix.append(prefix).append(".");
		extfix.append("SortBy");
		form.appendf("  <tr><td><b>SortBy: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
		form.append("</td></tr>\n");
	}
	if (!context.suppressed("ActivityResponse","Descending")) {
		extfix.clear();
		if (prefix && *prefix)
			extfix.append(prefix).append(".");
		extfix.append("Descending");
		
	form.appendf("  <tr><td><b>Descending? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	}
	if (!context.suppressed("ActivityResponse","SuperUser")) {
		extfix.clear();
		if (prefix && *prefix)
			extfix.append(prefix).append(".");
		extfix.append("SuperUser");
		
	form.appendf("  <tr><td><b>SuperUser? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	}
	if (!context.suppressed("ActivityResponse","AccessRight")) {
		extfix.clear();
		if (prefix && *prefix)
			extfix.append(prefix).append(".");
		extfix.append("AccessRight");
		form.appendf("  <tr><td><b>AccessRight: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
		form.append("</td></tr>\n");
	}
	if (!context.suppressed("ActivityResponse","ServerJobQueues")) {
		extfix.clear();
		if (prefix && *prefix)
			extfix.append(prefix).append(".");
		extfix.append("ServerJobQueues");
		form.appendf("<tr><td><b>ServerJobQueues: </b></td><td>");
		form.appendf("<table><tr><td><textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea></td>", extfix.str());
		form.append("</tr></table>");
		form.append("</td></tr>");
	}
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CActivityResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CActivityResponse::serialize(IRpcMessage& rpc_resp)
{
	IEspContext* ctx = rpc_resp.queryContext();
	double clientVer= ctx ? ctx->getClientVersion() : -1; /* no context gets everything */
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
		m_Build.marshall(rpc_resp, "Build", "", "", "");
		if ((clientVer==-1.0 || clientVer<1.16))
			m_ThorClusters.marshall(rpc_resp, "ThorClusters", "ThorCluster");
		if ((clientVer==-1.0 || (clientVer>=1.07 && clientVer<1.16)))
			m_RoxieClusters.marshall(rpc_resp, "RoxieClusters", "RoxieCluster");
		if ((clientVer==-1.0 || (clientVer>=1.12 && clientVer<1.16)))
			m_HThorClusters.marshall(rpc_resp, "HThorClusters", "HThorCluster");
		if ((clientVer==-1.0 || clientVer>=1.16))
			m_ThorClusterList.marshall(rpc_resp, "ThorClusterList", "TargetCluster");
		if ((clientVer==-1.0 || clientVer>=1.16))
			m_RoxieClusterList.marshall(rpc_resp, "RoxieClusterList", "TargetCluster");
		if ((clientVer==-1.0 || clientVer>=1.16))
			m_HThorClusterList.marshall(rpc_resp, "HThorClusterList", "TargetCluster");
		m_DFUJobs.marshall(rpc_resp, "DFUJobs", "DFUJob");
		m_Running.marshall(rpc_resp, "Running", "ActiveWorkunit");
		if ((clientVer==-1.0 || clientVer>=1.06))
			m_BannerContent.marshall(rpc_resp, "BannerContent", "", "", "");
		if ((clientVer==-1.0 || clientVer>=1.06))
			m_BannerColor.marshall(rpc_resp, "BannerColor", "", "", "");
		if ((clientVer==-1.0 || clientVer>=1.06))
			m_BannerSize.marshall(rpc_resp, "BannerSize", "", "", "");
		if ((clientVer==-1.0 || clientVer>=1.08))
			m_BannerScroll.marshall(rpc_resp, "BannerScroll", "", "", "");
		if ((clientVer==-1.0 || clientVer>=1.06))
			m_ChatURL.marshall(rpc_resp, "ChatURL", "", "", "");
		if ((clientVer==-1.0 || clientVer>=1.06))
			m_ShowBanner.marshall(rpc_resp, "ShowBanner", "", "", "");
		if ((clientVer==-1.0 || clientVer>=1.06))
			m_ShowChatURL.marshall(rpc_resp, "ShowChatURL", "", "", "");
		if ((clientVer==-1.0 || clientVer>=1.11))
			m_SortBy.marshall(rpc_resp, "SortBy", "", "", "");
		if ((clientVer==-1.0 || clientVer>=1.11))
			m_Descending.marshall(rpc_resp, "Descending", "", "", "");
		if ((clientVer==-1.0 || clientVer>=1.12))
			m_SuperUser.marshall(rpc_resp, "SuperUser", "", "", "");
		if ((clientVer==-1.0 || clientVer>=1.12))
			m_AccessRight.marshall(rpc_resp, "AccessRight", "", "", "");
		if ((clientVer==-1.0 || clientVer>=1.14))
			m_ServerJobQueues.marshall(rpc_resp, "ServerJobQueues", "ServerJobQueue");
	}
}


void CActivityResponse::copy(CActivityResponse &from)
{
	m_Build.copy(from.m_Build);
	m_ThorClusters.copy(from.m_ThorClusters);
	m_RoxieClusters.copy(from.m_RoxieClusters);
	m_HThorClusters.copy(from.m_HThorClusters);
	m_ThorClusterList.copy(from.m_ThorClusterList);
	m_RoxieClusterList.copy(from.m_RoxieClusterList);
	m_HThorClusterList.copy(from.m_HThorClusterList);
	m_DFUJobs.copy(from.m_DFUJobs);
	m_Running.copy(from.m_Running);
	m_BannerContent.copy(from.m_BannerContent);
	m_BannerColor.copy(from.m_BannerColor);
	m_BannerSize.copy(from.m_BannerSize);
	m_BannerScroll.copy(from.m_BannerScroll);
	m_ChatURL.copy(from.m_ChatURL);
	m_ShowBanner.copy(from.m_ShowBanner);
	m_ShowChatURL.copy(from.m_ShowChatURL);
	m_SortBy.copy(from.m_SortBy);
	m_Descending.copy(from.m_Descending);
	m_SuperUser.copy(from.m_SuperUser);
	m_AccessRight.copy(from.m_AccessRight);
	m_ServerJobQueues.copy(from.m_ServerJobQueues);
}


void CActivityResponse::copy(IConstActivityResponse &ifrom)
{
	setBuild(ifrom.getBuild());
	setThorClusters(ifrom.getThorClusters());
	setRoxieClusters(ifrom.getRoxieClusters());
	setHThorClusters(ifrom.getHThorClusters());
	setThorClusterList(ifrom.getThorClusterList());
	setRoxieClusterList(ifrom.getRoxieClusterList());
	setHThorClusterList(ifrom.getHThorClusterList());
	setDFUJobs(ifrom.getDFUJobs());
	setRunning(ifrom.getRunning());
	setBannerContent(ifrom.getBannerContent());
	setBannerColor(ifrom.getBannerColor());
	setBannerSize(ifrom.getBannerSize());
	setBannerScroll(ifrom.getBannerScroll());
	setChatURL(ifrom.getChatURL());
	setShowBanner(ifrom.getShowBanner());
	setShowChatURL(ifrom.getShowChatURL());
	setSortBy(ifrom.getSortBy());
	setDescending(ifrom.getDescending());
	setSuperUser(ifrom.getSuperUser());
	setAccessRight(ifrom.getAccessRight());
	setServerJobQueues(ifrom.getServerJobQueues());
}


void CActivityResponse::getAttributes(IProperties &attributes)
{
}


void CActivityResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
		double clientVer = ctx ? ctx->getClientVersion() : -1;
		m_Build.toStr(ctx, buffer, "Build", "", true, "", "");
		if ((clientVer==-1.0 || clientVer<1.16))
			m_ThorClusters.toStr(ctx, buffer, "ThorClusters", "ThorCluster");
		if ((clientVer==-1.0 || (clientVer>=1.07 && clientVer<1.16)))
			m_RoxieClusters.toStr(ctx, buffer, "RoxieClusters", "RoxieCluster");
		if ((clientVer==-1.0 || (clientVer>=1.12 && clientVer<1.16)))
			m_HThorClusters.toStr(ctx, buffer, "HThorClusters", "HThorCluster");
		if ((clientVer==-1.0 || clientVer>=1.16))
			m_ThorClusterList.toStr(ctx, buffer, "ThorClusterList", "TargetCluster");
		if ((clientVer==-1.0 || clientVer>=1.16))
			m_RoxieClusterList.toStr(ctx, buffer, "RoxieClusterList", "TargetCluster");
		if ((clientVer==-1.0 || clientVer>=1.16))
			m_HThorClusterList.toStr(ctx, buffer, "HThorClusterList", "TargetCluster");
		m_DFUJobs.toStr(ctx, buffer, "DFUJobs", "DFUJob");
		m_Running.toStr(ctx, buffer, "Running", "ActiveWorkunit");
		if ((clientVer==-1.0 || clientVer>=1.06))
			m_BannerContent.toStr(ctx, buffer, "BannerContent", "", true, "", "");
		if ((clientVer==-1.0 || clientVer>=1.06))
			m_BannerColor.toStr(ctx, buffer, "BannerColor", "", true, "", "");
		if ((clientVer==-1.0 || clientVer>=1.06))
			m_BannerSize.toStr(ctx, buffer, "BannerSize", "", true, "", "");
		if ((clientVer==-1.0 || clientVer>=1.08))
			m_BannerScroll.toStr(ctx, buffer, "BannerScroll", "", true, "", "");
		if ((clientVer==-1.0 || clientVer>=1.06))
			m_ChatURL.toStr(ctx, buffer, "ChatURL", "", true, "", "");
		if ((clientVer==-1.0 || clientVer>=1.06))
			m_ShowBanner.toStr(ctx, buffer, "ShowBanner", "", true, "", "");
		if ((clientVer==-1.0 || clientVer>=1.06))
			m_ShowChatURL.toStr(ctx, buffer, "ShowChatURL", "", true, "", "");
		if ((clientVer==-1.0 || clientVer>=1.11))
			m_SortBy.toStr(ctx, buffer, "SortBy", "", true, "", "");
		if ((clientVer==-1.0 || clientVer>=1.11))
			m_Descending.toStr(ctx, buffer, "Descending", "", true, "", "");
		if ((clientVer==-1.0 || clientVer>=1.12))
			m_SuperUser.toStr(ctx, buffer, "SuperUser", "", true, "", "");
		if ((clientVer==-1.0 || clientVer>=1.12))
			m_AccessRight.toStr(ctx, buffer, "AccessRight", "", true, "", "");
		if ((clientVer==-1.0 || clientVer>=1.14))
			m_ServerJobQueues.toStr(ctx, buffer, "ServerJobQueues", "ServerJobQueue");
	}
}


void CActivityResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CActivityResponse::serializer(IEspContext* ctx, IConstActivityResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<ActivityResponse>");
	double clientVer = ctx ? ctx->getClientVersion() : -1;
	// field Build
	{
		const char* s = src.getBuild();
		if (s && *s)
		{
			buffer.append("<Build>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Build>");
		}
	}
	// field ThorClusters
	if ((clientVer==-1.0 || clientVer<1.16))
	{
		IArrayOf<IConstThorCluster>& v = src.getThorClusters();
		int size = v.length();
		if (size>0)
			buffer.append("<ThorClusters>");
		for (int i=0;i<size;i++)
		{
			buffer.append("<Item>");
			CThorCluster::serializer(ctx,v.item(i),buffer,false);
			buffer.append("</Item>");
		}
		if (size>0)
			buffer.append("</ThorClusters>");
	}
	// field RoxieClusters
	if ((clientVer==-1.0 || (clientVer>=1.07 && clientVer<1.16)))
	{
		IArrayOf<IConstRoxieCluster>& v = src.getRoxieClusters();
		int size = v.length();
		if (size>0)
			buffer.append("<RoxieClusters>");
		for (int i=0;i<size;i++)
		{
			buffer.append("<Item>");
			CRoxieCluster::serializer(ctx,v.item(i),buffer,false);
			buffer.append("</Item>");
		}
		if (size>0)
			buffer.append("</RoxieClusters>");
	}
	// field HThorClusters
	if ((clientVer==-1.0 || (clientVer>=1.12 && clientVer<1.16)))
	{
		IArrayOf<IConstHThorCluster>& v = src.getHThorClusters();
		int size = v.length();
		if (size>0)
			buffer.append("<HThorClusters>");
		for (int i=0;i<size;i++)
		{
			buffer.append("<Item>");
			CHThorCluster::serializer(ctx,v.item(i),buffer,false);
			buffer.append("</Item>");
		}
		if (size>0)
			buffer.append("</HThorClusters>");
	}
	// field ThorClusterList
	if ((clientVer==-1.0 || clientVer>=1.16))
	{
		IArrayOf<IConstTargetCluster>& v = src.getThorClusterList();
		int size = v.length();
		if (size>0)
			buffer.append("<ThorClusterList>");
		for (int i=0;i<size;i++)
		{
			buffer.append("<Item>");
			CTargetCluster::serializer(ctx,v.item(i),buffer,false);
			buffer.append("</Item>");
		}
		if (size>0)
			buffer.append("</ThorClusterList>");
	}
	// field RoxieClusterList
	if ((clientVer==-1.0 || clientVer>=1.16))
	{
		IArrayOf<IConstTargetCluster>& v = src.getRoxieClusterList();
		int size = v.length();
		if (size>0)
			buffer.append("<RoxieClusterList>");
		for (int i=0;i<size;i++)
		{
			buffer.append("<Item>");
			CTargetCluster::serializer(ctx,v.item(i),buffer,false);
			buffer.append("</Item>");
		}
		if (size>0)
			buffer.append("</RoxieClusterList>");
	}
	// field HThorClusterList
	if ((clientVer==-1.0 || clientVer>=1.16))
	{
		IArrayOf<IConstTargetCluster>& v = src.getHThorClusterList();
		int size = v.length();
		if (size>0)
			buffer.append("<HThorClusterList>");
		for (int i=0;i<size;i++)
		{
			buffer.append("<Item>");
			CTargetCluster::serializer(ctx,v.item(i),buffer,false);
			buffer.append("</Item>");
		}
		if (size>0)
			buffer.append("</HThorClusterList>");
	}
	// field DFUJobs
	{
		IArrayOf<IConstDFUJob>& v = src.getDFUJobs();
		int size = v.length();
		if (size>0)
			buffer.append("<DFUJobs>");
		for (int i=0;i<size;i++)
		{
			buffer.append("<Item>");
			CDFUJob::serializer(ctx,v.item(i),buffer,false);
			buffer.append("</Item>");
		}
		if (size>0)
			buffer.append("</DFUJobs>");
	}
	// field Running
	{
		IArrayOf<IConstActiveWorkunit>& v = src.getRunning();
		int size = v.length();
		if (size>0)
			buffer.append("<Running>");
		for (int i=0;i<size;i++)
		{
			buffer.append("<Item>");
			CActiveWorkunit::serializer(ctx,v.item(i),buffer,false);
			buffer.append("</Item>");
		}
		if (size>0)
			buffer.append("</Running>");
	}
	// field BannerContent
	if ((clientVer==-1.0 || clientVer>=1.06))
	{
		const char* s = src.getBannerContent();
		if (s && *s)
		{
			buffer.append("<BannerContent>");
			encodeUtf8XML(s,buffer);
			buffer.append("</BannerContent>");
		}
	}
	// field BannerColor
	if ((clientVer==-1.0 || clientVer>=1.06))
	{
		const char* s = src.getBannerColor();
		if (s && *s)
		{
			buffer.append("<BannerColor>");
			encodeUtf8XML(s,buffer);
			buffer.append("</BannerColor>");
		}
	}
	// field BannerSize
	if ((clientVer==-1.0 || clientVer>=1.06))
	{
		const char* s = src.getBannerSize();
		if (s && *s)
		{
			buffer.append("<BannerSize>");
			encodeUtf8XML(s,buffer);
			buffer.append("</BannerSize>");
		}
	}
	// field BannerScroll
	if ((clientVer==-1.0 || clientVer>=1.08))
	{
		const char* s = src.getBannerScroll();
		if (s && *s)
		{
			buffer.append("<BannerScroll>");
			encodeUtf8XML(s,buffer);
			buffer.append("</BannerScroll>");
		}
	}
	// field ChatURL
	if ((clientVer==-1.0 || clientVer>=1.06))
	{
		const char* s = src.getChatURL();
		if (s && *s)
		{
			buffer.append("<ChatURL>");
			encodeUtf8XML(s,buffer);
			buffer.append("</ChatURL>");
		}
	}
	// field ShowBanner
	if ((clientVer==-1.0 || clientVer>=1.06))
	{
		int n = src.getShowBanner();
		if (n)
			buffer.appendf("<ShowBanner>%d</ShowBanner>", n);
	}
	// field ShowChatURL
	if ((clientVer==-1.0 || clientVer>=1.06))
	{
		int n = src.getShowChatURL();
		if (n)
			buffer.appendf("<ShowChatURL>%d</ShowChatURL>", n);
	}
	// field SortBy
	if ((clientVer==-1.0 || clientVer>=1.11))
	{
		const char* s = src.getSortBy();
		if (s && *s)
		{
			buffer.append("<SortBy>");
			encodeUtf8XML(s,buffer);
			buffer.append("</SortBy>");
		}
	}
	// field Descending
	if ((clientVer==-1.0 || clientVer>=1.11))
	{
		bool b = src.getDescending();
		if (b)
			buffer.appendf("<Descending>1</Descending>");
	}
	// field SuperUser
	if ((clientVer==-1.0 || clientVer>=1.12))
	{
		bool b = src.getSuperUser();
		if (b)
			buffer.appendf("<SuperUser>1</SuperUser>");
	}
	// field AccessRight
	if ((clientVer==-1.0 || clientVer>=1.12))
	{
		const char* s = src.getAccessRight();
		if (s && *s)
		{
			buffer.append("<AccessRight>");
			encodeUtf8XML(s,buffer);
			buffer.append("</AccessRight>");
		}
	}
	// field ServerJobQueues
	if ((clientVer==-1.0 || clientVer>=1.14))
	{
		IArrayOf<IConstServerJobQueue>& v = src.getServerJobQueues();
		int size = v.length();
		if (size>0)
			buffer.append("<ServerJobQueues>");
		for (int i=0;i<size;i++)
		{
			buffer.append("<Item>");
			CServerJobQueue::serializer(ctx,v.item(i),buffer,false);
			buffer.append("</Item>");
		}
		if (size>0)
			buffer.append("</ServerJobQueues>");
	}
	if (keepRootTag)
		buffer.append("</ActivityResponse>");
}

bool CActivityResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
		hasValue |= m_Build.unmarshall(rpc_request, "Build", basepath);
		hasValue |= m_ThorClusters.unmarshall(rpc_request, "ThorClusters", basepath);
		hasValue |= m_RoxieClusters.unmarshall(rpc_request, "RoxieClusters", basepath);
		hasValue |= m_HThorClusters.unmarshall(rpc_request, "HThorClusters", basepath);
		hasValue |= m_ThorClusterList.unmarshall(rpc_request, "ThorClusterList", basepath);
		hasValue |= m_RoxieClusterList.unmarshall(rpc_request, "RoxieClusterList", basepath);
		hasValue |= m_HThorClusterList.unmarshall(rpc_request, "HThorClusterList", basepath);
		hasValue |= m_DFUJobs.unmarshall(rpc_request, "DFUJobs", basepath);
		hasValue |= m_Running.unmarshall(rpc_request, "Running", basepath);
		hasValue |= m_BannerContent.unmarshall(rpc_request, "BannerContent", basepath);
		hasValue |= m_BannerColor.unmarshall(rpc_request, "BannerColor", basepath);
		hasValue |= m_BannerSize.unmarshall(rpc_request, "BannerSize", basepath);
		hasValue |= m_BannerScroll.unmarshall(rpc_request, "BannerScroll", basepath);
		hasValue |= m_ChatURL.unmarshall(rpc_request, "ChatURL", basepath);
		hasValue |= m_ShowBanner.unmarshall(rpc_request, "ShowBanner", basepath);
		hasValue |= m_ShowChatURL.unmarshall(rpc_request, "ShowChatURL", basepath);
		hasValue |= m_SortBy.unmarshall(rpc_request, "SortBy", basepath);
		hasValue |= m_Descending.unmarshall(rpc_request, "Descending", basepath);
		hasValue |= m_SuperUser.unmarshall(rpc_request, "SuperUser", basepath);
		hasValue |= m_AccessRight.unmarshall(rpc_request, "AccessRight", basepath);
		hasValue |= m_ServerJobQueues.unmarshall(rpc_request, "ServerJobQueues", basepath);
	}
	return hasValue;
}

bool CActivityResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Build.unmarshall(ctx, soapval, "Build");
	hasValue |= m_ThorClusters.unmarshall(ctx, soapval, "ThorClusters");
	hasValue |= m_RoxieClusters.unmarshall(ctx, soapval, "RoxieClusters");
	hasValue |= m_HThorClusters.unmarshall(ctx, soapval, "HThorClusters");
	hasValue |= m_ThorClusterList.unmarshall(ctx, soapval, "ThorClusterList");
	hasValue |= m_RoxieClusterList.unmarshall(ctx, soapval, "RoxieClusterList");
	hasValue |= m_HThorClusterList.unmarshall(ctx, soapval, "HThorClusterList");
	hasValue |= m_DFUJobs.unmarshall(ctx, soapval, "DFUJobs");
	hasValue |= m_Running.unmarshall(ctx, soapval, "Running");
	hasValue |= m_BannerContent.unmarshall(ctx, soapval, "BannerContent");
	hasValue |= m_BannerColor.unmarshall(ctx, soapval, "BannerColor");
	hasValue |= m_BannerSize.unmarshall(ctx, soapval, "BannerSize");
	hasValue |= m_BannerScroll.unmarshall(ctx, soapval, "BannerScroll");
	hasValue |= m_ChatURL.unmarshall(ctx, soapval, "ChatURL");
	hasValue |= m_ShowBanner.unmarshall(ctx, soapval, "ShowBanner");
	hasValue |= m_ShowChatURL.unmarshall(ctx, soapval, "ShowChatURL");
	hasValue |= m_SortBy.unmarshall(ctx, soapval, "SortBy");
	hasValue |= m_Descending.unmarshall(ctx, soapval, "Descending");
	hasValue |= m_SuperUser.unmarshall(ctx, soapval, "SuperUser");
	hasValue |= m_AccessRight.unmarshall(ctx, soapval, "AccessRight");
	hasValue |= m_ServerJobQueues.unmarshall(ctx, soapval, "ServerJobQueues");
	return hasValue;
}

bool CActivityResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Build.unmarshall(ctx, params, attachments, "Build", basepath);
	hasValue |= m_ThorClusters.unmarshall(ctx, params, attachments, "ThorClusters", basepath);
	hasValue |= m_RoxieClusters.unmarshall(ctx, params, attachments, "RoxieClusters", basepath);
	hasValue |= m_HThorClusters.unmarshall(ctx, params, attachments, "HThorClusters", basepath);
	hasValue |= m_ThorClusterList.unmarshall(ctx, params, attachments, "ThorClusterList", basepath);
	hasValue |= m_RoxieClusterList.unmarshall(ctx, params, attachments, "RoxieClusterList", basepath);
	hasValue |= m_HThorClusterList.unmarshall(ctx, params, attachments, "HThorClusterList", basepath);
	hasValue |= m_DFUJobs.unmarshall(ctx, params, attachments, "DFUJobs", basepath);
	hasValue |= m_Running.unmarshall(ctx, params, attachments, "Running", basepath);
	hasValue |= m_BannerContent.unmarshall(ctx, params, attachments, "BannerContent", basepath);
	hasValue |= m_BannerColor.unmarshall(ctx, params, attachments, "BannerColor", basepath);
	hasValue |= m_BannerSize.unmarshall(ctx, params, attachments, "BannerSize", basepath);
	hasValue |= m_BannerScroll.unmarshall(ctx, params, attachments, "BannerScroll", basepath);
	hasValue |= m_ChatURL.unmarshall(ctx, params, attachments, "ChatURL", basepath);
	hasValue |= m_ShowBanner.unmarshall(ctx, params, attachments, "ShowBanner", basepath);
	hasValue |= m_ShowChatURL.unmarshall(ctx, params, attachments, "ShowChatURL", basepath);
	hasValue |= m_SortBy.unmarshall(ctx, params, attachments, "SortBy", basepath);
	hasValue |= m_Descending.unmarshall(ctx, params, attachments, "Descending", basepath);
	hasValue |= m_SuperUser.unmarshall(ctx, params, attachments, "SuperUser", basepath);
	hasValue |= m_AccessRight.unmarshall(ctx, params, attachments, "AccessRight", basepath);
	hasValue |= m_ServerJobQueues.unmarshall(ctx, params, attachments, "ServerJobQueues", basepath);
	return hasValue;
}

const char * CActivityResponse::getBuild() { return m_Build.query();}
IArrayOf<IConstThorCluster> & CActivityResponse::getThorClusters() { return (IArrayOf<IConstThorCluster> &) m_ThorClusters; }
IArrayOf<IConstRoxieCluster> & CActivityResponse::getRoxieClusters() { return (IArrayOf<IConstRoxieCluster> &) m_RoxieClusters; }
IArrayOf<IConstHThorCluster> & CActivityResponse::getHThorClusters() { return (IArrayOf<IConstHThorCluster> &) m_HThorClusters; }
IArrayOf<IConstTargetCluster> & CActivityResponse::getThorClusterList() { return (IArrayOf<IConstTargetCluster> &) m_ThorClusterList; }
IArrayOf<IConstTargetCluster> & CActivityResponse::getRoxieClusterList() { return (IArrayOf<IConstTargetCluster> &) m_RoxieClusterList; }
IArrayOf<IConstTargetCluster> & CActivityResponse::getHThorClusterList() { return (IArrayOf<IConstTargetCluster> &) m_HThorClusterList; }
IArrayOf<IConstDFUJob> & CActivityResponse::getDFUJobs() { return (IArrayOf<IConstDFUJob> &) m_DFUJobs; }
IArrayOf<IConstActiveWorkunit> & CActivityResponse::getRunning() { return (IArrayOf<IConstActiveWorkunit> &) m_Running; }
const char * CActivityResponse::getBannerContent() { return m_BannerContent.query();}
const char * CActivityResponse::getBannerColor() { return m_BannerColor.query();}
const char * CActivityResponse::getBannerSize() { return m_BannerSize.query();}
const char * CActivityResponse::getBannerScroll() { return m_BannerScroll.query();}
const char * CActivityResponse::getChatURL() { return m_ChatURL.query();}
int CActivityResponse::getShowBanner() { return m_ShowBanner;}
int CActivityResponse::getShowChatURL() { return m_ShowChatURL;}
const char * CActivityResponse::getSortBy() { return m_SortBy.query();}
bool CActivityResponse::getDescending() { return m_Descending;}
bool CActivityResponse::getSuperUser() { return m_SuperUser;}
const char * CActivityResponse::getAccessRight() { return m_AccessRight.query();}
IArrayOf<IConstServerJobQueue> & CActivityResponse::getServerJobQueues() { return (IArrayOf<IConstServerJobQueue> &) m_ServerJobQueues; }
void CActivityResponse::setBuild(const char * val){ m_Build.set(val); }
void CActivityResponse::setThorClusters(IArrayOf<IEspThorCluster> &val)
{
	m_ThorClusters->kill();
	IArrayOf<IConstThorCluster> &target = m_ThorClusters.getValue();
	ForEachItemIn(idx, val)
	{
		IEspThorCluster &item = (val).item(idx);
		item.Link();
		target.append(item);
	}
}
void CActivityResponse::setThorClusters(IArrayOf<IConstThorCluster> &val)
{
	m_ThorClusters->kill();
	IArrayOf<IConstThorCluster> &target = m_ThorClusters.getValue();
	ForEachItemIn(idx, val)
	{
		IConstThorCluster &item = val.item(idx);
		item.Link();
		target.append(item);
	}
}
void CActivityResponse::setRoxieClusters(IArrayOf<IEspRoxieCluster> &val)
{
	m_RoxieClusters->kill();
	IArrayOf<IConstRoxieCluster> &target = m_RoxieClusters.getValue();
	ForEachItemIn(idx, val)
	{
		IEspRoxieCluster &item = (val).item(idx);
		item.Link();
		target.append(item);
	}
}
void CActivityResponse::setRoxieClusters(IArrayOf<IConstRoxieCluster> &val)
{
	m_RoxieClusters->kill();
	IArrayOf<IConstRoxieCluster> &target = m_RoxieClusters.getValue();
	ForEachItemIn(idx, val)
	{
		IConstRoxieCluster &item = val.item(idx);
		item.Link();
		target.append(item);
	}
}
void CActivityResponse::setHThorClusters(IArrayOf<IEspHThorCluster> &val)
{
	m_HThorClusters->kill();
	IArrayOf<IConstHThorCluster> &target = m_HThorClusters.getValue();
	ForEachItemIn(idx, val)
	{
		IEspHThorCluster &item = (val).item(idx);
		item.Link();
		target.append(item);
	}
}
void CActivityResponse::setHThorClusters(IArrayOf<IConstHThorCluster> &val)
{
	m_HThorClusters->kill();
	IArrayOf<IConstHThorCluster> &target = m_HThorClusters.getValue();
	ForEachItemIn(idx, val)
	{
		IConstHThorCluster &item = val.item(idx);
		item.Link();
		target.append(item);
	}
}
void CActivityResponse::setThorClusterList(IArrayOf<IEspTargetCluster> &val)
{
	m_ThorClusterList->kill();
	IArrayOf<IConstTargetCluster> &target = m_ThorClusterList.getValue();
	ForEachItemIn(idx, val)
	{
		IEspTargetCluster &item = (val).item(idx);
		item.Link();
		target.append(item);
	}
}
void CActivityResponse::setThorClusterList(IArrayOf<IConstTargetCluster> &val)
{
	m_ThorClusterList->kill();
	IArrayOf<IConstTargetCluster> &target = m_ThorClusterList.getValue();
	ForEachItemIn(idx, val)
	{
		IConstTargetCluster &item = val.item(idx);
		item.Link();
		target.append(item);
	}
}
void CActivityResponse::setRoxieClusterList(IArrayOf<IEspTargetCluster> &val)
{
	m_RoxieClusterList->kill();
	IArrayOf<IConstTargetCluster> &target = m_RoxieClusterList.getValue();
	ForEachItemIn(idx, val)
	{
		IEspTargetCluster &item = (val).item(idx);
		item.Link();
		target.append(item);
	}
}
void CActivityResponse::setRoxieClusterList(IArrayOf<IConstTargetCluster> &val)
{
	m_RoxieClusterList->kill();
	IArrayOf<IConstTargetCluster> &target = m_RoxieClusterList.getValue();
	ForEachItemIn(idx, val)
	{
		IConstTargetCluster &item = val.item(idx);
		item.Link();
		target.append(item);
	}
}
void CActivityResponse::setHThorClusterList(IArrayOf<IEspTargetCluster> &val)
{
	m_HThorClusterList->kill();
	IArrayOf<IConstTargetCluster> &target = m_HThorClusterList.getValue();
	ForEachItemIn(idx, val)
	{
		IEspTargetCluster &item = (val).item(idx);
		item.Link();
		target.append(item);
	}
}
void CActivityResponse::setHThorClusterList(IArrayOf<IConstTargetCluster> &val)
{
	m_HThorClusterList->kill();
	IArrayOf<IConstTargetCluster> &target = m_HThorClusterList.getValue();
	ForEachItemIn(idx, val)
	{
		IConstTargetCluster &item = val.item(idx);
		item.Link();
		target.append(item);
	}
}
void CActivityResponse::setDFUJobs(IArrayOf<IEspDFUJob> &val)
{
	m_DFUJobs->kill();
	IArrayOf<IConstDFUJob> &target = m_DFUJobs.getValue();
	ForEachItemIn(idx, val)
	{
		IEspDFUJob &item = (val).item(idx);
		item.Link();
		target.append(item);
	}
}
void CActivityResponse::setDFUJobs(IArrayOf<IConstDFUJob> &val)
{
	m_DFUJobs->kill();
	IArrayOf<IConstDFUJob> &target = m_DFUJobs.getValue();
	ForEachItemIn(idx, val)
	{
		IConstDFUJob &item = val.item(idx);
		item.Link();
		target.append(item);
	}
}
void CActivityResponse::setRunning(IArrayOf<IEspActiveWorkunit> &val)
{
	m_Running->kill();
	IArrayOf<IConstActiveWorkunit> &target = m_Running.getValue();
	ForEachItemIn(idx, val)
	{
		IEspActiveWorkunit &item = (val).item(idx);
		item.Link();
		target.append(item);
	}
}
void CActivityResponse::setRunning(IArrayOf<IConstActiveWorkunit> &val)
{
	m_Running->kill();
	IArrayOf<IConstActiveWorkunit> &target = m_Running.getValue();
	ForEachItemIn(idx, val)
	{
		IConstActiveWorkunit &item = val.item(idx);
		item.Link();
		target.append(item);
	}
}
void CActivityResponse::setBannerContent(const char * val){ m_BannerContent.set(val); }
void CActivityResponse::setBannerColor(const char * val){ m_BannerColor.set(val); }
void CActivityResponse::setBannerSize(const char * val){ m_BannerSize.set(val); }
void CActivityResponse::setBannerScroll(const char * val){ m_BannerScroll.set(val); }
void CActivityResponse::setChatURL(const char * val){ m_ChatURL.set(val); }
void CActivityResponse::setShowBanner(int val){ m_ShowBanner=val; }
void CActivityResponse::setShowChatURL(int val){ m_ShowChatURL=val; }
void CActivityResponse::setSortBy(const char * val){ m_SortBy.set(val); }
void CActivityResponse::setDescending(bool val){ m_Descending=val; }
void CActivityResponse::setSuperUser(bool val){ m_SuperUser=val; }
void CActivityResponse::setAccessRight(const char * val){ m_AccessRight.set(val); }
void CActivityResponse::setServerJobQueues(IArrayOf<IEspServerJobQueue> &val)
{
	m_ServerJobQueues->kill();
	IArrayOf<IConstServerJobQueue> &target = m_ServerJobQueues.getValue();
	ForEachItemIn(idx, val)
	{
		IEspServerJobQueue &item = (val).item(idx);
		item.Link();
		target.append(item);
	}
}
void CActivityResponse::setServerJobQueues(IArrayOf<IConstServerJobQueue> &val)
{
	m_ServerJobQueues->kill();
	IArrayOf<IConstServerJobQueue> &target = m_ServerJobQueues.getValue();
	ForEachItemIn(idx, val)
	{
		IConstServerJobQueue &item = val.item(idx);
		item.Link();
		target.append(item);
	}
}
extern "C"  IEspActivityResponse *createActivityResponse(const char *serv){return ((IEspActivityResponse *)new CActivityResponse(serv));}
extern "C"  IClientActivityResponse *createClientActivityResponse(const char *serv){return ((IClientActivityResponse *)new CActivityResponse(serv));}

//=======================================================
// class CSMCIndexRequest Implementation
//=======================================================

CSMCIndexRequest::CSMCIndexRequest(const char *serviceName, IRpcMessageBinding *init)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("SMCIndexRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CSMCIndexRequest::CSMCIndexRequest(const char *serviceName, const char *bc)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("SMCIndexRequest");
}

CSMCIndexRequest::CSMCIndexRequest(const char *serviceName, IRpcMessage* rpcmsg)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("SMCIndexRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CSMCIndexRequest::CSMCIndexRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("SMCIndexRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CSMCIndexRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType><xsd:all/></xsd:complexType></xsd:element>\n", msgTypeName);
		}
	}
	return schema;
}

void CSMCIndexRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CSMCIndexRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CSMCIndexRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CSMCIndexRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CSMCIndexRequest::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

}


void CSMCIndexRequest::copy(CSMCIndexRequest &from)
{
}


void CSMCIndexRequest::copy(IConstSMCIndexRequest &ifrom)
{
}


void CSMCIndexRequest::getAttributes(IProperties &attributes)
{
}


void CSMCIndexRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
}


void CSMCIndexRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CSMCIndexRequest::serializer(IEspContext* ctx, IConstSMCIndexRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<SMCIndexRequest>");
	if (keepRootTag)
		buffer.append("</SMCIndexRequest>");
}

bool CSMCIndexRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	return hasValue;
}

bool CSMCIndexRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	return hasValue;
}

bool CSMCIndexRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	return hasValue;
}

extern "C"  IEspSMCIndexRequest *createSMCIndexRequest(const char *serv){return ((IEspSMCIndexRequest *)new CSMCIndexRequest(serv));}
extern "C"  IClientSMCIndexRequest *createClientSMCIndexRequest(const char *serv){return ((IClientSMCIndexRequest *)new CSMCIndexRequest(serv));}

//=======================================================
// class CSMCIndexResponse Implementation
//=======================================================

CSMCIndexResponse::CSMCIndexResponse(const char *serviceName, IRpcMessageBinding *init)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("SMCIndexResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CSMCIndexResponse::CSMCIndexResponse(const char *serviceName, const char *bc)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("SMCIndexResponse");
}

CSMCIndexResponse::CSMCIndexResponse(const char *serviceName, IRpcMessage* rpcmsg)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("SMCIndexResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CSMCIndexResponse::CSMCIndexResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("SMCIndexResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CSMCIndexResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		schema.append("<xsd:element name=\"Exceptions\" type=\"tns:ArrayOfEspException\" minOccurs=\"0\" maxOccurs=\"1\"/>");
		}
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CSMCIndexResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CSMCIndexResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CSMCIndexResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CSMCIndexResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CSMCIndexResponse::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
	}
}


void CSMCIndexResponse::copy(CSMCIndexResponse &from)
{
}


void CSMCIndexResponse::copy(IConstSMCIndexResponse &ifrom)
{
}


void CSMCIndexResponse::getAttributes(IProperties &attributes)
{
}


void CSMCIndexResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
	}
}


void CSMCIndexResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CSMCIndexResponse::serializer(IEspContext* ctx, IConstSMCIndexResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<SMCIndexResponse>");
	if (keepRootTag)
		buffer.append("</SMCIndexResponse>");
}

bool CSMCIndexResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
	}
	return hasValue;
}

bool CSMCIndexResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	return hasValue;
}

bool CSMCIndexResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	return hasValue;
}

extern "C"  IEspSMCIndexResponse *createSMCIndexResponse(const char *serv){return ((IEspSMCIndexResponse *)new CSMCIndexResponse(serv));}
extern "C"  IClientSMCIndexResponse *createClientSMCIndexResponse(const char *serv){return ((IClientSMCIndexResponse *)new CSMCIndexResponse(serv));}

//=======================================================
// class CCapability Implementation
//=======================================================

CCapability::CCapability(const char *serviceName, IRpcMessageBinding *init)
	: m_name(nilIgnore),m_description(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("Capability");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CCapability::CCapability(const char *serviceName, const char *bc)
	: m_name(nilIgnore),m_description(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("Capability");
}

StringBuffer &CCapability::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:complexType name=\"%s\">\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"name\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"description\" type=\"xsd:string\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType>\n");
		}
	}
	return schema;
}

void CCapability::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CCapability::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CCapability::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("name");
	form.appendf("  <tr><td><b>name: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("description");
	form.appendf("  <tr><td><b>description: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CCapability::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CCapability::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_name.marshall(rpc_resp, "name", "", "", "");
	m_description.marshall(rpc_resp, "description", "", "", "");
}


void CCapability::copy(CCapability &from)
{
	m_name.copy(from.m_name);
	m_description.copy(from.m_description);
}


void CCapability::copy(IConstCapability &ifrom)
{
	setName(ifrom.getName());
	setDescription(ifrom.getDescription());
}


void CCapability::getAttributes(IProperties &attributes)
{
}


void CCapability::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_name.toStr(ctx, buffer, "name", "", true, "", "");
	m_description.toStr(ctx, buffer, "description", "", true, "", "");
}


void CCapability::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CCapability::serializer(IEspContext* ctx, IConstCapability &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<Capability>");
	// field name
	{
		const char* s = src.getName();
		if (s && *s)
		{
			buffer.append("<name>");
			encodeUtf8XML(s,buffer);
			buffer.append("</name>");
		}
	}
	// field description
	{
		const char* s = src.getDescription();
		if (s && *s)
		{
			buffer.append("<description>");
			encodeUtf8XML(s,buffer);
			buffer.append("</description>");
		}
	}
	if (keepRootTag)
		buffer.append("</Capability>");
}

bool CCapability::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_name.unmarshall(rpc_request, "name", basepath);
	hasValue |= m_description.unmarshall(rpc_request, "description", basepath);
	return hasValue;
}

bool CCapability::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_name.unmarshall(ctx, soapval, "name");
	hasValue |= m_description.unmarshall(ctx, soapval, "description");
	return hasValue;
}

bool CCapability::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_name.unmarshall(ctx, params, attachments, "name", basepath);
	hasValue |= m_description.unmarshall(ctx, params, attachments, "description", basepath);
	return hasValue;
}

const char * CCapability::getName() { return m_name.query();}
const char * CCapability::getDescription() { return m_description.query();}
void CCapability::setName(const char * val){ m_name.set(val); }
void CCapability::setDescription(const char * val){ m_description.set(val); }
extern "C"  IEspCapability *createCapability(const char *serv, const char *msgname){return ((IEspCapability *)new CCapability(serv /*, msgname*/));}
extern "C"  IClientCapability *createClientCapability(const char *serv, const char *msgname){return ((IClientCapability *)new CCapability(serv /*, msgname*/));}

//=======================================================
// class CPermission Implementation
//=======================================================

CPermission::CPermission(const char *serviceName, IRpcMessageBinding *init)
	: m_Feature(nilIgnore),m_Capabilities(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("Permission");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CPermission::CPermission(const char *serviceName, const char *bc)
	: m_Feature(nilIgnore),m_Capabilities(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("Permission");
}

StringBuffer &CPermission::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:complexType name=\"%s\">\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Feature\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Capabilities\" type=\"tns:ArrayOfCapability\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType>\n");
		}
	}
	if (!(flags & 0x10)  || (flags & 0x100))
	{
		CCapability::getXsdDefinition(context, request, schema, added);
	}
	if (added.getValue("Capability") && added.getValue("ArrayOfCapability")==NULL) {
		schema.append("<xsd:complexType name=\"ArrayOfCapability\">\n");
		schema.append("<xsd:sequence>\n");
		schema.append("<xsd:element minOccurs=\"0\" maxOccurs=\"unbounded\" name=\"Capability\" type=\"tns:Capability\"/>\n");
		schema.append("</xsd:sequence>\n");
		schema.append("</xsd:complexType>\n");
		added.setValue("ArrayOfCapability",1);
	}
	return schema;
}

void CPermission::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CPermission::getMapInfo(IMapInfo& info, BoolHash& added)
{
	if (!added.getValue("Capability"))
	{
		added.setValue("Capability",1);
		CCapability::getMapInfo(info,added);
	}
}

StringBuffer &CPermission::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Feature");
	form.appendf("  <tr><td><b>Feature: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Capabilities");
	form.appendf("<tr><td><b>Capabilities: </b></td><td>");
	form.appendf("<table><tr><td><textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea></td>", extfix.str());
	form.append("</tr></table>");
	form.append("</td></tr>");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CPermission::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CPermission::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_Feature.marshall(rpc_resp, "Feature", "", "", "");
	m_Capabilities.marshall(rpc_resp, "Capabilities", "Capability");
}


void CPermission::copy(CPermission &from)
{
	m_Feature.copy(from.m_Feature);
	m_Capabilities.copy(from.m_Capabilities);
}


void CPermission::copy(IConstPermission &ifrom)
{
	setFeature(ifrom.getFeature());
	setCapabilities(ifrom.getCapabilities());
}


void CPermission::getAttributes(IProperties &attributes)
{
}


void CPermission::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_Feature.toStr(ctx, buffer, "Feature", "", true, "", "");
	m_Capabilities.toStr(ctx, buffer, "Capabilities", "Capability");
}


void CPermission::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CPermission::serializer(IEspContext* ctx, IConstPermission &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<Permission>");
	// field Feature
	{
		const char* s = src.getFeature();
		if (s && *s)
		{
			buffer.append("<Feature>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Feature>");
		}
	}
	// field Capabilities
	{
		IArrayOf<IConstCapability>& v = src.getCapabilities();
		int size = v.length();
		if (size>0)
			buffer.append("<Capabilities>");
		for (int i=0;i<size;i++)
		{
			buffer.append("<Item>");
			CCapability::serializer(ctx,v.item(i),buffer,false);
			buffer.append("</Item>");
		}
		if (size>0)
			buffer.append("</Capabilities>");
	}
	if (keepRootTag)
		buffer.append("</Permission>");
}

bool CPermission::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_Feature.unmarshall(rpc_request, "Feature", basepath);
	hasValue |= m_Capabilities.unmarshall(rpc_request, "Capabilities", basepath);
	return hasValue;
}

bool CPermission::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Feature.unmarshall(ctx, soapval, "Feature");
	hasValue |= m_Capabilities.unmarshall(ctx, soapval, "Capabilities");
	return hasValue;
}

bool CPermission::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Feature.unmarshall(ctx, params, attachments, "Feature", basepath);
	hasValue |= m_Capabilities.unmarshall(ctx, params, attachments, "Capabilities", basepath);
	return hasValue;
}

const char * CPermission::getFeature() { return m_Feature.query();}
IArrayOf<IConstCapability> & CPermission::getCapabilities() { return (IArrayOf<IConstCapability> &) m_Capabilities; }
void CPermission::setFeature(const char * val){ m_Feature.set(val); }
void CPermission::setCapabilities(IArrayOf<IEspCapability> &val)
{
	m_Capabilities->kill();
	IArrayOf<IConstCapability> &target = m_Capabilities.getValue();
	ForEachItemIn(idx, val)
	{
		IEspCapability &item = (val).item(idx);
		item.Link();
		target.append(item);
	}
}
void CPermission::setCapabilities(IArrayOf<IConstCapability> &val)
{
	m_Capabilities->kill();
	IArrayOf<IConstCapability> &target = m_Capabilities.getValue();
	ForEachItemIn(idx, val)
	{
		IConstCapability &item = val.item(idx);
		item.Link();
		target.append(item);
	}
}
extern "C"  IEspPermission *createPermission(const char *serv, const char *msgname){return ((IEspPermission *)new CPermission(serv /*, msgname*/));}
extern "C"  IClientPermission *createClientPermission(const char *serv, const char *msgname){return ((IClientPermission *)new CPermission(serv /*, msgname*/));}

//=======================================================
// class CSMCPermissionsRequest Implementation
//=======================================================

CSMCPermissionsRequest::CSMCPermissionsRequest(const char *serviceName, IRpcMessageBinding *init)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("SMCPermissionsRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CSMCPermissionsRequest::CSMCPermissionsRequest(const char *serviceName, const char *bc)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("SMCPermissionsRequest");
}

CSMCPermissionsRequest::CSMCPermissionsRequest(const char *serviceName, IRpcMessage* rpcmsg)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("SMCPermissionsRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CSMCPermissionsRequest::CSMCPermissionsRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("SMCPermissionsRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CSMCPermissionsRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType><xsd:all/></xsd:complexType></xsd:element>\n", msgTypeName);
		}
	}
	return schema;
}

void CSMCPermissionsRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CSMCPermissionsRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CSMCPermissionsRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CSMCPermissionsRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CSMCPermissionsRequest::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

}


void CSMCPermissionsRequest::copy(CSMCPermissionsRequest &from)
{
}


void CSMCPermissionsRequest::copy(IConstSMCPermissionsRequest &ifrom)
{
}


void CSMCPermissionsRequest::getAttributes(IProperties &attributes)
{
}


void CSMCPermissionsRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
}


void CSMCPermissionsRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CSMCPermissionsRequest::serializer(IEspContext* ctx, IConstSMCPermissionsRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<SMCPermissionsRequest>");
	if (keepRootTag)
		buffer.append("</SMCPermissionsRequest>");
}

bool CSMCPermissionsRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	return hasValue;
}

bool CSMCPermissionsRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	return hasValue;
}

bool CSMCPermissionsRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	return hasValue;
}

extern "C"  IEspSMCPermissionsRequest *createSMCPermissionsRequest(const char *serv){return ((IEspSMCPermissionsRequest *)new CSMCPermissionsRequest(serv));}
extern "C"  IClientSMCPermissionsRequest *createClientSMCPermissionsRequest(const char *serv){return ((IClientSMCPermissionsRequest *)new CSMCPermissionsRequest(serv));}

//=======================================================
// class CSMCPermissionsResponse Implementation
//=======================================================

CSMCPermissionsResponse::CSMCPermissionsResponse(const char *serviceName, IRpcMessageBinding *init)
	: m_Permissions(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("SMCPermissionsResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CSMCPermissionsResponse::CSMCPermissionsResponse(const char *serviceName, const char *bc)
	: m_Permissions(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("SMCPermissionsResponse");
}

CSMCPermissionsResponse::CSMCPermissionsResponse(const char *serviceName, IRpcMessage* rpcmsg)
	: m_Permissions(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("SMCPermissionsResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CSMCPermissionsResponse::CSMCPermissionsResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_Permissions(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("SMCPermissionsResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CSMCPermissionsResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Permissions\" type=\"tns:ArrayOfPermission\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	if (!(flags & 0x10)  || (flags & 0x100))
	{
		CPermission::getXsdDefinition(context, request, schema, added);
	}
	if (added.getValue("Permission") && added.getValue("ArrayOfPermission")==NULL) {
		schema.append("<xsd:complexType name=\"ArrayOfPermission\">\n");
		schema.append("<xsd:sequence>\n");
		schema.append("<xsd:element minOccurs=\"0\" maxOccurs=\"unbounded\" name=\"Permission\" type=\"tns:Permission\"/>\n");
		schema.append("</xsd:sequence>\n");
		schema.append("</xsd:complexType>\n");
		added.setValue("ArrayOfPermission",1);
	}
	return schema;
}

void CSMCPermissionsResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CSMCPermissionsResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
	if (!added.getValue("Permission"))
	{
		added.setValue("Permission",1);
		CPermission::getMapInfo(info,added);
	}
}

StringBuffer &CSMCPermissionsResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Permissions");
	form.appendf("<tr><td><b>Permissions: </b></td><td>");
	form.appendf("<table><tr><td><textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea></td>", extfix.str());
	form.append("</tr></table>");
	form.append("</td></tr>");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CSMCPermissionsResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CSMCPermissionsResponse::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
		m_Permissions.marshall(rpc_resp, "Permissions", "Permission");
	}
}


void CSMCPermissionsResponse::copy(CSMCPermissionsResponse &from)
{
	m_Permissions.copy(from.m_Permissions);
}


void CSMCPermissionsResponse::copy(IConstSMCPermissionsResponse &ifrom)
{
	setPermissions(ifrom.getPermissions());
}


void CSMCPermissionsResponse::getAttributes(IProperties &attributes)
{
}


void CSMCPermissionsResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
		m_Permissions.toStr(ctx, buffer, "Permissions", "Permission");
	}
}


void CSMCPermissionsResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CSMCPermissionsResponse::serializer(IEspContext* ctx, IConstSMCPermissionsResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<SMCPermissionsResponse>");
	// field Permissions
	{
		IArrayOf<IConstPermission>& v = src.getPermissions();
		int size = v.length();
		if (size>0)
			buffer.append("<Permissions>");
		for (int i=0;i<size;i++)
		{
			buffer.append("<Item>");
			CPermission::serializer(ctx,v.item(i),buffer,false);
			buffer.append("</Item>");
		}
		if (size>0)
			buffer.append("</Permissions>");
	}
	if (keepRootTag)
		buffer.append("</SMCPermissionsResponse>");
}

bool CSMCPermissionsResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
		hasValue |= m_Permissions.unmarshall(rpc_request, "Permissions", basepath);
	}
	return hasValue;
}

bool CSMCPermissionsResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Permissions.unmarshall(ctx, soapval, "Permissions");
	return hasValue;
}

bool CSMCPermissionsResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Permissions.unmarshall(ctx, params, attachments, "Permissions", basepath);
	return hasValue;
}

IArrayOf<IConstPermission> & CSMCPermissionsResponse::getPermissions() { return (IArrayOf<IConstPermission> &) m_Permissions; }
void CSMCPermissionsResponse::setPermissions(IArrayOf<IEspPermission> &val)
{
	m_Permissions->kill();
	IArrayOf<IConstPermission> &target = m_Permissions.getValue();
	ForEachItemIn(idx, val)
	{
		IEspPermission &item = (val).item(idx);
		item.Link();
		target.append(item);
	}
}
void CSMCPermissionsResponse::setPermissions(IArrayOf<IConstPermission> &val)
{
	m_Permissions->kill();
	IArrayOf<IConstPermission> &target = m_Permissions.getValue();
	ForEachItemIn(idx, val)
	{
		IConstPermission &item = val.item(idx);
		item.Link();
		target.append(item);
	}
}
extern "C"  IEspSMCPermissionsResponse *createSMCPermissionsResponse(const char *serv){return ((IEspSMCPermissionsResponse *)new CSMCPermissionsResponse(serv));}
extern "C"  IClientSMCPermissionsResponse *createClientSMCPermissionsResponse(const char *serv){return ((IClientSMCPermissionsResponse *)new CSMCPermissionsResponse(serv));}

//=======================================================
// class CSMCQueueRequest Implementation
//=======================================================

CSMCQueueRequest::CSMCQueueRequest(const char *serviceName, IRpcMessageBinding *init)
	: m_Cluster(nilIgnore),m_QueueName(nilIgnore),m_Comment(nilIgnore),m_ServerType(nilIgnore),m_NetworkAddress(nilIgnore),m_Port(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("SMCQueueRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CSMCQueueRequest::CSMCQueueRequest(const char *serviceName, const char *bc)
	: m_Cluster(nilIgnore),m_QueueName(nilIgnore),m_Comment(nilIgnore),m_ServerType(nilIgnore),m_NetworkAddress(nilIgnore),m_Port(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("SMCQueueRequest");
}

CSMCQueueRequest::CSMCQueueRequest(const char *serviceName, IRpcMessage* rpcmsg)
	: m_Cluster(nilIgnore),m_QueueName(nilIgnore),m_Comment(nilIgnore),m_ServerType(nilIgnore),m_NetworkAddress(nilIgnore),m_Port(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("SMCQueueRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CSMCQueueRequest::CSMCQueueRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_Cluster(nilIgnore),m_QueueName(nilIgnore),m_Comment(nilIgnore),m_ServerType(nilIgnore),m_NetworkAddress(nilIgnore),m_Port(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("SMCQueueRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CSMCQueueRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Cluster\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"QueueName\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Comment\" type=\"xsd:string\"/>\n");
		if (!context.suppressed("SMCQueueRequest","ServerType")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"ServerType\" type=\"xsd:string\"/>\n");
		}
		if (!context.suppressed("SMCQueueRequest","NetworkAddress")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"NetworkAddress\" type=\"xsd:string\"/>\n");
		}
		if (!context.suppressed("SMCQueueRequest","Port")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"Port\" type=\"xsd:int\"/>\n");
		}
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CSMCQueueRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CSMCQueueRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
	info.addMinVersion("SMCQueueRequest","ServerType",1.19);
	info.addMinVersion("SMCQueueRequest","NetworkAddress",1.19);
	info.addMinVersion("SMCQueueRequest","Port",1.19);
}

StringBuffer &CSMCQueueRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Cluster");
	form.appendf("  <tr><td><b>Cluster: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("QueueName");
	form.appendf("  <tr><td><b>QueueName: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Comment");
	form.appendf("  <tr><td><b>Comment: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (!context.suppressed("SMCQueueRequest","ServerType")) {
		extfix.clear();
		if (prefix && *prefix)
			extfix.append(prefix).append(".");
		extfix.append("ServerType");
		form.appendf("  <tr><td><b>ServerType: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
		form.append("</td></tr>\n");
	}
	if (!context.suppressed("SMCQueueRequest","NetworkAddress")) {
		extfix.clear();
		if (prefix && *prefix)
			extfix.append(prefix).append(".");
		extfix.append("NetworkAddress");
		form.appendf("  <tr><td><b>NetworkAddress: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
		form.append("</td></tr>\n");
	}
	if (!context.suppressed("SMCQueueRequest","Port")) {
		extfix.clear();
		if (prefix && *prefix) extfix.append(prefix).append(".");
			extfix.append("Port");
		form.appendf("  <tr><td><b>Port: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
		form.append("</td></tr>\n");
	}
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CSMCQueueRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CSMCQueueRequest::serialize(IRpcMessage& rpc_resp)
{
	IEspContext* ctx = rpc_resp.queryContext();
	double clientVer= ctx ? ctx->getClientVersion() : -1; /* no context gets everything */
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_Cluster.marshall(rpc_resp, "Cluster", "", "", "");
	m_QueueName.marshall(rpc_resp, "QueueName", "", "", "");
	m_Comment.marshall(rpc_resp, "Comment", "", "", "");
	if ((clientVer==-1.0 || clientVer>=1.19))
		m_ServerType.marshall(rpc_resp, "ServerType", "", "", "");
	if ((clientVer==-1.0 || clientVer>=1.19))
		m_NetworkAddress.marshall(rpc_resp, "NetworkAddress", "", "", "");
	if ((clientVer==-1.0 || clientVer>=1.19))
		m_Port.marshall(rpc_resp, "Port", "", "", "");
}


void CSMCQueueRequest::copy(CSMCQueueRequest &from)
{
	m_Cluster.copy(from.m_Cluster);
	m_QueueName.copy(from.m_QueueName);
	m_Comment.copy(from.m_Comment);
	m_ServerType.copy(from.m_ServerType);
	m_NetworkAddress.copy(from.m_NetworkAddress);
	m_Port.copy(from.m_Port);
}


void CSMCQueueRequest::copy(IConstSMCQueueRequest &ifrom)
{
	setCluster(ifrom.getCluster());
	setQueueName(ifrom.getQueueName());
	setComment(ifrom.getComment());
	setServerType(ifrom.getServerType());
	setNetworkAddress(ifrom.getNetworkAddress());
	setPort(ifrom.getPort());
}


void CSMCQueueRequest::getAttributes(IProperties &attributes)
{
}


void CSMCQueueRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	double clientVer = ctx ? ctx->getClientVersion() : -1;
	m_Cluster.toStr(ctx, buffer, "Cluster", "", true, "", "");
	m_QueueName.toStr(ctx, buffer, "QueueName", "", true, "", "");
	m_Comment.toStr(ctx, buffer, "Comment", "", true, "", "");
	if ((clientVer==-1.0 || clientVer>=1.19))
		m_ServerType.toStr(ctx, buffer, "ServerType", "", true, "", "");
	if ((clientVer==-1.0 || clientVer>=1.19))
		m_NetworkAddress.toStr(ctx, buffer, "NetworkAddress", "", true, "", "");
	if ((clientVer==-1.0 || clientVer>=1.19))
		m_Port.toStr(ctx, buffer, "Port", "", true, "", "");
}


void CSMCQueueRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CSMCQueueRequest::serializer(IEspContext* ctx, IConstSMCQueueRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<SMCQueueRequest>");
	double clientVer = ctx ? ctx->getClientVersion() : -1;
	// field Cluster
	{
		const char* s = src.getCluster();
		if (s && *s)
		{
			buffer.append("<Cluster>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Cluster>");
		}
	}
	// field QueueName
	{
		const char* s = src.getQueueName();
		if (s && *s)
		{
			buffer.append("<QueueName>");
			encodeUtf8XML(s,buffer);
			buffer.append("</QueueName>");
		}
	}
	// field Comment
	{
		const char* s = src.getComment();
		if (s && *s)
		{
			buffer.append("<Comment>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Comment>");
		}
	}
	// field ServerType
	if ((clientVer==-1.0 || clientVer>=1.19))
	{
		const char* s = src.getServerType();
		if (s && *s)
		{
			buffer.append("<ServerType>");
			encodeUtf8XML(s,buffer);
			buffer.append("</ServerType>");
		}
	}
	// field NetworkAddress
	if ((clientVer==-1.0 || clientVer>=1.19))
	{
		const char* s = src.getNetworkAddress();
		if (s && *s)
		{
			buffer.append("<NetworkAddress>");
			encodeUtf8XML(s,buffer);
			buffer.append("</NetworkAddress>");
		}
	}
	// field Port
	if ((clientVer==-1.0 || clientVer>=1.19))
	{
		int n = src.getPort();
		if (n)
			buffer.appendf("<Port>%d</Port>", n);
	}
	if (keepRootTag)
		buffer.append("</SMCQueueRequest>");
}

bool CSMCQueueRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_Cluster.unmarshall(rpc_request, "Cluster", basepath);
	hasValue |= m_QueueName.unmarshall(rpc_request, "QueueName", basepath);
	hasValue |= m_Comment.unmarshall(rpc_request, "Comment", basepath);
	hasValue |= m_ServerType.unmarshall(rpc_request, "ServerType", basepath);
	hasValue |= m_NetworkAddress.unmarshall(rpc_request, "NetworkAddress", basepath);
	hasValue |= m_Port.unmarshall(rpc_request, "Port", basepath);
	return hasValue;
}

bool CSMCQueueRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Cluster.unmarshall(ctx, soapval, "Cluster");
	hasValue |= m_QueueName.unmarshall(ctx, soapval, "QueueName");
	hasValue |= m_Comment.unmarshall(ctx, soapval, "Comment");
	hasValue |= m_ServerType.unmarshall(ctx, soapval, "ServerType");
	hasValue |= m_NetworkAddress.unmarshall(ctx, soapval, "NetworkAddress");
	hasValue |= m_Port.unmarshall(ctx, soapval, "Port");
	return hasValue;
}

bool CSMCQueueRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Cluster.unmarshall(ctx, params, attachments, "Cluster", basepath);
	hasValue |= m_QueueName.unmarshall(ctx, params, attachments, "QueueName", basepath);
	hasValue |= m_Comment.unmarshall(ctx, params, attachments, "Comment", basepath);
	hasValue |= m_ServerType.unmarshall(ctx, params, attachments, "ServerType", basepath);
	hasValue |= m_NetworkAddress.unmarshall(ctx, params, attachments, "NetworkAddress", basepath);
	hasValue |= m_Port.unmarshall(ctx, params, attachments, "Port", basepath);
	return hasValue;
}

const char * CSMCQueueRequest::getCluster() { return m_Cluster.query();}
const char * CSMCQueueRequest::getQueueName() { return m_QueueName.query();}
const char * CSMCQueueRequest::getComment() { return m_Comment.query();}
const char * CSMCQueueRequest::getServerType() { return m_ServerType.query();}
const char * CSMCQueueRequest::getNetworkAddress() { return m_NetworkAddress.query();}
int CSMCQueueRequest::getPort() { return m_Port;}
void CSMCQueueRequest::setCluster(const char * val){ m_Cluster.set(val); }
void CSMCQueueRequest::setQueueName(const char * val){ m_QueueName.set(val); }
void CSMCQueueRequest::setComment(const char * val){ m_Comment.set(val); }
void CSMCQueueRequest::setServerType(const char * val){ m_ServerType.set(val); }
void CSMCQueueRequest::setNetworkAddress(const char * val){ m_NetworkAddress.set(val); }
void CSMCQueueRequest::setPort(int val){ m_Port=val; }
extern "C"  IEspSMCQueueRequest *createSMCQueueRequest(const char *serv){return ((IEspSMCQueueRequest *)new CSMCQueueRequest(serv));}
extern "C"  IClientSMCQueueRequest *createClientSMCQueueRequest(const char *serv){return ((IClientSMCQueueRequest *)new CSMCQueueRequest(serv));}

//=======================================================
// class CSMCQueueResponse Implementation
//=======================================================

CSMCQueueResponse::CSMCQueueResponse(const char *serviceName, IRpcMessageBinding *init)
	: m_StatusServerInfo(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("SMCQueueResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CSMCQueueResponse::CSMCQueueResponse(const char *serviceName, const char *bc)
	: m_StatusServerInfo(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("SMCQueueResponse");
}

CSMCQueueResponse::CSMCQueueResponse(const char *serviceName, IRpcMessage* rpcmsg)
	: m_StatusServerInfo(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("SMCQueueResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CSMCQueueResponse::CSMCQueueResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_StatusServerInfo(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("SMCQueueResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CSMCQueueResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		schema.append("<xsd:element name=\"Exceptions\" type=\"tns:ArrayOfEspException\" minOccurs=\"0\" maxOccurs=\"1\"/>");
		}
		if (!context.suppressed("SMCQueueResponse","StatusServerInfo")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"StatusServerInfo\" type=\"tns:StatusServerInfo\"/>\n");
		}
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	if (!(flags & 0x10)  || (flags & 0x100))
	{
		if (!context.suppressed("SMCQueueResponse","StatusServerInfo"))
			CStatusServerInfo::getXsdDefinition(context, request, schema, added);
	}
	return schema;
}

void CSMCQueueResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CSMCQueueResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
	info.addMinVersion("SMCQueueResponse","StatusServerInfo",1.19);
	if (!added.getValue("StatusServerInfo"))
	{
		added.setValue("StatusServerInfo",1);
		CStatusServerInfo::getMapInfo(info,added);
	}
}

StringBuffer &CSMCQueueResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	if (!context.suppressed("SMCQueueResponse","StatusServerInfo")) {
		extfix.clear();
		if (prefix && *prefix)
			extfix.append(prefix).append(".");
		extfix.append("StatusServerInfo");
		form.append("<tr>").append("<td><b>StatusServerInfo: </b></td><td><hr/>");
		CStatusServerInfo::getHtmlForm(context, request, serv, method, form, false, extfix.str());
		form.append("<hr/></td></tr>");
	}
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CSMCQueueResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CSMCQueueResponse::serialize(IRpcMessage& rpc_resp)
{
	IEspContext* ctx = rpc_resp.queryContext();
	double clientVer= ctx ? ctx->getClientVersion() : -1; /* no context gets everything */
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
		if ((clientVer==-1.0 || clientVer>=1.19))
			m_StatusServerInfo.marshall(rpc_resp, "StatusServerInfo", "", "", "");
	}
}


void CSMCQueueResponse::copy(CSMCQueueResponse &from)
{
	m_StatusServerInfo.copy(from.m_StatusServerInfo);
}


void CSMCQueueResponse::copy(IConstSMCQueueResponse &ifrom)
{
	setStatusServerInfo(ifrom.getStatusServerInfo());
}


void CSMCQueueResponse::getAttributes(IProperties &attributes)
{
}


void CSMCQueueResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
		double clientVer = ctx ? ctx->getClientVersion() : -1;
		if ((clientVer==-1.0 || clientVer>=1.19))
			m_StatusServerInfo.toStr(ctx, buffer, "StatusServerInfo", "", false, "", "");
	}
}


void CSMCQueueResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CSMCQueueResponse::serializer(IEspContext* ctx, IConstSMCQueueResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<SMCQueueResponse>");
	double clientVer = ctx ? ctx->getClientVersion() : -1;
	// field StatusServerInfo
	if ((clientVer==-1.0 || clientVer>=1.19))
	{
		StringBuffer tmp;
		CStatusServerInfo::serializer(ctx,src.getStatusServerInfo(), tmp, false);
		if (tmp.length()>0)
			buffer.appendf("<StatusServerInfo>%s</StatusServerInfo>",tmp.str());
	}
	if (keepRootTag)
		buffer.append("</SMCQueueResponse>");
}

bool CSMCQueueResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
		hasValue |= m_StatusServerInfo.unmarshall(rpc_request, "StatusServerInfo", basepath);
	}
	return hasValue;
}

bool CSMCQueueResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_StatusServerInfo.unmarshall(ctx, soapval, "StatusServerInfo");
	return hasValue;
}

bool CSMCQueueResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_StatusServerInfo.unmarshall(ctx, params, attachments, "StatusServerInfo", basepath);
	return hasValue;
}

IConstStatusServerInfo & CSMCQueueResponse::getStatusServerInfo() { return (IConstStatusServerInfo &) m_StatusServerInfo.getValue();}
IEspStatusServerInfo & CSMCQueueResponse::updateStatusServerInfo(){ return (IEspStatusServerInfo &) m_StatusServerInfo.getValue(); }
void CSMCQueueResponse::setStatusServerInfo(IConstStatusServerInfo &ifrom){ m_StatusServerInfo.copy(ifrom); }
extern "C"  IEspSMCQueueResponse *createSMCQueueResponse(const char *serv){return ((IEspSMCQueueResponse *)new CSMCQueueResponse(serv));}
extern "C"  IClientSMCQueueResponse *createClientSMCQueueResponse(const char *serv){return ((IClientSMCQueueResponse *)new CSMCQueueResponse(serv));}

//=======================================================
// class CSMCJobRequest Implementation
//=======================================================

CSMCJobRequest::CSMCJobRequest(const char *serviceName, IRpcMessageBinding *init)
	: m_ClusterType(nilIgnore),m_Cluster(nilIgnore),m_QueueName(nilIgnore),m_Wuid(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("SMCJobRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CSMCJobRequest::CSMCJobRequest(const char *serviceName, const char *bc)
	: m_ClusterType(nilIgnore),m_Cluster(nilIgnore),m_QueueName(nilIgnore),m_Wuid(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("SMCJobRequest");
}

CSMCJobRequest::CSMCJobRequest(const char *serviceName, IRpcMessage* rpcmsg)
	: m_ClusterType(nilIgnore),m_Cluster(nilIgnore),m_QueueName(nilIgnore),m_Wuid(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("SMCJobRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CSMCJobRequest::CSMCJobRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_ClusterType(nilIgnore),m_Cluster(nilIgnore),m_QueueName(nilIgnore),m_Wuid(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("SMCJobRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CSMCJobRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"ClusterType\" type=\"xsd:int\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Cluster\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"QueueName\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Wuid\" type=\"xsd:string\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CSMCJobRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CSMCJobRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CSMCJobRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix) extfix.append(prefix).append(".");
		extfix.append("ClusterType");
	form.appendf("  <tr><td><b>ClusterType: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Cluster");
	form.appendf("  <tr><td><b>Cluster: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("QueueName");
	form.appendf("  <tr><td><b>QueueName: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Wuid");
	form.appendf("  <tr><td><b>Wuid: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CSMCJobRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CSMCJobRequest::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_ClusterType.marshall(rpc_resp, "ClusterType", "", "", "");
	m_Cluster.marshall(rpc_resp, "Cluster", "", "", "");
	m_QueueName.marshall(rpc_resp, "QueueName", "", "", "");
	m_Wuid.marshall(rpc_resp, "Wuid", "", "", "");
}


void CSMCJobRequest::copy(CSMCJobRequest &from)
{
	m_ClusterType.copy(from.m_ClusterType);
	m_Cluster.copy(from.m_Cluster);
	m_QueueName.copy(from.m_QueueName);
	m_Wuid.copy(from.m_Wuid);
}


void CSMCJobRequest::copy(IConstSMCJobRequest &ifrom)
{
	setClusterType(ifrom.getClusterType());
	setCluster(ifrom.getCluster());
	setQueueName(ifrom.getQueueName());
	setWuid(ifrom.getWuid());
}


void CSMCJobRequest::getAttributes(IProperties &attributes)
{
}


void CSMCJobRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_ClusterType.toStr(ctx, buffer, "ClusterType", "", true, "", "");
	m_Cluster.toStr(ctx, buffer, "Cluster", "", true, "", "");
	m_QueueName.toStr(ctx, buffer, "QueueName", "", true, "", "");
	m_Wuid.toStr(ctx, buffer, "Wuid", "", true, "", "");
}


void CSMCJobRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CSMCJobRequest::serializer(IEspContext* ctx, IConstSMCJobRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<SMCJobRequest>");
	// field ClusterType
	{
		int n = src.getClusterType();
		if (n)
			buffer.appendf("<ClusterType>%d</ClusterType>", n);
	}
	// field Cluster
	{
		const char* s = src.getCluster();
		if (s && *s)
		{
			buffer.append("<Cluster>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Cluster>");
		}
	}
	// field QueueName
	{
		const char* s = src.getQueueName();
		if (s && *s)
		{
			buffer.append("<QueueName>");
			encodeUtf8XML(s,buffer);
			buffer.append("</QueueName>");
		}
	}
	// field Wuid
	{
		const char* s = src.getWuid();
		if (s && *s)
		{
			buffer.append("<Wuid>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Wuid>");
		}
	}
	if (keepRootTag)
		buffer.append("</SMCJobRequest>");
}

bool CSMCJobRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_ClusterType.unmarshall(rpc_request, "ClusterType", basepath);
	hasValue |= m_Cluster.unmarshall(rpc_request, "Cluster", basepath);
	hasValue |= m_QueueName.unmarshall(rpc_request, "QueueName", basepath);
	hasValue |= m_Wuid.unmarshall(rpc_request, "Wuid", basepath);
	return hasValue;
}

bool CSMCJobRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_ClusterType.unmarshall(ctx, soapval, "ClusterType");
	hasValue |= m_Cluster.unmarshall(ctx, soapval, "Cluster");
	hasValue |= m_QueueName.unmarshall(ctx, soapval, "QueueName");
	hasValue |= m_Wuid.unmarshall(ctx, soapval, "Wuid");
	return hasValue;
}

bool CSMCJobRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_ClusterType.unmarshall(ctx, params, attachments, "ClusterType", basepath);
	hasValue |= m_Cluster.unmarshall(ctx, params, attachments, "Cluster", basepath);
	hasValue |= m_QueueName.unmarshall(ctx, params, attachments, "QueueName", basepath);
	hasValue |= m_Wuid.unmarshall(ctx, params, attachments, "Wuid", basepath);
	return hasValue;
}

int CSMCJobRequest::getClusterType() { return m_ClusterType;}
const char * CSMCJobRequest::getCluster() { return m_Cluster.query();}
const char * CSMCJobRequest::getQueueName() { return m_QueueName.query();}
const char * CSMCJobRequest::getWuid() { return m_Wuid.query();}
void CSMCJobRequest::setClusterType(int val){ m_ClusterType=val; }
void CSMCJobRequest::setCluster(const char * val){ m_Cluster.set(val); }
void CSMCJobRequest::setQueueName(const char * val){ m_QueueName.set(val); }
void CSMCJobRequest::setWuid(const char * val){ m_Wuid.set(val); }
extern "C"  IEspSMCJobRequest *createSMCJobRequest(const char *serv){return ((IEspSMCJobRequest *)new CSMCJobRequest(serv));}
extern "C"  IClientSMCJobRequest *createClientSMCJobRequest(const char *serv){return ((IClientSMCJobRequest *)new CSMCJobRequest(serv));}

//=======================================================
// class CSMCJobResponse Implementation
//=======================================================

CSMCJobResponse::CSMCJobResponse(const char *serviceName, IRpcMessageBinding *init)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("SMCJobResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CSMCJobResponse::CSMCJobResponse(const char *serviceName, const char *bc)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("SMCJobResponse");
}

CSMCJobResponse::CSMCJobResponse(const char *serviceName, IRpcMessage* rpcmsg)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("SMCJobResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CSMCJobResponse::CSMCJobResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("SMCJobResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CSMCJobResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		schema.append("<xsd:element name=\"Exceptions\" type=\"tns:ArrayOfEspException\" minOccurs=\"0\" maxOccurs=\"1\"/>");
		}
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CSMCJobResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CSMCJobResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CSMCJobResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CSMCJobResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CSMCJobResponse::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
	}
}


void CSMCJobResponse::copy(CSMCJobResponse &from)
{
}


void CSMCJobResponse::copy(IConstSMCJobResponse &ifrom)
{
}


void CSMCJobResponse::getAttributes(IProperties &attributes)
{
}


void CSMCJobResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
	}
}


void CSMCJobResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CSMCJobResponse::serializer(IEspContext* ctx, IConstSMCJobResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<SMCJobResponse>");
	if (keepRootTag)
		buffer.append("</SMCJobResponse>");
}

bool CSMCJobResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
	}
	return hasValue;
}

bool CSMCJobResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	return hasValue;
}

bool CSMCJobResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	return hasValue;
}

extern "C"  IEspSMCJobResponse *createSMCJobResponse(const char *serv){return ((IEspSMCJobResponse *)new CSMCJobResponse(serv));}
extern "C"  IClientSMCJobResponse *createClientSMCJobResponse(const char *serv){return ((IClientSMCJobResponse *)new CSMCJobResponse(serv));}

//=======================================================
// class CSMCJob Implementation
//=======================================================

CSMCJob::CSMCJob(const char *serviceName, IRpcMessageBinding *init)
	: m_Wuid(nilIgnore),m_QueueName(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("SMCJob");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CSMCJob::CSMCJob(const char *serviceName, const char *bc)
	: m_Wuid(nilIgnore),m_QueueName(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("SMCJob");
}

StringBuffer &CSMCJob::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:complexType name=\"%s\">\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Wuid\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"QueueName\" type=\"xsd:string\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType>\n");
		}
	}
	return schema;
}

void CSMCJob::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CSMCJob::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CSMCJob::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Wuid");
	form.appendf("  <tr><td><b>Wuid: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("QueueName");
	form.appendf("  <tr><td><b>QueueName: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CSMCJob::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CSMCJob::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_Wuid.marshall(rpc_resp, "Wuid", "", "", "");
	m_QueueName.marshall(rpc_resp, "QueueName", "", "", "");
}


void CSMCJob::copy(CSMCJob &from)
{
	m_Wuid.copy(from.m_Wuid);
	m_QueueName.copy(from.m_QueueName);
}


void CSMCJob::copy(IConstSMCJob &ifrom)
{
	setWuid(ifrom.getWuid());
	setQueueName(ifrom.getQueueName());
}


void CSMCJob::getAttributes(IProperties &attributes)
{
}


void CSMCJob::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_Wuid.toStr(ctx, buffer, "Wuid", "", true, "", "");
	m_QueueName.toStr(ctx, buffer, "QueueName", "", true, "", "");
}


void CSMCJob::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CSMCJob::serializer(IEspContext* ctx, IConstSMCJob &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<SMCJob>");
	// field Wuid
	{
		const char* s = src.getWuid();
		if (s && *s)
		{
			buffer.append("<Wuid>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Wuid>");
		}
	}
	// field QueueName
	{
		const char* s = src.getQueueName();
		if (s && *s)
		{
			buffer.append("<QueueName>");
			encodeUtf8XML(s,buffer);
			buffer.append("</QueueName>");
		}
	}
	if (keepRootTag)
		buffer.append("</SMCJob>");
}

bool CSMCJob::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_Wuid.unmarshall(rpc_request, "Wuid", basepath);
	hasValue |= m_QueueName.unmarshall(rpc_request, "QueueName", basepath);
	return hasValue;
}

bool CSMCJob::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Wuid.unmarshall(ctx, soapval, "Wuid");
	hasValue |= m_QueueName.unmarshall(ctx, soapval, "QueueName");
	return hasValue;
}

bool CSMCJob::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Wuid.unmarshall(ctx, params, attachments, "Wuid", basepath);
	hasValue |= m_QueueName.unmarshall(ctx, params, attachments, "QueueName", basepath);
	return hasValue;
}

const char * CSMCJob::getWuid() { return m_Wuid.query();}
const char * CSMCJob::getQueueName() { return m_QueueName.query();}
void CSMCJob::setWuid(const char * val){ m_Wuid.set(val); }
void CSMCJob::setQueueName(const char * val){ m_QueueName.set(val); }
extern "C"  IEspSMCJob *createSMCJob(const char *serv, const char *msgname){return ((IEspSMCJob *)new CSMCJob(serv /*, msgname*/));}
extern "C"  IClientSMCJob *createClientSMCJob(const char *serv, const char *msgname){return ((IClientSMCJob *)new CSMCJob(serv /*, msgname*/));}

//=======================================================
// class CSMCPriorityRequest Implementation
//=======================================================

CSMCPriorityRequest::CSMCPriorityRequest(const char *serviceName, IRpcMessageBinding *init)
	: m_ClusterType(nilIgnore),m_Cluster(nilIgnore),m_QueueName(nilIgnore),m_Wuid(nilIgnore),m_Priority(nilIgnore),m_SMCJobs(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("SMCPriorityRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CSMCPriorityRequest::CSMCPriorityRequest(const char *serviceName, const char *bc)
	: m_ClusterType(nilIgnore),m_Cluster(nilIgnore),m_QueueName(nilIgnore),m_Wuid(nilIgnore),m_Priority(nilIgnore),m_SMCJobs(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("SMCPriorityRequest");
}

CSMCPriorityRequest::CSMCPriorityRequest(const char *serviceName, IRpcMessage* rpcmsg)
	: m_ClusterType(nilIgnore),m_Cluster(nilIgnore),m_QueueName(nilIgnore),m_Wuid(nilIgnore),m_Priority(nilIgnore),m_SMCJobs(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("SMCPriorityRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CSMCPriorityRequest::CSMCPriorityRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_ClusterType(nilIgnore),m_Cluster(nilIgnore),m_QueueName(nilIgnore),m_Wuid(nilIgnore),m_Priority(nilIgnore),m_SMCJobs(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("SMCPriorityRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CSMCPriorityRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		if (!context.suppressed("SMCPriorityRequest","ClusterType")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"ClusterType\" type=\"xsd:int\"/>\n");
		}
		if (!context.suppressed("SMCPriorityRequest","Cluster")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"Cluster\" type=\"xsd:string\"/>\n");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"QueueName\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Wuid\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Priority\" type=\"xsd:string\"/>\n");
		if (!context.suppressed("SMCPriorityRequest","SMCJobs")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"SMCJobs\" type=\"tns:ArrayOfSMCJob\"/>\n");
		}
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	if (!(flags & 0x10)  || (flags & 0x100))
	{
		if (!context.suppressed("SMCPriorityRequest","SMCJobs"))
			CSMCJob::getXsdDefinition(context, request, schema, added);
	}
	if (added.getValue("SMCJob") && added.getValue("ArrayOfSMCJob")==NULL) {
		schema.append("<xsd:complexType name=\"ArrayOfSMCJob\">\n");
		schema.append("<xsd:sequence>\n");
		schema.append("<xsd:element minOccurs=\"0\" maxOccurs=\"unbounded\" name=\"SMCJob\" type=\"tns:SMCJob\"/>\n");
		schema.append("</xsd:sequence>\n");
		schema.append("</xsd:complexType>\n");
		added.setValue("ArrayOfSMCJob",1);
	}
	return schema;
}

void CSMCPriorityRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CSMCPriorityRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
	info.addDeprVersion("SMCPriorityRequest","ClusterType",1.18);
	info.addDeprVersion("SMCPriorityRequest","Cluster",1.18);
	info.addMinVersion("SMCPriorityRequest","SMCJobs",1.18);
	if (!added.getValue("SMCJob"))
	{
		added.setValue("SMCJob",1);
		CSMCJob::getMapInfo(info,added);
	}
}

StringBuffer &CSMCPriorityRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	if (!context.suppressed("SMCPriorityRequest","ClusterType")) {
		extfix.clear();
		if (prefix && *prefix) extfix.append(prefix).append(".");
			extfix.append("ClusterType");
		form.appendf("  <tr><td><b>ClusterType: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
		form.append("</td></tr>\n");
	}
	if (!context.suppressed("SMCPriorityRequest","Cluster")) {
		extfix.clear();
		if (prefix && *prefix)
			extfix.append(prefix).append(".");
		extfix.append("Cluster");
		form.appendf("  <tr><td><b>Cluster: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
		form.append("</td></tr>\n");
	}
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("QueueName");
	form.appendf("  <tr><td><b>QueueName: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Wuid");
	form.appendf("  <tr><td><b>Wuid: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Priority");
	form.appendf("  <tr><td><b>Priority: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (!context.suppressed("SMCPriorityRequest","SMCJobs")) {
		extfix.clear();
		if (prefix && *prefix)
			extfix.append(prefix).append(".");
		extfix.append("SMCJobs");
		form.appendf("<tr><td><b>SMCJobs: </b></td><td>");
		form.appendf("<table><tr><td><textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea></td>", extfix.str());
		form.append("</tr></table>");
		form.append("</td></tr>");
	}
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CSMCPriorityRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CSMCPriorityRequest::serialize(IRpcMessage& rpc_resp)
{
	IEspContext* ctx = rpc_resp.queryContext();
	double clientVer= ctx ? ctx->getClientVersion() : -1; /* no context gets everything */
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	if ((clientVer==-1.0 || clientVer<1.18))
		m_ClusterType.marshall(rpc_resp, "ClusterType", "", "", "");
	if ((clientVer==-1.0 || clientVer<1.18))
		m_Cluster.marshall(rpc_resp, "Cluster", "", "", "");
	m_QueueName.marshall(rpc_resp, "QueueName", "", "", "");
	m_Wuid.marshall(rpc_resp, "Wuid", "", "", "");
	m_Priority.marshall(rpc_resp, "Priority", "", "", "");
	if ((clientVer==-1.0 || clientVer>=1.18))
		m_SMCJobs.marshall(rpc_resp, "SMCJobs", "SMCJob");
}


void CSMCPriorityRequest::copy(CSMCPriorityRequest &from)
{
	m_ClusterType.copy(from.m_ClusterType);
	m_Cluster.copy(from.m_Cluster);
	m_QueueName.copy(from.m_QueueName);
	m_Wuid.copy(from.m_Wuid);
	m_Priority.copy(from.m_Priority);
	m_SMCJobs.copy(from.m_SMCJobs);
}


void CSMCPriorityRequest::copy(IConstSMCPriorityRequest &ifrom)
{
	setClusterType(ifrom.getClusterType());
	setCluster(ifrom.getCluster());
	setQueueName(ifrom.getQueueName());
	setWuid(ifrom.getWuid());
	setPriority(ifrom.getPriority());
	setSMCJobs(ifrom.getSMCJobs());
}


void CSMCPriorityRequest::getAttributes(IProperties &attributes)
{
}


void CSMCPriorityRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	double clientVer = ctx ? ctx->getClientVersion() : -1;
	if ((clientVer==-1.0 || clientVer<1.18))
		m_ClusterType.toStr(ctx, buffer, "ClusterType", "", true, "", "");
	if ((clientVer==-1.0 || clientVer<1.18))
		m_Cluster.toStr(ctx, buffer, "Cluster", "", true, "", "");
	m_QueueName.toStr(ctx, buffer, "QueueName", "", true, "", "");
	m_Wuid.toStr(ctx, buffer, "Wuid", "", true, "", "");
	m_Priority.toStr(ctx, buffer, "Priority", "", true, "", "");
	if ((clientVer==-1.0 || clientVer>=1.18))
		m_SMCJobs.toStr(ctx, buffer, "SMCJobs", "SMCJob");
}


void CSMCPriorityRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CSMCPriorityRequest::serializer(IEspContext* ctx, IConstSMCPriorityRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<SMCPriorityRequest>");
	double clientVer = ctx ? ctx->getClientVersion() : -1;
	// field ClusterType
	if ((clientVer==-1.0 || clientVer<1.18))
	{
		int n = src.getClusterType();
		if (n)
			buffer.appendf("<ClusterType>%d</ClusterType>", n);
	}
	// field Cluster
	if ((clientVer==-1.0 || clientVer<1.18))
	{
		const char* s = src.getCluster();
		if (s && *s)
		{
			buffer.append("<Cluster>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Cluster>");
		}
	}
	// field QueueName
	{
		const char* s = src.getQueueName();
		if (s && *s)
		{
			buffer.append("<QueueName>");
			encodeUtf8XML(s,buffer);
			buffer.append("</QueueName>");
		}
	}
	// field Wuid
	{
		const char* s = src.getWuid();
		if (s && *s)
		{
			buffer.append("<Wuid>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Wuid>");
		}
	}
	// field Priority
	{
		const char* s = src.getPriority();
		if (s && *s)
		{
			buffer.append("<Priority>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Priority>");
		}
	}
	// field SMCJobs
	if ((clientVer==-1.0 || clientVer>=1.18))
	{
		IArrayOf<IConstSMCJob>& v = src.getSMCJobs();
		int size = v.length();
		if (size>0)
			buffer.append("<SMCJobs>");
		for (int i=0;i<size;i++)
		{
			buffer.append("<Item>");
			CSMCJob::serializer(ctx,v.item(i),buffer,false);
			buffer.append("</Item>");
		}
		if (size>0)
			buffer.append("</SMCJobs>");
	}
	if (keepRootTag)
		buffer.append("</SMCPriorityRequest>");
}

bool CSMCPriorityRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_ClusterType.unmarshall(rpc_request, "ClusterType", basepath);
	hasValue |= m_Cluster.unmarshall(rpc_request, "Cluster", basepath);
	hasValue |= m_QueueName.unmarshall(rpc_request, "QueueName", basepath);
	hasValue |= m_Wuid.unmarshall(rpc_request, "Wuid", basepath);
	hasValue |= m_Priority.unmarshall(rpc_request, "Priority", basepath);
	hasValue |= m_SMCJobs.unmarshall(rpc_request, "SMCJobs", basepath);
	return hasValue;
}

bool CSMCPriorityRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_ClusterType.unmarshall(ctx, soapval, "ClusterType");
	hasValue |= m_Cluster.unmarshall(ctx, soapval, "Cluster");
	hasValue |= m_QueueName.unmarshall(ctx, soapval, "QueueName");
	hasValue |= m_Wuid.unmarshall(ctx, soapval, "Wuid");
	hasValue |= m_Priority.unmarshall(ctx, soapval, "Priority");
	hasValue |= m_SMCJobs.unmarshall(ctx, soapval, "SMCJobs");
	return hasValue;
}

bool CSMCPriorityRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_ClusterType.unmarshall(ctx, params, attachments, "ClusterType", basepath);
	hasValue |= m_Cluster.unmarshall(ctx, params, attachments, "Cluster", basepath);
	hasValue |= m_QueueName.unmarshall(ctx, params, attachments, "QueueName", basepath);
	hasValue |= m_Wuid.unmarshall(ctx, params, attachments, "Wuid", basepath);
	hasValue |= m_Priority.unmarshall(ctx, params, attachments, "Priority", basepath);
	hasValue |= m_SMCJobs.unmarshall(ctx, params, attachments, "SMCJobs", basepath);
	return hasValue;
}

int CSMCPriorityRequest::getClusterType() { return m_ClusterType;}
const char * CSMCPriorityRequest::getCluster() { return m_Cluster.query();}
const char * CSMCPriorityRequest::getQueueName() { return m_QueueName.query();}
const char * CSMCPriorityRequest::getWuid() { return m_Wuid.query();}
const char * CSMCPriorityRequest::getPriority() { return m_Priority.query();}
IArrayOf<IConstSMCJob> & CSMCPriorityRequest::getSMCJobs() { return (IArrayOf<IConstSMCJob> &) m_SMCJobs; }
void CSMCPriorityRequest::setClusterType(int val){ m_ClusterType=val; }
void CSMCPriorityRequest::setCluster(const char * val){ m_Cluster.set(val); }
void CSMCPriorityRequest::setQueueName(const char * val){ m_QueueName.set(val); }
void CSMCPriorityRequest::setWuid(const char * val){ m_Wuid.set(val); }
void CSMCPriorityRequest::setPriority(const char * val){ m_Priority.set(val); }
void CSMCPriorityRequest::setSMCJobs(IArrayOf<IEspSMCJob> &val)
{
	m_SMCJobs->kill();
	IArrayOf<IConstSMCJob> &target = m_SMCJobs.getValue();
	ForEachItemIn(idx, val)
	{
		IEspSMCJob &item = (val).item(idx);
		item.Link();
		target.append(item);
	}
}
void CSMCPriorityRequest::setSMCJobs(IArrayOf<IConstSMCJob> &val)
{
	m_SMCJobs->kill();
	IArrayOf<IConstSMCJob> &target = m_SMCJobs.getValue();
	ForEachItemIn(idx, val)
	{
		IConstSMCJob &item = val.item(idx);
		item.Link();
		target.append(item);
	}
}
extern "C"  IEspSMCPriorityRequest *createSMCPriorityRequest(const char *serv){return ((IEspSMCPriorityRequest *)new CSMCPriorityRequest(serv));}
extern "C"  IClientSMCPriorityRequest *createClientSMCPriorityRequest(const char *serv){return ((IClientSMCPriorityRequest *)new CSMCPriorityRequest(serv));}

//=======================================================
// class CSMCPriorityResponse Implementation
//=======================================================

CSMCPriorityResponse::CSMCPriorityResponse(const char *serviceName, IRpcMessageBinding *init)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("SMCPriorityResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CSMCPriorityResponse::CSMCPriorityResponse(const char *serviceName, const char *bc)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("SMCPriorityResponse");
}

CSMCPriorityResponse::CSMCPriorityResponse(const char *serviceName, IRpcMessage* rpcmsg)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("SMCPriorityResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CSMCPriorityResponse::CSMCPriorityResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("SMCPriorityResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CSMCPriorityResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		schema.append("<xsd:element name=\"Exceptions\" type=\"tns:ArrayOfEspException\" minOccurs=\"0\" maxOccurs=\"1\"/>");
		}
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CSMCPriorityResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CSMCPriorityResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CSMCPriorityResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CSMCPriorityResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CSMCPriorityResponse::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
	}
}


void CSMCPriorityResponse::copy(CSMCPriorityResponse &from)
{
}


void CSMCPriorityResponse::copy(IConstSMCPriorityResponse &ifrom)
{
}


void CSMCPriorityResponse::getAttributes(IProperties &attributes)
{
}


void CSMCPriorityResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
	}
}


void CSMCPriorityResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CSMCPriorityResponse::serializer(IEspContext* ctx, IConstSMCPriorityResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<SMCPriorityResponse>");
	if (keepRootTag)
		buffer.append("</SMCPriorityResponse>");
}

bool CSMCPriorityResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
	}
	return hasValue;
}

bool CSMCPriorityResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	return hasValue;
}

bool CSMCPriorityResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	return hasValue;
}

extern "C"  IEspSMCPriorityResponse *createSMCPriorityResponse(const char *serv){return ((IEspSMCPriorityResponse *)new CSMCPriorityResponse(serv));}
extern "C"  IClientSMCPriorityResponse *createClientSMCPriorityResponse(const char *serv){return ((IClientSMCPriorityResponse *)new CSMCPriorityResponse(serv));}

//=======================================================
// class CGetThorQueueAvailabilityRequest Implementation
//=======================================================

CGetThorQueueAvailabilityRequest::CGetThorQueueAvailabilityRequest(const char *serviceName, IRpcMessageBinding *init)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetThorQueueAvailabilityRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CGetThorQueueAvailabilityRequest::CGetThorQueueAvailabilityRequest(const char *serviceName, const char *bc)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetThorQueueAvailabilityRequest");
}

CGetThorQueueAvailabilityRequest::CGetThorQueueAvailabilityRequest(const char *serviceName, IRpcMessage* rpcmsg)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetThorQueueAvailabilityRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CGetThorQueueAvailabilityRequest::CGetThorQueueAvailabilityRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetThorQueueAvailabilityRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CGetThorQueueAvailabilityRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType><xsd:all/></xsd:complexType></xsd:element>\n", msgTypeName);
		}
	}
	return schema;
}

void CGetThorQueueAvailabilityRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CGetThorQueueAvailabilityRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CGetThorQueueAvailabilityRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CGetThorQueueAvailabilityRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CGetThorQueueAvailabilityRequest::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

}


void CGetThorQueueAvailabilityRequest::copy(CGetThorQueueAvailabilityRequest &from)
{
}


void CGetThorQueueAvailabilityRequest::copy(IConstGetThorQueueAvailabilityRequest &ifrom)
{
}


void CGetThorQueueAvailabilityRequest::getAttributes(IProperties &attributes)
{
}


void CGetThorQueueAvailabilityRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
}


void CGetThorQueueAvailabilityRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CGetThorQueueAvailabilityRequest::serializer(IEspContext* ctx, IConstGetThorQueueAvailabilityRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<GetThorQueueAvailabilityRequest>");
	if (keepRootTag)
		buffer.append("</GetThorQueueAvailabilityRequest>");
}

bool CGetThorQueueAvailabilityRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	return hasValue;
}

bool CGetThorQueueAvailabilityRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	return hasValue;
}

bool CGetThorQueueAvailabilityRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	return hasValue;
}

extern "C"  IEspGetThorQueueAvailabilityRequest *createGetThorQueueAvailabilityRequest(const char *serv){return ((IEspGetThorQueueAvailabilityRequest *)new CGetThorQueueAvailabilityRequest(serv));}
extern "C"  IClientGetThorQueueAvailabilityRequest *createClientGetThorQueueAvailabilityRequest(const char *serv){return ((IClientGetThorQueueAvailabilityRequest *)new CGetThorQueueAvailabilityRequest(serv));}

//=======================================================
// class CGetThorQueueAvailabilityResponse Implementation
//=======================================================

CGetThorQueueAvailabilityResponse::CGetThorQueueAvailabilityResponse(const char *serviceName, IRpcMessageBinding *init)
	: m_ThorClusters(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetThorQueueAvailabilityResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CGetThorQueueAvailabilityResponse::CGetThorQueueAvailabilityResponse(const char *serviceName, const char *bc)
	: m_ThorClusters(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetThorQueueAvailabilityResponse");
}

CGetThorQueueAvailabilityResponse::CGetThorQueueAvailabilityResponse(const char *serviceName, IRpcMessage* rpcmsg)
	: m_ThorClusters(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetThorQueueAvailabilityResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CGetThorQueueAvailabilityResponse::CGetThorQueueAvailabilityResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_ThorClusters(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetThorQueueAvailabilityResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CGetThorQueueAvailabilityResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		schema.append("<xsd:element name=\"Exceptions\" type=\"tns:ArrayOfEspException\" minOccurs=\"0\" maxOccurs=\"1\"/>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"ThorClusters\" type=\"tns:ArrayOfThorCluster\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	if (!(flags & 0x10)  || (flags & 0x100))
	{
		CThorCluster::getXsdDefinition(context, request, schema, added);
	}
	if (added.getValue("ThorCluster") && added.getValue("ArrayOfThorCluster")==NULL) {
		schema.append("<xsd:complexType name=\"ArrayOfThorCluster\">\n");
		schema.append("<xsd:sequence>\n");
		schema.append("<xsd:element minOccurs=\"0\" maxOccurs=\"unbounded\" name=\"ThorCluster\" type=\"tns:ThorCluster\"/>\n");
		schema.append("</xsd:sequence>\n");
		schema.append("</xsd:complexType>\n");
		added.setValue("ArrayOfThorCluster",1);
	}
	return schema;
}

void CGetThorQueueAvailabilityResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CGetThorQueueAvailabilityResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
	if (!added.getValue("ThorCluster"))
	{
		added.setValue("ThorCluster",1);
		CThorCluster::getMapInfo(info,added);
	}
}

StringBuffer &CGetThorQueueAvailabilityResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("ThorClusters");
	form.appendf("<tr><td><b>ThorClusters: </b></td><td>");
	form.appendf("<table><tr><td><textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea></td>", extfix.str());
	form.append("</tr></table>");
	form.append("</td></tr>");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CGetThorQueueAvailabilityResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CGetThorQueueAvailabilityResponse::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
		m_ThorClusters.marshall(rpc_resp, "ThorClusters", "ThorCluster");
	}
}


void CGetThorQueueAvailabilityResponse::copy(CGetThorQueueAvailabilityResponse &from)
{
	m_ThorClusters.copy(from.m_ThorClusters);
}


void CGetThorQueueAvailabilityResponse::copy(IConstGetThorQueueAvailabilityResponse &ifrom)
{
	setThorClusters(ifrom.getThorClusters());
}


void CGetThorQueueAvailabilityResponse::getAttributes(IProperties &attributes)
{
}


void CGetThorQueueAvailabilityResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
		m_ThorClusters.toStr(ctx, buffer, "ThorClusters", "ThorCluster");
	}
}


void CGetThorQueueAvailabilityResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CGetThorQueueAvailabilityResponse::serializer(IEspContext* ctx, IConstGetThorQueueAvailabilityResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<GetThorQueueAvailabilityResponse>");
	// field ThorClusters
	{
		IArrayOf<IConstThorCluster>& v = src.getThorClusters();
		int size = v.length();
		if (size>0)
			buffer.append("<ThorClusters>");
		for (int i=0;i<size;i++)
		{
			buffer.append("<Item>");
			CThorCluster::serializer(ctx,v.item(i),buffer,false);
			buffer.append("</Item>");
		}
		if (size>0)
			buffer.append("</ThorClusters>");
	}
	if (keepRootTag)
		buffer.append("</GetThorQueueAvailabilityResponse>");
}

bool CGetThorQueueAvailabilityResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
		hasValue |= m_ThorClusters.unmarshall(rpc_request, "ThorClusters", basepath);
	}
	return hasValue;
}

bool CGetThorQueueAvailabilityResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_ThorClusters.unmarshall(ctx, soapval, "ThorClusters");
	return hasValue;
}

bool CGetThorQueueAvailabilityResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_ThorClusters.unmarshall(ctx, params, attachments, "ThorClusters", basepath);
	return hasValue;
}

IArrayOf<IConstThorCluster> & CGetThorQueueAvailabilityResponse::getThorClusters() { return (IArrayOf<IConstThorCluster> &) m_ThorClusters; }
void CGetThorQueueAvailabilityResponse::setThorClusters(IArrayOf<IEspThorCluster> &val)
{
	m_ThorClusters->kill();
	IArrayOf<IConstThorCluster> &target = m_ThorClusters.getValue();
	ForEachItemIn(idx, val)
	{
		IEspThorCluster &item = (val).item(idx);
		item.Link();
		target.append(item);
	}
}
void CGetThorQueueAvailabilityResponse::setThorClusters(IArrayOf<IConstThorCluster> &val)
{
	m_ThorClusters->kill();
	IArrayOf<IConstThorCluster> &target = m_ThorClusters.getValue();
	ForEachItemIn(idx, val)
	{
		IConstThorCluster &item = val.item(idx);
		item.Link();
		target.append(item);
	}
}
extern "C"  IEspGetThorQueueAvailabilityResponse *createGetThorQueueAvailabilityResponse(const char *serv){return ((IEspGetThorQueueAvailabilityResponse *)new CGetThorQueueAvailabilityResponse(serv));}
extern "C"  IClientGetThorQueueAvailabilityResponse *createClientGetThorQueueAvailabilityResponse(const char *serv){return ((IClientGetThorQueueAvailabilityResponse *)new CGetThorQueueAvailabilityResponse(serv));}

//=======================================================
// class CSetBannerRequest Implementation
//=======================================================

CSetBannerRequest::CSetBannerRequest(const char *serviceName, IRpcMessageBinding *init)
	: m_ChatURL(nilRemove),m_BannerContent(nilRemove),m_BannerColor(nilRemove),m_BannerSize(nilRemove),m_BannerScroll(nilRemove),m_BannerAction(nilRemove),m_EnableChatURL(nilRemove),m_FromSubmitBtn(0, nilRemove,false)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("SetBannerRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CSetBannerRequest::CSetBannerRequest(const char *serviceName, const char *bc)
	: m_ChatURL(nilRemove),m_BannerContent(nilRemove),m_BannerColor(nilRemove),m_BannerSize(nilRemove),m_BannerScroll(nilRemove),m_BannerAction(nilRemove),m_EnableChatURL(nilRemove),m_FromSubmitBtn(0, nilRemove,false)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("SetBannerRequest");
}

CSetBannerRequest::CSetBannerRequest(const char *serviceName, IRpcMessage* rpcmsg)
	: m_ChatURL(nilRemove),m_BannerContent(nilRemove),m_BannerColor(nilRemove),m_BannerSize(nilRemove),m_BannerScroll(nilRemove),m_BannerAction(nilRemove),m_EnableChatURL(nilRemove),m_FromSubmitBtn(0, nilRemove,false)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("SetBannerRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CSetBannerRequest::CSetBannerRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_ChatURL(nilRemove),m_BannerContent(nilRemove),m_BannerColor(nilRemove),m_BannerSize(nilRemove),m_BannerScroll(nilRemove),m_BannerAction(nilRemove),m_EnableChatURL(nilRemove),m_FromSubmitBtn(0, nilRemove,false)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("SetBannerRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CSetBannerRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"ChatURL\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"BannerContent\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"BannerColor\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"BannerSize\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"BannerScroll\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"BannerAction\" type=\"xsd:int\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"EnableChatURL\" type=\"xsd:boolean\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" default=\"false\" name=\"FromSubmitBtn\" type=\"xsd:boolean\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CSetBannerRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CSetBannerRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CSetBannerRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("ChatURL");
	form.appendf("  <tr><td><b>ChatURL: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("BannerContent");
	form.appendf("  <tr><td><b>BannerContent: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("BannerColor");
	form.appendf("  <tr><td><b>BannerColor: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("BannerSize");
	form.appendf("  <tr><td><b>BannerSize: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("BannerScroll");
	form.appendf("  <tr><td><b>BannerScroll: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix) extfix.append(prefix).append(".");
		extfix.append("BannerAction");
	form.appendf("  <tr><td><b>BannerAction: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("EnableChatURL");
	
	form.appendf("  <tr><td><b>EnableChatURL? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("FromSubmitBtn");
	
	form.appendf("  <tr><td><b>FromSubmitBtn? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CSetBannerRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CSetBannerRequest::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_ChatURL.marshall(rpc_resp, "ChatURL", "", "", "");
	m_BannerContent.marshall(rpc_resp, "BannerContent", "", "", "");
	m_BannerColor.marshall(rpc_resp, "BannerColor", "", "", "");
	m_BannerSize.marshall(rpc_resp, "BannerSize", "", "", "");
	m_BannerScroll.marshall(rpc_resp, "BannerScroll", "", "", "");
	m_BannerAction.marshall(rpc_resp, "BannerAction", "", "", "");
	m_EnableChatURL.marshall(rpc_resp, "EnableChatURL", "", "", "");
	m_FromSubmitBtn.marshall(rpc_resp, "FromSubmitBtn", "", "", "");
}


void CSetBannerRequest::copy(CSetBannerRequest &from)
{
	m_ChatURL.copy(from.m_ChatURL);
	m_BannerContent.copy(from.m_BannerContent);
	m_BannerColor.copy(from.m_BannerColor);
	m_BannerSize.copy(from.m_BannerSize);
	m_BannerScroll.copy(from.m_BannerScroll);
	m_BannerAction.copy(from.m_BannerAction);
	m_EnableChatURL.copy(from.m_EnableChatURL);
	m_FromSubmitBtn.copy(from.m_FromSubmitBtn);
}


void CSetBannerRequest::copy(IConstSetBannerRequest &ifrom)
{
	setChatURL(ifrom.getChatURL());
	setBannerContent(ifrom.getBannerContent());
	setBannerColor(ifrom.getBannerColor());
	setBannerSize(ifrom.getBannerSize());
	setBannerScroll(ifrom.getBannerScroll());
	setBannerAction(ifrom.getBannerAction());
	setEnableChatURL(ifrom.getEnableChatURL());
	setFromSubmitBtn(ifrom.getFromSubmitBtn());
}


void CSetBannerRequest::getAttributes(IProperties &attributes)
{
}


void CSetBannerRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_ChatURL.toStr(ctx, buffer, "ChatURL", "", true, "", "");
	m_BannerContent.toStr(ctx, buffer, "BannerContent", "", true, "", "");
	m_BannerColor.toStr(ctx, buffer, "BannerColor", "", true, "", "");
	m_BannerSize.toStr(ctx, buffer, "BannerSize", "", true, "", "");
	m_BannerScroll.toStr(ctx, buffer, "BannerScroll", "", true, "", "");
	m_BannerAction.toStr(ctx, buffer, "BannerAction", "", true, "", "");
	m_EnableChatURL.toStr(ctx, buffer, "EnableChatURL", "", true, "", "");
	m_FromSubmitBtn.toStr(ctx, buffer, "FromSubmitBtn", "", true, "", "");
}


void CSetBannerRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CSetBannerRequest::serializer(IEspContext* ctx, IConstSetBannerRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<SetBannerRequest>");
	// field ChatURL
	{
		const char* s = src.getChatURL();
		if (s && *s)
		{
			buffer.append("<ChatURL>");
			encodeUtf8XML(s,buffer);
			buffer.append("</ChatURL>");
		}
	}
	// field BannerContent
	{
		const char* s = src.getBannerContent();
		if (s && *s)
		{
			buffer.append("<BannerContent>");
			encodeUtf8XML(s,buffer);
			buffer.append("</BannerContent>");
		}
	}
	// field BannerColor
	{
		const char* s = src.getBannerColor();
		if (s && *s)
		{
			buffer.append("<BannerColor>");
			encodeUtf8XML(s,buffer);
			buffer.append("</BannerColor>");
		}
	}
	// field BannerSize
	{
		const char* s = src.getBannerSize();
		if (s && *s)
		{
			buffer.append("<BannerSize>");
			encodeUtf8XML(s,buffer);
			buffer.append("</BannerSize>");
		}
	}
	// field BannerScroll
	{
		const char* s = src.getBannerScroll();
		if (s && *s)
		{
			buffer.append("<BannerScroll>");
			encodeUtf8XML(s,buffer);
			buffer.append("</BannerScroll>");
		}
	}
	// field BannerAction
	{
		int n = src.getBannerAction();
		if (n)
			buffer.appendf("<BannerAction>%d</BannerAction>", n);
	}
	// field EnableChatURL
	{
		bool b = src.getEnableChatURL();
		if (b)
			buffer.appendf("<EnableChatURL>1</EnableChatURL>");
	}
	// field FromSubmitBtn
	{
		bool b = src.getFromSubmitBtn();
		if (b)
			buffer.appendf("<FromSubmitBtn>1</FromSubmitBtn>");
	}
	if (keepRootTag)
		buffer.append("</SetBannerRequest>");
}

bool CSetBannerRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_ChatURL.unmarshall(rpc_request, "ChatURL", basepath);
	hasValue |= m_BannerContent.unmarshall(rpc_request, "BannerContent", basepath);
	hasValue |= m_BannerColor.unmarshall(rpc_request, "BannerColor", basepath);
	hasValue |= m_BannerSize.unmarshall(rpc_request, "BannerSize", basepath);
	hasValue |= m_BannerScroll.unmarshall(rpc_request, "BannerScroll", basepath);
	hasValue |= m_BannerAction.unmarshall(rpc_request, "BannerAction", basepath);
	hasValue |= m_EnableChatURL.unmarshall(rpc_request, "EnableChatURL", basepath);
	hasValue |= m_FromSubmitBtn.unmarshall(rpc_request, "FromSubmitBtn", basepath);
	return hasValue;
}

bool CSetBannerRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_ChatURL.unmarshall(ctx, soapval, "ChatURL");
	hasValue |= m_BannerContent.unmarshall(ctx, soapval, "BannerContent");
	hasValue |= m_BannerColor.unmarshall(ctx, soapval, "BannerColor");
	hasValue |= m_BannerSize.unmarshall(ctx, soapval, "BannerSize");
	hasValue |= m_BannerScroll.unmarshall(ctx, soapval, "BannerScroll");
	hasValue |= m_BannerAction.unmarshall(ctx, soapval, "BannerAction");
	hasValue |= m_EnableChatURL.unmarshall(ctx, soapval, "EnableChatURL");
	hasValue |= m_FromSubmitBtn.unmarshall(ctx, soapval, "FromSubmitBtn");
	return hasValue;
}

bool CSetBannerRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_ChatURL.unmarshall(ctx, params, attachments, "ChatURL", basepath);
	hasValue |= m_BannerContent.unmarshall(ctx, params, attachments, "BannerContent", basepath);
	hasValue |= m_BannerColor.unmarshall(ctx, params, attachments, "BannerColor", basepath);
	hasValue |= m_BannerSize.unmarshall(ctx, params, attachments, "BannerSize", basepath);
	hasValue |= m_BannerScroll.unmarshall(ctx, params, attachments, "BannerScroll", basepath);
	hasValue |= m_BannerAction.unmarshall(ctx, params, attachments, "BannerAction", basepath);
	hasValue |= m_EnableChatURL.unmarshall(ctx, params, attachments, "EnableChatURL", basepath);
	hasValue |= m_FromSubmitBtn.unmarshall(ctx, params, attachments, "FromSubmitBtn", basepath);
	return hasValue;
}

const char * CSetBannerRequest::getChatURL() { return m_ChatURL.query();}
const char * CSetBannerRequest::getBannerContent() { return m_BannerContent.query();}
const char * CSetBannerRequest::getBannerColor() { return m_BannerColor.query();}
const char * CSetBannerRequest::getBannerSize() { return m_BannerSize.query();}
const char * CSetBannerRequest::getBannerScroll() { return m_BannerScroll.query();}
bool CSetBannerRequest::getBannerAction_isNull(){return m_BannerAction.is_nil();}
int CSetBannerRequest::getBannerAction() { return m_BannerAction;}
bool CSetBannerRequest::getEnableChatURL_isNull(){return m_EnableChatURL.is_nil();}
bool CSetBannerRequest::getEnableChatURL() { return m_EnableChatURL;}
bool CSetBannerRequest::getFromSubmitBtn_isNull(){return m_FromSubmitBtn.is_nil();}
bool CSetBannerRequest::getFromSubmitBtn() { return m_FromSubmitBtn;}
void CSetBannerRequest::setChatURL(const char * val){ m_ChatURL.set(val); }
void CSetBannerRequest::setBannerContent(const char * val){ m_BannerContent.set(val); }
void CSetBannerRequest::setBannerColor(const char * val){ m_BannerColor.set(val); }
void CSetBannerRequest::setBannerSize(const char * val){ m_BannerSize.set(val); }
void CSetBannerRequest::setBannerScroll(const char * val){ m_BannerScroll.set(val); }
void CSetBannerRequest::setBannerAction_null(){ m_BannerAction.Nil(); }void CSetBannerRequest::setBannerAction(int val){ m_BannerAction=val; }
void CSetBannerRequest::setEnableChatURL_null(){ m_EnableChatURL.Nil(); }void CSetBannerRequest::setEnableChatURL(bool val){ m_EnableChatURL=val; }
void CSetBannerRequest::setFromSubmitBtn_null(){ m_FromSubmitBtn.Nil(); }void CSetBannerRequest::setFromSubmitBtn(bool val){ m_FromSubmitBtn=val; }
extern "C"  IEspSetBannerRequest *createSetBannerRequest(const char *serv){return ((IEspSetBannerRequest *)new CSetBannerRequest(serv));}
extern "C"  IClientSetBannerRequest *createClientSetBannerRequest(const char *serv){return ((IClientSetBannerRequest *)new CSetBannerRequest(serv));}

//=======================================================
// class CSetBannerResponse Implementation
//=======================================================

CSetBannerResponse::CSetBannerResponse(const char *serviceName, IRpcMessageBinding *init)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("SetBannerResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CSetBannerResponse::CSetBannerResponse(const char *serviceName, const char *bc)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("SetBannerResponse");
}

CSetBannerResponse::CSetBannerResponse(const char *serviceName, IRpcMessage* rpcmsg)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("SetBannerResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CSetBannerResponse::CSetBannerResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("SetBannerResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CSetBannerResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		schema.append("<xsd:element name=\"Exceptions\" type=\"tns:ArrayOfEspException\" minOccurs=\"0\" maxOccurs=\"1\"/>");
		}
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CSetBannerResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CSetBannerResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CSetBannerResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CSetBannerResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CSetBannerResponse::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
	}
}


void CSetBannerResponse::copy(CSetBannerResponse &from)
{
}


void CSetBannerResponse::copy(IConstSetBannerResponse &ifrom)
{
}


void CSetBannerResponse::getAttributes(IProperties &attributes)
{
}


void CSetBannerResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
	}
}


void CSetBannerResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CSetBannerResponse::serializer(IEspContext* ctx, IConstSetBannerResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<SetBannerResponse>");
	if (keepRootTag)
		buffer.append("</SetBannerResponse>");
}

bool CSetBannerResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
	}
	return hasValue;
}

bool CSetBannerResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	return hasValue;
}

bool CSetBannerResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	return hasValue;
}

extern "C"  IEspSetBannerResponse *createSetBannerResponse(const char *serv){return ((IEspSetBannerResponse *)new CSetBannerResponse(serv));}
extern "C"  IClientSetBannerResponse *createClientSetBannerResponse(const char *serv){return ((IClientSetBannerResponse *)new CSetBannerResponse(serv));}

//=======================================================
// class CNotInCommunityEditionRequest Implementation
//=======================================================

CNotInCommunityEditionRequest::CNotInCommunityEditionRequest(const char *serviceName, IRpcMessageBinding *init)
	: m_EEPortal(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("NotInCommunityEditionRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CNotInCommunityEditionRequest::CNotInCommunityEditionRequest(const char *serviceName, const char *bc)
	: m_EEPortal(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("NotInCommunityEditionRequest");
}

CNotInCommunityEditionRequest::CNotInCommunityEditionRequest(const char *serviceName, IRpcMessage* rpcmsg)
	: m_EEPortal(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("NotInCommunityEditionRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CNotInCommunityEditionRequest::CNotInCommunityEditionRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_EEPortal(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("NotInCommunityEditionRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CNotInCommunityEditionRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"EEPortal\" type=\"xsd:string\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CNotInCommunityEditionRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CNotInCommunityEditionRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CNotInCommunityEditionRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("EEPortal");
	form.appendf("  <tr><td><b>EEPortal: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CNotInCommunityEditionRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CNotInCommunityEditionRequest::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_EEPortal.marshall(rpc_resp, "EEPortal", "", "", "");
}


void CNotInCommunityEditionRequest::copy(CNotInCommunityEditionRequest &from)
{
	m_EEPortal.copy(from.m_EEPortal);
}


void CNotInCommunityEditionRequest::copy(IConstNotInCommunityEditionRequest &ifrom)
{
	setEEPortal(ifrom.getEEPortal());
}


void CNotInCommunityEditionRequest::getAttributes(IProperties &attributes)
{
}


void CNotInCommunityEditionRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_EEPortal.toStr(ctx, buffer, "EEPortal", "", true, "", "");
}


void CNotInCommunityEditionRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CNotInCommunityEditionRequest::serializer(IEspContext* ctx, IConstNotInCommunityEditionRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<NotInCommunityEditionRequest>");
	// field EEPortal
	{
		const char* s = src.getEEPortal();
		if (s && *s)
		{
			buffer.append("<EEPortal>");
			encodeUtf8XML(s,buffer);
			buffer.append("</EEPortal>");
		}
	}
	if (keepRootTag)
		buffer.append("</NotInCommunityEditionRequest>");
}

bool CNotInCommunityEditionRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_EEPortal.unmarshall(rpc_request, "EEPortal", basepath);
	return hasValue;
}

bool CNotInCommunityEditionRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_EEPortal.unmarshall(ctx, soapval, "EEPortal");
	return hasValue;
}

bool CNotInCommunityEditionRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_EEPortal.unmarshall(ctx, params, attachments, "EEPortal", basepath);
	return hasValue;
}

const char * CNotInCommunityEditionRequest::getEEPortal() { return m_EEPortal.query();}
void CNotInCommunityEditionRequest::setEEPortal(const char * val){ m_EEPortal.set(val); }
extern "C"  IEspNotInCommunityEditionRequest *createNotInCommunityEditionRequest(const char *serv){return ((IEspNotInCommunityEditionRequest *)new CNotInCommunityEditionRequest(serv));}
extern "C"  IClientNotInCommunityEditionRequest *createClientNotInCommunityEditionRequest(const char *serv){return ((IClientNotInCommunityEditionRequest *)new CNotInCommunityEditionRequest(serv));}

//=======================================================
// class CNotInCommunityEditionResponse Implementation
//=======================================================

CNotInCommunityEditionResponse::CNotInCommunityEditionResponse(const char *serviceName, IRpcMessageBinding *init)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("NotInCommunityEditionResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CNotInCommunityEditionResponse::CNotInCommunityEditionResponse(const char *serviceName, const char *bc)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("NotInCommunityEditionResponse");
}

CNotInCommunityEditionResponse::CNotInCommunityEditionResponse(const char *serviceName, IRpcMessage* rpcmsg)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("NotInCommunityEditionResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CNotInCommunityEditionResponse::CNotInCommunityEditionResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("NotInCommunityEditionResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CNotInCommunityEditionResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		schema.append("<xsd:element name=\"Exceptions\" type=\"tns:ArrayOfEspException\" minOccurs=\"0\" maxOccurs=\"1\"/>");
		}
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CNotInCommunityEditionResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CNotInCommunityEditionResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CNotInCommunityEditionResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CNotInCommunityEditionResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CNotInCommunityEditionResponse::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
	}
}


void CNotInCommunityEditionResponse::copy(CNotInCommunityEditionResponse &from)
{
}


void CNotInCommunityEditionResponse::copy(IConstNotInCommunityEditionResponse &ifrom)
{
}


void CNotInCommunityEditionResponse::getAttributes(IProperties &attributes)
{
}


void CNotInCommunityEditionResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
	}
}


void CNotInCommunityEditionResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CNotInCommunityEditionResponse::serializer(IEspContext* ctx, IConstNotInCommunityEditionResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<NotInCommunityEditionResponse>");
	if (keepRootTag)
		buffer.append("</NotInCommunityEditionResponse>");
}

bool CNotInCommunityEditionResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
	}
	return hasValue;
}

bool CNotInCommunityEditionResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	return hasValue;
}

bool CNotInCommunityEditionResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	return hasValue;
}

extern "C"  IEspNotInCommunityEditionResponse *createNotInCommunityEditionResponse(const char *serv){return ((IEspNotInCommunityEditionResponse *)new CNotInCommunityEditionResponse(serv));}
extern "C"  IClientNotInCommunityEditionResponse *createClientNotInCommunityEditionResponse(const char *serv){return ((IClientNotInCommunityEditionResponse *)new CNotInCommunityEditionResponse(serv));}

//=======================================================
// class CHPCCResource Implementation
//=======================================================

CHPCCResource::CHPCCResource(const char *serviceName, IRpcMessageBinding *init)
	: m_Name(nilIgnore),m_Description(nilIgnore),m_FileName(nilIgnore),m_Version(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("HPCCResource");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CHPCCResource::CHPCCResource(const char *serviceName, const char *bc)
	: m_Name(nilIgnore),m_Description(nilIgnore),m_FileName(nilIgnore),m_Version(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("HPCCResource");
}

StringBuffer &CHPCCResource::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:complexType name=\"%s\">\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Name\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Description\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"FileName\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Version\" type=\"xsd:string\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType>\n");
		}
	}
	return schema;
}

void CHPCCResource::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CHPCCResource::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CHPCCResource::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Name");
	form.appendf("  <tr><td><b>Name: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Description");
	form.appendf("  <tr><td><b>Description: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("FileName");
	form.appendf("  <tr><td><b>FileName: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Version");
	form.appendf("  <tr><td><b>Version: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CHPCCResource::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CHPCCResource::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_Name.marshall(rpc_resp, "Name", "", "", "");
	m_Description.marshall(rpc_resp, "Description", "", "", "");
	m_FileName.marshall(rpc_resp, "FileName", "", "", "");
	m_Version.marshall(rpc_resp, "Version", "", "", "");
}


void CHPCCResource::copy(CHPCCResource &from)
{
	m_Name.copy(from.m_Name);
	m_Description.copy(from.m_Description);
	m_FileName.copy(from.m_FileName);
	m_Version.copy(from.m_Version);
}


void CHPCCResource::copy(IConstHPCCResource &ifrom)
{
	setName(ifrom.getName());
	setDescription(ifrom.getDescription());
	setFileName(ifrom.getFileName());
	setVersion(ifrom.getVersion());
}


void CHPCCResource::getAttributes(IProperties &attributes)
{
}


void CHPCCResource::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_Name.toStr(ctx, buffer, "Name", "", true, "", "");
	m_Description.toStr(ctx, buffer, "Description", "", true, "", "");
	m_FileName.toStr(ctx, buffer, "FileName", "", true, "", "");
	m_Version.toStr(ctx, buffer, "Version", "", true, "", "");
}


void CHPCCResource::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CHPCCResource::serializer(IEspContext* ctx, IConstHPCCResource &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<HPCCResource>");
	// field Name
	{
		const char* s = src.getName();
		if (s && *s)
		{
			buffer.append("<Name>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Name>");
		}
	}
	// field Description
	{
		const char* s = src.getDescription();
		if (s && *s)
		{
			buffer.append("<Description>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Description>");
		}
	}
	// field FileName
	{
		const char* s = src.getFileName();
		if (s && *s)
		{
			buffer.append("<FileName>");
			encodeUtf8XML(s,buffer);
			buffer.append("</FileName>");
		}
	}
	// field Version
	{
		const char* s = src.getVersion();
		if (s && *s)
		{
			buffer.append("<Version>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Version>");
		}
	}
	if (keepRootTag)
		buffer.append("</HPCCResource>");
}

bool CHPCCResource::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_Name.unmarshall(rpc_request, "Name", basepath);
	hasValue |= m_Description.unmarshall(rpc_request, "Description", basepath);
	hasValue |= m_FileName.unmarshall(rpc_request, "FileName", basepath);
	hasValue |= m_Version.unmarshall(rpc_request, "Version", basepath);
	return hasValue;
}

bool CHPCCResource::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Name.unmarshall(ctx, soapval, "Name");
	hasValue |= m_Description.unmarshall(ctx, soapval, "Description");
	hasValue |= m_FileName.unmarshall(ctx, soapval, "FileName");
	hasValue |= m_Version.unmarshall(ctx, soapval, "Version");
	return hasValue;
}

bool CHPCCResource::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Name.unmarshall(ctx, params, attachments, "Name", basepath);
	hasValue |= m_Description.unmarshall(ctx, params, attachments, "Description", basepath);
	hasValue |= m_FileName.unmarshall(ctx, params, attachments, "FileName", basepath);
	hasValue |= m_Version.unmarshall(ctx, params, attachments, "Version", basepath);
	return hasValue;
}

const char * CHPCCResource::getName() { return m_Name.query();}
const char * CHPCCResource::getDescription() { return m_Description.query();}
const char * CHPCCResource::getFileName() { return m_FileName.query();}
const char * CHPCCResource::getVersion() { return m_Version.query();}
void CHPCCResource::setName(const char * val){ m_Name.set(val); }
void CHPCCResource::setDescription(const char * val){ m_Description.set(val); }
void CHPCCResource::setFileName(const char * val){ m_FileName.set(val); }
void CHPCCResource::setVersion(const char * val){ m_Version.set(val); }
extern "C"  IEspHPCCResource *createHPCCResource(const char *serv, const char *msgname){return ((IEspHPCCResource *)new CHPCCResource(serv /*, msgname*/));}
extern "C"  IClientHPCCResource *createClientHPCCResource(const char *serv, const char *msgname){return ((IClientHPCCResource *)new CHPCCResource(serv /*, msgname*/));}

//=======================================================
// class CHPCCResourceRepository Implementation
//=======================================================

CHPCCResourceRepository::CHPCCResourceRepository(const char *serviceName, IRpcMessageBinding *init)
	: m_Name(nilIgnore),m_Path(nilIgnore),m_HPCCResources(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("HPCCResourceRepository");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CHPCCResourceRepository::CHPCCResourceRepository(const char *serviceName, const char *bc)
	: m_Name(nilIgnore),m_Path(nilIgnore),m_HPCCResources(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("HPCCResourceRepository");
}

StringBuffer &CHPCCResourceRepository::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:complexType name=\"%s\">\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Name\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Path\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"HPCCResources\" type=\"tns:ArrayOfHPCCResource\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType>\n");
		}
	}
	if (!(flags & 0x10)  || (flags & 0x100))
	{
		CHPCCResource::getXsdDefinition(context, request, schema, added);
	}
	if (added.getValue("HPCCResource") && added.getValue("ArrayOfHPCCResource")==NULL) {
		schema.append("<xsd:complexType name=\"ArrayOfHPCCResource\">\n");
		schema.append("<xsd:sequence>\n");
		schema.append("<xsd:element minOccurs=\"0\" maxOccurs=\"unbounded\" name=\"HPCCResource\" type=\"tns:HPCCResource\"/>\n");
		schema.append("</xsd:sequence>\n");
		schema.append("</xsd:complexType>\n");
		added.setValue("ArrayOfHPCCResource",1);
	}
	return schema;
}

void CHPCCResourceRepository::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CHPCCResourceRepository::getMapInfo(IMapInfo& info, BoolHash& added)
{
	if (!added.getValue("HPCCResource"))
	{
		added.setValue("HPCCResource",1);
		CHPCCResource::getMapInfo(info,added);
	}
}

StringBuffer &CHPCCResourceRepository::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Name");
	form.appendf("  <tr><td><b>Name: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Path");
	form.appendf("  <tr><td><b>Path: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("HPCCResources");
	form.appendf("<tr><td><b>HPCCResources: </b></td><td>");
	form.appendf("<table><tr><td><textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea></td>", extfix.str());
	form.append("</tr></table>");
	form.append("</td></tr>");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CHPCCResourceRepository::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CHPCCResourceRepository::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_Name.marshall(rpc_resp, "Name", "", "", "");
	m_Path.marshall(rpc_resp, "Path", "", "", "");
	m_HPCCResources.marshall(rpc_resp, "HPCCResources", "HPCCResource");
}


void CHPCCResourceRepository::copy(CHPCCResourceRepository &from)
{
	m_Name.copy(from.m_Name);
	m_Path.copy(from.m_Path);
	m_HPCCResources.copy(from.m_HPCCResources);
}


void CHPCCResourceRepository::copy(IConstHPCCResourceRepository &ifrom)
{
	setName(ifrom.getName());
	setPath(ifrom.getPath());
	setHPCCResources(ifrom.getHPCCResources());
}


void CHPCCResourceRepository::getAttributes(IProperties &attributes)
{
}


void CHPCCResourceRepository::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_Name.toStr(ctx, buffer, "Name", "", true, "", "");
	m_Path.toStr(ctx, buffer, "Path", "", true, "", "");
	m_HPCCResources.toStr(ctx, buffer, "HPCCResources", "HPCCResource");
}


void CHPCCResourceRepository::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CHPCCResourceRepository::serializer(IEspContext* ctx, IConstHPCCResourceRepository &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<HPCCResourceRepository>");
	// field Name
	{
		const char* s = src.getName();
		if (s && *s)
		{
			buffer.append("<Name>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Name>");
		}
	}
	// field Path
	{
		const char* s = src.getPath();
		if (s && *s)
		{
			buffer.append("<Path>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Path>");
		}
	}
	// field HPCCResources
	{
		IArrayOf<IConstHPCCResource>& v = src.getHPCCResources();
		int size = v.length();
		if (size>0)
			buffer.append("<HPCCResources>");
		for (int i=0;i<size;i++)
		{
			buffer.append("<Item>");
			CHPCCResource::serializer(ctx,v.item(i),buffer,false);
			buffer.append("</Item>");
		}
		if (size>0)
			buffer.append("</HPCCResources>");
	}
	if (keepRootTag)
		buffer.append("</HPCCResourceRepository>");
}

bool CHPCCResourceRepository::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_Name.unmarshall(rpc_request, "Name", basepath);
	hasValue |= m_Path.unmarshall(rpc_request, "Path", basepath);
	hasValue |= m_HPCCResources.unmarshall(rpc_request, "HPCCResources", basepath);
	return hasValue;
}

bool CHPCCResourceRepository::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Name.unmarshall(ctx, soapval, "Name");
	hasValue |= m_Path.unmarshall(ctx, soapval, "Path");
	hasValue |= m_HPCCResources.unmarshall(ctx, soapval, "HPCCResources");
	return hasValue;
}

bool CHPCCResourceRepository::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Name.unmarshall(ctx, params, attachments, "Name", basepath);
	hasValue |= m_Path.unmarshall(ctx, params, attachments, "Path", basepath);
	hasValue |= m_HPCCResources.unmarshall(ctx, params, attachments, "HPCCResources", basepath);
	return hasValue;
}

const char * CHPCCResourceRepository::getName() { return m_Name.query();}
const char * CHPCCResourceRepository::getPath() { return m_Path.query();}
IArrayOf<IConstHPCCResource> & CHPCCResourceRepository::getHPCCResources() { return (IArrayOf<IConstHPCCResource> &) m_HPCCResources; }
void CHPCCResourceRepository::setName(const char * val){ m_Name.set(val); }
void CHPCCResourceRepository::setPath(const char * val){ m_Path.set(val); }
void CHPCCResourceRepository::setHPCCResources(IArrayOf<IEspHPCCResource> &val)
{
	m_HPCCResources->kill();
	IArrayOf<IConstHPCCResource> &target = m_HPCCResources.getValue();
	ForEachItemIn(idx, val)
	{
		IEspHPCCResource &item = (val).item(idx);
		item.Link();
		target.append(item);
	}
}
void CHPCCResourceRepository::setHPCCResources(IArrayOf<IConstHPCCResource> &val)
{
	m_HPCCResources->kill();
	IArrayOf<IConstHPCCResource> &target = m_HPCCResources.getValue();
	ForEachItemIn(idx, val)
	{
		IConstHPCCResource &item = val.item(idx);
		item.Link();
		target.append(item);
	}
}
extern "C"  IEspHPCCResourceRepository *createHPCCResourceRepository(const char *serv, const char *msgname){return ((IEspHPCCResourceRepository *)new CHPCCResourceRepository(serv /*, msgname*/));}
extern "C"  IClientHPCCResourceRepository *createClientHPCCResourceRepository(const char *serv, const char *msgname){return ((IClientHPCCResourceRepository *)new CHPCCResourceRepository(serv /*, msgname*/));}

//=======================================================
// class CBrowseResourcesRequest Implementation
//=======================================================

CBrowseResourcesRequest::CBrowseResourcesRequest(const char *serviceName, IRpcMessageBinding *init)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("BrowseResourcesRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CBrowseResourcesRequest::CBrowseResourcesRequest(const char *serviceName, const char *bc)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("BrowseResourcesRequest");
}

CBrowseResourcesRequest::CBrowseResourcesRequest(const char *serviceName, IRpcMessage* rpcmsg)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("BrowseResourcesRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CBrowseResourcesRequest::CBrowseResourcesRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("BrowseResourcesRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CBrowseResourcesRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType><xsd:all/></xsd:complexType></xsd:element>\n", msgTypeName);
		}
	}
	return schema;
}

void CBrowseResourcesRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CBrowseResourcesRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CBrowseResourcesRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CBrowseResourcesRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CBrowseResourcesRequest::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

}


void CBrowseResourcesRequest::copy(CBrowseResourcesRequest &from)
{
}


void CBrowseResourcesRequest::copy(IConstBrowseResourcesRequest &ifrom)
{
}


void CBrowseResourcesRequest::getAttributes(IProperties &attributes)
{
}


void CBrowseResourcesRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
}


void CBrowseResourcesRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CBrowseResourcesRequest::serializer(IEspContext* ctx, IConstBrowseResourcesRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<BrowseResourcesRequest>");
	if (keepRootTag)
		buffer.append("</BrowseResourcesRequest>");
}

bool CBrowseResourcesRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	return hasValue;
}

bool CBrowseResourcesRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	return hasValue;
}

bool CBrowseResourcesRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	return hasValue;
}

extern "C"  IEspBrowseResourcesRequest *createBrowseResourcesRequest(const char *serv){return ((IEspBrowseResourcesRequest *)new CBrowseResourcesRequest(serv));}
extern "C"  IClientBrowseResourcesRequest *createClientBrowseResourcesRequest(const char *serv){return ((IClientBrowseResourcesRequest *)new CBrowseResourcesRequest(serv));}

//=======================================================
// class CBrowseResourcesResponse Implementation
//=======================================================

CBrowseResourcesResponse::CBrowseResourcesResponse(const char *serviceName, IRpcMessageBinding *init)
	: m_PortalURL(nilRemove),m_NetAddress(nilRemove),m_OS(nilRemove),m_UseResource(nilRemove),m_HPCCResourceRepositories(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("BrowseResourcesResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CBrowseResourcesResponse::CBrowseResourcesResponse(const char *serviceName, const char *bc)
	: m_PortalURL(nilRemove),m_NetAddress(nilRemove),m_OS(nilRemove),m_UseResource(nilRemove),m_HPCCResourceRepositories(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("BrowseResourcesResponse");
}

CBrowseResourcesResponse::CBrowseResourcesResponse(const char *serviceName, IRpcMessage* rpcmsg)
	: m_PortalURL(nilRemove),m_NetAddress(nilRemove),m_OS(nilRemove),m_UseResource(nilRemove),m_HPCCResourceRepositories(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("BrowseResourcesResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CBrowseResourcesResponse::CBrowseResourcesResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_PortalURL(nilRemove),m_NetAddress(nilRemove),m_OS(nilRemove),m_UseResource(nilRemove),m_HPCCResourceRepositories(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("BrowseResourcesResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CBrowseResourcesResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		schema.append("<xsd:element name=\"Exceptions\" type=\"tns:ArrayOfEspException\" minOccurs=\"0\" maxOccurs=\"1\"/>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"PortalURL\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"NetAddress\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"OS\" type=\"xsd:int\"/>\n");
		if (!context.suppressed("BrowseResourcesResponse","UseResource")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"UseResource\" type=\"xsd:boolean\"/>\n");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"HPCCResourceRepositories\" type=\"tns:ArrayOfHPCCResourceRepository\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	if (!(flags & 0x10)  || (flags & 0x100))
	{
		CHPCCResourceRepository::getXsdDefinition(context, request, schema, added);
	}
	if (added.getValue("HPCCResourceRepository") && added.getValue("ArrayOfHPCCResourceRepository")==NULL) {
		schema.append("<xsd:complexType name=\"ArrayOfHPCCResourceRepository\">\n");
		schema.append("<xsd:sequence>\n");
		schema.append("<xsd:element minOccurs=\"0\" maxOccurs=\"unbounded\" name=\"HPCCResourceRepository\" type=\"tns:HPCCResourceRepository\"/>\n");
		schema.append("</xsd:sequence>\n");
		schema.append("</xsd:complexType>\n");
		added.setValue("ArrayOfHPCCResourceRepository",1);
	}
	return schema;
}

void CBrowseResourcesResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CBrowseResourcesResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
	info.addMinVersion("BrowseResourcesResponse","UseResource",1.13);
	if (!added.getValue("HPCCResourceRepository"))
	{
		added.setValue("HPCCResourceRepository",1);
		CHPCCResourceRepository::getMapInfo(info,added);
	}
}

StringBuffer &CBrowseResourcesResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("PortalURL");
	form.appendf("  <tr><td><b>PortalURL: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("NetAddress");
	form.appendf("  <tr><td><b>NetAddress: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix) extfix.append(prefix).append(".");
		extfix.append("OS");
	form.appendf("  <tr><td><b>OS: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
	form.append("</td></tr>\n");
	if (!context.suppressed("BrowseResourcesResponse","UseResource")) {
		extfix.clear();
		if (prefix && *prefix)
			extfix.append(prefix).append(".");
		extfix.append("UseResource");
		
	form.appendf("  <tr><td><b>UseResource? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	}
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("HPCCResourceRepositories");
	form.appendf("<tr><td><b>HPCCResourceRepositories: </b></td><td>");
	form.appendf("<table><tr><td><textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea></td>", extfix.str());
	form.append("</tr></table>");
	form.append("</td></tr>");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CBrowseResourcesResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CBrowseResourcesResponse::serialize(IRpcMessage& rpc_resp)
{
	IEspContext* ctx = rpc_resp.queryContext();
	double clientVer= ctx ? ctx->getClientVersion() : -1; /* no context gets everything */
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
		m_PortalURL.marshall(rpc_resp, "PortalURL", "", "", "");
		m_NetAddress.marshall(rpc_resp, "NetAddress", "", "", "");
		m_OS.marshall(rpc_resp, "OS", "", "", "");
		if ((clientVer==-1.0 || clientVer>=1.13))
			m_UseResource.marshall(rpc_resp, "UseResource", "", "", "");
		m_HPCCResourceRepositories.marshall(rpc_resp, "HPCCResourceRepositories", "HPCCResourceRepository");
	}
}


void CBrowseResourcesResponse::copy(CBrowseResourcesResponse &from)
{
	m_PortalURL.copy(from.m_PortalURL);
	m_NetAddress.copy(from.m_NetAddress);
	m_OS.copy(from.m_OS);
	m_UseResource.copy(from.m_UseResource);
	m_HPCCResourceRepositories.copy(from.m_HPCCResourceRepositories);
}


void CBrowseResourcesResponse::copy(IConstBrowseResourcesResponse &ifrom)
{
	setPortalURL(ifrom.getPortalURL());
	setNetAddress(ifrom.getNetAddress());
	setOS(ifrom.getOS());
	setUseResource(ifrom.getUseResource());
	setHPCCResourceRepositories(ifrom.getHPCCResourceRepositories());
}


void CBrowseResourcesResponse::getAttributes(IProperties &attributes)
{
}


void CBrowseResourcesResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
		double clientVer = ctx ? ctx->getClientVersion() : -1;
		m_PortalURL.toStr(ctx, buffer, "PortalURL", "", true, "", "");
		m_NetAddress.toStr(ctx, buffer, "NetAddress", "", true, "", "");
		m_OS.toStr(ctx, buffer, "OS", "", true, "", "");
		if ((clientVer==-1.0 || clientVer>=1.13))
			m_UseResource.toStr(ctx, buffer, "UseResource", "", true, "", "");
		m_HPCCResourceRepositories.toStr(ctx, buffer, "HPCCResourceRepositories", "HPCCResourceRepository");
	}
}


void CBrowseResourcesResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CBrowseResourcesResponse::serializer(IEspContext* ctx, IConstBrowseResourcesResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<BrowseResourcesResponse>");
	double clientVer = ctx ? ctx->getClientVersion() : -1;
	// field PortalURL
	{
		const char* s = src.getPortalURL();
		if (s && *s)
		{
			buffer.append("<PortalURL>");
			encodeUtf8XML(s,buffer);
			buffer.append("</PortalURL>");
		}
	}
	// field NetAddress
	{
		const char* s = src.getNetAddress();
		if (s && *s)
		{
			buffer.append("<NetAddress>");
			encodeUtf8XML(s,buffer);
			buffer.append("</NetAddress>");
		}
	}
	// field OS
	{
		int n = src.getOS();
		if (n)
			buffer.appendf("<OS>%d</OS>", n);
	}
	// field UseResource
	if ((clientVer==-1.0 || clientVer>=1.13))
	{
		bool b = src.getUseResource();
		if (b)
			buffer.appendf("<UseResource>1</UseResource>");
	}
	// field HPCCResourceRepositories
	{
		IArrayOf<IConstHPCCResourceRepository>& v = src.getHPCCResourceRepositories();
		int size = v.length();
		if (size>0)
			buffer.append("<HPCCResourceRepositories>");
		for (int i=0;i<size;i++)
		{
			buffer.append("<Item>");
			CHPCCResourceRepository::serializer(ctx,v.item(i),buffer,false);
			buffer.append("</Item>");
		}
		if (size>0)
			buffer.append("</HPCCResourceRepositories>");
	}
	if (keepRootTag)
		buffer.append("</BrowseResourcesResponse>");
}

bool CBrowseResourcesResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
		hasValue |= m_PortalURL.unmarshall(rpc_request, "PortalURL", basepath);
		hasValue |= m_NetAddress.unmarshall(rpc_request, "NetAddress", basepath);
		hasValue |= m_OS.unmarshall(rpc_request, "OS", basepath);
		hasValue |= m_UseResource.unmarshall(rpc_request, "UseResource", basepath);
		hasValue |= m_HPCCResourceRepositories.unmarshall(rpc_request, "HPCCResourceRepositories", basepath);
	}
	return hasValue;
}

bool CBrowseResourcesResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_PortalURL.unmarshall(ctx, soapval, "PortalURL");
	hasValue |= m_NetAddress.unmarshall(ctx, soapval, "NetAddress");
	hasValue |= m_OS.unmarshall(ctx, soapval, "OS");
	hasValue |= m_UseResource.unmarshall(ctx, soapval, "UseResource");
	hasValue |= m_HPCCResourceRepositories.unmarshall(ctx, soapval, "HPCCResourceRepositories");
	return hasValue;
}

bool CBrowseResourcesResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_PortalURL.unmarshall(ctx, params, attachments, "PortalURL", basepath);
	hasValue |= m_NetAddress.unmarshall(ctx, params, attachments, "NetAddress", basepath);
	hasValue |= m_OS.unmarshall(ctx, params, attachments, "OS", basepath);
	hasValue |= m_UseResource.unmarshall(ctx, params, attachments, "UseResource", basepath);
	hasValue |= m_HPCCResourceRepositories.unmarshall(ctx, params, attachments, "HPCCResourceRepositories", basepath);
	return hasValue;
}

const char * CBrowseResourcesResponse::getPortalURL() { return m_PortalURL.query();}
const char * CBrowseResourcesResponse::getNetAddress() { return m_NetAddress.query();}
bool CBrowseResourcesResponse::getOS_isNull(){return m_OS.is_nil();}
int CBrowseResourcesResponse::getOS() { return m_OS;}
bool CBrowseResourcesResponse::getUseResource_isNull(){return m_UseResource.is_nil();}
bool CBrowseResourcesResponse::getUseResource() { return m_UseResource;}
IArrayOf<IConstHPCCResourceRepository> & CBrowseResourcesResponse::getHPCCResourceRepositories() { return (IArrayOf<IConstHPCCResourceRepository> &) m_HPCCResourceRepositories; }
void CBrowseResourcesResponse::setPortalURL(const char * val){ m_PortalURL.set(val); }
void CBrowseResourcesResponse::setNetAddress(const char * val){ m_NetAddress.set(val); }
void CBrowseResourcesResponse::setOS_null(){ m_OS.Nil(); }void CBrowseResourcesResponse::setOS(int val){ m_OS=val; }
void CBrowseResourcesResponse::setUseResource_null(){ m_UseResource.Nil(); }void CBrowseResourcesResponse::setUseResource(bool val){ m_UseResource=val; }
void CBrowseResourcesResponse::setHPCCResourceRepositories(IArrayOf<IEspHPCCResourceRepository> &val)
{
	m_HPCCResourceRepositories->kill();
	IArrayOf<IConstHPCCResourceRepository> &target = m_HPCCResourceRepositories.getValue();
	ForEachItemIn(idx, val)
	{
		IEspHPCCResourceRepository &item = (val).item(idx);
		item.Link();
		target.append(item);
	}
}
void CBrowseResourcesResponse::setHPCCResourceRepositories(IArrayOf<IConstHPCCResourceRepository> &val)
{
	m_HPCCResourceRepositories->kill();
	IArrayOf<IConstHPCCResourceRepository> &target = m_HPCCResourceRepositories.getValue();
	ForEachItemIn(idx, val)
	{
		IConstHPCCResourceRepository &item = val.item(idx);
		item.Link();
		target.append(item);
	}
}
extern "C"  IEspBrowseResourcesResponse *createBrowseResourcesResponse(const char *serv){return ((IEspBrowseResourcesResponse *)new CBrowseResourcesResponse(serv));}
extern "C"  IClientBrowseResourcesResponse *createClientBrowseResourcesResponse(const char *serv){return ((IClientBrowseResourcesResponse *)new CBrowseResourcesResponse(serv));}

//=======================================================
// class CRoxieControlCmdRequest Implementation
//=======================================================

CRoxieControlCmdRequest::CRoxieControlCmdRequest(const char *serviceName, IRpcMessageBinding *init)
	: m_ProcessCluster(nilIgnore),m_Command(nilIgnore),m_Wait(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("RoxieControlCmdRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CRoxieControlCmdRequest::CRoxieControlCmdRequest(const char *serviceName, const char *bc)
	: m_ProcessCluster(nilIgnore),m_Command(nilIgnore),m_Wait(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("RoxieControlCmdRequest");
}

CRoxieControlCmdRequest::CRoxieControlCmdRequest(const char *serviceName, IRpcMessage* rpcmsg)
	: m_ProcessCluster(nilIgnore),m_Command(nilIgnore),m_Wait(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("RoxieControlCmdRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CRoxieControlCmdRequest::CRoxieControlCmdRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_ProcessCluster(nilIgnore),m_Command(nilIgnore),m_Wait(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("RoxieControlCmdRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CRoxieControlCmdRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"ProcessCluster\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Command\" type=\"tns:RoxieControlCmdType\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Wait\" type=\"xsd:int\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	if (!(flags & 0x10)  || (flags & 0x100))
	{
		CXRoxieControlCmdType::getXsdDefinition(context, request, schema, added);
	}
	return schema;
}

void CRoxieControlCmdRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CRoxieControlCmdRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
	if (!added.getValue("RoxieControlCmdType"))
	{
		added.setValue("RoxieControlCmdType",1);
		CXRoxieControlCmdType::getMapInfo(info,added);
	}
}

StringBuffer &CRoxieControlCmdRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("ProcessCluster");
	form.appendf("  <tr><td><b>ProcessCluster: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Command");
	form.appendf("  <tr><td><b>Command: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix) extfix.append(prefix).append(".");
		extfix.append("Wait");
	form.appendf("  <tr><td><b>Wait: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CRoxieControlCmdRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CRoxieControlCmdRequest::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_ProcessCluster.marshall(rpc_resp, "ProcessCluster", "", "", "");
	m_Command.marshall(rpc_resp, "Command", "", "", "");
	m_Wait.marshall(rpc_resp, "Wait", "", "", "");
}


void CRoxieControlCmdRequest::copy(CRoxieControlCmdRequest &from)
{
	m_ProcessCluster.copy(from.m_ProcessCluster);
	m_Command.copy(from.m_Command);
	m_Wait.copy(from.m_Wait);
}


void CRoxieControlCmdRequest::copy(IConstRoxieControlCmdRequest &ifrom)
{
	setProcessCluster(ifrom.getProcessCluster());
	setCommand(ifrom.getCommand());
	setWait(ifrom.getWait());
}


void CRoxieControlCmdRequest::getAttributes(IProperties &attributes)
{
}


void CRoxieControlCmdRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_ProcessCluster.toStr(ctx, buffer, "ProcessCluster", "", true, "", "");
	m_Command.toStr(ctx, buffer, "Command", "", true, "", "");
	m_Wait.toStr(ctx, buffer, "Wait", "", true, "", "");
}


void CRoxieControlCmdRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CRoxieControlCmdRequest::serializer(IEspContext* ctx, IConstRoxieControlCmdRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<RoxieControlCmdRequest>");
	// field ProcessCluster
	{
		const char* s = src.getProcessCluster();
		if (s && *s)
		{
			buffer.append("<ProcessCluster>");
			encodeUtf8XML(s,buffer);
			buffer.append("</ProcessCluster>");
		}
	}
	// field Command
	{
		const char* s = src.getCommandAsString();
		buffer.append("<Command>");
		encodeUtf8XML(s,buffer);
		buffer.append("</Command>");
	}
	// field Wait
	{
		int n = src.getWait();
		if (n)
			buffer.appendf("<Wait>%d</Wait>", n);
	}
	if (keepRootTag)
		buffer.append("</RoxieControlCmdRequest>");
}

bool CRoxieControlCmdRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_ProcessCluster.unmarshall(rpc_request, "ProcessCluster", basepath);
	hasValue |= m_Command.unmarshall(rpc_request, "Command", basepath);
	hasValue |= m_Wait.unmarshall(rpc_request, "Wait", basepath);
	return hasValue;
}

bool CRoxieControlCmdRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_ProcessCluster.unmarshall(ctx, soapval, "ProcessCluster");
	hasValue |= m_Command.unmarshall(ctx, soapval, "Command");
	hasValue |= m_Wait.unmarshall(ctx, soapval, "Wait");
	return hasValue;
}

bool CRoxieControlCmdRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_ProcessCluster.unmarshall(ctx, params, attachments, "ProcessCluster", basepath);
	hasValue |= m_Command.unmarshall(ctx, params, attachments, "Command", basepath);
	hasValue |= m_Wait.unmarshall(ctx, params, attachments, "Wait", basepath);
	return hasValue;
}

const char * CRoxieControlCmdRequest::getProcessCluster() { return m_ProcessCluster.query();}
CRoxieControlCmdType CRoxieControlCmdRequest::getCommand() { return m_Command.getValue(); }
const char* CRoxieControlCmdRequest::getCommandAsString() {  return (const char*)m_Command; }
int CRoxieControlCmdRequest::getWait() { return m_Wait;}
void CRoxieControlCmdRequest::setProcessCluster(const char * val){ m_ProcessCluster.set(val); }
void CRoxieControlCmdRequest::setCommand(CRoxieControlCmdType val) { m_Command.setValue(val); }
void CRoxieControlCmdRequest::setCommand(const char* val) { m_Command.setValue(val); }
void CRoxieControlCmdRequest::setWait(int val){ m_Wait=val; }
extern "C"  IEspRoxieControlCmdRequest *createRoxieControlCmdRequest(const char *serv){return ((IEspRoxieControlCmdRequest *)new CRoxieControlCmdRequest(serv));}
extern "C"  IClientRoxieControlCmdRequest *createClientRoxieControlCmdRequest(const char *serv){return ((IClientRoxieControlCmdRequest *)new CRoxieControlCmdRequest(serv));}

//=======================================================
// class CRoxieControlEndpointInfo Implementation
//=======================================================

CRoxieControlEndpointInfo::CRoxieControlEndpointInfo(const char *serviceName, IRpcMessageBinding *init)
	: m_Address(nilRemove),m_Attached(nilRemove),m_StateHash(nilRemove),m_Status(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("RoxieControlEndpointInfo");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CRoxieControlEndpointInfo::CRoxieControlEndpointInfo(const char *serviceName, const char *bc)
	: m_Address(nilRemove),m_Attached(nilRemove),m_StateHash(nilRemove),m_Status(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("RoxieControlEndpointInfo");
}

StringBuffer &CRoxieControlEndpointInfo::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:complexType name=\"%s\">\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Address\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Attached\" type=\"xsd:boolean\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"StateHash\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Status\" type=\"xsd:string\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType>\n");
		}
	}
	return schema;
}

void CRoxieControlEndpointInfo::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CRoxieControlEndpointInfo::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CRoxieControlEndpointInfo::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Address");
	form.appendf("  <tr><td><b>Address: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Attached");
	
	form.appendf("  <tr><td><b>Attached? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("StateHash");
	form.appendf("  <tr><td><b>StateHash: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Status");
	form.appendf("  <tr><td><b>Status: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CRoxieControlEndpointInfo::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CRoxieControlEndpointInfo::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_Address.marshall(rpc_resp, "Address", "", "", "");
	m_Attached.marshall(rpc_resp, "Attached", "", "", "");
	m_StateHash.marshall(rpc_resp, "StateHash", "", "", "");
	m_Status.marshall(rpc_resp, "Status", "", "", "");
}


void CRoxieControlEndpointInfo::copy(CRoxieControlEndpointInfo &from)
{
	m_Address.copy(from.m_Address);
	m_Attached.copy(from.m_Attached);
	m_StateHash.copy(from.m_StateHash);
	m_Status.copy(from.m_Status);
}


void CRoxieControlEndpointInfo::copy(IConstRoxieControlEndpointInfo &ifrom)
{
	setAddress(ifrom.getAddress());
	setAttached(ifrom.getAttached());
	setStateHash(ifrom.getStateHash());
	setStatus(ifrom.getStatus());
}


void CRoxieControlEndpointInfo::getAttributes(IProperties &attributes)
{
}


void CRoxieControlEndpointInfo::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_Address.toStr(ctx, buffer, "Address", "", true, "", "");
	m_Attached.toStr(ctx, buffer, "Attached", "", true, "", "");
	m_StateHash.toStr(ctx, buffer, "StateHash", "", true, "", "");
	m_Status.toStr(ctx, buffer, "Status", "", true, "", "");
}


void CRoxieControlEndpointInfo::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CRoxieControlEndpointInfo::serializer(IEspContext* ctx, IConstRoxieControlEndpointInfo &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<RoxieControlEndpointInfo>");
	// field Address
	{
		const char* s = src.getAddress();
		if (s && *s)
		{
			buffer.append("<Address>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Address>");
		}
	}
	// field Attached
	{
		bool b = src.getAttached();
		if (b)
			buffer.appendf("<Attached>1</Attached>");
	}
	// field StateHash
	{
		const char* s = src.getStateHash();
		if (s && *s)
		{
			buffer.append("<StateHash>");
			encodeUtf8XML(s,buffer);
			buffer.append("</StateHash>");
		}
	}
	// field Status
	{
		const char* s = src.getStatus();
		if (s && *s)
		{
			buffer.append("<Status>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Status>");
		}
	}
	if (keepRootTag)
		buffer.append("</RoxieControlEndpointInfo>");
}

bool CRoxieControlEndpointInfo::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_Address.unmarshall(rpc_request, "Address", basepath);
	hasValue |= m_Attached.unmarshall(rpc_request, "Attached", basepath);
	hasValue |= m_StateHash.unmarshall(rpc_request, "StateHash", basepath);
	hasValue |= m_Status.unmarshall(rpc_request, "Status", basepath);
	return hasValue;
}

bool CRoxieControlEndpointInfo::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Address.unmarshall(ctx, soapval, "Address");
	hasValue |= m_Attached.unmarshall(ctx, soapval, "Attached");
	hasValue |= m_StateHash.unmarshall(ctx, soapval, "StateHash");
	hasValue |= m_Status.unmarshall(ctx, soapval, "Status");
	return hasValue;
}

bool CRoxieControlEndpointInfo::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Address.unmarshall(ctx, params, attachments, "Address", basepath);
	hasValue |= m_Attached.unmarshall(ctx, params, attachments, "Attached", basepath);
	hasValue |= m_StateHash.unmarshall(ctx, params, attachments, "StateHash", basepath);
	hasValue |= m_Status.unmarshall(ctx, params, attachments, "Status", basepath);
	return hasValue;
}

const char * CRoxieControlEndpointInfo::getAddress() { return m_Address.query();}
bool CRoxieControlEndpointInfo::getAttached_isNull(){return m_Attached.is_nil();}
bool CRoxieControlEndpointInfo::getAttached() { return m_Attached;}
const char * CRoxieControlEndpointInfo::getStateHash() { return m_StateHash.query();}
const char * CRoxieControlEndpointInfo::getStatus() { return m_Status.query();}
void CRoxieControlEndpointInfo::setAddress(const char * val){ m_Address.set(val); }
void CRoxieControlEndpointInfo::setAttached_null(){ m_Attached.Nil(); }void CRoxieControlEndpointInfo::setAttached(bool val){ m_Attached=val; }
void CRoxieControlEndpointInfo::setStateHash(const char * val){ m_StateHash.set(val); }
void CRoxieControlEndpointInfo::setStatus(const char * val){ m_Status.set(val); }
extern "C"  IEspRoxieControlEndpointInfo *createRoxieControlEndpointInfo(const char *serv, const char *msgname){return ((IEspRoxieControlEndpointInfo *)new CRoxieControlEndpointInfo(serv /*, msgname*/));}
extern "C"  IClientRoxieControlEndpointInfo *createClientRoxieControlEndpointInfo(const char *serv, const char *msgname){return ((IClientRoxieControlEndpointInfo *)new CRoxieControlEndpointInfo(serv /*, msgname*/));}

//=======================================================
// class CRoxieControlCmdResponse Implementation
//=======================================================

CRoxieControlCmdResponse::CRoxieControlCmdResponse(const char *serviceName, IRpcMessageBinding *init)
	: m_Endpoints(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("RoxieControlCmdResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CRoxieControlCmdResponse::CRoxieControlCmdResponse(const char *serviceName, const char *bc)
	: m_Endpoints(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("RoxieControlCmdResponse");
}

CRoxieControlCmdResponse::CRoxieControlCmdResponse(const char *serviceName, IRpcMessage* rpcmsg)
	: m_Endpoints(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("RoxieControlCmdResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CRoxieControlCmdResponse::CRoxieControlCmdResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_Endpoints(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("RoxieControlCmdResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CRoxieControlCmdResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		schema.append("<xsd:element name=\"Exceptions\" type=\"tns:ArrayOfEspException\" minOccurs=\"0\" maxOccurs=\"1\"/>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Endpoints\">\n");
		schema.append("<xsd:complexType><xsd:sequence>\n");
		schema.append("<xsd:element minOccurs=\"0\" maxOccurs=\"unbounded\" name=\"Endpoint\" type=\"tns:RoxieControlEndpointInfo\"/>");
		schema.append("</xsd:sequence></xsd:complexType>");
		schema.append("</xsd:element>");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	if (!(flags & 0x10)  || (flags & 0x100))
	{
		CRoxieControlEndpointInfo::getXsdDefinition(context, request, schema, added);
	}
	return schema;
}

void CRoxieControlCmdResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CRoxieControlCmdResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
	if (!added.getValue("RoxieControlEndpointInfo"))
	{
		added.setValue("RoxieControlEndpointInfo",1);
		CRoxieControlEndpointInfo::getMapInfo(info,added);
	}
}

StringBuffer &CRoxieControlCmdResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Endpoints");
	form.appendf("<tr><td><b>Endpoints: </b></td><td>");
	form.appendf("<table><tr><td><textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea></td>", extfix.str());
	form.append("</tr></table>");
	form.append("</td></tr>");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CRoxieControlCmdResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CRoxieControlCmdResponse::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
		m_Endpoints.marshall(rpc_resp, "Endpoints", "Endpoint");
	}
}


void CRoxieControlCmdResponse::copy(CRoxieControlCmdResponse &from)
{
	m_Endpoints.copy(from.m_Endpoints);
}


void CRoxieControlCmdResponse::copy(IConstRoxieControlCmdResponse &ifrom)
{
	setEndpoints(ifrom.getEndpoints());
}


void CRoxieControlCmdResponse::getAttributes(IProperties &attributes)
{
}


void CRoxieControlCmdResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
		m_Endpoints.toStr(ctx, buffer, "Endpoints", "Endpoint");
	}
}


void CRoxieControlCmdResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CRoxieControlCmdResponse::serializer(IEspContext* ctx, IConstRoxieControlCmdResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<RoxieControlCmdResponse>");
	// field Endpoints
	{
		IArrayOf<IConstRoxieControlEndpointInfo>& v = src.getEndpoints();
		int size = v.length();
		if (size>0)
			buffer.append("<Endpoints>");
		for (int i=0;i<size;i++)
		{
			buffer.append("<Endpoint>");
			CRoxieControlEndpointInfo::serializer(ctx,v.item(i),buffer,false);
			buffer.append("</Endpoint>");
		}
		if (size>0)
			buffer.append("</Endpoints>");
	}
	if (keepRootTag)
		buffer.append("</RoxieControlCmdResponse>");
}

bool CRoxieControlCmdResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
		hasValue |= m_Endpoints.unmarshall(rpc_request, "Endpoints", basepath);
	}
	return hasValue;
}

bool CRoxieControlCmdResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Endpoints.unmarshall(ctx, soapval, "Endpoints");
	return hasValue;
}

bool CRoxieControlCmdResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Endpoints.unmarshall(ctx, params, attachments, "Endpoints", basepath);
	return hasValue;
}

IArrayOf<IConstRoxieControlEndpointInfo> & CRoxieControlCmdResponse::getEndpoints() { return (IArrayOf<IConstRoxieControlEndpointInfo> &) m_Endpoints; }
void CRoxieControlCmdResponse::setEndpoints(IArrayOf<IEspRoxieControlEndpointInfo> &val)
{
	m_Endpoints->kill();
	IArrayOf<IConstRoxieControlEndpointInfo> &target = m_Endpoints.getValue();
	ForEachItemIn(idx, val)
	{
		IEspRoxieControlEndpointInfo &item = (val).item(idx);
		item.Link();
		target.append(item);
	}
}
void CRoxieControlCmdResponse::setEndpoints(IArrayOf<IConstRoxieControlEndpointInfo> &val)
{
	m_Endpoints->kill();
	IArrayOf<IConstRoxieControlEndpointInfo> &target = m_Endpoints.getValue();
	ForEachItemIn(idx, val)
	{
		IConstRoxieControlEndpointInfo &item = val.item(idx);
		item.Link();
		target.append(item);
	}
}
extern "C"  IEspRoxieControlCmdResponse *createRoxieControlCmdResponse(const char *serv){return ((IEspRoxieControlCmdResponse *)new CRoxieControlCmdResponse(serv));}
extern "C"  IClientRoxieControlCmdResponse *createClientRoxieControlCmdResponse(const char *serv){return ((IClientRoxieControlCmdResponse *)new CRoxieControlCmdResponse(serv));}

//=======================================================
// class CGetStatusServerInfoRequest Implementation
//=======================================================

CGetStatusServerInfoRequest::CGetStatusServerInfoRequest(const char *serviceName, IRpcMessageBinding *init)
	: m_ServerName(nilIgnore),m_ServerType(nilIgnore),m_NetworkAddress(nilIgnore),m_Port(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetStatusServerInfoRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CGetStatusServerInfoRequest::CGetStatusServerInfoRequest(const char *serviceName, const char *bc)
	: m_ServerName(nilIgnore),m_ServerType(nilIgnore),m_NetworkAddress(nilIgnore),m_Port(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetStatusServerInfoRequest");
}

CGetStatusServerInfoRequest::CGetStatusServerInfoRequest(const char *serviceName, IRpcMessage* rpcmsg)
	: m_ServerName(nilIgnore),m_ServerType(nilIgnore),m_NetworkAddress(nilIgnore),m_Port(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetStatusServerInfoRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CGetStatusServerInfoRequest::CGetStatusServerInfoRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_ServerName(nilIgnore),m_ServerType(nilIgnore),m_NetworkAddress(nilIgnore),m_Port(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetStatusServerInfoRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CGetStatusServerInfoRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"ServerName\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"ServerType\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"NetworkAddress\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Port\" type=\"xsd:int\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CGetStatusServerInfoRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CGetStatusServerInfoRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CGetStatusServerInfoRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("ServerName");
	form.appendf("  <tr><td><b>ServerName: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("ServerType");
	form.appendf("  <tr><td><b>ServerType: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("NetworkAddress");
	form.appendf("  <tr><td><b>NetworkAddress: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix) extfix.append(prefix).append(".");
		extfix.append("Port");
	form.appendf("  <tr><td><b>Port: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CGetStatusServerInfoRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CGetStatusServerInfoRequest::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_ServerName.marshall(rpc_resp, "ServerName", "", "", "");
	m_ServerType.marshall(rpc_resp, "ServerType", "", "", "");
	m_NetworkAddress.marshall(rpc_resp, "NetworkAddress", "", "", "");
	m_Port.marshall(rpc_resp, "Port", "", "", "");
}


void CGetStatusServerInfoRequest::copy(CGetStatusServerInfoRequest &from)
{
	m_ServerName.copy(from.m_ServerName);
	m_ServerType.copy(from.m_ServerType);
	m_NetworkAddress.copy(from.m_NetworkAddress);
	m_Port.copy(from.m_Port);
}


void CGetStatusServerInfoRequest::copy(IConstGetStatusServerInfoRequest &ifrom)
{
	setServerName(ifrom.getServerName());
	setServerType(ifrom.getServerType());
	setNetworkAddress(ifrom.getNetworkAddress());
	setPort(ifrom.getPort());
}


void CGetStatusServerInfoRequest::getAttributes(IProperties &attributes)
{
}


void CGetStatusServerInfoRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_ServerName.toStr(ctx, buffer, "ServerName", "", true, "", "");
	m_ServerType.toStr(ctx, buffer, "ServerType", "", true, "", "");
	m_NetworkAddress.toStr(ctx, buffer, "NetworkAddress", "", true, "", "");
	m_Port.toStr(ctx, buffer, "Port", "", true, "", "");
}


void CGetStatusServerInfoRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CGetStatusServerInfoRequest::serializer(IEspContext* ctx, IConstGetStatusServerInfoRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<GetStatusServerInfoRequest>");
	// field ServerName
	{
		const char* s = src.getServerName();
		if (s && *s)
		{
			buffer.append("<ServerName>");
			encodeUtf8XML(s,buffer);
			buffer.append("</ServerName>");
		}
	}
	// field ServerType
	{
		const char* s = src.getServerType();
		if (s && *s)
		{
			buffer.append("<ServerType>");
			encodeUtf8XML(s,buffer);
			buffer.append("</ServerType>");
		}
	}
	// field NetworkAddress
	{
		const char* s = src.getNetworkAddress();
		if (s && *s)
		{
			buffer.append("<NetworkAddress>");
			encodeUtf8XML(s,buffer);
			buffer.append("</NetworkAddress>");
		}
	}
	// field Port
	{
		int n = src.getPort();
		if (n)
			buffer.appendf("<Port>%d</Port>", n);
	}
	if (keepRootTag)
		buffer.append("</GetStatusServerInfoRequest>");
}

bool CGetStatusServerInfoRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_ServerName.unmarshall(rpc_request, "ServerName", basepath);
	hasValue |= m_ServerType.unmarshall(rpc_request, "ServerType", basepath);
	hasValue |= m_NetworkAddress.unmarshall(rpc_request, "NetworkAddress", basepath);
	hasValue |= m_Port.unmarshall(rpc_request, "Port", basepath);
	return hasValue;
}

bool CGetStatusServerInfoRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_ServerName.unmarshall(ctx, soapval, "ServerName");
	hasValue |= m_ServerType.unmarshall(ctx, soapval, "ServerType");
	hasValue |= m_NetworkAddress.unmarshall(ctx, soapval, "NetworkAddress");
	hasValue |= m_Port.unmarshall(ctx, soapval, "Port");
	return hasValue;
}

bool CGetStatusServerInfoRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_ServerName.unmarshall(ctx, params, attachments, "ServerName", basepath);
	hasValue |= m_ServerType.unmarshall(ctx, params, attachments, "ServerType", basepath);
	hasValue |= m_NetworkAddress.unmarshall(ctx, params, attachments, "NetworkAddress", basepath);
	hasValue |= m_Port.unmarshall(ctx, params, attachments, "Port", basepath);
	return hasValue;
}

const char * CGetStatusServerInfoRequest::getServerName() { return m_ServerName.query();}
const char * CGetStatusServerInfoRequest::getServerType() { return m_ServerType.query();}
const char * CGetStatusServerInfoRequest::getNetworkAddress() { return m_NetworkAddress.query();}
int CGetStatusServerInfoRequest::getPort() { return m_Port;}
void CGetStatusServerInfoRequest::setServerName(const char * val){ m_ServerName.set(val); }
void CGetStatusServerInfoRequest::setServerType(const char * val){ m_ServerType.set(val); }
void CGetStatusServerInfoRequest::setNetworkAddress(const char * val){ m_NetworkAddress.set(val); }
void CGetStatusServerInfoRequest::setPort(int val){ m_Port=val; }
extern "C"  IEspGetStatusServerInfoRequest *createGetStatusServerInfoRequest(const char *serv){return ((IEspGetStatusServerInfoRequest *)new CGetStatusServerInfoRequest(serv));}
extern "C"  IClientGetStatusServerInfoRequest *createClientGetStatusServerInfoRequest(const char *serv){return ((IClientGetStatusServerInfoRequest *)new CGetStatusServerInfoRequest(serv));}

//=======================================================
// class CGetStatusServerInfoResponse Implementation
//=======================================================

CGetStatusServerInfoResponse::CGetStatusServerInfoResponse(const char *serviceName, IRpcMessageBinding *init)
	: m_StatusServerInfo(serviceName, nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetStatusServerInfoResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CGetStatusServerInfoResponse::CGetStatusServerInfoResponse(const char *serviceName, const char *bc)
	: m_StatusServerInfo(serviceName, nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetStatusServerInfoResponse");
}

CGetStatusServerInfoResponse::CGetStatusServerInfoResponse(const char *serviceName, IRpcMessage* rpcmsg)
	: m_StatusServerInfo(serviceName, nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetStatusServerInfoResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CGetStatusServerInfoResponse::CGetStatusServerInfoResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_StatusServerInfo(serviceName, nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetStatusServerInfoResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CGetStatusServerInfoResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		schema.append("<xsd:element name=\"Exceptions\" type=\"tns:ArrayOfEspException\" minOccurs=\"0\" maxOccurs=\"1\"/>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"StatusServerInfo\" type=\"tns:StatusServerInfo\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	if (!(flags & 0x10)  || (flags & 0x100))
	{
		CStatusServerInfo::getXsdDefinition(context, request, schema, added);
	}
	return schema;
}

void CGetStatusServerInfoResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CGetStatusServerInfoResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
	if (!added.getValue("StatusServerInfo"))
	{
		added.setValue("StatusServerInfo",1);
		CStatusServerInfo::getMapInfo(info,added);
	}
}

StringBuffer &CGetStatusServerInfoResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("StatusServerInfo");
	form.append("<tr>").append("<td><b>StatusServerInfo: </b></td><td><hr/>");
	CStatusServerInfo::getHtmlForm(context, request, serv, method, form, false, extfix.str());
	form.append("<hr/></td></tr>");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CGetStatusServerInfoResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CGetStatusServerInfoResponse::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
		m_StatusServerInfo.marshall(rpc_resp, "StatusServerInfo", "", "", "");
	}
}


void CGetStatusServerInfoResponse::copy(CGetStatusServerInfoResponse &from)
{
	m_StatusServerInfo.copy(from.m_StatusServerInfo);
}


void CGetStatusServerInfoResponse::copy(IConstGetStatusServerInfoResponse &ifrom)
{
	setStatusServerInfo(ifrom.getStatusServerInfo());
}


void CGetStatusServerInfoResponse::getAttributes(IProperties &attributes)
{
}


void CGetStatusServerInfoResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
		m_StatusServerInfo.toStr(ctx, buffer, "StatusServerInfo", "", false, "", "");
	}
}


void CGetStatusServerInfoResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CGetStatusServerInfoResponse::serializer(IEspContext* ctx, IConstGetStatusServerInfoResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<GetStatusServerInfoResponse>");
	// field StatusServerInfo
	{
		StringBuffer tmp;
		CStatusServerInfo::serializer(ctx,src.getStatusServerInfo(), tmp, false);
		if (tmp.length()>0)
			buffer.appendf("<StatusServerInfo>%s</StatusServerInfo>",tmp.str());
	}
	if (keepRootTag)
		buffer.append("</GetStatusServerInfoResponse>");
}

bool CGetStatusServerInfoResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
		hasValue |= m_StatusServerInfo.unmarshall(rpc_request, "StatusServerInfo", basepath);
	}
	return hasValue;
}

bool CGetStatusServerInfoResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_StatusServerInfo.unmarshall(ctx, soapval, "StatusServerInfo");
	return hasValue;
}

bool CGetStatusServerInfoResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_StatusServerInfo.unmarshall(ctx, params, attachments, "StatusServerInfo", basepath);
	return hasValue;
}

IConstStatusServerInfo & CGetStatusServerInfoResponse::getStatusServerInfo() { return (IConstStatusServerInfo &) m_StatusServerInfo.getValue();}
IEspStatusServerInfo & CGetStatusServerInfoResponse::updateStatusServerInfo(){ return (IEspStatusServerInfo &) m_StatusServerInfo.getValue(); }
void CGetStatusServerInfoResponse::setStatusServerInfo(IConstStatusServerInfo &ifrom){ m_StatusServerInfo.copy(ifrom); }
extern "C"  IEspGetStatusServerInfoResponse *createGetStatusServerInfoResponse(const char *serv){return ((IEspGetStatusServerInfoResponse *)new CGetStatusServerInfoResponse(serv));}
extern "C"  IClientGetStatusServerInfoResponse *createClientGetStatusServerInfoResponse(const char *serv){return ((IClientGetStatusServerInfoResponse *)new CGetStatusServerInfoResponse(serv));}

//=======================================================
// class CLock Implementation
//=======================================================

CLock::CLock(const char *serviceName, IRpcMessageBinding *init)
	: m_EPIP(nilRemove),m_XPath(nilRemove),m_LogicalFile(nilRemove),m_SessionID(nilRemove),m_DurationMS(nilRemove),m_TimeLocked(nilRemove),m_Modes(nilRemove),m_ModeNames(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("Lock");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CLock::CLock(const char *serviceName, const char *bc)
	: m_EPIP(nilRemove),m_XPath(nilRemove),m_LogicalFile(nilRemove),m_SessionID(nilRemove),m_DurationMS(nilRemove),m_TimeLocked(nilRemove),m_Modes(nilRemove),m_ModeNames(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("Lock");
}

StringBuffer &CLock::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:complexType name=\"%s\">\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"EPIP\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"XPath\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"LogicalFile\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"SessionID\" type=\"xsd:long\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"DurationMS\" type=\"xsd:unsignedInt\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"TimeLocked\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Modes\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"ModeNames\" type=\"tns:EspStringArray\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType>\n");
		}
	}
	if (added.getValue("EspStringArray")==NULL) {
		addEspNativeArray(schema,"string","EspStringArray");
		added.setValue("EspStringArray",1);
	}
	return schema;
}

void CLock::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CLock::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CLock::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("EPIP");
	form.appendf("  <tr><td><b>EPIP: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("XPath");
	form.appendf("  <tr><td><b>XPath: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("LogicalFile");
	form.appendf("  <tr><td><b>LogicalFile: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("SessionID");
	form.appendf("  <tr><td><b>SessionID: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix) extfix.append(prefix).append(".");
		extfix.append("DurationMS");
	form.appendf("  <tr><td><b>DurationMS: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("TimeLocked");
	form.appendf("  <tr><td><b>TimeLocked: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Modes");
	form.appendf("  <tr><td><b>Modes: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("ModeNames");
	form.appendf("<tr><td><b>ModeNames: </b></td><td>");
	form.appendf("<textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea>", extfix.str());
	form.append("</td></tr>");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CLock::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CLock::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_EPIP.marshall(rpc_resp, "EPIP", "", "", "");
	m_XPath.marshall(rpc_resp, "XPath", "", "", "");
	m_LogicalFile.marshall(rpc_resp, "LogicalFile", "", "", "");
	m_SessionID.marshall(rpc_resp, "SessionID", "", "", "");
	m_DurationMS.marshall(rpc_resp, "DurationMS", "", "", "");
	m_TimeLocked.marshall(rpc_resp, "TimeLocked", "", "", "");
	m_Modes.marshall(rpc_resp, "Modes", "", "", "");
	m_ModeNames.marshall(rpc_resp, "ModeNames", "Item");
}


void CLock::copy(CLock &from)
{
	m_EPIP.copy(from.m_EPIP);
	m_XPath.copy(from.m_XPath);
	m_LogicalFile.copy(from.m_LogicalFile);
	m_SessionID.copy(from.m_SessionID);
	m_DurationMS.copy(from.m_DurationMS);
	m_TimeLocked.copy(from.m_TimeLocked);
	m_Modes.copy(from.m_Modes);
	m_ModeNames.copy(from.m_ModeNames);
}


void CLock::copy(IConstLock &ifrom)
{
	setEPIP(ifrom.getEPIP());
	setXPath(ifrom.getXPath());
	setLogicalFile(ifrom.getLogicalFile());
	setSessionID(ifrom.getSessionID());
	setDurationMS(ifrom.getDurationMS());
	setTimeLocked(ifrom.getTimeLocked());
	setModes(ifrom.getModes());
	setModeNames(ifrom.getModeNames());
}


void CLock::getAttributes(IProperties &attributes)
{
}


void CLock::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_EPIP.toStr(ctx, buffer, "EPIP", "", true, "", "");
	m_XPath.toStr(ctx, buffer, "XPath", "", true, "", "");
	m_LogicalFile.toStr(ctx, buffer, "LogicalFile", "", true, "", "");
	m_SessionID.toStr(ctx, buffer, "SessionID", "", true, "", "");
	m_DurationMS.toStr(ctx, buffer, "DurationMS", "", true, "", "");
	m_TimeLocked.toStr(ctx, buffer, "TimeLocked", "", true, "", "");
	m_Modes.toStr(ctx, buffer, "Modes", "", true, "", "");
	m_ModeNames.toStr(ctx, buffer, "ModeNames", "Item");
}


void CLock::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CLock::serializer(IEspContext* ctx, IConstLock &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<Lock>");
	// field EPIP
	{
		const char* s = src.getEPIP();
		if (s && *s)
		{
			buffer.append("<EPIP>");
			encodeUtf8XML(s,buffer);
			buffer.append("</EPIP>");
		}
	}
	// field XPath
	{
		const char* s = src.getXPath();
		if (s && *s)
		{
			buffer.append("<XPath>");
			encodeUtf8XML(s,buffer);
			buffer.append("</XPath>");
		}
	}
	// field LogicalFile
	{
		const char* s = src.getLogicalFile();
		if (s && *s)
		{
			buffer.append("<LogicalFile>");
			encodeUtf8XML(s,buffer);
			buffer.append("</LogicalFile>");
		}
	}
	// field SessionID
	{
		//*** default kind: TK_INT; type=int64, name=SessionID
		buffer.append("<SessionID>");
		buffer.append(src.getSessionID());
		buffer.append("</SessionID>");
	}
	// field DurationMS
	{
		//*** default kind: TK_UNSIGNED; type=(null), name=DurationMS
		buffer.append("<DurationMS>");
		buffer.append(src.getDurationMS());
		buffer.append("</DurationMS>");
	}
	// field TimeLocked
	{
		const char* s = src.getTimeLocked();
		if (s && *s)
		{
			buffer.append("<TimeLocked>");
			encodeUtf8XML(s,buffer);
			buffer.append("</TimeLocked>");
		}
	}
	// field Modes
	{
		const char* s = src.getModes();
		if (s && *s)
		{
			buffer.append("<Modes>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Modes>");
		}
	}
	// field ModeNames
	{
		StringArray& v = src.getModeNames();
		if (v.length()>0)
			buffer.append("<ModeNames>");
		for (size32_t i=0;i<v.length();i++)
			buffer.appendf("<Item>%s</Item>",v.item(i));
		if (v.length()>0)
			buffer.append("</ModeNames>");
	}
	if (keepRootTag)
		buffer.append("</Lock>");
}

bool CLock::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_EPIP.unmarshall(rpc_request, "EPIP", basepath);
	hasValue |= m_XPath.unmarshall(rpc_request, "XPath", basepath);
	hasValue |= m_LogicalFile.unmarshall(rpc_request, "LogicalFile", basepath);
	hasValue |= m_SessionID.unmarshall(rpc_request, "SessionID", basepath);
	hasValue |= m_DurationMS.unmarshall(rpc_request, "DurationMS", basepath);
	hasValue |= m_TimeLocked.unmarshall(rpc_request, "TimeLocked", basepath);
	hasValue |= m_Modes.unmarshall(rpc_request, "Modes", basepath);
	hasValue |= m_ModeNames.unmarshall(rpc_request, "ModeNames", basepath);
	return hasValue;
}

bool CLock::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_EPIP.unmarshall(ctx, soapval, "EPIP");
	hasValue |= m_XPath.unmarshall(ctx, soapval, "XPath");
	hasValue |= m_LogicalFile.unmarshall(ctx, soapval, "LogicalFile");
	hasValue |= m_SessionID.unmarshall(ctx, soapval, "SessionID");
	hasValue |= m_DurationMS.unmarshall(ctx, soapval, "DurationMS");
	hasValue |= m_TimeLocked.unmarshall(ctx, soapval, "TimeLocked");
	hasValue |= m_Modes.unmarshall(ctx, soapval, "Modes");
	hasValue |= m_ModeNames.unmarshall(ctx, soapval, "ModeNames");
	return hasValue;
}

bool CLock::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_EPIP.unmarshall(ctx, params, attachments, "EPIP", basepath);
	hasValue |= m_XPath.unmarshall(ctx, params, attachments, "XPath", basepath);
	hasValue |= m_LogicalFile.unmarshall(ctx, params, attachments, "LogicalFile", basepath);
	hasValue |= m_SessionID.unmarshall(ctx, params, attachments, "SessionID", basepath);
	hasValue |= m_DurationMS.unmarshall(ctx, params, attachments, "DurationMS", basepath);
	hasValue |= m_TimeLocked.unmarshall(ctx, params, attachments, "TimeLocked", basepath);
	hasValue |= m_Modes.unmarshall(ctx, params, attachments, "Modes", basepath);
	hasValue |= m_ModeNames.unmarshall(ctx, params, attachments, "ModeNames", basepath);
	return hasValue;
}

const char * CLock::getEPIP() { return m_EPIP.query();}
const char * CLock::getXPath() { return m_XPath.query();}
const char * CLock::getLogicalFile() { return m_LogicalFile.query();}
bool CLock::getSessionID_isNull(){return m_SessionID.is_nil();}
__int64 CLock::getSessionID() { return m_SessionID;}
bool CLock::getDurationMS_isNull(){return m_DurationMS.is_nil();}
unsigned int CLock::getDurationMS() { return m_DurationMS;}
const char * CLock::getTimeLocked() { return m_TimeLocked.query();}
const char * CLock::getModes() { return m_Modes.query();}
StringArray & CLock::getModeNames() { return (StringArray &) m_ModeNames; }
void CLock::setEPIP(const char * val){ m_EPIP.set(val); }
void CLock::setXPath(const char * val){ m_XPath.set(val); }
void CLock::setLogicalFile(const char * val){ m_LogicalFile.set(val); }
void CLock::setSessionID_null(){ m_SessionID.Nil(); }void CLock::setSessionID(__int64 val){ m_SessionID=val; }
void CLock::setDurationMS_null(){ m_DurationMS.Nil(); }void CLock::setDurationMS(unsigned int val){ m_DurationMS=val; }
void CLock::setTimeLocked(const char * val){ m_TimeLocked.set(val); }
void CLock::setModes(const char * val){ m_Modes.set(val); }
void CLock::setModeNames(StringArray &val){ m_ModeNames->kill();  CloneArray(m_ModeNames.getValue(), val); }
extern "C"  IEspLock *createLock(const char *serv, const char *msgname){return ((IEspLock *)new CLock(serv /*, msgname*/));}
extern "C"  IClientLock *createClientLock(const char *serv, const char *msgname){return ((IClientLock *)new CLock(serv /*, msgname*/));}

//=======================================================
// class CLockQueryRequest Implementation
//=======================================================

CLockQueryRequest::CLockQueryRequest(const char *serviceName, IRpcMessageBinding *init)
	: m_EPIP(nilRemove),m_XPath(nilRemove),m_DurationMSLow(nilRemove),m_DurationMSHigh(nilRemove),m_TimeLockedLow(nilRemove),m_TimeLockedHigh(nilRemove),m_Mode(nilRemove),m_AllFileLocks(0, nilRemove,false)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("LockQueryRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CLockQueryRequest::CLockQueryRequest(const char *serviceName, const char *bc)
	: m_EPIP(nilRemove),m_XPath(nilRemove),m_DurationMSLow(nilRemove),m_DurationMSHigh(nilRemove),m_TimeLockedLow(nilRemove),m_TimeLockedHigh(nilRemove),m_Mode(nilRemove),m_AllFileLocks(0, nilRemove,false)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("LockQueryRequest");
}

CLockQueryRequest::CLockQueryRequest(const char *serviceName, IRpcMessage* rpcmsg)
	: m_EPIP(nilRemove),m_XPath(nilRemove),m_DurationMSLow(nilRemove),m_DurationMSHigh(nilRemove),m_TimeLockedLow(nilRemove),m_TimeLockedHigh(nilRemove),m_Mode(nilRemove),m_AllFileLocks(0, nilRemove,false)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("LockQueryRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CLockQueryRequest::CLockQueryRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_EPIP(nilRemove),m_XPath(nilRemove),m_DurationMSLow(nilRemove),m_DurationMSHigh(nilRemove),m_TimeLockedLow(nilRemove),m_TimeLockedHigh(nilRemove),m_Mode(nilRemove),m_AllFileLocks(0, nilRemove,false)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("LockQueryRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CLockQueryRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"EPIP\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"XPath\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"DurationMSLow\" type=\"xsd:unsignedInt\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"DurationMSHigh\" type=\"xsd:unsignedInt\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"TimeLockedLow\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"TimeLockedHigh\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Mode\" type=\"tns:LockModes\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" default=\"false\" name=\"AllFileLocks\" type=\"xsd:boolean\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	if (!(flags & 0x10)  || (flags & 0x100))
	{
		CXLockModes::getXsdDefinition(context, request, schema, added);
	}
	return schema;
}

void CLockQueryRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CLockQueryRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
	if (!added.getValue("LockModes"))
	{
		added.setValue("LockModes",1);
		CXLockModes::getMapInfo(info,added);
	}
}

StringBuffer &CLockQueryRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("EPIP");
	form.appendf("  <tr><td><b>EPIP: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("XPath");
	form.appendf("  <tr><td><b>XPath: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix) extfix.append(prefix).append(".");
		extfix.append("DurationMSLow");
	form.appendf("  <tr><td><b>DurationMSLow: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix) extfix.append(prefix).append(".");
		extfix.append("DurationMSHigh");
	form.appendf("  <tr><td><b>DurationMSHigh: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("TimeLockedLow");
	form.appendf("  <tr><td><b>TimeLockedLow: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("TimeLockedHigh");
	form.appendf("  <tr><td><b>TimeLockedHigh: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Mode");
	form.appendf("  <tr><td><b>Mode: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("AllFileLocks");
	
	form.appendf("  <tr><td><b>AllFileLocks? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CLockQueryRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CLockQueryRequest::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_EPIP.marshall(rpc_resp, "EPIP", "", "", "");
	m_XPath.marshall(rpc_resp, "XPath", "", "", "");
	m_DurationMSLow.marshall(rpc_resp, "DurationMSLow", "", "", "");
	m_DurationMSHigh.marshall(rpc_resp, "DurationMSHigh", "", "", "");
	m_TimeLockedLow.marshall(rpc_resp, "TimeLockedLow", "", "", "");
	m_TimeLockedHigh.marshall(rpc_resp, "TimeLockedHigh", "", "", "");
	m_Mode.marshall(rpc_resp, "Mode", "", "", "");
	m_AllFileLocks.marshall(rpc_resp, "AllFileLocks", "", "", "");
}


void CLockQueryRequest::copy(CLockQueryRequest &from)
{
	m_EPIP.copy(from.m_EPIP);
	m_XPath.copy(from.m_XPath);
	m_DurationMSLow.copy(from.m_DurationMSLow);
	m_DurationMSHigh.copy(from.m_DurationMSHigh);
	m_TimeLockedLow.copy(from.m_TimeLockedLow);
	m_TimeLockedHigh.copy(from.m_TimeLockedHigh);
	m_Mode.copy(from.m_Mode);
	m_AllFileLocks.copy(from.m_AllFileLocks);
}


void CLockQueryRequest::copy(IConstLockQueryRequest &ifrom)
{
	setEPIP(ifrom.getEPIP());
	setXPath(ifrom.getXPath());
	setDurationMSLow(ifrom.getDurationMSLow());
	setDurationMSHigh(ifrom.getDurationMSHigh());
	setTimeLockedLow(ifrom.getTimeLockedLow());
	setTimeLockedHigh(ifrom.getTimeLockedHigh());
	setMode(ifrom.getMode());
	setAllFileLocks(ifrom.getAllFileLocks());
}


void CLockQueryRequest::getAttributes(IProperties &attributes)
{
}


void CLockQueryRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_EPIP.toStr(ctx, buffer, "EPIP", "", true, "", "");
	m_XPath.toStr(ctx, buffer, "XPath", "", true, "", "");
	m_DurationMSLow.toStr(ctx, buffer, "DurationMSLow", "", true, "", "");
	m_DurationMSHigh.toStr(ctx, buffer, "DurationMSHigh", "", true, "", "");
	m_TimeLockedLow.toStr(ctx, buffer, "TimeLockedLow", "", true, "", "");
	m_TimeLockedHigh.toStr(ctx, buffer, "TimeLockedHigh", "", true, "", "");
	m_Mode.toStr(ctx, buffer, "Mode", "", true, "", "");
	m_AllFileLocks.toStr(ctx, buffer, "AllFileLocks", "", true, "", "");
}


void CLockQueryRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CLockQueryRequest::serializer(IEspContext* ctx, IConstLockQueryRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<LockQueryRequest>");
	// field EPIP
	{
		const char* s = src.getEPIP();
		if (s && *s)
		{
			buffer.append("<EPIP>");
			encodeUtf8XML(s,buffer);
			buffer.append("</EPIP>");
		}
	}
	// field XPath
	{
		const char* s = src.getXPath();
		if (s && *s)
		{
			buffer.append("<XPath>");
			encodeUtf8XML(s,buffer);
			buffer.append("</XPath>");
		}
	}
	// field DurationMSLow
	{
		//*** default kind: TK_UNSIGNED; type=(null), name=DurationMSLow
		buffer.append("<DurationMSLow>");
		buffer.append(src.getDurationMSLow());
		buffer.append("</DurationMSLow>");
	}
	// field DurationMSHigh
	{
		//*** default kind: TK_UNSIGNED; type=(null), name=DurationMSHigh
		buffer.append("<DurationMSHigh>");
		buffer.append(src.getDurationMSHigh());
		buffer.append("</DurationMSHigh>");
	}
	// field TimeLockedLow
	{
		const char* s = src.getTimeLockedLow();
		if (s && *s)
		{
			buffer.append("<TimeLockedLow>");
			encodeUtf8XML(s,buffer);
			buffer.append("</TimeLockedLow>");
		}
	}
	// field TimeLockedHigh
	{
		const char* s = src.getTimeLockedHigh();
		if (s && *s)
		{
			buffer.append("<TimeLockedHigh>");
			encodeUtf8XML(s,buffer);
			buffer.append("</TimeLockedHigh>");
		}
	}
	// field Mode
	{
		const char* s = src.getModeAsString();
		buffer.append("<Mode>");
		encodeUtf8XML(s,buffer);
		buffer.append("</Mode>");
	}
	// field AllFileLocks
	{
		bool b = src.getAllFileLocks();
		if (b)
			buffer.appendf("<AllFileLocks>1</AllFileLocks>");
	}
	if (keepRootTag)
		buffer.append("</LockQueryRequest>");
}

bool CLockQueryRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_EPIP.unmarshall(rpc_request, "EPIP", basepath);
	hasValue |= m_XPath.unmarshall(rpc_request, "XPath", basepath);
	hasValue |= m_DurationMSLow.unmarshall(rpc_request, "DurationMSLow", basepath);
	hasValue |= m_DurationMSHigh.unmarshall(rpc_request, "DurationMSHigh", basepath);
	hasValue |= m_TimeLockedLow.unmarshall(rpc_request, "TimeLockedLow", basepath);
	hasValue |= m_TimeLockedHigh.unmarshall(rpc_request, "TimeLockedHigh", basepath);
	hasValue |= m_Mode.unmarshall(rpc_request, "Mode", basepath);
	hasValue |= m_AllFileLocks.unmarshall(rpc_request, "AllFileLocks", basepath);
	return hasValue;
}

bool CLockQueryRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_EPIP.unmarshall(ctx, soapval, "EPIP");
	hasValue |= m_XPath.unmarshall(ctx, soapval, "XPath");
	hasValue |= m_DurationMSLow.unmarshall(ctx, soapval, "DurationMSLow");
	hasValue |= m_DurationMSHigh.unmarshall(ctx, soapval, "DurationMSHigh");
	hasValue |= m_TimeLockedLow.unmarshall(ctx, soapval, "TimeLockedLow");
	hasValue |= m_TimeLockedHigh.unmarshall(ctx, soapval, "TimeLockedHigh");
	hasValue |= m_Mode.unmarshall(ctx, soapval, "Mode");
	hasValue |= m_AllFileLocks.unmarshall(ctx, soapval, "AllFileLocks");
	return hasValue;
}

bool CLockQueryRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_EPIP.unmarshall(ctx, params, attachments, "EPIP", basepath);
	hasValue |= m_XPath.unmarshall(ctx, params, attachments, "XPath", basepath);
	hasValue |= m_DurationMSLow.unmarshall(ctx, params, attachments, "DurationMSLow", basepath);
	hasValue |= m_DurationMSHigh.unmarshall(ctx, params, attachments, "DurationMSHigh", basepath);
	hasValue |= m_TimeLockedLow.unmarshall(ctx, params, attachments, "TimeLockedLow", basepath);
	hasValue |= m_TimeLockedHigh.unmarshall(ctx, params, attachments, "TimeLockedHigh", basepath);
	hasValue |= m_Mode.unmarshall(ctx, params, attachments, "Mode", basepath);
	hasValue |= m_AllFileLocks.unmarshall(ctx, params, attachments, "AllFileLocks", basepath);
	return hasValue;
}

const char * CLockQueryRequest::getEPIP() { return m_EPIP.query();}
const char * CLockQueryRequest::getXPath() { return m_XPath.query();}
bool CLockQueryRequest::getDurationMSLow_isNull(){return m_DurationMSLow.is_nil();}
unsigned int CLockQueryRequest::getDurationMSLow() { return m_DurationMSLow;}
bool CLockQueryRequest::getDurationMSHigh_isNull(){return m_DurationMSHigh.is_nil();}
unsigned int CLockQueryRequest::getDurationMSHigh() { return m_DurationMSHigh;}
const char * CLockQueryRequest::getTimeLockedLow() { return m_TimeLockedLow.query();}
const char * CLockQueryRequest::getTimeLockedHigh() { return m_TimeLockedHigh.query();}
CLockModes CLockQueryRequest::getMode() { return m_Mode.getValue(); }
const char* CLockQueryRequest::getModeAsString() {  return (const char*)m_Mode; }
bool CLockQueryRequest::getAllFileLocks_isNull(){return m_AllFileLocks.is_nil();}
bool CLockQueryRequest::getAllFileLocks() { return m_AllFileLocks;}
void CLockQueryRequest::setEPIP(const char * val){ m_EPIP.set(val); }
void CLockQueryRequest::setXPath(const char * val){ m_XPath.set(val); }
void CLockQueryRequest::setDurationMSLow_null(){ m_DurationMSLow.Nil(); }void CLockQueryRequest::setDurationMSLow(unsigned int val){ m_DurationMSLow=val; }
void CLockQueryRequest::setDurationMSHigh_null(){ m_DurationMSHigh.Nil(); }void CLockQueryRequest::setDurationMSHigh(unsigned int val){ m_DurationMSHigh=val; }
void CLockQueryRequest::setTimeLockedLow(const char * val){ m_TimeLockedLow.set(val); }
void CLockQueryRequest::setTimeLockedHigh(const char * val){ m_TimeLockedHigh.set(val); }
void CLockQueryRequest::setMode(CLockModes val) { m_Mode.setValue(val); }
void CLockQueryRequest::setMode(const char* val) { m_Mode.setValue(val); }
void CLockQueryRequest::setAllFileLocks_null(){ m_AllFileLocks.Nil(); }void CLockQueryRequest::setAllFileLocks(bool val){ m_AllFileLocks=val; }
extern "C"  IEspLockQueryRequest *createLockQueryRequest(const char *serv){return ((IEspLockQueryRequest *)new CLockQueryRequest(serv));}
extern "C"  IClientLockQueryRequest *createClientLockQueryRequest(const char *serv){return ((IClientLockQueryRequest *)new CLockQueryRequest(serv));}

//=======================================================
// class CLockQueryResponse Implementation
//=======================================================

CLockQueryResponse::CLockQueryResponse(const char *serviceName, IRpcMessageBinding *init)
	: m_Locks(nilIgnore),m_NumLocks(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("LockQueryResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CLockQueryResponse::CLockQueryResponse(const char *serviceName, const char *bc)
	: m_Locks(nilIgnore),m_NumLocks(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("LockQueryResponse");
}

CLockQueryResponse::CLockQueryResponse(const char *serviceName, IRpcMessage* rpcmsg)
	: m_Locks(nilIgnore),m_NumLocks(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("LockQueryResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CLockQueryResponse::CLockQueryResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_Locks(nilIgnore),m_NumLocks(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("LockQueryResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CLockQueryResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		schema.append("<xsd:element name=\"Exceptions\" type=\"tns:ArrayOfEspException\" minOccurs=\"0\" maxOccurs=\"1\"/>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Locks\" type=\"tns:ArrayOfLock\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"NumLocks\" type=\"xsd:int\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	if (!(flags & 0x10)  || (flags & 0x100))
	{
		CLock::getXsdDefinition(context, request, schema, added);
	}
	if (added.getValue("Lock") && added.getValue("ArrayOfLock")==NULL) {
		schema.append("<xsd:complexType name=\"ArrayOfLock\">\n");
		schema.append("<xsd:sequence>\n");
		schema.append("<xsd:element minOccurs=\"0\" maxOccurs=\"unbounded\" name=\"Lock\" type=\"tns:Lock\"/>\n");
		schema.append("</xsd:sequence>\n");
		schema.append("</xsd:complexType>\n");
		added.setValue("ArrayOfLock",1);
	}
	return schema;
}

void CLockQueryResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CLockQueryResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
	if (!added.getValue("Lock"))
	{
		added.setValue("Lock",1);
		CLock::getMapInfo(info,added);
	}
}

StringBuffer &CLockQueryResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Locks");
	form.appendf("<tr><td><b>Locks: </b></td><td>");
	form.appendf("<table><tr><td><textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea></td>", extfix.str());
	form.append("</tr></table>");
	form.append("</td></tr>");
	extfix.clear();
	if (prefix && *prefix) extfix.append(prefix).append(".");
		extfix.append("NumLocks");
	form.appendf("  <tr><td><b>NumLocks: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CLockQueryResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CLockQueryResponse::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
		m_Locks.marshall(rpc_resp, "Locks", "Lock");
		m_NumLocks.marshall(rpc_resp, "NumLocks", "", "", "");
	}
}


void CLockQueryResponse::copy(CLockQueryResponse &from)
{
	m_Locks.copy(from.m_Locks);
	m_NumLocks.copy(from.m_NumLocks);
}


void CLockQueryResponse::copy(IConstLockQueryResponse &ifrom)
{
	setLocks(ifrom.getLocks());
	setNumLocks(ifrom.getNumLocks());
}


void CLockQueryResponse::getAttributes(IProperties &attributes)
{
}


void CLockQueryResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
		m_Locks.toStr(ctx, buffer, "Locks", "Lock");
		m_NumLocks.toStr(ctx, buffer, "NumLocks", "", true, "", "");
	}
}


void CLockQueryResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CLockQueryResponse::serializer(IEspContext* ctx, IConstLockQueryResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<LockQueryResponse>");
	// field Locks
	{
		IArrayOf<IConstLock>& v = src.getLocks();
		int size = v.length();
		if (size>0)
			buffer.append("<Locks>");
		for (int i=0;i<size;i++)
		{
			buffer.append("<Item>");
			CLock::serializer(ctx,v.item(i),buffer,false);
			buffer.append("</Item>");
		}
		if (size>0)
			buffer.append("</Locks>");
	}
	// field NumLocks
	{
		int n = src.getNumLocks();
		if (n)
			buffer.appendf("<NumLocks>%d</NumLocks>", n);
	}
	if (keepRootTag)
		buffer.append("</LockQueryResponse>");
}

bool CLockQueryResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
		hasValue |= m_Locks.unmarshall(rpc_request, "Locks", basepath);
		hasValue |= m_NumLocks.unmarshall(rpc_request, "NumLocks", basepath);
	}
	return hasValue;
}

bool CLockQueryResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Locks.unmarshall(ctx, soapval, "Locks");
	hasValue |= m_NumLocks.unmarshall(ctx, soapval, "NumLocks");
	return hasValue;
}

bool CLockQueryResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Locks.unmarshall(ctx, params, attachments, "Locks", basepath);
	hasValue |= m_NumLocks.unmarshall(ctx, params, attachments, "NumLocks", basepath);
	return hasValue;
}

IArrayOf<IConstLock> & CLockQueryResponse::getLocks() { return (IArrayOf<IConstLock> &) m_Locks; }
int CLockQueryResponse::getNumLocks() { return m_NumLocks;}
void CLockQueryResponse::setLocks(IArrayOf<IEspLock> &val)
{
	m_Locks->kill();
	IArrayOf<IConstLock> &target = m_Locks.getValue();
	ForEachItemIn(idx, val)
	{
		IEspLock &item = (val).item(idx);
		item.Link();
		target.append(item);
	}
}
void CLockQueryResponse::setLocks(IArrayOf<IConstLock> &val)
{
	m_Locks->kill();
	IArrayOf<IConstLock> &target = m_Locks.getValue();
	ForEachItemIn(idx, val)
	{
		IConstLock &item = val.item(idx);
		item.Link();
		target.append(item);
	}
}
void CLockQueryResponse::setNumLocks(int val){ m_NumLocks=val; }
extern "C"  IEspLockQueryResponse *createLockQueryResponse(const char *serv){return ((IEspLockQueryResponse *)new CLockQueryResponse(serv));}
extern "C"  IClientLockQueryResponse *createClientLockQueryResponse(const char *serv){return ((IClientLockQueryResponse *)new CLockQueryResponse(serv));}

//=======================================================
// class CWsSMCPingRequest Implementation
//=======================================================

CWsSMCPingRequest::CWsSMCPingRequest(const char *serviceName, IRpcMessageBinding *init)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("WsSMCPingRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CWsSMCPingRequest::CWsSMCPingRequest(const char *serviceName, const char *bc)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("WsSMCPingRequest");
}

CWsSMCPingRequest::CWsSMCPingRequest(const char *serviceName, IRpcMessage* rpcmsg)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("WsSMCPingRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CWsSMCPingRequest::CWsSMCPingRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("WsSMCPingRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CWsSMCPingRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType><xsd:all/></xsd:complexType></xsd:element>\n", msgTypeName);
		}
	}
	return schema;
}

void CWsSMCPingRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CWsSMCPingRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CWsSMCPingRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CWsSMCPingRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CWsSMCPingRequest::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

}


void CWsSMCPingRequest::copy(CWsSMCPingRequest &from)
{
}


void CWsSMCPingRequest::copy(IConstWsSMCPingRequest &ifrom)
{
}


void CWsSMCPingRequest::getAttributes(IProperties &attributes)
{
}


void CWsSMCPingRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
}


void CWsSMCPingRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CWsSMCPingRequest::serializer(IEspContext* ctx, IConstWsSMCPingRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<WsSMCPingRequest>");
	if (keepRootTag)
		buffer.append("</WsSMCPingRequest>");
}

bool CWsSMCPingRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	return hasValue;
}

bool CWsSMCPingRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	return hasValue;
}

bool CWsSMCPingRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	return hasValue;
}

extern "C"  IEspWsSMCPingRequest *createWsSMCPingRequest(const char *serv){return ((IEspWsSMCPingRequest *)new CWsSMCPingRequest(serv));}
extern "C"  IClientWsSMCPingRequest *createClientWsSMCPingRequest(const char *serv){return ((IClientWsSMCPingRequest *)new CWsSMCPingRequest(serv));}

//=======================================================
// class CWsSMCPingResponse Implementation
//=======================================================

CWsSMCPingResponse::CWsSMCPingResponse(const char *serviceName, IRpcMessageBinding *init)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("WsSMCPingResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CWsSMCPingResponse::CWsSMCPingResponse(const char *serviceName, const char *bc)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("WsSMCPingResponse");
}

CWsSMCPingResponse::CWsSMCPingResponse(const char *serviceName, IRpcMessage* rpcmsg)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("WsSMCPingResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CWsSMCPingResponse::CWsSMCPingResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("WsSMCPingResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CWsSMCPingResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType><xsd:all/></xsd:complexType></xsd:element>\n", msgTypeName);
		}
	}
	return schema;
}

void CWsSMCPingResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CWsSMCPingResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CWsSMCPingResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CWsSMCPingResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CWsSMCPingResponse::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
	}
}


void CWsSMCPingResponse::copy(CWsSMCPingResponse &from)
{
}


void CWsSMCPingResponse::copy(IConstWsSMCPingResponse &ifrom)
{
}


void CWsSMCPingResponse::getAttributes(IProperties &attributes)
{
}


void CWsSMCPingResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
	}
}


void CWsSMCPingResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CWsSMCPingResponse::serializer(IEspContext* ctx, IConstWsSMCPingResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<WsSMCPingResponse>");
	if (keepRootTag)
		buffer.append("</WsSMCPingResponse>");
}

bool CWsSMCPingResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
	}
	return hasValue;
}

bool CWsSMCPingResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	return hasValue;
}

bool CWsSMCPingResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	return hasValue;
}

extern "C"  IEspWsSMCPingResponse *createWsSMCPingResponse(const char *serv){return ((IEspWsSMCPingResponse *)new CWsSMCPingResponse(serv));}
extern "C"  IClientWsSMCPingResponse *createClientWsSMCPingResponse(const char *serv){return ((IClientWsSMCPingResponse *)new CWsSMCPingResponse(serv));}

//=======================================================
// class CWsSMCSoapBinding Implementation
//=======================================================

CWsSMCSoapBinding::CWsSMCSoapBinding(http_soap_log_level level):CHttpSoapBinding(NULL, NULL, NULL, level)
{
	init_strings();
	setWsdlVersion(1.21);
}

CWsSMCSoapBinding::CWsSMCSoapBinding(IPropertyTree* cfg, const char *bindname, const char *procname, http_soap_log_level level):CHttpSoapBinding(cfg, bindname, procname, level)
{
	init_strings(); 
	setWsdlVersion(1.21);

}

void CWsSMCSoapBinding::init_strings()
{
}

int CWsSMCSoapBinding::processRequest(IRpcMessage* rpc_call, IRpcMessage* rpc_response)
{
	if(rpc_call == NULL || rpc_response == NULL)
		return -1;

	IEspContext *ctx=rpc_call->queryContext();
	DBGLOG("Client version: %g", ctx->getClientVersion());
	StringBuffer serviceName;
	double clientVer=(ctx) ? ctx->getClientVersion() : 0.0;
	qualifyServiceName(*ctx, ctx->queryServiceName(NULL), NULL, serviceName, NULL);
	CRpcCall* thecall = static_cast<CRpcCall *>(rpc_call);
	CRpcResponse* response = static_cast<CRpcResponse*>(rpc_response);
	CHttpRequest* httprequest = thecall->getHttpReq();
	CHttpResponse* httpresponse = response->getHttpResp();

	Owned<IEspWsSMC> iserv = (IEspWsSMC*)getService();
	if(iserv == NULL)
	{
		response->set_status(SOAP_SERVER_ERROR);
		response->set_err("Service not available");
		DBGLOG("Service not available");
		return -1;
	}
	if (thecall->get_name() == NULL)
	{
		response->set_status(SOAP_CLIENT_ERROR);
		response->set_err("No service method specified");
		ERRLOG("No service method specified");
		return -1;
	}

	IEspContext& context = *rpc_call->queryContext();

	if(!stricmp(thecall->get_name(), "Activity")||!stricmp(thecall->get_name(), "ActivityRequest"))
	{
		Owned<CActivityRequest> esp_request = new CActivityRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CActivityResponse> esp_response = new CActivityResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		StringBuffer source;
		source.appendf("WsSMC::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "WsSMC", "Activity");
			iserv->onActivity(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "WsSMC", "Activity");
		response->set_name("ActivityResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "BrowseResources")||!stricmp(thecall->get_name(), "BrowseResourcesRequest"))
	{
		Owned<CBrowseResourcesRequest> esp_request = new CBrowseResourcesRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CBrowseResourcesResponse> esp_response = new CBrowseResourcesResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		StringBuffer source;
		source.appendf("WsSMC::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "WsSMC", "BrowseResources");
			iserv->onBrowseResources(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "WsSMC", "BrowseResources");
		response->set_name("BrowseResourcesResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "ClearQueue")||!stricmp(thecall->get_name(), "SMCQueueRequest"))
	{
		Owned<CSMCQueueRequest> esp_request = new CSMCQueueRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CSMCQueueResponse> esp_response = new CSMCQueueResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		StringBuffer source;
		source.appendf("WsSMC::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "WsSMC", "ClearQueue");
			iserv->onClearQueue(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "WsSMC", "ClearQueue");
		response->set_name("SMCQueueResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "GetStatusServerInfo")||!stricmp(thecall->get_name(), "GetStatusServerInfoRequest"))
	{
		Owned<CGetStatusServerInfoRequest> esp_request = new CGetStatusServerInfoRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CGetStatusServerInfoResponse> esp_response = new CGetStatusServerInfoResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		StringBuffer source;
		source.appendf("WsSMC::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "WsSMC", "GetStatusServerInfo");
			iserv->onGetStatusServerInfo(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "WsSMC", "GetStatusServerInfo");
		response->set_name("GetStatusServerInfoResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "GetThorQueueAvailability")||!stricmp(thecall->get_name(), "GetThorQueueAvailabilityRequest"))
	{
		Owned<CGetThorQueueAvailabilityRequest> esp_request = new CGetThorQueueAvailabilityRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CGetThorQueueAvailabilityResponse> esp_response = new CGetThorQueueAvailabilityResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		StringBuffer source;
		source.appendf("WsSMC::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "WsSMC", "GetThorQueueAvailability");
			iserv->onGetThorQueueAvailability(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "WsSMC", "GetThorQueueAvailability");
		response->set_name("GetThorQueueAvailabilityResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "Index")||!stricmp(thecall->get_name(), "SMCIndexRequest"))
	{
		Owned<CSMCIndexRequest> esp_request = new CSMCIndexRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CSMCIndexResponse> esp_response = new CSMCIndexResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		StringBuffer source;
		source.appendf("WsSMC::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "WsSMC", "Index");
			iserv->onIndex(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "WsSMC", "Index");
		response->set_name("SMCIndexResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "LockQuery")||!stricmp(thecall->get_name(), "LockQueryRequest"))
	{
		Owned<CLockQueryRequest> esp_request = new CLockQueryRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CLockQueryResponse> esp_response = new CLockQueryResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		StringBuffer source;
		source.appendf("WsSMC::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "WsSMC", "LockQuery");
			iserv->onLockQuery(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "WsSMC", "LockQuery");
		response->set_name("LockQueryResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "MoveJobBack")||!stricmp(thecall->get_name(), "SMCJobRequest"))
	{
		Owned<CSMCJobRequest> esp_request = new CSMCJobRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CSMCJobResponse> esp_response = new CSMCJobResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		StringBuffer source;
		source.appendf("WsSMC::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "WsSMC", "MoveJobBack");
			iserv->onMoveJobBack(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "WsSMC", "MoveJobBack");
		response->set_name("SMCJobResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "MoveJobDown")||!stricmp(thecall->get_name(), "SMCJobRequest"))
	{
		Owned<CSMCJobRequest> esp_request = new CSMCJobRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CSMCJobResponse> esp_response = new CSMCJobResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		StringBuffer source;
		source.appendf("WsSMC::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "WsSMC", "MoveJobDown");
			iserv->onMoveJobDown(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "WsSMC", "MoveJobDown");
		response->set_name("SMCJobResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "MoveJobFront")||!stricmp(thecall->get_name(), "SMCJobRequest"))
	{
		Owned<CSMCJobRequest> esp_request = new CSMCJobRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CSMCJobResponse> esp_response = new CSMCJobResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		StringBuffer source;
		source.appendf("WsSMC::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "WsSMC", "MoveJobFront");
			iserv->onMoveJobFront(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "WsSMC", "MoveJobFront");
		response->set_name("SMCJobResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "MoveJobUp")||!stricmp(thecall->get_name(), "SMCJobRequest"))
	{
		Owned<CSMCJobRequest> esp_request = new CSMCJobRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CSMCJobResponse> esp_response = new CSMCJobResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		StringBuffer source;
		source.appendf("WsSMC::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "WsSMC", "MoveJobUp");
			iserv->onMoveJobUp(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "WsSMC", "MoveJobUp");
		response->set_name("SMCJobResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "NotInCommunityEdition")||!stricmp(thecall->get_name(), "NotInCommunityEditionRequest"))
	{
		Owned<CNotInCommunityEditionRequest> esp_request = new CNotInCommunityEditionRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CNotInCommunityEditionResponse> esp_response = new CNotInCommunityEditionResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		StringBuffer source;
		source.appendf("WsSMC::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "WsSMC", "NotInCommunityEdition");
			iserv->onNotInCommunityEdition(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "WsSMC", "NotInCommunityEdition");
		response->set_name("NotInCommunityEditionResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "PauseQueue")||!stricmp(thecall->get_name(), "SMCQueueRequest"))
	{
		Owned<CSMCQueueRequest> esp_request = new CSMCQueueRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CSMCQueueResponse> esp_response = new CSMCQueueResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		StringBuffer source;
		source.appendf("WsSMC::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "WsSMC", "PauseQueue");
			iserv->onPauseQueue(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "WsSMC", "PauseQueue");
		response->set_name("SMCQueueResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "Ping")||!stricmp(thecall->get_name(), "WsSMCPingRequest"))
	{
		Owned<CWsSMCPingRequest> esp_request = new CWsSMCPingRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CWsSMCPingResponse> esp_response = new CWsSMCPingResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		StringBuffer source;
		source.appendf("WsSMC::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "WsSMC", "Ping");
			iserv->onPing(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "WsSMC", "Ping");
		response->set_name("WsSMCPingResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "RemoveJob")||!stricmp(thecall->get_name(), "SMCJobRequest"))
	{
		Owned<CSMCJobRequest> esp_request = new CSMCJobRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CSMCJobResponse> esp_response = new CSMCJobResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		StringBuffer source;
		source.appendf("WsSMC::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "WsSMC", "RemoveJob");
			iserv->onRemoveJob(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "WsSMC", "RemoveJob");
		response->set_name("SMCJobResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "ResumeQueue")||!stricmp(thecall->get_name(), "SMCQueueRequest"))
	{
		Owned<CSMCQueueRequest> esp_request = new CSMCQueueRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CSMCQueueResponse> esp_response = new CSMCQueueResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		StringBuffer source;
		source.appendf("WsSMC::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "WsSMC", "ResumeQueue");
			iserv->onResumeQueue(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "WsSMC", "ResumeQueue");
		response->set_name("SMCQueueResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "RoxieControlCmd")||!stricmp(thecall->get_name(), "RoxieControlCmdRequest"))
	{
		Owned<CRoxieControlCmdRequest> esp_request = new CRoxieControlCmdRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CRoxieControlCmdResponse> esp_response = new CRoxieControlCmdResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		StringBuffer source;
		source.appendf("WsSMC::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "WsSMC", "RoxieControlCmd");
			iserv->onRoxieControlCmd(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "WsSMC", "RoxieControlCmd");
		response->set_name("RoxieControlCmdResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "SetBanner")||!stricmp(thecall->get_name(), "SetBannerRequest"))
	{
		Owned<CSetBannerRequest> esp_request = new CSetBannerRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CSetBannerResponse> esp_response = new CSetBannerResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		StringBuffer source;
		source.appendf("WsSMC::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "WsSMC", "SetBanner");
			iserv->onSetBanner(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "WsSMC", "SetBanner");
		response->set_name("SetBannerResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "SetJobPriority")||!stricmp(thecall->get_name(), "SMCPriorityRequest"))
	{
		Owned<CSMCPriorityRequest> esp_request = new CSMCPriorityRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CSMCPriorityResponse> esp_response = new CSMCPriorityResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		StringBuffer source;
		source.appendf("WsSMC::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "WsSMC", "SetJobPriority");
			iserv->onSetJobPriority(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "WsSMC", "SetJobPriority");
		response->set_name("SMCPriorityResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "StopQueue")||!stricmp(thecall->get_name(), "SMCQueueRequest"))
	{
		Owned<CSMCQueueRequest> esp_request = new CSMCQueueRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CSMCQueueResponse> esp_response = new CSMCQueueResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		StringBuffer source;
		source.appendf("WsSMC::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "WsSMC", "StopQueue");
			iserv->onStopQueue(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "WsSMC", "StopQueue");
		response->set_name("SMCQueueResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	response->set_status(SOAP_CLIENT_ERROR);
	StringBuffer msg, svcName;
	msg.appendf("Method %s not available in service %s",thecall->get_name(),getServiceName(svcName).str());
	ERRLOG("%s", msg.str());
	response->set_err(msg);
	return -1;
}

int CWsSMCSoapBinding::getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &content, const char *service, const char *method, bool mda)
{
	BoolHash added;
	if (context.getClientVersion()<=0)
		context.setClientVersion(1.21);

	DBGLOG("Client version: %g", context.getClientVersion());
	bool fullservice = (!Utils::strcasecmp(service, "WsSMC"));
	bool allMethods = (method==NULL || *method==0);
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "Activity"))) || Utils::strcasecmp(method, "Activity")==0)
	{
		CActivityRequest::getMapInfo(context.queryMapInfo());
		CActivityResponse::getMapInfo(context.queryMapInfo());
		CActivityRequest::getXsdDefinition(context, request, "Activity", content, added);
		CActivityResponse::getXsdDefinition(context, request, content, added);
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "BrowseResources"))) || Utils::strcasecmp(method, "BrowseResources")==0)
	{
		CBrowseResourcesRequest::getMapInfo(context.queryMapInfo());
		CBrowseResourcesResponse::getMapInfo(context.queryMapInfo());
		CBrowseResourcesRequest::getXsdDefinition(context, request, "BrowseResources", content, added);
		CBrowseResourcesResponse::getXsdDefinition(context, request, content, added);
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "ClearQueue"))) || Utils::strcasecmp(method, "ClearQueue")==0)
	{
		CSMCQueueRequest::getMapInfo(context.queryMapInfo());
		CSMCQueueResponse::getMapInfo(context.queryMapInfo());
		CSMCQueueRequest::getXsdDefinition(context, request, "ClearQueue", content, added);
		CSMCQueueResponse::getXsdDefinition(context, request, content, added);
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "GetStatusServerInfo"))) || Utils::strcasecmp(method, "GetStatusServerInfo")==0)
	{
		CGetStatusServerInfoRequest::getMapInfo(context.queryMapInfo());
		CGetStatusServerInfoResponse::getMapInfo(context.queryMapInfo());
		CGetStatusServerInfoRequest::getXsdDefinition(context, request, "GetStatusServerInfo", content, added);
		CGetStatusServerInfoResponse::getXsdDefinition(context, request, content, added);
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "GetThorQueueAvailability"))) || Utils::strcasecmp(method, "GetThorQueueAvailability")==0)
	{
		CGetThorQueueAvailabilityRequest::getMapInfo(context.queryMapInfo());
		CGetThorQueueAvailabilityResponse::getMapInfo(context.queryMapInfo());
		CGetThorQueueAvailabilityRequest::getXsdDefinition(context, request, "GetThorQueueAvailability", content, added);
		CGetThorQueueAvailabilityResponse::getXsdDefinition(context, request, content, added);
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "Index"))) || Utils::strcasecmp(method, "Index")==0)
	{
		CSMCIndexRequest::getMapInfo(context.queryMapInfo());
		CSMCIndexResponse::getMapInfo(context.queryMapInfo());
		CSMCIndexRequest::getXsdDefinition(context, request, "Index", content, added);
		CSMCIndexResponse::getXsdDefinition(context, request, content, added);
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "LockQuery"))) || Utils::strcasecmp(method, "LockQuery")==0)
	{
		CLockQueryRequest::getMapInfo(context.queryMapInfo());
		CLockQueryResponse::getMapInfo(context.queryMapInfo());
		CLockQueryRequest::getXsdDefinition(context, request, "LockQuery", content, added);
		CLockQueryResponse::getXsdDefinition(context, request, content, added);
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "MoveJobBack"))) || Utils::strcasecmp(method, "MoveJobBack")==0)
	{
		CSMCJobRequest::getMapInfo(context.queryMapInfo());
		CSMCJobResponse::getMapInfo(context.queryMapInfo());
		CSMCJobRequest::getXsdDefinition(context, request, "MoveJobBack", content, added);
		CSMCJobResponse::getXsdDefinition(context, request, content, added);
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "MoveJobDown"))) || Utils::strcasecmp(method, "MoveJobDown")==0)
	{
		CSMCJobRequest::getMapInfo(context.queryMapInfo());
		CSMCJobResponse::getMapInfo(context.queryMapInfo());
		CSMCJobRequest::getXsdDefinition(context, request, "MoveJobDown", content, added);
		CSMCJobResponse::getXsdDefinition(context, request, content, added);
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "MoveJobFront"))) || Utils::strcasecmp(method, "MoveJobFront")==0)
	{
		CSMCJobRequest::getMapInfo(context.queryMapInfo());
		CSMCJobResponse::getMapInfo(context.queryMapInfo());
		CSMCJobRequest::getXsdDefinition(context, request, "MoveJobFront", content, added);
		CSMCJobResponse::getXsdDefinition(context, request, content, added);
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "MoveJobUp"))) || Utils::strcasecmp(method, "MoveJobUp")==0)
	{
		CSMCJobRequest::getMapInfo(context.queryMapInfo());
		CSMCJobResponse::getMapInfo(context.queryMapInfo());
		CSMCJobRequest::getXsdDefinition(context, request, "MoveJobUp", content, added);
		CSMCJobResponse::getXsdDefinition(context, request, content, added);
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "NotInCommunityEdition"))) || Utils::strcasecmp(method, "NotInCommunityEdition")==0)
	{
		CNotInCommunityEditionRequest::getMapInfo(context.queryMapInfo());
		CNotInCommunityEditionResponse::getMapInfo(context.queryMapInfo());
		CNotInCommunityEditionRequest::getXsdDefinition(context, request, "NotInCommunityEdition", content, added);
		CNotInCommunityEditionResponse::getXsdDefinition(context, request, content, added);
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "PauseQueue"))) || Utils::strcasecmp(method, "PauseQueue")==0)
	{
		CSMCQueueRequest::getMapInfo(context.queryMapInfo());
		CSMCQueueResponse::getMapInfo(context.queryMapInfo());
		CSMCQueueRequest::getXsdDefinition(context, request, "PauseQueue", content, added);
		CSMCQueueResponse::getXsdDefinition(context, request, content, added);
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "Ping"))) || Utils::strcasecmp(method, "Ping")==0)
	{
		CWsSMCPingRequest::getMapInfo(context.queryMapInfo());
		CWsSMCPingResponse::getMapInfo(context.queryMapInfo());
		CWsSMCPingRequest::getXsdDefinition(context, request, "Ping", content, added);
		CWsSMCPingResponse::getXsdDefinition(context, request, content, added);
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "RemoveJob"))) || Utils::strcasecmp(method, "RemoveJob")==0)
	{
		CSMCJobRequest::getMapInfo(context.queryMapInfo());
		CSMCJobResponse::getMapInfo(context.queryMapInfo());
		CSMCJobRequest::getXsdDefinition(context, request, "RemoveJob", content, added);
		CSMCJobResponse::getXsdDefinition(context, request, content, added);
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "ResumeQueue"))) || Utils::strcasecmp(method, "ResumeQueue")==0)
	{
		CSMCQueueRequest::getMapInfo(context.queryMapInfo());
		CSMCQueueResponse::getMapInfo(context.queryMapInfo());
		CSMCQueueRequest::getXsdDefinition(context, request, "ResumeQueue", content, added);
		CSMCQueueResponse::getXsdDefinition(context, request, content, added);
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "RoxieControlCmd"))) || Utils::strcasecmp(method, "RoxieControlCmd")==0)
	{
		CRoxieControlCmdRequest::getMapInfo(context.queryMapInfo());
		CRoxieControlCmdResponse::getMapInfo(context.queryMapInfo());
		CRoxieControlCmdRequest::getXsdDefinition(context, request, "RoxieControlCmd", content, added);
		CRoxieControlCmdResponse::getXsdDefinition(context, request, content, added);
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "SetBanner"))) || Utils::strcasecmp(method, "SetBanner")==0)
	{
		CSetBannerRequest::getMapInfo(context.queryMapInfo());
		CSetBannerResponse::getMapInfo(context.queryMapInfo());
		CSetBannerRequest::getXsdDefinition(context, request, "SetBanner", content, added);
		CSetBannerResponse::getXsdDefinition(context, request, content, added);
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "SetJobPriority"))) || Utils::strcasecmp(method, "SetJobPriority")==0)
	{
		CSMCPriorityRequest::getMapInfo(context.queryMapInfo());
		CSMCPriorityResponse::getMapInfo(context.queryMapInfo());
		CSMCPriorityRequest::getXsdDefinition(context, request, "SetJobPriority", content, added);
		CSMCPriorityResponse::getXsdDefinition(context, request, content, added);
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "StopQueue"))) || Utils::strcasecmp(method, "StopQueue")==0)
	{
		CSMCQueueRequest::getMapInfo(context.queryMapInfo());
		CSMCQueueResponse::getMapInfo(context.queryMapInfo());
		CSMCQueueRequest::getXsdDefinition(context, request, "StopQueue", content, added);
		CSMCQueueResponse::getXsdDefinition(context, request, content, added);
	}
	return 0;
}

int CWsSMCSoapBinding::getMethodHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &page, bool bIncludeFormTag)
{
	DBGLOG("Client version: %g", context.getClientVersion());
	if (Utils::strcasecmp(method, "Activity")==0)
	{
		CActivityRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "BrowseResources")==0)
	{
		CBrowseResourcesRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "ClearQueue")==0)
	{
		CSMCQueueRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "GetStatusServerInfo")==0)
	{
		CGetStatusServerInfoRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "GetThorQueueAvailability")==0)
	{
		CGetThorQueueAvailabilityRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "Index")==0)
	{
		CSMCIndexRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "LockQuery")==0)
	{
		CLockQueryRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "MoveJobBack")==0)
	{
		CSMCJobRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "MoveJobDown")==0)
	{
		CSMCJobRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "MoveJobFront")==0)
	{
		CSMCJobRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "MoveJobUp")==0)
	{
		CSMCJobRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "NotInCommunityEdition")==0)
	{
		CNotInCommunityEditionRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "PauseQueue")==0)
	{
		CSMCQueueRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "Ping")==0)
	{
		CWsSMCPingRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "RemoveJob")==0)
	{
		CSMCJobRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "ResumeQueue")==0)
	{
		CSMCQueueRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "RoxieControlCmd")==0)
	{
		CRoxieControlCmdRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "SetBanner")==0)
	{
		CSetBannerRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "SetJobPriority")==0)
	{
		CSMCPriorityRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "StopQueue")==0)
	{
		CSMCQueueRequest::getHtmlForm(context, request, serv, method, page);
	}
	return 0;
}

int CWsSMCSoapBinding::getQualifiedNames(IEspContext& ctx, MethodInfoArray & methods)
{
	double ver = ctx.getClientVersion();
	if (ver<=0)
		ver = getWsdlVersion();
	const char *servname=ctx.queryServiceName(NULL);
	bool fullservice = (!stricmp(servname, "esp")||!stricmp(servname, "WsSMC"));
	if ((fullservice || isMethodInSubService(ctx, servname, "Activity")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("Activity", "Activity", "ActivityResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "BrowseResources")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("BrowseResources", "BrowseResources", "BrowseResourcesResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "ClearQueue")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("ClearQueue", "ClearQueue", "SMCQueueResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "GetStatusServerInfo")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("GetStatusServerInfo", "GetStatusServerInfo", "GetStatusServerInfoResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "GetThorQueueAvailability")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("GetThorQueueAvailability", "GetThorQueueAvailability", "GetThorQueueAvailabilityResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "Index")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("Index", "Index", "SMCIndexResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "LockQuery")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("LockQuery", "LockQuery", "LockQueryResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "MoveJobBack")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("MoveJobBack", "MoveJobBack", "SMCJobResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "MoveJobDown")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("MoveJobDown", "MoveJobDown", "SMCJobResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "MoveJobFront")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("MoveJobFront", "MoveJobFront", "SMCJobResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "MoveJobUp")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("MoveJobUp", "MoveJobUp", "SMCJobResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "NotInCommunityEdition")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("NotInCommunityEdition", "NotInCommunityEdition", "NotInCommunityEditionResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "PauseQueue")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("PauseQueue", "PauseQueue", "SMCQueueResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "Ping")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("Ping", "Ping", "WsSMCPingResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "RemoveJob")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("RemoveJob", "RemoveJob", "SMCJobResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "ResumeQueue")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("ResumeQueue", "ResumeQueue", "SMCQueueResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "RoxieControlCmd")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("RoxieControlCmd", "RoxieControlCmd", "RoxieControlCmdResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "SetBanner")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("SetBanner", "SetBanner", "SetBannerResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "SetJobPriority")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("SetJobPriority", "SetJobPriority", "SMCPriorityResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "StopQueue")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("StopQueue", "StopQueue", "SMCQueueResponse"));
	return methods.ordinality();
}

StringBuffer & CWsSMCSoapBinding::getServiceName(StringBuffer &resp)
{
	resp.append("WsSMC");
	return resp;
}

bool CWsSMCSoapBinding::isValidServiceName(IEspContext &context, const char *name)
{
	if (!Utils::strcasecmp(name, "WsSMC"))
		return true;
	else
		return (hasSubService(context, name));
}

bool CWsSMCSoapBinding::qualifyMethodName(IEspContext &context, const char *methname, StringBuffer *methQName)
{
	if (!methname || !*methname)
	{
		if (methQName!=NULL)
			methQName->clear();
		return true;
	}
	if (Utils::strcasecmp(methname, "Activity")==0)
	{
		if (methQName!=NULL)
			methQName->set("Activity");
		return true;
	}
	if (Utils::strcasecmp(methname, "BrowseResources")==0)
	{
		if (methQName!=NULL)
			methQName->set("BrowseResources");
		return true;
	}
	if (Utils::strcasecmp(methname, "ClearQueue")==0)
	{
		if (methQName!=NULL)
			methQName->set("ClearQueue");
		return true;
	}
	if (Utils::strcasecmp(methname, "GetStatusServerInfo")==0)
	{
		if (methQName!=NULL)
			methQName->set("GetStatusServerInfo");
		return true;
	}
	if (Utils::strcasecmp(methname, "GetThorQueueAvailability")==0)
	{
		if (methQName!=NULL)
			methQName->set("GetThorQueueAvailability");
		return true;
	}
	if (Utils::strcasecmp(methname, "Index")==0)
	{
		if (methQName!=NULL)
			methQName->set("Index");
		return true;
	}
	if (Utils::strcasecmp(methname, "LockQuery")==0)
	{
		if (methQName!=NULL)
			methQName->set("LockQuery");
		return true;
	}
	if (Utils::strcasecmp(methname, "MoveJobBack")==0)
	{
		if (methQName!=NULL)
			methQName->set("MoveJobBack");
		return true;
	}
	if (Utils::strcasecmp(methname, "MoveJobDown")==0)
	{
		if (methQName!=NULL)
			methQName->set("MoveJobDown");
		return true;
	}
	if (Utils::strcasecmp(methname, "MoveJobFront")==0)
	{
		if (methQName!=NULL)
			methQName->set("MoveJobFront");
		return true;
	}
	if (Utils::strcasecmp(methname, "MoveJobUp")==0)
	{
		if (methQName!=NULL)
			methQName->set("MoveJobUp");
		return true;
	}
	if (Utils::strcasecmp(methname, "NotInCommunityEdition")==0)
	{
		if (methQName!=NULL)
			methQName->set("NotInCommunityEdition");
		return true;
	}
	if (Utils::strcasecmp(methname, "PauseQueue")==0)
	{
		if (methQName!=NULL)
			methQName->set("PauseQueue");
		return true;
	}
	if (Utils::strcasecmp(methname, "Ping")==0)
	{
		if (methQName!=NULL)
			methQName->set("Ping");
		return true;
	}
	if (Utils::strcasecmp(methname, "RemoveJob")==0)
	{
		if (methQName!=NULL)
			methQName->set("RemoveJob");
		return true;
	}
	if (Utils::strcasecmp(methname, "ResumeQueue")==0)
	{
		if (methQName!=NULL)
			methQName->set("ResumeQueue");
		return true;
	}
	if (Utils::strcasecmp(methname, "RoxieControlCmd")==0)
	{
		if (methQName!=NULL)
			methQName->set("RoxieControlCmd");
		return true;
	}
	if (Utils::strcasecmp(methname, "SetBanner")==0)
	{
		if (methQName!=NULL)
			methQName->set("SetBanner");
		return true;
	}
	if (Utils::strcasecmp(methname, "SetJobPriority")==0)
	{
		if (methQName!=NULL)
			methQName->set("SetJobPriority");
		return true;
	}
	if (Utils::strcasecmp(methname, "StopQueue")==0)
	{
		if (methQName!=NULL)
			methQName->set("StopQueue");
		return true;
	}
	return false;
}

bool CWsSMCSoapBinding::qualifyServiceName(IEspContext &context, const char *servname, const char *methname, StringBuffer &servQName, StringBuffer *methQName)
{
	servQName.clear();
	if (!Utils::strcasecmp(servname, "WsSMC"))
	{
		servQName.append("WsSMC");
		return qualifyMethodName(context, methname, methQName);
	}
	return qualifySubServiceName(context, servname, methname, servQName, methQName);
}

int CWsSMCSoapBinding::onGetFile(IEspContext &context, CHttpRequest* request, CHttpResponse* response, const char *pathex)
{
	if(request == NULL || response == NULL)
		return -1;
	StringBuffer mimetype;
	MemoryBuffer content;

	StringBuffer filepath;
	getBaseFilePath(filepath);
	if (strchr("\\/", filepath.charAt(filepath.length()-1))==NULL)
		filepath.append("/");
	filepath.append(pathex);
	response->httpContentFromFile(filepath.str());
	response->send();
	return 0;
}

int CWsSMCSoapBinding::onGetForm(IEspContext &context, CHttpRequest* request, CHttpResponse* response, const char *service, const char *method)
{
	return onGetNotFound(context, request, response, service);
}
int CWsSMCSoapBinding::onGetXForm(IEspContext &context, CHttpRequest* request, CHttpResponse* response, const char *service, const char *method)
{
	return EspHttpBinding::onGetXForm(context, request, response, service, method);
}

int CWsSMCSoapBinding::onGetService(IEspContext &context, CHttpRequest* request, CHttpResponse* response, const char *service, const char *method, const char *pathex)
{
	if(request == NULL || response == NULL)
		return -1;
	return onGetQuery(context, request, response, service, method);
}

 IRpcRequestBinding *CWsSMCSoapBinding::createReqBinding(IEspContext &context, IHttpMessage *ireq, const char *service, const char *method)
{
	CHttpRequest *request=static_cast<CHttpRequest*>(ireq);
	IProperties *props = (request) ? request->queryParameters() : NULL;

	if (!stricmp(method, "Activity") || !stricmp(method, "ActivityRequest"))
		return new CActivityRequest(&context, "WsSMC", props, NULL);
	if (!stricmp(method, "BrowseResources") || !stricmp(method, "BrowseResourcesRequest"))
		return new CBrowseResourcesRequest(&context, "WsSMC", props, NULL);
	if (!stricmp(method, "ClearQueue") || !stricmp(method, "SMCQueueRequest"))
		return new CSMCQueueRequest(&context, "WsSMC", props, NULL);
	if (!stricmp(method, "GetStatusServerInfo") || !stricmp(method, "GetStatusServerInfoRequest"))
		return new CGetStatusServerInfoRequest(&context, "WsSMC", props, NULL);
	if (!stricmp(method, "GetThorQueueAvailability") || !stricmp(method, "GetThorQueueAvailabilityRequest"))
		return new CGetThorQueueAvailabilityRequest(&context, "WsSMC", props, NULL);
	if (!stricmp(method, "Index") || !stricmp(method, "SMCIndexRequest"))
		return new CSMCIndexRequest(&context, "WsSMC", props, NULL);
	if (!stricmp(method, "LockQuery") || !stricmp(method, "LockQueryRequest"))
		return new CLockQueryRequest(&context, "WsSMC", props, NULL);
	if (!stricmp(method, "MoveJobBack") || !stricmp(method, "SMCJobRequest"))
		return new CSMCJobRequest(&context, "WsSMC", props, NULL);
	if (!stricmp(method, "MoveJobDown") || !stricmp(method, "SMCJobRequest"))
		return new CSMCJobRequest(&context, "WsSMC", props, NULL);
	if (!stricmp(method, "MoveJobFront") || !stricmp(method, "SMCJobRequest"))
		return new CSMCJobRequest(&context, "WsSMC", props, NULL);
	if (!stricmp(method, "MoveJobUp") || !stricmp(method, "SMCJobRequest"))
		return new CSMCJobRequest(&context, "WsSMC", props, NULL);
	if (!stricmp(method, "NotInCommunityEdition") || !stricmp(method, "NotInCommunityEditionRequest"))
		return new CNotInCommunityEditionRequest(&context, "WsSMC", props, NULL);
	if (!stricmp(method, "PauseQueue") || !stricmp(method, "SMCQueueRequest"))
		return new CSMCQueueRequest(&context, "WsSMC", props, NULL);
	if (!stricmp(method, "Ping") || !stricmp(method, "WsSMCPingRequest"))
		return new CWsSMCPingRequest(&context, "WsSMC", props, NULL);
	if (!stricmp(method, "RemoveJob") || !stricmp(method, "SMCJobRequest"))
		return new CSMCJobRequest(&context, "WsSMC", props, NULL);
	if (!stricmp(method, "ResumeQueue") || !stricmp(method, "SMCQueueRequest"))
		return new CSMCQueueRequest(&context, "WsSMC", props, NULL);
	if (!stricmp(method, "RoxieControlCmd") || !stricmp(method, "RoxieControlCmdRequest"))
		return new CRoxieControlCmdRequest(&context, "WsSMC", props, NULL);
	if (!stricmp(method, "SetBanner") || !stricmp(method, "SetBannerRequest"))
		return new CSetBannerRequest(&context, "WsSMC", props, NULL);
	if (!stricmp(method, "SetJobPriority") || !stricmp(method, "SMCPriorityRequest"))
		return new CSMCPriorityRequest(&context, "WsSMC", props, NULL);
	if (!stricmp(method, "StopQueue") || !stricmp(method, "SMCQueueRequest"))
		return new CSMCQueueRequest(&context, "WsSMC", props, NULL);
	return NULL;
}

int CWsSMCSoapBinding::onGetInstantQuery(IEspContext &context, CHttpRequest* request, CHttpResponse* response, const char *service, const char *method)
{
	if (context.getClientVersion()<=0)
		context.setClientVersion(1.21);

	if(request == NULL || response == NULL)
		return -1;
	StringBuffer respStr;
	Owned<IEspWsSMC> iserv = (IEspWsSMC*)getService();
	if(iserv == NULL)
	{
		respStr.append("Service not available");
		response->setContent(respStr.str());
		response->setContentType("text/html");
		response->send();
	}
	else
	{
		Owned<CSoapResponseBinding> esp_response;
		StringBuffer source;
		IEspContext& context = *request->queryContext();
		if(!stricmp(method, "Activity")||!stricmp(method, "ActivityRequest"))
		{
			Owned<CActivityRequest> esp_request = new CActivityRequest(&context, "WsSMC", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			Owned<CActivityResponse> esp_response = new CActivityResponse("WsSMC");
			StringBuffer source;
			source.appendf("WsSMC::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				iserv->onActivity(*request->queryContext(), *esp_request.get(), *esp_response.get());
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "WsSMC", "Activity", StringBuffer(getCFD()).append("./smc_xslt/exceptions.xslt").str()))
				return 0;
			if (canRedirect(*request) && esp_response->getRedirectUrl() && *esp_response->getRedirectUrl())
			{
				response->redirect(*request, esp_response->getRedirectUrl());
			}
			else
			{
				IProperties *props=request->queryParameters();
				if (skipXslt(context))
				{
					MemoryBuffer content;
					StringBuffer mimetype;
					esp_response->appendContent(&context,content, mimetype);
					onBeforeSendResponse(context,request,content,service,method);
					response->setContent(content.length(), content.toByteArray());
					response->setContentType(mimetype.str());
				}
				else
				{
					StringBuffer xml;
					StringBuffer sResponse;
					esp_response->serializeStruct(&context, xml, NULL);

					xslTransform(xml.str(), "/esp/xslt/index.xslt", sResponse.clear(), context.queryXslParameters());
					response->setContentType("text/html");
					response->setContent(sResponse.str());
				}
				response->send();
			}
			return 0;
		}
		if(!stricmp(method, "BrowseResources")||!stricmp(method, "BrowseResourcesRequest"))
		{
			Owned<CBrowseResourcesRequest> esp_request = new CBrowseResourcesRequest(&context, "WsSMC", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			Owned<CBrowseResourcesResponse> esp_response = new CBrowseResourcesResponse("WsSMC");
			StringBuffer source;
			source.appendf("WsSMC::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				iserv->onBrowseResources(*request->queryContext(), *esp_request.get(), *esp_response.get());
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "WsSMC", "BrowseResources", StringBuffer(getCFD()).append("./smc_xslt/exceptions.xslt").str()))
				return 0;
			if (canRedirect(*request) && esp_response->getRedirectUrl() && *esp_response->getRedirectUrl())
			{
				response->redirect(*request, esp_response->getRedirectUrl());
			}
			else
			{
				IProperties *props=request->queryParameters();
				if (skipXslt(context))
				{
					MemoryBuffer content;
					StringBuffer mimetype;
					esp_response->appendContent(&context,content, mimetype);
					onBeforeSendResponse(context,request,content,service,method);
					response->setContent(content.length(), content.toByteArray());
					response->setContentType(mimetype.str());
				}
				else
				{
					StringBuffer xml;
					StringBuffer sResponse;
					esp_response->serializeStruct(&context, xml, NULL);

					xslTransform(xml.str(), "/esp/xslt/hpccresourcelist.xslt", sResponse.clear(), context.queryXslParameters());
					response->setContentType("text/html");
					response->setContent(sResponse.str());
				}
				response->send();
			}
			return 0;
		}
		if(!stricmp(method, "ClearQueue")||!stricmp(method, "SMCQueueRequest"))
		{
			Owned<CSMCQueueRequest> esp_request = new CSMCQueueRequest(&context, "WsSMC", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			CSMCQueueResponse* resp = new CSMCQueueResponse("WsSMC");
			esp_response.setown(resp);
			MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
			source.setf("WsSMC::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				if(accessmap.ordinality()>0)
					onFeaturesAuthorize(context, accessmap, "WsSMC", "ClearQueue");
				iserv->onClearQueue(context, *esp_request.get(), *resp);
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "WsSMC", "ClearQueue", StringBuffer(getCFD()).append("./smc_xslt/exceptions.xslt").str()))
				return 0;
		}
		if(!stricmp(method, "GetStatusServerInfo")||!stricmp(method, "GetStatusServerInfoRequest"))
		{
			Owned<CGetStatusServerInfoRequest> esp_request = new CGetStatusServerInfoRequest(&context, "WsSMC", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			CGetStatusServerInfoResponse* resp = new CGetStatusServerInfoResponse("WsSMC");
			esp_response.setown(resp);
			MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
			source.setf("WsSMC::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				if(accessmap.ordinality()>0)
					onFeaturesAuthorize(context, accessmap, "WsSMC", "GetStatusServerInfo");
				iserv->onGetStatusServerInfo(context, *esp_request.get(), *resp);
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "WsSMC", "GetStatusServerInfo", StringBuffer(getCFD()).append("./smc_xslt/exceptions.xslt").str()))
				return 0;
		}
		if(!stricmp(method, "GetThorQueueAvailability")||!stricmp(method, "GetThorQueueAvailabilityRequest"))
		{
			Owned<CGetThorQueueAvailabilityRequest> esp_request = new CGetThorQueueAvailabilityRequest(&context, "WsSMC", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			CGetThorQueueAvailabilityResponse* resp = new CGetThorQueueAvailabilityResponse("WsSMC");
			esp_response.setown(resp);
			MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
			source.setf("WsSMC::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				if(accessmap.ordinality()>0)
					onFeaturesAuthorize(context, accessmap, "WsSMC", "GetThorQueueAvailability");
				iserv->onGetThorQueueAvailability(context, *esp_request.get(), *resp);
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "WsSMC", "GetThorQueueAvailability", StringBuffer(getCFD()).append("./smc_xslt/exceptions.xslt").str()))
				return 0;
		}
		if(!stricmp(method, "Index")||!stricmp(method, "SMCIndexRequest"))
		{
			Owned<CSMCIndexRequest> esp_request = new CSMCIndexRequest(&context, "WsSMC", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			CSMCIndexResponse* resp = new CSMCIndexResponse("WsSMC");
			esp_response.setown(resp);
			MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
			source.setf("WsSMC::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				if(accessmap.ordinality()>0)
					onFeaturesAuthorize(context, accessmap, "WsSMC", "Index");
				iserv->onIndex(context, *esp_request.get(), *resp);
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "WsSMC", "Index", StringBuffer(getCFD()).append("./smc_xslt/exceptions.xslt").str()))
				return 0;
		}
		if(!stricmp(method, "LockQuery")||!stricmp(method, "LockQueryRequest"))
		{
			Owned<CLockQueryRequest> esp_request = new CLockQueryRequest(&context, "WsSMC", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			CLockQueryResponse* resp = new CLockQueryResponse("WsSMC");
			esp_response.setown(resp);
			MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
			source.setf("WsSMC::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				if(accessmap.ordinality()>0)
					onFeaturesAuthorize(context, accessmap, "WsSMC", "LockQuery");
				iserv->onLockQuery(context, *esp_request.get(), *resp);
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "WsSMC", "LockQuery", StringBuffer(getCFD()).append("./smc_xslt/exceptions.xslt").str()))
				return 0;
		}
		if(!stricmp(method, "MoveJobBack")||!stricmp(method, "SMCJobRequest"))
		{
			Owned<CSMCJobRequest> esp_request = new CSMCJobRequest(&context, "WsSMC", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			CSMCJobResponse* resp = new CSMCJobResponse("WsSMC");
			esp_response.setown(resp);
			MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
			source.setf("WsSMC::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				if(accessmap.ordinality()>0)
					onFeaturesAuthorize(context, accessmap, "WsSMC", "MoveJobBack");
				iserv->onMoveJobBack(context, *esp_request.get(), *resp);
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "WsSMC", "MoveJobBack", StringBuffer(getCFD()).append("./smc_xslt/exceptions.xslt").str()))
				return 0;
		}
		if(!stricmp(method, "MoveJobDown")||!stricmp(method, "SMCJobRequest"))
		{
			Owned<CSMCJobRequest> esp_request = new CSMCJobRequest(&context, "WsSMC", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			CSMCJobResponse* resp = new CSMCJobResponse("WsSMC");
			esp_response.setown(resp);
			MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
			source.setf("WsSMC::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				if(accessmap.ordinality()>0)
					onFeaturesAuthorize(context, accessmap, "WsSMC", "MoveJobDown");
				iserv->onMoveJobDown(context, *esp_request.get(), *resp);
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "WsSMC", "MoveJobDown", StringBuffer(getCFD()).append("./smc_xslt/exceptions.xslt").str()))
				return 0;
		}
		if(!stricmp(method, "MoveJobFront")||!stricmp(method, "SMCJobRequest"))
		{
			Owned<CSMCJobRequest> esp_request = new CSMCJobRequest(&context, "WsSMC", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			CSMCJobResponse* resp = new CSMCJobResponse("WsSMC");
			esp_response.setown(resp);
			MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
			source.setf("WsSMC::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				if(accessmap.ordinality()>0)
					onFeaturesAuthorize(context, accessmap, "WsSMC", "MoveJobFront");
				iserv->onMoveJobFront(context, *esp_request.get(), *resp);
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "WsSMC", "MoveJobFront", StringBuffer(getCFD()).append("./smc_xslt/exceptions.xslt").str()))
				return 0;
		}
		if(!stricmp(method, "MoveJobUp")||!stricmp(method, "SMCJobRequest"))
		{
			Owned<CSMCJobRequest> esp_request = new CSMCJobRequest(&context, "WsSMC", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			CSMCJobResponse* resp = new CSMCJobResponse("WsSMC");
			esp_response.setown(resp);
			MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
			source.setf("WsSMC::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				if(accessmap.ordinality()>0)
					onFeaturesAuthorize(context, accessmap, "WsSMC", "MoveJobUp");
				iserv->onMoveJobUp(context, *esp_request.get(), *resp);
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "WsSMC", "MoveJobUp", StringBuffer(getCFD()).append("./smc_xslt/exceptions.xslt").str()))
				return 0;
		}
		if(!stricmp(method, "NotInCommunityEdition")||!stricmp(method, "NotInCommunityEditionRequest"))
		{
			Owned<CNotInCommunityEditionRequest> esp_request = new CNotInCommunityEditionRequest(&context, "WsSMC", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			CNotInCommunityEditionResponse* resp = new CNotInCommunityEditionResponse("WsSMC");
			esp_response.setown(resp);
			MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
			source.setf("WsSMC::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				if(accessmap.ordinality()>0)
					onFeaturesAuthorize(context, accessmap, "WsSMC", "NotInCommunityEdition");
				iserv->onNotInCommunityEdition(context, *esp_request.get(), *resp);
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "WsSMC", "NotInCommunityEdition", StringBuffer(getCFD()).append("./smc_xslt/exceptions.xslt").str()))
				return 0;
		}
		if(!stricmp(method, "PauseQueue")||!stricmp(method, "SMCQueueRequest"))
		{
			Owned<CSMCQueueRequest> esp_request = new CSMCQueueRequest(&context, "WsSMC", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			CSMCQueueResponse* resp = new CSMCQueueResponse("WsSMC");
			esp_response.setown(resp);
			MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
			source.setf("WsSMC::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				if(accessmap.ordinality()>0)
					onFeaturesAuthorize(context, accessmap, "WsSMC", "PauseQueue");
				iserv->onPauseQueue(context, *esp_request.get(), *resp);
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "WsSMC", "PauseQueue", StringBuffer(getCFD()).append("./smc_xslt/exceptions.xslt").str()))
				return 0;
		}
		if(!stricmp(method, "Ping")||!stricmp(method, "WsSMCPingRequest"))
		{
			Owned<CWsSMCPingRequest> esp_request = new CWsSMCPingRequest(&context, "WsSMC", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			CWsSMCPingResponse* resp = new CWsSMCPingResponse("WsSMC");
			esp_response.setown(resp);
			MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
			source.setf("WsSMC::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				if(accessmap.ordinality()>0)
					onFeaturesAuthorize(context, accessmap, "WsSMC", "Ping");
				iserv->onPing(context, *esp_request.get(), *resp);
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "WsSMC", "Ping", StringBuffer(getCFD()).append("./smc_xslt/exceptions.xslt").str()))
				return 0;
		}
		if(!stricmp(method, "RemoveJob")||!stricmp(method, "SMCJobRequest"))
		{
			Owned<CSMCJobRequest> esp_request = new CSMCJobRequest(&context, "WsSMC", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			CSMCJobResponse* resp = new CSMCJobResponse("WsSMC");
			esp_response.setown(resp);
			MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
			source.setf("WsSMC::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				if(accessmap.ordinality()>0)
					onFeaturesAuthorize(context, accessmap, "WsSMC", "RemoveJob");
				iserv->onRemoveJob(context, *esp_request.get(), *resp);
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "WsSMC", "RemoveJob", StringBuffer(getCFD()).append("./smc_xslt/exceptions.xslt").str()))
				return 0;
		}
		if(!stricmp(method, "ResumeQueue")||!stricmp(method, "SMCQueueRequest"))
		{
			Owned<CSMCQueueRequest> esp_request = new CSMCQueueRequest(&context, "WsSMC", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			CSMCQueueResponse* resp = new CSMCQueueResponse("WsSMC");
			esp_response.setown(resp);
			MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
			source.setf("WsSMC::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				if(accessmap.ordinality()>0)
					onFeaturesAuthorize(context, accessmap, "WsSMC", "ResumeQueue");
				iserv->onResumeQueue(context, *esp_request.get(), *resp);
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "WsSMC", "ResumeQueue", StringBuffer(getCFD()).append("./smc_xslt/exceptions.xslt").str()))
				return 0;
		}
		if(!stricmp(method, "RoxieControlCmd")||!stricmp(method, "RoxieControlCmdRequest"))
		{
			Owned<CRoxieControlCmdRequest> esp_request = new CRoxieControlCmdRequest(&context, "WsSMC", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			CRoxieControlCmdResponse* resp = new CRoxieControlCmdResponse("WsSMC");
			esp_response.setown(resp);
			MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
			source.setf("WsSMC::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				if(accessmap.ordinality()>0)
					onFeaturesAuthorize(context, accessmap, "WsSMC", "RoxieControlCmd");
				iserv->onRoxieControlCmd(context, *esp_request.get(), *resp);
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "WsSMC", "RoxieControlCmd", StringBuffer(getCFD()).append("./smc_xslt/exceptions.xslt").str()))
				return 0;
		}
		if(!stricmp(method, "SetBanner")||!stricmp(method, "SetBannerRequest"))
		{
			Owned<CSetBannerRequest> esp_request = new CSetBannerRequest(&context, "WsSMC", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			CSetBannerResponse* resp = new CSetBannerResponse("WsSMC");
			esp_response.setown(resp);
			MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
			source.setf("WsSMC::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				if(accessmap.ordinality()>0)
					onFeaturesAuthorize(context, accessmap, "WsSMC", "SetBanner");
				iserv->onSetBanner(context, *esp_request.get(), *resp);
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "WsSMC", "SetBanner", StringBuffer(getCFD()).append("./smc_xslt/exceptions.xslt").str()))
				return 0;
		}
		if(!stricmp(method, "SetJobPriority")||!stricmp(method, "SMCPriorityRequest"))
		{
			Owned<CSMCPriorityRequest> esp_request = new CSMCPriorityRequest(&context, "WsSMC", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			CSMCPriorityResponse* resp = new CSMCPriorityResponse("WsSMC");
			esp_response.setown(resp);
			MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
			source.setf("WsSMC::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				if(accessmap.ordinality()>0)
					onFeaturesAuthorize(context, accessmap, "WsSMC", "SetJobPriority");
				iserv->onSetJobPriority(context, *esp_request.get(), *resp);
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "WsSMC", "SetJobPriority", StringBuffer(getCFD()).append("./smc_xslt/exceptions.xslt").str()))
				return 0;
		}
		if(!stricmp(method, "StopQueue")||!stricmp(method, "SMCQueueRequest"))
		{
			Owned<CSMCQueueRequest> esp_request = new CSMCQueueRequest(&context, "WsSMC", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			CSMCQueueResponse* resp = new CSMCQueueResponse("WsSMC");
			esp_response.setown(resp);
			MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
			source.setf("WsSMC::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				if(accessmap.ordinality()>0)
					onFeaturesAuthorize(context, accessmap, "WsSMC", "StopQueue");
				iserv->onStopQueue(context, *esp_request.get(), *resp);
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "WsSMC", "StopQueue", StringBuffer(getCFD()).append("./smc_xslt/exceptions.xslt").str()))
				return 0;
		}

		if (esp_response.get())
		{
			if (canRedirect(*request) && esp_response->getRedirectUrl() && *esp_response->getRedirectUrl())
				response->redirect(*request, esp_response->getRedirectUrl());
			else
			{
				MemoryBuffer content;
				StringBuffer mimetype;
				esp_response->appendContent(&context,content, mimetype);
				onBeforeSendResponse(context,request,content,service,method);
				response->setContent(content.length(), content.toByteArray());
				response->setContentType(mimetype.str());
				response->send();
			}
			return 0;
		}
	}
	return onGetNotFound(context, request,  response, service);
}





//=======================================================
// client util methods
//=======================================================

//------ method Activity ---------

IClientActivityRequest * CClientWsSMC::createActivityRequest()
{
	CActivityRequest* request = new CActivityRequest("WsSMC");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	request->setMsgName("Activity");
	return request;
}

IClientActivityResponse * CClientWsSMC::Activity(IClientActivityRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CActivityRequest* esprequest = static_cast<CActivityRequest*>(request);
	CActivityResponse* espresponse = new CActivityResponse("WsSMC");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientWsSMC::async_Activity(IClientActivityRequest *request, IClientWsSMCEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CActivityRequest* esprequest = static_cast<CActivityRequest*>(request);
	esprequest->setMethod("Activity");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientWsSMC::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientActivityResponse *CClientWsSMC::ActivityFn(const char * ChatURL_, const char * BannerContent_, const char * BannerColor_, const char * BannerSize_, const char * BannerScroll_, int BannerAction_, bool EnableChatURL_, bool FromSubmitBtn_, const char * SortBy_, bool Descending_)
{
	Owned<IClientActivityRequest> req =  createActivityRequest();
	req->setChatURL(ChatURL_);
	req->setBannerContent(BannerContent_);
	req->setBannerColor(BannerColor_);
	req->setBannerSize(BannerSize_);
	req->setBannerScroll(BannerScroll_);
	req->setBannerAction(BannerAction_);
	req->setEnableChatURL(EnableChatURL_);
	req->setFromSubmitBtn(FromSubmitBtn_);
	req->setSortBy(SortBy_);
	req->setDescending(Descending_);
	return Activity(req.get());
}

//------ method BrowseResources ---------

IClientBrowseResourcesRequest * CClientWsSMC::createBrowseResourcesRequest()
{
	CBrowseResourcesRequest* request = new CBrowseResourcesRequest("WsSMC");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	request->setMsgName("BrowseResources");
	return request;
}

IClientBrowseResourcesResponse * CClientWsSMC::BrowseResources(IClientBrowseResourcesRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CBrowseResourcesRequest* esprequest = static_cast<CBrowseResourcesRequest*>(request);
	CBrowseResourcesResponse* espresponse = new CBrowseResourcesResponse("WsSMC");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientWsSMC::async_BrowseResources(IClientBrowseResourcesRequest *request, IClientWsSMCEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CBrowseResourcesRequest* esprequest = static_cast<CBrowseResourcesRequest*>(request);
	esprequest->setMethod("BrowseResources");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientWsSMC::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientBrowseResourcesResponse *CClientWsSMC::BrowseResourcesFn()
{
	Owned<IClientBrowseResourcesRequest> req =  createBrowseResourcesRequest();
	return BrowseResources(req.get());
}

//------ method ClearQueue ---------

IClientSMCQueueRequest * CClientWsSMC::createClearQueueRequest()
{
	CSMCQueueRequest* request = new CSMCQueueRequest("WsSMC");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	request->setMsgName("ClearQueue");
	return request;
}

IClientSMCQueueResponse * CClientWsSMC::ClearQueue(IClientSMCQueueRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CSMCQueueRequest* esprequest = static_cast<CSMCQueueRequest*>(request);
	CSMCQueueResponse* espresponse = new CSMCQueueResponse("WsSMC");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientWsSMC::async_ClearQueue(IClientSMCQueueRequest *request, IClientWsSMCEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CSMCQueueRequest* esprequest = static_cast<CSMCQueueRequest*>(request);
	esprequest->setMethod("ClearQueue");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientWsSMC::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientSMCQueueResponse *CClientWsSMC::ClearQueueFn(const char * Cluster_, const char * QueueName_, const char * Comment_, const char * ServerType_, const char * NetworkAddress_, int Port_)
{
	Owned<IClientSMCQueueRequest> req =  createClearQueueRequest();
	req->setCluster(Cluster_);
	req->setQueueName(QueueName_);
	req->setComment(Comment_);
	req->setServerType(ServerType_);
	req->setNetworkAddress(NetworkAddress_);
	req->setPort(Port_);
	return ClearQueue(req.get());
}

//------ method GetStatusServerInfo ---------

IClientGetStatusServerInfoRequest * CClientWsSMC::createGetStatusServerInfoRequest()
{
	CGetStatusServerInfoRequest* request = new CGetStatusServerInfoRequest("WsSMC");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	request->setMsgName("GetStatusServerInfo");
	return request;
}

IClientGetStatusServerInfoResponse * CClientWsSMC::GetStatusServerInfo(IClientGetStatusServerInfoRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CGetStatusServerInfoRequest* esprequest = static_cast<CGetStatusServerInfoRequest*>(request);
	CGetStatusServerInfoResponse* espresponse = new CGetStatusServerInfoResponse("WsSMC");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientWsSMC::async_GetStatusServerInfo(IClientGetStatusServerInfoRequest *request, IClientWsSMCEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CGetStatusServerInfoRequest* esprequest = static_cast<CGetStatusServerInfoRequest*>(request);
	esprequest->setMethod("GetStatusServerInfo");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientWsSMC::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientGetStatusServerInfoResponse *CClientWsSMC::GetStatusServerInfoFn(const char * ServerName_, const char * ServerType_, const char * NetworkAddress_, int Port_)
{
	Owned<IClientGetStatusServerInfoRequest> req =  createGetStatusServerInfoRequest();
	req->setServerName(ServerName_);
	req->setServerType(ServerType_);
	req->setNetworkAddress(NetworkAddress_);
	req->setPort(Port_);
	return GetStatusServerInfo(req.get());
}

//------ method GetThorQueueAvailability ---------

IClientGetThorQueueAvailabilityRequest * CClientWsSMC::createGetThorQueueAvailabilityRequest()
{
	CGetThorQueueAvailabilityRequest* request = new CGetThorQueueAvailabilityRequest("WsSMC");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	request->setMsgName("GetThorQueueAvailability");
	return request;
}

IClientGetThorQueueAvailabilityResponse * CClientWsSMC::GetThorQueueAvailability(IClientGetThorQueueAvailabilityRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CGetThorQueueAvailabilityRequest* esprequest = static_cast<CGetThorQueueAvailabilityRequest*>(request);
	CGetThorQueueAvailabilityResponse* espresponse = new CGetThorQueueAvailabilityResponse("WsSMC");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientWsSMC::async_GetThorQueueAvailability(IClientGetThorQueueAvailabilityRequest *request, IClientWsSMCEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CGetThorQueueAvailabilityRequest* esprequest = static_cast<CGetThorQueueAvailabilityRequest*>(request);
	esprequest->setMethod("GetThorQueueAvailability");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientWsSMC::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientGetThorQueueAvailabilityResponse *CClientWsSMC::GetThorQueueAvailabilityFn()
{
	Owned<IClientGetThorQueueAvailabilityRequest> req =  createGetThorQueueAvailabilityRequest();
	return GetThorQueueAvailability(req.get());
}

//------ method Index ---------

IClientSMCIndexRequest * CClientWsSMC::createIndexRequest()
{
	CSMCIndexRequest* request = new CSMCIndexRequest("WsSMC");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	request->setMsgName("Index");
	return request;
}

IClientSMCIndexResponse * CClientWsSMC::Index(IClientSMCIndexRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CSMCIndexRequest* esprequest = static_cast<CSMCIndexRequest*>(request);
	CSMCIndexResponse* espresponse = new CSMCIndexResponse("WsSMC");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientWsSMC::async_Index(IClientSMCIndexRequest *request, IClientWsSMCEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CSMCIndexRequest* esprequest = static_cast<CSMCIndexRequest*>(request);
	esprequest->setMethod("Index");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientWsSMC::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientSMCIndexResponse *CClientWsSMC::IndexFn()
{
	Owned<IClientSMCIndexRequest> req =  createIndexRequest();
	return Index(req.get());
}

//------ method LockQuery ---------

IClientLockQueryRequest * CClientWsSMC::createLockQueryRequest()
{
	CLockQueryRequest* request = new CLockQueryRequest("WsSMC");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	request->setMsgName("LockQuery");
	return request;
}

IClientLockQueryResponse * CClientWsSMC::LockQuery(IClientLockQueryRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CLockQueryRequest* esprequest = static_cast<CLockQueryRequest*>(request);
	CLockQueryResponse* espresponse = new CLockQueryResponse("WsSMC");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientWsSMC::async_LockQuery(IClientLockQueryRequest *request, IClientWsSMCEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CLockQueryRequest* esprequest = static_cast<CLockQueryRequest*>(request);
	esprequest->setMethod("LockQuery");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientWsSMC::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientLockQueryResponse *CClientWsSMC::LockQueryFn(const char * EPIP_, const char * XPath_, unsigned int DurationMSLow_, unsigned int DurationMSHigh_, const char * TimeLockedLow_, const char * TimeLockedHigh_, CLockModes Mode_, bool AllFileLocks_)
{
	Owned<IClientLockQueryRequest> req =  createLockQueryRequest();
	req->setEPIP(EPIP_);
	req->setXPath(XPath_);
	req->setDurationMSLow(DurationMSLow_);
	req->setDurationMSHigh(DurationMSHigh_);
	req->setTimeLockedLow(TimeLockedLow_);
	req->setTimeLockedHigh(TimeLockedHigh_);
	req->setMode(Mode_);
	req->setAllFileLocks(AllFileLocks_);
	return LockQuery(req.get());
}

//------ method MoveJobBack ---------

IClientSMCJobRequest * CClientWsSMC::createMoveJobBackRequest()
{
	CSMCJobRequest* request = new CSMCJobRequest("WsSMC");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	request->setMsgName("MoveJobBack");
	return request;
}

IClientSMCJobResponse * CClientWsSMC::MoveJobBack(IClientSMCJobRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CSMCJobRequest* esprequest = static_cast<CSMCJobRequest*>(request);
	CSMCJobResponse* espresponse = new CSMCJobResponse("WsSMC");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientWsSMC::async_MoveJobBack(IClientSMCJobRequest *request, IClientWsSMCEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CSMCJobRequest* esprequest = static_cast<CSMCJobRequest*>(request);
	esprequest->setMethod("MoveJobBack");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientWsSMC::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientSMCJobResponse *CClientWsSMC::MoveJobBackFn(int ClusterType_, const char * Cluster_, const char * QueueName_, const char * Wuid_)
{
	Owned<IClientSMCJobRequest> req =  createMoveJobBackRequest();
	req->setClusterType(ClusterType_);
	req->setCluster(Cluster_);
	req->setQueueName(QueueName_);
	req->setWuid(Wuid_);
	return MoveJobBack(req.get());
}

//------ method MoveJobDown ---------

IClientSMCJobRequest * CClientWsSMC::createMoveJobDownRequest()
{
	CSMCJobRequest* request = new CSMCJobRequest("WsSMC");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	request->setMsgName("MoveJobDown");
	return request;
}

IClientSMCJobResponse * CClientWsSMC::MoveJobDown(IClientSMCJobRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CSMCJobRequest* esprequest = static_cast<CSMCJobRequest*>(request);
	CSMCJobResponse* espresponse = new CSMCJobResponse("WsSMC");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientWsSMC::async_MoveJobDown(IClientSMCJobRequest *request, IClientWsSMCEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CSMCJobRequest* esprequest = static_cast<CSMCJobRequest*>(request);
	esprequest->setMethod("MoveJobDown");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientWsSMC::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientSMCJobResponse *CClientWsSMC::MoveJobDownFn(int ClusterType_, const char * Cluster_, const char * QueueName_, const char * Wuid_)
{
	Owned<IClientSMCJobRequest> req =  createMoveJobDownRequest();
	req->setClusterType(ClusterType_);
	req->setCluster(Cluster_);
	req->setQueueName(QueueName_);
	req->setWuid(Wuid_);
	return MoveJobDown(req.get());
}

//------ method MoveJobFront ---------

IClientSMCJobRequest * CClientWsSMC::createMoveJobFrontRequest()
{
	CSMCJobRequest* request = new CSMCJobRequest("WsSMC");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	request->setMsgName("MoveJobFront");
	return request;
}

IClientSMCJobResponse * CClientWsSMC::MoveJobFront(IClientSMCJobRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CSMCJobRequest* esprequest = static_cast<CSMCJobRequest*>(request);
	CSMCJobResponse* espresponse = new CSMCJobResponse("WsSMC");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientWsSMC::async_MoveJobFront(IClientSMCJobRequest *request, IClientWsSMCEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CSMCJobRequest* esprequest = static_cast<CSMCJobRequest*>(request);
	esprequest->setMethod("MoveJobFront");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientWsSMC::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientSMCJobResponse *CClientWsSMC::MoveJobFrontFn(int ClusterType_, const char * Cluster_, const char * QueueName_, const char * Wuid_)
{
	Owned<IClientSMCJobRequest> req =  createMoveJobFrontRequest();
	req->setClusterType(ClusterType_);
	req->setCluster(Cluster_);
	req->setQueueName(QueueName_);
	req->setWuid(Wuid_);
	return MoveJobFront(req.get());
}

//------ method MoveJobUp ---------

IClientSMCJobRequest * CClientWsSMC::createMoveJobUpRequest()
{
	CSMCJobRequest* request = new CSMCJobRequest("WsSMC");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	request->setMsgName("MoveJobUp");
	return request;
}

IClientSMCJobResponse * CClientWsSMC::MoveJobUp(IClientSMCJobRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CSMCJobRequest* esprequest = static_cast<CSMCJobRequest*>(request);
	CSMCJobResponse* espresponse = new CSMCJobResponse("WsSMC");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientWsSMC::async_MoveJobUp(IClientSMCJobRequest *request, IClientWsSMCEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CSMCJobRequest* esprequest = static_cast<CSMCJobRequest*>(request);
	esprequest->setMethod("MoveJobUp");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientWsSMC::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientSMCJobResponse *CClientWsSMC::MoveJobUpFn(int ClusterType_, const char * Cluster_, const char * QueueName_, const char * Wuid_)
{
	Owned<IClientSMCJobRequest> req =  createMoveJobUpRequest();
	req->setClusterType(ClusterType_);
	req->setCluster(Cluster_);
	req->setQueueName(QueueName_);
	req->setWuid(Wuid_);
	return MoveJobUp(req.get());
}

//------ method NotInCommunityEdition ---------

IClientNotInCommunityEditionRequest * CClientWsSMC::createNotInCommunityEditionRequest()
{
	CNotInCommunityEditionRequest* request = new CNotInCommunityEditionRequest("WsSMC");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	request->setMsgName("NotInCommunityEdition");
	return request;
}

IClientNotInCommunityEditionResponse * CClientWsSMC::NotInCommunityEdition(IClientNotInCommunityEditionRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CNotInCommunityEditionRequest* esprequest = static_cast<CNotInCommunityEditionRequest*>(request);
	CNotInCommunityEditionResponse* espresponse = new CNotInCommunityEditionResponse("WsSMC");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientWsSMC::async_NotInCommunityEdition(IClientNotInCommunityEditionRequest *request, IClientWsSMCEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CNotInCommunityEditionRequest* esprequest = static_cast<CNotInCommunityEditionRequest*>(request);
	esprequest->setMethod("NotInCommunityEdition");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientWsSMC::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientNotInCommunityEditionResponse *CClientWsSMC::NotInCommunityEditionFn(const char * EEPortal_)
{
	Owned<IClientNotInCommunityEditionRequest> req =  createNotInCommunityEditionRequest();
	req->setEEPortal(EEPortal_);
	return NotInCommunityEdition(req.get());
}

//------ method PauseQueue ---------

IClientSMCQueueRequest * CClientWsSMC::createPauseQueueRequest()
{
	CSMCQueueRequest* request = new CSMCQueueRequest("WsSMC");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	request->setMsgName("PauseQueue");
	return request;
}

IClientSMCQueueResponse * CClientWsSMC::PauseQueue(IClientSMCQueueRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CSMCQueueRequest* esprequest = static_cast<CSMCQueueRequest*>(request);
	CSMCQueueResponse* espresponse = new CSMCQueueResponse("WsSMC");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientWsSMC::async_PauseQueue(IClientSMCQueueRequest *request, IClientWsSMCEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CSMCQueueRequest* esprequest = static_cast<CSMCQueueRequest*>(request);
	esprequest->setMethod("PauseQueue");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientWsSMC::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientSMCQueueResponse *CClientWsSMC::PauseQueueFn(const char * Cluster_, const char * QueueName_, const char * Comment_, const char * ServerType_, const char * NetworkAddress_, int Port_)
{
	Owned<IClientSMCQueueRequest> req =  createPauseQueueRequest();
	req->setCluster(Cluster_);
	req->setQueueName(QueueName_);
	req->setComment(Comment_);
	req->setServerType(ServerType_);
	req->setNetworkAddress(NetworkAddress_);
	req->setPort(Port_);
	return PauseQueue(req.get());
}

//------ method Ping ---------

IClientWsSMCPingRequest * CClientWsSMC::createPingRequest()
{
	CWsSMCPingRequest* request = new CWsSMCPingRequest("WsSMC");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	request->setMsgName("Ping");
	return request;
}

IClientWsSMCPingResponse * CClientWsSMC::Ping(IClientWsSMCPingRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CWsSMCPingRequest* esprequest = static_cast<CWsSMCPingRequest*>(request);
	CWsSMCPingResponse* espresponse = new CWsSMCPingResponse("WsSMC");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientWsSMC::async_Ping(IClientWsSMCPingRequest *request, IClientWsSMCEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CWsSMCPingRequest* esprequest = static_cast<CWsSMCPingRequest*>(request);
	esprequest->setMethod("Ping");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientWsSMC::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientWsSMCPingResponse *CClientWsSMC::PingFn()
{
	Owned<IClientWsSMCPingRequest> req =  createPingRequest();
	return Ping(req.get());
}

//------ method RemoveJob ---------

IClientSMCJobRequest * CClientWsSMC::createRemoveJobRequest()
{
	CSMCJobRequest* request = new CSMCJobRequest("WsSMC");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	request->setMsgName("RemoveJob");
	return request;
}

IClientSMCJobResponse * CClientWsSMC::RemoveJob(IClientSMCJobRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CSMCJobRequest* esprequest = static_cast<CSMCJobRequest*>(request);
	CSMCJobResponse* espresponse = new CSMCJobResponse("WsSMC");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientWsSMC::async_RemoveJob(IClientSMCJobRequest *request, IClientWsSMCEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CSMCJobRequest* esprequest = static_cast<CSMCJobRequest*>(request);
	esprequest->setMethod("RemoveJob");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientWsSMC::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientSMCJobResponse *CClientWsSMC::RemoveJobFn(int ClusterType_, const char * Cluster_, const char * QueueName_, const char * Wuid_)
{
	Owned<IClientSMCJobRequest> req =  createRemoveJobRequest();
	req->setClusterType(ClusterType_);
	req->setCluster(Cluster_);
	req->setQueueName(QueueName_);
	req->setWuid(Wuid_);
	return RemoveJob(req.get());
}

//------ method ResumeQueue ---------

IClientSMCQueueRequest * CClientWsSMC::createResumeQueueRequest()
{
	CSMCQueueRequest* request = new CSMCQueueRequest("WsSMC");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	request->setMsgName("ResumeQueue");
	return request;
}

IClientSMCQueueResponse * CClientWsSMC::ResumeQueue(IClientSMCQueueRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CSMCQueueRequest* esprequest = static_cast<CSMCQueueRequest*>(request);
	CSMCQueueResponse* espresponse = new CSMCQueueResponse("WsSMC");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientWsSMC::async_ResumeQueue(IClientSMCQueueRequest *request, IClientWsSMCEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CSMCQueueRequest* esprequest = static_cast<CSMCQueueRequest*>(request);
	esprequest->setMethod("ResumeQueue");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientWsSMC::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientSMCQueueResponse *CClientWsSMC::ResumeQueueFn(const char * Cluster_, const char * QueueName_, const char * Comment_, const char * ServerType_, const char * NetworkAddress_, int Port_)
{
	Owned<IClientSMCQueueRequest> req =  createResumeQueueRequest();
	req->setCluster(Cluster_);
	req->setQueueName(QueueName_);
	req->setComment(Comment_);
	req->setServerType(ServerType_);
	req->setNetworkAddress(NetworkAddress_);
	req->setPort(Port_);
	return ResumeQueue(req.get());
}

//------ method RoxieControlCmd ---------

IClientRoxieControlCmdRequest * CClientWsSMC::createRoxieControlCmdRequest()
{
	CRoxieControlCmdRequest* request = new CRoxieControlCmdRequest("WsSMC");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	request->setMsgName("RoxieControlCmd");
	return request;
}

IClientRoxieControlCmdResponse * CClientWsSMC::RoxieControlCmd(IClientRoxieControlCmdRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CRoxieControlCmdRequest* esprequest = static_cast<CRoxieControlCmdRequest*>(request);
	CRoxieControlCmdResponse* espresponse = new CRoxieControlCmdResponse("WsSMC");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientWsSMC::async_RoxieControlCmd(IClientRoxieControlCmdRequest *request, IClientWsSMCEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CRoxieControlCmdRequest* esprequest = static_cast<CRoxieControlCmdRequest*>(request);
	esprequest->setMethod("RoxieControlCmd");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientWsSMC::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientRoxieControlCmdResponse *CClientWsSMC::RoxieControlCmdFn(const char * ProcessCluster_, CRoxieControlCmdType Command_, int Wait_)
{
	Owned<IClientRoxieControlCmdRequest> req =  createRoxieControlCmdRequest();
	req->setProcessCluster(ProcessCluster_);
	req->setCommand(Command_);
	req->setWait(Wait_);
	return RoxieControlCmd(req.get());
}

//------ method SetBanner ---------

IClientSetBannerRequest * CClientWsSMC::createSetBannerRequest()
{
	CSetBannerRequest* request = new CSetBannerRequest("WsSMC");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	request->setMsgName("SetBanner");
	return request;
}

IClientSetBannerResponse * CClientWsSMC::SetBanner(IClientSetBannerRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CSetBannerRequest* esprequest = static_cast<CSetBannerRequest*>(request);
	CSetBannerResponse* espresponse = new CSetBannerResponse("WsSMC");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientWsSMC::async_SetBanner(IClientSetBannerRequest *request, IClientWsSMCEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CSetBannerRequest* esprequest = static_cast<CSetBannerRequest*>(request);
	esprequest->setMethod("SetBanner");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientWsSMC::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientSetBannerResponse *CClientWsSMC::SetBannerFn(const char * ChatURL_, const char * BannerContent_, const char * BannerColor_, const char * BannerSize_, const char * BannerScroll_, int BannerAction_, bool EnableChatURL_, bool FromSubmitBtn_)
{
	Owned<IClientSetBannerRequest> req =  createSetBannerRequest();
	req->setChatURL(ChatURL_);
	req->setBannerContent(BannerContent_);
	req->setBannerColor(BannerColor_);
	req->setBannerSize(BannerSize_);
	req->setBannerScroll(BannerScroll_);
	req->setBannerAction(BannerAction_);
	req->setEnableChatURL(EnableChatURL_);
	req->setFromSubmitBtn(FromSubmitBtn_);
	return SetBanner(req.get());
}

//------ method SetJobPriority ---------

IClientSMCPriorityRequest * CClientWsSMC::createSetJobPriorityRequest()
{
	CSMCPriorityRequest* request = new CSMCPriorityRequest("WsSMC");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	request->setMsgName("SetJobPriority");
	return request;
}

IClientSMCPriorityResponse * CClientWsSMC::SetJobPriority(IClientSMCPriorityRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CSMCPriorityRequest* esprequest = static_cast<CSMCPriorityRequest*>(request);
	CSMCPriorityResponse* espresponse = new CSMCPriorityResponse("WsSMC");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientWsSMC::async_SetJobPriority(IClientSMCPriorityRequest *request, IClientWsSMCEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CSMCPriorityRequest* esprequest = static_cast<CSMCPriorityRequest*>(request);
	esprequest->setMethod("SetJobPriority");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientWsSMC::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientSMCPriorityResponse *CClientWsSMC::SetJobPriorityFn(int ClusterType_, const char * Cluster_, const char * QueueName_, const char * Wuid_, const char * Priority_, IArrayOf<IConstSMCJob> &SMCJobs_)
{
	Owned<IClientSMCPriorityRequest> req =  createSetJobPriorityRequest();
	req->setClusterType(ClusterType_);
	req->setCluster(Cluster_);
	req->setQueueName(QueueName_);
	req->setWuid(Wuid_);
	req->setPriority(Priority_);
	req->setSMCJobs(SMCJobs_);
	return SetJobPriority(req.get());
}

//------ method StopQueue ---------

IClientSMCQueueRequest * CClientWsSMC::createStopQueueRequest()
{
	CSMCQueueRequest* request = new CSMCQueueRequest("WsSMC");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	request->setMsgName("StopQueue");
	return request;
}

IClientSMCQueueResponse * CClientWsSMC::StopQueue(IClientSMCQueueRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CSMCQueueRequest* esprequest = static_cast<CSMCQueueRequest*>(request);
	CSMCQueueResponse* espresponse = new CSMCQueueResponse("WsSMC");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientWsSMC::async_StopQueue(IClientSMCQueueRequest *request, IClientWsSMCEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CSMCQueueRequest* esprequest = static_cast<CSMCQueueRequest*>(request);
	esprequest->setMethod("StopQueue");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientWsSMC::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientSMCQueueResponse *CClientWsSMC::StopQueueFn(const char * Cluster_, const char * QueueName_, const char * Comment_, const char * ServerType_, const char * NetworkAddress_, int Port_)
{
	Owned<IClientSMCQueueRequest> req =  createStopQueueRequest();
	req->setCluster(Cluster_);
	req->setQueueName(QueueName_);
	req->setComment(Comment_);
	req->setServerType(ServerType_);
	req->setNetworkAddress(NetworkAddress_);
	req->setPort(Port_);
	return StopQueue(req.get());
}

int CClientWsSMC::transferThunkEvent(void *data)
{
	IRpcResponseBinding *response = (IRpcResponseBinding *)data;
	if (response!=NULL)
	{
		IClientWsSMCEvents *eventSink = (IClientWsSMCEvents *)response->getEventSink();
		response->lock();

		if (stricmp(response->getMethod(), "Activity")==0)
		{
			IClientActivityResponse* icresp = dynamic_cast<IClientActivityResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onActivityComplete(icresp, response->queryState());
				else
					eventSink->onActivityError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "BrowseResources")==0)
		{
			IClientBrowseResourcesResponse* icresp = dynamic_cast<IClientBrowseResourcesResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onBrowseResourcesComplete(icresp, response->queryState());
				else
					eventSink->onBrowseResourcesError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "ClearQueue")==0)
		{
			IClientSMCQueueResponse* icresp = dynamic_cast<IClientSMCQueueResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onClearQueueComplete(icresp, response->queryState());
				else
					eventSink->onClearQueueError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "GetStatusServerInfo")==0)
		{
			IClientGetStatusServerInfoResponse* icresp = dynamic_cast<IClientGetStatusServerInfoResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onGetStatusServerInfoComplete(icresp, response->queryState());
				else
					eventSink->onGetStatusServerInfoError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "GetThorQueueAvailability")==0)
		{
			IClientGetThorQueueAvailabilityResponse* icresp = dynamic_cast<IClientGetThorQueueAvailabilityResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onGetThorQueueAvailabilityComplete(icresp, response->queryState());
				else
					eventSink->onGetThorQueueAvailabilityError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "Index")==0)
		{
			IClientSMCIndexResponse* icresp = dynamic_cast<IClientSMCIndexResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onIndexComplete(icresp, response->queryState());
				else
					eventSink->onIndexError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "LockQuery")==0)
		{
			IClientLockQueryResponse* icresp = dynamic_cast<IClientLockQueryResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onLockQueryComplete(icresp, response->queryState());
				else
					eventSink->onLockQueryError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "MoveJobBack")==0)
		{
			IClientSMCJobResponse* icresp = dynamic_cast<IClientSMCJobResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onMoveJobBackComplete(icresp, response->queryState());
				else
					eventSink->onMoveJobBackError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "MoveJobDown")==0)
		{
			IClientSMCJobResponse* icresp = dynamic_cast<IClientSMCJobResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onMoveJobDownComplete(icresp, response->queryState());
				else
					eventSink->onMoveJobDownError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "MoveJobFront")==0)
		{
			IClientSMCJobResponse* icresp = dynamic_cast<IClientSMCJobResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onMoveJobFrontComplete(icresp, response->queryState());
				else
					eventSink->onMoveJobFrontError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "MoveJobUp")==0)
		{
			IClientSMCJobResponse* icresp = dynamic_cast<IClientSMCJobResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onMoveJobUpComplete(icresp, response->queryState());
				else
					eventSink->onMoveJobUpError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "NotInCommunityEdition")==0)
		{
			IClientNotInCommunityEditionResponse* icresp = dynamic_cast<IClientNotInCommunityEditionResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onNotInCommunityEditionComplete(icresp, response->queryState());
				else
					eventSink->onNotInCommunityEditionError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "PauseQueue")==0)
		{
			IClientSMCQueueResponse* icresp = dynamic_cast<IClientSMCQueueResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onPauseQueueComplete(icresp, response->queryState());
				else
					eventSink->onPauseQueueError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "Ping")==0)
		{
			IClientWsSMCPingResponse* icresp = dynamic_cast<IClientWsSMCPingResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onPingComplete(icresp, response->queryState());
				else
					eventSink->onPingError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "RemoveJob")==0)
		{
			IClientSMCJobResponse* icresp = dynamic_cast<IClientSMCJobResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onRemoveJobComplete(icresp, response->queryState());
				else
					eventSink->onRemoveJobError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "ResumeQueue")==0)
		{
			IClientSMCQueueResponse* icresp = dynamic_cast<IClientSMCQueueResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onResumeQueueComplete(icresp, response->queryState());
				else
					eventSink->onResumeQueueError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "RoxieControlCmd")==0)
		{
			IClientRoxieControlCmdResponse* icresp = dynamic_cast<IClientRoxieControlCmdResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onRoxieControlCmdComplete(icresp, response->queryState());
				else
					eventSink->onRoxieControlCmdError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "SetBanner")==0)
		{
			IClientSetBannerResponse* icresp = dynamic_cast<IClientSetBannerResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onSetBannerComplete(icresp, response->queryState());
				else
					eventSink->onSetBannerError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "SetJobPriority")==0)
		{
			IClientSMCPriorityResponse* icresp = dynamic_cast<IClientSMCPriorityResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onSetJobPriorityComplete(icresp, response->queryState());
				else
					eventSink->onSetJobPriorityError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "StopQueue")==0)
		{
			IClientSMCQueueResponse* icresp = dynamic_cast<IClientSMCQueueResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onStopQueueComplete(icresp, response->queryState());
				else
					eventSink->onStopQueueError(icresp,response->queryState());
			}
		}
		response->unlock();
	}
	return 0;
}

static IRpcResponseBinding* createWsSMCResponseObject(IRpcRequestBinding *request)
{
	const char* method = request->getMethod();
	if (stricmp(method, "Activity")==0)
		return new CActivityResponse("WsSMC", request);
	if (stricmp(method, "BrowseResources")==0)
		return new CBrowseResourcesResponse("WsSMC", request);
	if (stricmp(method, "ClearQueue")==0)
		return new CSMCQueueResponse("WsSMC", request);
	if (stricmp(method, "GetStatusServerInfo")==0)
		return new CGetStatusServerInfoResponse("WsSMC", request);
	if (stricmp(method, "GetThorQueueAvailability")==0)
		return new CGetThorQueueAvailabilityResponse("WsSMC", request);
	if (stricmp(method, "Index")==0)
		return new CSMCIndexResponse("WsSMC", request);
	if (stricmp(method, "LockQuery")==0)
		return new CLockQueryResponse("WsSMC", request);
	if (stricmp(method, "MoveJobBack")==0)
		return new CSMCJobResponse("WsSMC", request);
	if (stricmp(method, "MoveJobDown")==0)
		return new CSMCJobResponse("WsSMC", request);
	if (stricmp(method, "MoveJobFront")==0)
		return new CSMCJobResponse("WsSMC", request);
	if (stricmp(method, "MoveJobUp")==0)
		return new CSMCJobResponse("WsSMC", request);
	if (stricmp(method, "NotInCommunityEdition")==0)
		return new CNotInCommunityEditionResponse("WsSMC", request);
	if (stricmp(method, "PauseQueue")==0)
		return new CSMCQueueResponse("WsSMC", request);
	if (stricmp(method, "Ping")==0)
		return new CWsSMCPingResponse("WsSMC", request);
	if (stricmp(method, "RemoveJob")==0)
		return new CSMCJobResponse("WsSMC", request);
	if (stricmp(method, "ResumeQueue")==0)
		return new CSMCQueueResponse("WsSMC", request);
	if (stricmp(method, "RoxieControlCmd")==0)
		return new CRoxieControlCmdResponse("WsSMC", request);
	if (stricmp(method, "SetBanner")==0)
		return new CSetBannerResponse("WsSMC", request);
	if (stricmp(method, "SetJobPriority")==0)
		return new CSMCPriorityResponse("WsSMC", request);
	if (stricmp(method, "StopQueue")==0)
		return new CSMCQueueResponse("WsSMC", request);
	return NULL;
}

#ifdef _WIN32
void CClientWsSMC::espWorkerThread(void* data)
#else
void *CClientWsSMC::espWorkerThread(void *data)
#endif
{
	IRpcRequestBinding *request = (IRpcRequestBinding *) data;

	if (request != NULL)
	{
		request->lock();
		IRpcResponseBinding *response=createWsSMCResponseObject(request);
		if (response!=NULL)
		{
			try{
				request->post(*response);
			}
			catch(IException* ex){
				StringBuffer errorStr;
				ex->errorMessage(errorStr);
				ERRLOG("CClientWsSMC::espWorkerThread(%s)--Exception caught while posting async request: %s", request->getMethod(), errorStr.str());
				ex->Release();
			}
			catch(...){
				ERRLOG("Unknown exception caught while posting async request");
			}
		}
#ifdef USE_CLIENT_THREAD
		ThunkToClientThread(request->getThunkHandle(), transferThunkEvent, (void *)response);
#else
		transferThunkEvent((void *)response);
#endif
		request->unlock();
		if(request->queryState()!=NULL)
			request->queryState()->Release();

		if(response!=NULL)
			response->Release();

		request->Release();
	}
#if defined(_WIN32)
#else
	return (void *) 0 ;
#endif
}



extern "C" IClientWsSMC * createWsSMCClient() {  return new CClientWsSMC(); }


#endif //ws_smc_ESPGEN_INCLUDED
