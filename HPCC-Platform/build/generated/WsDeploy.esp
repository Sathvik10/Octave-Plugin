// *** Source file generated by HIDL Version 1.3 from WsDeploy.ecm ***
// *** Not to be hand edited (changes will be lost on re-generation) ***

#ifndef WsDeploy_ESPGEN_INCLUDED
#define WsDeploy_ESPGEN_INCLUDED

#include "WsDeploy_esp.ipp"

#ifdef _WIN32
#include "edwin.h"
#include <process.h>
#endif



//=======================================================
// class CTask Implementation
//=======================================================

CTask::CTask(const char *serviceName, IRpcMessageBinding *init)
	: m_Caption(nilIgnore),m_FileName(nilIgnore),m_TargetPath(nilIgnore),m_SourcePath(nilIgnore),m_Status(nilIgnore),m_Message(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("Task");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CTask::CTask(const char *serviceName, const char *bc)
	: m_Caption(nilIgnore),m_FileName(nilIgnore),m_TargetPath(nilIgnore),m_SourcePath(nilIgnore),m_Status(nilIgnore),m_Message(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("Task");
}

StringBuffer &CTask::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:complexType name=\"%s\">\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Caption\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"FileName\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"TargetPath\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"SourcePath\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Status\" type=\"xsd:int\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Message\" type=\"xsd:string\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType>\n");
		}
	}
	return schema;
}

void CTask::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CTask::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CTask::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Caption");
	form.appendf("  <tr><td><b>Caption: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("FileName");
	form.appendf("  <tr><td><b>FileName: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("TargetPath");
	form.appendf("  <tr><td><b>TargetPath: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("SourcePath");
	form.appendf("  <tr><td><b>SourcePath: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix) extfix.append(prefix).append(".");
		extfix.append("Status");
	form.appendf("  <tr><td><b>Status: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Message");
	form.appendf("  <tr><td><b>Message: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CTask::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CTask::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_Caption.marshall(rpc_resp, "Caption", "", "", "");
	m_FileName.marshall(rpc_resp, "FileName", "", "", "");
	m_TargetPath.marshall(rpc_resp, "TargetPath", "", "", "");
	m_SourcePath.marshall(rpc_resp, "SourcePath", "", "", "");
	m_Status.marshall(rpc_resp, "Status", "", "", "");
	m_Message.marshall(rpc_resp, "Message", "", "", "");
}


void CTask::copy(CTask &from)
{
	m_Caption.copy(from.m_Caption);
	m_FileName.copy(from.m_FileName);
	m_TargetPath.copy(from.m_TargetPath);
	m_SourcePath.copy(from.m_SourcePath);
	m_Status.copy(from.m_Status);
	m_Message.copy(from.m_Message);
}


void CTask::copy(IConstTask &ifrom)
{
	setCaption(ifrom.getCaption());
	setFileName(ifrom.getFileName());
	setTargetPath(ifrom.getTargetPath());
	setSourcePath(ifrom.getSourcePath());
	setStatus(ifrom.getStatus());
	setMessage(ifrom.getMessage());
}


void CTask::getAttributes(IProperties &attributes)
{
}


void CTask::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_Caption.toStr(ctx, buffer, "Caption", "", true, "", "");
	m_FileName.toStr(ctx, buffer, "FileName", "", true, "", "");
	m_TargetPath.toStr(ctx, buffer, "TargetPath", "", true, "", "");
	m_SourcePath.toStr(ctx, buffer, "SourcePath", "", true, "", "");
	m_Status.toStr(ctx, buffer, "Status", "", true, "", "");
	m_Message.toStr(ctx, buffer, "Message", "", true, "", "");
}


void CTask::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CTask::serializer(IEspContext* ctx, IConstTask &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<Task>");
	// field Caption
	{
		const char* s = src.getCaption();
		if (s && *s)
		{
			buffer.append("<Caption>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Caption>");
		}
	}
	// field FileName
	{
		const char* s = src.getFileName();
		if (s && *s)
		{
			buffer.append("<FileName>");
			encodeUtf8XML(s,buffer);
			buffer.append("</FileName>");
		}
	}
	// field TargetPath
	{
		const char* s = src.getTargetPath();
		if (s && *s)
		{
			buffer.append("<TargetPath>");
			encodeUtf8XML(s,buffer);
			buffer.append("</TargetPath>");
		}
	}
	// field SourcePath
	{
		const char* s = src.getSourcePath();
		if (s && *s)
		{
			buffer.append("<SourcePath>");
			encodeUtf8XML(s,buffer);
			buffer.append("</SourcePath>");
		}
	}
	// field Status
	{
		int n = src.getStatus();
		if (n)
			buffer.appendf("<Status>%d</Status>", n);
	}
	// field Message
	{
		const char* s = src.getMessage();
		if (s && *s)
		{
			buffer.append("<Message>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Message>");
		}
	}
	if (keepRootTag)
		buffer.append("</Task>");
}

bool CTask::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_Caption.unmarshall(rpc_request, "Caption", basepath);
	hasValue |= m_FileName.unmarshall(rpc_request, "FileName", basepath);
	hasValue |= m_TargetPath.unmarshall(rpc_request, "TargetPath", basepath);
	hasValue |= m_SourcePath.unmarshall(rpc_request, "SourcePath", basepath);
	hasValue |= m_Status.unmarshall(rpc_request, "Status", basepath);
	hasValue |= m_Message.unmarshall(rpc_request, "Message", basepath);
	return hasValue;
}

bool CTask::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Caption.unmarshall(ctx, soapval, "Caption");
	hasValue |= m_FileName.unmarshall(ctx, soapval, "FileName");
	hasValue |= m_TargetPath.unmarshall(ctx, soapval, "TargetPath");
	hasValue |= m_SourcePath.unmarshall(ctx, soapval, "SourcePath");
	hasValue |= m_Status.unmarshall(ctx, soapval, "Status");
	hasValue |= m_Message.unmarshall(ctx, soapval, "Message");
	return hasValue;
}

bool CTask::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Caption.unmarshall(ctx, params, attachments, "Caption", basepath);
	hasValue |= m_FileName.unmarshall(ctx, params, attachments, "FileName", basepath);
	hasValue |= m_TargetPath.unmarshall(ctx, params, attachments, "TargetPath", basepath);
	hasValue |= m_SourcePath.unmarshall(ctx, params, attachments, "SourcePath", basepath);
	hasValue |= m_Status.unmarshall(ctx, params, attachments, "Status", basepath);
	hasValue |= m_Message.unmarshall(ctx, params, attachments, "Message", basepath);
	return hasValue;
}

const char * CTask::getCaption() { return m_Caption.query();}
const char * CTask::getFileName() { return m_FileName.query();}
const char * CTask::getTargetPath() { return m_TargetPath.query();}
const char * CTask::getSourcePath() { return m_SourcePath.query();}
int CTask::getStatus() { return m_Status;}
const char * CTask::getMessage() { return m_Message.query();}
void CTask::setCaption(const char * val){ m_Caption.set(val); }
void CTask::setFileName(const char * val){ m_FileName.set(val); }
void CTask::setTargetPath(const char * val){ m_TargetPath.set(val); }
void CTask::setSourcePath(const char * val){ m_SourcePath.set(val); }
void CTask::setStatus(int val){ m_Status=val; }
void CTask::setMessage(const char * val){ m_Message.set(val); }
extern "C"  IEspTask *createTask(const char *serv, const char *msgname){return ((IEspTask *)new CTask(serv /*, msgname*/));}
extern "C"  IClientTask *createClientTask(const char *serv, const char *msgname){return ((IClientTask *)new CTask(serv /*, msgname*/));}

//=======================================================
// class CComponent Implementation
//=======================================================

CComponent::CComponent(const char *serviceName, IRpcMessageBinding *init)
	: m_Type(nilIgnore),m_DisplayType(nilIgnore),m_Name(nilIgnore),m_Build(nilIgnore),m_Computer(nilIgnore),m_Instance(nilIgnore),m_InstanceType(nilIgnore),m_Tasks(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("Component");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CComponent::CComponent(const char *serviceName, const char *bc)
	: m_Type(nilIgnore),m_DisplayType(nilIgnore),m_Name(nilIgnore),m_Build(nilIgnore),m_Computer(nilIgnore),m_Instance(nilIgnore),m_InstanceType(nilIgnore),m_Tasks(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("Component");
}

StringBuffer &CComponent::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:complexType name=\"%s\">\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Type\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"DisplayType\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Name\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Build\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Computer\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Instance\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"InstanceType\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Tasks\" type=\"tns:ArrayOfTask\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType>\n");
		}
	}
	if (!(flags & 0x10)  || (flags & 0x100))
	{
		CTask::getXsdDefinition(context, request, schema, added);
	}
	if (added.getValue("Task") && added.getValue("ArrayOfTask")==NULL) {
		schema.append("<xsd:complexType name=\"ArrayOfTask\">\n");
		schema.append("<xsd:sequence>\n");
		schema.append("<xsd:element minOccurs=\"0\" maxOccurs=\"unbounded\" name=\"Task\" type=\"tns:Task\"/>\n");
		schema.append("</xsd:sequence>\n");
		schema.append("</xsd:complexType>\n");
		added.setValue("ArrayOfTask",1);
	}
	return schema;
}

void CComponent::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CComponent::getMapInfo(IMapInfo& info, BoolHash& added)
{
	if (!added.getValue("Task"))
	{
		added.setValue("Task",1);
		CTask::getMapInfo(info,added);
	}
}

StringBuffer &CComponent::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Type");
	form.appendf("  <tr><td><b>Type: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("DisplayType");
	form.appendf("  <tr><td><b>DisplayType: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Name");
	form.appendf("  <tr><td><b>Name: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Build");
	form.appendf("  <tr><td><b>Build: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Computer");
	form.appendf("  <tr><td><b>Computer: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Instance");
	form.appendf("  <tr><td><b>Instance: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("InstanceType");
	form.appendf("  <tr><td><b>InstanceType: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Tasks");
	form.appendf("<tr><td><b>Tasks: </b></td><td>");
	form.appendf("<table><tr><td><textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea></td>", extfix.str());
	form.append("</tr></table>");
	form.append("</td></tr>");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CComponent::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CComponent::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_Type.marshall(rpc_resp, "Type", "", "", "");
	m_DisplayType.marshall(rpc_resp, "DisplayType", "", "", "");
	m_Name.marshall(rpc_resp, "Name", "", "", "");
	m_Build.marshall(rpc_resp, "Build", "", "", "");
	m_Computer.marshall(rpc_resp, "Computer", "", "", "");
	m_Instance.marshall(rpc_resp, "Instance", "", "", "");
	m_InstanceType.marshall(rpc_resp, "InstanceType", "", "", "");
	m_Tasks.marshall(rpc_resp, "Tasks", "Task");
}


void CComponent::copy(CComponent &from)
{
	m_Type.copy(from.m_Type);
	m_DisplayType.copy(from.m_DisplayType);
	m_Name.copy(from.m_Name);
	m_Build.copy(from.m_Build);
	m_Computer.copy(from.m_Computer);
	m_Instance.copy(from.m_Instance);
	m_InstanceType.copy(from.m_InstanceType);
	m_Tasks.copy(from.m_Tasks);
}


void CComponent::copy(IConstComponent &ifrom)
{
	setType(ifrom.getType());
	setDisplayType(ifrom.getDisplayType());
	setName(ifrom.getName());
	setBuild(ifrom.getBuild());
	setComputer(ifrom.getComputer());
	setInstance(ifrom.getInstance());
	setInstanceType(ifrom.getInstanceType());
	setTasks(ifrom.getTasks());
}


void CComponent::getAttributes(IProperties &attributes)
{
}


void CComponent::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_Type.toStr(ctx, buffer, "Type", "", true, "", "");
	m_DisplayType.toStr(ctx, buffer, "DisplayType", "", true, "", "");
	m_Name.toStr(ctx, buffer, "Name", "", true, "", "");
	m_Build.toStr(ctx, buffer, "Build", "", true, "", "");
	m_Computer.toStr(ctx, buffer, "Computer", "", true, "", "");
	m_Instance.toStr(ctx, buffer, "Instance", "", true, "", "");
	m_InstanceType.toStr(ctx, buffer, "InstanceType", "", true, "", "");
	m_Tasks.toStr(ctx, buffer, "Tasks", "Task");
}


void CComponent::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CComponent::serializer(IEspContext* ctx, IConstComponent &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<Component>");
	// field Type
	{
		const char* s = src.getType();
		if (s && *s)
		{
			buffer.append("<Type>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Type>");
		}
	}
	// field DisplayType
	{
		const char* s = src.getDisplayType();
		if (s && *s)
		{
			buffer.append("<DisplayType>");
			encodeUtf8XML(s,buffer);
			buffer.append("</DisplayType>");
		}
	}
	// field Name
	{
		const char* s = src.getName();
		if (s && *s)
		{
			buffer.append("<Name>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Name>");
		}
	}
	// field Build
	{
		const char* s = src.getBuild();
		if (s && *s)
		{
			buffer.append("<Build>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Build>");
		}
	}
	// field Computer
	{
		const char* s = src.getComputer();
		if (s && *s)
		{
			buffer.append("<Computer>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Computer>");
		}
	}
	// field Instance
	{
		const char* s = src.getInstance();
		if (s && *s)
		{
			buffer.append("<Instance>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Instance>");
		}
	}
	// field InstanceType
	{
		const char* s = src.getInstanceType();
		if (s && *s)
		{
			buffer.append("<InstanceType>");
			encodeUtf8XML(s,buffer);
			buffer.append("</InstanceType>");
		}
	}
	// field Tasks
	{
		IArrayOf<IConstTask>& v = src.getTasks();
		int size = v.length();
		if (size>0)
			buffer.append("<Tasks>");
		for (int i=0;i<size;i++)
		{
			buffer.append("<Item>");
			CTask::serializer(ctx,v.item(i),buffer,false);
			buffer.append("</Item>");
		}
		if (size>0)
			buffer.append("</Tasks>");
	}
	if (keepRootTag)
		buffer.append("</Component>");
}

bool CComponent::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_Type.unmarshall(rpc_request, "Type", basepath);
	hasValue |= m_DisplayType.unmarshall(rpc_request, "DisplayType", basepath);
	hasValue |= m_Name.unmarshall(rpc_request, "Name", basepath);
	hasValue |= m_Build.unmarshall(rpc_request, "Build", basepath);
	hasValue |= m_Computer.unmarshall(rpc_request, "Computer", basepath);
	hasValue |= m_Instance.unmarshall(rpc_request, "Instance", basepath);
	hasValue |= m_InstanceType.unmarshall(rpc_request, "InstanceType", basepath);
	hasValue |= m_Tasks.unmarshall(rpc_request, "Tasks", basepath);
	return hasValue;
}

bool CComponent::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Type.unmarshall(ctx, soapval, "Type");
	hasValue |= m_DisplayType.unmarshall(ctx, soapval, "DisplayType");
	hasValue |= m_Name.unmarshall(ctx, soapval, "Name");
	hasValue |= m_Build.unmarshall(ctx, soapval, "Build");
	hasValue |= m_Computer.unmarshall(ctx, soapval, "Computer");
	hasValue |= m_Instance.unmarshall(ctx, soapval, "Instance");
	hasValue |= m_InstanceType.unmarshall(ctx, soapval, "InstanceType");
	hasValue |= m_Tasks.unmarshall(ctx, soapval, "Tasks");
	return hasValue;
}

bool CComponent::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Type.unmarshall(ctx, params, attachments, "Type", basepath);
	hasValue |= m_DisplayType.unmarshall(ctx, params, attachments, "DisplayType", basepath);
	hasValue |= m_Name.unmarshall(ctx, params, attachments, "Name", basepath);
	hasValue |= m_Build.unmarshall(ctx, params, attachments, "Build", basepath);
	hasValue |= m_Computer.unmarshall(ctx, params, attachments, "Computer", basepath);
	hasValue |= m_Instance.unmarshall(ctx, params, attachments, "Instance", basepath);
	hasValue |= m_InstanceType.unmarshall(ctx, params, attachments, "InstanceType", basepath);
	hasValue |= m_Tasks.unmarshall(ctx, params, attachments, "Tasks", basepath);
	return hasValue;
}

const char * CComponent::getType() { return m_Type.query();}
const char * CComponent::getDisplayType() { return m_DisplayType.query();}
const char * CComponent::getName() { return m_Name.query();}
const char * CComponent::getBuild() { return m_Build.query();}
const char * CComponent::getComputer() { return m_Computer.query();}
const char * CComponent::getInstance() { return m_Instance.query();}
const char * CComponent::getInstanceType() { return m_InstanceType.query();}
IArrayOf<IConstTask> & CComponent::getTasks() { return (IArrayOf<IConstTask> &) m_Tasks; }
void CComponent::setType(const char * val){ m_Type.set(val); }
void CComponent::setDisplayType(const char * val){ m_DisplayType.set(val); }
void CComponent::setName(const char * val){ m_Name.set(val); }
void CComponent::setBuild(const char * val){ m_Build.set(val); }
void CComponent::setComputer(const char * val){ m_Computer.set(val); }
void CComponent::setInstance(const char * val){ m_Instance.set(val); }
void CComponent::setInstanceType(const char * val){ m_InstanceType.set(val); }
void CComponent::setTasks(IArrayOf<IEspTask> &val)
{
	m_Tasks->kill();
	IArrayOf<IConstTask> &target = m_Tasks.getValue();
	ForEachItemIn(idx, val)
	{
		IEspTask &item = (val).item(idx);
		item.Link();
		target.append(item);
	}
}
void CComponent::setTasks(IArrayOf<IConstTask> &val)
{
	m_Tasks->kill();
	IArrayOf<IConstTask> &target = m_Tasks.getValue();
	ForEachItemIn(idx, val)
	{
		IConstTask &item = val.item(idx);
		item.Link();
		target.append(item);
	}
}
extern "C"  IEspComponent *createComponent(const char *serv, const char *msgname){return ((IEspComponent *)new CComponent(serv /*, msgname*/));}
extern "C"  IClientComponent *createClientComponent(const char *serv, const char *msgname){return ((IClientComponent *)new CComponent(serv /*, msgname*/));}

//=======================================================
// class CDeployOptions Implementation
//=======================================================

CDeployOptions::CDeployOptions(const char *serviceName, IRpcMessageBinding *init)
	: m_Compare(nilIgnore),m_ConfigFiles(nilIgnore),m_BuildFiles(nilIgnore),m_UpgradeBuildFiles(nilIgnore),m_Start(nilIgnore),m_Stop(nilIgnore),m_BackupRename(nilIgnore),m_BackupCopy(nilIgnore),m_ArchiveEnv(nilIgnore),m_Log(nilIgnore),m_ArchivePath(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("DeployOptions");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CDeployOptions::CDeployOptions(const char *serviceName, const char *bc)
	: m_Compare(nilIgnore),m_ConfigFiles(nilIgnore),m_BuildFiles(nilIgnore),m_UpgradeBuildFiles(nilIgnore),m_Start(nilIgnore),m_Stop(nilIgnore),m_BackupRename(nilIgnore),m_BackupCopy(nilIgnore),m_ArchiveEnv(nilIgnore),m_Log(nilIgnore),m_ArchivePath(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("DeployOptions");
}

StringBuffer &CDeployOptions::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:complexType name=\"%s\">\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Compare\" type=\"xsd:boolean\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"ConfigFiles\" type=\"xsd:boolean\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"BuildFiles\" type=\"xsd:boolean\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"UpgradeBuildFiles\" type=\"xsd:boolean\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Start\" type=\"xsd:boolean\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Stop\" type=\"xsd:boolean\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"BackupRename\" type=\"xsd:boolean\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"BackupCopy\" type=\"xsd:boolean\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"ArchiveEnv\" type=\"xsd:boolean\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Log\" type=\"xsd:boolean\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"ArchivePath\" type=\"xsd:string\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType>\n");
		}
	}
	return schema;
}

void CDeployOptions::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CDeployOptions::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CDeployOptions::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Compare");
	
	form.appendf("  <tr><td><b>Compare? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("ConfigFiles");
	
	form.appendf("  <tr><td><b>ConfigFiles? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("BuildFiles");
	
	form.appendf("  <tr><td><b>BuildFiles? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("UpgradeBuildFiles");
	
	form.appendf("  <tr><td><b>UpgradeBuildFiles? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Start");
	
	form.appendf("  <tr><td><b>Start? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Stop");
	
	form.appendf("  <tr><td><b>Stop? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("BackupRename");
	
	form.appendf("  <tr><td><b>BackupRename? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("BackupCopy");
	
	form.appendf("  <tr><td><b>BackupCopy? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("ArchiveEnv");
	
	form.appendf("  <tr><td><b>ArchiveEnv? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Log");
	
	form.appendf("  <tr><td><b>Log? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("ArchivePath");
	form.appendf("  <tr><td><b>ArchivePath: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CDeployOptions::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CDeployOptions::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_Compare.marshall(rpc_resp, "Compare", "", "", "");
	m_ConfigFiles.marshall(rpc_resp, "ConfigFiles", "", "", "");
	m_BuildFiles.marshall(rpc_resp, "BuildFiles", "", "", "");
	m_UpgradeBuildFiles.marshall(rpc_resp, "UpgradeBuildFiles", "", "", "");
	m_Start.marshall(rpc_resp, "Start", "", "", "");
	m_Stop.marshall(rpc_resp, "Stop", "", "", "");
	m_BackupRename.marshall(rpc_resp, "BackupRename", "", "", "");
	m_BackupCopy.marshall(rpc_resp, "BackupCopy", "", "", "");
	m_ArchiveEnv.marshall(rpc_resp, "ArchiveEnv", "", "", "");
	m_Log.marshall(rpc_resp, "Log", "", "", "");
	m_ArchivePath.marshall(rpc_resp, "ArchivePath", "", "", "");
}


void CDeployOptions::copy(CDeployOptions &from)
{
	m_Compare.copy(from.m_Compare);
	m_ConfigFiles.copy(from.m_ConfigFiles);
	m_BuildFiles.copy(from.m_BuildFiles);
	m_UpgradeBuildFiles.copy(from.m_UpgradeBuildFiles);
	m_Start.copy(from.m_Start);
	m_Stop.copy(from.m_Stop);
	m_BackupRename.copy(from.m_BackupRename);
	m_BackupCopy.copy(from.m_BackupCopy);
	m_ArchiveEnv.copy(from.m_ArchiveEnv);
	m_Log.copy(from.m_Log);
	m_ArchivePath.copy(from.m_ArchivePath);
}


void CDeployOptions::copy(IConstDeployOptions &ifrom)
{
	setCompare(ifrom.getCompare());
	setConfigFiles(ifrom.getConfigFiles());
	setBuildFiles(ifrom.getBuildFiles());
	setUpgradeBuildFiles(ifrom.getUpgradeBuildFiles());
	setStart(ifrom.getStart());
	setStop(ifrom.getStop());
	setBackupRename(ifrom.getBackupRename());
	setBackupCopy(ifrom.getBackupCopy());
	setArchiveEnv(ifrom.getArchiveEnv());
	setLog(ifrom.getLog());
	setArchivePath(ifrom.getArchivePath());
}


void CDeployOptions::getAttributes(IProperties &attributes)
{
}


void CDeployOptions::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_Compare.toStr(ctx, buffer, "Compare", "", true, "", "");
	m_ConfigFiles.toStr(ctx, buffer, "ConfigFiles", "", true, "", "");
	m_BuildFiles.toStr(ctx, buffer, "BuildFiles", "", true, "", "");
	m_UpgradeBuildFiles.toStr(ctx, buffer, "UpgradeBuildFiles", "", true, "", "");
	m_Start.toStr(ctx, buffer, "Start", "", true, "", "");
	m_Stop.toStr(ctx, buffer, "Stop", "", true, "", "");
	m_BackupRename.toStr(ctx, buffer, "BackupRename", "", true, "", "");
	m_BackupCopy.toStr(ctx, buffer, "BackupCopy", "", true, "", "");
	m_ArchiveEnv.toStr(ctx, buffer, "ArchiveEnv", "", true, "", "");
	m_Log.toStr(ctx, buffer, "Log", "", true, "", "");
	m_ArchivePath.toStr(ctx, buffer, "ArchivePath", "", true, "", "");
}


void CDeployOptions::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CDeployOptions::serializer(IEspContext* ctx, IConstDeployOptions &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<DeployOptions>");
	// field Compare
	{
		bool b = src.getCompare();
		if (b)
			buffer.appendf("<Compare>1</Compare>");
	}
	// field ConfigFiles
	{
		bool b = src.getConfigFiles();
		if (b)
			buffer.appendf("<ConfigFiles>1</ConfigFiles>");
	}
	// field BuildFiles
	{
		bool b = src.getBuildFiles();
		if (b)
			buffer.appendf("<BuildFiles>1</BuildFiles>");
	}
	// field UpgradeBuildFiles
	{
		bool b = src.getUpgradeBuildFiles();
		if (b)
			buffer.appendf("<UpgradeBuildFiles>1</UpgradeBuildFiles>");
	}
	// field Start
	{
		bool b = src.getStart();
		if (b)
			buffer.appendf("<Start>1</Start>");
	}
	// field Stop
	{
		bool b = src.getStop();
		if (b)
			buffer.appendf("<Stop>1</Stop>");
	}
	// field BackupRename
	{
		bool b = src.getBackupRename();
		if (b)
			buffer.appendf("<BackupRename>1</BackupRename>");
	}
	// field BackupCopy
	{
		bool b = src.getBackupCopy();
		if (b)
			buffer.appendf("<BackupCopy>1</BackupCopy>");
	}
	// field ArchiveEnv
	{
		bool b = src.getArchiveEnv();
		if (b)
			buffer.appendf("<ArchiveEnv>1</ArchiveEnv>");
	}
	// field Log
	{
		bool b = src.getLog();
		if (b)
			buffer.appendf("<Log>1</Log>");
	}
	// field ArchivePath
	{
		const char* s = src.getArchivePath();
		if (s && *s)
		{
			buffer.append("<ArchivePath>");
			encodeUtf8XML(s,buffer);
			buffer.append("</ArchivePath>");
		}
	}
	if (keepRootTag)
		buffer.append("</DeployOptions>");
}

bool CDeployOptions::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_Compare.unmarshall(rpc_request, "Compare", basepath);
	hasValue |= m_ConfigFiles.unmarshall(rpc_request, "ConfigFiles", basepath);
	hasValue |= m_BuildFiles.unmarshall(rpc_request, "BuildFiles", basepath);
	hasValue |= m_UpgradeBuildFiles.unmarshall(rpc_request, "UpgradeBuildFiles", basepath);
	hasValue |= m_Start.unmarshall(rpc_request, "Start", basepath);
	hasValue |= m_Stop.unmarshall(rpc_request, "Stop", basepath);
	hasValue |= m_BackupRename.unmarshall(rpc_request, "BackupRename", basepath);
	hasValue |= m_BackupCopy.unmarshall(rpc_request, "BackupCopy", basepath);
	hasValue |= m_ArchiveEnv.unmarshall(rpc_request, "ArchiveEnv", basepath);
	hasValue |= m_Log.unmarshall(rpc_request, "Log", basepath);
	hasValue |= m_ArchivePath.unmarshall(rpc_request, "ArchivePath", basepath);
	return hasValue;
}

bool CDeployOptions::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Compare.unmarshall(ctx, soapval, "Compare");
	hasValue |= m_ConfigFiles.unmarshall(ctx, soapval, "ConfigFiles");
	hasValue |= m_BuildFiles.unmarshall(ctx, soapval, "BuildFiles");
	hasValue |= m_UpgradeBuildFiles.unmarshall(ctx, soapval, "UpgradeBuildFiles");
	hasValue |= m_Start.unmarshall(ctx, soapval, "Start");
	hasValue |= m_Stop.unmarshall(ctx, soapval, "Stop");
	hasValue |= m_BackupRename.unmarshall(ctx, soapval, "BackupRename");
	hasValue |= m_BackupCopy.unmarshall(ctx, soapval, "BackupCopy");
	hasValue |= m_ArchiveEnv.unmarshall(ctx, soapval, "ArchiveEnv");
	hasValue |= m_Log.unmarshall(ctx, soapval, "Log");
	hasValue |= m_ArchivePath.unmarshall(ctx, soapval, "ArchivePath");
	return hasValue;
}

bool CDeployOptions::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Compare.unmarshall(ctx, params, attachments, "Compare", basepath);
	hasValue |= m_ConfigFiles.unmarshall(ctx, params, attachments, "ConfigFiles", basepath);
	hasValue |= m_BuildFiles.unmarshall(ctx, params, attachments, "BuildFiles", basepath);
	hasValue |= m_UpgradeBuildFiles.unmarshall(ctx, params, attachments, "UpgradeBuildFiles", basepath);
	hasValue |= m_Start.unmarshall(ctx, params, attachments, "Start", basepath);
	hasValue |= m_Stop.unmarshall(ctx, params, attachments, "Stop", basepath);
	hasValue |= m_BackupRename.unmarshall(ctx, params, attachments, "BackupRename", basepath);
	hasValue |= m_BackupCopy.unmarshall(ctx, params, attachments, "BackupCopy", basepath);
	hasValue |= m_ArchiveEnv.unmarshall(ctx, params, attachments, "ArchiveEnv", basepath);
	hasValue |= m_Log.unmarshall(ctx, params, attachments, "Log", basepath);
	hasValue |= m_ArchivePath.unmarshall(ctx, params, attachments, "ArchivePath", basepath);
	return hasValue;
}

bool CDeployOptions::getCompare() { return m_Compare;}
bool CDeployOptions::getConfigFiles() { return m_ConfigFiles;}
bool CDeployOptions::getBuildFiles() { return m_BuildFiles;}
bool CDeployOptions::getUpgradeBuildFiles() { return m_UpgradeBuildFiles;}
bool CDeployOptions::getStart() { return m_Start;}
bool CDeployOptions::getStop() { return m_Stop;}
bool CDeployOptions::getBackupRename() { return m_BackupRename;}
bool CDeployOptions::getBackupCopy() { return m_BackupCopy;}
bool CDeployOptions::getArchiveEnv() { return m_ArchiveEnv;}
bool CDeployOptions::getLog() { return m_Log;}
const char * CDeployOptions::getArchivePath() { return m_ArchivePath.query();}
void CDeployOptions::setCompare(bool val){ m_Compare=val; }
void CDeployOptions::setConfigFiles(bool val){ m_ConfigFiles=val; }
void CDeployOptions::setBuildFiles(bool val){ m_BuildFiles=val; }
void CDeployOptions::setUpgradeBuildFiles(bool val){ m_UpgradeBuildFiles=val; }
void CDeployOptions::setStart(bool val){ m_Start=val; }
void CDeployOptions::setStop(bool val){ m_Stop=val; }
void CDeployOptions::setBackupRename(bool val){ m_BackupRename=val; }
void CDeployOptions::setBackupCopy(bool val){ m_BackupCopy=val; }
void CDeployOptions::setArchiveEnv(bool val){ m_ArchiveEnv=val; }
void CDeployOptions::setLog(bool val){ m_Log=val; }
void CDeployOptions::setArchivePath(const char * val){ m_ArchivePath.set(val); }
extern "C"  IEspDeployOptions *createDeployOptions(const char *serv, const char *msgname){return ((IEspDeployOptions *)new CDeployOptions(serv /*, msgname*/));}
extern "C"  IClientDeployOptions *createClientDeployOptions(const char *serv, const char *msgname){return ((IClientDeployOptions *)new CDeployOptions(serv /*, msgname*/));}

//=======================================================
// class CWsDeployReqInfo Implementation
//=======================================================

CWsDeployReqInfo::CWsDeployReqInfo(const char *serviceName, IRpcMessageBinding *init)
	: m_FileName(nilIgnore),m_UserId(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("WsDeployReqInfo");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CWsDeployReqInfo::CWsDeployReqInfo(const char *serviceName, const char *bc)
	: m_FileName(nilIgnore),m_UserId(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("WsDeployReqInfo");
}

StringBuffer &CWsDeployReqInfo::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:complexType name=\"%s\">\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"FileName\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"UserId\" type=\"xsd:string\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType>\n");
		}
	}
	return schema;
}

void CWsDeployReqInfo::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CWsDeployReqInfo::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CWsDeployReqInfo::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("FileName");
	form.appendf("  <tr><td><b>FileName: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("UserId");
	form.appendf("  <tr><td><b>UserId: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CWsDeployReqInfo::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CWsDeployReqInfo::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_FileName.marshall(rpc_resp, "FileName", "", "", "");
	m_UserId.marshall(rpc_resp, "UserId", "", "", "");
}


void CWsDeployReqInfo::copy(CWsDeployReqInfo &from)
{
	m_FileName.copy(from.m_FileName);
	m_UserId.copy(from.m_UserId);
}


void CWsDeployReqInfo::copy(IConstWsDeployReqInfo &ifrom)
{
	setFileName(ifrom.getFileName());
	setUserId(ifrom.getUserId());
}


void CWsDeployReqInfo::getAttributes(IProperties &attributes)
{
}


void CWsDeployReqInfo::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_FileName.toStr(ctx, buffer, "FileName", "", true, "", "");
	m_UserId.toStr(ctx, buffer, "UserId", "", true, "", "");
}


void CWsDeployReqInfo::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CWsDeployReqInfo::serializer(IEspContext* ctx, IConstWsDeployReqInfo &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<WsDeployReqInfo>");
	// field FileName
	{
		const char* s = src.getFileName();
		if (s && *s)
		{
			buffer.append("<FileName>");
			encodeUtf8XML(s,buffer);
			buffer.append("</FileName>");
		}
	}
	// field UserId
	{
		const char* s = src.getUserId();
		if (s && *s)
		{
			buffer.append("<UserId>");
			encodeUtf8XML(s,buffer);
			buffer.append("</UserId>");
		}
	}
	if (keepRootTag)
		buffer.append("</WsDeployReqInfo>");
}

bool CWsDeployReqInfo::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_FileName.unmarshall(rpc_request, "FileName", basepath);
	hasValue |= m_UserId.unmarshall(rpc_request, "UserId", basepath);
	return hasValue;
}

bool CWsDeployReqInfo::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_FileName.unmarshall(ctx, soapval, "FileName");
	hasValue |= m_UserId.unmarshall(ctx, soapval, "UserId");
	return hasValue;
}

bool CWsDeployReqInfo::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_FileName.unmarshall(ctx, params, attachments, "FileName", basepath);
	hasValue |= m_UserId.unmarshall(ctx, params, attachments, "UserId", basepath);
	return hasValue;
}

const char * CWsDeployReqInfo::getFileName() { return m_FileName.query();}
const char * CWsDeployReqInfo::getUserId() { return m_UserId.query();}
void CWsDeployReqInfo::setFileName(const char * val){ m_FileName.set(val); }
void CWsDeployReqInfo::setUserId(const char * val){ m_UserId.set(val); }
extern "C"  IEspWsDeployReqInfo *createWsDeployReqInfo(const char *serv, const char *msgname){return ((IEspWsDeployReqInfo *)new CWsDeployReqInfo(serv /*, msgname*/));}
extern "C"  IClientWsDeployReqInfo *createClientWsDeployReqInfo(const char *serv, const char *msgname){return ((IClientWsDeployReqInfo *)new CWsDeployReqInfo(serv /*, msgname*/));}

//=======================================================
// class CDeployInfo Implementation
//=======================================================

CDeployInfo::CDeployInfo(const char *serviceName, IRpcMessageBinding *init)
	: m_Components(nilIgnore),m_Options(serviceName, nilIgnore),m_Status(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("DeployInfo");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CDeployInfo::CDeployInfo(const char *serviceName, const char *bc)
	: m_Components(nilIgnore),m_Options(serviceName, nilIgnore),m_Status(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("DeployInfo");
}

StringBuffer &CDeployInfo::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:complexType name=\"%s\">\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Components\" type=\"tns:ArrayOfComponent\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Options\" type=\"tns:DeployOptions\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Status\" type=\"xsd:string\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType>\n");
		}
	}
	if (!(flags & 0x10)  || (flags & 0x100))
	{
		CComponent::getXsdDefinition(context, request, schema, added);
		CDeployOptions::getXsdDefinition(context, request, schema, added);
	}
	if (added.getValue("Component") && added.getValue("ArrayOfComponent")==NULL) {
		schema.append("<xsd:complexType name=\"ArrayOfComponent\">\n");
		schema.append("<xsd:sequence>\n");
		schema.append("<xsd:element minOccurs=\"0\" maxOccurs=\"unbounded\" name=\"Component\" type=\"tns:Component\"/>\n");
		schema.append("</xsd:sequence>\n");
		schema.append("</xsd:complexType>\n");
		added.setValue("ArrayOfComponent",1);
	}
	return schema;
}

void CDeployInfo::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CDeployInfo::getMapInfo(IMapInfo& info, BoolHash& added)
{
	if (!added.getValue("Component"))
	{
		added.setValue("Component",1);
		CComponent::getMapInfo(info,added);
	}
	if (!added.getValue("DeployOptions"))
	{
		added.setValue("DeployOptions",1);
		CDeployOptions::getMapInfo(info,added);
	}
}

StringBuffer &CDeployInfo::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Components");
	form.appendf("<tr><td><b>Components: </b></td><td>");
	form.appendf("<table><tr><td><textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea></td>", extfix.str());
	form.append("</tr></table>");
	form.append("</td></tr>");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Options");
	form.append("<tr>").append("<td><b>Options: </b></td><td><hr/>");
	CDeployOptions::getHtmlForm(context, request, serv, method, form, false, extfix.str());
	form.append("<hr/></td></tr>");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Status");
	form.appendf("  <tr><td><b>Status: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CDeployInfo::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CDeployInfo::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_Components.marshall(rpc_resp, "Components", "Component");
	m_Options.marshall(rpc_resp, "Options", "", "", "");
	m_Status.marshall(rpc_resp, "Status", "", "", "");
}


void CDeployInfo::copy(CDeployInfo &from)
{
	m_Components.copy(from.m_Components);
	m_Options.copy(from.m_Options);
	m_Status.copy(from.m_Status);
}


void CDeployInfo::copy(IConstDeployInfo &ifrom)
{
	setComponents(ifrom.getComponents());
	setOptions(ifrom.getOptions());
	setStatus(ifrom.getStatus());
}


void CDeployInfo::getAttributes(IProperties &attributes)
{
}


void CDeployInfo::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_Components.toStr(ctx, buffer, "Components", "Component");
	m_Options.toStr(ctx, buffer, "Options", "", false, "", "");
	m_Status.toStr(ctx, buffer, "Status", "", true, "", "");
}


void CDeployInfo::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CDeployInfo::serializer(IEspContext* ctx, IConstDeployInfo &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<DeployInfo>");
	// field Components
	{
		IArrayOf<IConstComponent>& v = src.getComponents();
		int size = v.length();
		if (size>0)
			buffer.append("<Components>");
		for (int i=0;i<size;i++)
		{
			buffer.append("<Item>");
			CComponent::serializer(ctx,v.item(i),buffer,false);
			buffer.append("</Item>");
		}
		if (size>0)
			buffer.append("</Components>");
	}
	// field Options
	{
		StringBuffer tmp;
		CDeployOptions::serializer(ctx,src.getOptions(), tmp, false);
		if (tmp.length()>0)
			buffer.appendf("<Options>%s</Options>",tmp.str());
	}
	// field Status
	{
		const char* s = src.getStatus();
		if (s && *s)
		{
			buffer.append("<Status>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Status>");
		}
	}
	if (keepRootTag)
		buffer.append("</DeployInfo>");
}

bool CDeployInfo::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_Components.unmarshall(rpc_request, "Components", basepath);
	hasValue |= m_Options.unmarshall(rpc_request, "Options", basepath);
	hasValue |= m_Status.unmarshall(rpc_request, "Status", basepath);
	return hasValue;
}

bool CDeployInfo::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Components.unmarshall(ctx, soapval, "Components");
	hasValue |= m_Options.unmarshall(ctx, soapval, "Options");
	hasValue |= m_Status.unmarshall(ctx, soapval, "Status");
	return hasValue;
}

bool CDeployInfo::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Components.unmarshall(ctx, params, attachments, "Components", basepath);
	hasValue |= m_Options.unmarshall(ctx, params, attachments, "Options", basepath);
	hasValue |= m_Status.unmarshall(ctx, params, attachments, "Status", basepath);
	return hasValue;
}

IArrayOf<IConstComponent> & CDeployInfo::getComponents() { return (IArrayOf<IConstComponent> &) m_Components; }
IConstDeployOptions & CDeployInfo::getOptions() { return (IConstDeployOptions &) m_Options.getValue();}
const char * CDeployInfo::getStatus() { return m_Status.query();}
void CDeployInfo::setComponents(IArrayOf<IEspComponent> &val)
{
	m_Components->kill();
	IArrayOf<IConstComponent> &target = m_Components.getValue();
	ForEachItemIn(idx, val)
	{
		IEspComponent &item = (val).item(idx);
		item.Link();
		target.append(item);
	}
}
void CDeployInfo::setComponents(IArrayOf<IConstComponent> &val)
{
	m_Components->kill();
	IArrayOf<IConstComponent> &target = m_Components.getValue();
	ForEachItemIn(idx, val)
	{
		IConstComponent &item = val.item(idx);
		item.Link();
		target.append(item);
	}
}
IEspDeployOptions & CDeployInfo::updateOptions(){ return (IEspDeployOptions &) m_Options.getValue(); }
void CDeployInfo::setOptions(IConstDeployOptions &ifrom){ m_Options.copy(ifrom); }
void CDeployInfo::setStatus(const char * val){ m_Status.set(val); }
extern "C"  IEspDeployInfo *createDeployInfo(const char *serv, const char *msgname){return ((IEspDeployInfo *)new CDeployInfo(serv /*, msgname*/));}
extern "C"  IClientDeployInfo *createClientDeployInfo(const char *serv, const char *msgname){return ((IClientDeployInfo *)new CDeployInfo(serv /*, msgname*/));}

//=======================================================
// class CDaliInfo Implementation
//=======================================================

CDaliInfo::CDaliInfo(const char *serviceName, IRpcMessageBinding *init)
	: m_DaliIp(nilIgnore),m_DaliName(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("DaliInfo");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CDaliInfo::CDaliInfo(const char *serviceName, const char *bc)
	: m_DaliIp(nilIgnore),m_DaliName(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("DaliInfo");
}

StringBuffer &CDaliInfo::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:complexType name=\"%s\">\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"DaliIp\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"DaliName\" type=\"xsd:string\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType>\n");
		}
	}
	return schema;
}

void CDaliInfo::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CDaliInfo::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CDaliInfo::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("DaliIp");
	form.appendf("  <tr><td><b>DaliIp: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("DaliName");
	form.appendf("  <tr><td><b>DaliName: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CDaliInfo::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CDaliInfo::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_DaliIp.marshall(rpc_resp, "DaliIp", "", "", "");
	m_DaliName.marshall(rpc_resp, "DaliName", "", "", "");
}


void CDaliInfo::copy(CDaliInfo &from)
{
	m_DaliIp.copy(from.m_DaliIp);
	m_DaliName.copy(from.m_DaliName);
}


void CDaliInfo::copy(IConstDaliInfo &ifrom)
{
	setDaliIp(ifrom.getDaliIp());
	setDaliName(ifrom.getDaliName());
}


void CDaliInfo::getAttributes(IProperties &attributes)
{
}


void CDaliInfo::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_DaliIp.toStr(ctx, buffer, "DaliIp", "", true, "", "");
	m_DaliName.toStr(ctx, buffer, "DaliName", "", true, "", "");
}


void CDaliInfo::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CDaliInfo::serializer(IEspContext* ctx, IConstDaliInfo &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<DaliInfo>");
	// field DaliIp
	{
		const char* s = src.getDaliIp();
		if (s && *s)
		{
			buffer.append("<DaliIp>");
			encodeUtf8XML(s,buffer);
			buffer.append("</DaliIp>");
		}
	}
	// field DaliName
	{
		const char* s = src.getDaliName();
		if (s && *s)
		{
			buffer.append("<DaliName>");
			encodeUtf8XML(s,buffer);
			buffer.append("</DaliName>");
		}
	}
	if (keepRootTag)
		buffer.append("</DaliInfo>");
}

bool CDaliInfo::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_DaliIp.unmarshall(rpc_request, "DaliIp", basepath);
	hasValue |= m_DaliName.unmarshall(rpc_request, "DaliName", basepath);
	return hasValue;
}

bool CDaliInfo::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_DaliIp.unmarshall(ctx, soapval, "DaliIp");
	hasValue |= m_DaliName.unmarshall(ctx, soapval, "DaliName");
	return hasValue;
}

bool CDaliInfo::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_DaliIp.unmarshall(ctx, params, attachments, "DaliIp", basepath);
	hasValue |= m_DaliName.unmarshall(ctx, params, attachments, "DaliName", basepath);
	return hasValue;
}

const char * CDaliInfo::getDaliIp() { return m_DaliIp.query();}
const char * CDaliInfo::getDaliName() { return m_DaliName.query();}
void CDaliInfo::setDaliIp(const char * val){ m_DaliIp.set(val); }
void CDaliInfo::setDaliName(const char * val){ m_DaliName.set(val); }
extern "C"  IEspDaliInfo *createDaliInfo(const char *serv, const char *msgname){return ((IEspDaliInfo *)new CDaliInfo(serv /*, msgname*/));}
extern "C"  IClientDaliInfo *createClientDaliInfo(const char *serv, const char *msgname){return ((IClientDaliInfo *)new CDaliInfo(serv /*, msgname*/));}

//=======================================================
// class CEmptyRequest Implementation
//=======================================================

CEmptyRequest::CEmptyRequest(const char *serviceName, IRpcMessageBinding *init)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("EmptyRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CEmptyRequest::CEmptyRequest(const char *serviceName, const char *bc)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("EmptyRequest");
}

CEmptyRequest::CEmptyRequest(const char *serviceName, IRpcMessage* rpcmsg)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("EmptyRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CEmptyRequest::CEmptyRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("EmptyRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CEmptyRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType><xsd:all/></xsd:complexType></xsd:element>\n", msgTypeName);
		}
	}
	return schema;
}

void CEmptyRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CEmptyRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CEmptyRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CEmptyRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CEmptyRequest::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

}


void CEmptyRequest::copy(CEmptyRequest &from)
{
}


void CEmptyRequest::copy(IConstEmptyRequest &ifrom)
{
}


void CEmptyRequest::getAttributes(IProperties &attributes)
{
}


void CEmptyRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
}


void CEmptyRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CEmptyRequest::serializer(IEspContext* ctx, IConstEmptyRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<EmptyRequest>");
	if (keepRootTag)
		buffer.append("</EmptyRequest>");
}

bool CEmptyRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	return hasValue;
}

bool CEmptyRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	return hasValue;
}

bool CEmptyRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	return hasValue;
}

extern "C"  IEspEmptyRequest *createEmptyRequest(const char *serv){return ((IEspEmptyRequest *)new CEmptyRequest(serv));}
extern "C"  IClientEmptyRequest *createClientEmptyRequest(const char *serv){return ((IClientEmptyRequest *)new CEmptyRequest(serv));}

//=======================================================
// class CInitResponse Implementation
//=======================================================

CInitResponse::CInitResponse(const char *serviceName, IRpcMessageBinding *init)
	: m_Component(nilIgnore),m_Command(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("InitResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CInitResponse::CInitResponse(const char *serviceName, const char *bc)
	: m_Component(nilIgnore),m_Command(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("InitResponse");
}

CInitResponse::CInitResponse(const char *serviceName, IRpcMessage* rpcmsg)
	: m_Component(nilIgnore),m_Command(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("InitResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CInitResponse::CInitResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_Component(nilIgnore),m_Command(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("InitResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CInitResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		schema.append("<xsd:element name=\"Exceptions\" type=\"tns:ArrayOfEspException\" minOccurs=\"0\" maxOccurs=\"1\"/>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Component\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Command\" type=\"xsd:string\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CInitResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CInitResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CInitResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Component");
	form.appendf("  <tr><td><b>Component: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Command");
	form.appendf("  <tr><td><b>Command: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CInitResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CInitResponse::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	rpc_resp.setEncodeXml(false);
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
		m_Component.marshall(rpc_resp, "Component", "", "", "");
		m_Command.marshall(rpc_resp, "Command", "", "", "");
	}
}


void CInitResponse::copy(CInitResponse &from)
{
	m_Component.copy(from.m_Component);
	m_Command.copy(from.m_Command);
}


void CInitResponse::copy(IConstInitResponse &ifrom)
{
	setComponent(ifrom.getComponent());
	setCommand(ifrom.getCommand());
}


void CInitResponse::getAttributes(IProperties &attributes)
{
}


void CInitResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
		m_Component.toStr(ctx, buffer, "Component", "", false, "", "");
		m_Command.toStr(ctx, buffer, "Command", "", false, "", "");
	}
}


void CInitResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CInitResponse::serializer(IEspContext* ctx, IConstInitResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<InitResponse>");
	// field Component
	{
		const char* s = src.getComponent();
		if (s && *s)
		buffer.appendf("<Component>%s</Component>",s);
	}
	// field Command
	{
		const char* s = src.getCommand();
		if (s && *s)
		buffer.appendf("<Command>%s</Command>",s);
	}
	if (keepRootTag)
		buffer.append("</InitResponse>");
}

bool CInitResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
		hasValue |= m_Component.unmarshall(rpc_request, "Component", basepath);
		hasValue |= m_Command.unmarshall(rpc_request, "Command", basepath);
	}
	return hasValue;
}

bool CInitResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Component.unmarshall(ctx, soapval, "Component");
	hasValue |= m_Command.unmarshall(ctx, soapval, "Command");
	return hasValue;
}

bool CInitResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Component.unmarshall(ctx, params, attachments, "Component", basepath);
	hasValue |= m_Command.unmarshall(ctx, params, attachments, "Command", basepath);
	return hasValue;
}

const char * CInitResponse::getComponent() { return m_Component.query();}
const char * CInitResponse::getCommand() { return m_Command.query();}
void CInitResponse::setComponent(const char * val){ m_Component.set(val); }
void CInitResponse::setCommand(const char * val){ m_Command.set(val); }
extern "C"  IEspInitResponse *createInitResponse(const char *serv){return ((IEspInitResponse *)new CInitResponse(serv));}
extern "C"  IClientInitResponse *createClientInitResponse(const char *serv){return ((IClientInitResponse *)new CInitResponse(serv));}

//=======================================================
// class CDeployRequest Implementation
//=======================================================

CDeployRequest::CDeployRequest(const char *serviceName, IRpcMessageBinding *init)
	: m_Deploy(serviceName, nilIgnore),m_ReqInfo(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("DeployRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CDeployRequest::CDeployRequest(const char *serviceName, const char *bc)
	: m_Deploy(serviceName, nilIgnore),m_ReqInfo(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("DeployRequest");
}

CDeployRequest::CDeployRequest(const char *serviceName, IRpcMessage* rpcmsg)
	: m_Deploy(serviceName, nilIgnore),m_ReqInfo(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("DeployRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CDeployRequest::CDeployRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_Deploy(serviceName, nilIgnore),m_ReqInfo(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("DeployRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CDeployRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Deploy\" type=\"tns:DeployInfo\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"ReqInfo\" type=\"tns:WsDeployReqInfo\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	if (!(flags & 0x10)  || (flags & 0x100))
	{
		CDeployInfo::getXsdDefinition(context, request, schema, added);
		CWsDeployReqInfo::getXsdDefinition(context, request, schema, added);
	}
	return schema;
}

void CDeployRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CDeployRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
	if (!added.getValue("DeployInfo"))
	{
		added.setValue("DeployInfo",1);
		CDeployInfo::getMapInfo(info,added);
	}
	if (!added.getValue("WsDeployReqInfo"))
	{
		added.setValue("WsDeployReqInfo",1);
		CWsDeployReqInfo::getMapInfo(info,added);
	}
}

StringBuffer &CDeployRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Deploy");
	form.append("<tr>").append("<td><b>Deploy: </b></td><td><hr/>");
	CDeployInfo::getHtmlForm(context, request, serv, method, form, false, extfix.str());
	form.append("<hr/></td></tr>");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("ReqInfo");
	form.append("<tr>").append("<td><b>ReqInfo: </b></td><td><hr/>");
	CWsDeployReqInfo::getHtmlForm(context, request, serv, method, form, false, extfix.str());
	form.append("<hr/></td></tr>");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CDeployRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CDeployRequest::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_Deploy.marshall(rpc_resp, "Deploy", "", "", "");
	m_ReqInfo.marshall(rpc_resp, "ReqInfo", "", "", "");
}


void CDeployRequest::copy(CDeployRequest &from)
{
	m_Deploy.copy(from.m_Deploy);
	m_ReqInfo.copy(from.m_ReqInfo);
}


void CDeployRequest::copy(IConstDeployRequest &ifrom)
{
	setDeploy(ifrom.getDeploy());
	setReqInfo(ifrom.getReqInfo());
}


void CDeployRequest::getAttributes(IProperties &attributes)
{
}


void CDeployRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_Deploy.toStr(ctx, buffer, "Deploy", "", false, "", "");
	m_ReqInfo.toStr(ctx, buffer, "ReqInfo", "", false, "", "");
}


void CDeployRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CDeployRequest::serializer(IEspContext* ctx, IConstDeployRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<DeployRequest>");
	// field Deploy
	{
		StringBuffer tmp;
		CDeployInfo::serializer(ctx,src.getDeploy(), tmp, false);
		if (tmp.length()>0)
			buffer.appendf("<Deploy>%s</Deploy>",tmp.str());
	}
	// field ReqInfo
	{
		StringBuffer tmp;
		CWsDeployReqInfo::serializer(ctx,src.getReqInfo(), tmp, false);
		if (tmp.length()>0)
			buffer.appendf("<ReqInfo>%s</ReqInfo>",tmp.str());
	}
	if (keepRootTag)
		buffer.append("</DeployRequest>");
}

bool CDeployRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_Deploy.unmarshall(rpc_request, "Deploy", basepath);
	hasValue |= m_ReqInfo.unmarshall(rpc_request, "ReqInfo", basepath);
	return hasValue;
}

bool CDeployRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Deploy.unmarshall(ctx, soapval, "Deploy");
	hasValue |= m_ReqInfo.unmarshall(ctx, soapval, "ReqInfo");
	return hasValue;
}

bool CDeployRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Deploy.unmarshall(ctx, params, attachments, "Deploy", basepath);
	hasValue |= m_ReqInfo.unmarshall(ctx, params, attachments, "ReqInfo", basepath);
	return hasValue;
}

IConstDeployInfo & CDeployRequest::getDeploy() { return (IConstDeployInfo &) m_Deploy.getValue();}
IConstWsDeployReqInfo & CDeployRequest::getReqInfo() { return (IConstWsDeployReqInfo &) m_ReqInfo.getValue();}
IEspDeployInfo & CDeployRequest::updateDeploy(){ return (IEspDeployInfo &) m_Deploy.getValue(); }
void CDeployRequest::setDeploy(IConstDeployInfo &ifrom){ m_Deploy.copy(ifrom); }
IEspWsDeployReqInfo & CDeployRequest::updateReqInfo(){ return (IEspWsDeployReqInfo &) m_ReqInfo.getValue(); }
void CDeployRequest::setReqInfo(IConstWsDeployReqInfo &ifrom){ m_ReqInfo.copy(ifrom); }
extern "C"  IEspDeployRequest *createDeployRequest(const char *serv){return ((IEspDeployRequest *)new CDeployRequest(serv));}
extern "C"  IClientDeployRequest *createClientDeployRequest(const char *serv){return ((IClientDeployRequest *)new CDeployRequest(serv));}

//=======================================================
// class CDeployResponse Implementation
//=======================================================

CDeployResponse::CDeployResponse(const char *serviceName, IRpcMessageBinding *init)
	: m_Component(nilIgnore),m_Command(nilIgnore),m_Deploy(nilIgnore),m_Status(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("DeployResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CDeployResponse::CDeployResponse(const char *serviceName, const char *bc)
	: m_Component(nilIgnore),m_Command(nilIgnore),m_Deploy(nilIgnore),m_Status(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("DeployResponse");
}

CDeployResponse::CDeployResponse(const char *serviceName, IRpcMessage* rpcmsg)
	: m_Component(nilIgnore),m_Command(nilIgnore),m_Deploy(nilIgnore),m_Status(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("DeployResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CDeployResponse::CDeployResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_Component(nilIgnore),m_Command(nilIgnore),m_Deploy(nilIgnore),m_Status(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("DeployResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CDeployResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		schema.append("<xsd:element name=\"Exceptions\" type=\"tns:ArrayOfEspException\" minOccurs=\"0\" maxOccurs=\"1\"/>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Component\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Command\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Deploy\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Status\" type=\"xsd:string\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CDeployResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CDeployResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CDeployResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Component");
	form.appendf("  <tr><td><b>Component: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Command");
	form.appendf("  <tr><td><b>Command: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Deploy");
	form.appendf("  <tr><td><b>Deploy: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Status");
	form.appendf("  <tr><td><b>Status: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CDeployResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CDeployResponse::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	rpc_resp.setEncodeXml(false);
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
		m_Component.marshall(rpc_resp, "Component", "", "", "");
		m_Command.marshall(rpc_resp, "Command", "", "", "");
		m_Deploy.marshall(rpc_resp, "Deploy", "", "", "");
		m_Status.marshall(rpc_resp, "Status", "", "", "");
	}
}


void CDeployResponse::copy(CDeployResponse &from)
{
	m_Component.copy(from.m_Component);
	m_Command.copy(from.m_Command);
	m_Deploy.copy(from.m_Deploy);
	m_Status.copy(from.m_Status);
}


void CDeployResponse::copy(IConstDeployResponse &ifrom)
{
	setComponent(ifrom.getComponent());
	setCommand(ifrom.getCommand());
	setDeploy(ifrom.getDeploy());
	setStatus(ifrom.getStatus());
}


void CDeployResponse::getAttributes(IProperties &attributes)
{
}


void CDeployResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
		m_Component.toStr(ctx, buffer, "Component", "", false, "", "");
		m_Command.toStr(ctx, buffer, "Command", "", false, "", "");
		m_Deploy.toStr(ctx, buffer, "Deploy", "", false, "", "");
		m_Status.toStr(ctx, buffer, "Status", "", false, "", "");
	}
}


void CDeployResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CDeployResponse::serializer(IEspContext* ctx, IConstDeployResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<DeployResponse>");
	// field Component
	{
		const char* s = src.getComponent();
		if (s && *s)
		buffer.appendf("<Component>%s</Component>",s);
	}
	// field Command
	{
		const char* s = src.getCommand();
		if (s && *s)
		buffer.appendf("<Command>%s</Command>",s);
	}
	// field Deploy
	{
		const char* s = src.getDeploy();
		if (s && *s)
		buffer.appendf("<Deploy>%s</Deploy>",s);
	}
	// field Status
	{
		const char* s = src.getStatus();
		if (s && *s)
		buffer.appendf("<Status>%s</Status>",s);
	}
	if (keepRootTag)
		buffer.append("</DeployResponse>");
}

bool CDeployResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
		hasValue |= m_Component.unmarshall(rpc_request, "Component", basepath);
		hasValue |= m_Command.unmarshall(rpc_request, "Command", basepath);
		hasValue |= m_Deploy.unmarshall(rpc_request, "Deploy", basepath);
		hasValue |= m_Status.unmarshall(rpc_request, "Status", basepath);
	}
	return hasValue;
}

bool CDeployResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Component.unmarshall(ctx, soapval, "Component");
	hasValue |= m_Command.unmarshall(ctx, soapval, "Command");
	hasValue |= m_Deploy.unmarshall(ctx, soapval, "Deploy");
	hasValue |= m_Status.unmarshall(ctx, soapval, "Status");
	return hasValue;
}

bool CDeployResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Component.unmarshall(ctx, params, attachments, "Component", basepath);
	hasValue |= m_Command.unmarshall(ctx, params, attachments, "Command", basepath);
	hasValue |= m_Deploy.unmarshall(ctx, params, attachments, "Deploy", basepath);
	hasValue |= m_Status.unmarshall(ctx, params, attachments, "Status", basepath);
	return hasValue;
}

const char * CDeployResponse::getComponent() { return m_Component.query();}
const char * CDeployResponse::getCommand() { return m_Command.query();}
const char * CDeployResponse::getDeploy() { return m_Deploy.query();}
const char * CDeployResponse::getStatus() { return m_Status.query();}
void CDeployResponse::setComponent(const char * val){ m_Component.set(val); }
void CDeployResponse::setCommand(const char * val){ m_Command.set(val); }
void CDeployResponse::setDeploy(const char * val){ m_Deploy.set(val); }
void CDeployResponse::setStatus(const char * val){ m_Status.set(val); }
extern "C"  IEspDeployResponse *createDeployResponse(const char *serv){return ((IEspDeployResponse *)new CDeployResponse(serv));}
extern "C"  IClientDeployResponse *createClientDeployResponse(const char *serv){return ((IClientDeployResponse *)new CDeployResponse(serv));}

//=======================================================
// class CGraphResponse Implementation
//=======================================================

CGraphResponse::CGraphResponse(const char *serviceName, IRpcMessageBinding *init)
	: m_GraphContainer(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GraphResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CGraphResponse::CGraphResponse(const char *serviceName, const char *bc)
	: m_GraphContainer(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GraphResponse");
}

CGraphResponse::CGraphResponse(const char *serviceName, IRpcMessage* rpcmsg)
	: m_GraphContainer(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GraphResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CGraphResponse::CGraphResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_GraphContainer(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GraphResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CGraphResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		schema.append("<xsd:element name=\"Exceptions\" type=\"tns:ArrayOfEspException\" minOccurs=\"0\" maxOccurs=\"1\"/>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"GraphContainer\" type=\"xsd:string\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CGraphResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CGraphResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CGraphResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("GraphContainer");
	form.appendf("  <tr><td><b>GraphContainer: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CGraphResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CGraphResponse::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	rpc_resp.setEncodeXml(false);
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
		m_GraphContainer.marshall(rpc_resp, "GraphContainer", "", "", "");
	}
}


void CGraphResponse::copy(CGraphResponse &from)
{
	m_GraphContainer.copy(from.m_GraphContainer);
}


void CGraphResponse::copy(IConstGraphResponse &ifrom)
{
	setGraphContainer(ifrom.getGraphContainer());
}


void CGraphResponse::getAttributes(IProperties &attributes)
{
}


void CGraphResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
		m_GraphContainer.toStr(ctx, buffer, "GraphContainer", "", false, "", "");
	}
}


void CGraphResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CGraphResponse::serializer(IEspContext* ctx, IConstGraphResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<GraphResponse>");
	// field GraphContainer
	{
		const char* s = src.getGraphContainer();
		if (s && *s)
		buffer.appendf("<GraphContainer>%s</GraphContainer>",s);
	}
	if (keepRootTag)
		buffer.append("</GraphResponse>");
}

bool CGraphResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
		hasValue |= m_GraphContainer.unmarshall(rpc_request, "GraphContainer", basepath);
	}
	return hasValue;
}

bool CGraphResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_GraphContainer.unmarshall(ctx, soapval, "GraphContainer");
	return hasValue;
}

bool CGraphResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_GraphContainer.unmarshall(ctx, params, attachments, "GraphContainer", basepath);
	return hasValue;
}

const char * CGraphResponse::getGraphContainer() { return m_GraphContainer.query();}
void CGraphResponse::setGraphContainer(const char * val){ m_GraphContainer.set(val); }
extern "C"  IEspGraphResponse *createGraphResponse(const char *serv){return ((IEspGraphResponse *)new CGraphResponse(serv));}
extern "C"  IClientGraphResponse *createClientGraphResponse(const char *serv){return ((IClientGraphResponse *)new CGraphResponse(serv));}

//=======================================================
// class CNavMenuEventRequest Implementation
//=======================================================

CNavMenuEventRequest::CNavMenuEventRequest(const char *serviceName, IRpcMessageBinding *init)
	: m_Cmd(nilIgnore),m_XmlArgs(nilIgnore),m_ReqInfo(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("NavMenuEventRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CNavMenuEventRequest::CNavMenuEventRequest(const char *serviceName, const char *bc)
	: m_Cmd(nilIgnore),m_XmlArgs(nilIgnore),m_ReqInfo(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("NavMenuEventRequest");
}

CNavMenuEventRequest::CNavMenuEventRequest(const char *serviceName, IRpcMessage* rpcmsg)
	: m_Cmd(nilIgnore),m_XmlArgs(nilIgnore),m_ReqInfo(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("NavMenuEventRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CNavMenuEventRequest::CNavMenuEventRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_Cmd(nilIgnore),m_XmlArgs(nilIgnore),m_ReqInfo(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("NavMenuEventRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CNavMenuEventRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Cmd\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"XmlArgs\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"ReqInfo\" type=\"tns:WsDeployReqInfo\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	if (!(flags & 0x10)  || (flags & 0x100))
	{
		CWsDeployReqInfo::getXsdDefinition(context, request, schema, added);
	}
	return schema;
}

void CNavMenuEventRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CNavMenuEventRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
	if (!added.getValue("WsDeployReqInfo"))
	{
		added.setValue("WsDeployReqInfo",1);
		CWsDeployReqInfo::getMapInfo(info,added);
	}
}

StringBuffer &CNavMenuEventRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Cmd");
	form.appendf("  <tr><td><b>Cmd: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("XmlArgs");
	form.appendf("  <tr><td><b>XmlArgs: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("ReqInfo");
	form.append("<tr>").append("<td><b>ReqInfo: </b></td><td><hr/>");
	CWsDeployReqInfo::getHtmlForm(context, request, serv, method, form, false, extfix.str());
	form.append("<hr/></td></tr>");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CNavMenuEventRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CNavMenuEventRequest::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_Cmd.marshall(rpc_resp, "Cmd", "", "", "");
	m_XmlArgs.marshall(rpc_resp, "XmlArgs", "", "", "");
	m_ReqInfo.marshall(rpc_resp, "ReqInfo", "", "", "");
}


void CNavMenuEventRequest::copy(CNavMenuEventRequest &from)
{
	m_Cmd.copy(from.m_Cmd);
	m_XmlArgs.copy(from.m_XmlArgs);
	m_ReqInfo.copy(from.m_ReqInfo);
}


void CNavMenuEventRequest::copy(IConstNavMenuEventRequest &ifrom)
{
	setCmd(ifrom.getCmd());
	setXmlArgs(ifrom.getXmlArgs());
	setReqInfo(ifrom.getReqInfo());
}


void CNavMenuEventRequest::getAttributes(IProperties &attributes)
{
}


void CNavMenuEventRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_Cmd.toStr(ctx, buffer, "Cmd", "", true, "", "");
	m_XmlArgs.toStr(ctx, buffer, "XmlArgs", "", true, "", "");
	m_ReqInfo.toStr(ctx, buffer, "ReqInfo", "", false, "", "");
}


void CNavMenuEventRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CNavMenuEventRequest::serializer(IEspContext* ctx, IConstNavMenuEventRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<NavMenuEventRequest>");
	// field Cmd
	{
		const char* s = src.getCmd();
		if (s && *s)
		{
			buffer.append("<Cmd>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Cmd>");
		}
	}
	// field XmlArgs
	{
		const char* s = src.getXmlArgs();
		if (s && *s)
		{
			buffer.append("<XmlArgs>");
			encodeUtf8XML(s,buffer);
			buffer.append("</XmlArgs>");
		}
	}
	// field ReqInfo
	{
		StringBuffer tmp;
		CWsDeployReqInfo::serializer(ctx,src.getReqInfo(), tmp, false);
		if (tmp.length()>0)
			buffer.appendf("<ReqInfo>%s</ReqInfo>",tmp.str());
	}
	if (keepRootTag)
		buffer.append("</NavMenuEventRequest>");
}

bool CNavMenuEventRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_Cmd.unmarshall(rpc_request, "Cmd", basepath);
	hasValue |= m_XmlArgs.unmarshall(rpc_request, "XmlArgs", basepath);
	hasValue |= m_ReqInfo.unmarshall(rpc_request, "ReqInfo", basepath);
	return hasValue;
}

bool CNavMenuEventRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Cmd.unmarshall(ctx, soapval, "Cmd");
	hasValue |= m_XmlArgs.unmarshall(ctx, soapval, "XmlArgs");
	hasValue |= m_ReqInfo.unmarshall(ctx, soapval, "ReqInfo");
	return hasValue;
}

bool CNavMenuEventRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Cmd.unmarshall(ctx, params, attachments, "Cmd", basepath);
	hasValue |= m_XmlArgs.unmarshall(ctx, params, attachments, "XmlArgs", basepath);
	hasValue |= m_ReqInfo.unmarshall(ctx, params, attachments, "ReqInfo", basepath);
	return hasValue;
}

const char * CNavMenuEventRequest::getCmd() { return m_Cmd.query();}
const char * CNavMenuEventRequest::getXmlArgs() { return m_XmlArgs.query();}
IConstWsDeployReqInfo & CNavMenuEventRequest::getReqInfo() { return (IConstWsDeployReqInfo &) m_ReqInfo.getValue();}
void CNavMenuEventRequest::setCmd(const char * val){ m_Cmd.set(val); }
void CNavMenuEventRequest::setXmlArgs(const char * val){ m_XmlArgs.set(val); }
IEspWsDeployReqInfo & CNavMenuEventRequest::updateReqInfo(){ return (IEspWsDeployReqInfo &) m_ReqInfo.getValue(); }
void CNavMenuEventRequest::setReqInfo(IConstWsDeployReqInfo &ifrom){ m_ReqInfo.copy(ifrom); }
extern "C"  IEspNavMenuEventRequest *createNavMenuEventRequest(const char *serv){return ((IEspNavMenuEventRequest *)new CNavMenuEventRequest(serv));}
extern "C"  IClientNavMenuEventRequest *createClientNavMenuEventRequest(const char *serv){return ((IClientNavMenuEventRequest *)new CNavMenuEventRequest(serv));}

//=======================================================
// class CNavMenuEventResponse Implementation
//=======================================================

CNavMenuEventResponse::CNavMenuEventResponse(const char *serviceName, IRpcMessageBinding *init)
	: m_Component(nilIgnore),m_Command(nilIgnore),m_XmlArgs(nilIgnore),m_LastSaved(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("NavMenuEventResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CNavMenuEventResponse::CNavMenuEventResponse(const char *serviceName, const char *bc)
	: m_Component(nilIgnore),m_Command(nilIgnore),m_XmlArgs(nilIgnore),m_LastSaved(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("NavMenuEventResponse");
}

CNavMenuEventResponse::CNavMenuEventResponse(const char *serviceName, IRpcMessage* rpcmsg)
	: m_Component(nilIgnore),m_Command(nilIgnore),m_XmlArgs(nilIgnore),m_LastSaved(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("NavMenuEventResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CNavMenuEventResponse::CNavMenuEventResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_Component(nilIgnore),m_Command(nilIgnore),m_XmlArgs(nilIgnore),m_LastSaved(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("NavMenuEventResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CNavMenuEventResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		schema.append("<xsd:element name=\"Exceptions\" type=\"tns:ArrayOfEspException\" minOccurs=\"0\" maxOccurs=\"1\"/>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Component\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Command\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"XmlArgs\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"LastSaved\" type=\"xsd:string\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CNavMenuEventResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CNavMenuEventResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CNavMenuEventResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Component");
	form.appendf("  <tr><td><b>Component: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Command");
	form.appendf("  <tr><td><b>Command: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("XmlArgs");
	form.appendf("  <tr><td><b>XmlArgs: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("LastSaved");
	form.appendf("  <tr><td><b>LastSaved: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CNavMenuEventResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CNavMenuEventResponse::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	rpc_resp.setEncodeXml(false);
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
		m_Component.marshall(rpc_resp, "Component", "", "", "");
		m_Command.marshall(rpc_resp, "Command", "", "", "");
		m_XmlArgs.marshall(rpc_resp, "XmlArgs", "", "", "");
		m_LastSaved.marshall(rpc_resp, "LastSaved", "", "", "");
	}
}


void CNavMenuEventResponse::copy(CNavMenuEventResponse &from)
{
	m_Component.copy(from.m_Component);
	m_Command.copy(from.m_Command);
	m_XmlArgs.copy(from.m_XmlArgs);
	m_LastSaved.copy(from.m_LastSaved);
}


void CNavMenuEventResponse::copy(IConstNavMenuEventResponse &ifrom)
{
	setComponent(ifrom.getComponent());
	setCommand(ifrom.getCommand());
	setXmlArgs(ifrom.getXmlArgs());
	setLastSaved(ifrom.getLastSaved());
}


void CNavMenuEventResponse::getAttributes(IProperties &attributes)
{
}


void CNavMenuEventResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
		m_Component.toStr(ctx, buffer, "Component", "", false, "", "");
		m_Command.toStr(ctx, buffer, "Command", "", false, "", "");
		m_XmlArgs.toStr(ctx, buffer, "XmlArgs", "", false, "", "");
		m_LastSaved.toStr(ctx, buffer, "LastSaved", "", false, "", "");
	}
}


void CNavMenuEventResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CNavMenuEventResponse::serializer(IEspContext* ctx, IConstNavMenuEventResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<NavMenuEventResponse>");
	// field Component
	{
		const char* s = src.getComponent();
		if (s && *s)
		buffer.appendf("<Component>%s</Component>",s);
	}
	// field Command
	{
		const char* s = src.getCommand();
		if (s && *s)
		buffer.appendf("<Command>%s</Command>",s);
	}
	// field XmlArgs
	{
		const char* s = src.getXmlArgs();
		if (s && *s)
		buffer.appendf("<XmlArgs>%s</XmlArgs>",s);
	}
	// field LastSaved
	{
		const char* s = src.getLastSaved();
		if (s && *s)
		buffer.appendf("<LastSaved>%s</LastSaved>",s);
	}
	if (keepRootTag)
		buffer.append("</NavMenuEventResponse>");
}

bool CNavMenuEventResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
		hasValue |= m_Component.unmarshall(rpc_request, "Component", basepath);
		hasValue |= m_Command.unmarshall(rpc_request, "Command", basepath);
		hasValue |= m_XmlArgs.unmarshall(rpc_request, "XmlArgs", basepath);
		hasValue |= m_LastSaved.unmarshall(rpc_request, "LastSaved", basepath);
	}
	return hasValue;
}

bool CNavMenuEventResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Component.unmarshall(ctx, soapval, "Component");
	hasValue |= m_Command.unmarshall(ctx, soapval, "Command");
	hasValue |= m_XmlArgs.unmarshall(ctx, soapval, "XmlArgs");
	hasValue |= m_LastSaved.unmarshall(ctx, soapval, "LastSaved");
	return hasValue;
}

bool CNavMenuEventResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Component.unmarshall(ctx, params, attachments, "Component", basepath);
	hasValue |= m_Command.unmarshall(ctx, params, attachments, "Command", basepath);
	hasValue |= m_XmlArgs.unmarshall(ctx, params, attachments, "XmlArgs", basepath);
	hasValue |= m_LastSaved.unmarshall(ctx, params, attachments, "LastSaved", basepath);
	return hasValue;
}

const char * CNavMenuEventResponse::getComponent() { return m_Component.query();}
const char * CNavMenuEventResponse::getCommand() { return m_Command.query();}
const char * CNavMenuEventResponse::getXmlArgs() { return m_XmlArgs.query();}
const char * CNavMenuEventResponse::getLastSaved() { return m_LastSaved.query();}
void CNavMenuEventResponse::setComponent(const char * val){ m_Component.set(val); }
void CNavMenuEventResponse::setCommand(const char * val){ m_Command.set(val); }
void CNavMenuEventResponse::setXmlArgs(const char * val){ m_XmlArgs.set(val); }
void CNavMenuEventResponse::setLastSaved(const char * val){ m_LastSaved.set(val); }
extern "C"  IEspNavMenuEventResponse *createNavMenuEventResponse(const char *serv){return ((IEspNavMenuEventResponse *)new CNavMenuEventResponse(serv));}
extern "C"  IClientNavMenuEventResponse *createClientNavMenuEventResponse(const char *serv){return ((IClientNavMenuEventResponse *)new CNavMenuEventResponse(serv));}

//=======================================================
// class CDisplaySettingsRequest Implementation
//=======================================================

CDisplaySettingsRequest::CDisplaySettingsRequest(const char *serviceName, IRpcMessageBinding *init)
	: m_Cmd(nilIgnore),m_XmlArgs(nilIgnore),m_ReqInfo(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("DisplaySettingsRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CDisplaySettingsRequest::CDisplaySettingsRequest(const char *serviceName, const char *bc)
	: m_Cmd(nilIgnore),m_XmlArgs(nilIgnore),m_ReqInfo(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("DisplaySettingsRequest");
}

CDisplaySettingsRequest::CDisplaySettingsRequest(const char *serviceName, IRpcMessage* rpcmsg)
	: m_Cmd(nilIgnore),m_XmlArgs(nilIgnore),m_ReqInfo(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("DisplaySettingsRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CDisplaySettingsRequest::CDisplaySettingsRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_Cmd(nilIgnore),m_XmlArgs(nilIgnore),m_ReqInfo(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("DisplaySettingsRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CDisplaySettingsRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Cmd\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"XmlArgs\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"ReqInfo\" type=\"tns:WsDeployReqInfo\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	if (!(flags & 0x10)  || (flags & 0x100))
	{
		CWsDeployReqInfo::getXsdDefinition(context, request, schema, added);
	}
	return schema;
}

void CDisplaySettingsRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CDisplaySettingsRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
	if (!added.getValue("WsDeployReqInfo"))
	{
		added.setValue("WsDeployReqInfo",1);
		CWsDeployReqInfo::getMapInfo(info,added);
	}
}

StringBuffer &CDisplaySettingsRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Cmd");
	form.appendf("  <tr><td><b>Cmd: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("XmlArgs");
	form.appendf("  <tr><td><b>XmlArgs: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("ReqInfo");
	form.append("<tr>").append("<td><b>ReqInfo: </b></td><td><hr/>");
	CWsDeployReqInfo::getHtmlForm(context, request, serv, method, form, false, extfix.str());
	form.append("<hr/></td></tr>");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CDisplaySettingsRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CDisplaySettingsRequest::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_Cmd.marshall(rpc_resp, "Cmd", "", "", "");
	m_XmlArgs.marshall(rpc_resp, "XmlArgs", "", "", "");
	m_ReqInfo.marshall(rpc_resp, "ReqInfo", "", "", "");
}


void CDisplaySettingsRequest::copy(CDisplaySettingsRequest &from)
{
	m_Cmd.copy(from.m_Cmd);
	m_XmlArgs.copy(from.m_XmlArgs);
	m_ReqInfo.copy(from.m_ReqInfo);
}


void CDisplaySettingsRequest::copy(IConstDisplaySettingsRequest &ifrom)
{
	setCmd(ifrom.getCmd());
	setXmlArgs(ifrom.getXmlArgs());
	setReqInfo(ifrom.getReqInfo());
}


void CDisplaySettingsRequest::getAttributes(IProperties &attributes)
{
}


void CDisplaySettingsRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_Cmd.toStr(ctx, buffer, "Cmd", "", true, "", "");
	m_XmlArgs.toStr(ctx, buffer, "XmlArgs", "", true, "", "");
	m_ReqInfo.toStr(ctx, buffer, "ReqInfo", "", false, "", "");
}


void CDisplaySettingsRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CDisplaySettingsRequest::serializer(IEspContext* ctx, IConstDisplaySettingsRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<DisplaySettingsRequest>");
	// field Cmd
	{
		const char* s = src.getCmd();
		if (s && *s)
		{
			buffer.append("<Cmd>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Cmd>");
		}
	}
	// field XmlArgs
	{
		const char* s = src.getXmlArgs();
		if (s && *s)
		{
			buffer.append("<XmlArgs>");
			encodeUtf8XML(s,buffer);
			buffer.append("</XmlArgs>");
		}
	}
	// field ReqInfo
	{
		StringBuffer tmp;
		CWsDeployReqInfo::serializer(ctx,src.getReqInfo(), tmp, false);
		if (tmp.length()>0)
			buffer.appendf("<ReqInfo>%s</ReqInfo>",tmp.str());
	}
	if (keepRootTag)
		buffer.append("</DisplaySettingsRequest>");
}

bool CDisplaySettingsRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_Cmd.unmarshall(rpc_request, "Cmd", basepath);
	hasValue |= m_XmlArgs.unmarshall(rpc_request, "XmlArgs", basepath);
	hasValue |= m_ReqInfo.unmarshall(rpc_request, "ReqInfo", basepath);
	return hasValue;
}

bool CDisplaySettingsRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Cmd.unmarshall(ctx, soapval, "Cmd");
	hasValue |= m_XmlArgs.unmarshall(ctx, soapval, "XmlArgs");
	hasValue |= m_ReqInfo.unmarshall(ctx, soapval, "ReqInfo");
	return hasValue;
}

bool CDisplaySettingsRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Cmd.unmarshall(ctx, params, attachments, "Cmd", basepath);
	hasValue |= m_XmlArgs.unmarshall(ctx, params, attachments, "XmlArgs", basepath);
	hasValue |= m_ReqInfo.unmarshall(ctx, params, attachments, "ReqInfo", basepath);
	return hasValue;
}

const char * CDisplaySettingsRequest::getCmd() { return m_Cmd.query();}
const char * CDisplaySettingsRequest::getXmlArgs() { return m_XmlArgs.query();}
IConstWsDeployReqInfo & CDisplaySettingsRequest::getReqInfo() { return (IConstWsDeployReqInfo &) m_ReqInfo.getValue();}
void CDisplaySettingsRequest::setCmd(const char * val){ m_Cmd.set(val); }
void CDisplaySettingsRequest::setXmlArgs(const char * val){ m_XmlArgs.set(val); }
IEspWsDeployReqInfo & CDisplaySettingsRequest::updateReqInfo(){ return (IEspWsDeployReqInfo &) m_ReqInfo.getValue(); }
void CDisplaySettingsRequest::setReqInfo(IConstWsDeployReqInfo &ifrom){ m_ReqInfo.copy(ifrom); }
extern "C"  IEspDisplaySettingsRequest *createDisplaySettingsRequest(const char *serv){return ((IEspDisplaySettingsRequest *)new CDisplaySettingsRequest(serv));}
extern "C"  IClientDisplaySettingsRequest *createClientDisplaySettingsRequest(const char *serv){return ((IClientDisplaySettingsRequest *)new CDisplaySettingsRequest(serv));}

//=======================================================
// class CDisplaySettingsResponse Implementation
//=======================================================

CDisplaySettingsResponse::CDisplaySettingsResponse(const char *serviceName, IRpcMessageBinding *init)
	: m_Component(nilIgnore),m_CompDefn(nilIgnore),m_ViewChildNodes(nilIgnore),m_MultiRowNodes(nilIgnore),m_XmlArgs(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("DisplaySettingsResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CDisplaySettingsResponse::CDisplaySettingsResponse(const char *serviceName, const char *bc)
	: m_Component(nilIgnore),m_CompDefn(nilIgnore),m_ViewChildNodes(nilIgnore),m_MultiRowNodes(nilIgnore),m_XmlArgs(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("DisplaySettingsResponse");
}

CDisplaySettingsResponse::CDisplaySettingsResponse(const char *serviceName, IRpcMessage* rpcmsg)
	: m_Component(nilIgnore),m_CompDefn(nilIgnore),m_ViewChildNodes(nilIgnore),m_MultiRowNodes(nilIgnore),m_XmlArgs(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("DisplaySettingsResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CDisplaySettingsResponse::CDisplaySettingsResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_Component(nilIgnore),m_CompDefn(nilIgnore),m_ViewChildNodes(nilIgnore),m_MultiRowNodes(nilIgnore),m_XmlArgs(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("DisplaySettingsResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CDisplaySettingsResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		schema.append("<xsd:element name=\"Exceptions\" type=\"tns:ArrayOfEspException\" minOccurs=\"0\" maxOccurs=\"1\"/>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Component\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"CompDefn\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"ViewChildNodes\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"MultiRowNodes\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"XmlArgs\" type=\"xsd:string\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CDisplaySettingsResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CDisplaySettingsResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CDisplaySettingsResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Component");
	form.appendf("  <tr><td><b>Component: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("CompDefn");
	form.appendf("  <tr><td><b>CompDefn: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("ViewChildNodes");
	form.appendf("  <tr><td><b>ViewChildNodes: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("MultiRowNodes");
	form.appendf("  <tr><td><b>MultiRowNodes: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("XmlArgs");
	form.appendf("  <tr><td><b>XmlArgs: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CDisplaySettingsResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CDisplaySettingsResponse::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	rpc_resp.setEncodeXml(false);
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
		m_Component.marshall(rpc_resp, "Component", "", "", "");
		m_CompDefn.marshall(rpc_resp, "CompDefn", "", "", "");
		m_ViewChildNodes.marshall(rpc_resp, "ViewChildNodes", "", "", "");
		m_MultiRowNodes.marshall(rpc_resp, "MultiRowNodes", "", "", "");
		m_XmlArgs.marshall(rpc_resp, "XmlArgs", "", "", "");
	}
}


void CDisplaySettingsResponse::copy(CDisplaySettingsResponse &from)
{
	m_Component.copy(from.m_Component);
	m_CompDefn.copy(from.m_CompDefn);
	m_ViewChildNodes.copy(from.m_ViewChildNodes);
	m_MultiRowNodes.copy(from.m_MultiRowNodes);
	m_XmlArgs.copy(from.m_XmlArgs);
}


void CDisplaySettingsResponse::copy(IConstDisplaySettingsResponse &ifrom)
{
	setComponent(ifrom.getComponent());
	setCompDefn(ifrom.getCompDefn());
	setViewChildNodes(ifrom.getViewChildNodes());
	setMultiRowNodes(ifrom.getMultiRowNodes());
	setXmlArgs(ifrom.getXmlArgs());
}


void CDisplaySettingsResponse::getAttributes(IProperties &attributes)
{
}


void CDisplaySettingsResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
		m_Component.toStr(ctx, buffer, "Component", "", false, "", "");
		m_CompDefn.toStr(ctx, buffer, "CompDefn", "", false, "", "");
		m_ViewChildNodes.toStr(ctx, buffer, "ViewChildNodes", "", false, "", "");
		m_MultiRowNodes.toStr(ctx, buffer, "MultiRowNodes", "", false, "", "");
		m_XmlArgs.toStr(ctx, buffer, "XmlArgs", "", false, "", "");
	}
}


void CDisplaySettingsResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CDisplaySettingsResponse::serializer(IEspContext* ctx, IConstDisplaySettingsResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<DisplaySettingsResponse>");
	// field Component
	{
		const char* s = src.getComponent();
		if (s && *s)
		buffer.appendf("<Component>%s</Component>",s);
	}
	// field CompDefn
	{
		const char* s = src.getCompDefn();
		if (s && *s)
		buffer.appendf("<CompDefn>%s</CompDefn>",s);
	}
	// field ViewChildNodes
	{
		const char* s = src.getViewChildNodes();
		if (s && *s)
		buffer.appendf("<ViewChildNodes>%s</ViewChildNodes>",s);
	}
	// field MultiRowNodes
	{
		const char* s = src.getMultiRowNodes();
		if (s && *s)
		buffer.appendf("<MultiRowNodes>%s</MultiRowNodes>",s);
	}
	// field XmlArgs
	{
		const char* s = src.getXmlArgs();
		if (s && *s)
		buffer.appendf("<XmlArgs>%s</XmlArgs>",s);
	}
	if (keepRootTag)
		buffer.append("</DisplaySettingsResponse>");
}

bool CDisplaySettingsResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
		hasValue |= m_Component.unmarshall(rpc_request, "Component", basepath);
		hasValue |= m_CompDefn.unmarshall(rpc_request, "CompDefn", basepath);
		hasValue |= m_ViewChildNodes.unmarshall(rpc_request, "ViewChildNodes", basepath);
		hasValue |= m_MultiRowNodes.unmarshall(rpc_request, "MultiRowNodes", basepath);
		hasValue |= m_XmlArgs.unmarshall(rpc_request, "XmlArgs", basepath);
	}
	return hasValue;
}

bool CDisplaySettingsResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Component.unmarshall(ctx, soapval, "Component");
	hasValue |= m_CompDefn.unmarshall(ctx, soapval, "CompDefn");
	hasValue |= m_ViewChildNodes.unmarshall(ctx, soapval, "ViewChildNodes");
	hasValue |= m_MultiRowNodes.unmarshall(ctx, soapval, "MultiRowNodes");
	hasValue |= m_XmlArgs.unmarshall(ctx, soapval, "XmlArgs");
	return hasValue;
}

bool CDisplaySettingsResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Component.unmarshall(ctx, params, attachments, "Component", basepath);
	hasValue |= m_CompDefn.unmarshall(ctx, params, attachments, "CompDefn", basepath);
	hasValue |= m_ViewChildNodes.unmarshall(ctx, params, attachments, "ViewChildNodes", basepath);
	hasValue |= m_MultiRowNodes.unmarshall(ctx, params, attachments, "MultiRowNodes", basepath);
	hasValue |= m_XmlArgs.unmarshall(ctx, params, attachments, "XmlArgs", basepath);
	return hasValue;
}

const char * CDisplaySettingsResponse::getComponent() { return m_Component.query();}
const char * CDisplaySettingsResponse::getCompDefn() { return m_CompDefn.query();}
const char * CDisplaySettingsResponse::getViewChildNodes() { return m_ViewChildNodes.query();}
const char * CDisplaySettingsResponse::getMultiRowNodes() { return m_MultiRowNodes.query();}
const char * CDisplaySettingsResponse::getXmlArgs() { return m_XmlArgs.query();}
void CDisplaySettingsResponse::setComponent(const char * val){ m_Component.set(val); }
void CDisplaySettingsResponse::setCompDefn(const char * val){ m_CompDefn.set(val); }
void CDisplaySettingsResponse::setViewChildNodes(const char * val){ m_ViewChildNodes.set(val); }
void CDisplaySettingsResponse::setMultiRowNodes(const char * val){ m_MultiRowNodes.set(val); }
void CDisplaySettingsResponse::setXmlArgs(const char * val){ m_XmlArgs.set(val); }
extern "C"  IEspDisplaySettingsResponse *createDisplaySettingsResponse(const char *serv){return ((IEspDisplaySettingsResponse *)new CDisplaySettingsResponse(serv));}
extern "C"  IClientDisplaySettingsResponse *createClientDisplaySettingsResponse(const char *serv){return ((IClientDisplaySettingsResponse *)new CDisplaySettingsResponse(serv));}

//=======================================================
// class CSaveSettingRequest Implementation
//=======================================================

CSaveSettingRequest::CSaveSettingRequest(const char *serviceName, IRpcMessageBinding *init)
	: m_XmlArgs(nilIgnore),m_ReqInfo(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("SaveSettingRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CSaveSettingRequest::CSaveSettingRequest(const char *serviceName, const char *bc)
	: m_XmlArgs(nilIgnore),m_ReqInfo(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("SaveSettingRequest");
}

CSaveSettingRequest::CSaveSettingRequest(const char *serviceName, IRpcMessage* rpcmsg)
	: m_XmlArgs(nilIgnore),m_ReqInfo(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("SaveSettingRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CSaveSettingRequest::CSaveSettingRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_XmlArgs(nilIgnore),m_ReqInfo(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("SaveSettingRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CSaveSettingRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"XmlArgs\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"ReqInfo\" type=\"tns:WsDeployReqInfo\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	if (!(flags & 0x10)  || (flags & 0x100))
	{
		CWsDeployReqInfo::getXsdDefinition(context, request, schema, added);
	}
	return schema;
}

void CSaveSettingRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CSaveSettingRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
	if (!added.getValue("WsDeployReqInfo"))
	{
		added.setValue("WsDeployReqInfo",1);
		CWsDeployReqInfo::getMapInfo(info,added);
	}
}

StringBuffer &CSaveSettingRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("XmlArgs");
	form.appendf("  <tr><td><b>XmlArgs: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("ReqInfo");
	form.append("<tr>").append("<td><b>ReqInfo: </b></td><td><hr/>");
	CWsDeployReqInfo::getHtmlForm(context, request, serv, method, form, false, extfix.str());
	form.append("<hr/></td></tr>");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CSaveSettingRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CSaveSettingRequest::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_XmlArgs.marshall(rpc_resp, "XmlArgs", "", "", "");
	m_ReqInfo.marshall(rpc_resp, "ReqInfo", "", "", "");
}


void CSaveSettingRequest::copy(CSaveSettingRequest &from)
{
	m_XmlArgs.copy(from.m_XmlArgs);
	m_ReqInfo.copy(from.m_ReqInfo);
}


void CSaveSettingRequest::copy(IConstSaveSettingRequest &ifrom)
{
	setXmlArgs(ifrom.getXmlArgs());
	setReqInfo(ifrom.getReqInfo());
}


void CSaveSettingRequest::getAttributes(IProperties &attributes)
{
}


void CSaveSettingRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_XmlArgs.toStr(ctx, buffer, "XmlArgs", "", true, "", "");
	m_ReqInfo.toStr(ctx, buffer, "ReqInfo", "", false, "", "");
}


void CSaveSettingRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CSaveSettingRequest::serializer(IEspContext* ctx, IConstSaveSettingRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<SaveSettingRequest>");
	// field XmlArgs
	{
		const char* s = src.getXmlArgs();
		if (s && *s)
		{
			buffer.append("<XmlArgs>");
			encodeUtf8XML(s,buffer);
			buffer.append("</XmlArgs>");
		}
	}
	// field ReqInfo
	{
		StringBuffer tmp;
		CWsDeployReqInfo::serializer(ctx,src.getReqInfo(), tmp, false);
		if (tmp.length()>0)
			buffer.appendf("<ReqInfo>%s</ReqInfo>",tmp.str());
	}
	if (keepRootTag)
		buffer.append("</SaveSettingRequest>");
}

bool CSaveSettingRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_XmlArgs.unmarshall(rpc_request, "XmlArgs", basepath);
	hasValue |= m_ReqInfo.unmarshall(rpc_request, "ReqInfo", basepath);
	return hasValue;
}

bool CSaveSettingRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_XmlArgs.unmarshall(ctx, soapval, "XmlArgs");
	hasValue |= m_ReqInfo.unmarshall(ctx, soapval, "ReqInfo");
	return hasValue;
}

bool CSaveSettingRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_XmlArgs.unmarshall(ctx, params, attachments, "XmlArgs", basepath);
	hasValue |= m_ReqInfo.unmarshall(ctx, params, attachments, "ReqInfo", basepath);
	return hasValue;
}

const char * CSaveSettingRequest::getXmlArgs() { return m_XmlArgs.query();}
IConstWsDeployReqInfo & CSaveSettingRequest::getReqInfo() { return (IConstWsDeployReqInfo &) m_ReqInfo.getValue();}
void CSaveSettingRequest::setXmlArgs(const char * val){ m_XmlArgs.set(val); }
IEspWsDeployReqInfo & CSaveSettingRequest::updateReqInfo(){ return (IEspWsDeployReqInfo &) m_ReqInfo.getValue(); }
void CSaveSettingRequest::setReqInfo(IConstWsDeployReqInfo &ifrom){ m_ReqInfo.copy(ifrom); }
extern "C"  IEspSaveSettingRequest *createSaveSettingRequest(const char *serv){return ((IEspSaveSettingRequest *)new CSaveSettingRequest(serv));}
extern "C"  IClientSaveSettingRequest *createClientSaveSettingRequest(const char *serv){return ((IClientSaveSettingRequest *)new CSaveSettingRequest(serv));}

//=======================================================
// class CSaveSettingResponse Implementation
//=======================================================

CSaveSettingResponse::CSaveSettingResponse(const char *serviceName, IRpcMessageBinding *init)
	: m_UpdateAttr(nilIgnore),m_UpdateValue(nilIgnore),m_PrevValue(nilIgnore),m_IsSaved(nilIgnore),m_Refresh(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("SaveSettingResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CSaveSettingResponse::CSaveSettingResponse(const char *serviceName, const char *bc)
	: m_UpdateAttr(nilIgnore),m_UpdateValue(nilIgnore),m_PrevValue(nilIgnore),m_IsSaved(nilIgnore),m_Refresh(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("SaveSettingResponse");
}

CSaveSettingResponse::CSaveSettingResponse(const char *serviceName, IRpcMessage* rpcmsg)
	: m_UpdateAttr(nilIgnore),m_UpdateValue(nilIgnore),m_PrevValue(nilIgnore),m_IsSaved(nilIgnore),m_Refresh(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("SaveSettingResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CSaveSettingResponse::CSaveSettingResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_UpdateAttr(nilIgnore),m_UpdateValue(nilIgnore),m_PrevValue(nilIgnore),m_IsSaved(nilIgnore),m_Refresh(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("SaveSettingResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CSaveSettingResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		schema.append("<xsd:element name=\"Exceptions\" type=\"tns:ArrayOfEspException\" minOccurs=\"0\" maxOccurs=\"1\"/>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"UpdateAttr\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"UpdateValue\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"PrevValue\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"IsSaved\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Refresh\" type=\"xsd:string\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CSaveSettingResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CSaveSettingResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CSaveSettingResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("UpdateAttr");
	form.appendf("  <tr><td><b>UpdateAttr: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("UpdateValue");
	form.appendf("  <tr><td><b>UpdateValue: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("PrevValue");
	form.appendf("  <tr><td><b>PrevValue: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("IsSaved");
	form.appendf("  <tr><td><b>IsSaved: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Refresh");
	form.appendf("  <tr><td><b>Refresh: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CSaveSettingResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CSaveSettingResponse::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	rpc_resp.setEncodeXml(false);
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
		m_UpdateAttr.marshall(rpc_resp, "UpdateAttr", "", "", "");
		m_UpdateValue.marshall(rpc_resp, "UpdateValue", "", "", "");
		m_PrevValue.marshall(rpc_resp, "PrevValue", "", "", "");
		m_IsSaved.marshall(rpc_resp, "IsSaved", "", "", "");
		m_Refresh.marshall(rpc_resp, "Refresh", "", "", "");
	}
}


void CSaveSettingResponse::copy(CSaveSettingResponse &from)
{
	m_UpdateAttr.copy(from.m_UpdateAttr);
	m_UpdateValue.copy(from.m_UpdateValue);
	m_PrevValue.copy(from.m_PrevValue);
	m_IsSaved.copy(from.m_IsSaved);
	m_Refresh.copy(from.m_Refresh);
}


void CSaveSettingResponse::copy(IConstSaveSettingResponse &ifrom)
{
	setUpdateAttr(ifrom.getUpdateAttr());
	setUpdateValue(ifrom.getUpdateValue());
	setPrevValue(ifrom.getPrevValue());
	setIsSaved(ifrom.getIsSaved());
	setRefresh(ifrom.getRefresh());
}


void CSaveSettingResponse::getAttributes(IProperties &attributes)
{
}


void CSaveSettingResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
		m_UpdateAttr.toStr(ctx, buffer, "UpdateAttr", "", false, "", "");
		m_UpdateValue.toStr(ctx, buffer, "UpdateValue", "", false, "", "");
		m_PrevValue.toStr(ctx, buffer, "PrevValue", "", false, "", "");
		m_IsSaved.toStr(ctx, buffer, "IsSaved", "", false, "", "");
		m_Refresh.toStr(ctx, buffer, "Refresh", "", false, "", "");
	}
}


void CSaveSettingResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CSaveSettingResponse::serializer(IEspContext* ctx, IConstSaveSettingResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<SaveSettingResponse>");
	// field UpdateAttr
	{
		const char* s = src.getUpdateAttr();
		if (s && *s)
		buffer.appendf("<UpdateAttr>%s</UpdateAttr>",s);
	}
	// field UpdateValue
	{
		const char* s = src.getUpdateValue();
		if (s && *s)
		buffer.appendf("<UpdateValue>%s</UpdateValue>",s);
	}
	// field PrevValue
	{
		const char* s = src.getPrevValue();
		if (s && *s)
		buffer.appendf("<PrevValue>%s</PrevValue>",s);
	}
	// field IsSaved
	{
		const char* s = src.getIsSaved();
		if (s && *s)
		buffer.appendf("<IsSaved>%s</IsSaved>",s);
	}
	// field Refresh
	{
		const char* s = src.getRefresh();
		if (s && *s)
		buffer.appendf("<Refresh>%s</Refresh>",s);
	}
	if (keepRootTag)
		buffer.append("</SaveSettingResponse>");
}

bool CSaveSettingResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
		hasValue |= m_UpdateAttr.unmarshall(rpc_request, "UpdateAttr", basepath);
		hasValue |= m_UpdateValue.unmarshall(rpc_request, "UpdateValue", basepath);
		hasValue |= m_PrevValue.unmarshall(rpc_request, "PrevValue", basepath);
		hasValue |= m_IsSaved.unmarshall(rpc_request, "IsSaved", basepath);
		hasValue |= m_Refresh.unmarshall(rpc_request, "Refresh", basepath);
	}
	return hasValue;
}

bool CSaveSettingResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_UpdateAttr.unmarshall(ctx, soapval, "UpdateAttr");
	hasValue |= m_UpdateValue.unmarshall(ctx, soapval, "UpdateValue");
	hasValue |= m_PrevValue.unmarshall(ctx, soapval, "PrevValue");
	hasValue |= m_IsSaved.unmarshall(ctx, soapval, "IsSaved");
	hasValue |= m_Refresh.unmarshall(ctx, soapval, "Refresh");
	return hasValue;
}

bool CSaveSettingResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_UpdateAttr.unmarshall(ctx, params, attachments, "UpdateAttr", basepath);
	hasValue |= m_UpdateValue.unmarshall(ctx, params, attachments, "UpdateValue", basepath);
	hasValue |= m_PrevValue.unmarshall(ctx, params, attachments, "PrevValue", basepath);
	hasValue |= m_IsSaved.unmarshall(ctx, params, attachments, "IsSaved", basepath);
	hasValue |= m_Refresh.unmarshall(ctx, params, attachments, "Refresh", basepath);
	return hasValue;
}

const char * CSaveSettingResponse::getUpdateAttr() { return m_UpdateAttr.query();}
const char * CSaveSettingResponse::getUpdateValue() { return m_UpdateValue.query();}
const char * CSaveSettingResponse::getPrevValue() { return m_PrevValue.query();}
const char * CSaveSettingResponse::getIsSaved() { return m_IsSaved.query();}
const char * CSaveSettingResponse::getRefresh() { return m_Refresh.query();}
void CSaveSettingResponse::setUpdateAttr(const char * val){ m_UpdateAttr.set(val); }
void CSaveSettingResponse::setUpdateValue(const char * val){ m_UpdateValue.set(val); }
void CSaveSettingResponse::setPrevValue(const char * val){ m_PrevValue.set(val); }
void CSaveSettingResponse::setIsSaved(const char * val){ m_IsSaved.set(val); }
void CSaveSettingResponse::setRefresh(const char * val){ m_Refresh.set(val); }
extern "C"  IEspSaveSettingResponse *createSaveSettingResponse(const char *serv){return ((IEspSaveSettingResponse *)new CSaveSettingResponse(serv));}
extern "C"  IClientSaveSettingResponse *createClientSaveSettingResponse(const char *serv){return ((IClientSaveSettingResponse *)new CSaveSettingResponse(serv));}

//=======================================================
// class CGetBuildSetInfoRequest Implementation
//=======================================================

CGetBuildSetInfoRequest::CGetBuildSetInfoRequest(const char *serviceName, IRpcMessageBinding *init)
	: m_Cmd(nilIgnore),m_XmlArgs(nilIgnore),m_ReqInfo(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetBuildSetInfoRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CGetBuildSetInfoRequest::CGetBuildSetInfoRequest(const char *serviceName, const char *bc)
	: m_Cmd(nilIgnore),m_XmlArgs(nilIgnore),m_ReqInfo(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetBuildSetInfoRequest");
}

CGetBuildSetInfoRequest::CGetBuildSetInfoRequest(const char *serviceName, IRpcMessage* rpcmsg)
	: m_Cmd(nilIgnore),m_XmlArgs(nilIgnore),m_ReqInfo(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetBuildSetInfoRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CGetBuildSetInfoRequest::CGetBuildSetInfoRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_Cmd(nilIgnore),m_XmlArgs(nilIgnore),m_ReqInfo(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetBuildSetInfoRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CGetBuildSetInfoRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Cmd\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"XmlArgs\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"ReqInfo\" type=\"tns:WsDeployReqInfo\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	if (!(flags & 0x10)  || (flags & 0x100))
	{
		CWsDeployReqInfo::getXsdDefinition(context, request, schema, added);
	}
	return schema;
}

void CGetBuildSetInfoRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CGetBuildSetInfoRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
	if (!added.getValue("WsDeployReqInfo"))
	{
		added.setValue("WsDeployReqInfo",1);
		CWsDeployReqInfo::getMapInfo(info,added);
	}
}

StringBuffer &CGetBuildSetInfoRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Cmd");
	form.appendf("  <tr><td><b>Cmd: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("XmlArgs");
	form.appendf("  <tr><td><b>XmlArgs: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("ReqInfo");
	form.append("<tr>").append("<td><b>ReqInfo: </b></td><td><hr/>");
	CWsDeployReqInfo::getHtmlForm(context, request, serv, method, form, false, extfix.str());
	form.append("<hr/></td></tr>");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CGetBuildSetInfoRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CGetBuildSetInfoRequest::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_Cmd.marshall(rpc_resp, "Cmd", "", "", "");
	m_XmlArgs.marshall(rpc_resp, "XmlArgs", "", "", "");
	m_ReqInfo.marshall(rpc_resp, "ReqInfo", "", "", "");
}


void CGetBuildSetInfoRequest::copy(CGetBuildSetInfoRequest &from)
{
	m_Cmd.copy(from.m_Cmd);
	m_XmlArgs.copy(from.m_XmlArgs);
	m_ReqInfo.copy(from.m_ReqInfo);
}


void CGetBuildSetInfoRequest::copy(IConstGetBuildSetInfoRequest &ifrom)
{
	setCmd(ifrom.getCmd());
	setXmlArgs(ifrom.getXmlArgs());
	setReqInfo(ifrom.getReqInfo());
}


void CGetBuildSetInfoRequest::getAttributes(IProperties &attributes)
{
}


void CGetBuildSetInfoRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_Cmd.toStr(ctx, buffer, "Cmd", "", true, "", "");
	m_XmlArgs.toStr(ctx, buffer, "XmlArgs", "", true, "", "");
	m_ReqInfo.toStr(ctx, buffer, "ReqInfo", "", false, "", "");
}


void CGetBuildSetInfoRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CGetBuildSetInfoRequest::serializer(IEspContext* ctx, IConstGetBuildSetInfoRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<GetBuildSetInfoRequest>");
	// field Cmd
	{
		const char* s = src.getCmd();
		if (s && *s)
		{
			buffer.append("<Cmd>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Cmd>");
		}
	}
	// field XmlArgs
	{
		const char* s = src.getXmlArgs();
		if (s && *s)
		{
			buffer.append("<XmlArgs>");
			encodeUtf8XML(s,buffer);
			buffer.append("</XmlArgs>");
		}
	}
	// field ReqInfo
	{
		StringBuffer tmp;
		CWsDeployReqInfo::serializer(ctx,src.getReqInfo(), tmp, false);
		if (tmp.length()>0)
			buffer.appendf("<ReqInfo>%s</ReqInfo>",tmp.str());
	}
	if (keepRootTag)
		buffer.append("</GetBuildSetInfoRequest>");
}

bool CGetBuildSetInfoRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_Cmd.unmarshall(rpc_request, "Cmd", basepath);
	hasValue |= m_XmlArgs.unmarshall(rpc_request, "XmlArgs", basepath);
	hasValue |= m_ReqInfo.unmarshall(rpc_request, "ReqInfo", basepath);
	return hasValue;
}

bool CGetBuildSetInfoRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Cmd.unmarshall(ctx, soapval, "Cmd");
	hasValue |= m_XmlArgs.unmarshall(ctx, soapval, "XmlArgs");
	hasValue |= m_ReqInfo.unmarshall(ctx, soapval, "ReqInfo");
	return hasValue;
}

bool CGetBuildSetInfoRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Cmd.unmarshall(ctx, params, attachments, "Cmd", basepath);
	hasValue |= m_XmlArgs.unmarshall(ctx, params, attachments, "XmlArgs", basepath);
	hasValue |= m_ReqInfo.unmarshall(ctx, params, attachments, "ReqInfo", basepath);
	return hasValue;
}

const char * CGetBuildSetInfoRequest::getCmd() { return m_Cmd.query();}
const char * CGetBuildSetInfoRequest::getXmlArgs() { return m_XmlArgs.query();}
IConstWsDeployReqInfo & CGetBuildSetInfoRequest::getReqInfo() { return (IConstWsDeployReqInfo &) m_ReqInfo.getValue();}
void CGetBuildSetInfoRequest::setCmd(const char * val){ m_Cmd.set(val); }
void CGetBuildSetInfoRequest::setXmlArgs(const char * val){ m_XmlArgs.set(val); }
IEspWsDeployReqInfo & CGetBuildSetInfoRequest::updateReqInfo(){ return (IEspWsDeployReqInfo &) m_ReqInfo.getValue(); }
void CGetBuildSetInfoRequest::setReqInfo(IConstWsDeployReqInfo &ifrom){ m_ReqInfo.copy(ifrom); }
extern "C"  IEspGetBuildSetInfoRequest *createGetBuildSetInfoRequest(const char *serv){return ((IEspGetBuildSetInfoRequest *)new CGetBuildSetInfoRequest(serv));}
extern "C"  IClientGetBuildSetInfoRequest *createClientGetBuildSetInfoRequest(const char *serv){return ((IClientGetBuildSetInfoRequest *)new CGetBuildSetInfoRequest(serv));}

//=======================================================
// class CGetBuildSetInfoResponse Implementation
//=======================================================

CGetBuildSetInfoResponse::CGetBuildSetInfoResponse(const char *serviceName, IRpcMessageBinding *init)
	: m_Component(nilIgnore),m_XmlArgs(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetBuildSetInfoResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CGetBuildSetInfoResponse::CGetBuildSetInfoResponse(const char *serviceName, const char *bc)
	: m_Component(nilIgnore),m_XmlArgs(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetBuildSetInfoResponse");
}

CGetBuildSetInfoResponse::CGetBuildSetInfoResponse(const char *serviceName, IRpcMessage* rpcmsg)
	: m_Component(nilIgnore),m_XmlArgs(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetBuildSetInfoResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CGetBuildSetInfoResponse::CGetBuildSetInfoResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_Component(nilIgnore),m_XmlArgs(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetBuildSetInfoResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CGetBuildSetInfoResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		schema.append("<xsd:element name=\"Exceptions\" type=\"tns:ArrayOfEspException\" minOccurs=\"0\" maxOccurs=\"1\"/>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Component\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"XmlArgs\" type=\"xsd:string\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CGetBuildSetInfoResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CGetBuildSetInfoResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CGetBuildSetInfoResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Component");
	form.appendf("  <tr><td><b>Component: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("XmlArgs");
	form.appendf("  <tr><td><b>XmlArgs: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CGetBuildSetInfoResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CGetBuildSetInfoResponse::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	rpc_resp.setEncodeXml(false);
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
		m_Component.marshall(rpc_resp, "Component", "", "", "");
		m_XmlArgs.marshall(rpc_resp, "XmlArgs", "", "", "");
	}
}


void CGetBuildSetInfoResponse::copy(CGetBuildSetInfoResponse &from)
{
	m_Component.copy(from.m_Component);
	m_XmlArgs.copy(from.m_XmlArgs);
}


void CGetBuildSetInfoResponse::copy(IConstGetBuildSetInfoResponse &ifrom)
{
	setComponent(ifrom.getComponent());
	setXmlArgs(ifrom.getXmlArgs());
}


void CGetBuildSetInfoResponse::getAttributes(IProperties &attributes)
{
}


void CGetBuildSetInfoResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
		m_Component.toStr(ctx, buffer, "Component", "", false, "", "");
		m_XmlArgs.toStr(ctx, buffer, "XmlArgs", "", false, "", "");
	}
}


void CGetBuildSetInfoResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CGetBuildSetInfoResponse::serializer(IEspContext* ctx, IConstGetBuildSetInfoResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<GetBuildSetInfoResponse>");
	// field Component
	{
		const char* s = src.getComponent();
		if (s && *s)
		buffer.appendf("<Component>%s</Component>",s);
	}
	// field XmlArgs
	{
		const char* s = src.getXmlArgs();
		if (s && *s)
		buffer.appendf("<XmlArgs>%s</XmlArgs>",s);
	}
	if (keepRootTag)
		buffer.append("</GetBuildSetInfoResponse>");
}

bool CGetBuildSetInfoResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
		hasValue |= m_Component.unmarshall(rpc_request, "Component", basepath);
		hasValue |= m_XmlArgs.unmarshall(rpc_request, "XmlArgs", basepath);
	}
	return hasValue;
}

bool CGetBuildSetInfoResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Component.unmarshall(ctx, soapval, "Component");
	hasValue |= m_XmlArgs.unmarshall(ctx, soapval, "XmlArgs");
	return hasValue;
}

bool CGetBuildSetInfoResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Component.unmarshall(ctx, params, attachments, "Component", basepath);
	hasValue |= m_XmlArgs.unmarshall(ctx, params, attachments, "XmlArgs", basepath);
	return hasValue;
}

const char * CGetBuildSetInfoResponse::getComponent() { return m_Component.query();}
const char * CGetBuildSetInfoResponse::getXmlArgs() { return m_XmlArgs.query();}
void CGetBuildSetInfoResponse::setComponent(const char * val){ m_Component.set(val); }
void CGetBuildSetInfoResponse::setXmlArgs(const char * val){ m_XmlArgs.set(val); }
extern "C"  IEspGetBuildSetInfoResponse *createGetBuildSetInfoResponse(const char *serv){return ((IEspGetBuildSetInfoResponse *)new CGetBuildSetInfoResponse(serv));}
extern "C"  IClientGetBuildSetInfoResponse *createClientGetBuildSetInfoResponse(const char *serv){return ((IClientGetBuildSetInfoResponse *)new CGetBuildSetInfoResponse(serv));}

//=======================================================
// class CGetDeployableCompsRequest Implementation
//=======================================================

CGetDeployableCompsRequest::CGetDeployableCompsRequest(const char *serviceName, IRpcMessageBinding *init)
	: m_Cmd(nilIgnore),m_XmlArgs(nilIgnore),m_ReqInfo(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetDeployableCompsRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CGetDeployableCompsRequest::CGetDeployableCompsRequest(const char *serviceName, const char *bc)
	: m_Cmd(nilIgnore),m_XmlArgs(nilIgnore),m_ReqInfo(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetDeployableCompsRequest");
}

CGetDeployableCompsRequest::CGetDeployableCompsRequest(const char *serviceName, IRpcMessage* rpcmsg)
	: m_Cmd(nilIgnore),m_XmlArgs(nilIgnore),m_ReqInfo(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetDeployableCompsRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CGetDeployableCompsRequest::CGetDeployableCompsRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_Cmd(nilIgnore),m_XmlArgs(nilIgnore),m_ReqInfo(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetDeployableCompsRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CGetDeployableCompsRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Cmd\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"XmlArgs\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"ReqInfo\" type=\"tns:WsDeployReqInfo\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	if (!(flags & 0x10)  || (flags & 0x100))
	{
		CWsDeployReqInfo::getXsdDefinition(context, request, schema, added);
	}
	return schema;
}

void CGetDeployableCompsRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CGetDeployableCompsRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
	if (!added.getValue("WsDeployReqInfo"))
	{
		added.setValue("WsDeployReqInfo",1);
		CWsDeployReqInfo::getMapInfo(info,added);
	}
}

StringBuffer &CGetDeployableCompsRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Cmd");
	form.appendf("  <tr><td><b>Cmd: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("XmlArgs");
	form.appendf("  <tr><td><b>XmlArgs: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("ReqInfo");
	form.append("<tr>").append("<td><b>ReqInfo: </b></td><td><hr/>");
	CWsDeployReqInfo::getHtmlForm(context, request, serv, method, form, false, extfix.str());
	form.append("<hr/></td></tr>");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CGetDeployableCompsRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CGetDeployableCompsRequest::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_Cmd.marshall(rpc_resp, "Cmd", "", "", "");
	m_XmlArgs.marshall(rpc_resp, "XmlArgs", "", "", "");
	m_ReqInfo.marshall(rpc_resp, "ReqInfo", "", "", "");
}


void CGetDeployableCompsRequest::copy(CGetDeployableCompsRequest &from)
{
	m_Cmd.copy(from.m_Cmd);
	m_XmlArgs.copy(from.m_XmlArgs);
	m_ReqInfo.copy(from.m_ReqInfo);
}


void CGetDeployableCompsRequest::copy(IConstGetDeployableCompsRequest &ifrom)
{
	setCmd(ifrom.getCmd());
	setXmlArgs(ifrom.getXmlArgs());
	setReqInfo(ifrom.getReqInfo());
}


void CGetDeployableCompsRequest::getAttributes(IProperties &attributes)
{
}


void CGetDeployableCompsRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_Cmd.toStr(ctx, buffer, "Cmd", "", true, "", "");
	m_XmlArgs.toStr(ctx, buffer, "XmlArgs", "", true, "", "");
	m_ReqInfo.toStr(ctx, buffer, "ReqInfo", "", false, "", "");
}


void CGetDeployableCompsRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CGetDeployableCompsRequest::serializer(IEspContext* ctx, IConstGetDeployableCompsRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<GetDeployableCompsRequest>");
	// field Cmd
	{
		const char* s = src.getCmd();
		if (s && *s)
		{
			buffer.append("<Cmd>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Cmd>");
		}
	}
	// field XmlArgs
	{
		const char* s = src.getXmlArgs();
		if (s && *s)
		{
			buffer.append("<XmlArgs>");
			encodeUtf8XML(s,buffer);
			buffer.append("</XmlArgs>");
		}
	}
	// field ReqInfo
	{
		StringBuffer tmp;
		CWsDeployReqInfo::serializer(ctx,src.getReqInfo(), tmp, false);
		if (tmp.length()>0)
			buffer.appendf("<ReqInfo>%s</ReqInfo>",tmp.str());
	}
	if (keepRootTag)
		buffer.append("</GetDeployableCompsRequest>");
}

bool CGetDeployableCompsRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_Cmd.unmarshall(rpc_request, "Cmd", basepath);
	hasValue |= m_XmlArgs.unmarshall(rpc_request, "XmlArgs", basepath);
	hasValue |= m_ReqInfo.unmarshall(rpc_request, "ReqInfo", basepath);
	return hasValue;
}

bool CGetDeployableCompsRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Cmd.unmarshall(ctx, soapval, "Cmd");
	hasValue |= m_XmlArgs.unmarshall(ctx, soapval, "XmlArgs");
	hasValue |= m_ReqInfo.unmarshall(ctx, soapval, "ReqInfo");
	return hasValue;
}

bool CGetDeployableCompsRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Cmd.unmarshall(ctx, params, attachments, "Cmd", basepath);
	hasValue |= m_XmlArgs.unmarshall(ctx, params, attachments, "XmlArgs", basepath);
	hasValue |= m_ReqInfo.unmarshall(ctx, params, attachments, "ReqInfo", basepath);
	return hasValue;
}

const char * CGetDeployableCompsRequest::getCmd() { return m_Cmd.query();}
const char * CGetDeployableCompsRequest::getXmlArgs() { return m_XmlArgs.query();}
IConstWsDeployReqInfo & CGetDeployableCompsRequest::getReqInfo() { return (IConstWsDeployReqInfo &) m_ReqInfo.getValue();}
void CGetDeployableCompsRequest::setCmd(const char * val){ m_Cmd.set(val); }
void CGetDeployableCompsRequest::setXmlArgs(const char * val){ m_XmlArgs.set(val); }
IEspWsDeployReqInfo & CGetDeployableCompsRequest::updateReqInfo(){ return (IEspWsDeployReqInfo &) m_ReqInfo.getValue(); }
void CGetDeployableCompsRequest::setReqInfo(IConstWsDeployReqInfo &ifrom){ m_ReqInfo.copy(ifrom); }
extern "C"  IEspGetDeployableCompsRequest *createGetDeployableCompsRequest(const char *serv){return ((IEspGetDeployableCompsRequest *)new CGetDeployableCompsRequest(serv));}
extern "C"  IClientGetDeployableCompsRequest *createClientGetDeployableCompsRequest(const char *serv){return ((IClientGetDeployableCompsRequest *)new CGetDeployableCompsRequest(serv));}

//=======================================================
// class CGetDeployableCompsResponse Implementation
//=======================================================

CGetDeployableCompsResponse::CGetDeployableCompsResponse(const char *serviceName, IRpcMessageBinding *init)
	: m_Component(nilIgnore),m_XmlArgs(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetDeployableCompsResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CGetDeployableCompsResponse::CGetDeployableCompsResponse(const char *serviceName, const char *bc)
	: m_Component(nilIgnore),m_XmlArgs(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetDeployableCompsResponse");
}

CGetDeployableCompsResponse::CGetDeployableCompsResponse(const char *serviceName, IRpcMessage* rpcmsg)
	: m_Component(nilIgnore),m_XmlArgs(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetDeployableCompsResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CGetDeployableCompsResponse::CGetDeployableCompsResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_Component(nilIgnore),m_XmlArgs(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetDeployableCompsResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CGetDeployableCompsResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		schema.append("<xsd:element name=\"Exceptions\" type=\"tns:ArrayOfEspException\" minOccurs=\"0\" maxOccurs=\"1\"/>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Component\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"XmlArgs\" type=\"xsd:string\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CGetDeployableCompsResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CGetDeployableCompsResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CGetDeployableCompsResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Component");
	form.appendf("  <tr><td><b>Component: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("XmlArgs");
	form.appendf("  <tr><td><b>XmlArgs: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CGetDeployableCompsResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CGetDeployableCompsResponse::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	rpc_resp.setEncodeXml(false);
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
		m_Component.marshall(rpc_resp, "Component", "", "", "");
		m_XmlArgs.marshall(rpc_resp, "XmlArgs", "", "", "");
	}
}


void CGetDeployableCompsResponse::copy(CGetDeployableCompsResponse &from)
{
	m_Component.copy(from.m_Component);
	m_XmlArgs.copy(from.m_XmlArgs);
}


void CGetDeployableCompsResponse::copy(IConstGetDeployableCompsResponse &ifrom)
{
	setComponent(ifrom.getComponent());
	setXmlArgs(ifrom.getXmlArgs());
}


void CGetDeployableCompsResponse::getAttributes(IProperties &attributes)
{
}


void CGetDeployableCompsResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
		m_Component.toStr(ctx, buffer, "Component", "", false, "", "");
		m_XmlArgs.toStr(ctx, buffer, "XmlArgs", "", false, "", "");
	}
}


void CGetDeployableCompsResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CGetDeployableCompsResponse::serializer(IEspContext* ctx, IConstGetDeployableCompsResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<GetDeployableCompsResponse>");
	// field Component
	{
		const char* s = src.getComponent();
		if (s && *s)
		buffer.appendf("<Component>%s</Component>",s);
	}
	// field XmlArgs
	{
		const char* s = src.getXmlArgs();
		if (s && *s)
		buffer.appendf("<XmlArgs>%s</XmlArgs>",s);
	}
	if (keepRootTag)
		buffer.append("</GetDeployableCompsResponse>");
}

bool CGetDeployableCompsResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
		hasValue |= m_Component.unmarshall(rpc_request, "Component", basepath);
		hasValue |= m_XmlArgs.unmarshall(rpc_request, "XmlArgs", basepath);
	}
	return hasValue;
}

bool CGetDeployableCompsResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Component.unmarshall(ctx, soapval, "Component");
	hasValue |= m_XmlArgs.unmarshall(ctx, soapval, "XmlArgs");
	return hasValue;
}

bool CGetDeployableCompsResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Component.unmarshall(ctx, params, attachments, "Component", basepath);
	hasValue |= m_XmlArgs.unmarshall(ctx, params, attachments, "XmlArgs", basepath);
	return hasValue;
}

const char * CGetDeployableCompsResponse::getComponent() { return m_Component.query();}
const char * CGetDeployableCompsResponse::getXmlArgs() { return m_XmlArgs.query();}
void CGetDeployableCompsResponse::setComponent(const char * val){ m_Component.set(val); }
void CGetDeployableCompsResponse::setXmlArgs(const char * val){ m_XmlArgs.set(val); }
extern "C"  IEspGetDeployableCompsResponse *createGetDeployableCompsResponse(const char *serv){return ((IEspGetDeployableCompsResponse *)new CGetDeployableCompsResponse(serv));}
extern "C"  IClientGetDeployableCompsResponse *createClientGetDeployableCompsResponse(const char *serv){return ((IClientGetDeployableCompsResponse *)new CGetDeployableCompsResponse(serv));}

//=======================================================
// class CStartDeploymentRequest Implementation
//=======================================================

CStartDeploymentRequest::CStartDeploymentRequest(const char *serviceName, IRpcMessageBinding *init)
	: m_SelComps(nilIgnore),m_Options(serviceName, nilIgnore),m_ReqInfo(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("StartDeploymentRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CStartDeploymentRequest::CStartDeploymentRequest(const char *serviceName, const char *bc)
	: m_SelComps(nilIgnore),m_Options(serviceName, nilIgnore),m_ReqInfo(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("StartDeploymentRequest");
}

CStartDeploymentRequest::CStartDeploymentRequest(const char *serviceName, IRpcMessage* rpcmsg)
	: m_SelComps(nilIgnore),m_Options(serviceName, nilIgnore),m_ReqInfo(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("StartDeploymentRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CStartDeploymentRequest::CStartDeploymentRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_SelComps(nilIgnore),m_Options(serviceName, nilIgnore),m_ReqInfo(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("StartDeploymentRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CStartDeploymentRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"SelComps\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Options\" type=\"tns:DeployOptions\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"ReqInfo\" type=\"tns:WsDeployReqInfo\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	if (!(flags & 0x10)  || (flags & 0x100))
	{
		CDeployOptions::getXsdDefinition(context, request, schema, added);
		CWsDeployReqInfo::getXsdDefinition(context, request, schema, added);
	}
	return schema;
}

void CStartDeploymentRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CStartDeploymentRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
	if (!added.getValue("DeployOptions"))
	{
		added.setValue("DeployOptions",1);
		CDeployOptions::getMapInfo(info,added);
	}
	if (!added.getValue("WsDeployReqInfo"))
	{
		added.setValue("WsDeployReqInfo",1);
		CWsDeployReqInfo::getMapInfo(info,added);
	}
}

StringBuffer &CStartDeploymentRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("SelComps");
	form.appendf("  <tr><td><b>SelComps: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Options");
	form.append("<tr>").append("<td><b>Options: </b></td><td><hr/>");
	CDeployOptions::getHtmlForm(context, request, serv, method, form, false, extfix.str());
	form.append("<hr/></td></tr>");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("ReqInfo");
	form.append("<tr>").append("<td><b>ReqInfo: </b></td><td><hr/>");
	CWsDeployReqInfo::getHtmlForm(context, request, serv, method, form, false, extfix.str());
	form.append("<hr/></td></tr>");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CStartDeploymentRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CStartDeploymentRequest::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_SelComps.marshall(rpc_resp, "SelComps", "", "", "");
	m_Options.marshall(rpc_resp, "Options", "", "", "");
	m_ReqInfo.marshall(rpc_resp, "ReqInfo", "", "", "");
}


void CStartDeploymentRequest::copy(CStartDeploymentRequest &from)
{
	m_SelComps.copy(from.m_SelComps);
	m_Options.copy(from.m_Options);
	m_ReqInfo.copy(from.m_ReqInfo);
}


void CStartDeploymentRequest::copy(IConstStartDeploymentRequest &ifrom)
{
	setSelComps(ifrom.getSelComps());
	setOptions(ifrom.getOptions());
	setReqInfo(ifrom.getReqInfo());
}


void CStartDeploymentRequest::getAttributes(IProperties &attributes)
{
}


void CStartDeploymentRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_SelComps.toStr(ctx, buffer, "SelComps", "", true, "", "");
	m_Options.toStr(ctx, buffer, "Options", "", false, "", "");
	m_ReqInfo.toStr(ctx, buffer, "ReqInfo", "", false, "", "");
}


void CStartDeploymentRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CStartDeploymentRequest::serializer(IEspContext* ctx, IConstStartDeploymentRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<StartDeploymentRequest>");
	// field SelComps
	{
		const char* s = src.getSelComps();
		if (s && *s)
		{
			buffer.append("<SelComps>");
			encodeUtf8XML(s,buffer);
			buffer.append("</SelComps>");
		}
	}
	// field Options
	{
		StringBuffer tmp;
		CDeployOptions::serializer(ctx,src.getOptions(), tmp, false);
		if (tmp.length()>0)
			buffer.appendf("<Options>%s</Options>",tmp.str());
	}
	// field ReqInfo
	{
		StringBuffer tmp;
		CWsDeployReqInfo::serializer(ctx,src.getReqInfo(), tmp, false);
		if (tmp.length()>0)
			buffer.appendf("<ReqInfo>%s</ReqInfo>",tmp.str());
	}
	if (keepRootTag)
		buffer.append("</StartDeploymentRequest>");
}

bool CStartDeploymentRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_SelComps.unmarshall(rpc_request, "SelComps", basepath);
	hasValue |= m_Options.unmarshall(rpc_request, "Options", basepath);
	hasValue |= m_ReqInfo.unmarshall(rpc_request, "ReqInfo", basepath);
	return hasValue;
}

bool CStartDeploymentRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_SelComps.unmarshall(ctx, soapval, "SelComps");
	hasValue |= m_Options.unmarshall(ctx, soapval, "Options");
	hasValue |= m_ReqInfo.unmarshall(ctx, soapval, "ReqInfo");
	return hasValue;
}

bool CStartDeploymentRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_SelComps.unmarshall(ctx, params, attachments, "SelComps", basepath);
	hasValue |= m_Options.unmarshall(ctx, params, attachments, "Options", basepath);
	hasValue |= m_ReqInfo.unmarshall(ctx, params, attachments, "ReqInfo", basepath);
	return hasValue;
}

const char * CStartDeploymentRequest::getSelComps() { return m_SelComps.query();}
IConstDeployOptions & CStartDeploymentRequest::getOptions() { return (IConstDeployOptions &) m_Options.getValue();}
IConstWsDeployReqInfo & CStartDeploymentRequest::getReqInfo() { return (IConstWsDeployReqInfo &) m_ReqInfo.getValue();}
void CStartDeploymentRequest::setSelComps(const char * val){ m_SelComps.set(val); }
IEspDeployOptions & CStartDeploymentRequest::updateOptions(){ return (IEspDeployOptions &) m_Options.getValue(); }
void CStartDeploymentRequest::setOptions(IConstDeployOptions &ifrom){ m_Options.copy(ifrom); }
IEspWsDeployReqInfo & CStartDeploymentRequest::updateReqInfo(){ return (IEspWsDeployReqInfo &) m_ReqInfo.getValue(); }
void CStartDeploymentRequest::setReqInfo(IConstWsDeployReqInfo &ifrom){ m_ReqInfo.copy(ifrom); }
extern "C"  IEspStartDeploymentRequest *createStartDeploymentRequest(const char *serv){return ((IEspStartDeploymentRequest *)new CStartDeploymentRequest(serv));}
extern "C"  IClientStartDeploymentRequest *createClientStartDeploymentRequest(const char *serv){return ((IClientStartDeploymentRequest *)new CStartDeploymentRequest(serv));}

//=======================================================
// class CStartDeploymentResponse Implementation
//=======================================================

CStartDeploymentResponse::CStartDeploymentResponse(const char *serviceName, IRpcMessageBinding *init)
	: m_Status(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("StartDeploymentResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CStartDeploymentResponse::CStartDeploymentResponse(const char *serviceName, const char *bc)
	: m_Status(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("StartDeploymentResponse");
}

CStartDeploymentResponse::CStartDeploymentResponse(const char *serviceName, IRpcMessage* rpcmsg)
	: m_Status(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("StartDeploymentResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CStartDeploymentResponse::CStartDeploymentResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_Status(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("StartDeploymentResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CStartDeploymentResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		schema.append("<xsd:element name=\"Exceptions\" type=\"tns:ArrayOfEspException\" minOccurs=\"0\" maxOccurs=\"1\"/>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Status\" type=\"xsd:string\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CStartDeploymentResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CStartDeploymentResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CStartDeploymentResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Status");
	form.appendf("  <tr><td><b>Status: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CStartDeploymentResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CStartDeploymentResponse::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	rpc_resp.setEncodeXml(false);
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
		m_Status.marshall(rpc_resp, "Status", "", "", "");
	}
}


void CStartDeploymentResponse::copy(CStartDeploymentResponse &from)
{
	m_Status.copy(from.m_Status);
}


void CStartDeploymentResponse::copy(IConstStartDeploymentResponse &ifrom)
{
	setStatus(ifrom.getStatus());
}


void CStartDeploymentResponse::getAttributes(IProperties &attributes)
{
}


void CStartDeploymentResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
		m_Status.toStr(ctx, buffer, "Status", "", false, "", "");
	}
}


void CStartDeploymentResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CStartDeploymentResponse::serializer(IEspContext* ctx, IConstStartDeploymentResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<StartDeploymentResponse>");
	// field Status
	{
		const char* s = src.getStatus();
		if (s && *s)
		buffer.appendf("<Status>%s</Status>",s);
	}
	if (keepRootTag)
		buffer.append("</StartDeploymentResponse>");
}

bool CStartDeploymentResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
		hasValue |= m_Status.unmarshall(rpc_request, "Status", basepath);
	}
	return hasValue;
}

bool CStartDeploymentResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Status.unmarshall(ctx, soapval, "Status");
	return hasValue;
}

bool CStartDeploymentResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Status.unmarshall(ctx, params, attachments, "Status", basepath);
	return hasValue;
}

const char * CStartDeploymentResponse::getStatus() { return m_Status.query();}
void CStartDeploymentResponse::setStatus(const char * val){ m_Status.set(val); }
extern "C"  IEspStartDeploymentResponse *createStartDeploymentResponse(const char *serv){return ((IEspStartDeploymentResponse *)new CStartDeploymentResponse(serv));}
extern "C"  IClientStartDeploymentResponse *createClientStartDeploymentResponse(const char *serv){return ((IClientStartDeploymentResponse *)new CStartDeploymentResponse(serv));}

//=======================================================
// class CGetBuildServerDirsRequest Implementation
//=======================================================

CGetBuildServerDirsRequest::CGetBuildServerDirsRequest(const char *serviceName, IRpcMessageBinding *init)
	: m_Cmd(nilIgnore),m_XmlArgs(nilIgnore),m_ReqInfo(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetBuildServerDirsRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CGetBuildServerDirsRequest::CGetBuildServerDirsRequest(const char *serviceName, const char *bc)
	: m_Cmd(nilIgnore),m_XmlArgs(nilIgnore),m_ReqInfo(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetBuildServerDirsRequest");
}

CGetBuildServerDirsRequest::CGetBuildServerDirsRequest(const char *serviceName, IRpcMessage* rpcmsg)
	: m_Cmd(nilIgnore),m_XmlArgs(nilIgnore),m_ReqInfo(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetBuildServerDirsRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CGetBuildServerDirsRequest::CGetBuildServerDirsRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_Cmd(nilIgnore),m_XmlArgs(nilIgnore),m_ReqInfo(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetBuildServerDirsRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CGetBuildServerDirsRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Cmd\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"XmlArgs\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"ReqInfo\" type=\"tns:WsDeployReqInfo\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	if (!(flags & 0x10)  || (flags & 0x100))
	{
		CWsDeployReqInfo::getXsdDefinition(context, request, schema, added);
	}
	return schema;
}

void CGetBuildServerDirsRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CGetBuildServerDirsRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
	if (!added.getValue("WsDeployReqInfo"))
	{
		added.setValue("WsDeployReqInfo",1);
		CWsDeployReqInfo::getMapInfo(info,added);
	}
}

StringBuffer &CGetBuildServerDirsRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Cmd");
	form.appendf("  <tr><td><b>Cmd: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("XmlArgs");
	form.appendf("  <tr><td><b>XmlArgs: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("ReqInfo");
	form.append("<tr>").append("<td><b>ReqInfo: </b></td><td><hr/>");
	CWsDeployReqInfo::getHtmlForm(context, request, serv, method, form, false, extfix.str());
	form.append("<hr/></td></tr>");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CGetBuildServerDirsRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CGetBuildServerDirsRequest::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_Cmd.marshall(rpc_resp, "Cmd", "", "", "");
	m_XmlArgs.marshall(rpc_resp, "XmlArgs", "", "", "");
	m_ReqInfo.marshall(rpc_resp, "ReqInfo", "", "", "");
}


void CGetBuildServerDirsRequest::copy(CGetBuildServerDirsRequest &from)
{
	m_Cmd.copy(from.m_Cmd);
	m_XmlArgs.copy(from.m_XmlArgs);
	m_ReqInfo.copy(from.m_ReqInfo);
}


void CGetBuildServerDirsRequest::copy(IConstGetBuildServerDirsRequest &ifrom)
{
	setCmd(ifrom.getCmd());
	setXmlArgs(ifrom.getXmlArgs());
	setReqInfo(ifrom.getReqInfo());
}


void CGetBuildServerDirsRequest::getAttributes(IProperties &attributes)
{
}


void CGetBuildServerDirsRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_Cmd.toStr(ctx, buffer, "Cmd", "", true, "", "");
	m_XmlArgs.toStr(ctx, buffer, "XmlArgs", "", true, "", "");
	m_ReqInfo.toStr(ctx, buffer, "ReqInfo", "", false, "", "");
}


void CGetBuildServerDirsRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CGetBuildServerDirsRequest::serializer(IEspContext* ctx, IConstGetBuildServerDirsRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<GetBuildServerDirsRequest>");
	// field Cmd
	{
		const char* s = src.getCmd();
		if (s && *s)
		{
			buffer.append("<Cmd>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Cmd>");
		}
	}
	// field XmlArgs
	{
		const char* s = src.getXmlArgs();
		if (s && *s)
		{
			buffer.append("<XmlArgs>");
			encodeUtf8XML(s,buffer);
			buffer.append("</XmlArgs>");
		}
	}
	// field ReqInfo
	{
		StringBuffer tmp;
		CWsDeployReqInfo::serializer(ctx,src.getReqInfo(), tmp, false);
		if (tmp.length()>0)
			buffer.appendf("<ReqInfo>%s</ReqInfo>",tmp.str());
	}
	if (keepRootTag)
		buffer.append("</GetBuildServerDirsRequest>");
}

bool CGetBuildServerDirsRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_Cmd.unmarshall(rpc_request, "Cmd", basepath);
	hasValue |= m_XmlArgs.unmarshall(rpc_request, "XmlArgs", basepath);
	hasValue |= m_ReqInfo.unmarshall(rpc_request, "ReqInfo", basepath);
	return hasValue;
}

bool CGetBuildServerDirsRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Cmd.unmarshall(ctx, soapval, "Cmd");
	hasValue |= m_XmlArgs.unmarshall(ctx, soapval, "XmlArgs");
	hasValue |= m_ReqInfo.unmarshall(ctx, soapval, "ReqInfo");
	return hasValue;
}

bool CGetBuildServerDirsRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Cmd.unmarshall(ctx, params, attachments, "Cmd", basepath);
	hasValue |= m_XmlArgs.unmarshall(ctx, params, attachments, "XmlArgs", basepath);
	hasValue |= m_ReqInfo.unmarshall(ctx, params, attachments, "ReqInfo", basepath);
	return hasValue;
}

const char * CGetBuildServerDirsRequest::getCmd() { return m_Cmd.query();}
const char * CGetBuildServerDirsRequest::getXmlArgs() { return m_XmlArgs.query();}
IConstWsDeployReqInfo & CGetBuildServerDirsRequest::getReqInfo() { return (IConstWsDeployReqInfo &) m_ReqInfo.getValue();}
void CGetBuildServerDirsRequest::setCmd(const char * val){ m_Cmd.set(val); }
void CGetBuildServerDirsRequest::setXmlArgs(const char * val){ m_XmlArgs.set(val); }
IEspWsDeployReqInfo & CGetBuildServerDirsRequest::updateReqInfo(){ return (IEspWsDeployReqInfo &) m_ReqInfo.getValue(); }
void CGetBuildServerDirsRequest::setReqInfo(IConstWsDeployReqInfo &ifrom){ m_ReqInfo.copy(ifrom); }
extern "C"  IEspGetBuildServerDirsRequest *createGetBuildServerDirsRequest(const char *serv){return ((IEspGetBuildServerDirsRequest *)new CGetBuildServerDirsRequest(serv));}
extern "C"  IClientGetBuildServerDirsRequest *createClientGetBuildServerDirsRequest(const char *serv){return ((IClientGetBuildServerDirsRequest *)new CGetBuildServerDirsRequest(serv));}

//=======================================================
// class CGetBuildServerDirsResponse Implementation
//=======================================================

CGetBuildServerDirsResponse::CGetBuildServerDirsResponse(const char *serviceName, IRpcMessageBinding *init)
	: m_Component(nilIgnore),m_XmlArgs(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetBuildServerDirsResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CGetBuildServerDirsResponse::CGetBuildServerDirsResponse(const char *serviceName, const char *bc)
	: m_Component(nilIgnore),m_XmlArgs(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetBuildServerDirsResponse");
}

CGetBuildServerDirsResponse::CGetBuildServerDirsResponse(const char *serviceName, IRpcMessage* rpcmsg)
	: m_Component(nilIgnore),m_XmlArgs(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetBuildServerDirsResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CGetBuildServerDirsResponse::CGetBuildServerDirsResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_Component(nilIgnore),m_XmlArgs(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetBuildServerDirsResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CGetBuildServerDirsResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		schema.append("<xsd:element name=\"Exceptions\" type=\"tns:ArrayOfEspException\" minOccurs=\"0\" maxOccurs=\"1\"/>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Component\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"XmlArgs\" type=\"xsd:string\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CGetBuildServerDirsResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CGetBuildServerDirsResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CGetBuildServerDirsResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Component");
	form.appendf("  <tr><td><b>Component: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("XmlArgs");
	form.appendf("  <tr><td><b>XmlArgs: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CGetBuildServerDirsResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CGetBuildServerDirsResponse::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	rpc_resp.setEncodeXml(false);
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
		m_Component.marshall(rpc_resp, "Component", "", "", "");
		m_XmlArgs.marshall(rpc_resp, "XmlArgs", "", "", "");
	}
}


void CGetBuildServerDirsResponse::copy(CGetBuildServerDirsResponse &from)
{
	m_Component.copy(from.m_Component);
	m_XmlArgs.copy(from.m_XmlArgs);
}


void CGetBuildServerDirsResponse::copy(IConstGetBuildServerDirsResponse &ifrom)
{
	setComponent(ifrom.getComponent());
	setXmlArgs(ifrom.getXmlArgs());
}


void CGetBuildServerDirsResponse::getAttributes(IProperties &attributes)
{
}


void CGetBuildServerDirsResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
		m_Component.toStr(ctx, buffer, "Component", "", false, "", "");
		m_XmlArgs.toStr(ctx, buffer, "XmlArgs", "", false, "", "");
	}
}


void CGetBuildServerDirsResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CGetBuildServerDirsResponse::serializer(IEspContext* ctx, IConstGetBuildServerDirsResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<GetBuildServerDirsResponse>");
	// field Component
	{
		const char* s = src.getComponent();
		if (s && *s)
		buffer.appendf("<Component>%s</Component>",s);
	}
	// field XmlArgs
	{
		const char* s = src.getXmlArgs();
		if (s && *s)
		buffer.appendf("<XmlArgs>%s</XmlArgs>",s);
	}
	if (keepRootTag)
		buffer.append("</GetBuildServerDirsResponse>");
}

bool CGetBuildServerDirsResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
		hasValue |= m_Component.unmarshall(rpc_request, "Component", basepath);
		hasValue |= m_XmlArgs.unmarshall(rpc_request, "XmlArgs", basepath);
	}
	return hasValue;
}

bool CGetBuildServerDirsResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Component.unmarshall(ctx, soapval, "Component");
	hasValue |= m_XmlArgs.unmarshall(ctx, soapval, "XmlArgs");
	return hasValue;
}

bool CGetBuildServerDirsResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Component.unmarshall(ctx, params, attachments, "Component", basepath);
	hasValue |= m_XmlArgs.unmarshall(ctx, params, attachments, "XmlArgs", basepath);
	return hasValue;
}

const char * CGetBuildServerDirsResponse::getComponent() { return m_Component.query();}
const char * CGetBuildServerDirsResponse::getXmlArgs() { return m_XmlArgs.query();}
void CGetBuildServerDirsResponse::setComponent(const char * val){ m_Component.set(val); }
void CGetBuildServerDirsResponse::setXmlArgs(const char * val){ m_XmlArgs.set(val); }
extern "C"  IEspGetBuildServerDirsResponse *createGetBuildServerDirsResponse(const char *serv){return ((IEspGetBuildServerDirsResponse *)new CGetBuildServerDirsResponse(serv));}
extern "C"  IClientGetBuildServerDirsResponse *createClientGetBuildServerDirsResponse(const char *serv){return ((IClientGetBuildServerDirsResponse *)new CGetBuildServerDirsResponse(serv));}

//=======================================================
// class CImportBuildRequest Implementation
//=======================================================

CImportBuildRequest::CImportBuildRequest(const char *serviceName, IRpcMessageBinding *init)
	: m_BuildName(nilIgnore),m_BuildUrl(nilIgnore),m_BuildSets(nilIgnore),m_ReqInfo(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ImportBuildRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CImportBuildRequest::CImportBuildRequest(const char *serviceName, const char *bc)
	: m_BuildName(nilIgnore),m_BuildUrl(nilIgnore),m_BuildSets(nilIgnore),m_ReqInfo(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ImportBuildRequest");
}

CImportBuildRequest::CImportBuildRequest(const char *serviceName, IRpcMessage* rpcmsg)
	: m_BuildName(nilIgnore),m_BuildUrl(nilIgnore),m_BuildSets(nilIgnore),m_ReqInfo(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ImportBuildRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CImportBuildRequest::CImportBuildRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_BuildName(nilIgnore),m_BuildUrl(nilIgnore),m_BuildSets(nilIgnore),m_ReqInfo(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ImportBuildRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CImportBuildRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"BuildName\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"BuildUrl\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"BuildSets\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"ReqInfo\" type=\"tns:WsDeployReqInfo\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	if (!(flags & 0x10)  || (flags & 0x100))
	{
		CWsDeployReqInfo::getXsdDefinition(context, request, schema, added);
	}
	return schema;
}

void CImportBuildRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CImportBuildRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
	if (!added.getValue("WsDeployReqInfo"))
	{
		added.setValue("WsDeployReqInfo",1);
		CWsDeployReqInfo::getMapInfo(info,added);
	}
}

StringBuffer &CImportBuildRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("BuildName");
	form.appendf("  <tr><td><b>BuildName: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("BuildUrl");
	form.appendf("  <tr><td><b>BuildUrl: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("BuildSets");
	form.appendf("  <tr><td><b>BuildSets: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("ReqInfo");
	form.append("<tr>").append("<td><b>ReqInfo: </b></td><td><hr/>");
	CWsDeployReqInfo::getHtmlForm(context, request, serv, method, form, false, extfix.str());
	form.append("<hr/></td></tr>");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CImportBuildRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CImportBuildRequest::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_BuildName.marshall(rpc_resp, "BuildName", "", "", "");
	m_BuildUrl.marshall(rpc_resp, "BuildUrl", "", "", "");
	m_BuildSets.marshall(rpc_resp, "BuildSets", "", "", "");
	m_ReqInfo.marshall(rpc_resp, "ReqInfo", "", "", "");
}


void CImportBuildRequest::copy(CImportBuildRequest &from)
{
	m_BuildName.copy(from.m_BuildName);
	m_BuildUrl.copy(from.m_BuildUrl);
	m_BuildSets.copy(from.m_BuildSets);
	m_ReqInfo.copy(from.m_ReqInfo);
}


void CImportBuildRequest::copy(IConstImportBuildRequest &ifrom)
{
	setBuildName(ifrom.getBuildName());
	setBuildUrl(ifrom.getBuildUrl());
	setBuildSets(ifrom.getBuildSets());
	setReqInfo(ifrom.getReqInfo());
}


void CImportBuildRequest::getAttributes(IProperties &attributes)
{
}


void CImportBuildRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_BuildName.toStr(ctx, buffer, "BuildName", "", true, "", "");
	m_BuildUrl.toStr(ctx, buffer, "BuildUrl", "", true, "", "");
	m_BuildSets.toStr(ctx, buffer, "BuildSets", "", true, "", "");
	m_ReqInfo.toStr(ctx, buffer, "ReqInfo", "", false, "", "");
}


void CImportBuildRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CImportBuildRequest::serializer(IEspContext* ctx, IConstImportBuildRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<ImportBuildRequest>");
	// field BuildName
	{
		const char* s = src.getBuildName();
		if (s && *s)
		{
			buffer.append("<BuildName>");
			encodeUtf8XML(s,buffer);
			buffer.append("</BuildName>");
		}
	}
	// field BuildUrl
	{
		const char* s = src.getBuildUrl();
		if (s && *s)
		{
			buffer.append("<BuildUrl>");
			encodeUtf8XML(s,buffer);
			buffer.append("</BuildUrl>");
		}
	}
	// field BuildSets
	{
		const char* s = src.getBuildSets();
		if (s && *s)
		{
			buffer.append("<BuildSets>");
			encodeUtf8XML(s,buffer);
			buffer.append("</BuildSets>");
		}
	}
	// field ReqInfo
	{
		StringBuffer tmp;
		CWsDeployReqInfo::serializer(ctx,src.getReqInfo(), tmp, false);
		if (tmp.length()>0)
			buffer.appendf("<ReqInfo>%s</ReqInfo>",tmp.str());
	}
	if (keepRootTag)
		buffer.append("</ImportBuildRequest>");
}

bool CImportBuildRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_BuildName.unmarshall(rpc_request, "BuildName", basepath);
	hasValue |= m_BuildUrl.unmarshall(rpc_request, "BuildUrl", basepath);
	hasValue |= m_BuildSets.unmarshall(rpc_request, "BuildSets", basepath);
	hasValue |= m_ReqInfo.unmarshall(rpc_request, "ReqInfo", basepath);
	return hasValue;
}

bool CImportBuildRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_BuildName.unmarshall(ctx, soapval, "BuildName");
	hasValue |= m_BuildUrl.unmarshall(ctx, soapval, "BuildUrl");
	hasValue |= m_BuildSets.unmarshall(ctx, soapval, "BuildSets");
	hasValue |= m_ReqInfo.unmarshall(ctx, soapval, "ReqInfo");
	return hasValue;
}

bool CImportBuildRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_BuildName.unmarshall(ctx, params, attachments, "BuildName", basepath);
	hasValue |= m_BuildUrl.unmarshall(ctx, params, attachments, "BuildUrl", basepath);
	hasValue |= m_BuildSets.unmarshall(ctx, params, attachments, "BuildSets", basepath);
	hasValue |= m_ReqInfo.unmarshall(ctx, params, attachments, "ReqInfo", basepath);
	return hasValue;
}

const char * CImportBuildRequest::getBuildName() { return m_BuildName.query();}
const char * CImportBuildRequest::getBuildUrl() { return m_BuildUrl.query();}
const char * CImportBuildRequest::getBuildSets() { return m_BuildSets.query();}
IConstWsDeployReqInfo & CImportBuildRequest::getReqInfo() { return (IConstWsDeployReqInfo &) m_ReqInfo.getValue();}
void CImportBuildRequest::setBuildName(const char * val){ m_BuildName.set(val); }
void CImportBuildRequest::setBuildUrl(const char * val){ m_BuildUrl.set(val); }
void CImportBuildRequest::setBuildSets(const char * val){ m_BuildSets.set(val); }
IEspWsDeployReqInfo & CImportBuildRequest::updateReqInfo(){ return (IEspWsDeployReqInfo &) m_ReqInfo.getValue(); }
void CImportBuildRequest::setReqInfo(IConstWsDeployReqInfo &ifrom){ m_ReqInfo.copy(ifrom); }
extern "C"  IEspImportBuildRequest *createImportBuildRequest(const char *serv){return ((IEspImportBuildRequest *)new CImportBuildRequest(serv));}
extern "C"  IClientImportBuildRequest *createClientImportBuildRequest(const char *serv){return ((IClientImportBuildRequest *)new CImportBuildRequest(serv));}

//=======================================================
// class CImportBuildResponse Implementation
//=======================================================

CImportBuildResponse::CImportBuildResponse(const char *serviceName, IRpcMessageBinding *init)
	: m_Status(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ImportBuildResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CImportBuildResponse::CImportBuildResponse(const char *serviceName, const char *bc)
	: m_Status(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ImportBuildResponse");
}

CImportBuildResponse::CImportBuildResponse(const char *serviceName, IRpcMessage* rpcmsg)
	: m_Status(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ImportBuildResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CImportBuildResponse::CImportBuildResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_Status(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ImportBuildResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CImportBuildResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		schema.append("<xsd:element name=\"Exceptions\" type=\"tns:ArrayOfEspException\" minOccurs=\"0\" maxOccurs=\"1\"/>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Status\" type=\"xsd:string\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CImportBuildResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CImportBuildResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CImportBuildResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Status");
	form.appendf("  <tr><td><b>Status: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CImportBuildResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CImportBuildResponse::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	rpc_resp.setEncodeXml(false);
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
		m_Status.marshall(rpc_resp, "Status", "", "", "");
	}
}


void CImportBuildResponse::copy(CImportBuildResponse &from)
{
	m_Status.copy(from.m_Status);
}


void CImportBuildResponse::copy(IConstImportBuildResponse &ifrom)
{
	setStatus(ifrom.getStatus());
}


void CImportBuildResponse::getAttributes(IProperties &attributes)
{
}


void CImportBuildResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
		m_Status.toStr(ctx, buffer, "Status", "", false, "", "");
	}
}


void CImportBuildResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CImportBuildResponse::serializer(IEspContext* ctx, IConstImportBuildResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<ImportBuildResponse>");
	// field Status
	{
		const char* s = src.getStatus();
		if (s && *s)
		buffer.appendf("<Status>%s</Status>",s);
	}
	if (keepRootTag)
		buffer.append("</ImportBuildResponse>");
}

bool CImportBuildResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
		hasValue |= m_Status.unmarshall(rpc_request, "Status", basepath);
	}
	return hasValue;
}

bool CImportBuildResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Status.unmarshall(ctx, soapval, "Status");
	return hasValue;
}

bool CImportBuildResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Status.unmarshall(ctx, params, attachments, "Status", basepath);
	return hasValue;
}

const char * CImportBuildResponse::getStatus() { return m_Status.query();}
void CImportBuildResponse::setStatus(const char * val){ m_Status.set(val); }
extern "C"  IEspImportBuildResponse *createImportBuildResponse(const char *serv){return ((IEspImportBuildResponse *)new CImportBuildResponse(serv));}
extern "C"  IClientImportBuildResponse *createClientImportBuildResponse(const char *serv){return ((IClientImportBuildResponse *)new CImportBuildResponse(serv));}

//=======================================================
// class CGetComputersForRoxieRequest Implementation
//=======================================================

CGetComputersForRoxieRequest::CGetComputersForRoxieRequest(const char *serviceName, IRpcMessageBinding *init)
	: m_Cmd(nilIgnore),m_XmlArgs(nilIgnore),m_ReqInfo(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetComputersForRoxieRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CGetComputersForRoxieRequest::CGetComputersForRoxieRequest(const char *serviceName, const char *bc)
	: m_Cmd(nilIgnore),m_XmlArgs(nilIgnore),m_ReqInfo(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetComputersForRoxieRequest");
}

CGetComputersForRoxieRequest::CGetComputersForRoxieRequest(const char *serviceName, IRpcMessage* rpcmsg)
	: m_Cmd(nilIgnore),m_XmlArgs(nilIgnore),m_ReqInfo(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetComputersForRoxieRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CGetComputersForRoxieRequest::CGetComputersForRoxieRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_Cmd(nilIgnore),m_XmlArgs(nilIgnore),m_ReqInfo(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetComputersForRoxieRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CGetComputersForRoxieRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Cmd\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"XmlArgs\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"ReqInfo\" type=\"tns:WsDeployReqInfo\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	if (!(flags & 0x10)  || (flags & 0x100))
	{
		CWsDeployReqInfo::getXsdDefinition(context, request, schema, added);
	}
	return schema;
}

void CGetComputersForRoxieRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CGetComputersForRoxieRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
	if (!added.getValue("WsDeployReqInfo"))
	{
		added.setValue("WsDeployReqInfo",1);
		CWsDeployReqInfo::getMapInfo(info,added);
	}
}

StringBuffer &CGetComputersForRoxieRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Cmd");
	form.appendf("  <tr><td><b>Cmd: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("XmlArgs");
	form.appendf("  <tr><td><b>XmlArgs: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("ReqInfo");
	form.append("<tr>").append("<td><b>ReqInfo: </b></td><td><hr/>");
	CWsDeployReqInfo::getHtmlForm(context, request, serv, method, form, false, extfix.str());
	form.append("<hr/></td></tr>");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CGetComputersForRoxieRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CGetComputersForRoxieRequest::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_Cmd.marshall(rpc_resp, "Cmd", "", "", "");
	m_XmlArgs.marshall(rpc_resp, "XmlArgs", "", "", "");
	m_ReqInfo.marshall(rpc_resp, "ReqInfo", "", "", "");
}


void CGetComputersForRoxieRequest::copy(CGetComputersForRoxieRequest &from)
{
	m_Cmd.copy(from.m_Cmd);
	m_XmlArgs.copy(from.m_XmlArgs);
	m_ReqInfo.copy(from.m_ReqInfo);
}


void CGetComputersForRoxieRequest::copy(IConstGetComputersForRoxieRequest &ifrom)
{
	setCmd(ifrom.getCmd());
	setXmlArgs(ifrom.getXmlArgs());
	setReqInfo(ifrom.getReqInfo());
}


void CGetComputersForRoxieRequest::getAttributes(IProperties &attributes)
{
}


void CGetComputersForRoxieRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_Cmd.toStr(ctx, buffer, "Cmd", "", true, "", "");
	m_XmlArgs.toStr(ctx, buffer, "XmlArgs", "", true, "", "");
	m_ReqInfo.toStr(ctx, buffer, "ReqInfo", "", false, "", "");
}


void CGetComputersForRoxieRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CGetComputersForRoxieRequest::serializer(IEspContext* ctx, IConstGetComputersForRoxieRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<GetComputersForRoxieRequest>");
	// field Cmd
	{
		const char* s = src.getCmd();
		if (s && *s)
		{
			buffer.append("<Cmd>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Cmd>");
		}
	}
	// field XmlArgs
	{
		const char* s = src.getXmlArgs();
		if (s && *s)
		{
			buffer.append("<XmlArgs>");
			encodeUtf8XML(s,buffer);
			buffer.append("</XmlArgs>");
		}
	}
	// field ReqInfo
	{
		StringBuffer tmp;
		CWsDeployReqInfo::serializer(ctx,src.getReqInfo(), tmp, false);
		if (tmp.length()>0)
			buffer.appendf("<ReqInfo>%s</ReqInfo>",tmp.str());
	}
	if (keepRootTag)
		buffer.append("</GetComputersForRoxieRequest>");
}

bool CGetComputersForRoxieRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_Cmd.unmarshall(rpc_request, "Cmd", basepath);
	hasValue |= m_XmlArgs.unmarshall(rpc_request, "XmlArgs", basepath);
	hasValue |= m_ReqInfo.unmarshall(rpc_request, "ReqInfo", basepath);
	return hasValue;
}

bool CGetComputersForRoxieRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Cmd.unmarshall(ctx, soapval, "Cmd");
	hasValue |= m_XmlArgs.unmarshall(ctx, soapval, "XmlArgs");
	hasValue |= m_ReqInfo.unmarshall(ctx, soapval, "ReqInfo");
	return hasValue;
}

bool CGetComputersForRoxieRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Cmd.unmarshall(ctx, params, attachments, "Cmd", basepath);
	hasValue |= m_XmlArgs.unmarshall(ctx, params, attachments, "XmlArgs", basepath);
	hasValue |= m_ReqInfo.unmarshall(ctx, params, attachments, "ReqInfo", basepath);
	return hasValue;
}

const char * CGetComputersForRoxieRequest::getCmd() { return m_Cmd.query();}
const char * CGetComputersForRoxieRequest::getXmlArgs() { return m_XmlArgs.query();}
IConstWsDeployReqInfo & CGetComputersForRoxieRequest::getReqInfo() { return (IConstWsDeployReqInfo &) m_ReqInfo.getValue();}
void CGetComputersForRoxieRequest::setCmd(const char * val){ m_Cmd.set(val); }
void CGetComputersForRoxieRequest::setXmlArgs(const char * val){ m_XmlArgs.set(val); }
IEspWsDeployReqInfo & CGetComputersForRoxieRequest::updateReqInfo(){ return (IEspWsDeployReqInfo &) m_ReqInfo.getValue(); }
void CGetComputersForRoxieRequest::setReqInfo(IConstWsDeployReqInfo &ifrom){ m_ReqInfo.copy(ifrom); }
extern "C"  IEspGetComputersForRoxieRequest *createGetComputersForRoxieRequest(const char *serv){return ((IEspGetComputersForRoxieRequest *)new CGetComputersForRoxieRequest(serv));}
extern "C"  IClientGetComputersForRoxieRequest *createClientGetComputersForRoxieRequest(const char *serv){return ((IClientGetComputersForRoxieRequest *)new CGetComputersForRoxieRequest(serv));}

//=======================================================
// class CGetComputersForRoxieResponse Implementation
//=======================================================

CGetComputersForRoxieResponse::CGetComputersForRoxieResponse(const char *serviceName, IRpcMessageBinding *init)
	: m_Computers(nilIgnore),m_Filters(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetComputersForRoxieResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CGetComputersForRoxieResponse::CGetComputersForRoxieResponse(const char *serviceName, const char *bc)
	: m_Computers(nilIgnore),m_Filters(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetComputersForRoxieResponse");
}

CGetComputersForRoxieResponse::CGetComputersForRoxieResponse(const char *serviceName, IRpcMessage* rpcmsg)
	: m_Computers(nilIgnore),m_Filters(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetComputersForRoxieResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CGetComputersForRoxieResponse::CGetComputersForRoxieResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_Computers(nilIgnore),m_Filters(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetComputersForRoxieResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CGetComputersForRoxieResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		schema.append("<xsd:element name=\"Exceptions\" type=\"tns:ArrayOfEspException\" minOccurs=\"0\" maxOccurs=\"1\"/>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Computers\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Filters\" type=\"xsd:string\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CGetComputersForRoxieResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CGetComputersForRoxieResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CGetComputersForRoxieResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Computers");
	form.appendf("  <tr><td><b>Computers: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Filters");
	form.appendf("  <tr><td><b>Filters: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CGetComputersForRoxieResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CGetComputersForRoxieResponse::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	rpc_resp.setEncodeXml(false);
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
		m_Computers.marshall(rpc_resp, "Computers", "", "", "");
		m_Filters.marshall(rpc_resp, "Filters", "", "", "");
	}
}


void CGetComputersForRoxieResponse::copy(CGetComputersForRoxieResponse &from)
{
	m_Computers.copy(from.m_Computers);
	m_Filters.copy(from.m_Filters);
}


void CGetComputersForRoxieResponse::copy(IConstGetComputersForRoxieResponse &ifrom)
{
	setComputers(ifrom.getComputers());
	setFilters(ifrom.getFilters());
}


void CGetComputersForRoxieResponse::getAttributes(IProperties &attributes)
{
}


void CGetComputersForRoxieResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
		m_Computers.toStr(ctx, buffer, "Computers", "", false, "", "");
		m_Filters.toStr(ctx, buffer, "Filters", "", false, "", "");
	}
}


void CGetComputersForRoxieResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CGetComputersForRoxieResponse::serializer(IEspContext* ctx, IConstGetComputersForRoxieResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<GetComputersForRoxieResponse>");
	// field Computers
	{
		const char* s = src.getComputers();
		if (s && *s)
		buffer.appendf("<Computers>%s</Computers>",s);
	}
	// field Filters
	{
		const char* s = src.getFilters();
		if (s && *s)
		buffer.appendf("<Filters>%s</Filters>",s);
	}
	if (keepRootTag)
		buffer.append("</GetComputersForRoxieResponse>");
}

bool CGetComputersForRoxieResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
		hasValue |= m_Computers.unmarshall(rpc_request, "Computers", basepath);
		hasValue |= m_Filters.unmarshall(rpc_request, "Filters", basepath);
	}
	return hasValue;
}

bool CGetComputersForRoxieResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Computers.unmarshall(ctx, soapval, "Computers");
	hasValue |= m_Filters.unmarshall(ctx, soapval, "Filters");
	return hasValue;
}

bool CGetComputersForRoxieResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Computers.unmarshall(ctx, params, attachments, "Computers", basepath);
	hasValue |= m_Filters.unmarshall(ctx, params, attachments, "Filters", basepath);
	return hasValue;
}

const char * CGetComputersForRoxieResponse::getComputers() { return m_Computers.query();}
const char * CGetComputersForRoxieResponse::getFilters() { return m_Filters.query();}
void CGetComputersForRoxieResponse::setComputers(const char * val){ m_Computers.set(val); }
void CGetComputersForRoxieResponse::setFilters(const char * val){ m_Filters.set(val); }
extern "C"  IEspGetComputersForRoxieResponse *createGetComputersForRoxieResponse(const char *serv){return ((IEspGetComputersForRoxieResponse *)new CGetComputersForRoxieResponse(serv));}
extern "C"  IClientGetComputersForRoxieResponse *createClientGetComputersForRoxieResponse(const char *serv){return ((IClientGetComputersForRoxieResponse *)new CGetComputersForRoxieResponse(serv));}

//=======================================================
// class CHandleRoxieOperationRequest Implementation
//=======================================================

CHandleRoxieOperationRequest::CHandleRoxieOperationRequest(const char *serviceName, IRpcMessageBinding *init)
	: m_Cmd(nilIgnore),m_XmlArgs(nilIgnore),m_ReqInfo(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("HandleRoxieOperationRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CHandleRoxieOperationRequest::CHandleRoxieOperationRequest(const char *serviceName, const char *bc)
	: m_Cmd(nilIgnore),m_XmlArgs(nilIgnore),m_ReqInfo(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("HandleRoxieOperationRequest");
}

CHandleRoxieOperationRequest::CHandleRoxieOperationRequest(const char *serviceName, IRpcMessage* rpcmsg)
	: m_Cmd(nilIgnore),m_XmlArgs(nilIgnore),m_ReqInfo(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("HandleRoxieOperationRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CHandleRoxieOperationRequest::CHandleRoxieOperationRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_Cmd(nilIgnore),m_XmlArgs(nilIgnore),m_ReqInfo(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("HandleRoxieOperationRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CHandleRoxieOperationRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Cmd\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"XmlArgs\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"ReqInfo\" type=\"tns:WsDeployReqInfo\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	if (!(flags & 0x10)  || (flags & 0x100))
	{
		CWsDeployReqInfo::getXsdDefinition(context, request, schema, added);
	}
	return schema;
}

void CHandleRoxieOperationRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CHandleRoxieOperationRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
	if (!added.getValue("WsDeployReqInfo"))
	{
		added.setValue("WsDeployReqInfo",1);
		CWsDeployReqInfo::getMapInfo(info,added);
	}
}

StringBuffer &CHandleRoxieOperationRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Cmd");
	form.appendf("  <tr><td><b>Cmd: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("XmlArgs");
	form.appendf("  <tr><td><b>XmlArgs: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("ReqInfo");
	form.append("<tr>").append("<td><b>ReqInfo: </b></td><td><hr/>");
	CWsDeployReqInfo::getHtmlForm(context, request, serv, method, form, false, extfix.str());
	form.append("<hr/></td></tr>");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CHandleRoxieOperationRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CHandleRoxieOperationRequest::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_Cmd.marshall(rpc_resp, "Cmd", "", "", "");
	m_XmlArgs.marshall(rpc_resp, "XmlArgs", "", "", "");
	m_ReqInfo.marshall(rpc_resp, "ReqInfo", "", "", "");
}


void CHandleRoxieOperationRequest::copy(CHandleRoxieOperationRequest &from)
{
	m_Cmd.copy(from.m_Cmd);
	m_XmlArgs.copy(from.m_XmlArgs);
	m_ReqInfo.copy(from.m_ReqInfo);
}


void CHandleRoxieOperationRequest::copy(IConstHandleRoxieOperationRequest &ifrom)
{
	setCmd(ifrom.getCmd());
	setXmlArgs(ifrom.getXmlArgs());
	setReqInfo(ifrom.getReqInfo());
}


void CHandleRoxieOperationRequest::getAttributes(IProperties &attributes)
{
}


void CHandleRoxieOperationRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_Cmd.toStr(ctx, buffer, "Cmd", "", true, "", "");
	m_XmlArgs.toStr(ctx, buffer, "XmlArgs", "", true, "", "");
	m_ReqInfo.toStr(ctx, buffer, "ReqInfo", "", false, "", "");
}


void CHandleRoxieOperationRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CHandleRoxieOperationRequest::serializer(IEspContext* ctx, IConstHandleRoxieOperationRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<HandleRoxieOperationRequest>");
	// field Cmd
	{
		const char* s = src.getCmd();
		if (s && *s)
		{
			buffer.append("<Cmd>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Cmd>");
		}
	}
	// field XmlArgs
	{
		const char* s = src.getXmlArgs();
		if (s && *s)
		{
			buffer.append("<XmlArgs>");
			encodeUtf8XML(s,buffer);
			buffer.append("</XmlArgs>");
		}
	}
	// field ReqInfo
	{
		StringBuffer tmp;
		CWsDeployReqInfo::serializer(ctx,src.getReqInfo(), tmp, false);
		if (tmp.length()>0)
			buffer.appendf("<ReqInfo>%s</ReqInfo>",tmp.str());
	}
	if (keepRootTag)
		buffer.append("</HandleRoxieOperationRequest>");
}

bool CHandleRoxieOperationRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_Cmd.unmarshall(rpc_request, "Cmd", basepath);
	hasValue |= m_XmlArgs.unmarshall(rpc_request, "XmlArgs", basepath);
	hasValue |= m_ReqInfo.unmarshall(rpc_request, "ReqInfo", basepath);
	return hasValue;
}

bool CHandleRoxieOperationRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Cmd.unmarshall(ctx, soapval, "Cmd");
	hasValue |= m_XmlArgs.unmarshall(ctx, soapval, "XmlArgs");
	hasValue |= m_ReqInfo.unmarshall(ctx, soapval, "ReqInfo");
	return hasValue;
}

bool CHandleRoxieOperationRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Cmd.unmarshall(ctx, params, attachments, "Cmd", basepath);
	hasValue |= m_XmlArgs.unmarshall(ctx, params, attachments, "XmlArgs", basepath);
	hasValue |= m_ReqInfo.unmarshall(ctx, params, attachments, "ReqInfo", basepath);
	return hasValue;
}

const char * CHandleRoxieOperationRequest::getCmd() { return m_Cmd.query();}
const char * CHandleRoxieOperationRequest::getXmlArgs() { return m_XmlArgs.query();}
IConstWsDeployReqInfo & CHandleRoxieOperationRequest::getReqInfo() { return (IConstWsDeployReqInfo &) m_ReqInfo.getValue();}
void CHandleRoxieOperationRequest::setCmd(const char * val){ m_Cmd.set(val); }
void CHandleRoxieOperationRequest::setXmlArgs(const char * val){ m_XmlArgs.set(val); }
IEspWsDeployReqInfo & CHandleRoxieOperationRequest::updateReqInfo(){ return (IEspWsDeployReqInfo &) m_ReqInfo.getValue(); }
void CHandleRoxieOperationRequest::setReqInfo(IConstWsDeployReqInfo &ifrom){ m_ReqInfo.copy(ifrom); }
extern "C"  IEspHandleRoxieOperationRequest *createHandleRoxieOperationRequest(const char *serv){return ((IEspHandleRoxieOperationRequest *)new CHandleRoxieOperationRequest(serv));}
extern "C"  IClientHandleRoxieOperationRequest *createClientHandleRoxieOperationRequest(const char *serv){return ((IClientHandleRoxieOperationRequest *)new CHandleRoxieOperationRequest(serv));}

//=======================================================
// class CHandleRoxieOperationResponse Implementation
//=======================================================

CHandleRoxieOperationResponse::CHandleRoxieOperationResponse(const char *serviceName, IRpcMessageBinding *init)
	: m_Status(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("HandleRoxieOperationResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CHandleRoxieOperationResponse::CHandleRoxieOperationResponse(const char *serviceName, const char *bc)
	: m_Status(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("HandleRoxieOperationResponse");
}

CHandleRoxieOperationResponse::CHandleRoxieOperationResponse(const char *serviceName, IRpcMessage* rpcmsg)
	: m_Status(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("HandleRoxieOperationResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CHandleRoxieOperationResponse::CHandleRoxieOperationResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_Status(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("HandleRoxieOperationResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CHandleRoxieOperationResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		schema.append("<xsd:element name=\"Exceptions\" type=\"tns:ArrayOfEspException\" minOccurs=\"0\" maxOccurs=\"1\"/>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Status\" type=\"xsd:string\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CHandleRoxieOperationResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CHandleRoxieOperationResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CHandleRoxieOperationResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Status");
	form.appendf("  <tr><td><b>Status: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CHandleRoxieOperationResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CHandleRoxieOperationResponse::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	rpc_resp.setEncodeXml(false);
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
		m_Status.marshall(rpc_resp, "Status", "", "", "");
	}
}


void CHandleRoxieOperationResponse::copy(CHandleRoxieOperationResponse &from)
{
	m_Status.copy(from.m_Status);
}


void CHandleRoxieOperationResponse::copy(IConstHandleRoxieOperationResponse &ifrom)
{
	setStatus(ifrom.getStatus());
}


void CHandleRoxieOperationResponse::getAttributes(IProperties &attributes)
{
}


void CHandleRoxieOperationResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
		m_Status.toStr(ctx, buffer, "Status", "", false, "", "");
	}
}


void CHandleRoxieOperationResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CHandleRoxieOperationResponse::serializer(IEspContext* ctx, IConstHandleRoxieOperationResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<HandleRoxieOperationResponse>");
	// field Status
	{
		const char* s = src.getStatus();
		if (s && *s)
		buffer.appendf("<Status>%s</Status>",s);
	}
	if (keepRootTag)
		buffer.append("</HandleRoxieOperationResponse>");
}

bool CHandleRoxieOperationResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
		hasValue |= m_Status.unmarshall(rpc_request, "Status", basepath);
	}
	return hasValue;
}

bool CHandleRoxieOperationResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Status.unmarshall(ctx, soapval, "Status");
	return hasValue;
}

bool CHandleRoxieOperationResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Status.unmarshall(ctx, params, attachments, "Status", basepath);
	return hasValue;
}

const char * CHandleRoxieOperationResponse::getStatus() { return m_Status.query();}
void CHandleRoxieOperationResponse::setStatus(const char * val){ m_Status.set(val); }
extern "C"  IEspHandleRoxieOperationResponse *createHandleRoxieOperationResponse(const char *serv){return ((IEspHandleRoxieOperationResponse *)new CHandleRoxieOperationResponse(serv));}
extern "C"  IClientHandleRoxieOperationResponse *createClientHandleRoxieOperationResponse(const char *serv){return ((IClientHandleRoxieOperationResponse *)new CHandleRoxieOperationResponse(serv));}

//=======================================================
// class CHandleThorTopologyRequest Implementation
//=======================================================

CHandleThorTopologyRequest::CHandleThorTopologyRequest(const char *serviceName, IRpcMessageBinding *init)
	: m_Operation(nilIgnore),m_XmlArgs(nilIgnore),m_ReqInfo(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("HandleThorTopologyRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CHandleThorTopologyRequest::CHandleThorTopologyRequest(const char *serviceName, const char *bc)
	: m_Operation(nilIgnore),m_XmlArgs(nilIgnore),m_ReqInfo(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("HandleThorTopologyRequest");
}

CHandleThorTopologyRequest::CHandleThorTopologyRequest(const char *serviceName, IRpcMessage* rpcmsg)
	: m_Operation(nilIgnore),m_XmlArgs(nilIgnore),m_ReqInfo(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("HandleThorTopologyRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CHandleThorTopologyRequest::CHandleThorTopologyRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_Operation(nilIgnore),m_XmlArgs(nilIgnore),m_ReqInfo(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("HandleThorTopologyRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CHandleThorTopologyRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Operation\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"XmlArgs\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"ReqInfo\" type=\"tns:WsDeployReqInfo\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	if (!(flags & 0x10)  || (flags & 0x100))
	{
		CWsDeployReqInfo::getXsdDefinition(context, request, schema, added);
	}
	return schema;
}

void CHandleThorTopologyRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CHandleThorTopologyRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
	if (!added.getValue("WsDeployReqInfo"))
	{
		added.setValue("WsDeployReqInfo",1);
		CWsDeployReqInfo::getMapInfo(info,added);
	}
}

StringBuffer &CHandleThorTopologyRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Operation");
	form.appendf("  <tr><td><b>Operation: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("XmlArgs");
	form.appendf("  <tr><td><b>XmlArgs: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("ReqInfo");
	form.append("<tr>").append("<td><b>ReqInfo: </b></td><td><hr/>");
	CWsDeployReqInfo::getHtmlForm(context, request, serv, method, form, false, extfix.str());
	form.append("<hr/></td></tr>");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CHandleThorTopologyRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CHandleThorTopologyRequest::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_Operation.marshall(rpc_resp, "Operation", "", "", "");
	m_XmlArgs.marshall(rpc_resp, "XmlArgs", "", "", "");
	m_ReqInfo.marshall(rpc_resp, "ReqInfo", "", "", "");
}


void CHandleThorTopologyRequest::copy(CHandleThorTopologyRequest &from)
{
	m_Operation.copy(from.m_Operation);
	m_XmlArgs.copy(from.m_XmlArgs);
	m_ReqInfo.copy(from.m_ReqInfo);
}


void CHandleThorTopologyRequest::copy(IConstHandleThorTopologyRequest &ifrom)
{
	setOperation(ifrom.getOperation());
	setXmlArgs(ifrom.getXmlArgs());
	setReqInfo(ifrom.getReqInfo());
}


void CHandleThorTopologyRequest::getAttributes(IProperties &attributes)
{
}


void CHandleThorTopologyRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_Operation.toStr(ctx, buffer, "Operation", "", true, "", "");
	m_XmlArgs.toStr(ctx, buffer, "XmlArgs", "", true, "", "");
	m_ReqInfo.toStr(ctx, buffer, "ReqInfo", "", false, "", "");
}


void CHandleThorTopologyRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CHandleThorTopologyRequest::serializer(IEspContext* ctx, IConstHandleThorTopologyRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<HandleThorTopologyRequest>");
	// field Operation
	{
		const char* s = src.getOperation();
		if (s && *s)
		{
			buffer.append("<Operation>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Operation>");
		}
	}
	// field XmlArgs
	{
		const char* s = src.getXmlArgs();
		if (s && *s)
		{
			buffer.append("<XmlArgs>");
			encodeUtf8XML(s,buffer);
			buffer.append("</XmlArgs>");
		}
	}
	// field ReqInfo
	{
		StringBuffer tmp;
		CWsDeployReqInfo::serializer(ctx,src.getReqInfo(), tmp, false);
		if (tmp.length()>0)
			buffer.appendf("<ReqInfo>%s</ReqInfo>",tmp.str());
	}
	if (keepRootTag)
		buffer.append("</HandleThorTopologyRequest>");
}

bool CHandleThorTopologyRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_Operation.unmarshall(rpc_request, "Operation", basepath);
	hasValue |= m_XmlArgs.unmarshall(rpc_request, "XmlArgs", basepath);
	hasValue |= m_ReqInfo.unmarshall(rpc_request, "ReqInfo", basepath);
	return hasValue;
}

bool CHandleThorTopologyRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Operation.unmarshall(ctx, soapval, "Operation");
	hasValue |= m_XmlArgs.unmarshall(ctx, soapval, "XmlArgs");
	hasValue |= m_ReqInfo.unmarshall(ctx, soapval, "ReqInfo");
	return hasValue;
}

bool CHandleThorTopologyRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Operation.unmarshall(ctx, params, attachments, "Operation", basepath);
	hasValue |= m_XmlArgs.unmarshall(ctx, params, attachments, "XmlArgs", basepath);
	hasValue |= m_ReqInfo.unmarshall(ctx, params, attachments, "ReqInfo", basepath);
	return hasValue;
}

const char * CHandleThorTopologyRequest::getOperation() { return m_Operation.query();}
const char * CHandleThorTopologyRequest::getXmlArgs() { return m_XmlArgs.query();}
IConstWsDeployReqInfo & CHandleThorTopologyRequest::getReqInfo() { return (IConstWsDeployReqInfo &) m_ReqInfo.getValue();}
void CHandleThorTopologyRequest::setOperation(const char * val){ m_Operation.set(val); }
void CHandleThorTopologyRequest::setXmlArgs(const char * val){ m_XmlArgs.set(val); }
IEspWsDeployReqInfo & CHandleThorTopologyRequest::updateReqInfo(){ return (IEspWsDeployReqInfo &) m_ReqInfo.getValue(); }
void CHandleThorTopologyRequest::setReqInfo(IConstWsDeployReqInfo &ifrom){ m_ReqInfo.copy(ifrom); }
extern "C"  IEspHandleThorTopologyRequest *createHandleThorTopologyRequest(const char *serv){return ((IEspHandleThorTopologyRequest *)new CHandleThorTopologyRequest(serv));}
extern "C"  IClientHandleThorTopologyRequest *createClientHandleThorTopologyRequest(const char *serv){return ((IClientHandleThorTopologyRequest *)new CHandleThorTopologyRequest(serv));}

//=======================================================
// class CHandleThorTopologyResponse Implementation
//=======================================================

CHandleThorTopologyResponse::CHandleThorTopologyResponse(const char *serviceName, IRpcMessageBinding *init)
	: m_Status(nilIgnore),m_CompName(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("HandleThorTopologyResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CHandleThorTopologyResponse::CHandleThorTopologyResponse(const char *serviceName, const char *bc)
	: m_Status(nilIgnore),m_CompName(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("HandleThorTopologyResponse");
}

CHandleThorTopologyResponse::CHandleThorTopologyResponse(const char *serviceName, IRpcMessage* rpcmsg)
	: m_Status(nilIgnore),m_CompName(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("HandleThorTopologyResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CHandleThorTopologyResponse::CHandleThorTopologyResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_Status(nilIgnore),m_CompName(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("HandleThorTopologyResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CHandleThorTopologyResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		schema.append("<xsd:element name=\"Exceptions\" type=\"tns:ArrayOfEspException\" minOccurs=\"0\" maxOccurs=\"1\"/>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Status\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"CompName\" type=\"xsd:string\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CHandleThorTopologyResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CHandleThorTopologyResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CHandleThorTopologyResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Status");
	form.appendf("  <tr><td><b>Status: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("CompName");
	form.appendf("  <tr><td><b>CompName: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CHandleThorTopologyResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CHandleThorTopologyResponse::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	rpc_resp.setEncodeXml(false);
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
		m_Status.marshall(rpc_resp, "Status", "", "", "");
		m_CompName.marshall(rpc_resp, "CompName", "", "", "");
	}
}


void CHandleThorTopologyResponse::copy(CHandleThorTopologyResponse &from)
{
	m_Status.copy(from.m_Status);
	m_CompName.copy(from.m_CompName);
}


void CHandleThorTopologyResponse::copy(IConstHandleThorTopologyResponse &ifrom)
{
	setStatus(ifrom.getStatus());
	setCompName(ifrom.getCompName());
}


void CHandleThorTopologyResponse::getAttributes(IProperties &attributes)
{
}


void CHandleThorTopologyResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
		m_Status.toStr(ctx, buffer, "Status", "", false, "", "");
		m_CompName.toStr(ctx, buffer, "CompName", "", false, "", "");
	}
}


void CHandleThorTopologyResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CHandleThorTopologyResponse::serializer(IEspContext* ctx, IConstHandleThorTopologyResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<HandleThorTopologyResponse>");
	// field Status
	{
		const char* s = src.getStatus();
		if (s && *s)
		buffer.appendf("<Status>%s</Status>",s);
	}
	// field CompName
	{
		const char* s = src.getCompName();
		if (s && *s)
		buffer.appendf("<CompName>%s</CompName>",s);
	}
	if (keepRootTag)
		buffer.append("</HandleThorTopologyResponse>");
}

bool CHandleThorTopologyResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
		hasValue |= m_Status.unmarshall(rpc_request, "Status", basepath);
		hasValue |= m_CompName.unmarshall(rpc_request, "CompName", basepath);
	}
	return hasValue;
}

bool CHandleThorTopologyResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Status.unmarshall(ctx, soapval, "Status");
	hasValue |= m_CompName.unmarshall(ctx, soapval, "CompName");
	return hasValue;
}

bool CHandleThorTopologyResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Status.unmarshall(ctx, params, attachments, "Status", basepath);
	hasValue |= m_CompName.unmarshall(ctx, params, attachments, "CompName", basepath);
	return hasValue;
}

const char * CHandleThorTopologyResponse::getStatus() { return m_Status.query();}
const char * CHandleThorTopologyResponse::getCompName() { return m_CompName.query();}
void CHandleThorTopologyResponse::setStatus(const char * val){ m_Status.set(val); }
void CHandleThorTopologyResponse::setCompName(const char * val){ m_CompName.set(val); }
extern "C"  IEspHandleThorTopologyResponse *createHandleThorTopologyResponse(const char *serv){return ((IEspHandleThorTopologyResponse *)new CHandleThorTopologyResponse(serv));}
extern "C"  IClientHandleThorTopologyResponse *createClientHandleThorTopologyResponse(const char *serv){return ((IClientHandleThorTopologyResponse *)new CHandleThorTopologyResponse(serv));}

//=======================================================
// class CHandleAttributeDeleteRequest Implementation
//=======================================================

CHandleAttributeDeleteRequest::CHandleAttributeDeleteRequest(const char *serviceName, IRpcMessageBinding *init)
	: m_Operation(nilIgnore),m_XmlArgs(nilIgnore),m_bLeaf(nilIgnore),m_ReqInfo(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("HandleAttributeDeleteRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CHandleAttributeDeleteRequest::CHandleAttributeDeleteRequest(const char *serviceName, const char *bc)
	: m_Operation(nilIgnore),m_XmlArgs(nilIgnore),m_bLeaf(nilIgnore),m_ReqInfo(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("HandleAttributeDeleteRequest");
}

CHandleAttributeDeleteRequest::CHandleAttributeDeleteRequest(const char *serviceName, IRpcMessage* rpcmsg)
	: m_Operation(nilIgnore),m_XmlArgs(nilIgnore),m_bLeaf(nilIgnore),m_ReqInfo(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("HandleAttributeDeleteRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CHandleAttributeDeleteRequest::CHandleAttributeDeleteRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_Operation(nilIgnore),m_XmlArgs(nilIgnore),m_bLeaf(nilIgnore),m_ReqInfo(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("HandleAttributeDeleteRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CHandleAttributeDeleteRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Operation\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"XmlArgs\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"bLeaf\" type=\"xsd:boolean\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"ReqInfo\" type=\"tns:WsDeployReqInfo\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	if (!(flags & 0x10)  || (flags & 0x100))
	{
		CWsDeployReqInfo::getXsdDefinition(context, request, schema, added);
	}
	return schema;
}

void CHandleAttributeDeleteRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CHandleAttributeDeleteRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
	if (!added.getValue("WsDeployReqInfo"))
	{
		added.setValue("WsDeployReqInfo",1);
		CWsDeployReqInfo::getMapInfo(info,added);
	}
}

StringBuffer &CHandleAttributeDeleteRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Operation");
	form.appendf("  <tr><td><b>Operation: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("XmlArgs");
	form.appendf("  <tr><td><b>XmlArgs: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("bLeaf");
	
	form.appendf("  <tr><td><b>bLeaf? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("ReqInfo");
	form.append("<tr>").append("<td><b>ReqInfo: </b></td><td><hr/>");
	CWsDeployReqInfo::getHtmlForm(context, request, serv, method, form, false, extfix.str());
	form.append("<hr/></td></tr>");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CHandleAttributeDeleteRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CHandleAttributeDeleteRequest::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_Operation.marshall(rpc_resp, "Operation", "", "", "");
	m_XmlArgs.marshall(rpc_resp, "XmlArgs", "", "", "");
	m_bLeaf.marshall(rpc_resp, "bLeaf", "", "", "");
	m_ReqInfo.marshall(rpc_resp, "ReqInfo", "", "", "");
}


void CHandleAttributeDeleteRequest::copy(CHandleAttributeDeleteRequest &from)
{
	m_Operation.copy(from.m_Operation);
	m_XmlArgs.copy(from.m_XmlArgs);
	m_bLeaf.copy(from.m_bLeaf);
	m_ReqInfo.copy(from.m_ReqInfo);
}


void CHandleAttributeDeleteRequest::copy(IConstHandleAttributeDeleteRequest &ifrom)
{
	setOperation(ifrom.getOperation());
	setXmlArgs(ifrom.getXmlArgs());
	setBLeaf(ifrom.getBLeaf());
	setReqInfo(ifrom.getReqInfo());
}


void CHandleAttributeDeleteRequest::getAttributes(IProperties &attributes)
{
}


void CHandleAttributeDeleteRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_Operation.toStr(ctx, buffer, "Operation", "", true, "", "");
	m_XmlArgs.toStr(ctx, buffer, "XmlArgs", "", true, "", "");
	m_bLeaf.toStr(ctx, buffer, "bLeaf", "", true, "", "");
	m_ReqInfo.toStr(ctx, buffer, "ReqInfo", "", false, "", "");
}


void CHandleAttributeDeleteRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CHandleAttributeDeleteRequest::serializer(IEspContext* ctx, IConstHandleAttributeDeleteRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<HandleAttributeDeleteRequest>");
	// field Operation
	{
		const char* s = src.getOperation();
		if (s && *s)
		{
			buffer.append("<Operation>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Operation>");
		}
	}
	// field XmlArgs
	{
		const char* s = src.getXmlArgs();
		if (s && *s)
		{
			buffer.append("<XmlArgs>");
			encodeUtf8XML(s,buffer);
			buffer.append("</XmlArgs>");
		}
	}
	// field bLeaf
	{
		bool b = src.getBLeaf();
		if (b)
			buffer.appendf("<bLeaf>1</bLeaf>");
	}
	// field ReqInfo
	{
		StringBuffer tmp;
		CWsDeployReqInfo::serializer(ctx,src.getReqInfo(), tmp, false);
		if (tmp.length()>0)
			buffer.appendf("<ReqInfo>%s</ReqInfo>",tmp.str());
	}
	if (keepRootTag)
		buffer.append("</HandleAttributeDeleteRequest>");
}

bool CHandleAttributeDeleteRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_Operation.unmarshall(rpc_request, "Operation", basepath);
	hasValue |= m_XmlArgs.unmarshall(rpc_request, "XmlArgs", basepath);
	hasValue |= m_bLeaf.unmarshall(rpc_request, "bLeaf", basepath);
	hasValue |= m_ReqInfo.unmarshall(rpc_request, "ReqInfo", basepath);
	return hasValue;
}

bool CHandleAttributeDeleteRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Operation.unmarshall(ctx, soapval, "Operation");
	hasValue |= m_XmlArgs.unmarshall(ctx, soapval, "XmlArgs");
	hasValue |= m_bLeaf.unmarshall(ctx, soapval, "bLeaf");
	hasValue |= m_ReqInfo.unmarshall(ctx, soapval, "ReqInfo");
	return hasValue;
}

bool CHandleAttributeDeleteRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Operation.unmarshall(ctx, params, attachments, "Operation", basepath);
	hasValue |= m_XmlArgs.unmarshall(ctx, params, attachments, "XmlArgs", basepath);
	hasValue |= m_bLeaf.unmarshall(ctx, params, attachments, "bLeaf", basepath);
	hasValue |= m_ReqInfo.unmarshall(ctx, params, attachments, "ReqInfo", basepath);
	return hasValue;
}

const char * CHandleAttributeDeleteRequest::getOperation() { return m_Operation.query();}
const char * CHandleAttributeDeleteRequest::getXmlArgs() { return m_XmlArgs.query();}
bool CHandleAttributeDeleteRequest::getBLeaf() { return m_bLeaf;}
IConstWsDeployReqInfo & CHandleAttributeDeleteRequest::getReqInfo() { return (IConstWsDeployReqInfo &) m_ReqInfo.getValue();}
void CHandleAttributeDeleteRequest::setOperation(const char * val){ m_Operation.set(val); }
void CHandleAttributeDeleteRequest::setXmlArgs(const char * val){ m_XmlArgs.set(val); }
void CHandleAttributeDeleteRequest::setBLeaf(bool val){ m_bLeaf=val; }
IEspWsDeployReqInfo & CHandleAttributeDeleteRequest::updateReqInfo(){ return (IEspWsDeployReqInfo &) m_ReqInfo.getValue(); }
void CHandleAttributeDeleteRequest::setReqInfo(IConstWsDeployReqInfo &ifrom){ m_ReqInfo.copy(ifrom); }
extern "C"  IEspHandleAttributeDeleteRequest *createHandleAttributeDeleteRequest(const char *serv){return ((IEspHandleAttributeDeleteRequest *)new CHandleAttributeDeleteRequest(serv));}
extern "C"  IClientHandleAttributeDeleteRequest *createClientHandleAttributeDeleteRequest(const char *serv){return ((IClientHandleAttributeDeleteRequest *)new CHandleAttributeDeleteRequest(serv));}

//=======================================================
// class CHandleAttributeAddRequest Implementation
//=======================================================

CHandleAttributeAddRequest::CHandleAttributeAddRequest(const char *serviceName, IRpcMessageBinding *init)
	: m_Operation(nilIgnore),m_XmlArgs(nilIgnore),m_ReqInfo(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("HandleAttributeAddRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CHandleAttributeAddRequest::CHandleAttributeAddRequest(const char *serviceName, const char *bc)
	: m_Operation(nilIgnore),m_XmlArgs(nilIgnore),m_ReqInfo(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("HandleAttributeAddRequest");
}

CHandleAttributeAddRequest::CHandleAttributeAddRequest(const char *serviceName, IRpcMessage* rpcmsg)
	: m_Operation(nilIgnore),m_XmlArgs(nilIgnore),m_ReqInfo(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("HandleAttributeAddRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CHandleAttributeAddRequest::CHandleAttributeAddRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_Operation(nilIgnore),m_XmlArgs(nilIgnore),m_ReqInfo(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("HandleAttributeAddRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CHandleAttributeAddRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Operation\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"XmlArgs\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"ReqInfo\" type=\"tns:WsDeployReqInfo\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	if (!(flags & 0x10)  || (flags & 0x100))
	{
		CWsDeployReqInfo::getXsdDefinition(context, request, schema, added);
	}
	return schema;
}

void CHandleAttributeAddRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CHandleAttributeAddRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
	if (!added.getValue("WsDeployReqInfo"))
	{
		added.setValue("WsDeployReqInfo",1);
		CWsDeployReqInfo::getMapInfo(info,added);
	}
}

StringBuffer &CHandleAttributeAddRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Operation");
	form.appendf("  <tr><td><b>Operation: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("XmlArgs");
	form.appendf("  <tr><td><b>XmlArgs: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("ReqInfo");
	form.append("<tr>").append("<td><b>ReqInfo: </b></td><td><hr/>");
	CWsDeployReqInfo::getHtmlForm(context, request, serv, method, form, false, extfix.str());
	form.append("<hr/></td></tr>");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CHandleAttributeAddRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CHandleAttributeAddRequest::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_Operation.marshall(rpc_resp, "Operation", "", "", "");
	m_XmlArgs.marshall(rpc_resp, "XmlArgs", "", "", "");
	m_ReqInfo.marshall(rpc_resp, "ReqInfo", "", "", "");
}


void CHandleAttributeAddRequest::copy(CHandleAttributeAddRequest &from)
{
	m_Operation.copy(from.m_Operation);
	m_XmlArgs.copy(from.m_XmlArgs);
	m_ReqInfo.copy(from.m_ReqInfo);
}


void CHandleAttributeAddRequest::copy(IConstHandleAttributeAddRequest &ifrom)
{
	setOperation(ifrom.getOperation());
	setXmlArgs(ifrom.getXmlArgs());
	setReqInfo(ifrom.getReqInfo());
}


void CHandleAttributeAddRequest::getAttributes(IProperties &attributes)
{
}


void CHandleAttributeAddRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_Operation.toStr(ctx, buffer, "Operation", "", true, "", "");
	m_XmlArgs.toStr(ctx, buffer, "XmlArgs", "", true, "", "");
	m_ReqInfo.toStr(ctx, buffer, "ReqInfo", "", false, "", "");
}


void CHandleAttributeAddRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CHandleAttributeAddRequest::serializer(IEspContext* ctx, IConstHandleAttributeAddRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<HandleAttributeAddRequest>");
	// field Operation
	{
		const char* s = src.getOperation();
		if (s && *s)
		{
			buffer.append("<Operation>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Operation>");
		}
	}
	// field XmlArgs
	{
		const char* s = src.getXmlArgs();
		if (s && *s)
		{
			buffer.append("<XmlArgs>");
			encodeUtf8XML(s,buffer);
			buffer.append("</XmlArgs>");
		}
	}
	// field ReqInfo
	{
		StringBuffer tmp;
		CWsDeployReqInfo::serializer(ctx,src.getReqInfo(), tmp, false);
		if (tmp.length()>0)
			buffer.appendf("<ReqInfo>%s</ReqInfo>",tmp.str());
	}
	if (keepRootTag)
		buffer.append("</HandleAttributeAddRequest>");
}

bool CHandleAttributeAddRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_Operation.unmarshall(rpc_request, "Operation", basepath);
	hasValue |= m_XmlArgs.unmarshall(rpc_request, "XmlArgs", basepath);
	hasValue |= m_ReqInfo.unmarshall(rpc_request, "ReqInfo", basepath);
	return hasValue;
}

bool CHandleAttributeAddRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Operation.unmarshall(ctx, soapval, "Operation");
	hasValue |= m_XmlArgs.unmarshall(ctx, soapval, "XmlArgs");
	hasValue |= m_ReqInfo.unmarshall(ctx, soapval, "ReqInfo");
	return hasValue;
}

bool CHandleAttributeAddRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Operation.unmarshall(ctx, params, attachments, "Operation", basepath);
	hasValue |= m_XmlArgs.unmarshall(ctx, params, attachments, "XmlArgs", basepath);
	hasValue |= m_ReqInfo.unmarshall(ctx, params, attachments, "ReqInfo", basepath);
	return hasValue;
}

const char * CHandleAttributeAddRequest::getOperation() { return m_Operation.query();}
const char * CHandleAttributeAddRequest::getXmlArgs() { return m_XmlArgs.query();}
IConstWsDeployReqInfo & CHandleAttributeAddRequest::getReqInfo() { return (IConstWsDeployReqInfo &) m_ReqInfo.getValue();}
void CHandleAttributeAddRequest::setOperation(const char * val){ m_Operation.set(val); }
void CHandleAttributeAddRequest::setXmlArgs(const char * val){ m_XmlArgs.set(val); }
IEspWsDeployReqInfo & CHandleAttributeAddRequest::updateReqInfo(){ return (IEspWsDeployReqInfo &) m_ReqInfo.getValue(); }
void CHandleAttributeAddRequest::setReqInfo(IConstWsDeployReqInfo &ifrom){ m_ReqInfo.copy(ifrom); }
extern "C"  IEspHandleAttributeAddRequest *createHandleAttributeAddRequest(const char *serv){return ((IEspHandleAttributeAddRequest *)new CHandleAttributeAddRequest(serv));}
extern "C"  IClientHandleAttributeAddRequest *createClientHandleAttributeAddRequest(const char *serv){return ((IClientHandleAttributeAddRequest *)new CHandleAttributeAddRequest(serv));}

//=======================================================
// class CHandleAttributeAddResponse Implementation
//=======================================================

CHandleAttributeAddResponse::CHandleAttributeAddResponse(const char *serviceName, IRpcMessageBinding *init)
	: m_Status(nilIgnore),m_CompName(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("HandleAttributeAddResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CHandleAttributeAddResponse::CHandleAttributeAddResponse(const char *serviceName, const char *bc)
	: m_Status(nilIgnore),m_CompName(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("HandleAttributeAddResponse");
}

CHandleAttributeAddResponse::CHandleAttributeAddResponse(const char *serviceName, IRpcMessage* rpcmsg)
	: m_Status(nilIgnore),m_CompName(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("HandleAttributeAddResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CHandleAttributeAddResponse::CHandleAttributeAddResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_Status(nilIgnore),m_CompName(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("HandleAttributeAddResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CHandleAttributeAddResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		schema.append("<xsd:element name=\"Exceptions\" type=\"tns:ArrayOfEspException\" minOccurs=\"0\" maxOccurs=\"1\"/>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Status\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"CompName\" type=\"xsd:string\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CHandleAttributeAddResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CHandleAttributeAddResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CHandleAttributeAddResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Status");
	form.appendf("  <tr><td><b>Status: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("CompName");
	form.appendf("  <tr><td><b>CompName: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CHandleAttributeAddResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CHandleAttributeAddResponse::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	rpc_resp.setEncodeXml(false);
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
		m_Status.marshall(rpc_resp, "Status", "", "", "");
		m_CompName.marshall(rpc_resp, "CompName", "", "", "");
	}
}


void CHandleAttributeAddResponse::copy(CHandleAttributeAddResponse &from)
{
	m_Status.copy(from.m_Status);
	m_CompName.copy(from.m_CompName);
}


void CHandleAttributeAddResponse::copy(IConstHandleAttributeAddResponse &ifrom)
{
	setStatus(ifrom.getStatus());
	setCompName(ifrom.getCompName());
}


void CHandleAttributeAddResponse::getAttributes(IProperties &attributes)
{
}


void CHandleAttributeAddResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
		m_Status.toStr(ctx, buffer, "Status", "", false, "", "");
		m_CompName.toStr(ctx, buffer, "CompName", "", false, "", "");
	}
}


void CHandleAttributeAddResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CHandleAttributeAddResponse::serializer(IEspContext* ctx, IConstHandleAttributeAddResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<HandleAttributeAddResponse>");
	// field Status
	{
		const char* s = src.getStatus();
		if (s && *s)
		buffer.appendf("<Status>%s</Status>",s);
	}
	// field CompName
	{
		const char* s = src.getCompName();
		if (s && *s)
		buffer.appendf("<CompName>%s</CompName>",s);
	}
	if (keepRootTag)
		buffer.append("</HandleAttributeAddResponse>");
}

bool CHandleAttributeAddResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
		hasValue |= m_Status.unmarshall(rpc_request, "Status", basepath);
		hasValue |= m_CompName.unmarshall(rpc_request, "CompName", basepath);
	}
	return hasValue;
}

bool CHandleAttributeAddResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Status.unmarshall(ctx, soapval, "Status");
	hasValue |= m_CompName.unmarshall(ctx, soapval, "CompName");
	return hasValue;
}

bool CHandleAttributeAddResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Status.unmarshall(ctx, params, attachments, "Status", basepath);
	hasValue |= m_CompName.unmarshall(ctx, params, attachments, "CompName", basepath);
	return hasValue;
}

const char * CHandleAttributeAddResponse::getStatus() { return m_Status.query();}
const char * CHandleAttributeAddResponse::getCompName() { return m_CompName.query();}
void CHandleAttributeAddResponse::setStatus(const char * val){ m_Status.set(val); }
void CHandleAttributeAddResponse::setCompName(const char * val){ m_CompName.set(val); }
extern "C"  IEspHandleAttributeAddResponse *createHandleAttributeAddResponse(const char *serv){return ((IEspHandleAttributeAddResponse *)new CHandleAttributeAddResponse(serv));}
extern "C"  IClientHandleAttributeAddResponse *createClientHandleAttributeAddResponse(const char *serv){return ((IClientHandleAttributeAddResponse *)new CHandleAttributeAddResponse(serv));}

//=======================================================
// class CHandleAttributeDeleteResponse Implementation
//=======================================================

CHandleAttributeDeleteResponse::CHandleAttributeDeleteResponse(const char *serviceName, IRpcMessageBinding *init)
	: m_Status(nilIgnore),m_CompName(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("HandleAttributeDeleteResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CHandleAttributeDeleteResponse::CHandleAttributeDeleteResponse(const char *serviceName, const char *bc)
	: m_Status(nilIgnore),m_CompName(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("HandleAttributeDeleteResponse");
}

CHandleAttributeDeleteResponse::CHandleAttributeDeleteResponse(const char *serviceName, IRpcMessage* rpcmsg)
	: m_Status(nilIgnore),m_CompName(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("HandleAttributeDeleteResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CHandleAttributeDeleteResponse::CHandleAttributeDeleteResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_Status(nilIgnore),m_CompName(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("HandleAttributeDeleteResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CHandleAttributeDeleteResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		schema.append("<xsd:element name=\"Exceptions\" type=\"tns:ArrayOfEspException\" minOccurs=\"0\" maxOccurs=\"1\"/>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Status\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"CompName\" type=\"xsd:string\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CHandleAttributeDeleteResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CHandleAttributeDeleteResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CHandleAttributeDeleteResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Status");
	form.appendf("  <tr><td><b>Status: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("CompName");
	form.appendf("  <tr><td><b>CompName: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CHandleAttributeDeleteResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CHandleAttributeDeleteResponse::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	rpc_resp.setEncodeXml(false);
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
		m_Status.marshall(rpc_resp, "Status", "", "", "");
		m_CompName.marshall(rpc_resp, "CompName", "", "", "");
	}
}


void CHandleAttributeDeleteResponse::copy(CHandleAttributeDeleteResponse &from)
{
	m_Status.copy(from.m_Status);
	m_CompName.copy(from.m_CompName);
}


void CHandleAttributeDeleteResponse::copy(IConstHandleAttributeDeleteResponse &ifrom)
{
	setStatus(ifrom.getStatus());
	setCompName(ifrom.getCompName());
}


void CHandleAttributeDeleteResponse::getAttributes(IProperties &attributes)
{
}


void CHandleAttributeDeleteResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
		m_Status.toStr(ctx, buffer, "Status", "", false, "", "");
		m_CompName.toStr(ctx, buffer, "CompName", "", false, "", "");
	}
}


void CHandleAttributeDeleteResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CHandleAttributeDeleteResponse::serializer(IEspContext* ctx, IConstHandleAttributeDeleteResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<HandleAttributeDeleteResponse>");
	// field Status
	{
		const char* s = src.getStatus();
		if (s && *s)
		buffer.appendf("<Status>%s</Status>",s);
	}
	// field CompName
	{
		const char* s = src.getCompName();
		if (s && *s)
		buffer.appendf("<CompName>%s</CompName>",s);
	}
	if (keepRootTag)
		buffer.append("</HandleAttributeDeleteResponse>");
}

bool CHandleAttributeDeleteResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
		hasValue |= m_Status.unmarshall(rpc_request, "Status", basepath);
		hasValue |= m_CompName.unmarshall(rpc_request, "CompName", basepath);
	}
	return hasValue;
}

bool CHandleAttributeDeleteResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Status.unmarshall(ctx, soapval, "Status");
	hasValue |= m_CompName.unmarshall(ctx, soapval, "CompName");
	return hasValue;
}

bool CHandleAttributeDeleteResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Status.unmarshall(ctx, params, attachments, "Status", basepath);
	hasValue |= m_CompName.unmarshall(ctx, params, attachments, "CompName", basepath);
	return hasValue;
}

const char * CHandleAttributeDeleteResponse::getStatus() { return m_Status.query();}
const char * CHandleAttributeDeleteResponse::getCompName() { return m_CompName.query();}
void CHandleAttributeDeleteResponse::setStatus(const char * val){ m_Status.set(val); }
void CHandleAttributeDeleteResponse::setCompName(const char * val){ m_CompName.set(val); }
extern "C"  IEspHandleAttributeDeleteResponse *createHandleAttributeDeleteResponse(const char *serv){return ((IEspHandleAttributeDeleteResponse *)new CHandleAttributeDeleteResponse(serv));}
extern "C"  IClientHandleAttributeDeleteResponse *createClientHandleAttributeDeleteResponse(const char *serv){return ((IClientHandleAttributeDeleteResponse *)new CHandleAttributeDeleteResponse(serv));}

//=======================================================
// class CHandleComponentRequest Implementation
//=======================================================

CHandleComponentRequest::CHandleComponentRequest(const char *serviceName, IRpcMessageBinding *init)
	: m_Operation(nilIgnore),m_XmlArgs(nilIgnore),m_ReqInfo(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("HandleComponentRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CHandleComponentRequest::CHandleComponentRequest(const char *serviceName, const char *bc)
	: m_Operation(nilIgnore),m_XmlArgs(nilIgnore),m_ReqInfo(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("HandleComponentRequest");
}

CHandleComponentRequest::CHandleComponentRequest(const char *serviceName, IRpcMessage* rpcmsg)
	: m_Operation(nilIgnore),m_XmlArgs(nilIgnore),m_ReqInfo(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("HandleComponentRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CHandleComponentRequest::CHandleComponentRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_Operation(nilIgnore),m_XmlArgs(nilIgnore),m_ReqInfo(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("HandleComponentRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CHandleComponentRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Operation\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"XmlArgs\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"ReqInfo\" type=\"tns:WsDeployReqInfo\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	if (!(flags & 0x10)  || (flags & 0x100))
	{
		CWsDeployReqInfo::getXsdDefinition(context, request, schema, added);
	}
	return schema;
}

void CHandleComponentRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CHandleComponentRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
	if (!added.getValue("WsDeployReqInfo"))
	{
		added.setValue("WsDeployReqInfo",1);
		CWsDeployReqInfo::getMapInfo(info,added);
	}
}

StringBuffer &CHandleComponentRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Operation");
	form.appendf("  <tr><td><b>Operation: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("XmlArgs");
	form.appendf("  <tr><td><b>XmlArgs: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("ReqInfo");
	form.append("<tr>").append("<td><b>ReqInfo: </b></td><td><hr/>");
	CWsDeployReqInfo::getHtmlForm(context, request, serv, method, form, false, extfix.str());
	form.append("<hr/></td></tr>");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CHandleComponentRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CHandleComponentRequest::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_Operation.marshall(rpc_resp, "Operation", "", "", "");
	m_XmlArgs.marshall(rpc_resp, "XmlArgs", "", "", "");
	m_ReqInfo.marshall(rpc_resp, "ReqInfo", "", "", "");
}


void CHandleComponentRequest::copy(CHandleComponentRequest &from)
{
	m_Operation.copy(from.m_Operation);
	m_XmlArgs.copy(from.m_XmlArgs);
	m_ReqInfo.copy(from.m_ReqInfo);
}


void CHandleComponentRequest::copy(IConstHandleComponentRequest &ifrom)
{
	setOperation(ifrom.getOperation());
	setXmlArgs(ifrom.getXmlArgs());
	setReqInfo(ifrom.getReqInfo());
}


void CHandleComponentRequest::getAttributes(IProperties &attributes)
{
}


void CHandleComponentRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_Operation.toStr(ctx, buffer, "Operation", "", true, "", "");
	m_XmlArgs.toStr(ctx, buffer, "XmlArgs", "", true, "", "");
	m_ReqInfo.toStr(ctx, buffer, "ReqInfo", "", false, "", "");
}


void CHandleComponentRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CHandleComponentRequest::serializer(IEspContext* ctx, IConstHandleComponentRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<HandleComponentRequest>");
	// field Operation
	{
		const char* s = src.getOperation();
		if (s && *s)
		{
			buffer.append("<Operation>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Operation>");
		}
	}
	// field XmlArgs
	{
		const char* s = src.getXmlArgs();
		if (s && *s)
		{
			buffer.append("<XmlArgs>");
			encodeUtf8XML(s,buffer);
			buffer.append("</XmlArgs>");
		}
	}
	// field ReqInfo
	{
		StringBuffer tmp;
		CWsDeployReqInfo::serializer(ctx,src.getReqInfo(), tmp, false);
		if (tmp.length()>0)
			buffer.appendf("<ReqInfo>%s</ReqInfo>",tmp.str());
	}
	if (keepRootTag)
		buffer.append("</HandleComponentRequest>");
}

bool CHandleComponentRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_Operation.unmarshall(rpc_request, "Operation", basepath);
	hasValue |= m_XmlArgs.unmarshall(rpc_request, "XmlArgs", basepath);
	hasValue |= m_ReqInfo.unmarshall(rpc_request, "ReqInfo", basepath);
	return hasValue;
}

bool CHandleComponentRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Operation.unmarshall(ctx, soapval, "Operation");
	hasValue |= m_XmlArgs.unmarshall(ctx, soapval, "XmlArgs");
	hasValue |= m_ReqInfo.unmarshall(ctx, soapval, "ReqInfo");
	return hasValue;
}

bool CHandleComponentRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Operation.unmarshall(ctx, params, attachments, "Operation", basepath);
	hasValue |= m_XmlArgs.unmarshall(ctx, params, attachments, "XmlArgs", basepath);
	hasValue |= m_ReqInfo.unmarshall(ctx, params, attachments, "ReqInfo", basepath);
	return hasValue;
}

const char * CHandleComponentRequest::getOperation() { return m_Operation.query();}
const char * CHandleComponentRequest::getXmlArgs() { return m_XmlArgs.query();}
IConstWsDeployReqInfo & CHandleComponentRequest::getReqInfo() { return (IConstWsDeployReqInfo &) m_ReqInfo.getValue();}
void CHandleComponentRequest::setOperation(const char * val){ m_Operation.set(val); }
void CHandleComponentRequest::setXmlArgs(const char * val){ m_XmlArgs.set(val); }
IEspWsDeployReqInfo & CHandleComponentRequest::updateReqInfo(){ return (IEspWsDeployReqInfo &) m_ReqInfo.getValue(); }
void CHandleComponentRequest::setReqInfo(IConstWsDeployReqInfo &ifrom){ m_ReqInfo.copy(ifrom); }
extern "C"  IEspHandleComponentRequest *createHandleComponentRequest(const char *serv){return ((IEspHandleComponentRequest *)new CHandleComponentRequest(serv));}
extern "C"  IClientHandleComponentRequest *createClientHandleComponentRequest(const char *serv){return ((IClientHandleComponentRequest *)new CHandleComponentRequest(serv));}

//=======================================================
// class CHandleComponentResponse Implementation
//=======================================================

CHandleComponentResponse::CHandleComponentResponse(const char *serviceName, IRpcMessageBinding *init)
	: m_Status(nilIgnore),m_CompName(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("HandleComponentResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CHandleComponentResponse::CHandleComponentResponse(const char *serviceName, const char *bc)
	: m_Status(nilIgnore),m_CompName(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("HandleComponentResponse");
}

CHandleComponentResponse::CHandleComponentResponse(const char *serviceName, IRpcMessage* rpcmsg)
	: m_Status(nilIgnore),m_CompName(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("HandleComponentResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CHandleComponentResponse::CHandleComponentResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_Status(nilIgnore),m_CompName(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("HandleComponentResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CHandleComponentResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		schema.append("<xsd:element name=\"Exceptions\" type=\"tns:ArrayOfEspException\" minOccurs=\"0\" maxOccurs=\"1\"/>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Status\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"CompName\" type=\"xsd:string\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CHandleComponentResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CHandleComponentResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CHandleComponentResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Status");
	form.appendf("  <tr><td><b>Status: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("CompName");
	form.appendf("  <tr><td><b>CompName: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CHandleComponentResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CHandleComponentResponse::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	rpc_resp.setEncodeXml(false);
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
		m_Status.marshall(rpc_resp, "Status", "", "", "");
		m_CompName.marshall(rpc_resp, "CompName", "", "", "");
	}
}


void CHandleComponentResponse::copy(CHandleComponentResponse &from)
{
	m_Status.copy(from.m_Status);
	m_CompName.copy(from.m_CompName);
}


void CHandleComponentResponse::copy(IConstHandleComponentResponse &ifrom)
{
	setStatus(ifrom.getStatus());
	setCompName(ifrom.getCompName());
}


void CHandleComponentResponse::getAttributes(IProperties &attributes)
{
}


void CHandleComponentResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
		m_Status.toStr(ctx, buffer, "Status", "", false, "", "");
		m_CompName.toStr(ctx, buffer, "CompName", "", false, "", "");
	}
}


void CHandleComponentResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CHandleComponentResponse::serializer(IEspContext* ctx, IConstHandleComponentResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<HandleComponentResponse>");
	// field Status
	{
		const char* s = src.getStatus();
		if (s && *s)
		buffer.appendf("<Status>%s</Status>",s);
	}
	// field CompName
	{
		const char* s = src.getCompName();
		if (s && *s)
		buffer.appendf("<CompName>%s</CompName>",s);
	}
	if (keepRootTag)
		buffer.append("</HandleComponentResponse>");
}

bool CHandleComponentResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
		hasValue |= m_Status.unmarshall(rpc_request, "Status", basepath);
		hasValue |= m_CompName.unmarshall(rpc_request, "CompName", basepath);
	}
	return hasValue;
}

bool CHandleComponentResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Status.unmarshall(ctx, soapval, "Status");
	hasValue |= m_CompName.unmarshall(ctx, soapval, "CompName");
	return hasValue;
}

bool CHandleComponentResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Status.unmarshall(ctx, params, attachments, "Status", basepath);
	hasValue |= m_CompName.unmarshall(ctx, params, attachments, "CompName", basepath);
	return hasValue;
}

const char * CHandleComponentResponse::getStatus() { return m_Status.query();}
const char * CHandleComponentResponse::getCompName() { return m_CompName.query();}
void CHandleComponentResponse::setStatus(const char * val){ m_Status.set(val); }
void CHandleComponentResponse::setCompName(const char * val){ m_CompName.set(val); }
extern "C"  IEspHandleComponentResponse *createHandleComponentResponse(const char *serv){return ((IEspHandleComponentResponse *)new CHandleComponentResponse(serv));}
extern "C"  IClientHandleComponentResponse *createClientHandleComponentResponse(const char *serv){return ((IClientHandleComponentResponse *)new CHandleComponentResponse(serv));}

//=======================================================
// class CHandleInstanceRequest Implementation
//=======================================================

CHandleInstanceRequest::CHandleInstanceRequest(const char *serviceName, IRpcMessageBinding *init)
	: m_Operation(nilIgnore),m_XmlArgs(nilIgnore),m_ReqInfo(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("HandleInstanceRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CHandleInstanceRequest::CHandleInstanceRequest(const char *serviceName, const char *bc)
	: m_Operation(nilIgnore),m_XmlArgs(nilIgnore),m_ReqInfo(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("HandleInstanceRequest");
}

CHandleInstanceRequest::CHandleInstanceRequest(const char *serviceName, IRpcMessage* rpcmsg)
	: m_Operation(nilIgnore),m_XmlArgs(nilIgnore),m_ReqInfo(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("HandleInstanceRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CHandleInstanceRequest::CHandleInstanceRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_Operation(nilIgnore),m_XmlArgs(nilIgnore),m_ReqInfo(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("HandleInstanceRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CHandleInstanceRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Operation\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"XmlArgs\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"ReqInfo\" type=\"tns:WsDeployReqInfo\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	if (!(flags & 0x10)  || (flags & 0x100))
	{
		CWsDeployReqInfo::getXsdDefinition(context, request, schema, added);
	}
	return schema;
}

void CHandleInstanceRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CHandleInstanceRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
	if (!added.getValue("WsDeployReqInfo"))
	{
		added.setValue("WsDeployReqInfo",1);
		CWsDeployReqInfo::getMapInfo(info,added);
	}
}

StringBuffer &CHandleInstanceRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Operation");
	form.appendf("  <tr><td><b>Operation: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("XmlArgs");
	form.appendf("  <tr><td><b>XmlArgs: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("ReqInfo");
	form.append("<tr>").append("<td><b>ReqInfo: </b></td><td><hr/>");
	CWsDeployReqInfo::getHtmlForm(context, request, serv, method, form, false, extfix.str());
	form.append("<hr/></td></tr>");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CHandleInstanceRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CHandleInstanceRequest::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_Operation.marshall(rpc_resp, "Operation", "", "", "");
	m_XmlArgs.marshall(rpc_resp, "XmlArgs", "", "", "");
	m_ReqInfo.marshall(rpc_resp, "ReqInfo", "", "", "");
}


void CHandleInstanceRequest::copy(CHandleInstanceRequest &from)
{
	m_Operation.copy(from.m_Operation);
	m_XmlArgs.copy(from.m_XmlArgs);
	m_ReqInfo.copy(from.m_ReqInfo);
}


void CHandleInstanceRequest::copy(IConstHandleInstanceRequest &ifrom)
{
	setOperation(ifrom.getOperation());
	setXmlArgs(ifrom.getXmlArgs());
	setReqInfo(ifrom.getReqInfo());
}


void CHandleInstanceRequest::getAttributes(IProperties &attributes)
{
}


void CHandleInstanceRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_Operation.toStr(ctx, buffer, "Operation", "", true, "", "");
	m_XmlArgs.toStr(ctx, buffer, "XmlArgs", "", true, "", "");
	m_ReqInfo.toStr(ctx, buffer, "ReqInfo", "", false, "", "");
}


void CHandleInstanceRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CHandleInstanceRequest::serializer(IEspContext* ctx, IConstHandleInstanceRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<HandleInstanceRequest>");
	// field Operation
	{
		const char* s = src.getOperation();
		if (s && *s)
		{
			buffer.append("<Operation>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Operation>");
		}
	}
	// field XmlArgs
	{
		const char* s = src.getXmlArgs();
		if (s && *s)
		{
			buffer.append("<XmlArgs>");
			encodeUtf8XML(s,buffer);
			buffer.append("</XmlArgs>");
		}
	}
	// field ReqInfo
	{
		StringBuffer tmp;
		CWsDeployReqInfo::serializer(ctx,src.getReqInfo(), tmp, false);
		if (tmp.length()>0)
			buffer.appendf("<ReqInfo>%s</ReqInfo>",tmp.str());
	}
	if (keepRootTag)
		buffer.append("</HandleInstanceRequest>");
}

bool CHandleInstanceRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_Operation.unmarshall(rpc_request, "Operation", basepath);
	hasValue |= m_XmlArgs.unmarshall(rpc_request, "XmlArgs", basepath);
	hasValue |= m_ReqInfo.unmarshall(rpc_request, "ReqInfo", basepath);
	return hasValue;
}

bool CHandleInstanceRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Operation.unmarshall(ctx, soapval, "Operation");
	hasValue |= m_XmlArgs.unmarshall(ctx, soapval, "XmlArgs");
	hasValue |= m_ReqInfo.unmarshall(ctx, soapval, "ReqInfo");
	return hasValue;
}

bool CHandleInstanceRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Operation.unmarshall(ctx, params, attachments, "Operation", basepath);
	hasValue |= m_XmlArgs.unmarshall(ctx, params, attachments, "XmlArgs", basepath);
	hasValue |= m_ReqInfo.unmarshall(ctx, params, attachments, "ReqInfo", basepath);
	return hasValue;
}

const char * CHandleInstanceRequest::getOperation() { return m_Operation.query();}
const char * CHandleInstanceRequest::getXmlArgs() { return m_XmlArgs.query();}
IConstWsDeployReqInfo & CHandleInstanceRequest::getReqInfo() { return (IConstWsDeployReqInfo &) m_ReqInfo.getValue();}
void CHandleInstanceRequest::setOperation(const char * val){ m_Operation.set(val); }
void CHandleInstanceRequest::setXmlArgs(const char * val){ m_XmlArgs.set(val); }
IEspWsDeployReqInfo & CHandleInstanceRequest::updateReqInfo(){ return (IEspWsDeployReqInfo &) m_ReqInfo.getValue(); }
void CHandleInstanceRequest::setReqInfo(IConstWsDeployReqInfo &ifrom){ m_ReqInfo.copy(ifrom); }
extern "C"  IEspHandleInstanceRequest *createHandleInstanceRequest(const char *serv){return ((IEspHandleInstanceRequest *)new CHandleInstanceRequest(serv));}
extern "C"  IClientHandleInstanceRequest *createClientHandleInstanceRequest(const char *serv){return ((IClientHandleInstanceRequest *)new CHandleInstanceRequest(serv));}

//=======================================================
// class CHandleInstanceResponse Implementation
//=======================================================

CHandleInstanceResponse::CHandleInstanceResponse(const char *serviceName, IRpcMessageBinding *init)
	: m_Status(nilIgnore),m_NewName(nilIgnore),m_Duplicates(nilIgnore),m_ReqdCompNames(nilIgnore),m_AddReqdComps(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("HandleInstanceResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CHandleInstanceResponse::CHandleInstanceResponse(const char *serviceName, const char *bc)
	: m_Status(nilIgnore),m_NewName(nilIgnore),m_Duplicates(nilIgnore),m_ReqdCompNames(nilIgnore),m_AddReqdComps(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("HandleInstanceResponse");
}

CHandleInstanceResponse::CHandleInstanceResponse(const char *serviceName, IRpcMessage* rpcmsg)
	: m_Status(nilIgnore),m_NewName(nilIgnore),m_Duplicates(nilIgnore),m_ReqdCompNames(nilIgnore),m_AddReqdComps(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("HandleInstanceResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CHandleInstanceResponse::CHandleInstanceResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_Status(nilIgnore),m_NewName(nilIgnore),m_Duplicates(nilIgnore),m_ReqdCompNames(nilIgnore),m_AddReqdComps(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("HandleInstanceResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CHandleInstanceResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		schema.append("<xsd:element name=\"Exceptions\" type=\"tns:ArrayOfEspException\" minOccurs=\"0\" maxOccurs=\"1\"/>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Status\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"NewName\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Duplicates\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"ReqdCompNames\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"AddReqdComps\" type=\"xsd:string\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CHandleInstanceResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CHandleInstanceResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CHandleInstanceResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Status");
	form.appendf("  <tr><td><b>Status: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("NewName");
	form.appendf("  <tr><td><b>NewName: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Duplicates");
	form.appendf("  <tr><td><b>Duplicates: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("ReqdCompNames");
	form.appendf("  <tr><td><b>ReqdCompNames: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("AddReqdComps");
	form.appendf("  <tr><td><b>AddReqdComps: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CHandleInstanceResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CHandleInstanceResponse::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	rpc_resp.setEncodeXml(false);
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
		m_Status.marshall(rpc_resp, "Status", "", "", "");
		m_NewName.marshall(rpc_resp, "NewName", "", "", "");
		m_Duplicates.marshall(rpc_resp, "Duplicates", "", "", "");
		m_ReqdCompNames.marshall(rpc_resp, "ReqdCompNames", "", "", "");
		m_AddReqdComps.marshall(rpc_resp, "AddReqdComps", "", "", "");
	}
}


void CHandleInstanceResponse::copy(CHandleInstanceResponse &from)
{
	m_Status.copy(from.m_Status);
	m_NewName.copy(from.m_NewName);
	m_Duplicates.copy(from.m_Duplicates);
	m_ReqdCompNames.copy(from.m_ReqdCompNames);
	m_AddReqdComps.copy(from.m_AddReqdComps);
}


void CHandleInstanceResponse::copy(IConstHandleInstanceResponse &ifrom)
{
	setStatus(ifrom.getStatus());
	setNewName(ifrom.getNewName());
	setDuplicates(ifrom.getDuplicates());
	setReqdCompNames(ifrom.getReqdCompNames());
	setAddReqdComps(ifrom.getAddReqdComps());
}


void CHandleInstanceResponse::getAttributes(IProperties &attributes)
{
}


void CHandleInstanceResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
		m_Status.toStr(ctx, buffer, "Status", "", false, "", "");
		m_NewName.toStr(ctx, buffer, "NewName", "", false, "", "");
		m_Duplicates.toStr(ctx, buffer, "Duplicates", "", false, "", "");
		m_ReqdCompNames.toStr(ctx, buffer, "ReqdCompNames", "", false, "", "");
		m_AddReqdComps.toStr(ctx, buffer, "AddReqdComps", "", false, "", "");
	}
}


void CHandleInstanceResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CHandleInstanceResponse::serializer(IEspContext* ctx, IConstHandleInstanceResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<HandleInstanceResponse>");
	// field Status
	{
		const char* s = src.getStatus();
		if (s && *s)
		buffer.appendf("<Status>%s</Status>",s);
	}
	// field NewName
	{
		const char* s = src.getNewName();
		if (s && *s)
		buffer.appendf("<NewName>%s</NewName>",s);
	}
	// field Duplicates
	{
		const char* s = src.getDuplicates();
		if (s && *s)
		buffer.appendf("<Duplicates>%s</Duplicates>",s);
	}
	// field ReqdCompNames
	{
		const char* s = src.getReqdCompNames();
		if (s && *s)
		buffer.appendf("<ReqdCompNames>%s</ReqdCompNames>",s);
	}
	// field AddReqdComps
	{
		const char* s = src.getAddReqdComps();
		if (s && *s)
		buffer.appendf("<AddReqdComps>%s</AddReqdComps>",s);
	}
	if (keepRootTag)
		buffer.append("</HandleInstanceResponse>");
}

bool CHandleInstanceResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
		hasValue |= m_Status.unmarshall(rpc_request, "Status", basepath);
		hasValue |= m_NewName.unmarshall(rpc_request, "NewName", basepath);
		hasValue |= m_Duplicates.unmarshall(rpc_request, "Duplicates", basepath);
		hasValue |= m_ReqdCompNames.unmarshall(rpc_request, "ReqdCompNames", basepath);
		hasValue |= m_AddReqdComps.unmarshall(rpc_request, "AddReqdComps", basepath);
	}
	return hasValue;
}

bool CHandleInstanceResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Status.unmarshall(ctx, soapval, "Status");
	hasValue |= m_NewName.unmarshall(ctx, soapval, "NewName");
	hasValue |= m_Duplicates.unmarshall(ctx, soapval, "Duplicates");
	hasValue |= m_ReqdCompNames.unmarshall(ctx, soapval, "ReqdCompNames");
	hasValue |= m_AddReqdComps.unmarshall(ctx, soapval, "AddReqdComps");
	return hasValue;
}

bool CHandleInstanceResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Status.unmarshall(ctx, params, attachments, "Status", basepath);
	hasValue |= m_NewName.unmarshall(ctx, params, attachments, "NewName", basepath);
	hasValue |= m_Duplicates.unmarshall(ctx, params, attachments, "Duplicates", basepath);
	hasValue |= m_ReqdCompNames.unmarshall(ctx, params, attachments, "ReqdCompNames", basepath);
	hasValue |= m_AddReqdComps.unmarshall(ctx, params, attachments, "AddReqdComps", basepath);
	return hasValue;
}

const char * CHandleInstanceResponse::getStatus() { return m_Status.query();}
const char * CHandleInstanceResponse::getNewName() { return m_NewName.query();}
const char * CHandleInstanceResponse::getDuplicates() { return m_Duplicates.query();}
const char * CHandleInstanceResponse::getReqdCompNames() { return m_ReqdCompNames.query();}
const char * CHandleInstanceResponse::getAddReqdComps() { return m_AddReqdComps.query();}
void CHandleInstanceResponse::setStatus(const char * val){ m_Status.set(val); }
void CHandleInstanceResponse::setNewName(const char * val){ m_NewName.set(val); }
void CHandleInstanceResponse::setDuplicates(const char * val){ m_Duplicates.set(val); }
void CHandleInstanceResponse::setReqdCompNames(const char * val){ m_ReqdCompNames.set(val); }
void CHandleInstanceResponse::setAddReqdComps(const char * val){ m_AddReqdComps.set(val); }
extern "C"  IEspHandleInstanceResponse *createHandleInstanceResponse(const char *serv){return ((IEspHandleInstanceResponse *)new CHandleInstanceResponse(serv));}
extern "C"  IClientHandleInstanceResponse *createClientHandleInstanceResponse(const char *serv){return ((IClientHandleInstanceResponse *)new CHandleInstanceResponse(serv));}

//=======================================================
// class CAddReqdCompsRequest Implementation
//=======================================================

CAddReqdCompsRequest::CAddReqdCompsRequest(const char *serviceName, IRpcMessageBinding *init)
	: m_XmlArgs(nilIgnore),m_ReqInfo(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("AddReqdCompsRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CAddReqdCompsRequest::CAddReqdCompsRequest(const char *serviceName, const char *bc)
	: m_XmlArgs(nilIgnore),m_ReqInfo(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("AddReqdCompsRequest");
}

CAddReqdCompsRequest::CAddReqdCompsRequest(const char *serviceName, IRpcMessage* rpcmsg)
	: m_XmlArgs(nilIgnore),m_ReqInfo(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("AddReqdCompsRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CAddReqdCompsRequest::CAddReqdCompsRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_XmlArgs(nilIgnore),m_ReqInfo(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("AddReqdCompsRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CAddReqdCompsRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"XmlArgs\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"ReqInfo\" type=\"tns:WsDeployReqInfo\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	if (!(flags & 0x10)  || (flags & 0x100))
	{
		CWsDeployReqInfo::getXsdDefinition(context, request, schema, added);
	}
	return schema;
}

void CAddReqdCompsRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CAddReqdCompsRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
	if (!added.getValue("WsDeployReqInfo"))
	{
		added.setValue("WsDeployReqInfo",1);
		CWsDeployReqInfo::getMapInfo(info,added);
	}
}

StringBuffer &CAddReqdCompsRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("XmlArgs");
	form.appendf("  <tr><td><b>XmlArgs: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("ReqInfo");
	form.append("<tr>").append("<td><b>ReqInfo: </b></td><td><hr/>");
	CWsDeployReqInfo::getHtmlForm(context, request, serv, method, form, false, extfix.str());
	form.append("<hr/></td></tr>");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CAddReqdCompsRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CAddReqdCompsRequest::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_XmlArgs.marshall(rpc_resp, "XmlArgs", "", "", "");
	m_ReqInfo.marshall(rpc_resp, "ReqInfo", "", "", "");
}


void CAddReqdCompsRequest::copy(CAddReqdCompsRequest &from)
{
	m_XmlArgs.copy(from.m_XmlArgs);
	m_ReqInfo.copy(from.m_ReqInfo);
}


void CAddReqdCompsRequest::copy(IConstAddReqdCompsRequest &ifrom)
{
	setXmlArgs(ifrom.getXmlArgs());
	setReqInfo(ifrom.getReqInfo());
}


void CAddReqdCompsRequest::getAttributes(IProperties &attributes)
{
}


void CAddReqdCompsRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_XmlArgs.toStr(ctx, buffer, "XmlArgs", "", true, "", "");
	m_ReqInfo.toStr(ctx, buffer, "ReqInfo", "", false, "", "");
}


void CAddReqdCompsRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CAddReqdCompsRequest::serializer(IEspContext* ctx, IConstAddReqdCompsRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<AddReqdCompsRequest>");
	// field XmlArgs
	{
		const char* s = src.getXmlArgs();
		if (s && *s)
		{
			buffer.append("<XmlArgs>");
			encodeUtf8XML(s,buffer);
			buffer.append("</XmlArgs>");
		}
	}
	// field ReqInfo
	{
		StringBuffer tmp;
		CWsDeployReqInfo::serializer(ctx,src.getReqInfo(), tmp, false);
		if (tmp.length()>0)
			buffer.appendf("<ReqInfo>%s</ReqInfo>",tmp.str());
	}
	if (keepRootTag)
		buffer.append("</AddReqdCompsRequest>");
}

bool CAddReqdCompsRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_XmlArgs.unmarshall(rpc_request, "XmlArgs", basepath);
	hasValue |= m_ReqInfo.unmarshall(rpc_request, "ReqInfo", basepath);
	return hasValue;
}

bool CAddReqdCompsRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_XmlArgs.unmarshall(ctx, soapval, "XmlArgs");
	hasValue |= m_ReqInfo.unmarshall(ctx, soapval, "ReqInfo");
	return hasValue;
}

bool CAddReqdCompsRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_XmlArgs.unmarshall(ctx, params, attachments, "XmlArgs", basepath);
	hasValue |= m_ReqInfo.unmarshall(ctx, params, attachments, "ReqInfo", basepath);
	return hasValue;
}

const char * CAddReqdCompsRequest::getXmlArgs() { return m_XmlArgs.query();}
IConstWsDeployReqInfo & CAddReqdCompsRequest::getReqInfo() { return (IConstWsDeployReqInfo &) m_ReqInfo.getValue();}
void CAddReqdCompsRequest::setXmlArgs(const char * val){ m_XmlArgs.set(val); }
IEspWsDeployReqInfo & CAddReqdCompsRequest::updateReqInfo(){ return (IEspWsDeployReqInfo &) m_ReqInfo.getValue(); }
void CAddReqdCompsRequest::setReqInfo(IConstWsDeployReqInfo &ifrom){ m_ReqInfo.copy(ifrom); }
extern "C"  IEspAddReqdCompsRequest *createAddReqdCompsRequest(const char *serv){return ((IEspAddReqdCompsRequest *)new CAddReqdCompsRequest(serv));}
extern "C"  IClientAddReqdCompsRequest *createClientAddReqdCompsRequest(const char *serv){return ((IClientAddReqdCompsRequest *)new CAddReqdCompsRequest(serv));}

//=======================================================
// class CAddReqdCompsResponse Implementation
//=======================================================

CAddReqdCompsResponse::CAddReqdCompsResponse(const char *serviceName, IRpcMessageBinding *init)
	: m_Status(nilIgnore),m_Failures(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("AddReqdCompsResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CAddReqdCompsResponse::CAddReqdCompsResponse(const char *serviceName, const char *bc)
	: m_Status(nilIgnore),m_Failures(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("AddReqdCompsResponse");
}

CAddReqdCompsResponse::CAddReqdCompsResponse(const char *serviceName, IRpcMessage* rpcmsg)
	: m_Status(nilIgnore),m_Failures(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("AddReqdCompsResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CAddReqdCompsResponse::CAddReqdCompsResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_Status(nilIgnore),m_Failures(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("AddReqdCompsResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CAddReqdCompsResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		schema.append("<xsd:element name=\"Exceptions\" type=\"tns:ArrayOfEspException\" minOccurs=\"0\" maxOccurs=\"1\"/>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Status\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Failures\" type=\"xsd:string\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CAddReqdCompsResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CAddReqdCompsResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CAddReqdCompsResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Status");
	form.appendf("  <tr><td><b>Status: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Failures");
	form.appendf("  <tr><td><b>Failures: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CAddReqdCompsResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CAddReqdCompsResponse::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	rpc_resp.setEncodeXml(false);
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
		m_Status.marshall(rpc_resp, "Status", "", "", "");
		m_Failures.marshall(rpc_resp, "Failures", "", "", "");
	}
}


void CAddReqdCompsResponse::copy(CAddReqdCompsResponse &from)
{
	m_Status.copy(from.m_Status);
	m_Failures.copy(from.m_Failures);
}


void CAddReqdCompsResponse::copy(IConstAddReqdCompsResponse &ifrom)
{
	setStatus(ifrom.getStatus());
	setFailures(ifrom.getFailures());
}


void CAddReqdCompsResponse::getAttributes(IProperties &attributes)
{
}


void CAddReqdCompsResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
		m_Status.toStr(ctx, buffer, "Status", "", false, "", "");
		m_Failures.toStr(ctx, buffer, "Failures", "", false, "", "");
	}
}


void CAddReqdCompsResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CAddReqdCompsResponse::serializer(IEspContext* ctx, IConstAddReqdCompsResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<AddReqdCompsResponse>");
	// field Status
	{
		const char* s = src.getStatus();
		if (s && *s)
		buffer.appendf("<Status>%s</Status>",s);
	}
	// field Failures
	{
		const char* s = src.getFailures();
		if (s && *s)
		buffer.appendf("<Failures>%s</Failures>",s);
	}
	if (keepRootTag)
		buffer.append("</AddReqdCompsResponse>");
}

bool CAddReqdCompsResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
		hasValue |= m_Status.unmarshall(rpc_request, "Status", basepath);
		hasValue |= m_Failures.unmarshall(rpc_request, "Failures", basepath);
	}
	return hasValue;
}

bool CAddReqdCompsResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Status.unmarshall(ctx, soapval, "Status");
	hasValue |= m_Failures.unmarshall(ctx, soapval, "Failures");
	return hasValue;
}

bool CAddReqdCompsResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Status.unmarshall(ctx, params, attachments, "Status", basepath);
	hasValue |= m_Failures.unmarshall(ctx, params, attachments, "Failures", basepath);
	return hasValue;
}

const char * CAddReqdCompsResponse::getStatus() { return m_Status.query();}
const char * CAddReqdCompsResponse::getFailures() { return m_Failures.query();}
void CAddReqdCompsResponse::setStatus(const char * val){ m_Status.set(val); }
void CAddReqdCompsResponse::setFailures(const char * val){ m_Failures.set(val); }
extern "C"  IEspAddReqdCompsResponse *createAddReqdCompsResponse(const char *serv){return ((IEspAddReqdCompsResponse *)new CAddReqdCompsResponse(serv));}
extern "C"  IClientAddReqdCompsResponse *createClientAddReqdCompsResponse(const char *serv){return ((IClientAddReqdCompsResponse *)new CAddReqdCompsResponse(serv));}

//=======================================================
// class CHandleEspServiceBindingsRequest Implementation
//=======================================================

CHandleEspServiceBindingsRequest::CHandleEspServiceBindingsRequest(const char *serviceName, IRpcMessageBinding *init)
	: m_Operation(nilIgnore),m_XmlArgs(nilIgnore),m_ReqInfo(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("HandleEspServiceBindingsRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CHandleEspServiceBindingsRequest::CHandleEspServiceBindingsRequest(const char *serviceName, const char *bc)
	: m_Operation(nilIgnore),m_XmlArgs(nilIgnore),m_ReqInfo(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("HandleEspServiceBindingsRequest");
}

CHandleEspServiceBindingsRequest::CHandleEspServiceBindingsRequest(const char *serviceName, IRpcMessage* rpcmsg)
	: m_Operation(nilIgnore),m_XmlArgs(nilIgnore),m_ReqInfo(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("HandleEspServiceBindingsRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CHandleEspServiceBindingsRequest::CHandleEspServiceBindingsRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_Operation(nilIgnore),m_XmlArgs(nilIgnore),m_ReqInfo(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("HandleEspServiceBindingsRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CHandleEspServiceBindingsRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Operation\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"XmlArgs\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"ReqInfo\" type=\"tns:WsDeployReqInfo\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	if (!(flags & 0x10)  || (flags & 0x100))
	{
		CWsDeployReqInfo::getXsdDefinition(context, request, schema, added);
	}
	return schema;
}

void CHandleEspServiceBindingsRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CHandleEspServiceBindingsRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
	if (!added.getValue("WsDeployReqInfo"))
	{
		added.setValue("WsDeployReqInfo",1);
		CWsDeployReqInfo::getMapInfo(info,added);
	}
}

StringBuffer &CHandleEspServiceBindingsRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Operation");
	form.appendf("  <tr><td><b>Operation: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("XmlArgs");
	form.appendf("  <tr><td><b>XmlArgs: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("ReqInfo");
	form.append("<tr>").append("<td><b>ReqInfo: </b></td><td><hr/>");
	CWsDeployReqInfo::getHtmlForm(context, request, serv, method, form, false, extfix.str());
	form.append("<hr/></td></tr>");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CHandleEspServiceBindingsRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CHandleEspServiceBindingsRequest::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_Operation.marshall(rpc_resp, "Operation", "", "", "");
	m_XmlArgs.marshall(rpc_resp, "XmlArgs", "", "", "");
	m_ReqInfo.marshall(rpc_resp, "ReqInfo", "", "", "");
}


void CHandleEspServiceBindingsRequest::copy(CHandleEspServiceBindingsRequest &from)
{
	m_Operation.copy(from.m_Operation);
	m_XmlArgs.copy(from.m_XmlArgs);
	m_ReqInfo.copy(from.m_ReqInfo);
}


void CHandleEspServiceBindingsRequest::copy(IConstHandleEspServiceBindingsRequest &ifrom)
{
	setOperation(ifrom.getOperation());
	setXmlArgs(ifrom.getXmlArgs());
	setReqInfo(ifrom.getReqInfo());
}


void CHandleEspServiceBindingsRequest::getAttributes(IProperties &attributes)
{
}


void CHandleEspServiceBindingsRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_Operation.toStr(ctx, buffer, "Operation", "", true, "", "");
	m_XmlArgs.toStr(ctx, buffer, "XmlArgs", "", true, "", "");
	m_ReqInfo.toStr(ctx, buffer, "ReqInfo", "", false, "", "");
}


void CHandleEspServiceBindingsRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CHandleEspServiceBindingsRequest::serializer(IEspContext* ctx, IConstHandleEspServiceBindingsRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<HandleEspServiceBindingsRequest>");
	// field Operation
	{
		const char* s = src.getOperation();
		if (s && *s)
		{
			buffer.append("<Operation>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Operation>");
		}
	}
	// field XmlArgs
	{
		const char* s = src.getXmlArgs();
		if (s && *s)
		{
			buffer.append("<XmlArgs>");
			encodeUtf8XML(s,buffer);
			buffer.append("</XmlArgs>");
		}
	}
	// field ReqInfo
	{
		StringBuffer tmp;
		CWsDeployReqInfo::serializer(ctx,src.getReqInfo(), tmp, false);
		if (tmp.length()>0)
			buffer.appendf("<ReqInfo>%s</ReqInfo>",tmp.str());
	}
	if (keepRootTag)
		buffer.append("</HandleEspServiceBindingsRequest>");
}

bool CHandleEspServiceBindingsRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_Operation.unmarshall(rpc_request, "Operation", basepath);
	hasValue |= m_XmlArgs.unmarshall(rpc_request, "XmlArgs", basepath);
	hasValue |= m_ReqInfo.unmarshall(rpc_request, "ReqInfo", basepath);
	return hasValue;
}

bool CHandleEspServiceBindingsRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Operation.unmarshall(ctx, soapval, "Operation");
	hasValue |= m_XmlArgs.unmarshall(ctx, soapval, "XmlArgs");
	hasValue |= m_ReqInfo.unmarshall(ctx, soapval, "ReqInfo");
	return hasValue;
}

bool CHandleEspServiceBindingsRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Operation.unmarshall(ctx, params, attachments, "Operation", basepath);
	hasValue |= m_XmlArgs.unmarshall(ctx, params, attachments, "XmlArgs", basepath);
	hasValue |= m_ReqInfo.unmarshall(ctx, params, attachments, "ReqInfo", basepath);
	return hasValue;
}

const char * CHandleEspServiceBindingsRequest::getOperation() { return m_Operation.query();}
const char * CHandleEspServiceBindingsRequest::getXmlArgs() { return m_XmlArgs.query();}
IConstWsDeployReqInfo & CHandleEspServiceBindingsRequest::getReqInfo() { return (IConstWsDeployReqInfo &) m_ReqInfo.getValue();}
void CHandleEspServiceBindingsRequest::setOperation(const char * val){ m_Operation.set(val); }
void CHandleEspServiceBindingsRequest::setXmlArgs(const char * val){ m_XmlArgs.set(val); }
IEspWsDeployReqInfo & CHandleEspServiceBindingsRequest::updateReqInfo(){ return (IEspWsDeployReqInfo &) m_ReqInfo.getValue(); }
void CHandleEspServiceBindingsRequest::setReqInfo(IConstWsDeployReqInfo &ifrom){ m_ReqInfo.copy(ifrom); }
extern "C"  IEspHandleEspServiceBindingsRequest *createHandleEspServiceBindingsRequest(const char *serv){return ((IEspHandleEspServiceBindingsRequest *)new CHandleEspServiceBindingsRequest(serv));}
extern "C"  IClientHandleEspServiceBindingsRequest *createClientHandleEspServiceBindingsRequest(const char *serv){return ((IClientHandleEspServiceBindingsRequest *)new CHandleEspServiceBindingsRequest(serv));}

//=======================================================
// class CHandleEspServiceBindingsResponse Implementation
//=======================================================

CHandleEspServiceBindingsResponse::CHandleEspServiceBindingsResponse(const char *serviceName, IRpcMessageBinding *init)
	: m_Status(nilIgnore),m_NewName(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("HandleEspServiceBindingsResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CHandleEspServiceBindingsResponse::CHandleEspServiceBindingsResponse(const char *serviceName, const char *bc)
	: m_Status(nilIgnore),m_NewName(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("HandleEspServiceBindingsResponse");
}

CHandleEspServiceBindingsResponse::CHandleEspServiceBindingsResponse(const char *serviceName, IRpcMessage* rpcmsg)
	: m_Status(nilIgnore),m_NewName(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("HandleEspServiceBindingsResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CHandleEspServiceBindingsResponse::CHandleEspServiceBindingsResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_Status(nilIgnore),m_NewName(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("HandleEspServiceBindingsResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CHandleEspServiceBindingsResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		schema.append("<xsd:element name=\"Exceptions\" type=\"tns:ArrayOfEspException\" minOccurs=\"0\" maxOccurs=\"1\"/>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Status\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"NewName\" type=\"xsd:string\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CHandleEspServiceBindingsResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CHandleEspServiceBindingsResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CHandleEspServiceBindingsResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Status");
	form.appendf("  <tr><td><b>Status: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("NewName");
	form.appendf("  <tr><td><b>NewName: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CHandleEspServiceBindingsResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CHandleEspServiceBindingsResponse::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	rpc_resp.setEncodeXml(false);
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
		m_Status.marshall(rpc_resp, "Status", "", "", "");
		m_NewName.marshall(rpc_resp, "NewName", "", "", "");
	}
}


void CHandleEspServiceBindingsResponse::copy(CHandleEspServiceBindingsResponse &from)
{
	m_Status.copy(from.m_Status);
	m_NewName.copy(from.m_NewName);
}


void CHandleEspServiceBindingsResponse::copy(IConstHandleEspServiceBindingsResponse &ifrom)
{
	setStatus(ifrom.getStatus());
	setNewName(ifrom.getNewName());
}


void CHandleEspServiceBindingsResponse::getAttributes(IProperties &attributes)
{
}


void CHandleEspServiceBindingsResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
		m_Status.toStr(ctx, buffer, "Status", "", false, "", "");
		m_NewName.toStr(ctx, buffer, "NewName", "", false, "", "");
	}
}


void CHandleEspServiceBindingsResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CHandleEspServiceBindingsResponse::serializer(IEspContext* ctx, IConstHandleEspServiceBindingsResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<HandleEspServiceBindingsResponse>");
	// field Status
	{
		const char* s = src.getStatus();
		if (s && *s)
		buffer.appendf("<Status>%s</Status>",s);
	}
	// field NewName
	{
		const char* s = src.getNewName();
		if (s && *s)
		buffer.appendf("<NewName>%s</NewName>",s);
	}
	if (keepRootTag)
		buffer.append("</HandleEspServiceBindingsResponse>");
}

bool CHandleEspServiceBindingsResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
		hasValue |= m_Status.unmarshall(rpc_request, "Status", basepath);
		hasValue |= m_NewName.unmarshall(rpc_request, "NewName", basepath);
	}
	return hasValue;
}

bool CHandleEspServiceBindingsResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Status.unmarshall(ctx, soapval, "Status");
	hasValue |= m_NewName.unmarshall(ctx, soapval, "NewName");
	return hasValue;
}

bool CHandleEspServiceBindingsResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Status.unmarshall(ctx, params, attachments, "Status", basepath);
	hasValue |= m_NewName.unmarshall(ctx, params, attachments, "NewName", basepath);
	return hasValue;
}

const char * CHandleEspServiceBindingsResponse::getStatus() { return m_Status.query();}
const char * CHandleEspServiceBindingsResponse::getNewName() { return m_NewName.query();}
void CHandleEspServiceBindingsResponse::setStatus(const char * val){ m_Status.set(val); }
void CHandleEspServiceBindingsResponse::setNewName(const char * val){ m_NewName.set(val); }
extern "C"  IEspHandleEspServiceBindingsResponse *createHandleEspServiceBindingsResponse(const char *serv){return ((IEspHandleEspServiceBindingsResponse *)new CHandleEspServiceBindingsResponse(serv));}
extern "C"  IClientHandleEspServiceBindingsResponse *createClientHandleEspServiceBindingsResponse(const char *serv){return ((IClientHandleEspServiceBindingsResponse *)new CHandleEspServiceBindingsResponse(serv));}

//=======================================================
// class CHandleComputerRequest Implementation
//=======================================================

CHandleComputerRequest::CHandleComputerRequest(const char *serviceName, IRpcMessageBinding *init)
	: m_Operation(nilIgnore),m_XmlArgs(nilIgnore),m_ReqInfo(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("HandleComputerRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CHandleComputerRequest::CHandleComputerRequest(const char *serviceName, const char *bc)
	: m_Operation(nilIgnore),m_XmlArgs(nilIgnore),m_ReqInfo(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("HandleComputerRequest");
}

CHandleComputerRequest::CHandleComputerRequest(const char *serviceName, IRpcMessage* rpcmsg)
	: m_Operation(nilIgnore),m_XmlArgs(nilIgnore),m_ReqInfo(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("HandleComputerRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CHandleComputerRequest::CHandleComputerRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_Operation(nilIgnore),m_XmlArgs(nilIgnore),m_ReqInfo(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("HandleComputerRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CHandleComputerRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Operation\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"XmlArgs\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"ReqInfo\" type=\"tns:WsDeployReqInfo\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	if (!(flags & 0x10)  || (flags & 0x100))
	{
		CWsDeployReqInfo::getXsdDefinition(context, request, schema, added);
	}
	return schema;
}

void CHandleComputerRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CHandleComputerRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
	if (!added.getValue("WsDeployReqInfo"))
	{
		added.setValue("WsDeployReqInfo",1);
		CWsDeployReqInfo::getMapInfo(info,added);
	}
}

StringBuffer &CHandleComputerRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Operation");
	form.appendf("  <tr><td><b>Operation: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("XmlArgs");
	form.appendf("  <tr><td><b>XmlArgs: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("ReqInfo");
	form.append("<tr>").append("<td><b>ReqInfo: </b></td><td><hr/>");
	CWsDeployReqInfo::getHtmlForm(context, request, serv, method, form, false, extfix.str());
	form.append("<hr/></td></tr>");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CHandleComputerRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CHandleComputerRequest::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_Operation.marshall(rpc_resp, "Operation", "", "", "");
	m_XmlArgs.marshall(rpc_resp, "XmlArgs", "", "", "");
	m_ReqInfo.marshall(rpc_resp, "ReqInfo", "", "", "");
}


void CHandleComputerRequest::copy(CHandleComputerRequest &from)
{
	m_Operation.copy(from.m_Operation);
	m_XmlArgs.copy(from.m_XmlArgs);
	m_ReqInfo.copy(from.m_ReqInfo);
}


void CHandleComputerRequest::copy(IConstHandleComputerRequest &ifrom)
{
	setOperation(ifrom.getOperation());
	setXmlArgs(ifrom.getXmlArgs());
	setReqInfo(ifrom.getReqInfo());
}


void CHandleComputerRequest::getAttributes(IProperties &attributes)
{
}


void CHandleComputerRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_Operation.toStr(ctx, buffer, "Operation", "", true, "", "");
	m_XmlArgs.toStr(ctx, buffer, "XmlArgs", "", true, "", "");
	m_ReqInfo.toStr(ctx, buffer, "ReqInfo", "", false, "", "");
}


void CHandleComputerRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CHandleComputerRequest::serializer(IEspContext* ctx, IConstHandleComputerRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<HandleComputerRequest>");
	// field Operation
	{
		const char* s = src.getOperation();
		if (s && *s)
		{
			buffer.append("<Operation>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Operation>");
		}
	}
	// field XmlArgs
	{
		const char* s = src.getXmlArgs();
		if (s && *s)
		{
			buffer.append("<XmlArgs>");
			encodeUtf8XML(s,buffer);
			buffer.append("</XmlArgs>");
		}
	}
	// field ReqInfo
	{
		StringBuffer tmp;
		CWsDeployReqInfo::serializer(ctx,src.getReqInfo(), tmp, false);
		if (tmp.length()>0)
			buffer.appendf("<ReqInfo>%s</ReqInfo>",tmp.str());
	}
	if (keepRootTag)
		buffer.append("</HandleComputerRequest>");
}

bool CHandleComputerRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_Operation.unmarshall(rpc_request, "Operation", basepath);
	hasValue |= m_XmlArgs.unmarshall(rpc_request, "XmlArgs", basepath);
	hasValue |= m_ReqInfo.unmarshall(rpc_request, "ReqInfo", basepath);
	return hasValue;
}

bool CHandleComputerRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Operation.unmarshall(ctx, soapval, "Operation");
	hasValue |= m_XmlArgs.unmarshall(ctx, soapval, "XmlArgs");
	hasValue |= m_ReqInfo.unmarshall(ctx, soapval, "ReqInfo");
	return hasValue;
}

bool CHandleComputerRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Operation.unmarshall(ctx, params, attachments, "Operation", basepath);
	hasValue |= m_XmlArgs.unmarshall(ctx, params, attachments, "XmlArgs", basepath);
	hasValue |= m_ReqInfo.unmarshall(ctx, params, attachments, "ReqInfo", basepath);
	return hasValue;
}

const char * CHandleComputerRequest::getOperation() { return m_Operation.query();}
const char * CHandleComputerRequest::getXmlArgs() { return m_XmlArgs.query();}
IConstWsDeployReqInfo & CHandleComputerRequest::getReqInfo() { return (IConstWsDeployReqInfo &) m_ReqInfo.getValue();}
void CHandleComputerRequest::setOperation(const char * val){ m_Operation.set(val); }
void CHandleComputerRequest::setXmlArgs(const char * val){ m_XmlArgs.set(val); }
IEspWsDeployReqInfo & CHandleComputerRequest::updateReqInfo(){ return (IEspWsDeployReqInfo &) m_ReqInfo.getValue(); }
void CHandleComputerRequest::setReqInfo(IConstWsDeployReqInfo &ifrom){ m_ReqInfo.copy(ifrom); }
extern "C"  IEspHandleComputerRequest *createHandleComputerRequest(const char *serv){return ((IEspHandleComputerRequest *)new CHandleComputerRequest(serv));}
extern "C"  IClientHandleComputerRequest *createClientHandleComputerRequest(const char *serv){return ((IClientHandleComputerRequest *)new CHandleComputerRequest(serv));}

//=======================================================
// class CHandleComputerResponse Implementation
//=======================================================

CHandleComputerResponse::CHandleComputerResponse(const char *serviceName, IRpcMessageBinding *init)
	: m_Status(nilIgnore),m_CompName(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("HandleComputerResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CHandleComputerResponse::CHandleComputerResponse(const char *serviceName, const char *bc)
	: m_Status(nilIgnore),m_CompName(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("HandleComputerResponse");
}

CHandleComputerResponse::CHandleComputerResponse(const char *serviceName, IRpcMessage* rpcmsg)
	: m_Status(nilIgnore),m_CompName(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("HandleComputerResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CHandleComputerResponse::CHandleComputerResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_Status(nilIgnore),m_CompName(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("HandleComputerResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CHandleComputerResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		schema.append("<xsd:element name=\"Exceptions\" type=\"tns:ArrayOfEspException\" minOccurs=\"0\" maxOccurs=\"1\"/>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Status\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"CompName\" type=\"xsd:string\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CHandleComputerResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CHandleComputerResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CHandleComputerResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Status");
	form.appendf("  <tr><td><b>Status: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("CompName");
	form.appendf("  <tr><td><b>CompName: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CHandleComputerResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CHandleComputerResponse::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	rpc_resp.setEncodeXml(false);
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
		m_Status.marshall(rpc_resp, "Status", "", "", "");
		m_CompName.marshall(rpc_resp, "CompName", "", "", "");
	}
}


void CHandleComputerResponse::copy(CHandleComputerResponse &from)
{
	m_Status.copy(from.m_Status);
	m_CompName.copy(from.m_CompName);
}


void CHandleComputerResponse::copy(IConstHandleComputerResponse &ifrom)
{
	setStatus(ifrom.getStatus());
	setCompName(ifrom.getCompName());
}


void CHandleComputerResponse::getAttributes(IProperties &attributes)
{
}


void CHandleComputerResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
		m_Status.toStr(ctx, buffer, "Status", "", false, "", "");
		m_CompName.toStr(ctx, buffer, "CompName", "", false, "", "");
	}
}


void CHandleComputerResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CHandleComputerResponse::serializer(IEspContext* ctx, IConstHandleComputerResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<HandleComputerResponse>");
	// field Status
	{
		const char* s = src.getStatus();
		if (s && *s)
		buffer.appendf("<Status>%s</Status>",s);
	}
	// field CompName
	{
		const char* s = src.getCompName();
		if (s && *s)
		buffer.appendf("<CompName>%s</CompName>",s);
	}
	if (keepRootTag)
		buffer.append("</HandleComputerResponse>");
}

bool CHandleComputerResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
		hasValue |= m_Status.unmarshall(rpc_request, "Status", basepath);
		hasValue |= m_CompName.unmarshall(rpc_request, "CompName", basepath);
	}
	return hasValue;
}

bool CHandleComputerResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Status.unmarshall(ctx, soapval, "Status");
	hasValue |= m_CompName.unmarshall(ctx, soapval, "CompName");
	return hasValue;
}

bool CHandleComputerResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Status.unmarshall(ctx, params, attachments, "Status", basepath);
	hasValue |= m_CompName.unmarshall(ctx, params, attachments, "CompName", basepath);
	return hasValue;
}

const char * CHandleComputerResponse::getStatus() { return m_Status.query();}
const char * CHandleComputerResponse::getCompName() { return m_CompName.query();}
void CHandleComputerResponse::setStatus(const char * val){ m_Status.set(val); }
void CHandleComputerResponse::setCompName(const char * val){ m_CompName.set(val); }
extern "C"  IEspHandleComputerResponse *createHandleComputerResponse(const char *serv){return ((IEspHandleComputerResponse *)new CHandleComputerResponse(serv));}
extern "C"  IClientHandleComputerResponse *createClientHandleComputerResponse(const char *serv){return ((IClientHandleComputerResponse *)new CHandleComputerResponse(serv));}

//=======================================================
// class CHandleTopologyRequest Implementation
//=======================================================

CHandleTopologyRequest::CHandleTopologyRequest(const char *serviceName, IRpcMessageBinding *init)
	: m_Operation(nilIgnore),m_XmlArgs(nilIgnore),m_ReqInfo(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("HandleTopologyRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CHandleTopologyRequest::CHandleTopologyRequest(const char *serviceName, const char *bc)
	: m_Operation(nilIgnore),m_XmlArgs(nilIgnore),m_ReqInfo(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("HandleTopologyRequest");
}

CHandleTopologyRequest::CHandleTopologyRequest(const char *serviceName, IRpcMessage* rpcmsg)
	: m_Operation(nilIgnore),m_XmlArgs(nilIgnore),m_ReqInfo(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("HandleTopologyRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CHandleTopologyRequest::CHandleTopologyRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_Operation(nilIgnore),m_XmlArgs(nilIgnore),m_ReqInfo(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("HandleTopologyRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CHandleTopologyRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Operation\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"XmlArgs\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"ReqInfo\" type=\"tns:WsDeployReqInfo\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	if (!(flags & 0x10)  || (flags & 0x100))
	{
		CWsDeployReqInfo::getXsdDefinition(context, request, schema, added);
	}
	return schema;
}

void CHandleTopologyRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CHandleTopologyRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
	if (!added.getValue("WsDeployReqInfo"))
	{
		added.setValue("WsDeployReqInfo",1);
		CWsDeployReqInfo::getMapInfo(info,added);
	}
}

StringBuffer &CHandleTopologyRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Operation");
	form.appendf("  <tr><td><b>Operation: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("XmlArgs");
	form.appendf("  <tr><td><b>XmlArgs: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("ReqInfo");
	form.append("<tr>").append("<td><b>ReqInfo: </b></td><td><hr/>");
	CWsDeployReqInfo::getHtmlForm(context, request, serv, method, form, false, extfix.str());
	form.append("<hr/></td></tr>");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CHandleTopologyRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CHandleTopologyRequest::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_Operation.marshall(rpc_resp, "Operation", "", "", "");
	m_XmlArgs.marshall(rpc_resp, "XmlArgs", "", "", "");
	m_ReqInfo.marshall(rpc_resp, "ReqInfo", "", "", "");
}


void CHandleTopologyRequest::copy(CHandleTopologyRequest &from)
{
	m_Operation.copy(from.m_Operation);
	m_XmlArgs.copy(from.m_XmlArgs);
	m_ReqInfo.copy(from.m_ReqInfo);
}


void CHandleTopologyRequest::copy(IConstHandleTopologyRequest &ifrom)
{
	setOperation(ifrom.getOperation());
	setXmlArgs(ifrom.getXmlArgs());
	setReqInfo(ifrom.getReqInfo());
}


void CHandleTopologyRequest::getAttributes(IProperties &attributes)
{
}


void CHandleTopologyRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_Operation.toStr(ctx, buffer, "Operation", "", true, "", "");
	m_XmlArgs.toStr(ctx, buffer, "XmlArgs", "", true, "", "");
	m_ReqInfo.toStr(ctx, buffer, "ReqInfo", "", false, "", "");
}


void CHandleTopologyRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CHandleTopologyRequest::serializer(IEspContext* ctx, IConstHandleTopologyRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<HandleTopologyRequest>");
	// field Operation
	{
		const char* s = src.getOperation();
		if (s && *s)
		{
			buffer.append("<Operation>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Operation>");
		}
	}
	// field XmlArgs
	{
		const char* s = src.getXmlArgs();
		if (s && *s)
		{
			buffer.append("<XmlArgs>");
			encodeUtf8XML(s,buffer);
			buffer.append("</XmlArgs>");
		}
	}
	// field ReqInfo
	{
		StringBuffer tmp;
		CWsDeployReqInfo::serializer(ctx,src.getReqInfo(), tmp, false);
		if (tmp.length()>0)
			buffer.appendf("<ReqInfo>%s</ReqInfo>",tmp.str());
	}
	if (keepRootTag)
		buffer.append("</HandleTopologyRequest>");
}

bool CHandleTopologyRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_Operation.unmarshall(rpc_request, "Operation", basepath);
	hasValue |= m_XmlArgs.unmarshall(rpc_request, "XmlArgs", basepath);
	hasValue |= m_ReqInfo.unmarshall(rpc_request, "ReqInfo", basepath);
	return hasValue;
}

bool CHandleTopologyRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Operation.unmarshall(ctx, soapval, "Operation");
	hasValue |= m_XmlArgs.unmarshall(ctx, soapval, "XmlArgs");
	hasValue |= m_ReqInfo.unmarshall(ctx, soapval, "ReqInfo");
	return hasValue;
}

bool CHandleTopologyRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Operation.unmarshall(ctx, params, attachments, "Operation", basepath);
	hasValue |= m_XmlArgs.unmarshall(ctx, params, attachments, "XmlArgs", basepath);
	hasValue |= m_ReqInfo.unmarshall(ctx, params, attachments, "ReqInfo", basepath);
	return hasValue;
}

const char * CHandleTopologyRequest::getOperation() { return m_Operation.query();}
const char * CHandleTopologyRequest::getXmlArgs() { return m_XmlArgs.query();}
IConstWsDeployReqInfo & CHandleTopologyRequest::getReqInfo() { return (IConstWsDeployReqInfo &) m_ReqInfo.getValue();}
void CHandleTopologyRequest::setOperation(const char * val){ m_Operation.set(val); }
void CHandleTopologyRequest::setXmlArgs(const char * val){ m_XmlArgs.set(val); }
IEspWsDeployReqInfo & CHandleTopologyRequest::updateReqInfo(){ return (IEspWsDeployReqInfo &) m_ReqInfo.getValue(); }
void CHandleTopologyRequest::setReqInfo(IConstWsDeployReqInfo &ifrom){ m_ReqInfo.copy(ifrom); }
extern "C"  IEspHandleTopologyRequest *createHandleTopologyRequest(const char *serv){return ((IEspHandleTopologyRequest *)new CHandleTopologyRequest(serv));}
extern "C"  IClientHandleTopologyRequest *createClientHandleTopologyRequest(const char *serv){return ((IClientHandleTopologyRequest *)new CHandleTopologyRequest(serv));}

//=======================================================
// class CHandleTopologyResponse Implementation
//=======================================================

CHandleTopologyResponse::CHandleTopologyResponse(const char *serviceName, IRpcMessageBinding *init)
	: m_Status(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("HandleTopologyResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CHandleTopologyResponse::CHandleTopologyResponse(const char *serviceName, const char *bc)
	: m_Status(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("HandleTopologyResponse");
}

CHandleTopologyResponse::CHandleTopologyResponse(const char *serviceName, IRpcMessage* rpcmsg)
	: m_Status(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("HandleTopologyResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CHandleTopologyResponse::CHandleTopologyResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_Status(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("HandleTopologyResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CHandleTopologyResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		schema.append("<xsd:element name=\"Exceptions\" type=\"tns:ArrayOfEspException\" minOccurs=\"0\" maxOccurs=\"1\"/>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Status\" type=\"xsd:string\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CHandleTopologyResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CHandleTopologyResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CHandleTopologyResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Status");
	form.appendf("  <tr><td><b>Status: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CHandleTopologyResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CHandleTopologyResponse::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	rpc_resp.setEncodeXml(false);
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
		m_Status.marshall(rpc_resp, "Status", "", "", "");
	}
}


void CHandleTopologyResponse::copy(CHandleTopologyResponse &from)
{
	m_Status.copy(from.m_Status);
}


void CHandleTopologyResponse::copy(IConstHandleTopologyResponse &ifrom)
{
	setStatus(ifrom.getStatus());
}


void CHandleTopologyResponse::getAttributes(IProperties &attributes)
{
}


void CHandleTopologyResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
		m_Status.toStr(ctx, buffer, "Status", "", false, "", "");
	}
}


void CHandleTopologyResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CHandleTopologyResponse::serializer(IEspContext* ctx, IConstHandleTopologyResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<HandleTopologyResponse>");
	// field Status
	{
		const char* s = src.getStatus();
		if (s && *s)
		buffer.appendf("<Status>%s</Status>",s);
	}
	if (keepRootTag)
		buffer.append("</HandleTopologyResponse>");
}

bool CHandleTopologyResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
		hasValue |= m_Status.unmarshall(rpc_request, "Status", basepath);
	}
	return hasValue;
}

bool CHandleTopologyResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Status.unmarshall(ctx, soapval, "Status");
	return hasValue;
}

bool CHandleTopologyResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Status.unmarshall(ctx, params, attachments, "Status", basepath);
	return hasValue;
}

const char * CHandleTopologyResponse::getStatus() { return m_Status.query();}
void CHandleTopologyResponse::setStatus(const char * val){ m_Status.set(val); }
extern "C"  IEspHandleTopologyResponse *createHandleTopologyResponse(const char *serv){return ((IEspHandleTopologyResponse *)new CHandleTopologyResponse(serv));}
extern "C"  IClientHandleTopologyResponse *createClientHandleTopologyResponse(const char *serv){return ((IClientHandleTopologyResponse *)new CHandleTopologyResponse(serv));}

//=======================================================
// class CHandleRowsRequest Implementation
//=======================================================

CHandleRowsRequest::CHandleRowsRequest(const char *serviceName, IRpcMessageBinding *init)
	: m_Operation(nilIgnore),m_XmlArgs(nilIgnore),m_ReqInfo(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("HandleRowsRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CHandleRowsRequest::CHandleRowsRequest(const char *serviceName, const char *bc)
	: m_Operation(nilIgnore),m_XmlArgs(nilIgnore),m_ReqInfo(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("HandleRowsRequest");
}

CHandleRowsRequest::CHandleRowsRequest(const char *serviceName, IRpcMessage* rpcmsg)
	: m_Operation(nilIgnore),m_XmlArgs(nilIgnore),m_ReqInfo(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("HandleRowsRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CHandleRowsRequest::CHandleRowsRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_Operation(nilIgnore),m_XmlArgs(nilIgnore),m_ReqInfo(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("HandleRowsRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CHandleRowsRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Operation\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"XmlArgs\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"ReqInfo\" type=\"tns:WsDeployReqInfo\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	if (!(flags & 0x10)  || (flags & 0x100))
	{
		CWsDeployReqInfo::getXsdDefinition(context, request, schema, added);
	}
	return schema;
}

void CHandleRowsRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CHandleRowsRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
	if (!added.getValue("WsDeployReqInfo"))
	{
		added.setValue("WsDeployReqInfo",1);
		CWsDeployReqInfo::getMapInfo(info,added);
	}
}

StringBuffer &CHandleRowsRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Operation");
	form.appendf("  <tr><td><b>Operation: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("XmlArgs");
	form.appendf("  <tr><td><b>XmlArgs: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("ReqInfo");
	form.append("<tr>").append("<td><b>ReqInfo: </b></td><td><hr/>");
	CWsDeployReqInfo::getHtmlForm(context, request, serv, method, form, false, extfix.str());
	form.append("<hr/></td></tr>");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CHandleRowsRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CHandleRowsRequest::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_Operation.marshall(rpc_resp, "Operation", "", "", "");
	m_XmlArgs.marshall(rpc_resp, "XmlArgs", "", "", "");
	m_ReqInfo.marshall(rpc_resp, "ReqInfo", "", "", "");
}


void CHandleRowsRequest::copy(CHandleRowsRequest &from)
{
	m_Operation.copy(from.m_Operation);
	m_XmlArgs.copy(from.m_XmlArgs);
	m_ReqInfo.copy(from.m_ReqInfo);
}


void CHandleRowsRequest::copy(IConstHandleRowsRequest &ifrom)
{
	setOperation(ifrom.getOperation());
	setXmlArgs(ifrom.getXmlArgs());
	setReqInfo(ifrom.getReqInfo());
}


void CHandleRowsRequest::getAttributes(IProperties &attributes)
{
}


void CHandleRowsRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_Operation.toStr(ctx, buffer, "Operation", "", true, "", "");
	m_XmlArgs.toStr(ctx, buffer, "XmlArgs", "", true, "", "");
	m_ReqInfo.toStr(ctx, buffer, "ReqInfo", "", false, "", "");
}


void CHandleRowsRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CHandleRowsRequest::serializer(IEspContext* ctx, IConstHandleRowsRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<HandleRowsRequest>");
	// field Operation
	{
		const char* s = src.getOperation();
		if (s && *s)
		{
			buffer.append("<Operation>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Operation>");
		}
	}
	// field XmlArgs
	{
		const char* s = src.getXmlArgs();
		if (s && *s)
		{
			buffer.append("<XmlArgs>");
			encodeUtf8XML(s,buffer);
			buffer.append("</XmlArgs>");
		}
	}
	// field ReqInfo
	{
		StringBuffer tmp;
		CWsDeployReqInfo::serializer(ctx,src.getReqInfo(), tmp, false);
		if (tmp.length()>0)
			buffer.appendf("<ReqInfo>%s</ReqInfo>",tmp.str());
	}
	if (keepRootTag)
		buffer.append("</HandleRowsRequest>");
}

bool CHandleRowsRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_Operation.unmarshall(rpc_request, "Operation", basepath);
	hasValue |= m_XmlArgs.unmarshall(rpc_request, "XmlArgs", basepath);
	hasValue |= m_ReqInfo.unmarshall(rpc_request, "ReqInfo", basepath);
	return hasValue;
}

bool CHandleRowsRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Operation.unmarshall(ctx, soapval, "Operation");
	hasValue |= m_XmlArgs.unmarshall(ctx, soapval, "XmlArgs");
	hasValue |= m_ReqInfo.unmarshall(ctx, soapval, "ReqInfo");
	return hasValue;
}

bool CHandleRowsRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Operation.unmarshall(ctx, params, attachments, "Operation", basepath);
	hasValue |= m_XmlArgs.unmarshall(ctx, params, attachments, "XmlArgs", basepath);
	hasValue |= m_ReqInfo.unmarshall(ctx, params, attachments, "ReqInfo", basepath);
	return hasValue;
}

const char * CHandleRowsRequest::getOperation() { return m_Operation.query();}
const char * CHandleRowsRequest::getXmlArgs() { return m_XmlArgs.query();}
IConstWsDeployReqInfo & CHandleRowsRequest::getReqInfo() { return (IConstWsDeployReqInfo &) m_ReqInfo.getValue();}
void CHandleRowsRequest::setOperation(const char * val){ m_Operation.set(val); }
void CHandleRowsRequest::setXmlArgs(const char * val){ m_XmlArgs.set(val); }
IEspWsDeployReqInfo & CHandleRowsRequest::updateReqInfo(){ return (IEspWsDeployReqInfo &) m_ReqInfo.getValue(); }
void CHandleRowsRequest::setReqInfo(IConstWsDeployReqInfo &ifrom){ m_ReqInfo.copy(ifrom); }
extern "C"  IEspHandleRowsRequest *createHandleRowsRequest(const char *serv){return ((IEspHandleRowsRequest *)new CHandleRowsRequest(serv));}
extern "C"  IClientHandleRowsRequest *createClientHandleRowsRequest(const char *serv){return ((IClientHandleRowsRequest *)new CHandleRowsRequest(serv));}

//=======================================================
// class CHandleRowsResponse Implementation
//=======================================================

CHandleRowsResponse::CHandleRowsResponse(const char *serviceName, IRpcMessageBinding *init)
	: m_Status(nilIgnore),m_CompName(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("HandleRowsResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CHandleRowsResponse::CHandleRowsResponse(const char *serviceName, const char *bc)
	: m_Status(nilIgnore),m_CompName(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("HandleRowsResponse");
}

CHandleRowsResponse::CHandleRowsResponse(const char *serviceName, IRpcMessage* rpcmsg)
	: m_Status(nilIgnore),m_CompName(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("HandleRowsResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CHandleRowsResponse::CHandleRowsResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_Status(nilIgnore),m_CompName(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("HandleRowsResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CHandleRowsResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		schema.append("<xsd:element name=\"Exceptions\" type=\"tns:ArrayOfEspException\" minOccurs=\"0\" maxOccurs=\"1\"/>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Status\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"CompName\" type=\"xsd:string\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CHandleRowsResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CHandleRowsResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CHandleRowsResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Status");
	form.appendf("  <tr><td><b>Status: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("CompName");
	form.appendf("  <tr><td><b>CompName: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CHandleRowsResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CHandleRowsResponse::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	rpc_resp.setEncodeXml(false);
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
		m_Status.marshall(rpc_resp, "Status", "", "", "");
		m_CompName.marshall(rpc_resp, "CompName", "", "", "");
	}
}


void CHandleRowsResponse::copy(CHandleRowsResponse &from)
{
	m_Status.copy(from.m_Status);
	m_CompName.copy(from.m_CompName);
}


void CHandleRowsResponse::copy(IConstHandleRowsResponse &ifrom)
{
	setStatus(ifrom.getStatus());
	setCompName(ifrom.getCompName());
}


void CHandleRowsResponse::getAttributes(IProperties &attributes)
{
}


void CHandleRowsResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
		m_Status.toStr(ctx, buffer, "Status", "", false, "", "");
		m_CompName.toStr(ctx, buffer, "CompName", "", false, "", "");
	}
}


void CHandleRowsResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CHandleRowsResponse::serializer(IEspContext* ctx, IConstHandleRowsResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<HandleRowsResponse>");
	// field Status
	{
		const char* s = src.getStatus();
		if (s && *s)
		buffer.appendf("<Status>%s</Status>",s);
	}
	// field CompName
	{
		const char* s = src.getCompName();
		if (s && *s)
		buffer.appendf("<CompName>%s</CompName>",s);
	}
	if (keepRootTag)
		buffer.append("</HandleRowsResponse>");
}

bool CHandleRowsResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
		hasValue |= m_Status.unmarshall(rpc_request, "Status", basepath);
		hasValue |= m_CompName.unmarshall(rpc_request, "CompName", basepath);
	}
	return hasValue;
}

bool CHandleRowsResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Status.unmarshall(ctx, soapval, "Status");
	hasValue |= m_CompName.unmarshall(ctx, soapval, "CompName");
	return hasValue;
}

bool CHandleRowsResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Status.unmarshall(ctx, params, attachments, "Status", basepath);
	hasValue |= m_CompName.unmarshall(ctx, params, attachments, "CompName", basepath);
	return hasValue;
}

const char * CHandleRowsResponse::getStatus() { return m_Status.query();}
const char * CHandleRowsResponse::getCompName() { return m_CompName.query();}
void CHandleRowsResponse::setStatus(const char * val){ m_Status.set(val); }
void CHandleRowsResponse::setCompName(const char * val){ m_CompName.set(val); }
extern "C"  IEspHandleRowsResponse *createHandleRowsResponse(const char *serv){return ((IEspHandleRowsResponse *)new CHandleRowsResponse(serv));}
extern "C"  IClientHandleRowsResponse *createClientHandleRowsResponse(const char *serv){return ((IClientHandleRowsResponse *)new CHandleRowsResponse(serv));}

//=======================================================
// class CHandleAccessRulesRequest Implementation
//=======================================================

CHandleAccessRulesRequest::CHandleAccessRulesRequest(const char *serviceName, IRpcMessageBinding *init)
	: m_Operation(nilIgnore),m_XmlArgs(nilIgnore),m_ReqInfo(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("HandleAccessRulesRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CHandleAccessRulesRequest::CHandleAccessRulesRequest(const char *serviceName, const char *bc)
	: m_Operation(nilIgnore),m_XmlArgs(nilIgnore),m_ReqInfo(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("HandleAccessRulesRequest");
}

CHandleAccessRulesRequest::CHandleAccessRulesRequest(const char *serviceName, IRpcMessage* rpcmsg)
	: m_Operation(nilIgnore),m_XmlArgs(nilIgnore),m_ReqInfo(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("HandleAccessRulesRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CHandleAccessRulesRequest::CHandleAccessRulesRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_Operation(nilIgnore),m_XmlArgs(nilIgnore),m_ReqInfo(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("HandleAccessRulesRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CHandleAccessRulesRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Operation\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"XmlArgs\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"ReqInfo\" type=\"tns:WsDeployReqInfo\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	if (!(flags & 0x10)  || (flags & 0x100))
	{
		CWsDeployReqInfo::getXsdDefinition(context, request, schema, added);
	}
	return schema;
}

void CHandleAccessRulesRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CHandleAccessRulesRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
	if (!added.getValue("WsDeployReqInfo"))
	{
		added.setValue("WsDeployReqInfo",1);
		CWsDeployReqInfo::getMapInfo(info,added);
	}
}

StringBuffer &CHandleAccessRulesRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Operation");
	form.appendf("  <tr><td><b>Operation: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("XmlArgs");
	form.appendf("  <tr><td><b>XmlArgs: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("ReqInfo");
	form.append("<tr>").append("<td><b>ReqInfo: </b></td><td><hr/>");
	CWsDeployReqInfo::getHtmlForm(context, request, serv, method, form, false, extfix.str());
	form.append("<hr/></td></tr>");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CHandleAccessRulesRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CHandleAccessRulesRequest::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_Operation.marshall(rpc_resp, "Operation", "", "", "");
	m_XmlArgs.marshall(rpc_resp, "XmlArgs", "", "", "");
	m_ReqInfo.marshall(rpc_resp, "ReqInfo", "", "", "");
}


void CHandleAccessRulesRequest::copy(CHandleAccessRulesRequest &from)
{
	m_Operation.copy(from.m_Operation);
	m_XmlArgs.copy(from.m_XmlArgs);
	m_ReqInfo.copy(from.m_ReqInfo);
}


void CHandleAccessRulesRequest::copy(IConstHandleAccessRulesRequest &ifrom)
{
	setOperation(ifrom.getOperation());
	setXmlArgs(ifrom.getXmlArgs());
	setReqInfo(ifrom.getReqInfo());
}


void CHandleAccessRulesRequest::getAttributes(IProperties &attributes)
{
}


void CHandleAccessRulesRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_Operation.toStr(ctx, buffer, "Operation", "", true, "", "");
	m_XmlArgs.toStr(ctx, buffer, "XmlArgs", "", true, "", "");
	m_ReqInfo.toStr(ctx, buffer, "ReqInfo", "", false, "", "");
}


void CHandleAccessRulesRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CHandleAccessRulesRequest::serializer(IEspContext* ctx, IConstHandleAccessRulesRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<HandleAccessRulesRequest>");
	// field Operation
	{
		const char* s = src.getOperation();
		if (s && *s)
		{
			buffer.append("<Operation>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Operation>");
		}
	}
	// field XmlArgs
	{
		const char* s = src.getXmlArgs();
		if (s && *s)
		{
			buffer.append("<XmlArgs>");
			encodeUtf8XML(s,buffer);
			buffer.append("</XmlArgs>");
		}
	}
	// field ReqInfo
	{
		StringBuffer tmp;
		CWsDeployReqInfo::serializer(ctx,src.getReqInfo(), tmp, false);
		if (tmp.length()>0)
			buffer.appendf("<ReqInfo>%s</ReqInfo>",tmp.str());
	}
	if (keepRootTag)
		buffer.append("</HandleAccessRulesRequest>");
}

bool CHandleAccessRulesRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_Operation.unmarshall(rpc_request, "Operation", basepath);
	hasValue |= m_XmlArgs.unmarshall(rpc_request, "XmlArgs", basepath);
	hasValue |= m_ReqInfo.unmarshall(rpc_request, "ReqInfo", basepath);
	return hasValue;
}

bool CHandleAccessRulesRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Operation.unmarshall(ctx, soapval, "Operation");
	hasValue |= m_XmlArgs.unmarshall(ctx, soapval, "XmlArgs");
	hasValue |= m_ReqInfo.unmarshall(ctx, soapval, "ReqInfo");
	return hasValue;
}

bool CHandleAccessRulesRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Operation.unmarshall(ctx, params, attachments, "Operation", basepath);
	hasValue |= m_XmlArgs.unmarshall(ctx, params, attachments, "XmlArgs", basepath);
	hasValue |= m_ReqInfo.unmarshall(ctx, params, attachments, "ReqInfo", basepath);
	return hasValue;
}

const char * CHandleAccessRulesRequest::getOperation() { return m_Operation.query();}
const char * CHandleAccessRulesRequest::getXmlArgs() { return m_XmlArgs.query();}
IConstWsDeployReqInfo & CHandleAccessRulesRequest::getReqInfo() { return (IConstWsDeployReqInfo &) m_ReqInfo.getValue();}
void CHandleAccessRulesRequest::setOperation(const char * val){ m_Operation.set(val); }
void CHandleAccessRulesRequest::setXmlArgs(const char * val){ m_XmlArgs.set(val); }
IEspWsDeployReqInfo & CHandleAccessRulesRequest::updateReqInfo(){ return (IEspWsDeployReqInfo &) m_ReqInfo.getValue(); }
void CHandleAccessRulesRequest::setReqInfo(IConstWsDeployReqInfo &ifrom){ m_ReqInfo.copy(ifrom); }
extern "C"  IEspHandleAccessRulesRequest *createHandleAccessRulesRequest(const char *serv){return ((IEspHandleAccessRulesRequest *)new CHandleAccessRulesRequest(serv));}
extern "C"  IClientHandleAccessRulesRequest *createClientHandleAccessRulesRequest(const char *serv){return ((IClientHandleAccessRulesRequest *)new CHandleAccessRulesRequest(serv));}

//=======================================================
// class CHandleBaseAccessControlListRequest Implementation
//=======================================================

CHandleBaseAccessControlListRequest::CHandleBaseAccessControlListRequest(const char *serviceName, IRpcMessageBinding *init)
	: m_Operation(nilIgnore),m_XmlArgs(nilIgnore),m_ReqInfo(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("HandleBaseAccessControlListRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CHandleBaseAccessControlListRequest::CHandleBaseAccessControlListRequest(const char *serviceName, const char *bc)
	: m_Operation(nilIgnore),m_XmlArgs(nilIgnore),m_ReqInfo(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("HandleBaseAccessControlListRequest");
}

CHandleBaseAccessControlListRequest::CHandleBaseAccessControlListRequest(const char *serviceName, IRpcMessage* rpcmsg)
	: m_Operation(nilIgnore),m_XmlArgs(nilIgnore),m_ReqInfo(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("HandleBaseAccessControlListRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CHandleBaseAccessControlListRequest::CHandleBaseAccessControlListRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_Operation(nilIgnore),m_XmlArgs(nilIgnore),m_ReqInfo(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("HandleBaseAccessControlListRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CHandleBaseAccessControlListRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Operation\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"XmlArgs\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"ReqInfo\" type=\"tns:WsDeployReqInfo\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	if (!(flags & 0x10)  || (flags & 0x100))
	{
		CWsDeployReqInfo::getXsdDefinition(context, request, schema, added);
	}
	return schema;
}

void CHandleBaseAccessControlListRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CHandleBaseAccessControlListRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
	if (!added.getValue("WsDeployReqInfo"))
	{
		added.setValue("WsDeployReqInfo",1);
		CWsDeployReqInfo::getMapInfo(info,added);
	}
}

StringBuffer &CHandleBaseAccessControlListRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Operation");
	form.appendf("  <tr><td><b>Operation: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("XmlArgs");
	form.appendf("  <tr><td><b>XmlArgs: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("ReqInfo");
	form.append("<tr>").append("<td><b>ReqInfo: </b></td><td><hr/>");
	CWsDeployReqInfo::getHtmlForm(context, request, serv, method, form, false, extfix.str());
	form.append("<hr/></td></tr>");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CHandleBaseAccessControlListRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CHandleBaseAccessControlListRequest::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_Operation.marshall(rpc_resp, "Operation", "", "", "");
	m_XmlArgs.marshall(rpc_resp, "XmlArgs", "", "", "");
	m_ReqInfo.marshall(rpc_resp, "ReqInfo", "", "", "");
}


void CHandleBaseAccessControlListRequest::copy(CHandleBaseAccessControlListRequest &from)
{
	m_Operation.copy(from.m_Operation);
	m_XmlArgs.copy(from.m_XmlArgs);
	m_ReqInfo.copy(from.m_ReqInfo);
}


void CHandleBaseAccessControlListRequest::copy(IConstHandleBaseAccessControlListRequest &ifrom)
{
	setOperation(ifrom.getOperation());
	setXmlArgs(ifrom.getXmlArgs());
	setReqInfo(ifrom.getReqInfo());
}


void CHandleBaseAccessControlListRequest::getAttributes(IProperties &attributes)
{
}


void CHandleBaseAccessControlListRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_Operation.toStr(ctx, buffer, "Operation", "", true, "", "");
	m_XmlArgs.toStr(ctx, buffer, "XmlArgs", "", true, "", "");
	m_ReqInfo.toStr(ctx, buffer, "ReqInfo", "", false, "", "");
}


void CHandleBaseAccessControlListRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CHandleBaseAccessControlListRequest::serializer(IEspContext* ctx, IConstHandleBaseAccessControlListRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<HandleBaseAccessControlListRequest>");
	// field Operation
	{
		const char* s = src.getOperation();
		if (s && *s)
		{
			buffer.append("<Operation>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Operation>");
		}
	}
	// field XmlArgs
	{
		const char* s = src.getXmlArgs();
		if (s && *s)
		{
			buffer.append("<XmlArgs>");
			encodeUtf8XML(s,buffer);
			buffer.append("</XmlArgs>");
		}
	}
	// field ReqInfo
	{
		StringBuffer tmp;
		CWsDeployReqInfo::serializer(ctx,src.getReqInfo(), tmp, false);
		if (tmp.length()>0)
			buffer.appendf("<ReqInfo>%s</ReqInfo>",tmp.str());
	}
	if (keepRootTag)
		buffer.append("</HandleBaseAccessControlListRequest>");
}

bool CHandleBaseAccessControlListRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_Operation.unmarshall(rpc_request, "Operation", basepath);
	hasValue |= m_XmlArgs.unmarshall(rpc_request, "XmlArgs", basepath);
	hasValue |= m_ReqInfo.unmarshall(rpc_request, "ReqInfo", basepath);
	return hasValue;
}

bool CHandleBaseAccessControlListRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Operation.unmarshall(ctx, soapval, "Operation");
	hasValue |= m_XmlArgs.unmarshall(ctx, soapval, "XmlArgs");
	hasValue |= m_ReqInfo.unmarshall(ctx, soapval, "ReqInfo");
	return hasValue;
}

bool CHandleBaseAccessControlListRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Operation.unmarshall(ctx, params, attachments, "Operation", basepath);
	hasValue |= m_XmlArgs.unmarshall(ctx, params, attachments, "XmlArgs", basepath);
	hasValue |= m_ReqInfo.unmarshall(ctx, params, attachments, "ReqInfo", basepath);
	return hasValue;
}

const char * CHandleBaseAccessControlListRequest::getOperation() { return m_Operation.query();}
const char * CHandleBaseAccessControlListRequest::getXmlArgs() { return m_XmlArgs.query();}
IConstWsDeployReqInfo & CHandleBaseAccessControlListRequest::getReqInfo() { return (IConstWsDeployReqInfo &) m_ReqInfo.getValue();}
void CHandleBaseAccessControlListRequest::setOperation(const char * val){ m_Operation.set(val); }
void CHandleBaseAccessControlListRequest::setXmlArgs(const char * val){ m_XmlArgs.set(val); }
IEspWsDeployReqInfo & CHandleBaseAccessControlListRequest::updateReqInfo(){ return (IEspWsDeployReqInfo &) m_ReqInfo.getValue(); }
void CHandleBaseAccessControlListRequest::setReqInfo(IConstWsDeployReqInfo &ifrom){ m_ReqInfo.copy(ifrom); }
extern "C"  IEspHandleBaseAccessControlListRequest *createHandleBaseAccessControlListRequest(const char *serv){return ((IEspHandleBaseAccessControlListRequest *)new CHandleBaseAccessControlListRequest(serv));}
extern "C"  IClientHandleBaseAccessControlListRequest *createClientHandleBaseAccessControlListRequest(const char *serv){return ((IClientHandleBaseAccessControlListRequest *)new CHandleBaseAccessControlListRequest(serv));}

//=======================================================
// class CHandleAccessRulesResponse Implementation
//=======================================================

CHandleAccessRulesResponse::CHandleAccessRulesResponse(const char *serviceName, IRpcMessageBinding *init)
	: m_Status(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("HandleAccessRulesResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CHandleAccessRulesResponse::CHandleAccessRulesResponse(const char *serviceName, const char *bc)
	: m_Status(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("HandleAccessRulesResponse");
}

CHandleAccessRulesResponse::CHandleAccessRulesResponse(const char *serviceName, IRpcMessage* rpcmsg)
	: m_Status(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("HandleAccessRulesResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CHandleAccessRulesResponse::CHandleAccessRulesResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_Status(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("HandleAccessRulesResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CHandleAccessRulesResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		schema.append("<xsd:element name=\"Exceptions\" type=\"tns:ArrayOfEspException\" minOccurs=\"0\" maxOccurs=\"1\"/>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Status\" type=\"xsd:string\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CHandleAccessRulesResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CHandleAccessRulesResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CHandleAccessRulesResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Status");
	form.appendf("  <tr><td><b>Status: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CHandleAccessRulesResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CHandleAccessRulesResponse::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	rpc_resp.setEncodeXml(false);
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
		m_Status.marshall(rpc_resp, "Status", "", "", "");
	}
}


void CHandleAccessRulesResponse::copy(CHandleAccessRulesResponse &from)
{
	m_Status.copy(from.m_Status);
}


void CHandleAccessRulesResponse::copy(IConstHandleAccessRulesResponse &ifrom)
{
	setStatus(ifrom.getStatus());
}


void CHandleAccessRulesResponse::getAttributes(IProperties &attributes)
{
}


void CHandleAccessRulesResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
		m_Status.toStr(ctx, buffer, "Status", "", false, "", "");
	}
}


void CHandleAccessRulesResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CHandleAccessRulesResponse::serializer(IEspContext* ctx, IConstHandleAccessRulesResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<HandleAccessRulesResponse>");
	// field Status
	{
		const char* s = src.getStatus();
		if (s && *s)
		buffer.appendf("<Status>%s</Status>",s);
	}
	if (keepRootTag)
		buffer.append("</HandleAccessRulesResponse>");
}

bool CHandleAccessRulesResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
		hasValue |= m_Status.unmarshall(rpc_request, "Status", basepath);
	}
	return hasValue;
}

bool CHandleAccessRulesResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Status.unmarshall(ctx, soapval, "Status");
	return hasValue;
}

bool CHandleAccessRulesResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Status.unmarshall(ctx, params, attachments, "Status", basepath);
	return hasValue;
}

const char * CHandleAccessRulesResponse::getStatus() { return m_Status.query();}
void CHandleAccessRulesResponse::setStatus(const char * val){ m_Status.set(val); }
extern "C"  IEspHandleAccessRulesResponse *createHandleAccessRulesResponse(const char *serv){return ((IEspHandleAccessRulesResponse *)new CHandleAccessRulesResponse(serv));}
extern "C"  IClientHandleAccessRulesResponse *createClientHandleAccessRulesResponse(const char *serv){return ((IClientHandleAccessRulesResponse *)new CHandleAccessRulesResponse(serv));}

//=======================================================
// class CHandleBaseAccessControlListResponse Implementation
//=======================================================

CHandleBaseAccessControlListResponse::CHandleBaseAccessControlListResponse(const char *serviceName, IRpcMessageBinding *init)
	: m_Status(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("HandleBaseAccessControlListResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CHandleBaseAccessControlListResponse::CHandleBaseAccessControlListResponse(const char *serviceName, const char *bc)
	: m_Status(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("HandleBaseAccessControlListResponse");
}

CHandleBaseAccessControlListResponse::CHandleBaseAccessControlListResponse(const char *serviceName, IRpcMessage* rpcmsg)
	: m_Status(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("HandleBaseAccessControlListResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CHandleBaseAccessControlListResponse::CHandleBaseAccessControlListResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_Status(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("HandleBaseAccessControlListResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CHandleBaseAccessControlListResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		schema.append("<xsd:element name=\"Exceptions\" type=\"tns:ArrayOfEspException\" minOccurs=\"0\" maxOccurs=\"1\"/>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Status\" type=\"xsd:string\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CHandleBaseAccessControlListResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CHandleBaseAccessControlListResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CHandleBaseAccessControlListResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Status");
	form.appendf("  <tr><td><b>Status: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CHandleBaseAccessControlListResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CHandleBaseAccessControlListResponse::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	rpc_resp.setEncodeXml(false);
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
		m_Status.marshall(rpc_resp, "Status", "", "", "");
	}
}


void CHandleBaseAccessControlListResponse::copy(CHandleBaseAccessControlListResponse &from)
{
	m_Status.copy(from.m_Status);
}


void CHandleBaseAccessControlListResponse::copy(IConstHandleBaseAccessControlListResponse &ifrom)
{
	setStatus(ifrom.getStatus());
}


void CHandleBaseAccessControlListResponse::getAttributes(IProperties &attributes)
{
}


void CHandleBaseAccessControlListResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
		m_Status.toStr(ctx, buffer, "Status", "", false, "", "");
	}
}


void CHandleBaseAccessControlListResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CHandleBaseAccessControlListResponse::serializer(IEspContext* ctx, IConstHandleBaseAccessControlListResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<HandleBaseAccessControlListResponse>");
	// field Status
	{
		const char* s = src.getStatus();
		if (s && *s)
		buffer.appendf("<Status>%s</Status>",s);
	}
	if (keepRootTag)
		buffer.append("</HandleBaseAccessControlListResponse>");
}

bool CHandleBaseAccessControlListResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
		hasValue |= m_Status.unmarshall(rpc_request, "Status", basepath);
	}
	return hasValue;
}

bool CHandleBaseAccessControlListResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Status.unmarshall(ctx, soapval, "Status");
	return hasValue;
}

bool CHandleBaseAccessControlListResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Status.unmarshall(ctx, params, attachments, "Status", basepath);
	return hasValue;
}

const char * CHandleBaseAccessControlListResponse::getStatus() { return m_Status.query();}
void CHandleBaseAccessControlListResponse::setStatus(const char * val){ m_Status.set(val); }
extern "C"  IEspHandleBaseAccessControlListResponse *createHandleBaseAccessControlListResponse(const char *serv){return ((IEspHandleBaseAccessControlListResponse *)new CHandleBaseAccessControlListResponse(serv));}
extern "C"  IClientHandleBaseAccessControlListResponse *createClientHandleBaseAccessControlListResponse(const char *serv){return ((IClientHandleBaseAccessControlListResponse *)new CHandleBaseAccessControlListResponse(serv));}

//=======================================================
// class CGetNavTreeDefnRequest Implementation
//=======================================================

CGetNavTreeDefnRequest::CGetNavTreeDefnRequest(const char *serviceName, IRpcMessageBinding *init)
	: m_XmlArgs(nilIgnore),m_ReqInfo(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetNavTreeDefnRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CGetNavTreeDefnRequest::CGetNavTreeDefnRequest(const char *serviceName, const char *bc)
	: m_XmlArgs(nilIgnore),m_ReqInfo(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetNavTreeDefnRequest");
}

CGetNavTreeDefnRequest::CGetNavTreeDefnRequest(const char *serviceName, IRpcMessage* rpcmsg)
	: m_XmlArgs(nilIgnore),m_ReqInfo(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetNavTreeDefnRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CGetNavTreeDefnRequest::CGetNavTreeDefnRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_XmlArgs(nilIgnore),m_ReqInfo(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetNavTreeDefnRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CGetNavTreeDefnRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"XmlArgs\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"ReqInfo\" type=\"tns:WsDeployReqInfo\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	if (!(flags & 0x10)  || (flags & 0x100))
	{
		CWsDeployReqInfo::getXsdDefinition(context, request, schema, added);
	}
	return schema;
}

void CGetNavTreeDefnRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CGetNavTreeDefnRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
	if (!added.getValue("WsDeployReqInfo"))
	{
		added.setValue("WsDeployReqInfo",1);
		CWsDeployReqInfo::getMapInfo(info,added);
	}
}

StringBuffer &CGetNavTreeDefnRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("XmlArgs");
	form.appendf("  <tr><td><b>XmlArgs: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("ReqInfo");
	form.append("<tr>").append("<td><b>ReqInfo: </b></td><td><hr/>");
	CWsDeployReqInfo::getHtmlForm(context, request, serv, method, form, false, extfix.str());
	form.append("<hr/></td></tr>");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CGetNavTreeDefnRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CGetNavTreeDefnRequest::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_XmlArgs.marshall(rpc_resp, "XmlArgs", "", "", "");
	m_ReqInfo.marshall(rpc_resp, "ReqInfo", "", "", "");
}


void CGetNavTreeDefnRequest::copy(CGetNavTreeDefnRequest &from)
{
	m_XmlArgs.copy(from.m_XmlArgs);
	m_ReqInfo.copy(from.m_ReqInfo);
}


void CGetNavTreeDefnRequest::copy(IConstGetNavTreeDefnRequest &ifrom)
{
	setXmlArgs(ifrom.getXmlArgs());
	setReqInfo(ifrom.getReqInfo());
}


void CGetNavTreeDefnRequest::getAttributes(IProperties &attributes)
{
}


void CGetNavTreeDefnRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_XmlArgs.toStr(ctx, buffer, "XmlArgs", "", true, "", "");
	m_ReqInfo.toStr(ctx, buffer, "ReqInfo", "", false, "", "");
}


void CGetNavTreeDefnRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CGetNavTreeDefnRequest::serializer(IEspContext* ctx, IConstGetNavTreeDefnRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<GetNavTreeDefnRequest>");
	// field XmlArgs
	{
		const char* s = src.getXmlArgs();
		if (s && *s)
		{
			buffer.append("<XmlArgs>");
			encodeUtf8XML(s,buffer);
			buffer.append("</XmlArgs>");
		}
	}
	// field ReqInfo
	{
		StringBuffer tmp;
		CWsDeployReqInfo::serializer(ctx,src.getReqInfo(), tmp, false);
		if (tmp.length()>0)
			buffer.appendf("<ReqInfo>%s</ReqInfo>",tmp.str());
	}
	if (keepRootTag)
		buffer.append("</GetNavTreeDefnRequest>");
}

bool CGetNavTreeDefnRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_XmlArgs.unmarshall(rpc_request, "XmlArgs", basepath);
	hasValue |= m_ReqInfo.unmarshall(rpc_request, "ReqInfo", basepath);
	return hasValue;
}

bool CGetNavTreeDefnRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_XmlArgs.unmarshall(ctx, soapval, "XmlArgs");
	hasValue |= m_ReqInfo.unmarshall(ctx, soapval, "ReqInfo");
	return hasValue;
}

bool CGetNavTreeDefnRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_XmlArgs.unmarshall(ctx, params, attachments, "XmlArgs", basepath);
	hasValue |= m_ReqInfo.unmarshall(ctx, params, attachments, "ReqInfo", basepath);
	return hasValue;
}

const char * CGetNavTreeDefnRequest::getXmlArgs() { return m_XmlArgs.query();}
IConstWsDeployReqInfo & CGetNavTreeDefnRequest::getReqInfo() { return (IConstWsDeployReqInfo &) m_ReqInfo.getValue();}
void CGetNavTreeDefnRequest::setXmlArgs(const char * val){ m_XmlArgs.set(val); }
IEspWsDeployReqInfo & CGetNavTreeDefnRequest::updateReqInfo(){ return (IEspWsDeployReqInfo &) m_ReqInfo.getValue(); }
void CGetNavTreeDefnRequest::setReqInfo(IConstWsDeployReqInfo &ifrom){ m_ReqInfo.copy(ifrom); }
extern "C"  IEspGetNavTreeDefnRequest *createGetNavTreeDefnRequest(const char *serv){return ((IEspGetNavTreeDefnRequest *)new CGetNavTreeDefnRequest(serv));}
extern "C"  IClientGetNavTreeDefnRequest *createClientGetNavTreeDefnRequest(const char *serv){return ((IClientGetNavTreeDefnRequest *)new CGetNavTreeDefnRequest(serv));}

//=======================================================
// class CGetNavTreeDefnResponse Implementation
//=======================================================

CGetNavTreeDefnResponse::CGetNavTreeDefnResponse(const char *serviceName, IRpcMessageBinding *init)
	: m_CompDefn(nilIgnore),m_ReadOnly(nilIgnore),m_LastSaved(nilIgnore),m_LastStarted(nilIgnore),m_Message(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetNavTreeDefnResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CGetNavTreeDefnResponse::CGetNavTreeDefnResponse(const char *serviceName, const char *bc)
	: m_CompDefn(nilIgnore),m_ReadOnly(nilIgnore),m_LastSaved(nilIgnore),m_LastStarted(nilIgnore),m_Message(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetNavTreeDefnResponse");
}

CGetNavTreeDefnResponse::CGetNavTreeDefnResponse(const char *serviceName, IRpcMessage* rpcmsg)
	: m_CompDefn(nilIgnore),m_ReadOnly(nilIgnore),m_LastSaved(nilIgnore),m_LastStarted(nilIgnore),m_Message(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetNavTreeDefnResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CGetNavTreeDefnResponse::CGetNavTreeDefnResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_CompDefn(nilIgnore),m_ReadOnly(nilIgnore),m_LastSaved(nilIgnore),m_LastStarted(nilIgnore),m_Message(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetNavTreeDefnResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CGetNavTreeDefnResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		schema.append("<xsd:element name=\"Exceptions\" type=\"tns:ArrayOfEspException\" minOccurs=\"0\" maxOccurs=\"1\"/>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"CompDefn\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"ReadOnly\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"LastSaved\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"LastStarted\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Message\" type=\"xsd:string\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CGetNavTreeDefnResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CGetNavTreeDefnResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CGetNavTreeDefnResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("CompDefn");
	form.appendf("  <tr><td><b>CompDefn: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("ReadOnly");
	form.appendf("  <tr><td><b>ReadOnly: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("LastSaved");
	form.appendf("  <tr><td><b>LastSaved: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("LastStarted");
	form.appendf("  <tr><td><b>LastStarted: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Message");
	form.appendf("  <tr><td><b>Message: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CGetNavTreeDefnResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CGetNavTreeDefnResponse::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	rpc_resp.setEncodeXml(false);
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
		m_CompDefn.marshall(rpc_resp, "CompDefn", "", "", "");
		m_ReadOnly.marshall(rpc_resp, "ReadOnly", "", "", "");
		m_LastSaved.marshall(rpc_resp, "LastSaved", "", "", "");
		m_LastStarted.marshall(rpc_resp, "LastStarted", "", "", "");
		m_Message.marshall(rpc_resp, "Message", "", "", "");
	}
}


void CGetNavTreeDefnResponse::copy(CGetNavTreeDefnResponse &from)
{
	m_CompDefn.copy(from.m_CompDefn);
	m_ReadOnly.copy(from.m_ReadOnly);
	m_LastSaved.copy(from.m_LastSaved);
	m_LastStarted.copy(from.m_LastStarted);
	m_Message.copy(from.m_Message);
}


void CGetNavTreeDefnResponse::copy(IConstGetNavTreeDefnResponse &ifrom)
{
	setCompDefn(ifrom.getCompDefn());
	setReadOnly(ifrom.getReadOnly());
	setLastSaved(ifrom.getLastSaved());
	setLastStarted(ifrom.getLastStarted());
	setMessage(ifrom.getMessage());
}


void CGetNavTreeDefnResponse::getAttributes(IProperties &attributes)
{
}


void CGetNavTreeDefnResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
		m_CompDefn.toStr(ctx, buffer, "CompDefn", "", false, "", "");
		m_ReadOnly.toStr(ctx, buffer, "ReadOnly", "", false, "", "");
		m_LastSaved.toStr(ctx, buffer, "LastSaved", "", false, "", "");
		m_LastStarted.toStr(ctx, buffer, "LastStarted", "", false, "", "");
		m_Message.toStr(ctx, buffer, "Message", "", false, "", "");
	}
}


void CGetNavTreeDefnResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CGetNavTreeDefnResponse::serializer(IEspContext* ctx, IConstGetNavTreeDefnResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<GetNavTreeDefnResponse>");
	// field CompDefn
	{
		const char* s = src.getCompDefn();
		if (s && *s)
		buffer.appendf("<CompDefn>%s</CompDefn>",s);
	}
	// field ReadOnly
	{
		const char* s = src.getReadOnly();
		if (s && *s)
		buffer.appendf("<ReadOnly>%s</ReadOnly>",s);
	}
	// field LastSaved
	{
		const char* s = src.getLastSaved();
		if (s && *s)
		buffer.appendf("<LastSaved>%s</LastSaved>",s);
	}
	// field LastStarted
	{
		const char* s = src.getLastStarted();
		if (s && *s)
		buffer.appendf("<LastStarted>%s</LastStarted>",s);
	}
	// field Message
	{
		const char* s = src.getMessage();
		if (s && *s)
		buffer.appendf("<Message>%s</Message>",s);
	}
	if (keepRootTag)
		buffer.append("</GetNavTreeDefnResponse>");
}

bool CGetNavTreeDefnResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
		hasValue |= m_CompDefn.unmarshall(rpc_request, "CompDefn", basepath);
		hasValue |= m_ReadOnly.unmarshall(rpc_request, "ReadOnly", basepath);
		hasValue |= m_LastSaved.unmarshall(rpc_request, "LastSaved", basepath);
		hasValue |= m_LastStarted.unmarshall(rpc_request, "LastStarted", basepath);
		hasValue |= m_Message.unmarshall(rpc_request, "Message", basepath);
	}
	return hasValue;
}

bool CGetNavTreeDefnResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_CompDefn.unmarshall(ctx, soapval, "CompDefn");
	hasValue |= m_ReadOnly.unmarshall(ctx, soapval, "ReadOnly");
	hasValue |= m_LastSaved.unmarshall(ctx, soapval, "LastSaved");
	hasValue |= m_LastStarted.unmarshall(ctx, soapval, "LastStarted");
	hasValue |= m_Message.unmarshall(ctx, soapval, "Message");
	return hasValue;
}

bool CGetNavTreeDefnResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_CompDefn.unmarshall(ctx, params, attachments, "CompDefn", basepath);
	hasValue |= m_ReadOnly.unmarshall(ctx, params, attachments, "ReadOnly", basepath);
	hasValue |= m_LastSaved.unmarshall(ctx, params, attachments, "LastSaved", basepath);
	hasValue |= m_LastStarted.unmarshall(ctx, params, attachments, "LastStarted", basepath);
	hasValue |= m_Message.unmarshall(ctx, params, attachments, "Message", basepath);
	return hasValue;
}

const char * CGetNavTreeDefnResponse::getCompDefn() { return m_CompDefn.query();}
const char * CGetNavTreeDefnResponse::getReadOnly() { return m_ReadOnly.query();}
const char * CGetNavTreeDefnResponse::getLastSaved() { return m_LastSaved.query();}
const char * CGetNavTreeDefnResponse::getLastStarted() { return m_LastStarted.query();}
const char * CGetNavTreeDefnResponse::getMessage() { return m_Message.query();}
void CGetNavTreeDefnResponse::setCompDefn(const char * val){ m_CompDefn.set(val); }
void CGetNavTreeDefnResponse::setReadOnly(const char * val){ m_ReadOnly.set(val); }
void CGetNavTreeDefnResponse::setLastSaved(const char * val){ m_LastSaved.set(val); }
void CGetNavTreeDefnResponse::setLastStarted(const char * val){ m_LastStarted.set(val); }
void CGetNavTreeDefnResponse::setMessage(const char * val){ m_Message.set(val); }
extern "C"  IEspGetNavTreeDefnResponse *createGetNavTreeDefnResponse(const char *serv){return ((IEspGetNavTreeDefnResponse *)new CGetNavTreeDefnResponse(serv));}
extern "C"  IClientGetNavTreeDefnResponse *createClientGetNavTreeDefnResponse(const char *serv){return ((IClientGetNavTreeDefnResponse *)new CGetNavTreeDefnResponse(serv));}

//=======================================================
// class CGetValueRequest Implementation
//=======================================================

CGetValueRequest::CGetValueRequest(const char *serviceName, IRpcMessageBinding *init)
	: m_Params(nilIgnore),m_ReqInfo(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetValueRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CGetValueRequest::CGetValueRequest(const char *serviceName, const char *bc)
	: m_Params(nilIgnore),m_ReqInfo(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetValueRequest");
}

CGetValueRequest::CGetValueRequest(const char *serviceName, IRpcMessage* rpcmsg)
	: m_Params(nilIgnore),m_ReqInfo(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetValueRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CGetValueRequest::CGetValueRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_Params(nilIgnore),m_ReqInfo(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetValueRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CGetValueRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Params\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"ReqInfo\" type=\"tns:WsDeployReqInfo\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	if (!(flags & 0x10)  || (flags & 0x100))
	{
		CWsDeployReqInfo::getXsdDefinition(context, request, schema, added);
	}
	return schema;
}

void CGetValueRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CGetValueRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
	if (!added.getValue("WsDeployReqInfo"))
	{
		added.setValue("WsDeployReqInfo",1);
		CWsDeployReqInfo::getMapInfo(info,added);
	}
}

StringBuffer &CGetValueRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Params");
	form.appendf("  <tr><td><b>Params: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("ReqInfo");
	form.append("<tr>").append("<td><b>ReqInfo: </b></td><td><hr/>");
	CWsDeployReqInfo::getHtmlForm(context, request, serv, method, form, false, extfix.str());
	form.append("<hr/></td></tr>");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CGetValueRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CGetValueRequest::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_Params.marshall(rpc_resp, "Params", "", "", "");
	m_ReqInfo.marshall(rpc_resp, "ReqInfo", "", "", "");
}


void CGetValueRequest::copy(CGetValueRequest &from)
{
	m_Params.copy(from.m_Params);
	m_ReqInfo.copy(from.m_ReqInfo);
}


void CGetValueRequest::copy(IConstGetValueRequest &ifrom)
{
	setParams(ifrom.getParams());
	setReqInfo(ifrom.getReqInfo());
}


void CGetValueRequest::getAttributes(IProperties &attributes)
{
}


void CGetValueRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_Params.toStr(ctx, buffer, "Params", "", true, "", "");
	m_ReqInfo.toStr(ctx, buffer, "ReqInfo", "", false, "", "");
}


void CGetValueRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CGetValueRequest::serializer(IEspContext* ctx, IConstGetValueRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<GetValueRequest>");
	// field Params
	{
		const char* s = src.getParams();
		if (s && *s)
		{
			buffer.append("<Params>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Params>");
		}
	}
	// field ReqInfo
	{
		StringBuffer tmp;
		CWsDeployReqInfo::serializer(ctx,src.getReqInfo(), tmp, false);
		if (tmp.length()>0)
			buffer.appendf("<ReqInfo>%s</ReqInfo>",tmp.str());
	}
	if (keepRootTag)
		buffer.append("</GetValueRequest>");
}

bool CGetValueRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_Params.unmarshall(rpc_request, "Params", basepath);
	hasValue |= m_ReqInfo.unmarshall(rpc_request, "ReqInfo", basepath);
	return hasValue;
}

bool CGetValueRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Params.unmarshall(ctx, soapval, "Params");
	hasValue |= m_ReqInfo.unmarshall(ctx, soapval, "ReqInfo");
	return hasValue;
}

bool CGetValueRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Params.unmarshall(ctx, params, attachments, "Params", basepath);
	hasValue |= m_ReqInfo.unmarshall(ctx, params, attachments, "ReqInfo", basepath);
	return hasValue;
}

const char * CGetValueRequest::getParams() { return m_Params.query();}
IConstWsDeployReqInfo & CGetValueRequest::getReqInfo() { return (IConstWsDeployReqInfo &) m_ReqInfo.getValue();}
void CGetValueRequest::setParams(const char * val){ m_Params.set(val); }
IEspWsDeployReqInfo & CGetValueRequest::updateReqInfo(){ return (IEspWsDeployReqInfo &) m_ReqInfo.getValue(); }
void CGetValueRequest::setReqInfo(IConstWsDeployReqInfo &ifrom){ m_ReqInfo.copy(ifrom); }
extern "C"  IEspGetValueRequest *createGetValueRequest(const char *serv){return ((IEspGetValueRequest *)new CGetValueRequest(serv));}
extern "C"  IClientGetValueRequest *createClientGetValueRequest(const char *serv){return ((IClientGetValueRequest *)new CGetValueRequest(serv));}

//=======================================================
// class CGetValueResponse Implementation
//=======================================================

CGetValueResponse::CGetValueResponse(const char *serviceName, IRpcMessageBinding *init)
	: m_Status(nilIgnore),m_ReqValue(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetValueResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CGetValueResponse::CGetValueResponse(const char *serviceName, const char *bc)
	: m_Status(nilIgnore),m_ReqValue(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetValueResponse");
}

CGetValueResponse::CGetValueResponse(const char *serviceName, IRpcMessage* rpcmsg)
	: m_Status(nilIgnore),m_ReqValue(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetValueResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CGetValueResponse::CGetValueResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_Status(nilIgnore),m_ReqValue(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetValueResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CGetValueResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		schema.append("<xsd:element name=\"Exceptions\" type=\"tns:ArrayOfEspException\" minOccurs=\"0\" maxOccurs=\"1\"/>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Status\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"ReqValue\" type=\"xsd:string\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CGetValueResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CGetValueResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CGetValueResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Status");
	form.appendf("  <tr><td><b>Status: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("ReqValue");
	form.appendf("  <tr><td><b>ReqValue: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CGetValueResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CGetValueResponse::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	rpc_resp.setEncodeXml(false);
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
		m_Status.marshall(rpc_resp, "Status", "", "", "");
		m_ReqValue.marshall(rpc_resp, "ReqValue", "", "", "");
	}
}


void CGetValueResponse::copy(CGetValueResponse &from)
{
	m_Status.copy(from.m_Status);
	m_ReqValue.copy(from.m_ReqValue);
}


void CGetValueResponse::copy(IConstGetValueResponse &ifrom)
{
	setStatus(ifrom.getStatus());
	setReqValue(ifrom.getReqValue());
}


void CGetValueResponse::getAttributes(IProperties &attributes)
{
}


void CGetValueResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
		m_Status.toStr(ctx, buffer, "Status", "", false, "", "");
		m_ReqValue.toStr(ctx, buffer, "ReqValue", "", false, "", "");
	}
}


void CGetValueResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CGetValueResponse::serializer(IEspContext* ctx, IConstGetValueResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<GetValueResponse>");
	// field Status
	{
		const char* s = src.getStatus();
		if (s && *s)
		buffer.appendf("<Status>%s</Status>",s);
	}
	// field ReqValue
	{
		const char* s = src.getReqValue();
		if (s && *s)
		buffer.appendf("<ReqValue>%s</ReqValue>",s);
	}
	if (keepRootTag)
		buffer.append("</GetValueResponse>");
}

bool CGetValueResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
		hasValue |= m_Status.unmarshall(rpc_request, "Status", basepath);
		hasValue |= m_ReqValue.unmarshall(rpc_request, "ReqValue", basepath);
	}
	return hasValue;
}

bool CGetValueResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Status.unmarshall(ctx, soapval, "Status");
	hasValue |= m_ReqValue.unmarshall(ctx, soapval, "ReqValue");
	return hasValue;
}

bool CGetValueResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Status.unmarshall(ctx, params, attachments, "Status", basepath);
	hasValue |= m_ReqValue.unmarshall(ctx, params, attachments, "ReqValue", basepath);
	return hasValue;
}

const char * CGetValueResponse::getStatus() { return m_Status.query();}
const char * CGetValueResponse::getReqValue() { return m_ReqValue.query();}
void CGetValueResponse::setStatus(const char * val){ m_Status.set(val); }
void CGetValueResponse::setReqValue(const char * val){ m_ReqValue.set(val); }
extern "C"  IEspGetValueResponse *createGetValueResponse(const char *serv){return ((IEspGetValueResponse *)new CGetValueResponse(serv));}
extern "C"  IClientGetValueResponse *createClientGetValueResponse(const char *serv){return ((IClientGetValueResponse *)new CGetValueResponse(serv));}

//=======================================================
// class CUnlockUserRequest Implementation
//=======================================================

CUnlockUserRequest::CUnlockUserRequest(const char *serviceName, IRpcMessageBinding *init)
	: m_ReqInfo(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("UnlockUserRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CUnlockUserRequest::CUnlockUserRequest(const char *serviceName, const char *bc)
	: m_ReqInfo(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("UnlockUserRequest");
}

CUnlockUserRequest::CUnlockUserRequest(const char *serviceName, IRpcMessage* rpcmsg)
	: m_ReqInfo(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("UnlockUserRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CUnlockUserRequest::CUnlockUserRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_ReqInfo(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("UnlockUserRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CUnlockUserRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"ReqInfo\" type=\"tns:WsDeployReqInfo\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	if (!(flags & 0x10)  || (flags & 0x100))
	{
		CWsDeployReqInfo::getXsdDefinition(context, request, schema, added);
	}
	return schema;
}

void CUnlockUserRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CUnlockUserRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
	if (!added.getValue("WsDeployReqInfo"))
	{
		added.setValue("WsDeployReqInfo",1);
		CWsDeployReqInfo::getMapInfo(info,added);
	}
}

StringBuffer &CUnlockUserRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("ReqInfo");
	form.append("<tr>").append("<td><b>ReqInfo: </b></td><td><hr/>");
	CWsDeployReqInfo::getHtmlForm(context, request, serv, method, form, false, extfix.str());
	form.append("<hr/></td></tr>");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CUnlockUserRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CUnlockUserRequest::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_ReqInfo.marshall(rpc_resp, "ReqInfo", "", "", "");
}


void CUnlockUserRequest::copy(CUnlockUserRequest &from)
{
	m_ReqInfo.copy(from.m_ReqInfo);
}


void CUnlockUserRequest::copy(IConstUnlockUserRequest &ifrom)
{
	setReqInfo(ifrom.getReqInfo());
}


void CUnlockUserRequest::getAttributes(IProperties &attributes)
{
}


void CUnlockUserRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_ReqInfo.toStr(ctx, buffer, "ReqInfo", "", false, "", "");
}


void CUnlockUserRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CUnlockUserRequest::serializer(IEspContext* ctx, IConstUnlockUserRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<UnlockUserRequest>");
	// field ReqInfo
	{
		StringBuffer tmp;
		CWsDeployReqInfo::serializer(ctx,src.getReqInfo(), tmp, false);
		if (tmp.length()>0)
			buffer.appendf("<ReqInfo>%s</ReqInfo>",tmp.str());
	}
	if (keepRootTag)
		buffer.append("</UnlockUserRequest>");
}

bool CUnlockUserRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_ReqInfo.unmarshall(rpc_request, "ReqInfo", basepath);
	return hasValue;
}

bool CUnlockUserRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_ReqInfo.unmarshall(ctx, soapval, "ReqInfo");
	return hasValue;
}

bool CUnlockUserRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_ReqInfo.unmarshall(ctx, params, attachments, "ReqInfo", basepath);
	return hasValue;
}

IConstWsDeployReqInfo & CUnlockUserRequest::getReqInfo() { return (IConstWsDeployReqInfo &) m_ReqInfo.getValue();}
IEspWsDeployReqInfo & CUnlockUserRequest::updateReqInfo(){ return (IEspWsDeployReqInfo &) m_ReqInfo.getValue(); }
void CUnlockUserRequest::setReqInfo(IConstWsDeployReqInfo &ifrom){ m_ReqInfo.copy(ifrom); }
extern "C"  IEspUnlockUserRequest *createUnlockUserRequest(const char *serv){return ((IEspUnlockUserRequest *)new CUnlockUserRequest(serv));}
extern "C"  IClientUnlockUserRequest *createClientUnlockUserRequest(const char *serv){return ((IClientUnlockUserRequest *)new CUnlockUserRequest(serv));}

//=======================================================
// class CUnlockUserResponse Implementation
//=======================================================

CUnlockUserResponse::CUnlockUserResponse(const char *serviceName, IRpcMessageBinding *init)
	: m_Status(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("UnlockUserResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CUnlockUserResponse::CUnlockUserResponse(const char *serviceName, const char *bc)
	: m_Status(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("UnlockUserResponse");
}

CUnlockUserResponse::CUnlockUserResponse(const char *serviceName, IRpcMessage* rpcmsg)
	: m_Status(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("UnlockUserResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CUnlockUserResponse::CUnlockUserResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_Status(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("UnlockUserResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CUnlockUserResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		schema.append("<xsd:element name=\"Exceptions\" type=\"tns:ArrayOfEspException\" minOccurs=\"0\" maxOccurs=\"1\"/>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Status\" type=\"xsd:string\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CUnlockUserResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CUnlockUserResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CUnlockUserResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Status");
	form.appendf("  <tr><td><b>Status: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CUnlockUserResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CUnlockUserResponse::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	rpc_resp.setEncodeXml(false);
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
		m_Status.marshall(rpc_resp, "Status", "", "", "");
	}
}


void CUnlockUserResponse::copy(CUnlockUserResponse &from)
{
	m_Status.copy(from.m_Status);
}


void CUnlockUserResponse::copy(IConstUnlockUserResponse &ifrom)
{
	setStatus(ifrom.getStatus());
}


void CUnlockUserResponse::getAttributes(IProperties &attributes)
{
}


void CUnlockUserResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
		m_Status.toStr(ctx, buffer, "Status", "", false, "", "");
	}
}


void CUnlockUserResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CUnlockUserResponse::serializer(IEspContext* ctx, IConstUnlockUserResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<UnlockUserResponse>");
	// field Status
	{
		const char* s = src.getStatus();
		if (s && *s)
		buffer.appendf("<Status>%s</Status>",s);
	}
	if (keepRootTag)
		buffer.append("</UnlockUserResponse>");
}

bool CUnlockUserResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
		hasValue |= m_Status.unmarshall(rpc_request, "Status", basepath);
	}
	return hasValue;
}

bool CUnlockUserResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Status.unmarshall(ctx, soapval, "Status");
	return hasValue;
}

bool CUnlockUserResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Status.unmarshall(ctx, params, attachments, "Status", basepath);
	return hasValue;
}

const char * CUnlockUserResponse::getStatus() { return m_Status.query();}
void CUnlockUserResponse::setStatus(const char * val){ m_Status.set(val); }
extern "C"  IEspUnlockUserResponse *createUnlockUserResponse(const char *serv){return ((IEspUnlockUserResponse *)new CUnlockUserResponse(serv));}
extern "C"  IClientUnlockUserResponse *createClientUnlockUserResponse(const char *serv){return ((IClientUnlockUserResponse *)new CUnlockUserResponse(serv));}

//=======================================================
// class CClientAliveRequest Implementation
//=======================================================

CClientAliveRequest::CClientAliveRequest(const char *serviceName, IRpcMessageBinding *init)
	: m_ReqInfo(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ClientAliveRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CClientAliveRequest::CClientAliveRequest(const char *serviceName, const char *bc)
	: m_ReqInfo(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ClientAliveRequest");
}

CClientAliveRequest::CClientAliveRequest(const char *serviceName, IRpcMessage* rpcmsg)
	: m_ReqInfo(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ClientAliveRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CClientAliveRequest::CClientAliveRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_ReqInfo(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ClientAliveRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CClientAliveRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"ReqInfo\" type=\"tns:WsDeployReqInfo\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	if (!(flags & 0x10)  || (flags & 0x100))
	{
		CWsDeployReqInfo::getXsdDefinition(context, request, schema, added);
	}
	return schema;
}

void CClientAliveRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CClientAliveRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
	if (!added.getValue("WsDeployReqInfo"))
	{
		added.setValue("WsDeployReqInfo",1);
		CWsDeployReqInfo::getMapInfo(info,added);
	}
}

StringBuffer &CClientAliveRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("ReqInfo");
	form.append("<tr>").append("<td><b>ReqInfo: </b></td><td><hr/>");
	CWsDeployReqInfo::getHtmlForm(context, request, serv, method, form, false, extfix.str());
	form.append("<hr/></td></tr>");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CClientAliveRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CClientAliveRequest::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_ReqInfo.marshall(rpc_resp, "ReqInfo", "", "", "");
}


void CClientAliveRequest::copy(CClientAliveRequest &from)
{
	m_ReqInfo.copy(from.m_ReqInfo);
}


void CClientAliveRequest::copy(IConstClientAliveRequest &ifrom)
{
	setReqInfo(ifrom.getReqInfo());
}


void CClientAliveRequest::getAttributes(IProperties &attributes)
{
}


void CClientAliveRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_ReqInfo.toStr(ctx, buffer, "ReqInfo", "", false, "", "");
}


void CClientAliveRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CClientAliveRequest::serializer(IEspContext* ctx, IConstClientAliveRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<ClientAliveRequest>");
	// field ReqInfo
	{
		StringBuffer tmp;
		CWsDeployReqInfo::serializer(ctx,src.getReqInfo(), tmp, false);
		if (tmp.length()>0)
			buffer.appendf("<ReqInfo>%s</ReqInfo>",tmp.str());
	}
	if (keepRootTag)
		buffer.append("</ClientAliveRequest>");
}

bool CClientAliveRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_ReqInfo.unmarshall(rpc_request, "ReqInfo", basepath);
	return hasValue;
}

bool CClientAliveRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_ReqInfo.unmarshall(ctx, soapval, "ReqInfo");
	return hasValue;
}

bool CClientAliveRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_ReqInfo.unmarshall(ctx, params, attachments, "ReqInfo", basepath);
	return hasValue;
}

IConstWsDeployReqInfo & CClientAliveRequest::getReqInfo() { return (IConstWsDeployReqInfo &) m_ReqInfo.getValue();}
IEspWsDeployReqInfo & CClientAliveRequest::updateReqInfo(){ return (IEspWsDeployReqInfo &) m_ReqInfo.getValue(); }
void CClientAliveRequest::setReqInfo(IConstWsDeployReqInfo &ifrom){ m_ReqInfo.copy(ifrom); }
extern "C"  IEspClientAliveRequest *createClientAliveRequest(const char *serv){return ((IEspClientAliveRequest *)new CClientAliveRequest(serv));}
extern "C"  IClientClientAliveRequest *createClientClientAliveRequest(const char *serv){return ((IClientClientAliveRequest *)new CClientAliveRequest(serv));}

//=======================================================
// class CClientAliveResponse Implementation
//=======================================================

CClientAliveResponse::CClientAliveResponse(const char *serviceName, IRpcMessageBinding *init)
	: m_LastSaved(nilIgnore),m_LastStarted(nilIgnore),m_RefreshClient(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ClientAliveResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CClientAliveResponse::CClientAliveResponse(const char *serviceName, const char *bc)
	: m_LastSaved(nilIgnore),m_LastStarted(nilIgnore),m_RefreshClient(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ClientAliveResponse");
}

CClientAliveResponse::CClientAliveResponse(const char *serviceName, IRpcMessage* rpcmsg)
	: m_LastSaved(nilIgnore),m_LastStarted(nilIgnore),m_RefreshClient(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ClientAliveResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CClientAliveResponse::CClientAliveResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_LastSaved(nilIgnore),m_LastStarted(nilIgnore),m_RefreshClient(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ClientAliveResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CClientAliveResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		schema.append("<xsd:element name=\"Exceptions\" type=\"tns:ArrayOfEspException\" minOccurs=\"0\" maxOccurs=\"1\"/>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"LastSaved\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"LastStarted\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"RefreshClient\" type=\"xsd:string\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CClientAliveResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CClientAliveResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CClientAliveResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("LastSaved");
	form.appendf("  <tr><td><b>LastSaved: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("LastStarted");
	form.appendf("  <tr><td><b>LastStarted: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("RefreshClient");
	form.appendf("  <tr><td><b>RefreshClient: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CClientAliveResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CClientAliveResponse::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	rpc_resp.setEncodeXml(false);
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
		m_LastSaved.marshall(rpc_resp, "LastSaved", "", "", "");
		m_LastStarted.marshall(rpc_resp, "LastStarted", "", "", "");
		m_RefreshClient.marshall(rpc_resp, "RefreshClient", "", "", "");
	}
}


void CClientAliveResponse::copy(CClientAliveResponse &from)
{
	m_LastSaved.copy(from.m_LastSaved);
	m_LastStarted.copy(from.m_LastStarted);
	m_RefreshClient.copy(from.m_RefreshClient);
}


void CClientAliveResponse::copy(IConstClientAliveResponse &ifrom)
{
	setLastSaved(ifrom.getLastSaved());
	setLastStarted(ifrom.getLastStarted());
	setRefreshClient(ifrom.getRefreshClient());
}


void CClientAliveResponse::getAttributes(IProperties &attributes)
{
}


void CClientAliveResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
		m_LastSaved.toStr(ctx, buffer, "LastSaved", "", false, "", "");
		m_LastStarted.toStr(ctx, buffer, "LastStarted", "", false, "", "");
		m_RefreshClient.toStr(ctx, buffer, "RefreshClient", "", false, "", "");
	}
}


void CClientAliveResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CClientAliveResponse::serializer(IEspContext* ctx, IConstClientAliveResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<ClientAliveResponse>");
	// field LastSaved
	{
		const char* s = src.getLastSaved();
		if (s && *s)
		buffer.appendf("<LastSaved>%s</LastSaved>",s);
	}
	// field LastStarted
	{
		const char* s = src.getLastStarted();
		if (s && *s)
		buffer.appendf("<LastStarted>%s</LastStarted>",s);
	}
	// field RefreshClient
	{
		const char* s = src.getRefreshClient();
		if (s && *s)
		buffer.appendf("<RefreshClient>%s</RefreshClient>",s);
	}
	if (keepRootTag)
		buffer.append("</ClientAliveResponse>");
}

bool CClientAliveResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
		hasValue |= m_LastSaved.unmarshall(rpc_request, "LastSaved", basepath);
		hasValue |= m_LastStarted.unmarshall(rpc_request, "LastStarted", basepath);
		hasValue |= m_RefreshClient.unmarshall(rpc_request, "RefreshClient", basepath);
	}
	return hasValue;
}

bool CClientAliveResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_LastSaved.unmarshall(ctx, soapval, "LastSaved");
	hasValue |= m_LastStarted.unmarshall(ctx, soapval, "LastStarted");
	hasValue |= m_RefreshClient.unmarshall(ctx, soapval, "RefreshClient");
	return hasValue;
}

bool CClientAliveResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_LastSaved.unmarshall(ctx, params, attachments, "LastSaved", basepath);
	hasValue |= m_LastStarted.unmarshall(ctx, params, attachments, "LastStarted", basepath);
	hasValue |= m_RefreshClient.unmarshall(ctx, params, attachments, "RefreshClient", basepath);
	return hasValue;
}

const char * CClientAliveResponse::getLastSaved() { return m_LastSaved.query();}
const char * CClientAliveResponse::getLastStarted() { return m_LastStarted.query();}
const char * CClientAliveResponse::getRefreshClient() { return m_RefreshClient.query();}
void CClientAliveResponse::setLastSaved(const char * val){ m_LastSaved.set(val); }
void CClientAliveResponse::setLastStarted(const char * val){ m_LastStarted.set(val); }
void CClientAliveResponse::setRefreshClient(const char * val){ m_RefreshClient.set(val); }
extern "C"  IEspClientAliveResponse *createClientAliveResponse(const char *serv){return ((IEspClientAliveResponse *)new CClientAliveResponse(serv));}
extern "C"  IClientClientAliveResponse *createClientClientAliveResponse(const char *serv){return ((IClientClientAliveResponse *)new CClientAliveResponse(serv));}

//=======================================================
// class CGetEnvironmentRequest Implementation
//=======================================================

CGetEnvironmentRequest::CGetEnvironmentRequest(const char *serviceName, IRpcMessageBinding *init)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetEnvironmentRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CGetEnvironmentRequest::CGetEnvironmentRequest(const char *serviceName, const char *bc)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetEnvironmentRequest");
}

CGetEnvironmentRequest::CGetEnvironmentRequest(const char *serviceName, IRpcMessage* rpcmsg)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetEnvironmentRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CGetEnvironmentRequest::CGetEnvironmentRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetEnvironmentRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CGetEnvironmentRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType><xsd:all/></xsd:complexType></xsd:element>\n", msgTypeName);
		}
	}
	return schema;
}

void CGetEnvironmentRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CGetEnvironmentRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CGetEnvironmentRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CGetEnvironmentRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CGetEnvironmentRequest::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

}


void CGetEnvironmentRequest::copy(CGetEnvironmentRequest &from)
{
}


void CGetEnvironmentRequest::copy(IConstGetEnvironmentRequest &ifrom)
{
}


void CGetEnvironmentRequest::getAttributes(IProperties &attributes)
{
}


void CGetEnvironmentRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
}


void CGetEnvironmentRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CGetEnvironmentRequest::serializer(IEspContext* ctx, IConstGetEnvironmentRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<GetEnvironmentRequest>");
	if (keepRootTag)
		buffer.append("</GetEnvironmentRequest>");
}

bool CGetEnvironmentRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	return hasValue;
}

bool CGetEnvironmentRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	return hasValue;
}

bool CGetEnvironmentRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	return hasValue;
}

extern "C"  IEspGetEnvironmentRequest *createGetEnvironmentRequest(const char *serv){return ((IEspGetEnvironmentRequest *)new CGetEnvironmentRequest(serv));}
extern "C"  IClientGetEnvironmentRequest *createClientGetEnvironmentRequest(const char *serv){return ((IClientGetEnvironmentRequest *)new CGetEnvironmentRequest(serv));}

//=======================================================
// class CGetEnvironmentResponse Implementation
//=======================================================

CGetEnvironmentResponse::CGetEnvironmentResponse(const char *serviceName, IRpcMessageBinding *init)
	: m_EnvXml(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetEnvironmentResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CGetEnvironmentResponse::CGetEnvironmentResponse(const char *serviceName, const char *bc)
	: m_EnvXml(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetEnvironmentResponse");
}

CGetEnvironmentResponse::CGetEnvironmentResponse(const char *serviceName, IRpcMessage* rpcmsg)
	: m_EnvXml(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetEnvironmentResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CGetEnvironmentResponse::CGetEnvironmentResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_EnvXml(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetEnvironmentResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CGetEnvironmentResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		schema.append("<xsd:element name=\"Exceptions\" type=\"tns:ArrayOfEspException\" minOccurs=\"0\" maxOccurs=\"1\"/>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"EnvXml\" type=\"xsd:string\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CGetEnvironmentResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CGetEnvironmentResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CGetEnvironmentResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("EnvXml");
	form.appendf("  <tr><td><b>EnvXml: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CGetEnvironmentResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CGetEnvironmentResponse::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	rpc_resp.setEncodeXml(false);
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
		m_EnvXml.marshall(rpc_resp, "EnvXml", "", "", "");
	}
}


void CGetEnvironmentResponse::copy(CGetEnvironmentResponse &from)
{
	m_EnvXml.copy(from.m_EnvXml);
}


void CGetEnvironmentResponse::copy(IConstGetEnvironmentResponse &ifrom)
{
	setEnvXml(ifrom.getEnvXml());
}


void CGetEnvironmentResponse::getAttributes(IProperties &attributes)
{
}


void CGetEnvironmentResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
		m_EnvXml.toStr(ctx, buffer, "EnvXml", "", false, "", "");
	}
}


void CGetEnvironmentResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CGetEnvironmentResponse::serializer(IEspContext* ctx, IConstGetEnvironmentResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<GetEnvironmentResponse>");
	// field EnvXml
	{
		const char* s = src.getEnvXml();
		if (s && *s)
		buffer.appendf("<EnvXml>%s</EnvXml>",s);
	}
	if (keepRootTag)
		buffer.append("</GetEnvironmentResponse>");
}

bool CGetEnvironmentResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
		hasValue |= m_EnvXml.unmarshall(rpc_request, "EnvXml", basepath);
	}
	return hasValue;
}

bool CGetEnvironmentResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_EnvXml.unmarshall(ctx, soapval, "EnvXml");
	return hasValue;
}

bool CGetEnvironmentResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_EnvXml.unmarshall(ctx, params, attachments, "EnvXml", basepath);
	return hasValue;
}

const char * CGetEnvironmentResponse::getEnvXml() { return m_EnvXml.query();}
void CGetEnvironmentResponse::setEnvXml(const char * val){ m_EnvXml.set(val); }
extern "C"  IEspGetEnvironmentResponse *createGetEnvironmentResponse(const char *serv){return ((IEspGetEnvironmentResponse *)new CGetEnvironmentResponse(serv));}
extern "C"  IClientGetEnvironmentResponse *createClientGetEnvironmentResponse(const char *serv){return ((IClientGetEnvironmentResponse *)new CGetEnvironmentResponse(serv));}

//=======================================================
// class CSetEnvironmentRequest Implementation
//=======================================================

CSetEnvironmentRequest::CSetEnvironmentRequest(const char *serviceName, IRpcMessageBinding *init)
	: m_EnvXml(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("SetEnvironmentRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CSetEnvironmentRequest::CSetEnvironmentRequest(const char *serviceName, const char *bc)
	: m_EnvXml(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("SetEnvironmentRequest");
}

CSetEnvironmentRequest::CSetEnvironmentRequest(const char *serviceName, IRpcMessage* rpcmsg)
	: m_EnvXml(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("SetEnvironmentRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CSetEnvironmentRequest::CSetEnvironmentRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_EnvXml(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("SetEnvironmentRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CSetEnvironmentRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"EnvXml\" type=\"xsd:string\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CSetEnvironmentRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CSetEnvironmentRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CSetEnvironmentRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("EnvXml");
	form.appendf("  <tr><td><b>EnvXml: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CSetEnvironmentRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CSetEnvironmentRequest::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_EnvXml.marshall(rpc_resp, "EnvXml", "", "", "");
}


void CSetEnvironmentRequest::copy(CSetEnvironmentRequest &from)
{
	m_EnvXml.copy(from.m_EnvXml);
}


void CSetEnvironmentRequest::copy(IConstSetEnvironmentRequest &ifrom)
{
	setEnvXml(ifrom.getEnvXml());
}


void CSetEnvironmentRequest::getAttributes(IProperties &attributes)
{
}


void CSetEnvironmentRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_EnvXml.toStr(ctx, buffer, "EnvXml", "", true, "", "");
}


void CSetEnvironmentRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CSetEnvironmentRequest::serializer(IEspContext* ctx, IConstSetEnvironmentRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<SetEnvironmentRequest>");
	// field EnvXml
	{
		const char* s = src.getEnvXml();
		if (s && *s)
		{
			buffer.append("<EnvXml>");
			encodeUtf8XML(s,buffer);
			buffer.append("</EnvXml>");
		}
	}
	if (keepRootTag)
		buffer.append("</SetEnvironmentRequest>");
}

bool CSetEnvironmentRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_EnvXml.unmarshall(rpc_request, "EnvXml", basepath);
	return hasValue;
}

bool CSetEnvironmentRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_EnvXml.unmarshall(ctx, soapval, "EnvXml");
	return hasValue;
}

bool CSetEnvironmentRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_EnvXml.unmarshall(ctx, params, attachments, "EnvXml", basepath);
	return hasValue;
}

const char * CSetEnvironmentRequest::getEnvXml() { return m_EnvXml.query();}
void CSetEnvironmentRequest::setEnvXml(const char * val){ m_EnvXml.set(val); }
extern "C"  IEspSetEnvironmentRequest *createSetEnvironmentRequest(const char *serv){return ((IEspSetEnvironmentRequest *)new CSetEnvironmentRequest(serv));}
extern "C"  IClientSetEnvironmentRequest *createClientSetEnvironmentRequest(const char *serv){return ((IClientSetEnvironmentRequest *)new CSetEnvironmentRequest(serv));}

//=======================================================
// class CSetEnvironmentResponse Implementation
//=======================================================

CSetEnvironmentResponse::CSetEnvironmentResponse(const char *serviceName, IRpcMessageBinding *init)
	: m_ReturnCode(nilIgnore),m_ErrorMsg(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("SetEnvironmentResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CSetEnvironmentResponse::CSetEnvironmentResponse(const char *serviceName, const char *bc)
	: m_ReturnCode(nilIgnore),m_ErrorMsg(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("SetEnvironmentResponse");
}

CSetEnvironmentResponse::CSetEnvironmentResponse(const char *serviceName, IRpcMessage* rpcmsg)
	: m_ReturnCode(nilIgnore),m_ErrorMsg(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("SetEnvironmentResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CSetEnvironmentResponse::CSetEnvironmentResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_ReturnCode(nilIgnore),m_ErrorMsg(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("SetEnvironmentResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CSetEnvironmentResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		schema.append("<xsd:element name=\"Exceptions\" type=\"tns:ArrayOfEspException\" minOccurs=\"0\" maxOccurs=\"1\"/>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"ReturnCode\" type=\"xsd:int\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"ErrorMsg\" type=\"xsd:string\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CSetEnvironmentResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CSetEnvironmentResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CSetEnvironmentResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix) extfix.append(prefix).append(".");
		extfix.append("ReturnCode");
	form.appendf("  <tr><td><b>ReturnCode: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("ErrorMsg");
	form.appendf("  <tr><td><b>ErrorMsg: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CSetEnvironmentResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CSetEnvironmentResponse::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	rpc_resp.setEncodeXml(false);
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
		m_ReturnCode.marshall(rpc_resp, "ReturnCode", "", "", "");
		m_ErrorMsg.marshall(rpc_resp, "ErrorMsg", "", "", "");
	}
}


void CSetEnvironmentResponse::copy(CSetEnvironmentResponse &from)
{
	m_ReturnCode.copy(from.m_ReturnCode);
	m_ErrorMsg.copy(from.m_ErrorMsg);
}


void CSetEnvironmentResponse::copy(IConstSetEnvironmentResponse &ifrom)
{
	setReturnCode(ifrom.getReturnCode());
	setErrorMsg(ifrom.getErrorMsg());
}


void CSetEnvironmentResponse::getAttributes(IProperties &attributes)
{
}


void CSetEnvironmentResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
		m_ReturnCode.toStr(ctx, buffer, "ReturnCode", "", false, "", "");
		m_ErrorMsg.toStr(ctx, buffer, "ErrorMsg", "", false, "", "");
	}
}


void CSetEnvironmentResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CSetEnvironmentResponse::serializer(IEspContext* ctx, IConstSetEnvironmentResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<SetEnvironmentResponse>");
	// field ReturnCode
	{
		int n = src.getReturnCode();
		if (n)
			buffer.appendf("<ReturnCode>%d</ReturnCode>", n);
	}
	// field ErrorMsg
	{
		const char* s = src.getErrorMsg();
		if (s && *s)
		buffer.appendf("<ErrorMsg>%s</ErrorMsg>",s);
	}
	if (keepRootTag)
		buffer.append("</SetEnvironmentResponse>");
}

bool CSetEnvironmentResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
		hasValue |= m_ReturnCode.unmarshall(rpc_request, "ReturnCode", basepath);
		hasValue |= m_ErrorMsg.unmarshall(rpc_request, "ErrorMsg", basepath);
	}
	return hasValue;
}

bool CSetEnvironmentResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_ReturnCode.unmarshall(ctx, soapval, "ReturnCode");
	hasValue |= m_ErrorMsg.unmarshall(ctx, soapval, "ErrorMsg");
	return hasValue;
}

bool CSetEnvironmentResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_ReturnCode.unmarshall(ctx, params, attachments, "ReturnCode", basepath);
	hasValue |= m_ErrorMsg.unmarshall(ctx, params, attachments, "ErrorMsg", basepath);
	return hasValue;
}

int CSetEnvironmentResponse::getReturnCode() { return m_ReturnCode;}
const char * CSetEnvironmentResponse::getErrorMsg() { return m_ErrorMsg.query();}
void CSetEnvironmentResponse::setReturnCode(int val){ m_ReturnCode=val; }
void CSetEnvironmentResponse::setErrorMsg(const char * val){ m_ErrorMsg.set(val); }
extern "C"  IEspSetEnvironmentResponse *createSetEnvironmentResponse(const char *serv){return ((IEspSetEnvironmentResponse *)new CSetEnvironmentResponse(serv));}
extern "C"  IClientSetEnvironmentResponse *createClientSetEnvironmentResponse(const char *serv){return ((IClientSetEnvironmentResponse *)new CSetEnvironmentResponse(serv));}

//=======================================================
// class CLockEnvironmentForCloudRequest Implementation
//=======================================================

CLockEnvironmentForCloudRequest::CLockEnvironmentForCloudRequest(const char *serviceName, IRpcMessageBinding *init)
	: m_Ip(nilIgnore),m_UserName(nilIgnore),m_ReqInfo(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("LockEnvironmentForCloudRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CLockEnvironmentForCloudRequest::CLockEnvironmentForCloudRequest(const char *serviceName, const char *bc)
	: m_Ip(nilIgnore),m_UserName(nilIgnore),m_ReqInfo(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("LockEnvironmentForCloudRequest");
}

CLockEnvironmentForCloudRequest::CLockEnvironmentForCloudRequest(const char *serviceName, IRpcMessage* rpcmsg)
	: m_Ip(nilIgnore),m_UserName(nilIgnore),m_ReqInfo(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("LockEnvironmentForCloudRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CLockEnvironmentForCloudRequest::CLockEnvironmentForCloudRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_Ip(nilIgnore),m_UserName(nilIgnore),m_ReqInfo(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("LockEnvironmentForCloudRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CLockEnvironmentForCloudRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Ip\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"UserName\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"ReqInfo\" type=\"tns:WsDeployReqInfo\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	if (!(flags & 0x10)  || (flags & 0x100))
	{
		CWsDeployReqInfo::getXsdDefinition(context, request, schema, added);
	}
	return schema;
}

void CLockEnvironmentForCloudRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CLockEnvironmentForCloudRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
	if (!added.getValue("WsDeployReqInfo"))
	{
		added.setValue("WsDeployReqInfo",1);
		CWsDeployReqInfo::getMapInfo(info,added);
	}
}

StringBuffer &CLockEnvironmentForCloudRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Ip");
	form.appendf("  <tr><td><b>Ip: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("UserName");
	form.appendf("  <tr><td><b>UserName: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("ReqInfo");
	form.append("<tr>").append("<td><b>ReqInfo: </b></td><td><hr/>");
	CWsDeployReqInfo::getHtmlForm(context, request, serv, method, form, false, extfix.str());
	form.append("<hr/></td></tr>");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CLockEnvironmentForCloudRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CLockEnvironmentForCloudRequest::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_Ip.marshall(rpc_resp, "Ip", "", "", "");
	m_UserName.marshall(rpc_resp, "UserName", "", "", "");
	m_ReqInfo.marshall(rpc_resp, "ReqInfo", "", "", "");
}


void CLockEnvironmentForCloudRequest::copy(CLockEnvironmentForCloudRequest &from)
{
	m_Ip.copy(from.m_Ip);
	m_UserName.copy(from.m_UserName);
	m_ReqInfo.copy(from.m_ReqInfo);
}


void CLockEnvironmentForCloudRequest::copy(IConstLockEnvironmentForCloudRequest &ifrom)
{
	setIp(ifrom.getIp());
	setUserName(ifrom.getUserName());
	setReqInfo(ifrom.getReqInfo());
}


void CLockEnvironmentForCloudRequest::getAttributes(IProperties &attributes)
{
}


void CLockEnvironmentForCloudRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_Ip.toStr(ctx, buffer, "Ip", "", true, "", "");
	m_UserName.toStr(ctx, buffer, "UserName", "", true, "", "");
	m_ReqInfo.toStr(ctx, buffer, "ReqInfo", "", false, "", "");
}


void CLockEnvironmentForCloudRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CLockEnvironmentForCloudRequest::serializer(IEspContext* ctx, IConstLockEnvironmentForCloudRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<LockEnvironmentForCloudRequest>");
	// field Ip
	{
		const char* s = src.getIp();
		if (s && *s)
		{
			buffer.append("<Ip>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Ip>");
		}
	}
	// field UserName
	{
		const char* s = src.getUserName();
		if (s && *s)
		{
			buffer.append("<UserName>");
			encodeUtf8XML(s,buffer);
			buffer.append("</UserName>");
		}
	}
	// field ReqInfo
	{
		StringBuffer tmp;
		CWsDeployReqInfo::serializer(ctx,src.getReqInfo(), tmp, false);
		if (tmp.length()>0)
			buffer.appendf("<ReqInfo>%s</ReqInfo>",tmp.str());
	}
	if (keepRootTag)
		buffer.append("</LockEnvironmentForCloudRequest>");
}

bool CLockEnvironmentForCloudRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_Ip.unmarshall(rpc_request, "Ip", basepath);
	hasValue |= m_UserName.unmarshall(rpc_request, "UserName", basepath);
	hasValue |= m_ReqInfo.unmarshall(rpc_request, "ReqInfo", basepath);
	return hasValue;
}

bool CLockEnvironmentForCloudRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Ip.unmarshall(ctx, soapval, "Ip");
	hasValue |= m_UserName.unmarshall(ctx, soapval, "UserName");
	hasValue |= m_ReqInfo.unmarshall(ctx, soapval, "ReqInfo");
	return hasValue;
}

bool CLockEnvironmentForCloudRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Ip.unmarshall(ctx, params, attachments, "Ip", basepath);
	hasValue |= m_UserName.unmarshall(ctx, params, attachments, "UserName", basepath);
	hasValue |= m_ReqInfo.unmarshall(ctx, params, attachments, "ReqInfo", basepath);
	return hasValue;
}

const char * CLockEnvironmentForCloudRequest::getIp() { return m_Ip.query();}
const char * CLockEnvironmentForCloudRequest::getUserName() { return m_UserName.query();}
IConstWsDeployReqInfo & CLockEnvironmentForCloudRequest::getReqInfo() { return (IConstWsDeployReqInfo &) m_ReqInfo.getValue();}
void CLockEnvironmentForCloudRequest::setIp(const char * val){ m_Ip.set(val); }
void CLockEnvironmentForCloudRequest::setUserName(const char * val){ m_UserName.set(val); }
IEspWsDeployReqInfo & CLockEnvironmentForCloudRequest::updateReqInfo(){ return (IEspWsDeployReqInfo &) m_ReqInfo.getValue(); }
void CLockEnvironmentForCloudRequest::setReqInfo(IConstWsDeployReqInfo &ifrom){ m_ReqInfo.copy(ifrom); }
extern "C"  IEspLockEnvironmentForCloudRequest *createLockEnvironmentForCloudRequest(const char *serv){return ((IEspLockEnvironmentForCloudRequest *)new CLockEnvironmentForCloudRequest(serv));}
extern "C"  IClientLockEnvironmentForCloudRequest *createClientLockEnvironmentForCloudRequest(const char *serv){return ((IClientLockEnvironmentForCloudRequest *)new CLockEnvironmentForCloudRequest(serv));}

//=======================================================
// class CLockEnvironmentForCloudResponse Implementation
//=======================================================

CLockEnvironmentForCloudResponse::CLockEnvironmentForCloudResponse(const char *serviceName, IRpcMessageBinding *init)
	: m_Msg(nilIgnore),m_ReturnCode(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("LockEnvironmentForCloudResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CLockEnvironmentForCloudResponse::CLockEnvironmentForCloudResponse(const char *serviceName, const char *bc)
	: m_Msg(nilIgnore),m_ReturnCode(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("LockEnvironmentForCloudResponse");
}

CLockEnvironmentForCloudResponse::CLockEnvironmentForCloudResponse(const char *serviceName, IRpcMessage* rpcmsg)
	: m_Msg(nilIgnore),m_ReturnCode(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("LockEnvironmentForCloudResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CLockEnvironmentForCloudResponse::CLockEnvironmentForCloudResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_Msg(nilIgnore),m_ReturnCode(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("LockEnvironmentForCloudResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CLockEnvironmentForCloudResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		schema.append("<xsd:element name=\"Exceptions\" type=\"tns:ArrayOfEspException\" minOccurs=\"0\" maxOccurs=\"1\"/>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Msg\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"ReturnCode\" type=\"xsd:int\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CLockEnvironmentForCloudResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CLockEnvironmentForCloudResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CLockEnvironmentForCloudResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Msg");
	form.appendf("  <tr><td><b>Msg: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix) extfix.append(prefix).append(".");
		extfix.append("ReturnCode");
	form.appendf("  <tr><td><b>ReturnCode: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CLockEnvironmentForCloudResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CLockEnvironmentForCloudResponse::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	rpc_resp.setEncodeXml(false);
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
		m_Msg.marshall(rpc_resp, "Msg", "", "", "");
		m_ReturnCode.marshall(rpc_resp, "ReturnCode", "", "", "");
	}
}


void CLockEnvironmentForCloudResponse::copy(CLockEnvironmentForCloudResponse &from)
{
	m_Msg.copy(from.m_Msg);
	m_ReturnCode.copy(from.m_ReturnCode);
}


void CLockEnvironmentForCloudResponse::copy(IConstLockEnvironmentForCloudResponse &ifrom)
{
	setMsg(ifrom.getMsg());
	setReturnCode(ifrom.getReturnCode());
}


void CLockEnvironmentForCloudResponse::getAttributes(IProperties &attributes)
{
}


void CLockEnvironmentForCloudResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
		m_Msg.toStr(ctx, buffer, "Msg", "", false, "", "");
		m_ReturnCode.toStr(ctx, buffer, "ReturnCode", "", false, "", "");
	}
}


void CLockEnvironmentForCloudResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CLockEnvironmentForCloudResponse::serializer(IEspContext* ctx, IConstLockEnvironmentForCloudResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<LockEnvironmentForCloudResponse>");
	// field Msg
	{
		const char* s = src.getMsg();
		if (s && *s)
		buffer.appendf("<Msg>%s</Msg>",s);
	}
	// field ReturnCode
	{
		int n = src.getReturnCode();
		if (n)
			buffer.appendf("<ReturnCode>%d</ReturnCode>", n);
	}
	if (keepRootTag)
		buffer.append("</LockEnvironmentForCloudResponse>");
}

bool CLockEnvironmentForCloudResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
		hasValue |= m_Msg.unmarshall(rpc_request, "Msg", basepath);
		hasValue |= m_ReturnCode.unmarshall(rpc_request, "ReturnCode", basepath);
	}
	return hasValue;
}

bool CLockEnvironmentForCloudResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Msg.unmarshall(ctx, soapval, "Msg");
	hasValue |= m_ReturnCode.unmarshall(ctx, soapval, "ReturnCode");
	return hasValue;
}

bool CLockEnvironmentForCloudResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Msg.unmarshall(ctx, params, attachments, "Msg", basepath);
	hasValue |= m_ReturnCode.unmarshall(ctx, params, attachments, "ReturnCode", basepath);
	return hasValue;
}

const char * CLockEnvironmentForCloudResponse::getMsg() { return m_Msg.query();}
int CLockEnvironmentForCloudResponse::getReturnCode() { return m_ReturnCode;}
void CLockEnvironmentForCloudResponse::setMsg(const char * val){ m_Msg.set(val); }
void CLockEnvironmentForCloudResponse::setReturnCode(int val){ m_ReturnCode=val; }
extern "C"  IEspLockEnvironmentForCloudResponse *createLockEnvironmentForCloudResponse(const char *serv){return ((IEspLockEnvironmentForCloudResponse *)new CLockEnvironmentForCloudResponse(serv));}
extern "C"  IClientLockEnvironmentForCloudResponse *createClientLockEnvironmentForCloudResponse(const char *serv){return ((IClientLockEnvironmentForCloudResponse *)new CLockEnvironmentForCloudResponse(serv));}

//=======================================================
// class CUnlockEnvironmentForCloudRequest Implementation
//=======================================================

CUnlockEnvironmentForCloudRequest::CUnlockEnvironmentForCloudRequest(const char *serviceName, IRpcMessageBinding *init)
	: m_Ip(nilIgnore),m_UserName(nilIgnore),m_NewEnvXml(nilIgnore),m_ReqInfo(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("UnlockEnvironmentForCloudRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CUnlockEnvironmentForCloudRequest::CUnlockEnvironmentForCloudRequest(const char *serviceName, const char *bc)
	: m_Ip(nilIgnore),m_UserName(nilIgnore),m_NewEnvXml(nilIgnore),m_ReqInfo(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("UnlockEnvironmentForCloudRequest");
}

CUnlockEnvironmentForCloudRequest::CUnlockEnvironmentForCloudRequest(const char *serviceName, IRpcMessage* rpcmsg)
	: m_Ip(nilIgnore),m_UserName(nilIgnore),m_NewEnvXml(nilIgnore),m_ReqInfo(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("UnlockEnvironmentForCloudRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CUnlockEnvironmentForCloudRequest::CUnlockEnvironmentForCloudRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_Ip(nilIgnore),m_UserName(nilIgnore),m_NewEnvXml(nilIgnore),m_ReqInfo(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("UnlockEnvironmentForCloudRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CUnlockEnvironmentForCloudRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Ip\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"UserName\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"NewEnvXml\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"ReqInfo\" type=\"tns:WsDeployReqInfo\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	if (!(flags & 0x10)  || (flags & 0x100))
	{
		CWsDeployReqInfo::getXsdDefinition(context, request, schema, added);
	}
	return schema;
}

void CUnlockEnvironmentForCloudRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CUnlockEnvironmentForCloudRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
	if (!added.getValue("WsDeployReqInfo"))
	{
		added.setValue("WsDeployReqInfo",1);
		CWsDeployReqInfo::getMapInfo(info,added);
	}
}

StringBuffer &CUnlockEnvironmentForCloudRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Ip");
	form.appendf("  <tr><td><b>Ip: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("UserName");
	form.appendf("  <tr><td><b>UserName: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("NewEnvXml");
	form.appendf("  <tr><td><b>NewEnvXml: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("ReqInfo");
	form.append("<tr>").append("<td><b>ReqInfo: </b></td><td><hr/>");
	CWsDeployReqInfo::getHtmlForm(context, request, serv, method, form, false, extfix.str());
	form.append("<hr/></td></tr>");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CUnlockEnvironmentForCloudRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CUnlockEnvironmentForCloudRequest::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_Ip.marshall(rpc_resp, "Ip", "", "", "");
	m_UserName.marshall(rpc_resp, "UserName", "", "", "");
	m_NewEnvXml.marshall(rpc_resp, "NewEnvXml", "", "", "");
	m_ReqInfo.marshall(rpc_resp, "ReqInfo", "", "", "");
}


void CUnlockEnvironmentForCloudRequest::copy(CUnlockEnvironmentForCloudRequest &from)
{
	m_Ip.copy(from.m_Ip);
	m_UserName.copy(from.m_UserName);
	m_NewEnvXml.copy(from.m_NewEnvXml);
	m_ReqInfo.copy(from.m_ReqInfo);
}


void CUnlockEnvironmentForCloudRequest::copy(IConstUnlockEnvironmentForCloudRequest &ifrom)
{
	setIp(ifrom.getIp());
	setUserName(ifrom.getUserName());
	setNewEnvXml(ifrom.getNewEnvXml());
	setReqInfo(ifrom.getReqInfo());
}


void CUnlockEnvironmentForCloudRequest::getAttributes(IProperties &attributes)
{
}


void CUnlockEnvironmentForCloudRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_Ip.toStr(ctx, buffer, "Ip", "", true, "", "");
	m_UserName.toStr(ctx, buffer, "UserName", "", true, "", "");
	m_NewEnvXml.toStr(ctx, buffer, "NewEnvXml", "", true, "", "");
	m_ReqInfo.toStr(ctx, buffer, "ReqInfo", "", false, "", "");
}


void CUnlockEnvironmentForCloudRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CUnlockEnvironmentForCloudRequest::serializer(IEspContext* ctx, IConstUnlockEnvironmentForCloudRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<UnlockEnvironmentForCloudRequest>");
	// field Ip
	{
		const char* s = src.getIp();
		if (s && *s)
		{
			buffer.append("<Ip>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Ip>");
		}
	}
	// field UserName
	{
		const char* s = src.getUserName();
		if (s && *s)
		{
			buffer.append("<UserName>");
			encodeUtf8XML(s,buffer);
			buffer.append("</UserName>");
		}
	}
	// field NewEnvXml
	{
		const char* s = src.getNewEnvXml();
		if (s && *s)
		{
			buffer.append("<NewEnvXml>");
			encodeUtf8XML(s,buffer);
			buffer.append("</NewEnvXml>");
		}
	}
	// field ReqInfo
	{
		StringBuffer tmp;
		CWsDeployReqInfo::serializer(ctx,src.getReqInfo(), tmp, false);
		if (tmp.length()>0)
			buffer.appendf("<ReqInfo>%s</ReqInfo>",tmp.str());
	}
	if (keepRootTag)
		buffer.append("</UnlockEnvironmentForCloudRequest>");
}

bool CUnlockEnvironmentForCloudRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_Ip.unmarshall(rpc_request, "Ip", basepath);
	hasValue |= m_UserName.unmarshall(rpc_request, "UserName", basepath);
	hasValue |= m_NewEnvXml.unmarshall(rpc_request, "NewEnvXml", basepath);
	hasValue |= m_ReqInfo.unmarshall(rpc_request, "ReqInfo", basepath);
	return hasValue;
}

bool CUnlockEnvironmentForCloudRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Ip.unmarshall(ctx, soapval, "Ip");
	hasValue |= m_UserName.unmarshall(ctx, soapval, "UserName");
	hasValue |= m_NewEnvXml.unmarshall(ctx, soapval, "NewEnvXml");
	hasValue |= m_ReqInfo.unmarshall(ctx, soapval, "ReqInfo");
	return hasValue;
}

bool CUnlockEnvironmentForCloudRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Ip.unmarshall(ctx, params, attachments, "Ip", basepath);
	hasValue |= m_UserName.unmarshall(ctx, params, attachments, "UserName", basepath);
	hasValue |= m_NewEnvXml.unmarshall(ctx, params, attachments, "NewEnvXml", basepath);
	hasValue |= m_ReqInfo.unmarshall(ctx, params, attachments, "ReqInfo", basepath);
	return hasValue;
}

const char * CUnlockEnvironmentForCloudRequest::getIp() { return m_Ip.query();}
const char * CUnlockEnvironmentForCloudRequest::getUserName() { return m_UserName.query();}
const char * CUnlockEnvironmentForCloudRequest::getNewEnvXml() { return m_NewEnvXml.query();}
IConstWsDeployReqInfo & CUnlockEnvironmentForCloudRequest::getReqInfo() { return (IConstWsDeployReqInfo &) m_ReqInfo.getValue();}
void CUnlockEnvironmentForCloudRequest::setIp(const char * val){ m_Ip.set(val); }
void CUnlockEnvironmentForCloudRequest::setUserName(const char * val){ m_UserName.set(val); }
void CUnlockEnvironmentForCloudRequest::setNewEnvXml(const char * val){ m_NewEnvXml.set(val); }
IEspWsDeployReqInfo & CUnlockEnvironmentForCloudRequest::updateReqInfo(){ return (IEspWsDeployReqInfo &) m_ReqInfo.getValue(); }
void CUnlockEnvironmentForCloudRequest::setReqInfo(IConstWsDeployReqInfo &ifrom){ m_ReqInfo.copy(ifrom); }
extern "C"  IEspUnlockEnvironmentForCloudRequest *createUnlockEnvironmentForCloudRequest(const char *serv){return ((IEspUnlockEnvironmentForCloudRequest *)new CUnlockEnvironmentForCloudRequest(serv));}
extern "C"  IClientUnlockEnvironmentForCloudRequest *createClientUnlockEnvironmentForCloudRequest(const char *serv){return ((IClientUnlockEnvironmentForCloudRequest *)new CUnlockEnvironmentForCloudRequest(serv));}

//=======================================================
// class CUnlockEnvironmentForCloudResponse Implementation
//=======================================================

CUnlockEnvironmentForCloudResponse::CUnlockEnvironmentForCloudResponse(const char *serviceName, IRpcMessageBinding *init)
	: m_Msg(nilIgnore),m_ReturnCode(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("UnlockEnvironmentForCloudResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CUnlockEnvironmentForCloudResponse::CUnlockEnvironmentForCloudResponse(const char *serviceName, const char *bc)
	: m_Msg(nilIgnore),m_ReturnCode(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("UnlockEnvironmentForCloudResponse");
}

CUnlockEnvironmentForCloudResponse::CUnlockEnvironmentForCloudResponse(const char *serviceName, IRpcMessage* rpcmsg)
	: m_Msg(nilIgnore),m_ReturnCode(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("UnlockEnvironmentForCloudResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CUnlockEnvironmentForCloudResponse::CUnlockEnvironmentForCloudResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_Msg(nilIgnore),m_ReturnCode(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("UnlockEnvironmentForCloudResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CUnlockEnvironmentForCloudResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		schema.append("<xsd:element name=\"Exceptions\" type=\"tns:ArrayOfEspException\" minOccurs=\"0\" maxOccurs=\"1\"/>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Msg\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"ReturnCode\" type=\"xsd:int\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CUnlockEnvironmentForCloudResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CUnlockEnvironmentForCloudResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CUnlockEnvironmentForCloudResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Msg");
	form.appendf("  <tr><td><b>Msg: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix) extfix.append(prefix).append(".");
		extfix.append("ReturnCode");
	form.appendf("  <tr><td><b>ReturnCode: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CUnlockEnvironmentForCloudResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CUnlockEnvironmentForCloudResponse::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	rpc_resp.setEncodeXml(false);
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
		m_Msg.marshall(rpc_resp, "Msg", "", "", "");
		m_ReturnCode.marshall(rpc_resp, "ReturnCode", "", "", "");
	}
}


void CUnlockEnvironmentForCloudResponse::copy(CUnlockEnvironmentForCloudResponse &from)
{
	m_Msg.copy(from.m_Msg);
	m_ReturnCode.copy(from.m_ReturnCode);
}


void CUnlockEnvironmentForCloudResponse::copy(IConstUnlockEnvironmentForCloudResponse &ifrom)
{
	setMsg(ifrom.getMsg());
	setReturnCode(ifrom.getReturnCode());
}


void CUnlockEnvironmentForCloudResponse::getAttributes(IProperties &attributes)
{
}


void CUnlockEnvironmentForCloudResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
		m_Msg.toStr(ctx, buffer, "Msg", "", false, "", "");
		m_ReturnCode.toStr(ctx, buffer, "ReturnCode", "", false, "", "");
	}
}


void CUnlockEnvironmentForCloudResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CUnlockEnvironmentForCloudResponse::serializer(IEspContext* ctx, IConstUnlockEnvironmentForCloudResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<UnlockEnvironmentForCloudResponse>");
	// field Msg
	{
		const char* s = src.getMsg();
		if (s && *s)
		buffer.appendf("<Msg>%s</Msg>",s);
	}
	// field ReturnCode
	{
		int n = src.getReturnCode();
		if (n)
			buffer.appendf("<ReturnCode>%d</ReturnCode>", n);
	}
	if (keepRootTag)
		buffer.append("</UnlockEnvironmentForCloudResponse>");
}

bool CUnlockEnvironmentForCloudResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
		hasValue |= m_Msg.unmarshall(rpc_request, "Msg", basepath);
		hasValue |= m_ReturnCode.unmarshall(rpc_request, "ReturnCode", basepath);
	}
	return hasValue;
}

bool CUnlockEnvironmentForCloudResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Msg.unmarshall(ctx, soapval, "Msg");
	hasValue |= m_ReturnCode.unmarshall(ctx, soapval, "ReturnCode");
	return hasValue;
}

bool CUnlockEnvironmentForCloudResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Msg.unmarshall(ctx, params, attachments, "Msg", basepath);
	hasValue |= m_ReturnCode.unmarshall(ctx, params, attachments, "ReturnCode", basepath);
	return hasValue;
}

const char * CUnlockEnvironmentForCloudResponse::getMsg() { return m_Msg.query();}
int CUnlockEnvironmentForCloudResponse::getReturnCode() { return m_ReturnCode;}
void CUnlockEnvironmentForCloudResponse::setMsg(const char * val){ m_Msg.set(val); }
void CUnlockEnvironmentForCloudResponse::setReturnCode(int val){ m_ReturnCode=val; }
extern "C"  IEspUnlockEnvironmentForCloudResponse *createUnlockEnvironmentForCloudResponse(const char *serv){return ((IEspUnlockEnvironmentForCloudResponse *)new CUnlockEnvironmentForCloudResponse(serv));}
extern "C"  IClientUnlockEnvironmentForCloudResponse *createClientUnlockEnvironmentForCloudResponse(const char *serv){return ((IClientUnlockEnvironmentForCloudResponse *)new CUnlockEnvironmentForCloudResponse(serv));}

//=======================================================
// class CSaveEnvironmentForCloudRequest Implementation
//=======================================================

CSaveEnvironmentForCloudRequest::CSaveEnvironmentForCloudRequest(const char *serviceName, IRpcMessageBinding *init)
	: m_Ip(nilIgnore),m_UserName(nilIgnore),m_NewEnv(nilIgnore),m_Id(nilIgnore),m_ReqInfo(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("SaveEnvironmentForCloudRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CSaveEnvironmentForCloudRequest::CSaveEnvironmentForCloudRequest(const char *serviceName, const char *bc)
	: m_Ip(nilIgnore),m_UserName(nilIgnore),m_NewEnv(nilIgnore),m_Id(nilIgnore),m_ReqInfo(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("SaveEnvironmentForCloudRequest");
}

CSaveEnvironmentForCloudRequest::CSaveEnvironmentForCloudRequest(const char *serviceName, IRpcMessage* rpcmsg)
	: m_Ip(nilIgnore),m_UserName(nilIgnore),m_NewEnv(nilIgnore),m_Id(nilIgnore),m_ReqInfo(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("SaveEnvironmentForCloudRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CSaveEnvironmentForCloudRequest::CSaveEnvironmentForCloudRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_Ip(nilIgnore),m_UserName(nilIgnore),m_NewEnv(nilIgnore),m_Id(nilIgnore),m_ReqInfo(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("SaveEnvironmentForCloudRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CSaveEnvironmentForCloudRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Ip\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"UserName\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"NewEnv\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Id\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"ReqInfo\" type=\"tns:WsDeployReqInfo\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	if (!(flags & 0x10)  || (flags & 0x100))
	{
		CWsDeployReqInfo::getXsdDefinition(context, request, schema, added);
	}
	return schema;
}

void CSaveEnvironmentForCloudRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CSaveEnvironmentForCloudRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
	if (!added.getValue("WsDeployReqInfo"))
	{
		added.setValue("WsDeployReqInfo",1);
		CWsDeployReqInfo::getMapInfo(info,added);
	}
}

StringBuffer &CSaveEnvironmentForCloudRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Ip");
	form.appendf("  <tr><td><b>Ip: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("UserName");
	form.appendf("  <tr><td><b>UserName: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("NewEnv");
	form.appendf("  <tr><td><b>NewEnv: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Id");
	form.appendf("  <tr><td><b>Id: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("ReqInfo");
	form.append("<tr>").append("<td><b>ReqInfo: </b></td><td><hr/>");
	CWsDeployReqInfo::getHtmlForm(context, request, serv, method, form, false, extfix.str());
	form.append("<hr/></td></tr>");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CSaveEnvironmentForCloudRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CSaveEnvironmentForCloudRequest::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_Ip.marshall(rpc_resp, "Ip", "", "", "");
	m_UserName.marshall(rpc_resp, "UserName", "", "", "");
	m_NewEnv.marshall(rpc_resp, "NewEnv", "", "", "");
	m_Id.marshall(rpc_resp, "Id", "", "", "");
	m_ReqInfo.marshall(rpc_resp, "ReqInfo", "", "", "");
}


void CSaveEnvironmentForCloudRequest::copy(CSaveEnvironmentForCloudRequest &from)
{
	m_Ip.copy(from.m_Ip);
	m_UserName.copy(from.m_UserName);
	m_NewEnv.copy(from.m_NewEnv);
	m_Id.copy(from.m_Id);
	m_ReqInfo.copy(from.m_ReqInfo);
}


void CSaveEnvironmentForCloudRequest::copy(IConstSaveEnvironmentForCloudRequest &ifrom)
{
	setIp(ifrom.getIp());
	setUserName(ifrom.getUserName());
	setNewEnv(ifrom.getNewEnv());
	setId(ifrom.getId());
	setReqInfo(ifrom.getReqInfo());
}


void CSaveEnvironmentForCloudRequest::getAttributes(IProperties &attributes)
{
}


void CSaveEnvironmentForCloudRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_Ip.toStr(ctx, buffer, "Ip", "", true, "", "");
	m_UserName.toStr(ctx, buffer, "UserName", "", true, "", "");
	m_NewEnv.toStr(ctx, buffer, "NewEnv", "", true, "", "");
	m_Id.toStr(ctx, buffer, "Id", "", true, "", "");
	m_ReqInfo.toStr(ctx, buffer, "ReqInfo", "", false, "", "");
}


void CSaveEnvironmentForCloudRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CSaveEnvironmentForCloudRequest::serializer(IEspContext* ctx, IConstSaveEnvironmentForCloudRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<SaveEnvironmentForCloudRequest>");
	// field Ip
	{
		const char* s = src.getIp();
		if (s && *s)
		{
			buffer.append("<Ip>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Ip>");
		}
	}
	// field UserName
	{
		const char* s = src.getUserName();
		if (s && *s)
		{
			buffer.append("<UserName>");
			encodeUtf8XML(s,buffer);
			buffer.append("</UserName>");
		}
	}
	// field NewEnv
	{
		const char* s = src.getNewEnv();
		if (s && *s)
		{
			buffer.append("<NewEnv>");
			encodeUtf8XML(s,buffer);
			buffer.append("</NewEnv>");
		}
	}
	// field Id
	{
		const char* s = src.getId();
		if (s && *s)
		{
			buffer.append("<Id>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Id>");
		}
	}
	// field ReqInfo
	{
		StringBuffer tmp;
		CWsDeployReqInfo::serializer(ctx,src.getReqInfo(), tmp, false);
		if (tmp.length()>0)
			buffer.appendf("<ReqInfo>%s</ReqInfo>",tmp.str());
	}
	if (keepRootTag)
		buffer.append("</SaveEnvironmentForCloudRequest>");
}

bool CSaveEnvironmentForCloudRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_Ip.unmarshall(rpc_request, "Ip", basepath);
	hasValue |= m_UserName.unmarshall(rpc_request, "UserName", basepath);
	hasValue |= m_NewEnv.unmarshall(rpc_request, "NewEnv", basepath);
	hasValue |= m_Id.unmarshall(rpc_request, "Id", basepath);
	hasValue |= m_ReqInfo.unmarshall(rpc_request, "ReqInfo", basepath);
	return hasValue;
}

bool CSaveEnvironmentForCloudRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Ip.unmarshall(ctx, soapval, "Ip");
	hasValue |= m_UserName.unmarshall(ctx, soapval, "UserName");
	hasValue |= m_NewEnv.unmarshall(ctx, soapval, "NewEnv");
	hasValue |= m_Id.unmarshall(ctx, soapval, "Id");
	hasValue |= m_ReqInfo.unmarshall(ctx, soapval, "ReqInfo");
	return hasValue;
}

bool CSaveEnvironmentForCloudRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Ip.unmarshall(ctx, params, attachments, "Ip", basepath);
	hasValue |= m_UserName.unmarshall(ctx, params, attachments, "UserName", basepath);
	hasValue |= m_NewEnv.unmarshall(ctx, params, attachments, "NewEnv", basepath);
	hasValue |= m_Id.unmarshall(ctx, params, attachments, "Id", basepath);
	hasValue |= m_ReqInfo.unmarshall(ctx, params, attachments, "ReqInfo", basepath);
	return hasValue;
}

const char * CSaveEnvironmentForCloudRequest::getIp() { return m_Ip.query();}
const char * CSaveEnvironmentForCloudRequest::getUserName() { return m_UserName.query();}
const char * CSaveEnvironmentForCloudRequest::getNewEnv() { return m_NewEnv.query();}
const char * CSaveEnvironmentForCloudRequest::getId() { return m_Id.query();}
IConstWsDeployReqInfo & CSaveEnvironmentForCloudRequest::getReqInfo() { return (IConstWsDeployReqInfo &) m_ReqInfo.getValue();}
void CSaveEnvironmentForCloudRequest::setIp(const char * val){ m_Ip.set(val); }
void CSaveEnvironmentForCloudRequest::setUserName(const char * val){ m_UserName.set(val); }
void CSaveEnvironmentForCloudRequest::setNewEnv(const char * val){ m_NewEnv.set(val); }
void CSaveEnvironmentForCloudRequest::setId(const char * val){ m_Id.set(val); }
IEspWsDeployReqInfo & CSaveEnvironmentForCloudRequest::updateReqInfo(){ return (IEspWsDeployReqInfo &) m_ReqInfo.getValue(); }
void CSaveEnvironmentForCloudRequest::setReqInfo(IConstWsDeployReqInfo &ifrom){ m_ReqInfo.copy(ifrom); }
extern "C"  IEspSaveEnvironmentForCloudRequest *createSaveEnvironmentForCloudRequest(const char *serv){return ((IEspSaveEnvironmentForCloudRequest *)new CSaveEnvironmentForCloudRequest(serv));}
extern "C"  IClientSaveEnvironmentForCloudRequest *createClientSaveEnvironmentForCloudRequest(const char *serv){return ((IClientSaveEnvironmentForCloudRequest *)new CSaveEnvironmentForCloudRequest(serv));}

//=======================================================
// class CSaveEnvironmentForCloudResponse Implementation
//=======================================================

CSaveEnvironmentForCloudResponse::CSaveEnvironmentForCloudResponse(const char *serviceName, IRpcMessageBinding *init)
	: m_Msg(nilIgnore),m_ReturnCode(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("SaveEnvironmentForCloudResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CSaveEnvironmentForCloudResponse::CSaveEnvironmentForCloudResponse(const char *serviceName, const char *bc)
	: m_Msg(nilIgnore),m_ReturnCode(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("SaveEnvironmentForCloudResponse");
}

CSaveEnvironmentForCloudResponse::CSaveEnvironmentForCloudResponse(const char *serviceName, IRpcMessage* rpcmsg)
	: m_Msg(nilIgnore),m_ReturnCode(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("SaveEnvironmentForCloudResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CSaveEnvironmentForCloudResponse::CSaveEnvironmentForCloudResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_Msg(nilIgnore),m_ReturnCode(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("SaveEnvironmentForCloudResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CSaveEnvironmentForCloudResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		schema.append("<xsd:element name=\"Exceptions\" type=\"tns:ArrayOfEspException\" minOccurs=\"0\" maxOccurs=\"1\"/>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Msg\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"ReturnCode\" type=\"xsd:int\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CSaveEnvironmentForCloudResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CSaveEnvironmentForCloudResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CSaveEnvironmentForCloudResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Msg");
	form.appendf("  <tr><td><b>Msg: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix) extfix.append(prefix).append(".");
		extfix.append("ReturnCode");
	form.appendf("  <tr><td><b>ReturnCode: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CSaveEnvironmentForCloudResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CSaveEnvironmentForCloudResponse::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	rpc_resp.setEncodeXml(false);
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
		m_Msg.marshall(rpc_resp, "Msg", "", "", "");
		m_ReturnCode.marshall(rpc_resp, "ReturnCode", "", "", "");
	}
}


void CSaveEnvironmentForCloudResponse::copy(CSaveEnvironmentForCloudResponse &from)
{
	m_Msg.copy(from.m_Msg);
	m_ReturnCode.copy(from.m_ReturnCode);
}


void CSaveEnvironmentForCloudResponse::copy(IConstSaveEnvironmentForCloudResponse &ifrom)
{
	setMsg(ifrom.getMsg());
	setReturnCode(ifrom.getReturnCode());
}


void CSaveEnvironmentForCloudResponse::getAttributes(IProperties &attributes)
{
}


void CSaveEnvironmentForCloudResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
		m_Msg.toStr(ctx, buffer, "Msg", "", false, "", "");
		m_ReturnCode.toStr(ctx, buffer, "ReturnCode", "", false, "", "");
	}
}


void CSaveEnvironmentForCloudResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CSaveEnvironmentForCloudResponse::serializer(IEspContext* ctx, IConstSaveEnvironmentForCloudResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<SaveEnvironmentForCloudResponse>");
	// field Msg
	{
		const char* s = src.getMsg();
		if (s && *s)
		buffer.appendf("<Msg>%s</Msg>",s);
	}
	// field ReturnCode
	{
		int n = src.getReturnCode();
		if (n)
			buffer.appendf("<ReturnCode>%d</ReturnCode>", n);
	}
	if (keepRootTag)
		buffer.append("</SaveEnvironmentForCloudResponse>");
}

bool CSaveEnvironmentForCloudResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
		hasValue |= m_Msg.unmarshall(rpc_request, "Msg", basepath);
		hasValue |= m_ReturnCode.unmarshall(rpc_request, "ReturnCode", basepath);
	}
	return hasValue;
}

bool CSaveEnvironmentForCloudResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Msg.unmarshall(ctx, soapval, "Msg");
	hasValue |= m_ReturnCode.unmarshall(ctx, soapval, "ReturnCode");
	return hasValue;
}

bool CSaveEnvironmentForCloudResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Msg.unmarshall(ctx, params, attachments, "Msg", basepath);
	hasValue |= m_ReturnCode.unmarshall(ctx, params, attachments, "ReturnCode", basepath);
	return hasValue;
}

const char * CSaveEnvironmentForCloudResponse::getMsg() { return m_Msg.query();}
int CSaveEnvironmentForCloudResponse::getReturnCode() { return m_ReturnCode;}
void CSaveEnvironmentForCloudResponse::setMsg(const char * val){ m_Msg.set(val); }
void CSaveEnvironmentForCloudResponse::setReturnCode(int val){ m_ReturnCode=val; }
extern "C"  IEspSaveEnvironmentForCloudResponse *createSaveEnvironmentForCloudResponse(const char *serv){return ((IEspSaveEnvironmentForCloudResponse *)new CSaveEnvironmentForCloudResponse(serv));}
extern "C"  IClientSaveEnvironmentForCloudResponse *createClientSaveEnvironmentForCloudResponse(const char *serv){return ((IClientSaveEnvironmentForCloudResponse *)new CSaveEnvironmentForCloudResponse(serv));}

//=======================================================
// class CRollbackEnvironmentForCloudRequest Implementation
//=======================================================

CRollbackEnvironmentForCloudRequest::CRollbackEnvironmentForCloudRequest(const char *serviceName, IRpcMessageBinding *init)
	: m_Ip(nilIgnore),m_UserName(nilIgnore),m_Id(nilIgnore),m_ReqInfo(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("RollbackEnvironmentForCloudRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CRollbackEnvironmentForCloudRequest::CRollbackEnvironmentForCloudRequest(const char *serviceName, const char *bc)
	: m_Ip(nilIgnore),m_UserName(nilIgnore),m_Id(nilIgnore),m_ReqInfo(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("RollbackEnvironmentForCloudRequest");
}

CRollbackEnvironmentForCloudRequest::CRollbackEnvironmentForCloudRequest(const char *serviceName, IRpcMessage* rpcmsg)
	: m_Ip(nilIgnore),m_UserName(nilIgnore),m_Id(nilIgnore),m_ReqInfo(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("RollbackEnvironmentForCloudRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CRollbackEnvironmentForCloudRequest::CRollbackEnvironmentForCloudRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_Ip(nilIgnore),m_UserName(nilIgnore),m_Id(nilIgnore),m_ReqInfo(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("RollbackEnvironmentForCloudRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CRollbackEnvironmentForCloudRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Ip\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"UserName\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Id\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"ReqInfo\" type=\"tns:WsDeployReqInfo\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	if (!(flags & 0x10)  || (flags & 0x100))
	{
		CWsDeployReqInfo::getXsdDefinition(context, request, schema, added);
	}
	return schema;
}

void CRollbackEnvironmentForCloudRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CRollbackEnvironmentForCloudRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
	if (!added.getValue("WsDeployReqInfo"))
	{
		added.setValue("WsDeployReqInfo",1);
		CWsDeployReqInfo::getMapInfo(info,added);
	}
}

StringBuffer &CRollbackEnvironmentForCloudRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Ip");
	form.appendf("  <tr><td><b>Ip: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("UserName");
	form.appendf("  <tr><td><b>UserName: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Id");
	form.appendf("  <tr><td><b>Id: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("ReqInfo");
	form.append("<tr>").append("<td><b>ReqInfo: </b></td><td><hr/>");
	CWsDeployReqInfo::getHtmlForm(context, request, serv, method, form, false, extfix.str());
	form.append("<hr/></td></tr>");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CRollbackEnvironmentForCloudRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CRollbackEnvironmentForCloudRequest::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_Ip.marshall(rpc_resp, "Ip", "", "", "");
	m_UserName.marshall(rpc_resp, "UserName", "", "", "");
	m_Id.marshall(rpc_resp, "Id", "", "", "");
	m_ReqInfo.marshall(rpc_resp, "ReqInfo", "", "", "");
}


void CRollbackEnvironmentForCloudRequest::copy(CRollbackEnvironmentForCloudRequest &from)
{
	m_Ip.copy(from.m_Ip);
	m_UserName.copy(from.m_UserName);
	m_Id.copy(from.m_Id);
	m_ReqInfo.copy(from.m_ReqInfo);
}


void CRollbackEnvironmentForCloudRequest::copy(IConstRollbackEnvironmentForCloudRequest &ifrom)
{
	setIp(ifrom.getIp());
	setUserName(ifrom.getUserName());
	setId(ifrom.getId());
	setReqInfo(ifrom.getReqInfo());
}


void CRollbackEnvironmentForCloudRequest::getAttributes(IProperties &attributes)
{
}


void CRollbackEnvironmentForCloudRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_Ip.toStr(ctx, buffer, "Ip", "", true, "", "");
	m_UserName.toStr(ctx, buffer, "UserName", "", true, "", "");
	m_Id.toStr(ctx, buffer, "Id", "", true, "", "");
	m_ReqInfo.toStr(ctx, buffer, "ReqInfo", "", false, "", "");
}


void CRollbackEnvironmentForCloudRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CRollbackEnvironmentForCloudRequest::serializer(IEspContext* ctx, IConstRollbackEnvironmentForCloudRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<RollbackEnvironmentForCloudRequest>");
	// field Ip
	{
		const char* s = src.getIp();
		if (s && *s)
		{
			buffer.append("<Ip>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Ip>");
		}
	}
	// field UserName
	{
		const char* s = src.getUserName();
		if (s && *s)
		{
			buffer.append("<UserName>");
			encodeUtf8XML(s,buffer);
			buffer.append("</UserName>");
		}
	}
	// field Id
	{
		const char* s = src.getId();
		if (s && *s)
		{
			buffer.append("<Id>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Id>");
		}
	}
	// field ReqInfo
	{
		StringBuffer tmp;
		CWsDeployReqInfo::serializer(ctx,src.getReqInfo(), tmp, false);
		if (tmp.length()>0)
			buffer.appendf("<ReqInfo>%s</ReqInfo>",tmp.str());
	}
	if (keepRootTag)
		buffer.append("</RollbackEnvironmentForCloudRequest>");
}

bool CRollbackEnvironmentForCloudRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_Ip.unmarshall(rpc_request, "Ip", basepath);
	hasValue |= m_UserName.unmarshall(rpc_request, "UserName", basepath);
	hasValue |= m_Id.unmarshall(rpc_request, "Id", basepath);
	hasValue |= m_ReqInfo.unmarshall(rpc_request, "ReqInfo", basepath);
	return hasValue;
}

bool CRollbackEnvironmentForCloudRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Ip.unmarshall(ctx, soapval, "Ip");
	hasValue |= m_UserName.unmarshall(ctx, soapval, "UserName");
	hasValue |= m_Id.unmarshall(ctx, soapval, "Id");
	hasValue |= m_ReqInfo.unmarshall(ctx, soapval, "ReqInfo");
	return hasValue;
}

bool CRollbackEnvironmentForCloudRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Ip.unmarshall(ctx, params, attachments, "Ip", basepath);
	hasValue |= m_UserName.unmarshall(ctx, params, attachments, "UserName", basepath);
	hasValue |= m_Id.unmarshall(ctx, params, attachments, "Id", basepath);
	hasValue |= m_ReqInfo.unmarshall(ctx, params, attachments, "ReqInfo", basepath);
	return hasValue;
}

const char * CRollbackEnvironmentForCloudRequest::getIp() { return m_Ip.query();}
const char * CRollbackEnvironmentForCloudRequest::getUserName() { return m_UserName.query();}
const char * CRollbackEnvironmentForCloudRequest::getId() { return m_Id.query();}
IConstWsDeployReqInfo & CRollbackEnvironmentForCloudRequest::getReqInfo() { return (IConstWsDeployReqInfo &) m_ReqInfo.getValue();}
void CRollbackEnvironmentForCloudRequest::setIp(const char * val){ m_Ip.set(val); }
void CRollbackEnvironmentForCloudRequest::setUserName(const char * val){ m_UserName.set(val); }
void CRollbackEnvironmentForCloudRequest::setId(const char * val){ m_Id.set(val); }
IEspWsDeployReqInfo & CRollbackEnvironmentForCloudRequest::updateReqInfo(){ return (IEspWsDeployReqInfo &) m_ReqInfo.getValue(); }
void CRollbackEnvironmentForCloudRequest::setReqInfo(IConstWsDeployReqInfo &ifrom){ m_ReqInfo.copy(ifrom); }
extern "C"  IEspRollbackEnvironmentForCloudRequest *createRollbackEnvironmentForCloudRequest(const char *serv){return ((IEspRollbackEnvironmentForCloudRequest *)new CRollbackEnvironmentForCloudRequest(serv));}
extern "C"  IClientRollbackEnvironmentForCloudRequest *createClientRollbackEnvironmentForCloudRequest(const char *serv){return ((IClientRollbackEnvironmentForCloudRequest *)new CRollbackEnvironmentForCloudRequest(serv));}

//=======================================================
// class CRollbackEnvironmentForCloudResponse Implementation
//=======================================================

CRollbackEnvironmentForCloudResponse::CRollbackEnvironmentForCloudResponse(const char *serviceName, IRpcMessageBinding *init)
	: m_Msg(nilIgnore),m_ReturnCode(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("RollbackEnvironmentForCloudResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CRollbackEnvironmentForCloudResponse::CRollbackEnvironmentForCloudResponse(const char *serviceName, const char *bc)
	: m_Msg(nilIgnore),m_ReturnCode(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("RollbackEnvironmentForCloudResponse");
}

CRollbackEnvironmentForCloudResponse::CRollbackEnvironmentForCloudResponse(const char *serviceName, IRpcMessage* rpcmsg)
	: m_Msg(nilIgnore),m_ReturnCode(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("RollbackEnvironmentForCloudResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CRollbackEnvironmentForCloudResponse::CRollbackEnvironmentForCloudResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_Msg(nilIgnore),m_ReturnCode(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("RollbackEnvironmentForCloudResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CRollbackEnvironmentForCloudResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		schema.append("<xsd:element name=\"Exceptions\" type=\"tns:ArrayOfEspException\" minOccurs=\"0\" maxOccurs=\"1\"/>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Msg\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"ReturnCode\" type=\"xsd:int\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CRollbackEnvironmentForCloudResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CRollbackEnvironmentForCloudResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CRollbackEnvironmentForCloudResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Msg");
	form.appendf("  <tr><td><b>Msg: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix) extfix.append(prefix).append(".");
		extfix.append("ReturnCode");
	form.appendf("  <tr><td><b>ReturnCode: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CRollbackEnvironmentForCloudResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CRollbackEnvironmentForCloudResponse::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	rpc_resp.setEncodeXml(false);
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
		m_Msg.marshall(rpc_resp, "Msg", "", "", "");
		m_ReturnCode.marshall(rpc_resp, "ReturnCode", "", "", "");
	}
}


void CRollbackEnvironmentForCloudResponse::copy(CRollbackEnvironmentForCloudResponse &from)
{
	m_Msg.copy(from.m_Msg);
	m_ReturnCode.copy(from.m_ReturnCode);
}


void CRollbackEnvironmentForCloudResponse::copy(IConstRollbackEnvironmentForCloudResponse &ifrom)
{
	setMsg(ifrom.getMsg());
	setReturnCode(ifrom.getReturnCode());
}


void CRollbackEnvironmentForCloudResponse::getAttributes(IProperties &attributes)
{
}


void CRollbackEnvironmentForCloudResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
		m_Msg.toStr(ctx, buffer, "Msg", "", false, "", "");
		m_ReturnCode.toStr(ctx, buffer, "ReturnCode", "", false, "", "");
	}
}


void CRollbackEnvironmentForCloudResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CRollbackEnvironmentForCloudResponse::serializer(IEspContext* ctx, IConstRollbackEnvironmentForCloudResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<RollbackEnvironmentForCloudResponse>");
	// field Msg
	{
		const char* s = src.getMsg();
		if (s && *s)
		buffer.appendf("<Msg>%s</Msg>",s);
	}
	// field ReturnCode
	{
		int n = src.getReturnCode();
		if (n)
			buffer.appendf("<ReturnCode>%d</ReturnCode>", n);
	}
	if (keepRootTag)
		buffer.append("</RollbackEnvironmentForCloudResponse>");
}

bool CRollbackEnvironmentForCloudResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
		hasValue |= m_Msg.unmarshall(rpc_request, "Msg", basepath);
		hasValue |= m_ReturnCode.unmarshall(rpc_request, "ReturnCode", basepath);
	}
	return hasValue;
}

bool CRollbackEnvironmentForCloudResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Msg.unmarshall(ctx, soapval, "Msg");
	hasValue |= m_ReturnCode.unmarshall(ctx, soapval, "ReturnCode");
	return hasValue;
}

bool CRollbackEnvironmentForCloudResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Msg.unmarshall(ctx, params, attachments, "Msg", basepath);
	hasValue |= m_ReturnCode.unmarshall(ctx, params, attachments, "ReturnCode", basepath);
	return hasValue;
}

const char * CRollbackEnvironmentForCloudResponse::getMsg() { return m_Msg.query();}
int CRollbackEnvironmentForCloudResponse::getReturnCode() { return m_ReturnCode;}
void CRollbackEnvironmentForCloudResponse::setMsg(const char * val){ m_Msg.set(val); }
void CRollbackEnvironmentForCloudResponse::setReturnCode(int val){ m_ReturnCode=val; }
extern "C"  IEspRollbackEnvironmentForCloudResponse *createRollbackEnvironmentForCloudResponse(const char *serv){return ((IEspRollbackEnvironmentForCloudResponse *)new CRollbackEnvironmentForCloudResponse(serv));}
extern "C"  IClientRollbackEnvironmentForCloudResponse *createClientRollbackEnvironmentForCloudResponse(const char *serv){return ((IClientRollbackEnvironmentForCloudResponse *)new CRollbackEnvironmentForCloudResponse(serv));}

//=======================================================
// class CNotifyInitSystemSaveEnvForCloudRequest Implementation
//=======================================================

CNotifyInitSystemSaveEnvForCloudRequest::CNotifyInitSystemSaveEnvForCloudRequest(const char *serviceName, IRpcMessageBinding *init)
	: m_Ip(nilIgnore),m_UserName(nilIgnore),m_ReqInfo(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("NotifyInitSystemSaveEnvForCloudRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CNotifyInitSystemSaveEnvForCloudRequest::CNotifyInitSystemSaveEnvForCloudRequest(const char *serviceName, const char *bc)
	: m_Ip(nilIgnore),m_UserName(nilIgnore),m_ReqInfo(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("NotifyInitSystemSaveEnvForCloudRequest");
}

CNotifyInitSystemSaveEnvForCloudRequest::CNotifyInitSystemSaveEnvForCloudRequest(const char *serviceName, IRpcMessage* rpcmsg)
	: m_Ip(nilIgnore),m_UserName(nilIgnore),m_ReqInfo(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("NotifyInitSystemSaveEnvForCloudRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CNotifyInitSystemSaveEnvForCloudRequest::CNotifyInitSystemSaveEnvForCloudRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_Ip(nilIgnore),m_UserName(nilIgnore),m_ReqInfo(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("NotifyInitSystemSaveEnvForCloudRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CNotifyInitSystemSaveEnvForCloudRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Ip\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"UserName\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"ReqInfo\" type=\"tns:WsDeployReqInfo\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	if (!(flags & 0x10)  || (flags & 0x100))
	{
		CWsDeployReqInfo::getXsdDefinition(context, request, schema, added);
	}
	return schema;
}

void CNotifyInitSystemSaveEnvForCloudRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CNotifyInitSystemSaveEnvForCloudRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
	if (!added.getValue("WsDeployReqInfo"))
	{
		added.setValue("WsDeployReqInfo",1);
		CWsDeployReqInfo::getMapInfo(info,added);
	}
}

StringBuffer &CNotifyInitSystemSaveEnvForCloudRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Ip");
	form.appendf("  <tr><td><b>Ip: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("UserName");
	form.appendf("  <tr><td><b>UserName: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("ReqInfo");
	form.append("<tr>").append("<td><b>ReqInfo: </b></td><td><hr/>");
	CWsDeployReqInfo::getHtmlForm(context, request, serv, method, form, false, extfix.str());
	form.append("<hr/></td></tr>");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CNotifyInitSystemSaveEnvForCloudRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CNotifyInitSystemSaveEnvForCloudRequest::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_Ip.marshall(rpc_resp, "Ip", "", "", "");
	m_UserName.marshall(rpc_resp, "UserName", "", "", "");
	m_ReqInfo.marshall(rpc_resp, "ReqInfo", "", "", "");
}


void CNotifyInitSystemSaveEnvForCloudRequest::copy(CNotifyInitSystemSaveEnvForCloudRequest &from)
{
	m_Ip.copy(from.m_Ip);
	m_UserName.copy(from.m_UserName);
	m_ReqInfo.copy(from.m_ReqInfo);
}


void CNotifyInitSystemSaveEnvForCloudRequest::copy(IConstNotifyInitSystemSaveEnvForCloudRequest &ifrom)
{
	setIp(ifrom.getIp());
	setUserName(ifrom.getUserName());
	setReqInfo(ifrom.getReqInfo());
}


void CNotifyInitSystemSaveEnvForCloudRequest::getAttributes(IProperties &attributes)
{
}


void CNotifyInitSystemSaveEnvForCloudRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_Ip.toStr(ctx, buffer, "Ip", "", true, "", "");
	m_UserName.toStr(ctx, buffer, "UserName", "", true, "", "");
	m_ReqInfo.toStr(ctx, buffer, "ReqInfo", "", false, "", "");
}


void CNotifyInitSystemSaveEnvForCloudRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CNotifyInitSystemSaveEnvForCloudRequest::serializer(IEspContext* ctx, IConstNotifyInitSystemSaveEnvForCloudRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<NotifyInitSystemSaveEnvForCloudRequest>");
	// field Ip
	{
		const char* s = src.getIp();
		if (s && *s)
		{
			buffer.append("<Ip>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Ip>");
		}
	}
	// field UserName
	{
		const char* s = src.getUserName();
		if (s && *s)
		{
			buffer.append("<UserName>");
			encodeUtf8XML(s,buffer);
			buffer.append("</UserName>");
		}
	}
	// field ReqInfo
	{
		StringBuffer tmp;
		CWsDeployReqInfo::serializer(ctx,src.getReqInfo(), tmp, false);
		if (tmp.length()>0)
			buffer.appendf("<ReqInfo>%s</ReqInfo>",tmp.str());
	}
	if (keepRootTag)
		buffer.append("</NotifyInitSystemSaveEnvForCloudRequest>");
}

bool CNotifyInitSystemSaveEnvForCloudRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_Ip.unmarshall(rpc_request, "Ip", basepath);
	hasValue |= m_UserName.unmarshall(rpc_request, "UserName", basepath);
	hasValue |= m_ReqInfo.unmarshall(rpc_request, "ReqInfo", basepath);
	return hasValue;
}

bool CNotifyInitSystemSaveEnvForCloudRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Ip.unmarshall(ctx, soapval, "Ip");
	hasValue |= m_UserName.unmarshall(ctx, soapval, "UserName");
	hasValue |= m_ReqInfo.unmarshall(ctx, soapval, "ReqInfo");
	return hasValue;
}

bool CNotifyInitSystemSaveEnvForCloudRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Ip.unmarshall(ctx, params, attachments, "Ip", basepath);
	hasValue |= m_UserName.unmarshall(ctx, params, attachments, "UserName", basepath);
	hasValue |= m_ReqInfo.unmarshall(ctx, params, attachments, "ReqInfo", basepath);
	return hasValue;
}

const char * CNotifyInitSystemSaveEnvForCloudRequest::getIp() { return m_Ip.query();}
const char * CNotifyInitSystemSaveEnvForCloudRequest::getUserName() { return m_UserName.query();}
IConstWsDeployReqInfo & CNotifyInitSystemSaveEnvForCloudRequest::getReqInfo() { return (IConstWsDeployReqInfo &) m_ReqInfo.getValue();}
void CNotifyInitSystemSaveEnvForCloudRequest::setIp(const char * val){ m_Ip.set(val); }
void CNotifyInitSystemSaveEnvForCloudRequest::setUserName(const char * val){ m_UserName.set(val); }
IEspWsDeployReqInfo & CNotifyInitSystemSaveEnvForCloudRequest::updateReqInfo(){ return (IEspWsDeployReqInfo &) m_ReqInfo.getValue(); }
void CNotifyInitSystemSaveEnvForCloudRequest::setReqInfo(IConstWsDeployReqInfo &ifrom){ m_ReqInfo.copy(ifrom); }
extern "C"  IEspNotifyInitSystemSaveEnvForCloudRequest *createNotifyInitSystemSaveEnvForCloudRequest(const char *serv){return ((IEspNotifyInitSystemSaveEnvForCloudRequest *)new CNotifyInitSystemSaveEnvForCloudRequest(serv));}
extern "C"  IClientNotifyInitSystemSaveEnvForCloudRequest *createClientNotifyInitSystemSaveEnvForCloudRequest(const char *serv){return ((IClientNotifyInitSystemSaveEnvForCloudRequest *)new CNotifyInitSystemSaveEnvForCloudRequest(serv));}

//=======================================================
// class CNotifyInitSystemSaveEnvForCloudResponse Implementation
//=======================================================

CNotifyInitSystemSaveEnvForCloudResponse::CNotifyInitSystemSaveEnvForCloudResponse(const char *serviceName, IRpcMessageBinding *init)
	: m_Msg(nilIgnore),m_ReturnCode(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("NotifyInitSystemSaveEnvForCloudResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CNotifyInitSystemSaveEnvForCloudResponse::CNotifyInitSystemSaveEnvForCloudResponse(const char *serviceName, const char *bc)
	: m_Msg(nilIgnore),m_ReturnCode(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("NotifyInitSystemSaveEnvForCloudResponse");
}

CNotifyInitSystemSaveEnvForCloudResponse::CNotifyInitSystemSaveEnvForCloudResponse(const char *serviceName, IRpcMessage* rpcmsg)
	: m_Msg(nilIgnore),m_ReturnCode(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("NotifyInitSystemSaveEnvForCloudResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CNotifyInitSystemSaveEnvForCloudResponse::CNotifyInitSystemSaveEnvForCloudResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_Msg(nilIgnore),m_ReturnCode(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("NotifyInitSystemSaveEnvForCloudResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CNotifyInitSystemSaveEnvForCloudResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		schema.append("<xsd:element name=\"Exceptions\" type=\"tns:ArrayOfEspException\" minOccurs=\"0\" maxOccurs=\"1\"/>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Msg\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"ReturnCode\" type=\"xsd:int\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CNotifyInitSystemSaveEnvForCloudResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CNotifyInitSystemSaveEnvForCloudResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CNotifyInitSystemSaveEnvForCloudResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Msg");
	form.appendf("  <tr><td><b>Msg: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix) extfix.append(prefix).append(".");
		extfix.append("ReturnCode");
	form.appendf("  <tr><td><b>ReturnCode: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CNotifyInitSystemSaveEnvForCloudResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CNotifyInitSystemSaveEnvForCloudResponse::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	rpc_resp.setEncodeXml(false);
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
		m_Msg.marshall(rpc_resp, "Msg", "", "", "");
		m_ReturnCode.marshall(rpc_resp, "ReturnCode", "", "", "");
	}
}


void CNotifyInitSystemSaveEnvForCloudResponse::copy(CNotifyInitSystemSaveEnvForCloudResponse &from)
{
	m_Msg.copy(from.m_Msg);
	m_ReturnCode.copy(from.m_ReturnCode);
}


void CNotifyInitSystemSaveEnvForCloudResponse::copy(IConstNotifyInitSystemSaveEnvForCloudResponse &ifrom)
{
	setMsg(ifrom.getMsg());
	setReturnCode(ifrom.getReturnCode());
}


void CNotifyInitSystemSaveEnvForCloudResponse::getAttributes(IProperties &attributes)
{
}


void CNotifyInitSystemSaveEnvForCloudResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
		m_Msg.toStr(ctx, buffer, "Msg", "", false, "", "");
		m_ReturnCode.toStr(ctx, buffer, "ReturnCode", "", false, "", "");
	}
}


void CNotifyInitSystemSaveEnvForCloudResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CNotifyInitSystemSaveEnvForCloudResponse::serializer(IEspContext* ctx, IConstNotifyInitSystemSaveEnvForCloudResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<NotifyInitSystemSaveEnvForCloudResponse>");
	// field Msg
	{
		const char* s = src.getMsg();
		if (s && *s)
		buffer.appendf("<Msg>%s</Msg>",s);
	}
	// field ReturnCode
	{
		int n = src.getReturnCode();
		if (n)
			buffer.appendf("<ReturnCode>%d</ReturnCode>", n);
	}
	if (keepRootTag)
		buffer.append("</NotifyInitSystemSaveEnvForCloudResponse>");
}

bool CNotifyInitSystemSaveEnvForCloudResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
		hasValue |= m_Msg.unmarshall(rpc_request, "Msg", basepath);
		hasValue |= m_ReturnCode.unmarshall(rpc_request, "ReturnCode", basepath);
	}
	return hasValue;
}

bool CNotifyInitSystemSaveEnvForCloudResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Msg.unmarshall(ctx, soapval, "Msg");
	hasValue |= m_ReturnCode.unmarshall(ctx, soapval, "ReturnCode");
	return hasValue;
}

bool CNotifyInitSystemSaveEnvForCloudResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Msg.unmarshall(ctx, params, attachments, "Msg", basepath);
	hasValue |= m_ReturnCode.unmarshall(ctx, params, attachments, "ReturnCode", basepath);
	return hasValue;
}

const char * CNotifyInitSystemSaveEnvForCloudResponse::getMsg() { return m_Msg.query();}
int CNotifyInitSystemSaveEnvForCloudResponse::getReturnCode() { return m_ReturnCode;}
void CNotifyInitSystemSaveEnvForCloudResponse::setMsg(const char * val){ m_Msg.set(val); }
void CNotifyInitSystemSaveEnvForCloudResponse::setReturnCode(int val){ m_ReturnCode=val; }
extern "C"  IEspNotifyInitSystemSaveEnvForCloudResponse *createNotifyInitSystemSaveEnvForCloudResponse(const char *serv){return ((IEspNotifyInitSystemSaveEnvForCloudResponse *)new CNotifyInitSystemSaveEnvForCloudResponse(serv));}
extern "C"  IClientNotifyInitSystemSaveEnvForCloudResponse *createClientNotifyInitSystemSaveEnvForCloudResponse(const char *serv){return ((IClientNotifyInitSystemSaveEnvForCloudResponse *)new CNotifyInitSystemSaveEnvForCloudResponse(serv));}

//=======================================================
// class CBuildEnvironmentRequest Implementation
//=======================================================

CBuildEnvironmentRequest::CBuildEnvironmentRequest(const char *serviceName, IRpcMessageBinding *init)
	: m_XmlArgs(nilIgnore),m_ReqInfo(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("BuildEnvironmentRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CBuildEnvironmentRequest::CBuildEnvironmentRequest(const char *serviceName, const char *bc)
	: m_XmlArgs(nilIgnore),m_ReqInfo(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("BuildEnvironmentRequest");
}

CBuildEnvironmentRequest::CBuildEnvironmentRequest(const char *serviceName, IRpcMessage* rpcmsg)
	: m_XmlArgs(nilIgnore),m_ReqInfo(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("BuildEnvironmentRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CBuildEnvironmentRequest::CBuildEnvironmentRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_XmlArgs(nilIgnore),m_ReqInfo(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("BuildEnvironmentRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CBuildEnvironmentRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"XmlArgs\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"ReqInfo\" type=\"tns:WsDeployReqInfo\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	if (!(flags & 0x10)  || (flags & 0x100))
	{
		CWsDeployReqInfo::getXsdDefinition(context, request, schema, added);
	}
	return schema;
}

void CBuildEnvironmentRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CBuildEnvironmentRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
	if (!added.getValue("WsDeployReqInfo"))
	{
		added.setValue("WsDeployReqInfo",1);
		CWsDeployReqInfo::getMapInfo(info,added);
	}
}

StringBuffer &CBuildEnvironmentRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("XmlArgs");
	form.appendf("  <tr><td><b>XmlArgs: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("ReqInfo");
	form.append("<tr>").append("<td><b>ReqInfo: </b></td><td><hr/>");
	CWsDeployReqInfo::getHtmlForm(context, request, serv, method, form, false, extfix.str());
	form.append("<hr/></td></tr>");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CBuildEnvironmentRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CBuildEnvironmentRequest::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_XmlArgs.marshall(rpc_resp, "XmlArgs", "", "", "");
	m_ReqInfo.marshall(rpc_resp, "ReqInfo", "", "", "");
}


void CBuildEnvironmentRequest::copy(CBuildEnvironmentRequest &from)
{
	m_XmlArgs.copy(from.m_XmlArgs);
	m_ReqInfo.copy(from.m_ReqInfo);
}


void CBuildEnvironmentRequest::copy(IConstBuildEnvironmentRequest &ifrom)
{
	setXmlArgs(ifrom.getXmlArgs());
	setReqInfo(ifrom.getReqInfo());
}


void CBuildEnvironmentRequest::getAttributes(IProperties &attributes)
{
}


void CBuildEnvironmentRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_XmlArgs.toStr(ctx, buffer, "XmlArgs", "", true, "", "");
	m_ReqInfo.toStr(ctx, buffer, "ReqInfo", "", false, "", "");
}


void CBuildEnvironmentRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CBuildEnvironmentRequest::serializer(IEspContext* ctx, IConstBuildEnvironmentRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<BuildEnvironmentRequest>");
	// field XmlArgs
	{
		const char* s = src.getXmlArgs();
		if (s && *s)
		{
			buffer.append("<XmlArgs>");
			encodeUtf8XML(s,buffer);
			buffer.append("</XmlArgs>");
		}
	}
	// field ReqInfo
	{
		StringBuffer tmp;
		CWsDeployReqInfo::serializer(ctx,src.getReqInfo(), tmp, false);
		if (tmp.length()>0)
			buffer.appendf("<ReqInfo>%s</ReqInfo>",tmp.str());
	}
	if (keepRootTag)
		buffer.append("</BuildEnvironmentRequest>");
}

bool CBuildEnvironmentRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_XmlArgs.unmarshall(rpc_request, "XmlArgs", basepath);
	hasValue |= m_ReqInfo.unmarshall(rpc_request, "ReqInfo", basepath);
	return hasValue;
}

bool CBuildEnvironmentRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_XmlArgs.unmarshall(ctx, soapval, "XmlArgs");
	hasValue |= m_ReqInfo.unmarshall(ctx, soapval, "ReqInfo");
	return hasValue;
}

bool CBuildEnvironmentRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_XmlArgs.unmarshall(ctx, params, attachments, "XmlArgs", basepath);
	hasValue |= m_ReqInfo.unmarshall(ctx, params, attachments, "ReqInfo", basepath);
	return hasValue;
}

const char * CBuildEnvironmentRequest::getXmlArgs() { return m_XmlArgs.query();}
IConstWsDeployReqInfo & CBuildEnvironmentRequest::getReqInfo() { return (IConstWsDeployReqInfo &) m_ReqInfo.getValue();}
void CBuildEnvironmentRequest::setXmlArgs(const char * val){ m_XmlArgs.set(val); }
IEspWsDeployReqInfo & CBuildEnvironmentRequest::updateReqInfo(){ return (IEspWsDeployReqInfo &) m_ReqInfo.getValue(); }
void CBuildEnvironmentRequest::setReqInfo(IConstWsDeployReqInfo &ifrom){ m_ReqInfo.copy(ifrom); }
extern "C"  IEspBuildEnvironmentRequest *createBuildEnvironmentRequest(const char *serv){return ((IEspBuildEnvironmentRequest *)new CBuildEnvironmentRequest(serv));}
extern "C"  IClientBuildEnvironmentRequest *createClientBuildEnvironmentRequest(const char *serv){return ((IClientBuildEnvironmentRequest *)new CBuildEnvironmentRequest(serv));}

//=======================================================
// class CBuildEnvironmentResponse Implementation
//=======================================================

CBuildEnvironmentResponse::CBuildEnvironmentResponse(const char *serviceName, IRpcMessageBinding *init)
	: m_Status(nilIgnore),m_Message(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("BuildEnvironmentResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CBuildEnvironmentResponse::CBuildEnvironmentResponse(const char *serviceName, const char *bc)
	: m_Status(nilIgnore),m_Message(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("BuildEnvironmentResponse");
}

CBuildEnvironmentResponse::CBuildEnvironmentResponse(const char *serviceName, IRpcMessage* rpcmsg)
	: m_Status(nilIgnore),m_Message(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("BuildEnvironmentResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CBuildEnvironmentResponse::CBuildEnvironmentResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_Status(nilIgnore),m_Message(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("BuildEnvironmentResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CBuildEnvironmentResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		schema.append("<xsd:element name=\"Exceptions\" type=\"tns:ArrayOfEspException\" minOccurs=\"0\" maxOccurs=\"1\"/>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Status\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Message\" type=\"xsd:string\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CBuildEnvironmentResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CBuildEnvironmentResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CBuildEnvironmentResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Status");
	form.appendf("  <tr><td><b>Status: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Message");
	form.appendf("  <tr><td><b>Message: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CBuildEnvironmentResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CBuildEnvironmentResponse::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	rpc_resp.setEncodeXml(false);
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
		m_Status.marshall(rpc_resp, "Status", "", "", "");
		m_Message.marshall(rpc_resp, "Message", "", "", "");
	}
}


void CBuildEnvironmentResponse::copy(CBuildEnvironmentResponse &from)
{
	m_Status.copy(from.m_Status);
	m_Message.copy(from.m_Message);
}


void CBuildEnvironmentResponse::copy(IConstBuildEnvironmentResponse &ifrom)
{
	setStatus(ifrom.getStatus());
	setMessage(ifrom.getMessage());
}


void CBuildEnvironmentResponse::getAttributes(IProperties &attributes)
{
}


void CBuildEnvironmentResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
		m_Status.toStr(ctx, buffer, "Status", "", false, "", "");
		m_Message.toStr(ctx, buffer, "Message", "", false, "", "");
	}
}


void CBuildEnvironmentResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CBuildEnvironmentResponse::serializer(IEspContext* ctx, IConstBuildEnvironmentResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<BuildEnvironmentResponse>");
	// field Status
	{
		const char* s = src.getStatus();
		if (s && *s)
		buffer.appendf("<Status>%s</Status>",s);
	}
	// field Message
	{
		const char* s = src.getMessage();
		if (s && *s)
		buffer.appendf("<Message>%s</Message>",s);
	}
	if (keepRootTag)
		buffer.append("</BuildEnvironmentResponse>");
}

bool CBuildEnvironmentResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
		hasValue |= m_Status.unmarshall(rpc_request, "Status", basepath);
		hasValue |= m_Message.unmarshall(rpc_request, "Message", basepath);
	}
	return hasValue;
}

bool CBuildEnvironmentResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Status.unmarshall(ctx, soapval, "Status");
	hasValue |= m_Message.unmarshall(ctx, soapval, "Message");
	return hasValue;
}

bool CBuildEnvironmentResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Status.unmarshall(ctx, params, attachments, "Status", basepath);
	hasValue |= m_Message.unmarshall(ctx, params, attachments, "Message", basepath);
	return hasValue;
}

const char * CBuildEnvironmentResponse::getStatus() { return m_Status.query();}
const char * CBuildEnvironmentResponse::getMessage() { return m_Message.query();}
void CBuildEnvironmentResponse::setStatus(const char * val){ m_Status.set(val); }
void CBuildEnvironmentResponse::setMessage(const char * val){ m_Message.set(val); }
extern "C"  IEspBuildEnvironmentResponse *createBuildEnvironmentResponse(const char *serv){return ((IEspBuildEnvironmentResponse *)new CBuildEnvironmentResponse(serv));}
extern "C"  IClientBuildEnvironmentResponse *createClientBuildEnvironmentResponse(const char *serv){return ((IClientBuildEnvironmentResponse *)new CBuildEnvironmentResponse(serv));}

//=======================================================
// class CGetSubnetIPAddrRequest Implementation
//=======================================================

CGetSubnetIPAddrRequest::CGetSubnetIPAddrRequest(const char *serviceName, IRpcMessageBinding *init)
	: m_ReqInfo(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetSubnetIPAddrRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CGetSubnetIPAddrRequest::CGetSubnetIPAddrRequest(const char *serviceName, const char *bc)
	: m_ReqInfo(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetSubnetIPAddrRequest");
}

CGetSubnetIPAddrRequest::CGetSubnetIPAddrRequest(const char *serviceName, IRpcMessage* rpcmsg)
	: m_ReqInfo(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetSubnetIPAddrRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CGetSubnetIPAddrRequest::CGetSubnetIPAddrRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_ReqInfo(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetSubnetIPAddrRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CGetSubnetIPAddrRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"ReqInfo\" type=\"tns:WsDeployReqInfo\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	if (!(flags & 0x10)  || (flags & 0x100))
	{
		CWsDeployReqInfo::getXsdDefinition(context, request, schema, added);
	}
	return schema;
}

void CGetSubnetIPAddrRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CGetSubnetIPAddrRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
	if (!added.getValue("WsDeployReqInfo"))
	{
		added.setValue("WsDeployReqInfo",1);
		CWsDeployReqInfo::getMapInfo(info,added);
	}
}

StringBuffer &CGetSubnetIPAddrRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("ReqInfo");
	form.append("<tr>").append("<td><b>ReqInfo: </b></td><td><hr/>");
	CWsDeployReqInfo::getHtmlForm(context, request, serv, method, form, false, extfix.str());
	form.append("<hr/></td></tr>");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CGetSubnetIPAddrRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CGetSubnetIPAddrRequest::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_ReqInfo.marshall(rpc_resp, "ReqInfo", "", "", "");
}


void CGetSubnetIPAddrRequest::copy(CGetSubnetIPAddrRequest &from)
{
	m_ReqInfo.copy(from.m_ReqInfo);
}


void CGetSubnetIPAddrRequest::copy(IConstGetSubnetIPAddrRequest &ifrom)
{
	setReqInfo(ifrom.getReqInfo());
}


void CGetSubnetIPAddrRequest::getAttributes(IProperties &attributes)
{
}


void CGetSubnetIPAddrRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_ReqInfo.toStr(ctx, buffer, "ReqInfo", "", false, "", "");
}


void CGetSubnetIPAddrRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CGetSubnetIPAddrRequest::serializer(IEspContext* ctx, IConstGetSubnetIPAddrRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<GetSubnetIPAddrRequest>");
	// field ReqInfo
	{
		StringBuffer tmp;
		CWsDeployReqInfo::serializer(ctx,src.getReqInfo(), tmp, false);
		if (tmp.length()>0)
			buffer.appendf("<ReqInfo>%s</ReqInfo>",tmp.str());
	}
	if (keepRootTag)
		buffer.append("</GetSubnetIPAddrRequest>");
}

bool CGetSubnetIPAddrRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_ReqInfo.unmarshall(rpc_request, "ReqInfo", basepath);
	return hasValue;
}

bool CGetSubnetIPAddrRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_ReqInfo.unmarshall(ctx, soapval, "ReqInfo");
	return hasValue;
}

bool CGetSubnetIPAddrRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_ReqInfo.unmarshall(ctx, params, attachments, "ReqInfo", basepath);
	return hasValue;
}

IConstWsDeployReqInfo & CGetSubnetIPAddrRequest::getReqInfo() { return (IConstWsDeployReqInfo &) m_ReqInfo.getValue();}
IEspWsDeployReqInfo & CGetSubnetIPAddrRequest::updateReqInfo(){ return (IEspWsDeployReqInfo &) m_ReqInfo.getValue(); }
void CGetSubnetIPAddrRequest::setReqInfo(IConstWsDeployReqInfo &ifrom){ m_ReqInfo.copy(ifrom); }
extern "C"  IEspGetSubnetIPAddrRequest *createGetSubnetIPAddrRequest(const char *serv){return ((IEspGetSubnetIPAddrRequest *)new CGetSubnetIPAddrRequest(serv));}
extern "C"  IClientGetSubnetIPAddrRequest *createClientGetSubnetIPAddrRequest(const char *serv){return ((IClientGetSubnetIPAddrRequest *)new CGetSubnetIPAddrRequest(serv));}

//=======================================================
// class CGetSubnetIPAddrResponse Implementation
//=======================================================

CGetSubnetIPAddrResponse::CGetSubnetIPAddrResponse(const char *serviceName, IRpcMessageBinding *init)
	: m_IPList(nilIgnore),m_Message(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetSubnetIPAddrResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CGetSubnetIPAddrResponse::CGetSubnetIPAddrResponse(const char *serviceName, const char *bc)
	: m_IPList(nilIgnore),m_Message(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetSubnetIPAddrResponse");
}

CGetSubnetIPAddrResponse::CGetSubnetIPAddrResponse(const char *serviceName, IRpcMessage* rpcmsg)
	: m_IPList(nilIgnore),m_Message(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetSubnetIPAddrResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CGetSubnetIPAddrResponse::CGetSubnetIPAddrResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_IPList(nilIgnore),m_Message(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetSubnetIPAddrResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CGetSubnetIPAddrResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		schema.append("<xsd:element name=\"Exceptions\" type=\"tns:ArrayOfEspException\" minOccurs=\"0\" maxOccurs=\"1\"/>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"IPList\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Message\" type=\"xsd:string\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CGetSubnetIPAddrResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CGetSubnetIPAddrResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CGetSubnetIPAddrResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("IPList");
	form.appendf("  <tr><td><b>IPList: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Message");
	form.appendf("  <tr><td><b>Message: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CGetSubnetIPAddrResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CGetSubnetIPAddrResponse::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	rpc_resp.setEncodeXml(false);
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
		m_IPList.marshall(rpc_resp, "IPList", "", "", "");
		m_Message.marshall(rpc_resp, "Message", "", "", "");
	}
}


void CGetSubnetIPAddrResponse::copy(CGetSubnetIPAddrResponse &from)
{
	m_IPList.copy(from.m_IPList);
	m_Message.copy(from.m_Message);
}


void CGetSubnetIPAddrResponse::copy(IConstGetSubnetIPAddrResponse &ifrom)
{
	setIPList(ifrom.getIPList());
	setMessage(ifrom.getMessage());
}


void CGetSubnetIPAddrResponse::getAttributes(IProperties &attributes)
{
}


void CGetSubnetIPAddrResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
		m_IPList.toStr(ctx, buffer, "IPList", "", false, "", "");
		m_Message.toStr(ctx, buffer, "Message", "", false, "", "");
	}
}


void CGetSubnetIPAddrResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CGetSubnetIPAddrResponse::serializer(IEspContext* ctx, IConstGetSubnetIPAddrResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<GetSubnetIPAddrResponse>");
	// field IPList
	{
		const char* s = src.getIPList();
		if (s && *s)
		buffer.appendf("<IPList>%s</IPList>",s);
	}
	// field Message
	{
		const char* s = src.getMessage();
		if (s && *s)
		buffer.appendf("<Message>%s</Message>",s);
	}
	if (keepRootTag)
		buffer.append("</GetSubnetIPAddrResponse>");
}

bool CGetSubnetIPAddrResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
		hasValue |= m_IPList.unmarshall(rpc_request, "IPList", basepath);
		hasValue |= m_Message.unmarshall(rpc_request, "Message", basepath);
	}
	return hasValue;
}

bool CGetSubnetIPAddrResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_IPList.unmarshall(ctx, soapval, "IPList");
	hasValue |= m_Message.unmarshall(ctx, soapval, "Message");
	return hasValue;
}

bool CGetSubnetIPAddrResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_IPList.unmarshall(ctx, params, attachments, "IPList", basepath);
	hasValue |= m_Message.unmarshall(ctx, params, attachments, "Message", basepath);
	return hasValue;
}

const char * CGetSubnetIPAddrResponse::getIPList() { return m_IPList.query();}
const char * CGetSubnetIPAddrResponse::getMessage() { return m_Message.query();}
void CGetSubnetIPAddrResponse::setIPList(const char * val){ m_IPList.set(val); }
void CGetSubnetIPAddrResponse::setMessage(const char * val){ m_Message.set(val); }
extern "C"  IEspGetSubnetIPAddrResponse *createGetSubnetIPAddrResponse(const char *serv){return ((IEspGetSubnetIPAddrResponse *)new CGetSubnetIPAddrResponse(serv));}
extern "C"  IClientGetSubnetIPAddrResponse *createClientGetSubnetIPAddrResponse(const char *serv){return ((IClientGetSubnetIPAddrResponse *)new CGetSubnetIPAddrResponse(serv));}

//=======================================================
// class CGetSummaryRequest Implementation
//=======================================================

CGetSummaryRequest::CGetSummaryRequest(const char *serviceName, IRpcMessageBinding *init)
	: m_PrepareLinkFlag(nilIgnore),m_ReqInfo(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetSummaryRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CGetSummaryRequest::CGetSummaryRequest(const char *serviceName, const char *bc)
	: m_PrepareLinkFlag(nilIgnore),m_ReqInfo(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetSummaryRequest");
}

CGetSummaryRequest::CGetSummaryRequest(const char *serviceName, IRpcMessage* rpcmsg)
	: m_PrepareLinkFlag(nilIgnore),m_ReqInfo(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetSummaryRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CGetSummaryRequest::CGetSummaryRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_PrepareLinkFlag(nilIgnore),m_ReqInfo(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetSummaryRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CGetSummaryRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"PrepareLinkFlag\" type=\"xsd:boolean\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"ReqInfo\" type=\"tns:WsDeployReqInfo\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	if (!(flags & 0x10)  || (flags & 0x100))
	{
		CWsDeployReqInfo::getXsdDefinition(context, request, schema, added);
	}
	return schema;
}

void CGetSummaryRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CGetSummaryRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
	if (!added.getValue("WsDeployReqInfo"))
	{
		added.setValue("WsDeployReqInfo",1);
		CWsDeployReqInfo::getMapInfo(info,added);
	}
}

StringBuffer &CGetSummaryRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("PrepareLinkFlag");
	
	form.appendf("  <tr><td><b>PrepareLinkFlag? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("ReqInfo");
	form.append("<tr>").append("<td><b>ReqInfo: </b></td><td><hr/>");
	CWsDeployReqInfo::getHtmlForm(context, request, serv, method, form, false, extfix.str());
	form.append("<hr/></td></tr>");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CGetSummaryRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CGetSummaryRequest::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_PrepareLinkFlag.marshall(rpc_resp, "PrepareLinkFlag", "", "", "");
	m_ReqInfo.marshall(rpc_resp, "ReqInfo", "", "", "");
}


void CGetSummaryRequest::copy(CGetSummaryRequest &from)
{
	m_PrepareLinkFlag.copy(from.m_PrepareLinkFlag);
	m_ReqInfo.copy(from.m_ReqInfo);
}


void CGetSummaryRequest::copy(IConstGetSummaryRequest &ifrom)
{
	setPrepareLinkFlag(ifrom.getPrepareLinkFlag());
	setReqInfo(ifrom.getReqInfo());
}


void CGetSummaryRequest::getAttributes(IProperties &attributes)
{
}


void CGetSummaryRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_PrepareLinkFlag.toStr(ctx, buffer, "PrepareLinkFlag", "", true, "", "");
	m_ReqInfo.toStr(ctx, buffer, "ReqInfo", "", false, "", "");
}


void CGetSummaryRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CGetSummaryRequest::serializer(IEspContext* ctx, IConstGetSummaryRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<GetSummaryRequest>");
	// field PrepareLinkFlag
	{
		bool b = src.getPrepareLinkFlag();
		if (b)
			buffer.appendf("<PrepareLinkFlag>1</PrepareLinkFlag>");
	}
	// field ReqInfo
	{
		StringBuffer tmp;
		CWsDeployReqInfo::serializer(ctx,src.getReqInfo(), tmp, false);
		if (tmp.length()>0)
			buffer.appendf("<ReqInfo>%s</ReqInfo>",tmp.str());
	}
	if (keepRootTag)
		buffer.append("</GetSummaryRequest>");
}

bool CGetSummaryRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_PrepareLinkFlag.unmarshall(rpc_request, "PrepareLinkFlag", basepath);
	hasValue |= m_ReqInfo.unmarshall(rpc_request, "ReqInfo", basepath);
	return hasValue;
}

bool CGetSummaryRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_PrepareLinkFlag.unmarshall(ctx, soapval, "PrepareLinkFlag");
	hasValue |= m_ReqInfo.unmarshall(ctx, soapval, "ReqInfo");
	return hasValue;
}

bool CGetSummaryRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_PrepareLinkFlag.unmarshall(ctx, params, attachments, "PrepareLinkFlag", basepath);
	hasValue |= m_ReqInfo.unmarshall(ctx, params, attachments, "ReqInfo", basepath);
	return hasValue;
}

bool CGetSummaryRequest::getPrepareLinkFlag() { return m_PrepareLinkFlag;}
IConstWsDeployReqInfo & CGetSummaryRequest::getReqInfo() { return (IConstWsDeployReqInfo &) m_ReqInfo.getValue();}
void CGetSummaryRequest::setPrepareLinkFlag(bool val){ m_PrepareLinkFlag=val; }
IEspWsDeployReqInfo & CGetSummaryRequest::updateReqInfo(){ return (IEspWsDeployReqInfo &) m_ReqInfo.getValue(); }
void CGetSummaryRequest::setReqInfo(IConstWsDeployReqInfo &ifrom){ m_ReqInfo.copy(ifrom); }
extern "C"  IEspGetSummaryRequest *createGetSummaryRequest(const char *serv){return ((IEspGetSummaryRequest *)new CGetSummaryRequest(serv));}
extern "C"  IClientGetSummaryRequest *createClientGetSummaryRequest(const char *serv){return ((IClientGetSummaryRequest *)new CGetSummaryRequest(serv));}

//=======================================================
// class CGetSummaryResponse Implementation
//=======================================================

CGetSummaryResponse::CGetSummaryResponse(const char *serviceName, IRpcMessageBinding *init)
	: m_Status(nilIgnore),m_XmlStr(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetSummaryResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CGetSummaryResponse::CGetSummaryResponse(const char *serviceName, const char *bc)
	: m_Status(nilIgnore),m_XmlStr(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetSummaryResponse");
}

CGetSummaryResponse::CGetSummaryResponse(const char *serviceName, IRpcMessage* rpcmsg)
	: m_Status(nilIgnore),m_XmlStr(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetSummaryResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CGetSummaryResponse::CGetSummaryResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_Status(nilIgnore),m_XmlStr(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetSummaryResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CGetSummaryResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		schema.append("<xsd:element name=\"Exceptions\" type=\"tns:ArrayOfEspException\" minOccurs=\"0\" maxOccurs=\"1\"/>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Status\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"XmlStr\" type=\"xsd:string\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CGetSummaryResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CGetSummaryResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CGetSummaryResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Status");
	form.appendf("  <tr><td><b>Status: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("XmlStr");
	form.appendf("  <tr><td><b>XmlStr: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CGetSummaryResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CGetSummaryResponse::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	rpc_resp.setEncodeXml(false);
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
		m_Status.marshall(rpc_resp, "Status", "", "", "");
		m_XmlStr.marshall(rpc_resp, "XmlStr", "", "", "");
	}
}


void CGetSummaryResponse::copy(CGetSummaryResponse &from)
{
	m_Status.copy(from.m_Status);
	m_XmlStr.copy(from.m_XmlStr);
}


void CGetSummaryResponse::copy(IConstGetSummaryResponse &ifrom)
{
	setStatus(ifrom.getStatus());
	setXmlStr(ifrom.getXmlStr());
}


void CGetSummaryResponse::getAttributes(IProperties &attributes)
{
}


void CGetSummaryResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
		m_Status.toStr(ctx, buffer, "Status", "", false, "", "");
		m_XmlStr.toStr(ctx, buffer, "XmlStr", "", false, "", "");
	}
}


void CGetSummaryResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CGetSummaryResponse::serializer(IEspContext* ctx, IConstGetSummaryResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<GetSummaryResponse>");
	// field Status
	{
		const char* s = src.getStatus();
		if (s && *s)
		buffer.appendf("<Status>%s</Status>",s);
	}
	// field XmlStr
	{
		const char* s = src.getXmlStr();
		if (s && *s)
		buffer.appendf("<XmlStr>%s</XmlStr>",s);
	}
	if (keepRootTag)
		buffer.append("</GetSummaryResponse>");
}

bool CGetSummaryResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
		hasValue |= m_Status.unmarshall(rpc_request, "Status", basepath);
		hasValue |= m_XmlStr.unmarshall(rpc_request, "XmlStr", basepath);
	}
	return hasValue;
}

bool CGetSummaryResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Status.unmarshall(ctx, soapval, "Status");
	hasValue |= m_XmlStr.unmarshall(ctx, soapval, "XmlStr");
	return hasValue;
}

bool CGetSummaryResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Status.unmarshall(ctx, params, attachments, "Status", basepath);
	hasValue |= m_XmlStr.unmarshall(ctx, params, attachments, "XmlStr", basepath);
	return hasValue;
}

const char * CGetSummaryResponse::getStatus() { return m_Status.query();}
const char * CGetSummaryResponse::getXmlStr() { return m_XmlStr.query();}
void CGetSummaryResponse::setStatus(const char * val){ m_Status.set(val); }
void CGetSummaryResponse::setXmlStr(const char * val){ m_XmlStr.set(val); }
extern "C"  IEspGetSummaryResponse *createGetSummaryResponse(const char *serv){return ((IEspGetSummaryResponse *)new CGetSummaryResponse(serv));}
extern "C"  IClientGetSummaryResponse *createClientGetSummaryResponse(const char *serv){return ((IClientGetSummaryResponse *)new CGetSummaryResponse(serv));}

//=======================================================
// class CWsDeployPingRequest Implementation
//=======================================================

CWsDeployPingRequest::CWsDeployPingRequest(const char *serviceName, IRpcMessageBinding *init)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("WsDeployPingRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CWsDeployPingRequest::CWsDeployPingRequest(const char *serviceName, const char *bc)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("WsDeployPingRequest");
}

CWsDeployPingRequest::CWsDeployPingRequest(const char *serviceName, IRpcMessage* rpcmsg)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("WsDeployPingRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CWsDeployPingRequest::CWsDeployPingRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("WsDeployPingRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CWsDeployPingRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType><xsd:all/></xsd:complexType></xsd:element>\n", msgTypeName);
		}
	}
	return schema;
}

void CWsDeployPingRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CWsDeployPingRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CWsDeployPingRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CWsDeployPingRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CWsDeployPingRequest::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

}


void CWsDeployPingRequest::copy(CWsDeployPingRequest &from)
{
}


void CWsDeployPingRequest::copy(IConstWsDeployPingRequest &ifrom)
{
}


void CWsDeployPingRequest::getAttributes(IProperties &attributes)
{
}


void CWsDeployPingRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
}


void CWsDeployPingRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CWsDeployPingRequest::serializer(IEspContext* ctx, IConstWsDeployPingRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<WsDeployPingRequest>");
	if (keepRootTag)
		buffer.append("</WsDeployPingRequest>");
}

bool CWsDeployPingRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	return hasValue;
}

bool CWsDeployPingRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	return hasValue;
}

bool CWsDeployPingRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	return hasValue;
}

extern "C"  IEspWsDeployPingRequest *createWsDeployPingRequest(const char *serv){return ((IEspWsDeployPingRequest *)new CWsDeployPingRequest(serv));}
extern "C"  IClientWsDeployPingRequest *createClientWsDeployPingRequest(const char *serv){return ((IClientWsDeployPingRequest *)new CWsDeployPingRequest(serv));}

//=======================================================
// class CWsDeployPingResponse Implementation
//=======================================================

CWsDeployPingResponse::CWsDeployPingResponse(const char *serviceName, IRpcMessageBinding *init)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("WsDeployPingResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CWsDeployPingResponse::CWsDeployPingResponse(const char *serviceName, const char *bc)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("WsDeployPingResponse");
}

CWsDeployPingResponse::CWsDeployPingResponse(const char *serviceName, IRpcMessage* rpcmsg)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("WsDeployPingResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CWsDeployPingResponse::CWsDeployPingResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("WsDeployPingResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CWsDeployPingResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType><xsd:all/></xsd:complexType></xsd:element>\n", msgTypeName);
		}
	}
	return schema;
}

void CWsDeployPingResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CWsDeployPingResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CWsDeployPingResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CWsDeployPingResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CWsDeployPingResponse::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
	}
}


void CWsDeployPingResponse::copy(CWsDeployPingResponse &from)
{
}


void CWsDeployPingResponse::copy(IConstWsDeployPingResponse &ifrom)
{
}


void CWsDeployPingResponse::getAttributes(IProperties &attributes)
{
}


void CWsDeployPingResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
	}
}


void CWsDeployPingResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CWsDeployPingResponse::serializer(IEspContext* ctx, IConstWsDeployPingResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<WsDeployPingResponse>");
	if (keepRootTag)
		buffer.append("</WsDeployPingResponse>");
}

bool CWsDeployPingResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
	}
	return hasValue;
}

bool CWsDeployPingResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	return hasValue;
}

bool CWsDeployPingResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	return hasValue;
}

extern "C"  IEspWsDeployPingResponse *createWsDeployPingResponse(const char *serv){return ((IEspWsDeployPingResponse *)new CWsDeployPingResponse(serv));}
extern "C"  IClientWsDeployPingResponse *createClientWsDeployPingResponse(const char *serv){return ((IClientWsDeployPingResponse *)new CWsDeployPingResponse(serv));}

//=======================================================
// class CWsDeploySoapBinding Implementation
//=======================================================

CWsDeploySoapBinding::CWsDeploySoapBinding(http_soap_log_level level):CHttpSoapBinding(NULL, NULL, NULL, level)
{
	init_strings();
	setWsdlVersion(1);
}

CWsDeploySoapBinding::CWsDeploySoapBinding(IPropertyTree* cfg, const char *bindname, const char *procname, http_soap_log_level level):CHttpSoapBinding(cfg, bindname, procname, level)
{
	init_strings(); 
	setWsdlVersion(1);

}

void CWsDeploySoapBinding::init_strings()
{
	addMethodDescription("AddReqdComps", "Add the required components on given ip addresses.");
	addMethodDescription("BuildEnvironment", "To Build the environment from wizard by providing xml");
	addMethodDescription("ClientAlive", "Send a signal back to the service that the client is alive");
	addMethodDescription("DisplaySettings", "Display Component Settings");
	addMethodDescription("GetBuildServerDirs", "Get Build Server Directories");
	addMethodDescription("GetBuildSetInfo", "Get BuildSet Info");
	addMethodDescription("GetComputersForRoxie", "Get computers for Roxie components");
	addMethodDescription("GetDeployableComps", "Get Deployable Components");
	addMethodDescription("GetEnvironment", "Get the environment as an xml string");
	addMethodDescription("GetNavTreeDefn", "Return nav tree definition for display purposes");
	addMethodDescription("GetSubnetIPAddr", "To get the List IP Addresses in cloud environment by executing auto discovery script.");
	addMethodDescription("GetSummary", "To get the environment summary");
	addMethodDescription("GetValue", "Returns the value for the requested field");
	addMethodDescription("Graph", "Dependency graph");
	addMethodDescription("HandleAccessRules", "Handle Access Rules Requests suchs as add & delete e.t.c");
	addMethodDescription("HandleAttributeAdd", "Handle add fom XML view");
	addMethodDescription("HandleAttributeDelete", "Handle branch or leaf deletes from XML view");
	addMethodDescription("HandleBaseAccessControlList", "Handle Base Access Control List Requests suchs as add & delete e.t.c");
	addMethodDescription("HandleComponent", "Handle new component operations like add & delete in the environment");
	addMethodDescription("HandleComputer", "Handle new hardware operations like add & delete computer e.t.c");
	addMethodDescription("HandleEspServiceBindings", "Handle new Esp Service binding operations like add & delete ");
	addMethodDescription("HandleInstance", "Handle new instance operations like add & delete in the environment");
	addMethodDescription("HandleRows", "Handle row operations like add & delete e.t.c");
	addMethodDescription("HandleRoxieOperation", "Add computers to Roxie");
	addMethodDescription("HandleThorTopology", "Add computers to Thor topology");
	addMethodDescription("HandleTopology", "Handle Topology  operations like add & delete e.t.c");
	addMethodDescription("ImportBuild", "Import Build");
	addMethodDescription("LockEnvironmentForCloud", "Lock the environment. Only valid as a soapcall in Cloud Environments");
	addMethodDescription("NavMenuEvent", "Handle an event from the navigation tree menu");
	addMethodDescription("NotifyInitSystemSaveEnvForCloud", "Rollback the environment. Only valid as a soapcall in Cloud Environments");
	addMethodDescription("RollbackEnvironmentForCloud", "Rollback the environment. Only valid as a soapcall in Cloud Environments");
	addMethodDescription("SaveEnvironmentForCloud", "Save the environment. Only valid as a soapcall in Cloud Environments");
	addMethodDescription("SaveSetting", "Save Component Setting");
	addMethodDescription("SetEnvironment", "Validate, update Dali and set the environment that is passed in as an xml string");
	addMethodDescription("StartDeployment", "Start Deployment");
	addMethodDescription("UnlockEnvironmentForCloud", "Unlock the environment. Only valid as a soapcall in Cloud Environments");
	addMethodDescription("UnlockUser", "Unlocks a user that is already connected");
}

int CWsDeploySoapBinding::processRequest(IRpcMessage* rpc_call, IRpcMessage* rpc_response)
{
	if(rpc_call == NULL || rpc_response == NULL)
		return -1;

	IEspContext *ctx=rpc_call->queryContext();
	DBGLOG("Client version: %g", ctx->getClientVersion());
	StringBuffer serviceName;
	double clientVer=(ctx) ? ctx->getClientVersion() : 0.0;
	qualifyServiceName(*ctx, ctx->queryServiceName(NULL), NULL, serviceName, NULL);
	CRpcCall* thecall = static_cast<CRpcCall *>(rpc_call);
	CRpcResponse* response = static_cast<CRpcResponse*>(rpc_response);
	CHttpRequest* httprequest = thecall->getHttpReq();
	CHttpResponse* httpresponse = response->getHttpResp();

	Owned<IEspWsDeploy> iserv = (IEspWsDeploy*)getService();
	if(iserv == NULL)
	{
		response->set_status(SOAP_SERVER_ERROR);
		response->set_err("Service not available");
		DBGLOG("Service not available");
		return -1;
	}
	if (thecall->get_name() == NULL)
	{
		response->set_status(SOAP_CLIENT_ERROR);
		response->set_err("No service method specified");
		ERRLOG("No service method specified");
		return -1;
	}

	IEspContext& context = *rpc_call->queryContext();

	if(!stricmp(thecall->get_name(), "AddReqdComps")||!stricmp(thecall->get_name(), "AddReqdCompsRequest"))
	{
		Owned<CAddReqdCompsRequest> esp_request = new CAddReqdCompsRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CAddReqdCompsResponse> esp_response = new CAddReqdCompsResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		StringBuffer source;
		source.appendf("WsDeploy::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "WsDeploy", "AddReqdComps");
			iserv->onAddReqdComps(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "WsDeploy", "AddReqdComps");
		response->set_name("AddReqdCompsResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "BuildEnvironment")||!stricmp(thecall->get_name(), "BuildEnvironmentRequest"))
	{
		Owned<CBuildEnvironmentRequest> esp_request = new CBuildEnvironmentRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CBuildEnvironmentResponse> esp_response = new CBuildEnvironmentResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		StringBuffer source;
		source.appendf("WsDeploy::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "WsDeploy", "BuildEnvironment");
			iserv->onBuildEnvironment(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "WsDeploy", "BuildEnvironment");
		response->set_name("BuildEnvironmentResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "ClientAlive")||!stricmp(thecall->get_name(), "ClientAliveRequest"))
	{
		Owned<CClientAliveRequest> esp_request = new CClientAliveRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CClientAliveResponse> esp_response = new CClientAliveResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		StringBuffer source;
		source.appendf("WsDeploy::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "WsDeploy", "ClientAlive");
			iserv->onClientAlive(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "WsDeploy", "ClientAlive");
		response->set_name("ClientAliveResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "DisplaySettings")||!stricmp(thecall->get_name(), "DisplaySettingsRequest"))
	{
		Owned<CDisplaySettingsRequest> esp_request = new CDisplaySettingsRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CDisplaySettingsResponse> esp_response = new CDisplaySettingsResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		StringBuffer source;
		source.appendf("WsDeploy::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "WsDeploy", "DisplaySettings");
			iserv->onDisplaySettings(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "WsDeploy", "DisplaySettings");
		response->set_name("DisplaySettingsResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "GetBuildServerDirs")||!stricmp(thecall->get_name(), "GetBuildServerDirsRequest"))
	{
		Owned<CGetBuildServerDirsRequest> esp_request = new CGetBuildServerDirsRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CGetBuildServerDirsResponse> esp_response = new CGetBuildServerDirsResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		StringBuffer source;
		source.appendf("WsDeploy::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "WsDeploy", "GetBuildServerDirs");
			iserv->onGetBuildServerDirs(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "WsDeploy", "GetBuildServerDirs");
		response->set_name("GetBuildServerDirsResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "GetBuildSetInfo")||!stricmp(thecall->get_name(), "GetBuildSetInfoRequest"))
	{
		Owned<CGetBuildSetInfoRequest> esp_request = new CGetBuildSetInfoRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CGetBuildSetInfoResponse> esp_response = new CGetBuildSetInfoResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		StringBuffer source;
		source.appendf("WsDeploy::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "WsDeploy", "GetBuildSetInfo");
			iserv->onGetBuildSetInfo(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "WsDeploy", "GetBuildSetInfo");
		response->set_name("GetBuildSetInfoResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "GetComputersForRoxie")||!stricmp(thecall->get_name(), "GetComputersForRoxieRequest"))
	{
		Owned<CGetComputersForRoxieRequest> esp_request = new CGetComputersForRoxieRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CGetComputersForRoxieResponse> esp_response = new CGetComputersForRoxieResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		StringBuffer source;
		source.appendf("WsDeploy::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "WsDeploy", "GetComputersForRoxie");
			iserv->onGetComputersForRoxie(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "WsDeploy", "GetComputersForRoxie");
		response->set_name("GetComputersForRoxieResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "GetDeployableComps")||!stricmp(thecall->get_name(), "GetDeployableCompsRequest"))
	{
		Owned<CGetDeployableCompsRequest> esp_request = new CGetDeployableCompsRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CGetDeployableCompsResponse> esp_response = new CGetDeployableCompsResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		StringBuffer source;
		source.appendf("WsDeploy::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "WsDeploy", "GetDeployableComps");
			iserv->onGetDeployableComps(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "WsDeploy", "GetDeployableComps");
		response->set_name("GetDeployableCompsResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "GetEnvironment")||!stricmp(thecall->get_name(), "GetEnvironmentRequest"))
	{
		Owned<CGetEnvironmentRequest> esp_request = new CGetEnvironmentRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CGetEnvironmentResponse> esp_response = new CGetEnvironmentResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		StringBuffer source;
		source.appendf("WsDeploy::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "WsDeploy", "GetEnvironment");
			iserv->onGetEnvironment(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "WsDeploy", "GetEnvironment");
		response->set_name("GetEnvironmentResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "GetNavTreeDefn")||!stricmp(thecall->get_name(), "GetNavTreeDefnRequest"))
	{
		Owned<CGetNavTreeDefnRequest> esp_request = new CGetNavTreeDefnRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CGetNavTreeDefnResponse> esp_response = new CGetNavTreeDefnResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		StringBuffer source;
		source.appendf("WsDeploy::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "WsDeploy", "GetNavTreeDefn");
			iserv->onGetNavTreeDefn(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "WsDeploy", "GetNavTreeDefn");
		response->set_name("GetNavTreeDefnResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "GetSubnetIPAddr")||!stricmp(thecall->get_name(), "GetSubnetIPAddrRequest"))
	{
		Owned<CGetSubnetIPAddrRequest> esp_request = new CGetSubnetIPAddrRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CGetSubnetIPAddrResponse> esp_response = new CGetSubnetIPAddrResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		StringBuffer source;
		source.appendf("WsDeploy::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "WsDeploy", "GetSubnetIPAddr");
			iserv->onGetSubnetIPAddr(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "WsDeploy", "GetSubnetIPAddr");
		response->set_name("GetSubnetIPAddrResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "GetSummary")||!stricmp(thecall->get_name(), "GetSummaryRequest"))
	{
		Owned<CGetSummaryRequest> esp_request = new CGetSummaryRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CGetSummaryResponse> esp_response = new CGetSummaryResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		StringBuffer source;
		source.appendf("WsDeploy::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "WsDeploy", "GetSummary");
			iserv->onGetSummary(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "WsDeploy", "GetSummary");
		response->set_name("GetSummaryResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "GetValue")||!stricmp(thecall->get_name(), "GetValueRequest"))
	{
		Owned<CGetValueRequest> esp_request = new CGetValueRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CGetValueResponse> esp_response = new CGetValueResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		StringBuffer source;
		source.appendf("WsDeploy::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "WsDeploy", "GetValue");
			iserv->onGetValue(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "WsDeploy", "GetValue");
		response->set_name("GetValueResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "Graph")||!stricmp(thecall->get_name(), "EmptyRequest"))
	{
		Owned<CEmptyRequest> esp_request = new CEmptyRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CGraphResponse> esp_response = new CGraphResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		StringBuffer source;
		source.appendf("WsDeploy::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "WsDeploy", "Graph");
			iserv->onGraph(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "WsDeploy", "Graph");
		response->set_name("GraphResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "HandleAccessRules")||!stricmp(thecall->get_name(), "HandleAccessRulesRequest"))
	{
		Owned<CHandleAccessRulesRequest> esp_request = new CHandleAccessRulesRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CHandleAccessRulesResponse> esp_response = new CHandleAccessRulesResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		StringBuffer source;
		source.appendf("WsDeploy::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "WsDeploy", "HandleAccessRules");
			iserv->onHandleAccessRules(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "WsDeploy", "HandleAccessRules");
		response->set_name("HandleAccessRulesResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "HandleAttributeAdd")||!stricmp(thecall->get_name(), "HandleAttributeAddRequest"))
	{
		Owned<CHandleAttributeAddRequest> esp_request = new CHandleAttributeAddRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CHandleAttributeAddResponse> esp_response = new CHandleAttributeAddResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		StringBuffer source;
		source.appendf("WsDeploy::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "WsDeploy", "HandleAttributeAdd");
			iserv->onHandleAttributeAdd(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "WsDeploy", "HandleAttributeAdd");
		response->set_name("HandleAttributeAddResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "HandleAttributeDelete")||!stricmp(thecall->get_name(), "HandleAttributeDeleteRequest"))
	{
		Owned<CHandleAttributeDeleteRequest> esp_request = new CHandleAttributeDeleteRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CHandleAttributeDeleteResponse> esp_response = new CHandleAttributeDeleteResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		StringBuffer source;
		source.appendf("WsDeploy::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "WsDeploy", "HandleAttributeDelete");
			iserv->onHandleAttributeDelete(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "WsDeploy", "HandleAttributeDelete");
		response->set_name("HandleAttributeDeleteResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "HandleBaseAccessControlList")||!stricmp(thecall->get_name(), "HandleBaseAccessControlListRequest"))
	{
		Owned<CHandleBaseAccessControlListRequest> esp_request = new CHandleBaseAccessControlListRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CHandleBaseAccessControlListResponse> esp_response = new CHandleBaseAccessControlListResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		StringBuffer source;
		source.appendf("WsDeploy::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "WsDeploy", "HandleBaseAccessControlList");
			iserv->onHandleBaseAccessControlList(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "WsDeploy", "HandleBaseAccessControlList");
		response->set_name("HandleBaseAccessControlListResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "HandleComponent")||!stricmp(thecall->get_name(), "HandleComponentRequest"))
	{
		Owned<CHandleComponentRequest> esp_request = new CHandleComponentRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CHandleComponentResponse> esp_response = new CHandleComponentResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		StringBuffer source;
		source.appendf("WsDeploy::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "WsDeploy", "HandleComponent");
			iserv->onHandleComponent(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "WsDeploy", "HandleComponent");
		response->set_name("HandleComponentResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "HandleComputer")||!stricmp(thecall->get_name(), "HandleComputerRequest"))
	{
		Owned<CHandleComputerRequest> esp_request = new CHandleComputerRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CHandleComputerResponse> esp_response = new CHandleComputerResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		StringBuffer source;
		source.appendf("WsDeploy::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "WsDeploy", "HandleComputer");
			iserv->onHandleComputer(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "WsDeploy", "HandleComputer");
		response->set_name("HandleComputerResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "HandleEspServiceBindings")||!stricmp(thecall->get_name(), "HandleEspServiceBindingsRequest"))
	{
		Owned<CHandleEspServiceBindingsRequest> esp_request = new CHandleEspServiceBindingsRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CHandleEspServiceBindingsResponse> esp_response = new CHandleEspServiceBindingsResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		StringBuffer source;
		source.appendf("WsDeploy::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "WsDeploy", "HandleEspServiceBindings");
			iserv->onHandleEspServiceBindings(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "WsDeploy", "HandleEspServiceBindings");
		response->set_name("HandleEspServiceBindingsResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "HandleInstance")||!stricmp(thecall->get_name(), "HandleInstanceRequest"))
	{
		Owned<CHandleInstanceRequest> esp_request = new CHandleInstanceRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CHandleInstanceResponse> esp_response = new CHandleInstanceResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		StringBuffer source;
		source.appendf("WsDeploy::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "WsDeploy", "HandleInstance");
			iserv->onHandleInstance(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "WsDeploy", "HandleInstance");
		response->set_name("HandleInstanceResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "HandleRows")||!stricmp(thecall->get_name(), "HandleRowsRequest"))
	{
		Owned<CHandleRowsRequest> esp_request = new CHandleRowsRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CHandleRowsResponse> esp_response = new CHandleRowsResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		StringBuffer source;
		source.appendf("WsDeploy::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "WsDeploy", "HandleRows");
			iserv->onHandleRows(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "WsDeploy", "HandleRows");
		response->set_name("HandleRowsResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "HandleRoxieOperation")||!stricmp(thecall->get_name(), "HandleRoxieOperationRequest"))
	{
		Owned<CHandleRoxieOperationRequest> esp_request = new CHandleRoxieOperationRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CHandleRoxieOperationResponse> esp_response = new CHandleRoxieOperationResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		StringBuffer source;
		source.appendf("WsDeploy::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "WsDeploy", "HandleRoxieOperation");
			iserv->onHandleRoxieOperation(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "WsDeploy", "HandleRoxieOperation");
		response->set_name("HandleRoxieOperationResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "HandleThorTopology")||!stricmp(thecall->get_name(), "HandleThorTopologyRequest"))
	{
		Owned<CHandleThorTopologyRequest> esp_request = new CHandleThorTopologyRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CHandleThorTopologyResponse> esp_response = new CHandleThorTopologyResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		StringBuffer source;
		source.appendf("WsDeploy::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "WsDeploy", "HandleThorTopology");
			iserv->onHandleThorTopology(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "WsDeploy", "HandleThorTopology");
		response->set_name("HandleThorTopologyResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "HandleTopology")||!stricmp(thecall->get_name(), "HandleTopologyRequest"))
	{
		Owned<CHandleTopologyRequest> esp_request = new CHandleTopologyRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CHandleTopologyResponse> esp_response = new CHandleTopologyResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		StringBuffer source;
		source.appendf("WsDeploy::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "WsDeploy", "HandleTopology");
			iserv->onHandleTopology(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "WsDeploy", "HandleTopology");
		response->set_name("HandleTopologyResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "ImportBuild")||!stricmp(thecall->get_name(), "ImportBuildRequest"))
	{
		Owned<CImportBuildRequest> esp_request = new CImportBuildRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CImportBuildResponse> esp_response = new CImportBuildResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		StringBuffer source;
		source.appendf("WsDeploy::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "WsDeploy", "ImportBuild");
			iserv->onImportBuild(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "WsDeploy", "ImportBuild");
		response->set_name("ImportBuildResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "LockEnvironmentForCloud")||!stricmp(thecall->get_name(), "LockEnvironmentForCloudRequest"))
	{
		Owned<CLockEnvironmentForCloudRequest> esp_request = new CLockEnvironmentForCloudRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CLockEnvironmentForCloudResponse> esp_response = new CLockEnvironmentForCloudResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		StringBuffer source;
		source.appendf("WsDeploy::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "WsDeploy", "LockEnvironmentForCloud");
			iserv->onLockEnvironmentForCloud(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "WsDeploy", "LockEnvironmentForCloud");
		response->set_name("LockEnvironmentForCloudResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "NavMenuEvent")||!stricmp(thecall->get_name(), "NavMenuEventRequest"))
	{
		Owned<CNavMenuEventRequest> esp_request = new CNavMenuEventRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CNavMenuEventResponse> esp_response = new CNavMenuEventResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		StringBuffer source;
		source.appendf("WsDeploy::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "WsDeploy", "NavMenuEvent");
			iserv->onNavMenuEvent(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "WsDeploy", "NavMenuEvent");
		response->set_name("NavMenuEventResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "NotifyInitSystemSaveEnvForCloud")||!stricmp(thecall->get_name(), "NotifyInitSystemSaveEnvForCloudRequest"))
	{
		Owned<CNotifyInitSystemSaveEnvForCloudRequest> esp_request = new CNotifyInitSystemSaveEnvForCloudRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CNotifyInitSystemSaveEnvForCloudResponse> esp_response = new CNotifyInitSystemSaveEnvForCloudResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		StringBuffer source;
		source.appendf("WsDeploy::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "WsDeploy", "NotifyInitSystemSaveEnvForCloud");
			iserv->onNotifyInitSystemSaveEnvForCloud(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "WsDeploy", "NotifyInitSystemSaveEnvForCloud");
		response->set_name("NotifyInitSystemSaveEnvForCloudResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "Ping")||!stricmp(thecall->get_name(), "WsDeployPingRequest"))
	{
		Owned<CWsDeployPingRequest> esp_request = new CWsDeployPingRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CWsDeployPingResponse> esp_response = new CWsDeployPingResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		StringBuffer source;
		source.appendf("WsDeploy::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "WsDeploy", "Ping");
			iserv->onPing(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "WsDeploy", "Ping");
		response->set_name("WsDeployPingResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "RollbackEnvironmentForCloud")||!stricmp(thecall->get_name(), "RollbackEnvironmentForCloudRequest"))
	{
		Owned<CRollbackEnvironmentForCloudRequest> esp_request = new CRollbackEnvironmentForCloudRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CRollbackEnvironmentForCloudResponse> esp_response = new CRollbackEnvironmentForCloudResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		StringBuffer source;
		source.appendf("WsDeploy::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "WsDeploy", "RollbackEnvironmentForCloud");
			iserv->onRollbackEnvironmentForCloud(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "WsDeploy", "RollbackEnvironmentForCloud");
		response->set_name("RollbackEnvironmentForCloudResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "SaveEnvironmentForCloud")||!stricmp(thecall->get_name(), "SaveEnvironmentForCloudRequest"))
	{
		Owned<CSaveEnvironmentForCloudRequest> esp_request = new CSaveEnvironmentForCloudRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CSaveEnvironmentForCloudResponse> esp_response = new CSaveEnvironmentForCloudResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		StringBuffer source;
		source.appendf("WsDeploy::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "WsDeploy", "SaveEnvironmentForCloud");
			iserv->onSaveEnvironmentForCloud(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "WsDeploy", "SaveEnvironmentForCloud");
		response->set_name("SaveEnvironmentForCloudResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "SaveSetting")||!stricmp(thecall->get_name(), "SaveSettingRequest"))
	{
		Owned<CSaveSettingRequest> esp_request = new CSaveSettingRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CSaveSettingResponse> esp_response = new CSaveSettingResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		StringBuffer source;
		source.appendf("WsDeploy::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "WsDeploy", "SaveSetting");
			iserv->onSaveSetting(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "WsDeploy", "SaveSetting");
		response->set_name("SaveSettingResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "SetEnvironment")||!stricmp(thecall->get_name(), "SetEnvironmentRequest"))
	{
		Owned<CSetEnvironmentRequest> esp_request = new CSetEnvironmentRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CSetEnvironmentResponse> esp_response = new CSetEnvironmentResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		StringBuffer source;
		source.appendf("WsDeploy::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "WsDeploy", "SetEnvironment");
			iserv->onSetEnvironment(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "WsDeploy", "SetEnvironment");
		response->set_name("SetEnvironmentResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "StartDeployment")||!stricmp(thecall->get_name(), "StartDeploymentRequest"))
	{
		Owned<CStartDeploymentRequest> esp_request = new CStartDeploymentRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CStartDeploymentResponse> esp_response = new CStartDeploymentResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		StringBuffer source;
		source.appendf("WsDeploy::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "WsDeploy", "StartDeployment");
			iserv->onStartDeployment(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "WsDeploy", "StartDeployment");
		response->set_name("StartDeploymentResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "UnlockEnvironmentForCloud")||!stricmp(thecall->get_name(), "UnlockEnvironmentForCloudRequest"))
	{
		Owned<CUnlockEnvironmentForCloudRequest> esp_request = new CUnlockEnvironmentForCloudRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CUnlockEnvironmentForCloudResponse> esp_response = new CUnlockEnvironmentForCloudResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		StringBuffer source;
		source.appendf("WsDeploy::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "WsDeploy", "UnlockEnvironmentForCloud");
			iserv->onUnlockEnvironmentForCloud(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "WsDeploy", "UnlockEnvironmentForCloud");
		response->set_name("UnlockEnvironmentForCloudResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "UnlockUser")||!stricmp(thecall->get_name(), "UnlockUserRequest"))
	{
		Owned<CUnlockUserRequest> esp_request = new CUnlockUserRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CUnlockUserResponse> esp_response = new CUnlockUserResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		StringBuffer source;
		source.appendf("WsDeploy::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "WsDeploy", "UnlockUser");
			iserv->onUnlockUser(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "WsDeploy", "UnlockUser");
		response->set_name("UnlockUserResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	response->set_status(SOAP_CLIENT_ERROR);
	StringBuffer msg, svcName;
	msg.appendf("Method %s not available in service %s",thecall->get_name(),getServiceName(svcName).str());
	ERRLOG("%s", msg.str());
	response->set_err(msg);
	return -1;
}

int CWsDeploySoapBinding::getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &content, const char *service, const char *method, bool mda)
{
	BoolHash added;
	DBGLOG("Client version: %g", context.getClientVersion());
	bool fullservice = (!Utils::strcasecmp(service, "WsDeploy"));
	bool allMethods = (method==NULL || *method==0);
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "AddReqdComps"))) || Utils::strcasecmp(method, "AddReqdComps")==0)
	{
		CAddReqdCompsRequest::getMapInfo(context.queryMapInfo());
		CAddReqdCompsResponse::getMapInfo(context.queryMapInfo());
		CAddReqdCompsRequest::getXsdDefinition(context, request, "AddReqdCompsRequest", content, added);
		CAddReqdCompsResponse::getXsdDefinition(context, request, content, added);
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "BuildEnvironment"))) || Utils::strcasecmp(method, "BuildEnvironment")==0)
	{
		CBuildEnvironmentRequest::getMapInfo(context.queryMapInfo());
		CBuildEnvironmentResponse::getMapInfo(context.queryMapInfo());
		CBuildEnvironmentRequest::getXsdDefinition(context, request, "BuildEnvironmentRequest", content, added);
		CBuildEnvironmentResponse::getXsdDefinition(context, request, content, added);
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "ClientAlive"))) || Utils::strcasecmp(method, "ClientAlive")==0)
	{
		CClientAliveRequest::getMapInfo(context.queryMapInfo());
		CClientAliveResponse::getMapInfo(context.queryMapInfo());
		CClientAliveRequest::getXsdDefinition(context, request, "ClientAliveRequest", content, added);
		CClientAliveResponse::getXsdDefinition(context, request, content, added);
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "DisplaySettings"))) || Utils::strcasecmp(method, "DisplaySettings")==0)
	{
		CDisplaySettingsRequest::getMapInfo(context.queryMapInfo());
		CDisplaySettingsResponse::getMapInfo(context.queryMapInfo());
		CDisplaySettingsRequest::getXsdDefinition(context, request, "DisplaySettingsRequest", content, added);
		CDisplaySettingsResponse::getXsdDefinition(context, request, content, added);
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "GetBuildServerDirs"))) || Utils::strcasecmp(method, "GetBuildServerDirs")==0)
	{
		CGetBuildServerDirsRequest::getMapInfo(context.queryMapInfo());
		CGetBuildServerDirsResponse::getMapInfo(context.queryMapInfo());
		CGetBuildServerDirsRequest::getXsdDefinition(context, request, "GetBuildServerDirsRequest", content, added);
		CGetBuildServerDirsResponse::getXsdDefinition(context, request, content, added);
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "GetBuildSetInfo"))) || Utils::strcasecmp(method, "GetBuildSetInfo")==0)
	{
		CGetBuildSetInfoRequest::getMapInfo(context.queryMapInfo());
		CGetBuildSetInfoResponse::getMapInfo(context.queryMapInfo());
		CGetBuildSetInfoRequest::getXsdDefinition(context, request, "GetBuildSetInfoRequest", content, added);
		CGetBuildSetInfoResponse::getXsdDefinition(context, request, content, added);
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "GetComputersForRoxie"))) || Utils::strcasecmp(method, "GetComputersForRoxie")==0)
	{
		CGetComputersForRoxieRequest::getMapInfo(context.queryMapInfo());
		CGetComputersForRoxieResponse::getMapInfo(context.queryMapInfo());
		CGetComputersForRoxieRequest::getXsdDefinition(context, request, "GetComputersForRoxieRequest", content, added);
		CGetComputersForRoxieResponse::getXsdDefinition(context, request, content, added);
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "GetDeployableComps"))) || Utils::strcasecmp(method, "GetDeployableComps")==0)
	{
		CGetDeployableCompsRequest::getMapInfo(context.queryMapInfo());
		CGetDeployableCompsResponse::getMapInfo(context.queryMapInfo());
		CGetDeployableCompsRequest::getXsdDefinition(context, request, "GetDeployableCompsRequest", content, added);
		CGetDeployableCompsResponse::getXsdDefinition(context, request, content, added);
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "GetEnvironment"))) || Utils::strcasecmp(method, "GetEnvironment")==0)
	{
		CGetEnvironmentRequest::getMapInfo(context.queryMapInfo());
		CGetEnvironmentResponse::getMapInfo(context.queryMapInfo());
		CGetEnvironmentRequest::getXsdDefinition(context, request, "GetEnvironmentRequest", content, added);
		CGetEnvironmentResponse::getXsdDefinition(context, request, content, added);
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "GetNavTreeDefn"))) || Utils::strcasecmp(method, "GetNavTreeDefn")==0)
	{
		CGetNavTreeDefnRequest::getMapInfo(context.queryMapInfo());
		CGetNavTreeDefnResponse::getMapInfo(context.queryMapInfo());
		CGetNavTreeDefnRequest::getXsdDefinition(context, request, "GetNavTreeDefnRequest", content, added);
		CGetNavTreeDefnResponse::getXsdDefinition(context, request, content, added);
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "GetSubnetIPAddr"))) || Utils::strcasecmp(method, "GetSubnetIPAddr")==0)
	{
		CGetSubnetIPAddrRequest::getMapInfo(context.queryMapInfo());
		CGetSubnetIPAddrResponse::getMapInfo(context.queryMapInfo());
		CGetSubnetIPAddrRequest::getXsdDefinition(context, request, "GetSubnetIPAddrRequest", content, added);
		CGetSubnetIPAddrResponse::getXsdDefinition(context, request, content, added);
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "GetSummary"))) || Utils::strcasecmp(method, "GetSummary")==0)
	{
		CGetSummaryRequest::getMapInfo(context.queryMapInfo());
		CGetSummaryResponse::getMapInfo(context.queryMapInfo());
		CGetSummaryRequest::getXsdDefinition(context, request, "GetSummaryRequest", content, added);
		CGetSummaryResponse::getXsdDefinition(context, request, content, added);
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "GetValue"))) || Utils::strcasecmp(method, "GetValue")==0)
	{
		CGetValueRequest::getMapInfo(context.queryMapInfo());
		CGetValueResponse::getMapInfo(context.queryMapInfo());
		CGetValueRequest::getXsdDefinition(context, request, "GetValueRequest", content, added);
		CGetValueResponse::getXsdDefinition(context, request, content, added);
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "Graph"))) || Utils::strcasecmp(method, "Graph")==0)
	{
		CEmptyRequest::getMapInfo(context.queryMapInfo());
		CGraphResponse::getMapInfo(context.queryMapInfo());
		CEmptyRequest::getXsdDefinition(context, request, "EmptyRequest", content, added);
		CGraphResponse::getXsdDefinition(context, request, content, added);
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "HandleAccessRules"))) || Utils::strcasecmp(method, "HandleAccessRules")==0)
	{
		CHandleAccessRulesRequest::getMapInfo(context.queryMapInfo());
		CHandleAccessRulesResponse::getMapInfo(context.queryMapInfo());
		CHandleAccessRulesRequest::getXsdDefinition(context, request, "HandleAccessRulesRequest", content, added);
		CHandleAccessRulesResponse::getXsdDefinition(context, request, content, added);
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "HandleAttributeAdd"))) || Utils::strcasecmp(method, "HandleAttributeAdd")==0)
	{
		CHandleAttributeAddRequest::getMapInfo(context.queryMapInfo());
		CHandleAttributeAddResponse::getMapInfo(context.queryMapInfo());
		CHandleAttributeAddRequest::getXsdDefinition(context, request, "HandleAttributeAddRequest", content, added);
		CHandleAttributeAddResponse::getXsdDefinition(context, request, content, added);
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "HandleAttributeDelete"))) || Utils::strcasecmp(method, "HandleAttributeDelete")==0)
	{
		CHandleAttributeDeleteRequest::getMapInfo(context.queryMapInfo());
		CHandleAttributeDeleteResponse::getMapInfo(context.queryMapInfo());
		CHandleAttributeDeleteRequest::getXsdDefinition(context, request, "HandleAttributeDeleteRequest", content, added);
		CHandleAttributeDeleteResponse::getXsdDefinition(context, request, content, added);
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "HandleBaseAccessControlList"))) || Utils::strcasecmp(method, "HandleBaseAccessControlList")==0)
	{
		CHandleBaseAccessControlListRequest::getMapInfo(context.queryMapInfo());
		CHandleBaseAccessControlListResponse::getMapInfo(context.queryMapInfo());
		CHandleBaseAccessControlListRequest::getXsdDefinition(context, request, "HandleBaseAccessControlListRequest", content, added);
		CHandleBaseAccessControlListResponse::getXsdDefinition(context, request, content, added);
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "HandleComponent"))) || Utils::strcasecmp(method, "HandleComponent")==0)
	{
		CHandleComponentRequest::getMapInfo(context.queryMapInfo());
		CHandleComponentResponse::getMapInfo(context.queryMapInfo());
		CHandleComponentRequest::getXsdDefinition(context, request, "HandleComponentRequest", content, added);
		CHandleComponentResponse::getXsdDefinition(context, request, content, added);
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "HandleComputer"))) || Utils::strcasecmp(method, "HandleComputer")==0)
	{
		CHandleComputerRequest::getMapInfo(context.queryMapInfo());
		CHandleComputerResponse::getMapInfo(context.queryMapInfo());
		CHandleComputerRequest::getXsdDefinition(context, request, "HandleComputerRequest", content, added);
		CHandleComputerResponse::getXsdDefinition(context, request, content, added);
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "HandleEspServiceBindings"))) || Utils::strcasecmp(method, "HandleEspServiceBindings")==0)
	{
		CHandleEspServiceBindingsRequest::getMapInfo(context.queryMapInfo());
		CHandleEspServiceBindingsResponse::getMapInfo(context.queryMapInfo());
		CHandleEspServiceBindingsRequest::getXsdDefinition(context, request, "HandleEspServiceBindingsRequest", content, added);
		CHandleEspServiceBindingsResponse::getXsdDefinition(context, request, content, added);
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "HandleInstance"))) || Utils::strcasecmp(method, "HandleInstance")==0)
	{
		CHandleInstanceRequest::getMapInfo(context.queryMapInfo());
		CHandleInstanceResponse::getMapInfo(context.queryMapInfo());
		CHandleInstanceRequest::getXsdDefinition(context, request, "HandleInstanceRequest", content, added);
		CHandleInstanceResponse::getXsdDefinition(context, request, content, added);
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "HandleRows"))) || Utils::strcasecmp(method, "HandleRows")==0)
	{
		CHandleRowsRequest::getMapInfo(context.queryMapInfo());
		CHandleRowsResponse::getMapInfo(context.queryMapInfo());
		CHandleRowsRequest::getXsdDefinition(context, request, "HandleRowsRequest", content, added);
		CHandleRowsResponse::getXsdDefinition(context, request, content, added);
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "HandleRoxieOperation"))) || Utils::strcasecmp(method, "HandleRoxieOperation")==0)
	{
		CHandleRoxieOperationRequest::getMapInfo(context.queryMapInfo());
		CHandleRoxieOperationResponse::getMapInfo(context.queryMapInfo());
		CHandleRoxieOperationRequest::getXsdDefinition(context, request, "HandleRoxieOperationRequest", content, added);
		CHandleRoxieOperationResponse::getXsdDefinition(context, request, content, added);
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "HandleThorTopology"))) || Utils::strcasecmp(method, "HandleThorTopology")==0)
	{
		CHandleThorTopologyRequest::getMapInfo(context.queryMapInfo());
		CHandleThorTopologyResponse::getMapInfo(context.queryMapInfo());
		CHandleThorTopologyRequest::getXsdDefinition(context, request, "HandleThorTopologyRequest", content, added);
		CHandleThorTopologyResponse::getXsdDefinition(context, request, content, added);
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "HandleTopology"))) || Utils::strcasecmp(method, "HandleTopology")==0)
	{
		CHandleTopologyRequest::getMapInfo(context.queryMapInfo());
		CHandleTopologyResponse::getMapInfo(context.queryMapInfo());
		CHandleTopologyRequest::getXsdDefinition(context, request, "HandleTopologyRequest", content, added);
		CHandleTopologyResponse::getXsdDefinition(context, request, content, added);
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "ImportBuild"))) || Utils::strcasecmp(method, "ImportBuild")==0)
	{
		CImportBuildRequest::getMapInfo(context.queryMapInfo());
		CImportBuildResponse::getMapInfo(context.queryMapInfo());
		CImportBuildRequest::getXsdDefinition(context, request, "ImportBuildRequest", content, added);
		CImportBuildResponse::getXsdDefinition(context, request, content, added);
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "LockEnvironmentForCloud"))) || Utils::strcasecmp(method, "LockEnvironmentForCloud")==0)
	{
		CLockEnvironmentForCloudRequest::getMapInfo(context.queryMapInfo());
		CLockEnvironmentForCloudResponse::getMapInfo(context.queryMapInfo());
		CLockEnvironmentForCloudRequest::getXsdDefinition(context, request, "LockEnvironmentForCloudRequest", content, added);
		CLockEnvironmentForCloudResponse::getXsdDefinition(context, request, content, added);
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "NavMenuEvent"))) || Utils::strcasecmp(method, "NavMenuEvent")==0)
	{
		CNavMenuEventRequest::getMapInfo(context.queryMapInfo());
		CNavMenuEventResponse::getMapInfo(context.queryMapInfo());
		CNavMenuEventRequest::getXsdDefinition(context, request, "NavMenuEventRequest", content, added);
		CNavMenuEventResponse::getXsdDefinition(context, request, content, added);
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "NotifyInitSystemSaveEnvForCloud"))) || Utils::strcasecmp(method, "NotifyInitSystemSaveEnvForCloud")==0)
	{
		CNotifyInitSystemSaveEnvForCloudRequest::getMapInfo(context.queryMapInfo());
		CNotifyInitSystemSaveEnvForCloudResponse::getMapInfo(context.queryMapInfo());
		CNotifyInitSystemSaveEnvForCloudRequest::getXsdDefinition(context, request, "NotifyInitSystemSaveEnvForCloudRequest", content, added);
		CNotifyInitSystemSaveEnvForCloudResponse::getXsdDefinition(context, request, content, added);
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "Ping"))) || Utils::strcasecmp(method, "Ping")==0)
	{
		CWsDeployPingRequest::getMapInfo(context.queryMapInfo());
		CWsDeployPingResponse::getMapInfo(context.queryMapInfo());
		CWsDeployPingRequest::getXsdDefinition(context, request, "WsDeployPingRequest", content, added);
		CWsDeployPingResponse::getXsdDefinition(context, request, content, added);
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "RollbackEnvironmentForCloud"))) || Utils::strcasecmp(method, "RollbackEnvironmentForCloud")==0)
	{
		CRollbackEnvironmentForCloudRequest::getMapInfo(context.queryMapInfo());
		CRollbackEnvironmentForCloudResponse::getMapInfo(context.queryMapInfo());
		CRollbackEnvironmentForCloudRequest::getXsdDefinition(context, request, "RollbackEnvironmentForCloudRequest", content, added);
		CRollbackEnvironmentForCloudResponse::getXsdDefinition(context, request, content, added);
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "SaveEnvironmentForCloud"))) || Utils::strcasecmp(method, "SaveEnvironmentForCloud")==0)
	{
		CSaveEnvironmentForCloudRequest::getMapInfo(context.queryMapInfo());
		CSaveEnvironmentForCloudResponse::getMapInfo(context.queryMapInfo());
		CSaveEnvironmentForCloudRequest::getXsdDefinition(context, request, "SaveEnvironmentForCloudRequest", content, added);
		CSaveEnvironmentForCloudResponse::getXsdDefinition(context, request, content, added);
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "SaveSetting"))) || Utils::strcasecmp(method, "SaveSetting")==0)
	{
		CSaveSettingRequest::getMapInfo(context.queryMapInfo());
		CSaveSettingResponse::getMapInfo(context.queryMapInfo());
		CSaveSettingRequest::getXsdDefinition(context, request, "SaveSettingRequest", content, added);
		CSaveSettingResponse::getXsdDefinition(context, request, content, added);
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "SetEnvironment"))) || Utils::strcasecmp(method, "SetEnvironment")==0)
	{
		CSetEnvironmentRequest::getMapInfo(context.queryMapInfo());
		CSetEnvironmentResponse::getMapInfo(context.queryMapInfo());
		CSetEnvironmentRequest::getXsdDefinition(context, request, "SetEnvironmentRequest", content, added);
		CSetEnvironmentResponse::getXsdDefinition(context, request, content, added);
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "StartDeployment"))) || Utils::strcasecmp(method, "StartDeployment")==0)
	{
		CStartDeploymentRequest::getMapInfo(context.queryMapInfo());
		CStartDeploymentResponse::getMapInfo(context.queryMapInfo());
		CStartDeploymentRequest::getXsdDefinition(context, request, "StartDeploymentRequest", content, added);
		CStartDeploymentResponse::getXsdDefinition(context, request, content, added);
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "UnlockEnvironmentForCloud"))) || Utils::strcasecmp(method, "UnlockEnvironmentForCloud")==0)
	{
		CUnlockEnvironmentForCloudRequest::getMapInfo(context.queryMapInfo());
		CUnlockEnvironmentForCloudResponse::getMapInfo(context.queryMapInfo());
		CUnlockEnvironmentForCloudRequest::getXsdDefinition(context, request, "UnlockEnvironmentForCloudRequest", content, added);
		CUnlockEnvironmentForCloudResponse::getXsdDefinition(context, request, content, added);
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "UnlockUser"))) || Utils::strcasecmp(method, "UnlockUser")==0)
	{
		CUnlockUserRequest::getMapInfo(context.queryMapInfo());
		CUnlockUserResponse::getMapInfo(context.queryMapInfo());
		CUnlockUserRequest::getXsdDefinition(context, request, "UnlockUserRequest", content, added);
		CUnlockUserResponse::getXsdDefinition(context, request, content, added);
	}
	return 0;
}

int CWsDeploySoapBinding::getMethodHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &page, bool bIncludeFormTag)
{
	DBGLOG("Client version: %g", context.getClientVersion());
	if (Utils::strcasecmp(method, "AddReqdComps")==0)
	{
		CAddReqdCompsRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "BuildEnvironment")==0)
	{
		CBuildEnvironmentRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "ClientAlive")==0)
	{
		CClientAliveRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "DisplaySettings")==0)
	{
		CDisplaySettingsRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "GetBuildServerDirs")==0)
	{
		CGetBuildServerDirsRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "GetBuildSetInfo")==0)
	{
		CGetBuildSetInfoRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "GetComputersForRoxie")==0)
	{
		CGetComputersForRoxieRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "GetDeployableComps")==0)
	{
		CGetDeployableCompsRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "GetEnvironment")==0)
	{
		CGetEnvironmentRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "GetNavTreeDefn")==0)
	{
		CGetNavTreeDefnRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "GetSubnetIPAddr")==0)
	{
		CGetSubnetIPAddrRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "GetSummary")==0)
	{
		CGetSummaryRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "GetValue")==0)
	{
		CGetValueRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "Graph")==0)
	{
		CEmptyRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "HandleAccessRules")==0)
	{
		CHandleAccessRulesRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "HandleAttributeAdd")==0)
	{
		CHandleAttributeAddRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "HandleAttributeDelete")==0)
	{
		CHandleAttributeDeleteRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "HandleBaseAccessControlList")==0)
	{
		CHandleBaseAccessControlListRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "HandleComponent")==0)
	{
		CHandleComponentRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "HandleComputer")==0)
	{
		CHandleComputerRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "HandleEspServiceBindings")==0)
	{
		CHandleEspServiceBindingsRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "HandleInstance")==0)
	{
		CHandleInstanceRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "HandleRows")==0)
	{
		CHandleRowsRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "HandleRoxieOperation")==0)
	{
		CHandleRoxieOperationRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "HandleThorTopology")==0)
	{
		CHandleThorTopologyRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "HandleTopology")==0)
	{
		CHandleTopologyRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "ImportBuild")==0)
	{
		CImportBuildRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "LockEnvironmentForCloud")==0)
	{
		CLockEnvironmentForCloudRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "NavMenuEvent")==0)
	{
		CNavMenuEventRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "NotifyInitSystemSaveEnvForCloud")==0)
	{
		CNotifyInitSystemSaveEnvForCloudRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "Ping")==0)
	{
		CWsDeployPingRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "RollbackEnvironmentForCloud")==0)
	{
		CRollbackEnvironmentForCloudRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "SaveEnvironmentForCloud")==0)
	{
		CSaveEnvironmentForCloudRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "SaveSetting")==0)
	{
		CSaveSettingRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "SetEnvironment")==0)
	{
		CSetEnvironmentRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "StartDeployment")==0)
	{
		CStartDeploymentRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "UnlockEnvironmentForCloud")==0)
	{
		CUnlockEnvironmentForCloudRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "UnlockUser")==0)
	{
		CUnlockUserRequest::getHtmlForm(context, request, serv, method, page);
	}
	return 0;
}

int CWsDeploySoapBinding::getQualifiedNames(IEspContext& ctx, MethodInfoArray & methods)
{
	double ver = ctx.getClientVersion();
	if (ver<=0)
		ver = getWsdlVersion();
	const char *servname=ctx.queryServiceName(NULL);
	bool fullservice = (!stricmp(servname, "esp")||!stricmp(servname, "WsDeploy"));
	if ((fullservice || isMethodInSubService(ctx, servname, "AddReqdComps")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("AddReqdComps", "AddReqdCompsRequest", "AddReqdCompsResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "BuildEnvironment")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("BuildEnvironment", "BuildEnvironmentRequest", "BuildEnvironmentResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "ClientAlive")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("ClientAlive", "ClientAliveRequest", "ClientAliveResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "DisplaySettings")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("DisplaySettings", "DisplaySettingsRequest", "DisplaySettingsResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "GetBuildServerDirs")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("GetBuildServerDirs", "GetBuildServerDirsRequest", "GetBuildServerDirsResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "GetBuildSetInfo")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("GetBuildSetInfo", "GetBuildSetInfoRequest", "GetBuildSetInfoResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "GetComputersForRoxie")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("GetComputersForRoxie", "GetComputersForRoxieRequest", "GetComputersForRoxieResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "GetDeployableComps")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("GetDeployableComps", "GetDeployableCompsRequest", "GetDeployableCompsResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "GetEnvironment")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("GetEnvironment", "GetEnvironmentRequest", "GetEnvironmentResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "GetNavTreeDefn")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("GetNavTreeDefn", "GetNavTreeDefnRequest", "GetNavTreeDefnResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "GetSubnetIPAddr")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("GetSubnetIPAddr", "GetSubnetIPAddrRequest", "GetSubnetIPAddrResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "GetSummary")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("GetSummary", "GetSummaryRequest", "GetSummaryResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "GetValue")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("GetValue", "GetValueRequest", "GetValueResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "Graph")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("Graph", "EmptyRequest", "GraphResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "HandleAccessRules")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("HandleAccessRules", "HandleAccessRulesRequest", "HandleAccessRulesResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "HandleAttributeAdd")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("HandleAttributeAdd", "HandleAttributeAddRequest", "HandleAttributeAddResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "HandleAttributeDelete")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("HandleAttributeDelete", "HandleAttributeDeleteRequest", "HandleAttributeDeleteResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "HandleBaseAccessControlList")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("HandleBaseAccessControlList", "HandleBaseAccessControlListRequest", "HandleBaseAccessControlListResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "HandleComponent")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("HandleComponent", "HandleComponentRequest", "HandleComponentResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "HandleComputer")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("HandleComputer", "HandleComputerRequest", "HandleComputerResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "HandleEspServiceBindings")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("HandleEspServiceBindings", "HandleEspServiceBindingsRequest", "HandleEspServiceBindingsResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "HandleInstance")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("HandleInstance", "HandleInstanceRequest", "HandleInstanceResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "HandleRows")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("HandleRows", "HandleRowsRequest", "HandleRowsResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "HandleRoxieOperation")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("HandleRoxieOperation", "HandleRoxieOperationRequest", "HandleRoxieOperationResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "HandleThorTopology")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("HandleThorTopology", "HandleThorTopologyRequest", "HandleThorTopologyResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "HandleTopology")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("HandleTopology", "HandleTopologyRequest", "HandleTopologyResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "ImportBuild")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("ImportBuild", "ImportBuildRequest", "ImportBuildResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "LockEnvironmentForCloud")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("LockEnvironmentForCloud", "LockEnvironmentForCloudRequest", "LockEnvironmentForCloudResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "NavMenuEvent")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("NavMenuEvent", "NavMenuEventRequest", "NavMenuEventResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "NotifyInitSystemSaveEnvForCloud")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("NotifyInitSystemSaveEnvForCloud", "NotifyInitSystemSaveEnvForCloudRequest", "NotifyInitSystemSaveEnvForCloudResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "Ping")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("Ping", "WsDeployPingRequest", "WsDeployPingResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "RollbackEnvironmentForCloud")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("RollbackEnvironmentForCloud", "RollbackEnvironmentForCloudRequest", "RollbackEnvironmentForCloudResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "SaveEnvironmentForCloud")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("SaveEnvironmentForCloud", "SaveEnvironmentForCloudRequest", "SaveEnvironmentForCloudResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "SaveSetting")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("SaveSetting", "SaveSettingRequest", "SaveSettingResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "SetEnvironment")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("SetEnvironment", "SetEnvironmentRequest", "SetEnvironmentResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "StartDeployment")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("StartDeployment", "StartDeploymentRequest", "StartDeploymentResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "UnlockEnvironmentForCloud")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("UnlockEnvironmentForCloud", "UnlockEnvironmentForCloudRequest", "UnlockEnvironmentForCloudResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "UnlockUser")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("UnlockUser", "UnlockUserRequest", "UnlockUserResponse"));
	return methods.ordinality();
}

StringBuffer & CWsDeploySoapBinding::getServiceName(StringBuffer &resp)
{
	resp.append("WsDeploy");
	return resp;
}

bool CWsDeploySoapBinding::isValidServiceName(IEspContext &context, const char *name)
{
	if (!Utils::strcasecmp(name, "WsDeploy"))
		return true;
	else
		return (hasSubService(context, name));
}

bool CWsDeploySoapBinding::qualifyMethodName(IEspContext &context, const char *methname, StringBuffer *methQName)
{
	if (!methname || !*methname)
	{
		if (methQName!=NULL)
			methQName->clear();
		return true;
	}
	if (Utils::strcasecmp(methname, "AddReqdComps")==0)
	{
		if (methQName!=NULL)
			methQName->set("AddReqdComps");
		return true;
	}
	if (Utils::strcasecmp(methname, "BuildEnvironment")==0)
	{
		if (methQName!=NULL)
			methQName->set("BuildEnvironment");
		return true;
	}
	if (Utils::strcasecmp(methname, "ClientAlive")==0)
	{
		if (methQName!=NULL)
			methQName->set("ClientAlive");
		return true;
	}
	if (Utils::strcasecmp(methname, "DisplaySettings")==0)
	{
		if (methQName!=NULL)
			methQName->set("DisplaySettings");
		return true;
	}
	if (Utils::strcasecmp(methname, "GetBuildServerDirs")==0)
	{
		if (methQName!=NULL)
			methQName->set("GetBuildServerDirs");
		return true;
	}
	if (Utils::strcasecmp(methname, "GetBuildSetInfo")==0)
	{
		if (methQName!=NULL)
			methQName->set("GetBuildSetInfo");
		return true;
	}
	if (Utils::strcasecmp(methname, "GetComputersForRoxie")==0)
	{
		if (methQName!=NULL)
			methQName->set("GetComputersForRoxie");
		return true;
	}
	if (Utils::strcasecmp(methname, "GetDeployableComps")==0)
	{
		if (methQName!=NULL)
			methQName->set("GetDeployableComps");
		return true;
	}
	if (Utils::strcasecmp(methname, "GetEnvironment")==0)
	{
		if (methQName!=NULL)
			methQName->set("GetEnvironment");
		return true;
	}
	if (Utils::strcasecmp(methname, "GetNavTreeDefn")==0)
	{
		if (methQName!=NULL)
			methQName->set("GetNavTreeDefn");
		return true;
	}
	if (Utils::strcasecmp(methname, "GetSubnetIPAddr")==0)
	{
		if (methQName!=NULL)
			methQName->set("GetSubnetIPAddr");
		return true;
	}
	if (Utils::strcasecmp(methname, "GetSummary")==0)
	{
		if (methQName!=NULL)
			methQName->set("GetSummary");
		return true;
	}
	if (Utils::strcasecmp(methname, "GetValue")==0)
	{
		if (methQName!=NULL)
			methQName->set("GetValue");
		return true;
	}
	if (Utils::strcasecmp(methname, "Graph")==0)
	{
		if (methQName!=NULL)
			methQName->set("Graph");
		return true;
	}
	if (Utils::strcasecmp(methname, "HandleAccessRules")==0)
	{
		if (methQName!=NULL)
			methQName->set("HandleAccessRules");
		return true;
	}
	if (Utils::strcasecmp(methname, "HandleAttributeAdd")==0)
	{
		if (methQName!=NULL)
			methQName->set("HandleAttributeAdd");
		return true;
	}
	if (Utils::strcasecmp(methname, "HandleAttributeDelete")==0)
	{
		if (methQName!=NULL)
			methQName->set("HandleAttributeDelete");
		return true;
	}
	if (Utils::strcasecmp(methname, "HandleBaseAccessControlList")==0)
	{
		if (methQName!=NULL)
			methQName->set("HandleBaseAccessControlList");
		return true;
	}
	if (Utils::strcasecmp(methname, "HandleComponent")==0)
	{
		if (methQName!=NULL)
			methQName->set("HandleComponent");
		return true;
	}
	if (Utils::strcasecmp(methname, "HandleComputer")==0)
	{
		if (methQName!=NULL)
			methQName->set("HandleComputer");
		return true;
	}
	if (Utils::strcasecmp(methname, "HandleEspServiceBindings")==0)
	{
		if (methQName!=NULL)
			methQName->set("HandleEspServiceBindings");
		return true;
	}
	if (Utils::strcasecmp(methname, "HandleInstance")==0)
	{
		if (methQName!=NULL)
			methQName->set("HandleInstance");
		return true;
	}
	if (Utils::strcasecmp(methname, "HandleRows")==0)
	{
		if (methQName!=NULL)
			methQName->set("HandleRows");
		return true;
	}
	if (Utils::strcasecmp(methname, "HandleRoxieOperation")==0)
	{
		if (methQName!=NULL)
			methQName->set("HandleRoxieOperation");
		return true;
	}
	if (Utils::strcasecmp(methname, "HandleThorTopology")==0)
	{
		if (methQName!=NULL)
			methQName->set("HandleThorTopology");
		return true;
	}
	if (Utils::strcasecmp(methname, "HandleTopology")==0)
	{
		if (methQName!=NULL)
			methQName->set("HandleTopology");
		return true;
	}
	if (Utils::strcasecmp(methname, "ImportBuild")==0)
	{
		if (methQName!=NULL)
			methQName->set("ImportBuild");
		return true;
	}
	if (Utils::strcasecmp(methname, "LockEnvironmentForCloud")==0)
	{
		if (methQName!=NULL)
			methQName->set("LockEnvironmentForCloud");
		return true;
	}
	if (Utils::strcasecmp(methname, "NavMenuEvent")==0)
	{
		if (methQName!=NULL)
			methQName->set("NavMenuEvent");
		return true;
	}
	if (Utils::strcasecmp(methname, "NotifyInitSystemSaveEnvForCloud")==0)
	{
		if (methQName!=NULL)
			methQName->set("NotifyInitSystemSaveEnvForCloud");
		return true;
	}
	if (Utils::strcasecmp(methname, "Ping")==0)
	{
		if (methQName!=NULL)
			methQName->set("Ping");
		return true;
	}
	if (Utils::strcasecmp(methname, "RollbackEnvironmentForCloud")==0)
	{
		if (methQName!=NULL)
			methQName->set("RollbackEnvironmentForCloud");
		return true;
	}
	if (Utils::strcasecmp(methname, "SaveEnvironmentForCloud")==0)
	{
		if (methQName!=NULL)
			methQName->set("SaveEnvironmentForCloud");
		return true;
	}
	if (Utils::strcasecmp(methname, "SaveSetting")==0)
	{
		if (methQName!=NULL)
			methQName->set("SaveSetting");
		return true;
	}
	if (Utils::strcasecmp(methname, "SetEnvironment")==0)
	{
		if (methQName!=NULL)
			methQName->set("SetEnvironment");
		return true;
	}
	if (Utils::strcasecmp(methname, "StartDeployment")==0)
	{
		if (methQName!=NULL)
			methQName->set("StartDeployment");
		return true;
	}
	if (Utils::strcasecmp(methname, "UnlockEnvironmentForCloud")==0)
	{
		if (methQName!=NULL)
			methQName->set("UnlockEnvironmentForCloud");
		return true;
	}
	if (Utils::strcasecmp(methname, "UnlockUser")==0)
	{
		if (methQName!=NULL)
			methQName->set("UnlockUser");
		return true;
	}
	return false;
}

bool CWsDeploySoapBinding::qualifyServiceName(IEspContext &context, const char *servname, const char *methname, StringBuffer &servQName, StringBuffer *methQName)
{
	servQName.clear();
	if (!Utils::strcasecmp(servname, "WsDeploy"))
	{
		servQName.append("WsDeploy");
		return qualifyMethodName(context, methname, methQName);
	}
	return qualifySubServiceName(context, servname, methname, servQName, methQName);
}

int CWsDeploySoapBinding::onGetFile(IEspContext &context, CHttpRequest* request, CHttpResponse* response, const char *pathex)
{
	if(request == NULL || response == NULL)
		return -1;
	StringBuffer mimetype;
	MemoryBuffer content;

	StringBuffer filepath;
	getBaseFilePath(filepath);
	if (strchr("\\/", filepath.charAt(filepath.length()-1))==NULL)
		filepath.append("/");
	filepath.append(pathex);
	response->httpContentFromFile(filepath.str());
	response->send();
	return 0;
}

int CWsDeploySoapBinding::onGetForm(IEspContext &context, CHttpRequest* request, CHttpResponse* response, const char *service, const char *method)
{
	if (!stricmp("AddReqdComps", method)) {
		CAddReqdCompsRequest::getMapInfo(context.queryMapInfo());
		CAddReqdCompsResponse::getMapInfo(context.queryMapInfo());
	}
	if (!stricmp("BuildEnvironment", method)) {
		CBuildEnvironmentRequest::getMapInfo(context.queryMapInfo());
		CBuildEnvironmentResponse::getMapInfo(context.queryMapInfo());
	}
	if (!stricmp("ClientAlive", method)) {
		CClientAliveRequest::getMapInfo(context.queryMapInfo());
		CClientAliveResponse::getMapInfo(context.queryMapInfo());
	}
	if (!stricmp("DisplaySettings", method)) {
		CDisplaySettingsRequest::getMapInfo(context.queryMapInfo());
		CDisplaySettingsResponse::getMapInfo(context.queryMapInfo());
	}
	if (!stricmp("GetBuildServerDirs", method)) {
		CGetBuildServerDirsRequest::getMapInfo(context.queryMapInfo());
		CGetBuildServerDirsResponse::getMapInfo(context.queryMapInfo());
	}
	if (!stricmp("GetBuildSetInfo", method)) {
		CGetBuildSetInfoRequest::getMapInfo(context.queryMapInfo());
		CGetBuildSetInfoResponse::getMapInfo(context.queryMapInfo());
	}
	if (!stricmp("GetComputersForRoxie", method)) {
		CGetComputersForRoxieRequest::getMapInfo(context.queryMapInfo());
		CGetComputersForRoxieResponse::getMapInfo(context.queryMapInfo());
	}
	if (!stricmp("GetDeployableComps", method)) {
		CGetDeployableCompsRequest::getMapInfo(context.queryMapInfo());
		CGetDeployableCompsResponse::getMapInfo(context.queryMapInfo());
	}
	if (!stricmp("GetEnvironment", method)) {
		CGetEnvironmentRequest::getMapInfo(context.queryMapInfo());
		CGetEnvironmentResponse::getMapInfo(context.queryMapInfo());
	}
	if (!stricmp("GetNavTreeDefn", method)) {
		CGetNavTreeDefnRequest::getMapInfo(context.queryMapInfo());
		CGetNavTreeDefnResponse::getMapInfo(context.queryMapInfo());
	}
	if (!stricmp("GetSubnetIPAddr", method)) {
		CGetSubnetIPAddrRequest::getMapInfo(context.queryMapInfo());
		CGetSubnetIPAddrResponse::getMapInfo(context.queryMapInfo());
	}
	if (!stricmp("GetSummary", method)) {
		CGetSummaryRequest::getMapInfo(context.queryMapInfo());
		CGetSummaryResponse::getMapInfo(context.queryMapInfo());
	}
	if (!stricmp("GetValue", method)) {
		CGetValueRequest::getMapInfo(context.queryMapInfo());
		CGetValueResponse::getMapInfo(context.queryMapInfo());
	}
	if (!stricmp("Graph", method)) {
		CEmptyRequest::getMapInfo(context.queryMapInfo());
		CGraphResponse::getMapInfo(context.queryMapInfo());
	}
	if (!stricmp("HandleAccessRules", method)) {
		CHandleAccessRulesRequest::getMapInfo(context.queryMapInfo());
		CHandleAccessRulesResponse::getMapInfo(context.queryMapInfo());
	}
	if (!stricmp("HandleAttributeAdd", method)) {
		CHandleAttributeAddRequest::getMapInfo(context.queryMapInfo());
		CHandleAttributeAddResponse::getMapInfo(context.queryMapInfo());
	}
	if (!stricmp("HandleAttributeDelete", method)) {
		CHandleAttributeDeleteRequest::getMapInfo(context.queryMapInfo());
		CHandleAttributeDeleteResponse::getMapInfo(context.queryMapInfo());
	}
	if (!stricmp("HandleBaseAccessControlList", method)) {
		CHandleBaseAccessControlListRequest::getMapInfo(context.queryMapInfo());
		CHandleBaseAccessControlListResponse::getMapInfo(context.queryMapInfo());
	}
	if (!stricmp("HandleComponent", method)) {
		CHandleComponentRequest::getMapInfo(context.queryMapInfo());
		CHandleComponentResponse::getMapInfo(context.queryMapInfo());
	}
	if (!stricmp("HandleComputer", method)) {
		CHandleComputerRequest::getMapInfo(context.queryMapInfo());
		CHandleComputerResponse::getMapInfo(context.queryMapInfo());
	}
	if (!stricmp("HandleEspServiceBindings", method)) {
		CHandleEspServiceBindingsRequest::getMapInfo(context.queryMapInfo());
		CHandleEspServiceBindingsResponse::getMapInfo(context.queryMapInfo());
	}
	if (!stricmp("HandleInstance", method)) {
		CHandleInstanceRequest::getMapInfo(context.queryMapInfo());
		CHandleInstanceResponse::getMapInfo(context.queryMapInfo());
	}
	if (!stricmp("HandleRows", method)) {
		CHandleRowsRequest::getMapInfo(context.queryMapInfo());
		CHandleRowsResponse::getMapInfo(context.queryMapInfo());
	}
	if (!stricmp("HandleRoxieOperation", method)) {
		CHandleRoxieOperationRequest::getMapInfo(context.queryMapInfo());
		CHandleRoxieOperationResponse::getMapInfo(context.queryMapInfo());
	}
	if (!stricmp("HandleThorTopology", method)) {
		CHandleThorTopologyRequest::getMapInfo(context.queryMapInfo());
		CHandleThorTopologyResponse::getMapInfo(context.queryMapInfo());
	}
	if (!stricmp("HandleTopology", method)) {
		CHandleTopologyRequest::getMapInfo(context.queryMapInfo());
		CHandleTopologyResponse::getMapInfo(context.queryMapInfo());
	}
	if (!stricmp("ImportBuild", method)) {
		CImportBuildRequest::getMapInfo(context.queryMapInfo());
		CImportBuildResponse::getMapInfo(context.queryMapInfo());
	}
	if (!stricmp("LockEnvironmentForCloud", method)) {
		CLockEnvironmentForCloudRequest::getMapInfo(context.queryMapInfo());
		CLockEnvironmentForCloudResponse::getMapInfo(context.queryMapInfo());
	}
	if (!stricmp("NavMenuEvent", method)) {
		CNavMenuEventRequest::getMapInfo(context.queryMapInfo());
		CNavMenuEventResponse::getMapInfo(context.queryMapInfo());
	}
	if (!stricmp("NotifyInitSystemSaveEnvForCloud", method)) {
		CNotifyInitSystemSaveEnvForCloudRequest::getMapInfo(context.queryMapInfo());
		CNotifyInitSystemSaveEnvForCloudResponse::getMapInfo(context.queryMapInfo());
	}
	if (!stricmp("Ping", method)) {
		CWsDeployPingRequest::getMapInfo(context.queryMapInfo());
		CWsDeployPingResponse::getMapInfo(context.queryMapInfo());
	}
	if (!stricmp("RollbackEnvironmentForCloud", method)) {
		CRollbackEnvironmentForCloudRequest::getMapInfo(context.queryMapInfo());
		CRollbackEnvironmentForCloudResponse::getMapInfo(context.queryMapInfo());
	}
	if (!stricmp("SaveEnvironmentForCloud", method)) {
		CSaveEnvironmentForCloudRequest::getMapInfo(context.queryMapInfo());
		CSaveEnvironmentForCloudResponse::getMapInfo(context.queryMapInfo());
	}
	if (!stricmp("SaveSetting", method)) {
		CSaveSettingRequest::getMapInfo(context.queryMapInfo());
		CSaveSettingResponse::getMapInfo(context.queryMapInfo());
	}
	if (!stricmp("SetEnvironment", method)) {
		CSetEnvironmentRequest::getMapInfo(context.queryMapInfo());
		CSetEnvironmentResponse::getMapInfo(context.queryMapInfo());
	}
	if (!stricmp("StartDeployment", method)) {
		CStartDeploymentRequest::getMapInfo(context.queryMapInfo());
		CStartDeploymentResponse::getMapInfo(context.queryMapInfo());
	}
	if (!stricmp("UnlockEnvironmentForCloud", method)) {
		CUnlockEnvironmentForCloudRequest::getMapInfo(context.queryMapInfo());
		CUnlockEnvironmentForCloudResponse::getMapInfo(context.queryMapInfo());
	}
	if (!stricmp("UnlockUser", method)) {
		CUnlockUserRequest::getMapInfo(context.queryMapInfo());
		CUnlockUserResponse::getMapInfo(context.queryMapInfo());
	}

	return EspHttpBinding::onGetForm(context, request, response, service, method);
}
int CWsDeploySoapBinding::onGetXForm(IEspContext &context, CHttpRequest* request, CHttpResponse* response, const char *service, const char *method)
{
	return EspHttpBinding::onGetXForm(context, request, response, service, method);
}

int CWsDeploySoapBinding::onGetService(IEspContext &context, CHttpRequest* request, CHttpResponse* response, const char *service, const char *method, const char *pathex)
{
	if(request == NULL || response == NULL)
		return -1;
	return onGetQuery(context, request, response, service, method);
}

 IRpcRequestBinding *CWsDeploySoapBinding::createReqBinding(IEspContext &context, IHttpMessage *ireq, const char *service, const char *method)
{
	CHttpRequest *request=static_cast<CHttpRequest*>(ireq);
	IProperties *props = (request) ? request->queryParameters() : NULL;

	if (!stricmp(method, "AddReqdComps") || !stricmp(method, "AddReqdCompsRequest"))
		return new CAddReqdCompsRequest(&context, "WsDeploy", props, NULL);
	if (!stricmp(method, "BuildEnvironment") || !stricmp(method, "BuildEnvironmentRequest"))
		return new CBuildEnvironmentRequest(&context, "WsDeploy", props, NULL);
	if (!stricmp(method, "ClientAlive") || !stricmp(method, "ClientAliveRequest"))
		return new CClientAliveRequest(&context, "WsDeploy", props, NULL);
	if (!stricmp(method, "DisplaySettings") || !stricmp(method, "DisplaySettingsRequest"))
		return new CDisplaySettingsRequest(&context, "WsDeploy", props, NULL);
	if (!stricmp(method, "GetBuildServerDirs") || !stricmp(method, "GetBuildServerDirsRequest"))
		return new CGetBuildServerDirsRequest(&context, "WsDeploy", props, NULL);
	if (!stricmp(method, "GetBuildSetInfo") || !stricmp(method, "GetBuildSetInfoRequest"))
		return new CGetBuildSetInfoRequest(&context, "WsDeploy", props, NULL);
	if (!stricmp(method, "GetComputersForRoxie") || !stricmp(method, "GetComputersForRoxieRequest"))
		return new CGetComputersForRoxieRequest(&context, "WsDeploy", props, NULL);
	if (!stricmp(method, "GetDeployableComps") || !stricmp(method, "GetDeployableCompsRequest"))
		return new CGetDeployableCompsRequest(&context, "WsDeploy", props, NULL);
	if (!stricmp(method, "GetEnvironment") || !stricmp(method, "GetEnvironmentRequest"))
		return new CGetEnvironmentRequest(&context, "WsDeploy", props, NULL);
	if (!stricmp(method, "GetNavTreeDefn") || !stricmp(method, "GetNavTreeDefnRequest"))
		return new CGetNavTreeDefnRequest(&context, "WsDeploy", props, NULL);
	if (!stricmp(method, "GetSubnetIPAddr") || !stricmp(method, "GetSubnetIPAddrRequest"))
		return new CGetSubnetIPAddrRequest(&context, "WsDeploy", props, NULL);
	if (!stricmp(method, "GetSummary") || !stricmp(method, "GetSummaryRequest"))
		return new CGetSummaryRequest(&context, "WsDeploy", props, NULL);
	if (!stricmp(method, "GetValue") || !stricmp(method, "GetValueRequest"))
		return new CGetValueRequest(&context, "WsDeploy", props, NULL);
	if (!stricmp(method, "Graph") || !stricmp(method, "EmptyRequest"))
		return new CEmptyRequest(&context, "WsDeploy", props, NULL);
	if (!stricmp(method, "HandleAccessRules") || !stricmp(method, "HandleAccessRulesRequest"))
		return new CHandleAccessRulesRequest(&context, "WsDeploy", props, NULL);
	if (!stricmp(method, "HandleAttributeAdd") || !stricmp(method, "HandleAttributeAddRequest"))
		return new CHandleAttributeAddRequest(&context, "WsDeploy", props, NULL);
	if (!stricmp(method, "HandleAttributeDelete") || !stricmp(method, "HandleAttributeDeleteRequest"))
		return new CHandleAttributeDeleteRequest(&context, "WsDeploy", props, NULL);
	if (!stricmp(method, "HandleBaseAccessControlList") || !stricmp(method, "HandleBaseAccessControlListRequest"))
		return new CHandleBaseAccessControlListRequest(&context, "WsDeploy", props, NULL);
	if (!stricmp(method, "HandleComponent") || !stricmp(method, "HandleComponentRequest"))
		return new CHandleComponentRequest(&context, "WsDeploy", props, NULL);
	if (!stricmp(method, "HandleComputer") || !stricmp(method, "HandleComputerRequest"))
		return new CHandleComputerRequest(&context, "WsDeploy", props, NULL);
	if (!stricmp(method, "HandleEspServiceBindings") || !stricmp(method, "HandleEspServiceBindingsRequest"))
		return new CHandleEspServiceBindingsRequest(&context, "WsDeploy", props, NULL);
	if (!stricmp(method, "HandleInstance") || !stricmp(method, "HandleInstanceRequest"))
		return new CHandleInstanceRequest(&context, "WsDeploy", props, NULL);
	if (!stricmp(method, "HandleRows") || !stricmp(method, "HandleRowsRequest"))
		return new CHandleRowsRequest(&context, "WsDeploy", props, NULL);
	if (!stricmp(method, "HandleRoxieOperation") || !stricmp(method, "HandleRoxieOperationRequest"))
		return new CHandleRoxieOperationRequest(&context, "WsDeploy", props, NULL);
	if (!stricmp(method, "HandleThorTopology") || !stricmp(method, "HandleThorTopologyRequest"))
		return new CHandleThorTopologyRequest(&context, "WsDeploy", props, NULL);
	if (!stricmp(method, "HandleTopology") || !stricmp(method, "HandleTopologyRequest"))
		return new CHandleTopologyRequest(&context, "WsDeploy", props, NULL);
	if (!stricmp(method, "ImportBuild") || !stricmp(method, "ImportBuildRequest"))
		return new CImportBuildRequest(&context, "WsDeploy", props, NULL);
	if (!stricmp(method, "LockEnvironmentForCloud") || !stricmp(method, "LockEnvironmentForCloudRequest"))
		return new CLockEnvironmentForCloudRequest(&context, "WsDeploy", props, NULL);
	if (!stricmp(method, "NavMenuEvent") || !stricmp(method, "NavMenuEventRequest"))
		return new CNavMenuEventRequest(&context, "WsDeploy", props, NULL);
	if (!stricmp(method, "NotifyInitSystemSaveEnvForCloud") || !stricmp(method, "NotifyInitSystemSaveEnvForCloudRequest"))
		return new CNotifyInitSystemSaveEnvForCloudRequest(&context, "WsDeploy", props, NULL);
	if (!stricmp(method, "Ping") || !stricmp(method, "WsDeployPingRequest"))
		return new CWsDeployPingRequest(&context, "WsDeploy", props, NULL);
	if (!stricmp(method, "RollbackEnvironmentForCloud") || !stricmp(method, "RollbackEnvironmentForCloudRequest"))
		return new CRollbackEnvironmentForCloudRequest(&context, "WsDeploy", props, NULL);
	if (!stricmp(method, "SaveEnvironmentForCloud") || !stricmp(method, "SaveEnvironmentForCloudRequest"))
		return new CSaveEnvironmentForCloudRequest(&context, "WsDeploy", props, NULL);
	if (!stricmp(method, "SaveSetting") || !stricmp(method, "SaveSettingRequest"))
		return new CSaveSettingRequest(&context, "WsDeploy", props, NULL);
	if (!stricmp(method, "SetEnvironment") || !stricmp(method, "SetEnvironmentRequest"))
		return new CSetEnvironmentRequest(&context, "WsDeploy", props, NULL);
	if (!stricmp(method, "StartDeployment") || !stricmp(method, "StartDeploymentRequest"))
		return new CStartDeploymentRequest(&context, "WsDeploy", props, NULL);
	if (!stricmp(method, "UnlockEnvironmentForCloud") || !stricmp(method, "UnlockEnvironmentForCloudRequest"))
		return new CUnlockEnvironmentForCloudRequest(&context, "WsDeploy", props, NULL);
	if (!stricmp(method, "UnlockUser") || !stricmp(method, "UnlockUserRequest"))
		return new CUnlockUserRequest(&context, "WsDeploy", props, NULL);
	return NULL;
}

int CWsDeploySoapBinding::onGetInstantQuery(IEspContext &context, CHttpRequest* request, CHttpResponse* response, const char *service, const char *method)
{
	if(request == NULL || response == NULL)
		return -1;
	StringBuffer respStr;
	Owned<IEspWsDeploy> iserv = (IEspWsDeploy*)getService();
	if(iserv == NULL)
	{
		respStr.append("Service not available");
		response->setContent(respStr.str());
		response->setContentType("text/html");
		response->send();
	}
	else
	{
		Owned<CSoapResponseBinding> esp_response;
		StringBuffer source;
		IEspContext& context = *request->queryContext();
		if(!stricmp(method, "AddReqdComps")||!stricmp(method, "AddReqdCompsRequest"))
		{
			Owned<CAddReqdCompsRequest> esp_request = new CAddReqdCompsRequest(&context, "WsDeploy", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			CAddReqdCompsResponse* resp = new CAddReqdCompsResponse("WsDeploy");
			esp_response.setown(resp);
			MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
			source.setf("WsDeploy::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				if(accessmap.ordinality()>0)
					onFeaturesAuthorize(context, accessmap, "WsDeploy", "AddReqdComps");
				iserv->onAddReqdComps(context, *esp_request.get(), *resp);
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "WsDeploy", "AddReqdComps", StringBuffer(getCFD()).append("xslt/exceptions.xslt").str()))
				return 0;
		}
		if(!stricmp(method, "BuildEnvironment")||!stricmp(method, "BuildEnvironmentRequest"))
		{
			Owned<CBuildEnvironmentRequest> esp_request = new CBuildEnvironmentRequest(&context, "WsDeploy", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			CBuildEnvironmentResponse* resp = new CBuildEnvironmentResponse("WsDeploy");
			esp_response.setown(resp);
			MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
			source.setf("WsDeploy::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				if(accessmap.ordinality()>0)
					onFeaturesAuthorize(context, accessmap, "WsDeploy", "BuildEnvironment");
				iserv->onBuildEnvironment(context, *esp_request.get(), *resp);
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "WsDeploy", "BuildEnvironment", StringBuffer(getCFD()).append("xslt/exceptions.xslt").str()))
				return 0;
		}
		if(!stricmp(method, "ClientAlive")||!stricmp(method, "ClientAliveRequest"))
		{
			Owned<CClientAliveRequest> esp_request = new CClientAliveRequest(&context, "WsDeploy", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			CClientAliveResponse* resp = new CClientAliveResponse("WsDeploy");
			esp_response.setown(resp);
			MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
			source.setf("WsDeploy::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				if(accessmap.ordinality()>0)
					onFeaturesAuthorize(context, accessmap, "WsDeploy", "ClientAlive");
				iserv->onClientAlive(context, *esp_request.get(), *resp);
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "WsDeploy", "ClientAlive", StringBuffer(getCFD()).append("xslt/exceptions.xslt").str()))
				return 0;
		}
		if(!stricmp(method, "DisplaySettings")||!stricmp(method, "DisplaySettingsRequest"))
		{
			Owned<CDisplaySettingsRequest> esp_request = new CDisplaySettingsRequest(&context, "WsDeploy", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			Owned<CDisplaySettingsResponse> esp_response = new CDisplaySettingsResponse("WsDeploy");
			StringBuffer source;
			source.appendf("WsDeploy::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				iserv->onDisplaySettings(*request->queryContext(), *esp_request.get(), *esp_response.get());
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "WsDeploy", "DisplaySettings", StringBuffer(getCFD()).append("xslt/exceptions.xslt").str()))
				return 0;
			if (canRedirect(*request) && esp_response->getRedirectUrl() && *esp_response->getRedirectUrl())
			{
				response->redirect(*request, esp_response->getRedirectUrl());
			}
			else
			{
				IProperties *props=request->queryParameters();
				if (skipXslt(context))
				{
					MemoryBuffer content;
					StringBuffer mimetype;
					esp_response->appendContent(&context,content, mimetype);
					onBeforeSendResponse(context,request,content,service,method);
					response->setContent(content.length(), content.toByteArray());
					response->setContentType(mimetype.str());
				}
				else
				{
					StringBuffer xml;
					StringBuffer sResponse;
					esp_response->serializeStruct(&context, xml, NULL);

					xslTransform(xml.str(), StringBuffer(getCFD()).append("xslt/ui_configmgr.xslt").str(), sResponse.clear(), context.queryXslParameters());
					response->setContentType("text/html");
					response->setContent(sResponse.str());
				}
				response->send();
			}
			return 0;
		}
		if(!stricmp(method, "GetBuildServerDirs")||!stricmp(method, "GetBuildServerDirsRequest"))
		{
			Owned<CGetBuildServerDirsRequest> esp_request = new CGetBuildServerDirsRequest(&context, "WsDeploy", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			CGetBuildServerDirsResponse* resp = new CGetBuildServerDirsResponse("WsDeploy");
			esp_response.setown(resp);
			MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
			source.setf("WsDeploy::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				if(accessmap.ordinality()>0)
					onFeaturesAuthorize(context, accessmap, "WsDeploy", "GetBuildServerDirs");
				iserv->onGetBuildServerDirs(context, *esp_request.get(), *resp);
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "WsDeploy", "GetBuildServerDirs", StringBuffer(getCFD()).append("xslt/exceptions.xslt").str()))
				return 0;
		}
		if(!stricmp(method, "GetBuildSetInfo")||!stricmp(method, "GetBuildSetInfoRequest"))
		{
			Owned<CGetBuildSetInfoRequest> esp_request = new CGetBuildSetInfoRequest(&context, "WsDeploy", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			CGetBuildSetInfoResponse* resp = new CGetBuildSetInfoResponse("WsDeploy");
			esp_response.setown(resp);
			MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
			source.setf("WsDeploy::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				if(accessmap.ordinality()>0)
					onFeaturesAuthorize(context, accessmap, "WsDeploy", "GetBuildSetInfo");
				iserv->onGetBuildSetInfo(context, *esp_request.get(), *resp);
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "WsDeploy", "GetBuildSetInfo", StringBuffer(getCFD()).append("xslt/exceptions.xslt").str()))
				return 0;
		}
		if(!stricmp(method, "GetComputersForRoxie")||!stricmp(method, "GetComputersForRoxieRequest"))
		{
			Owned<CGetComputersForRoxieRequest> esp_request = new CGetComputersForRoxieRequest(&context, "WsDeploy", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			CGetComputersForRoxieResponse* resp = new CGetComputersForRoxieResponse("WsDeploy");
			esp_response.setown(resp);
			MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
			source.setf("WsDeploy::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				if(accessmap.ordinality()>0)
					onFeaturesAuthorize(context, accessmap, "WsDeploy", "GetComputersForRoxie");
				iserv->onGetComputersForRoxie(context, *esp_request.get(), *resp);
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "WsDeploy", "GetComputersForRoxie", StringBuffer(getCFD()).append("xslt/exceptions.xslt").str()))
				return 0;
		}
		if(!stricmp(method, "GetDeployableComps")||!stricmp(method, "GetDeployableCompsRequest"))
		{
			Owned<CGetDeployableCompsRequest> esp_request = new CGetDeployableCompsRequest(&context, "WsDeploy", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			Owned<CGetDeployableCompsResponse> esp_response = new CGetDeployableCompsResponse("WsDeploy");
			StringBuffer source;
			source.appendf("WsDeploy::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				iserv->onGetDeployableComps(*request->queryContext(), *esp_request.get(), *esp_response.get());
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "WsDeploy", "GetDeployableComps", StringBuffer(getCFD()).append("xslt/exceptions.xslt").str()))
				return 0;
			if (canRedirect(*request) && esp_response->getRedirectUrl() && *esp_response->getRedirectUrl())
			{
				response->redirect(*request, esp_response->getRedirectUrl());
			}
			else
			{
				IProperties *props=request->queryParameters();
				if (skipXslt(context))
				{
					MemoryBuffer content;
					StringBuffer mimetype;
					esp_response->appendContent(&context,content, mimetype);
					onBeforeSendResponse(context,request,content,service,method);
					response->setContent(content.length(), content.toByteArray());
					response->setContentType(mimetype.str());
				}
				else
				{
					StringBuffer xml;
					StringBuffer sResponse;
					esp_response->serializeStruct(&context, xml, NULL);

					xslTransform(xml.str(), StringBuffer(getCFD()).append("xslt/ui_configmgr.xslt").str(), sResponse.clear(), context.queryXslParameters());
					response->setContentType("text/html");
					response->setContent(sResponse.str());
				}
				response->send();
			}
			return 0;
		}
		if(!stricmp(method, "GetEnvironment")||!stricmp(method, "GetEnvironmentRequest"))
		{
			Owned<CGetEnvironmentRequest> esp_request = new CGetEnvironmentRequest(&context, "WsDeploy", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			CGetEnvironmentResponse* resp = new CGetEnvironmentResponse("WsDeploy");
			esp_response.setown(resp);
			MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
			source.setf("WsDeploy::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				if(accessmap.ordinality()>0)
					onFeaturesAuthorize(context, accessmap, "WsDeploy", "GetEnvironment");
				iserv->onGetEnvironment(context, *esp_request.get(), *resp);
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "WsDeploy", "GetEnvironment", StringBuffer(getCFD()).append("xslt/exceptions.xslt").str()))
				return 0;
		}
		if(!stricmp(method, "GetNavTreeDefn")||!stricmp(method, "GetNavTreeDefnRequest"))
		{
			Owned<CGetNavTreeDefnRequest> esp_request = new CGetNavTreeDefnRequest(&context, "WsDeploy", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			CGetNavTreeDefnResponse* resp = new CGetNavTreeDefnResponse("WsDeploy");
			esp_response.setown(resp);
			MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
			source.setf("WsDeploy::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				if(accessmap.ordinality()>0)
					onFeaturesAuthorize(context, accessmap, "WsDeploy", "GetNavTreeDefn");
				iserv->onGetNavTreeDefn(context, *esp_request.get(), *resp);
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "WsDeploy", "GetNavTreeDefn", StringBuffer(getCFD()).append("xslt/exceptions.xslt").str()))
				return 0;
		}
		if(!stricmp(method, "GetSubnetIPAddr")||!stricmp(method, "GetSubnetIPAddrRequest"))
		{
			Owned<CGetSubnetIPAddrRequest> esp_request = new CGetSubnetIPAddrRequest(&context, "WsDeploy", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			CGetSubnetIPAddrResponse* resp = new CGetSubnetIPAddrResponse("WsDeploy");
			esp_response.setown(resp);
			MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
			source.setf("WsDeploy::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				if(accessmap.ordinality()>0)
					onFeaturesAuthorize(context, accessmap, "WsDeploy", "GetSubnetIPAddr");
				iserv->onGetSubnetIPAddr(context, *esp_request.get(), *resp);
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "WsDeploy", "GetSubnetIPAddr", StringBuffer(getCFD()).append("xslt/exceptions.xslt").str()))
				return 0;
		}
		if(!stricmp(method, "GetSummary")||!stricmp(method, "GetSummaryRequest"))
		{
			Owned<CGetSummaryRequest> esp_request = new CGetSummaryRequest(&context, "WsDeploy", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			CGetSummaryResponse* resp = new CGetSummaryResponse("WsDeploy");
			esp_response.setown(resp);
			MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
			source.setf("WsDeploy::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				if(accessmap.ordinality()>0)
					onFeaturesAuthorize(context, accessmap, "WsDeploy", "GetSummary");
				iserv->onGetSummary(context, *esp_request.get(), *resp);
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "WsDeploy", "GetSummary", StringBuffer(getCFD()).append("xslt/exceptions.xslt").str()))
				return 0;
		}
		if(!stricmp(method, "GetValue")||!stricmp(method, "GetValueRequest"))
		{
			Owned<CGetValueRequest> esp_request = new CGetValueRequest(&context, "WsDeploy", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			CGetValueResponse* resp = new CGetValueResponse("WsDeploy");
			esp_response.setown(resp);
			MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
			source.setf("WsDeploy::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				if(accessmap.ordinality()>0)
					onFeaturesAuthorize(context, accessmap, "WsDeploy", "GetValue");
				iserv->onGetValue(context, *esp_request.get(), *resp);
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "WsDeploy", "GetValue", StringBuffer(getCFD()).append("xslt/exceptions.xslt").str()))
				return 0;
		}
		if(!stricmp(method, "Graph")||!stricmp(method, "EmptyRequest"))
		{
			Owned<CEmptyRequest> esp_request = new CEmptyRequest(&context, "WsDeploy", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			Owned<CGraphResponse> esp_response = new CGraphResponse("WsDeploy");
			StringBuffer source;
			source.appendf("WsDeploy::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				iserv->onGraph(*request->queryContext(), *esp_request.get(), *esp_response.get());
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "WsDeploy", "Graph", StringBuffer(getCFD()).append("xslt/exceptions.xslt").str()))
				return 0;
			if (canRedirect(*request) && esp_response->getRedirectUrl() && *esp_response->getRedirectUrl())
			{
				response->redirect(*request, esp_response->getRedirectUrl());
			}
			else
			{
				IProperties *props=request->queryParameters();
				if (skipXslt(context))
				{
					MemoryBuffer content;
					StringBuffer mimetype;
					esp_response->appendContent(&context,content, mimetype);
					onBeforeSendResponse(context,request,content,service,method);
					response->setContent(content.length(), content.toByteArray());
					response->setContentType(mimetype.str());
				}
				else
				{
					StringBuffer xml;
					StringBuffer sResponse;
					esp_response->serializeStruct(&context, xml, NULL);

					xslTransform(xml.str(), StringBuffer(getCFD()).append("xslt/graph_display.xsl").str(), sResponse.clear(), context.queryXslParameters());
					response->setContentType("text/html");
					response->setContent(sResponse.str());
				}
				response->send();
			}
			return 0;
		}
		if(!stricmp(method, "HandleAccessRules")||!stricmp(method, "HandleAccessRulesRequest"))
		{
			Owned<CHandleAccessRulesRequest> esp_request = new CHandleAccessRulesRequest(&context, "WsDeploy", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			CHandleAccessRulesResponse* resp = new CHandleAccessRulesResponse("WsDeploy");
			esp_response.setown(resp);
			MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
			source.setf("WsDeploy::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				if(accessmap.ordinality()>0)
					onFeaturesAuthorize(context, accessmap, "WsDeploy", "HandleAccessRules");
				iserv->onHandleAccessRules(context, *esp_request.get(), *resp);
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "WsDeploy", "HandleAccessRules", StringBuffer(getCFD()).append("xslt/exceptions.xslt").str()))
				return 0;
		}
		if(!stricmp(method, "HandleAttributeAdd")||!stricmp(method, "HandleAttributeAddRequest"))
		{
			Owned<CHandleAttributeAddRequest> esp_request = new CHandleAttributeAddRequest(&context, "WsDeploy", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			CHandleAttributeAddResponse* resp = new CHandleAttributeAddResponse("WsDeploy");
			esp_response.setown(resp);
			MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
			source.setf("WsDeploy::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				if(accessmap.ordinality()>0)
					onFeaturesAuthorize(context, accessmap, "WsDeploy", "HandleAttributeAdd");
				iserv->onHandleAttributeAdd(context, *esp_request.get(), *resp);
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "WsDeploy", "HandleAttributeAdd", StringBuffer(getCFD()).append("xslt/exceptions.xslt").str()))
				return 0;
		}
		if(!stricmp(method, "HandleAttributeDelete")||!stricmp(method, "HandleAttributeDeleteRequest"))
		{
			Owned<CHandleAttributeDeleteRequest> esp_request = new CHandleAttributeDeleteRequest(&context, "WsDeploy", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			CHandleAttributeDeleteResponse* resp = new CHandleAttributeDeleteResponse("WsDeploy");
			esp_response.setown(resp);
			MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
			source.setf("WsDeploy::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				if(accessmap.ordinality()>0)
					onFeaturesAuthorize(context, accessmap, "WsDeploy", "HandleAttributeDelete");
				iserv->onHandleAttributeDelete(context, *esp_request.get(), *resp);
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "WsDeploy", "HandleAttributeDelete", StringBuffer(getCFD()).append("xslt/exceptions.xslt").str()))
				return 0;
		}
		if(!stricmp(method, "HandleBaseAccessControlList")||!stricmp(method, "HandleBaseAccessControlListRequest"))
		{
			Owned<CHandleBaseAccessControlListRequest> esp_request = new CHandleBaseAccessControlListRequest(&context, "WsDeploy", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			CHandleBaseAccessControlListResponse* resp = new CHandleBaseAccessControlListResponse("WsDeploy");
			esp_response.setown(resp);
			MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
			source.setf("WsDeploy::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				if(accessmap.ordinality()>0)
					onFeaturesAuthorize(context, accessmap, "WsDeploy", "HandleBaseAccessControlList");
				iserv->onHandleBaseAccessControlList(context, *esp_request.get(), *resp);
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "WsDeploy", "HandleBaseAccessControlList", StringBuffer(getCFD()).append("xslt/exceptions.xslt").str()))
				return 0;
		}
		if(!stricmp(method, "HandleComponent")||!stricmp(method, "HandleComponentRequest"))
		{
			Owned<CHandleComponentRequest> esp_request = new CHandleComponentRequest(&context, "WsDeploy", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			CHandleComponentResponse* resp = new CHandleComponentResponse("WsDeploy");
			esp_response.setown(resp);
			MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
			source.setf("WsDeploy::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				if(accessmap.ordinality()>0)
					onFeaturesAuthorize(context, accessmap, "WsDeploy", "HandleComponent");
				iserv->onHandleComponent(context, *esp_request.get(), *resp);
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "WsDeploy", "HandleComponent", StringBuffer(getCFD()).append("xslt/exceptions.xslt").str()))
				return 0;
		}
		if(!stricmp(method, "HandleComputer")||!stricmp(method, "HandleComputerRequest"))
		{
			Owned<CHandleComputerRequest> esp_request = new CHandleComputerRequest(&context, "WsDeploy", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			CHandleComputerResponse* resp = new CHandleComputerResponse("WsDeploy");
			esp_response.setown(resp);
			MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
			source.setf("WsDeploy::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				if(accessmap.ordinality()>0)
					onFeaturesAuthorize(context, accessmap, "WsDeploy", "HandleComputer");
				iserv->onHandleComputer(context, *esp_request.get(), *resp);
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "WsDeploy", "HandleComputer", StringBuffer(getCFD()).append("xslt/exceptions.xslt").str()))
				return 0;
		}
		if(!stricmp(method, "HandleEspServiceBindings")||!stricmp(method, "HandleEspServiceBindingsRequest"))
		{
			Owned<CHandleEspServiceBindingsRequest> esp_request = new CHandleEspServiceBindingsRequest(&context, "WsDeploy", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			CHandleEspServiceBindingsResponse* resp = new CHandleEspServiceBindingsResponse("WsDeploy");
			esp_response.setown(resp);
			MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
			source.setf("WsDeploy::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				if(accessmap.ordinality()>0)
					onFeaturesAuthorize(context, accessmap, "WsDeploy", "HandleEspServiceBindings");
				iserv->onHandleEspServiceBindings(context, *esp_request.get(), *resp);
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "WsDeploy", "HandleEspServiceBindings", StringBuffer(getCFD()).append("xslt/exceptions.xslt").str()))
				return 0;
		}
		if(!stricmp(method, "HandleInstance")||!stricmp(method, "HandleInstanceRequest"))
		{
			Owned<CHandleInstanceRequest> esp_request = new CHandleInstanceRequest(&context, "WsDeploy", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			CHandleInstanceResponse* resp = new CHandleInstanceResponse("WsDeploy");
			esp_response.setown(resp);
			MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
			source.setf("WsDeploy::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				if(accessmap.ordinality()>0)
					onFeaturesAuthorize(context, accessmap, "WsDeploy", "HandleInstance");
				iserv->onHandleInstance(context, *esp_request.get(), *resp);
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "WsDeploy", "HandleInstance", StringBuffer(getCFD()).append("xslt/exceptions.xslt").str()))
				return 0;
		}
		if(!stricmp(method, "HandleRows")||!stricmp(method, "HandleRowsRequest"))
		{
			Owned<CHandleRowsRequest> esp_request = new CHandleRowsRequest(&context, "WsDeploy", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			CHandleRowsResponse* resp = new CHandleRowsResponse("WsDeploy");
			esp_response.setown(resp);
			MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
			source.setf("WsDeploy::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				if(accessmap.ordinality()>0)
					onFeaturesAuthorize(context, accessmap, "WsDeploy", "HandleRows");
				iserv->onHandleRows(context, *esp_request.get(), *resp);
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "WsDeploy", "HandleRows", StringBuffer(getCFD()).append("xslt/exceptions.xslt").str()))
				return 0;
		}
		if(!stricmp(method, "HandleRoxieOperation")||!stricmp(method, "HandleRoxieOperationRequest"))
		{
			Owned<CHandleRoxieOperationRequest> esp_request = new CHandleRoxieOperationRequest(&context, "WsDeploy", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			CHandleRoxieOperationResponse* resp = new CHandleRoxieOperationResponse("WsDeploy");
			esp_response.setown(resp);
			MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
			source.setf("WsDeploy::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				if(accessmap.ordinality()>0)
					onFeaturesAuthorize(context, accessmap, "WsDeploy", "HandleRoxieOperation");
				iserv->onHandleRoxieOperation(context, *esp_request.get(), *resp);
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "WsDeploy", "HandleRoxieOperation", StringBuffer(getCFD()).append("xslt/exceptions.xslt").str()))
				return 0;
		}
		if(!stricmp(method, "HandleThorTopology")||!stricmp(method, "HandleThorTopologyRequest"))
		{
			Owned<CHandleThorTopologyRequest> esp_request = new CHandleThorTopologyRequest(&context, "WsDeploy", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			CHandleThorTopologyResponse* resp = new CHandleThorTopologyResponse("WsDeploy");
			esp_response.setown(resp);
			MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
			source.setf("WsDeploy::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				if(accessmap.ordinality()>0)
					onFeaturesAuthorize(context, accessmap, "WsDeploy", "HandleThorTopology");
				iserv->onHandleThorTopology(context, *esp_request.get(), *resp);
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "WsDeploy", "HandleThorTopology", StringBuffer(getCFD()).append("xslt/exceptions.xslt").str()))
				return 0;
		}
		if(!stricmp(method, "HandleTopology")||!stricmp(method, "HandleTopologyRequest"))
		{
			Owned<CHandleTopologyRequest> esp_request = new CHandleTopologyRequest(&context, "WsDeploy", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			CHandleTopologyResponse* resp = new CHandleTopologyResponse("WsDeploy");
			esp_response.setown(resp);
			MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
			source.setf("WsDeploy::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				if(accessmap.ordinality()>0)
					onFeaturesAuthorize(context, accessmap, "WsDeploy", "HandleTopology");
				iserv->onHandleTopology(context, *esp_request.get(), *resp);
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "WsDeploy", "HandleTopology", StringBuffer(getCFD()).append("xslt/exceptions.xslt").str()))
				return 0;
		}
		if(!stricmp(method, "ImportBuild")||!stricmp(method, "ImportBuildRequest"))
		{
			Owned<CImportBuildRequest> esp_request = new CImportBuildRequest(&context, "WsDeploy", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			CImportBuildResponse* resp = new CImportBuildResponse("WsDeploy");
			esp_response.setown(resp);
			MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
			source.setf("WsDeploy::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				if(accessmap.ordinality()>0)
					onFeaturesAuthorize(context, accessmap, "WsDeploy", "ImportBuild");
				iserv->onImportBuild(context, *esp_request.get(), *resp);
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "WsDeploy", "ImportBuild", StringBuffer(getCFD()).append("xslt/exceptions.xslt").str()))
				return 0;
		}
		if(!stricmp(method, "LockEnvironmentForCloud")||!stricmp(method, "LockEnvironmentForCloudRequest"))
		{
			Owned<CLockEnvironmentForCloudRequest> esp_request = new CLockEnvironmentForCloudRequest(&context, "WsDeploy", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			CLockEnvironmentForCloudResponse* resp = new CLockEnvironmentForCloudResponse("WsDeploy");
			esp_response.setown(resp);
			MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
			source.setf("WsDeploy::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				if(accessmap.ordinality()>0)
					onFeaturesAuthorize(context, accessmap, "WsDeploy", "LockEnvironmentForCloud");
				iserv->onLockEnvironmentForCloud(context, *esp_request.get(), *resp);
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "WsDeploy", "LockEnvironmentForCloud", StringBuffer(getCFD()).append("xslt/exceptions.xslt").str()))
				return 0;
		}
		if(!stricmp(method, "NavMenuEvent")||!stricmp(method, "NavMenuEventRequest"))
		{
			Owned<CNavMenuEventRequest> esp_request = new CNavMenuEventRequest(&context, "WsDeploy", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			CNavMenuEventResponse* resp = new CNavMenuEventResponse("WsDeploy");
			esp_response.setown(resp);
			MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
			source.setf("WsDeploy::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				if(accessmap.ordinality()>0)
					onFeaturesAuthorize(context, accessmap, "WsDeploy", "NavMenuEvent");
				iserv->onNavMenuEvent(context, *esp_request.get(), *resp);
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "WsDeploy", "NavMenuEvent", StringBuffer(getCFD()).append("xslt/exceptions.xslt").str()))
				return 0;
		}
		if(!stricmp(method, "NotifyInitSystemSaveEnvForCloud")||!stricmp(method, "NotifyInitSystemSaveEnvForCloudRequest"))
		{
			Owned<CNotifyInitSystemSaveEnvForCloudRequest> esp_request = new CNotifyInitSystemSaveEnvForCloudRequest(&context, "WsDeploy", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			CNotifyInitSystemSaveEnvForCloudResponse* resp = new CNotifyInitSystemSaveEnvForCloudResponse("WsDeploy");
			esp_response.setown(resp);
			MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
			source.setf("WsDeploy::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				if(accessmap.ordinality()>0)
					onFeaturesAuthorize(context, accessmap, "WsDeploy", "NotifyInitSystemSaveEnvForCloud");
				iserv->onNotifyInitSystemSaveEnvForCloud(context, *esp_request.get(), *resp);
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "WsDeploy", "NotifyInitSystemSaveEnvForCloud", StringBuffer(getCFD()).append("xslt/exceptions.xslt").str()))
				return 0;
		}
		if(!stricmp(method, "Ping")||!stricmp(method, "WsDeployPingRequest"))
		{
			Owned<CWsDeployPingRequest> esp_request = new CWsDeployPingRequest(&context, "WsDeploy", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			CWsDeployPingResponse* resp = new CWsDeployPingResponse("WsDeploy");
			esp_response.setown(resp);
			MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
			source.setf("WsDeploy::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				if(accessmap.ordinality()>0)
					onFeaturesAuthorize(context, accessmap, "WsDeploy", "Ping");
				iserv->onPing(context, *esp_request.get(), *resp);
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "WsDeploy", "Ping", StringBuffer(getCFD()).append("xslt/exceptions.xslt").str()))
				return 0;
		}
		if(!stricmp(method, "RollbackEnvironmentForCloud")||!stricmp(method, "RollbackEnvironmentForCloudRequest"))
		{
			Owned<CRollbackEnvironmentForCloudRequest> esp_request = new CRollbackEnvironmentForCloudRequest(&context, "WsDeploy", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			CRollbackEnvironmentForCloudResponse* resp = new CRollbackEnvironmentForCloudResponse("WsDeploy");
			esp_response.setown(resp);
			MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
			source.setf("WsDeploy::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				if(accessmap.ordinality()>0)
					onFeaturesAuthorize(context, accessmap, "WsDeploy", "RollbackEnvironmentForCloud");
				iserv->onRollbackEnvironmentForCloud(context, *esp_request.get(), *resp);
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "WsDeploy", "RollbackEnvironmentForCloud", StringBuffer(getCFD()).append("xslt/exceptions.xslt").str()))
				return 0;
		}
		if(!stricmp(method, "SaveEnvironmentForCloud")||!stricmp(method, "SaveEnvironmentForCloudRequest"))
		{
			Owned<CSaveEnvironmentForCloudRequest> esp_request = new CSaveEnvironmentForCloudRequest(&context, "WsDeploy", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			CSaveEnvironmentForCloudResponse* resp = new CSaveEnvironmentForCloudResponse("WsDeploy");
			esp_response.setown(resp);
			MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
			source.setf("WsDeploy::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				if(accessmap.ordinality()>0)
					onFeaturesAuthorize(context, accessmap, "WsDeploy", "SaveEnvironmentForCloud");
				iserv->onSaveEnvironmentForCloud(context, *esp_request.get(), *resp);
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "WsDeploy", "SaveEnvironmentForCloud", StringBuffer(getCFD()).append("xslt/exceptions.xslt").str()))
				return 0;
		}
		if(!stricmp(method, "SaveSetting")||!stricmp(method, "SaveSettingRequest"))
		{
			Owned<CSaveSettingRequest> esp_request = new CSaveSettingRequest(&context, "WsDeploy", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			CSaveSettingResponse* resp = new CSaveSettingResponse("WsDeploy");
			esp_response.setown(resp);
			MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
			source.setf("WsDeploy::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				if(accessmap.ordinality()>0)
					onFeaturesAuthorize(context, accessmap, "WsDeploy", "SaveSetting");
				iserv->onSaveSetting(context, *esp_request.get(), *resp);
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "WsDeploy", "SaveSetting", StringBuffer(getCFD()).append("xslt/exceptions.xslt").str()))
				return 0;
		}
		if(!stricmp(method, "SetEnvironment")||!stricmp(method, "SetEnvironmentRequest"))
		{
			Owned<CSetEnvironmentRequest> esp_request = new CSetEnvironmentRequest(&context, "WsDeploy", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			CSetEnvironmentResponse* resp = new CSetEnvironmentResponse("WsDeploy");
			esp_response.setown(resp);
			MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
			source.setf("WsDeploy::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				if(accessmap.ordinality()>0)
					onFeaturesAuthorize(context, accessmap, "WsDeploy", "SetEnvironment");
				iserv->onSetEnvironment(context, *esp_request.get(), *resp);
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "WsDeploy", "SetEnvironment", StringBuffer(getCFD()).append("xslt/exceptions.xslt").str()))
				return 0;
		}
		if(!stricmp(method, "StartDeployment")||!stricmp(method, "StartDeploymentRequest"))
		{
			Owned<CStartDeploymentRequest> esp_request = new CStartDeploymentRequest(&context, "WsDeploy", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			CStartDeploymentResponse* resp = new CStartDeploymentResponse("WsDeploy");
			esp_response.setown(resp);
			MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
			source.setf("WsDeploy::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				if(accessmap.ordinality()>0)
					onFeaturesAuthorize(context, accessmap, "WsDeploy", "StartDeployment");
				iserv->onStartDeployment(context, *esp_request.get(), *resp);
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "WsDeploy", "StartDeployment", StringBuffer(getCFD()).append("xslt/exceptions.xslt").str()))
				return 0;
		}
		if(!stricmp(method, "UnlockEnvironmentForCloud")||!stricmp(method, "UnlockEnvironmentForCloudRequest"))
		{
			Owned<CUnlockEnvironmentForCloudRequest> esp_request = new CUnlockEnvironmentForCloudRequest(&context, "WsDeploy", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			CUnlockEnvironmentForCloudResponse* resp = new CUnlockEnvironmentForCloudResponse("WsDeploy");
			esp_response.setown(resp);
			MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
			source.setf("WsDeploy::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				if(accessmap.ordinality()>0)
					onFeaturesAuthorize(context, accessmap, "WsDeploy", "UnlockEnvironmentForCloud");
				iserv->onUnlockEnvironmentForCloud(context, *esp_request.get(), *resp);
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "WsDeploy", "UnlockEnvironmentForCloud", StringBuffer(getCFD()).append("xslt/exceptions.xslt").str()))
				return 0;
		}
		if(!stricmp(method, "UnlockUser")||!stricmp(method, "UnlockUserRequest"))
		{
			Owned<CUnlockUserRequest> esp_request = new CUnlockUserRequest(&context, "WsDeploy", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			CUnlockUserResponse* resp = new CUnlockUserResponse("WsDeploy");
			esp_response.setown(resp);
			MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
			source.setf("WsDeploy::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				if(accessmap.ordinality()>0)
					onFeaturesAuthorize(context, accessmap, "WsDeploy", "UnlockUser");
				iserv->onUnlockUser(context, *esp_request.get(), *resp);
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "WsDeploy", "UnlockUser", StringBuffer(getCFD()).append("xslt/exceptions.xslt").str()))
				return 0;
		}

		if (esp_response.get())
		{
			if (canRedirect(*request) && esp_response->getRedirectUrl() && *esp_response->getRedirectUrl())
				response->redirect(*request, esp_response->getRedirectUrl());
			else
			{
				MemoryBuffer content;
				StringBuffer mimetype;
				esp_response->appendContent(&context,content, mimetype);
				onBeforeSendResponse(context,request,content,service,method);
				response->setContent(content.length(), content.toByteArray());
				response->setContentType(mimetype.str());
				response->send();
			}
			return 0;
		}
	}
	return onGetNotFound(context, request,  response, service);
}





//=======================================================
// client util methods
//=======================================================

//------ method AddReqdComps ---------

IClientAddReqdCompsRequest * CClientWsDeploy::createAddReqdCompsRequest()
{
	CAddReqdCompsRequest* request = new CAddReqdCompsRequest("WsDeploy");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientAddReqdCompsResponse * CClientWsDeploy::AddReqdComps(IClientAddReqdCompsRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CAddReqdCompsRequest* esprequest = static_cast<CAddReqdCompsRequest*>(request);
	CAddReqdCompsResponse* espresponse = new CAddReqdCompsResponse("WsDeploy");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientWsDeploy::async_AddReqdComps(IClientAddReqdCompsRequest *request, IClientWsDeployEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CAddReqdCompsRequest* esprequest = static_cast<CAddReqdCompsRequest*>(request);
	esprequest->setMethod("AddReqdComps");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientWsDeploy::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientAddReqdCompsResponse *CClientWsDeploy::AddReqdCompsFn(const char * XmlArgs_, IConstWsDeployReqInfo &ReqInfo_)
{
	Owned<IClientAddReqdCompsRequest> req =  createAddReqdCompsRequest();
	req->setXmlArgs(XmlArgs_);
	req->setReqInfo(ReqInfo_);
	return AddReqdComps(req.get());
}

//------ method BuildEnvironment ---------

IClientBuildEnvironmentRequest * CClientWsDeploy::createBuildEnvironmentRequest()
{
	CBuildEnvironmentRequest* request = new CBuildEnvironmentRequest("WsDeploy");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientBuildEnvironmentResponse * CClientWsDeploy::BuildEnvironment(IClientBuildEnvironmentRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CBuildEnvironmentRequest* esprequest = static_cast<CBuildEnvironmentRequest*>(request);
	CBuildEnvironmentResponse* espresponse = new CBuildEnvironmentResponse("WsDeploy");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientWsDeploy::async_BuildEnvironment(IClientBuildEnvironmentRequest *request, IClientWsDeployEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CBuildEnvironmentRequest* esprequest = static_cast<CBuildEnvironmentRequest*>(request);
	esprequest->setMethod("BuildEnvironment");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientWsDeploy::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientBuildEnvironmentResponse *CClientWsDeploy::BuildEnvironmentFn(const char * XmlArgs_, IConstWsDeployReqInfo &ReqInfo_)
{
	Owned<IClientBuildEnvironmentRequest> req =  createBuildEnvironmentRequest();
	req->setXmlArgs(XmlArgs_);
	req->setReqInfo(ReqInfo_);
	return BuildEnvironment(req.get());
}

//------ method ClientAlive ---------

IClientClientAliveRequest * CClientWsDeploy::createClientAliveRequest()
{
	CClientAliveRequest* request = new CClientAliveRequest("WsDeploy");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientClientAliveResponse * CClientWsDeploy::ClientAlive(IClientClientAliveRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CClientAliveRequest* esprequest = static_cast<CClientAliveRequest*>(request);
	CClientAliveResponse* espresponse = new CClientAliveResponse("WsDeploy");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientWsDeploy::async_ClientAlive(IClientClientAliveRequest *request, IClientWsDeployEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CClientAliveRequest* esprequest = static_cast<CClientAliveRequest*>(request);
	esprequest->setMethod("ClientAlive");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientWsDeploy::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientClientAliveResponse *CClientWsDeploy::ClientAliveFn(IConstWsDeployReqInfo &ReqInfo_)
{
	Owned<IClientClientAliveRequest> req =  createClientAliveRequest();
	req->setReqInfo(ReqInfo_);
	return ClientAlive(req.get());
}

//------ method DisplaySettings ---------

IClientDisplaySettingsRequest * CClientWsDeploy::createDisplaySettingsRequest()
{
	CDisplaySettingsRequest* request = new CDisplaySettingsRequest("WsDeploy");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientDisplaySettingsResponse * CClientWsDeploy::DisplaySettings(IClientDisplaySettingsRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CDisplaySettingsRequest* esprequest = static_cast<CDisplaySettingsRequest*>(request);
	CDisplaySettingsResponse* espresponse = new CDisplaySettingsResponse("WsDeploy");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientWsDeploy::async_DisplaySettings(IClientDisplaySettingsRequest *request, IClientWsDeployEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CDisplaySettingsRequest* esprequest = static_cast<CDisplaySettingsRequest*>(request);
	esprequest->setMethod("DisplaySettings");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientWsDeploy::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientDisplaySettingsResponse *CClientWsDeploy::DisplaySettingsFn(const char * Cmd_, const char * XmlArgs_, IConstWsDeployReqInfo &ReqInfo_)
{
	Owned<IClientDisplaySettingsRequest> req =  createDisplaySettingsRequest();
	req->setCmd(Cmd_);
	req->setXmlArgs(XmlArgs_);
	req->setReqInfo(ReqInfo_);
	return DisplaySettings(req.get());
}

//------ method GetBuildServerDirs ---------

IClientGetBuildServerDirsRequest * CClientWsDeploy::createGetBuildServerDirsRequest()
{
	CGetBuildServerDirsRequest* request = new CGetBuildServerDirsRequest("WsDeploy");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientGetBuildServerDirsResponse * CClientWsDeploy::GetBuildServerDirs(IClientGetBuildServerDirsRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CGetBuildServerDirsRequest* esprequest = static_cast<CGetBuildServerDirsRequest*>(request);
	CGetBuildServerDirsResponse* espresponse = new CGetBuildServerDirsResponse("WsDeploy");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientWsDeploy::async_GetBuildServerDirs(IClientGetBuildServerDirsRequest *request, IClientWsDeployEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CGetBuildServerDirsRequest* esprequest = static_cast<CGetBuildServerDirsRequest*>(request);
	esprequest->setMethod("GetBuildServerDirs");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientWsDeploy::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientGetBuildServerDirsResponse *CClientWsDeploy::GetBuildServerDirsFn(const char * Cmd_, const char * XmlArgs_, IConstWsDeployReqInfo &ReqInfo_)
{
	Owned<IClientGetBuildServerDirsRequest> req =  createGetBuildServerDirsRequest();
	req->setCmd(Cmd_);
	req->setXmlArgs(XmlArgs_);
	req->setReqInfo(ReqInfo_);
	return GetBuildServerDirs(req.get());
}

//------ method GetBuildSetInfo ---------

IClientGetBuildSetInfoRequest * CClientWsDeploy::createGetBuildSetInfoRequest()
{
	CGetBuildSetInfoRequest* request = new CGetBuildSetInfoRequest("WsDeploy");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientGetBuildSetInfoResponse * CClientWsDeploy::GetBuildSetInfo(IClientGetBuildSetInfoRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CGetBuildSetInfoRequest* esprequest = static_cast<CGetBuildSetInfoRequest*>(request);
	CGetBuildSetInfoResponse* espresponse = new CGetBuildSetInfoResponse("WsDeploy");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientWsDeploy::async_GetBuildSetInfo(IClientGetBuildSetInfoRequest *request, IClientWsDeployEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CGetBuildSetInfoRequest* esprequest = static_cast<CGetBuildSetInfoRequest*>(request);
	esprequest->setMethod("GetBuildSetInfo");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientWsDeploy::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientGetBuildSetInfoResponse *CClientWsDeploy::GetBuildSetInfoFn(const char * Cmd_, const char * XmlArgs_, IConstWsDeployReqInfo &ReqInfo_)
{
	Owned<IClientGetBuildSetInfoRequest> req =  createGetBuildSetInfoRequest();
	req->setCmd(Cmd_);
	req->setXmlArgs(XmlArgs_);
	req->setReqInfo(ReqInfo_);
	return GetBuildSetInfo(req.get());
}

//------ method GetComputersForRoxie ---------

IClientGetComputersForRoxieRequest * CClientWsDeploy::createGetComputersForRoxieRequest()
{
	CGetComputersForRoxieRequest* request = new CGetComputersForRoxieRequest("WsDeploy");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientGetComputersForRoxieResponse * CClientWsDeploy::GetComputersForRoxie(IClientGetComputersForRoxieRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CGetComputersForRoxieRequest* esprequest = static_cast<CGetComputersForRoxieRequest*>(request);
	CGetComputersForRoxieResponse* espresponse = new CGetComputersForRoxieResponse("WsDeploy");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientWsDeploy::async_GetComputersForRoxie(IClientGetComputersForRoxieRequest *request, IClientWsDeployEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CGetComputersForRoxieRequest* esprequest = static_cast<CGetComputersForRoxieRequest*>(request);
	esprequest->setMethod("GetComputersForRoxie");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientWsDeploy::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientGetComputersForRoxieResponse *CClientWsDeploy::GetComputersForRoxieFn(const char * Cmd_, const char * XmlArgs_, IConstWsDeployReqInfo &ReqInfo_)
{
	Owned<IClientGetComputersForRoxieRequest> req =  createGetComputersForRoxieRequest();
	req->setCmd(Cmd_);
	req->setXmlArgs(XmlArgs_);
	req->setReqInfo(ReqInfo_);
	return GetComputersForRoxie(req.get());
}

//------ method GetDeployableComps ---------

IClientGetDeployableCompsRequest * CClientWsDeploy::createGetDeployableCompsRequest()
{
	CGetDeployableCompsRequest* request = new CGetDeployableCompsRequest("WsDeploy");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientGetDeployableCompsResponse * CClientWsDeploy::GetDeployableComps(IClientGetDeployableCompsRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CGetDeployableCompsRequest* esprequest = static_cast<CGetDeployableCompsRequest*>(request);
	CGetDeployableCompsResponse* espresponse = new CGetDeployableCompsResponse("WsDeploy");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientWsDeploy::async_GetDeployableComps(IClientGetDeployableCompsRequest *request, IClientWsDeployEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CGetDeployableCompsRequest* esprequest = static_cast<CGetDeployableCompsRequest*>(request);
	esprequest->setMethod("GetDeployableComps");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientWsDeploy::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientGetDeployableCompsResponse *CClientWsDeploy::GetDeployableCompsFn(const char * Cmd_, const char * XmlArgs_, IConstWsDeployReqInfo &ReqInfo_)
{
	Owned<IClientGetDeployableCompsRequest> req =  createGetDeployableCompsRequest();
	req->setCmd(Cmd_);
	req->setXmlArgs(XmlArgs_);
	req->setReqInfo(ReqInfo_);
	return GetDeployableComps(req.get());
}

//------ method GetEnvironment ---------

IClientGetEnvironmentRequest * CClientWsDeploy::createGetEnvironmentRequest()
{
	CGetEnvironmentRequest* request = new CGetEnvironmentRequest("WsDeploy");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientGetEnvironmentResponse * CClientWsDeploy::GetEnvironment(IClientGetEnvironmentRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CGetEnvironmentRequest* esprequest = static_cast<CGetEnvironmentRequest*>(request);
	CGetEnvironmentResponse* espresponse = new CGetEnvironmentResponse("WsDeploy");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientWsDeploy::async_GetEnvironment(IClientGetEnvironmentRequest *request, IClientWsDeployEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CGetEnvironmentRequest* esprequest = static_cast<CGetEnvironmentRequest*>(request);
	esprequest->setMethod("GetEnvironment");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientWsDeploy::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientGetEnvironmentResponse *CClientWsDeploy::GetEnvironmentFn()
{
	Owned<IClientGetEnvironmentRequest> req =  createGetEnvironmentRequest();
	return GetEnvironment(req.get());
}

//------ method GetNavTreeDefn ---------

IClientGetNavTreeDefnRequest * CClientWsDeploy::createGetNavTreeDefnRequest()
{
	CGetNavTreeDefnRequest* request = new CGetNavTreeDefnRequest("WsDeploy");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientGetNavTreeDefnResponse * CClientWsDeploy::GetNavTreeDefn(IClientGetNavTreeDefnRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CGetNavTreeDefnRequest* esprequest = static_cast<CGetNavTreeDefnRequest*>(request);
	CGetNavTreeDefnResponse* espresponse = new CGetNavTreeDefnResponse("WsDeploy");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientWsDeploy::async_GetNavTreeDefn(IClientGetNavTreeDefnRequest *request, IClientWsDeployEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CGetNavTreeDefnRequest* esprequest = static_cast<CGetNavTreeDefnRequest*>(request);
	esprequest->setMethod("GetNavTreeDefn");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientWsDeploy::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientGetNavTreeDefnResponse *CClientWsDeploy::GetNavTreeDefnFn(const char * XmlArgs_, IConstWsDeployReqInfo &ReqInfo_)
{
	Owned<IClientGetNavTreeDefnRequest> req =  createGetNavTreeDefnRequest();
	req->setXmlArgs(XmlArgs_);
	req->setReqInfo(ReqInfo_);
	return GetNavTreeDefn(req.get());
}

//------ method GetSubnetIPAddr ---------

IClientGetSubnetIPAddrRequest * CClientWsDeploy::createGetSubnetIPAddrRequest()
{
	CGetSubnetIPAddrRequest* request = new CGetSubnetIPAddrRequest("WsDeploy");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientGetSubnetIPAddrResponse * CClientWsDeploy::GetSubnetIPAddr(IClientGetSubnetIPAddrRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CGetSubnetIPAddrRequest* esprequest = static_cast<CGetSubnetIPAddrRequest*>(request);
	CGetSubnetIPAddrResponse* espresponse = new CGetSubnetIPAddrResponse("WsDeploy");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientWsDeploy::async_GetSubnetIPAddr(IClientGetSubnetIPAddrRequest *request, IClientWsDeployEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CGetSubnetIPAddrRequest* esprequest = static_cast<CGetSubnetIPAddrRequest*>(request);
	esprequest->setMethod("GetSubnetIPAddr");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientWsDeploy::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientGetSubnetIPAddrResponse *CClientWsDeploy::GetSubnetIPAddrFn(IConstWsDeployReqInfo &ReqInfo_)
{
	Owned<IClientGetSubnetIPAddrRequest> req =  createGetSubnetIPAddrRequest();
	req->setReqInfo(ReqInfo_);
	return GetSubnetIPAddr(req.get());
}

//------ method GetSummary ---------

IClientGetSummaryRequest * CClientWsDeploy::createGetSummaryRequest()
{
	CGetSummaryRequest* request = new CGetSummaryRequest("WsDeploy");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientGetSummaryResponse * CClientWsDeploy::GetSummary(IClientGetSummaryRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CGetSummaryRequest* esprequest = static_cast<CGetSummaryRequest*>(request);
	CGetSummaryResponse* espresponse = new CGetSummaryResponse("WsDeploy");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientWsDeploy::async_GetSummary(IClientGetSummaryRequest *request, IClientWsDeployEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CGetSummaryRequest* esprequest = static_cast<CGetSummaryRequest*>(request);
	esprequest->setMethod("GetSummary");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientWsDeploy::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientGetSummaryResponse *CClientWsDeploy::GetSummaryFn(bool PrepareLinkFlag_, IConstWsDeployReqInfo &ReqInfo_)
{
	Owned<IClientGetSummaryRequest> req =  createGetSummaryRequest();
	req->setPrepareLinkFlag(PrepareLinkFlag_);
	req->setReqInfo(ReqInfo_);
	return GetSummary(req.get());
}

//------ method GetValue ---------

IClientGetValueRequest * CClientWsDeploy::createGetValueRequest()
{
	CGetValueRequest* request = new CGetValueRequest("WsDeploy");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientGetValueResponse * CClientWsDeploy::GetValue(IClientGetValueRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CGetValueRequest* esprequest = static_cast<CGetValueRequest*>(request);
	CGetValueResponse* espresponse = new CGetValueResponse("WsDeploy");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientWsDeploy::async_GetValue(IClientGetValueRequest *request, IClientWsDeployEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CGetValueRequest* esprequest = static_cast<CGetValueRequest*>(request);
	esprequest->setMethod("GetValue");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientWsDeploy::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientGetValueResponse *CClientWsDeploy::GetValueFn(const char * Params_, IConstWsDeployReqInfo &ReqInfo_)
{
	Owned<IClientGetValueRequest> req =  createGetValueRequest();
	req->setParams(Params_);
	req->setReqInfo(ReqInfo_);
	return GetValue(req.get());
}

//------ method Graph ---------

IClientEmptyRequest * CClientWsDeploy::createGraphRequest()
{
	CEmptyRequest* request = new CEmptyRequest("WsDeploy");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientGraphResponse * CClientWsDeploy::Graph(IClientEmptyRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CEmptyRequest* esprequest = static_cast<CEmptyRequest*>(request);
	CGraphResponse* espresponse = new CGraphResponse("WsDeploy");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientWsDeploy::async_Graph(IClientEmptyRequest *request, IClientWsDeployEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CEmptyRequest* esprequest = static_cast<CEmptyRequest*>(request);
	esprequest->setMethod("Graph");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientWsDeploy::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientGraphResponse *CClientWsDeploy::GraphFn()
{
	Owned<IClientEmptyRequest> req =  createGraphRequest();
	return Graph(req.get());
}

//------ method HandleAccessRules ---------

IClientHandleAccessRulesRequest * CClientWsDeploy::createHandleAccessRulesRequest()
{
	CHandleAccessRulesRequest* request = new CHandleAccessRulesRequest("WsDeploy");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientHandleAccessRulesResponse * CClientWsDeploy::HandleAccessRules(IClientHandleAccessRulesRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CHandleAccessRulesRequest* esprequest = static_cast<CHandleAccessRulesRequest*>(request);
	CHandleAccessRulesResponse* espresponse = new CHandleAccessRulesResponse("WsDeploy");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientWsDeploy::async_HandleAccessRules(IClientHandleAccessRulesRequest *request, IClientWsDeployEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CHandleAccessRulesRequest* esprequest = static_cast<CHandleAccessRulesRequest*>(request);
	esprequest->setMethod("HandleAccessRules");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientWsDeploy::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientHandleAccessRulesResponse *CClientWsDeploy::HandleAccessRulesFn(const char * Operation_, const char * XmlArgs_, IConstWsDeployReqInfo &ReqInfo_)
{
	Owned<IClientHandleAccessRulesRequest> req =  createHandleAccessRulesRequest();
	req->setOperation(Operation_);
	req->setXmlArgs(XmlArgs_);
	req->setReqInfo(ReqInfo_);
	return HandleAccessRules(req.get());
}

//------ method HandleAttributeAdd ---------

IClientHandleAttributeAddRequest * CClientWsDeploy::createHandleAttributeAddRequest()
{
	CHandleAttributeAddRequest* request = new CHandleAttributeAddRequest("WsDeploy");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientHandleAttributeAddResponse * CClientWsDeploy::HandleAttributeAdd(IClientHandleAttributeAddRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CHandleAttributeAddRequest* esprequest = static_cast<CHandleAttributeAddRequest*>(request);
	CHandleAttributeAddResponse* espresponse = new CHandleAttributeAddResponse("WsDeploy");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientWsDeploy::async_HandleAttributeAdd(IClientHandleAttributeAddRequest *request, IClientWsDeployEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CHandleAttributeAddRequest* esprequest = static_cast<CHandleAttributeAddRequest*>(request);
	esprequest->setMethod("HandleAttributeAdd");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientWsDeploy::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientHandleAttributeAddResponse *CClientWsDeploy::HandleAttributeAddFn(const char * Operation_, const char * XmlArgs_, IConstWsDeployReqInfo &ReqInfo_)
{
	Owned<IClientHandleAttributeAddRequest> req =  createHandleAttributeAddRequest();
	req->setOperation(Operation_);
	req->setXmlArgs(XmlArgs_);
	req->setReqInfo(ReqInfo_);
	return HandleAttributeAdd(req.get());
}

//------ method HandleAttributeDelete ---------

IClientHandleAttributeDeleteRequest * CClientWsDeploy::createHandleAttributeDeleteRequest()
{
	CHandleAttributeDeleteRequest* request = new CHandleAttributeDeleteRequest("WsDeploy");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientHandleAttributeDeleteResponse * CClientWsDeploy::HandleAttributeDelete(IClientHandleAttributeDeleteRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CHandleAttributeDeleteRequest* esprequest = static_cast<CHandleAttributeDeleteRequest*>(request);
	CHandleAttributeDeleteResponse* espresponse = new CHandleAttributeDeleteResponse("WsDeploy");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientWsDeploy::async_HandleAttributeDelete(IClientHandleAttributeDeleteRequest *request, IClientWsDeployEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CHandleAttributeDeleteRequest* esprequest = static_cast<CHandleAttributeDeleteRequest*>(request);
	esprequest->setMethod("HandleAttributeDelete");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientWsDeploy::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientHandleAttributeDeleteResponse *CClientWsDeploy::HandleAttributeDeleteFn(const char * Operation_, const char * XmlArgs_, bool bLeaf_, IConstWsDeployReqInfo &ReqInfo_)
{
	Owned<IClientHandleAttributeDeleteRequest> req =  createHandleAttributeDeleteRequest();
	req->setOperation(Operation_);
	req->setXmlArgs(XmlArgs_);
	req->setBLeaf(bLeaf_);
	req->setReqInfo(ReqInfo_);
	return HandleAttributeDelete(req.get());
}

//------ method HandleBaseAccessControlList ---------

IClientHandleBaseAccessControlListRequest * CClientWsDeploy::createHandleBaseAccessControlListRequest()
{
	CHandleBaseAccessControlListRequest* request = new CHandleBaseAccessControlListRequest("WsDeploy");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientHandleBaseAccessControlListResponse * CClientWsDeploy::HandleBaseAccessControlList(IClientHandleBaseAccessControlListRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CHandleBaseAccessControlListRequest* esprequest = static_cast<CHandleBaseAccessControlListRequest*>(request);
	CHandleBaseAccessControlListResponse* espresponse = new CHandleBaseAccessControlListResponse("WsDeploy");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientWsDeploy::async_HandleBaseAccessControlList(IClientHandleBaseAccessControlListRequest *request, IClientWsDeployEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CHandleBaseAccessControlListRequest* esprequest = static_cast<CHandleBaseAccessControlListRequest*>(request);
	esprequest->setMethod("HandleBaseAccessControlList");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientWsDeploy::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientHandleBaseAccessControlListResponse *CClientWsDeploy::HandleBaseAccessControlListFn(const char * Operation_, const char * XmlArgs_, IConstWsDeployReqInfo &ReqInfo_)
{
	Owned<IClientHandleBaseAccessControlListRequest> req =  createHandleBaseAccessControlListRequest();
	req->setOperation(Operation_);
	req->setXmlArgs(XmlArgs_);
	req->setReqInfo(ReqInfo_);
	return HandleBaseAccessControlList(req.get());
}

//------ method HandleComponent ---------

IClientHandleComponentRequest * CClientWsDeploy::createHandleComponentRequest()
{
	CHandleComponentRequest* request = new CHandleComponentRequest("WsDeploy");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientHandleComponentResponse * CClientWsDeploy::HandleComponent(IClientHandleComponentRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CHandleComponentRequest* esprequest = static_cast<CHandleComponentRequest*>(request);
	CHandleComponentResponse* espresponse = new CHandleComponentResponse("WsDeploy");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientWsDeploy::async_HandleComponent(IClientHandleComponentRequest *request, IClientWsDeployEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CHandleComponentRequest* esprequest = static_cast<CHandleComponentRequest*>(request);
	esprequest->setMethod("HandleComponent");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientWsDeploy::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientHandleComponentResponse *CClientWsDeploy::HandleComponentFn(const char * Operation_, const char * XmlArgs_, IConstWsDeployReqInfo &ReqInfo_)
{
	Owned<IClientHandleComponentRequest> req =  createHandleComponentRequest();
	req->setOperation(Operation_);
	req->setXmlArgs(XmlArgs_);
	req->setReqInfo(ReqInfo_);
	return HandleComponent(req.get());
}

//------ method HandleComputer ---------

IClientHandleComputerRequest * CClientWsDeploy::createHandleComputerRequest()
{
	CHandleComputerRequest* request = new CHandleComputerRequest("WsDeploy");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientHandleComputerResponse * CClientWsDeploy::HandleComputer(IClientHandleComputerRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CHandleComputerRequest* esprequest = static_cast<CHandleComputerRequest*>(request);
	CHandleComputerResponse* espresponse = new CHandleComputerResponse("WsDeploy");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientWsDeploy::async_HandleComputer(IClientHandleComputerRequest *request, IClientWsDeployEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CHandleComputerRequest* esprequest = static_cast<CHandleComputerRequest*>(request);
	esprequest->setMethod("HandleComputer");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientWsDeploy::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientHandleComputerResponse *CClientWsDeploy::HandleComputerFn(const char * Operation_, const char * XmlArgs_, IConstWsDeployReqInfo &ReqInfo_)
{
	Owned<IClientHandleComputerRequest> req =  createHandleComputerRequest();
	req->setOperation(Operation_);
	req->setXmlArgs(XmlArgs_);
	req->setReqInfo(ReqInfo_);
	return HandleComputer(req.get());
}

//------ method HandleEspServiceBindings ---------

IClientHandleEspServiceBindingsRequest * CClientWsDeploy::createHandleEspServiceBindingsRequest()
{
	CHandleEspServiceBindingsRequest* request = new CHandleEspServiceBindingsRequest("WsDeploy");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientHandleEspServiceBindingsResponse * CClientWsDeploy::HandleEspServiceBindings(IClientHandleEspServiceBindingsRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CHandleEspServiceBindingsRequest* esprequest = static_cast<CHandleEspServiceBindingsRequest*>(request);
	CHandleEspServiceBindingsResponse* espresponse = new CHandleEspServiceBindingsResponse("WsDeploy");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientWsDeploy::async_HandleEspServiceBindings(IClientHandleEspServiceBindingsRequest *request, IClientWsDeployEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CHandleEspServiceBindingsRequest* esprequest = static_cast<CHandleEspServiceBindingsRequest*>(request);
	esprequest->setMethod("HandleEspServiceBindings");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientWsDeploy::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientHandleEspServiceBindingsResponse *CClientWsDeploy::HandleEspServiceBindingsFn(const char * Operation_, const char * XmlArgs_, IConstWsDeployReqInfo &ReqInfo_)
{
	Owned<IClientHandleEspServiceBindingsRequest> req =  createHandleEspServiceBindingsRequest();
	req->setOperation(Operation_);
	req->setXmlArgs(XmlArgs_);
	req->setReqInfo(ReqInfo_);
	return HandleEspServiceBindings(req.get());
}

//------ method HandleInstance ---------

IClientHandleInstanceRequest * CClientWsDeploy::createHandleInstanceRequest()
{
	CHandleInstanceRequest* request = new CHandleInstanceRequest("WsDeploy");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientHandleInstanceResponse * CClientWsDeploy::HandleInstance(IClientHandleInstanceRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CHandleInstanceRequest* esprequest = static_cast<CHandleInstanceRequest*>(request);
	CHandleInstanceResponse* espresponse = new CHandleInstanceResponse("WsDeploy");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientWsDeploy::async_HandleInstance(IClientHandleInstanceRequest *request, IClientWsDeployEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CHandleInstanceRequest* esprequest = static_cast<CHandleInstanceRequest*>(request);
	esprequest->setMethod("HandleInstance");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientWsDeploy::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientHandleInstanceResponse *CClientWsDeploy::HandleInstanceFn(const char * Operation_, const char * XmlArgs_, IConstWsDeployReqInfo &ReqInfo_)
{
	Owned<IClientHandleInstanceRequest> req =  createHandleInstanceRequest();
	req->setOperation(Operation_);
	req->setXmlArgs(XmlArgs_);
	req->setReqInfo(ReqInfo_);
	return HandleInstance(req.get());
}

//------ method HandleRows ---------

IClientHandleRowsRequest * CClientWsDeploy::createHandleRowsRequest()
{
	CHandleRowsRequest* request = new CHandleRowsRequest("WsDeploy");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientHandleRowsResponse * CClientWsDeploy::HandleRows(IClientHandleRowsRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CHandleRowsRequest* esprequest = static_cast<CHandleRowsRequest*>(request);
	CHandleRowsResponse* espresponse = new CHandleRowsResponse("WsDeploy");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientWsDeploy::async_HandleRows(IClientHandleRowsRequest *request, IClientWsDeployEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CHandleRowsRequest* esprequest = static_cast<CHandleRowsRequest*>(request);
	esprequest->setMethod("HandleRows");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientWsDeploy::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientHandleRowsResponse *CClientWsDeploy::HandleRowsFn(const char * Operation_, const char * XmlArgs_, IConstWsDeployReqInfo &ReqInfo_)
{
	Owned<IClientHandleRowsRequest> req =  createHandleRowsRequest();
	req->setOperation(Operation_);
	req->setXmlArgs(XmlArgs_);
	req->setReqInfo(ReqInfo_);
	return HandleRows(req.get());
}

//------ method HandleRoxieOperation ---------

IClientHandleRoxieOperationRequest * CClientWsDeploy::createHandleRoxieOperationRequest()
{
	CHandleRoxieOperationRequest* request = new CHandleRoxieOperationRequest("WsDeploy");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientHandleRoxieOperationResponse * CClientWsDeploy::HandleRoxieOperation(IClientHandleRoxieOperationRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CHandleRoxieOperationRequest* esprequest = static_cast<CHandleRoxieOperationRequest*>(request);
	CHandleRoxieOperationResponse* espresponse = new CHandleRoxieOperationResponse("WsDeploy");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientWsDeploy::async_HandleRoxieOperation(IClientHandleRoxieOperationRequest *request, IClientWsDeployEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CHandleRoxieOperationRequest* esprequest = static_cast<CHandleRoxieOperationRequest*>(request);
	esprequest->setMethod("HandleRoxieOperation");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientWsDeploy::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientHandleRoxieOperationResponse *CClientWsDeploy::HandleRoxieOperationFn(const char * Cmd_, const char * XmlArgs_, IConstWsDeployReqInfo &ReqInfo_)
{
	Owned<IClientHandleRoxieOperationRequest> req =  createHandleRoxieOperationRequest();
	req->setCmd(Cmd_);
	req->setXmlArgs(XmlArgs_);
	req->setReqInfo(ReqInfo_);
	return HandleRoxieOperation(req.get());
}

//------ method HandleThorTopology ---------

IClientHandleThorTopologyRequest * CClientWsDeploy::createHandleThorTopologyRequest()
{
	CHandleThorTopologyRequest* request = new CHandleThorTopologyRequest("WsDeploy");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientHandleThorTopologyResponse * CClientWsDeploy::HandleThorTopology(IClientHandleThorTopologyRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CHandleThorTopologyRequest* esprequest = static_cast<CHandleThorTopologyRequest*>(request);
	CHandleThorTopologyResponse* espresponse = new CHandleThorTopologyResponse("WsDeploy");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientWsDeploy::async_HandleThorTopology(IClientHandleThorTopologyRequest *request, IClientWsDeployEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CHandleThorTopologyRequest* esprequest = static_cast<CHandleThorTopologyRequest*>(request);
	esprequest->setMethod("HandleThorTopology");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientWsDeploy::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientHandleThorTopologyResponse *CClientWsDeploy::HandleThorTopologyFn(const char * Operation_, const char * XmlArgs_, IConstWsDeployReqInfo &ReqInfo_)
{
	Owned<IClientHandleThorTopologyRequest> req =  createHandleThorTopologyRequest();
	req->setOperation(Operation_);
	req->setXmlArgs(XmlArgs_);
	req->setReqInfo(ReqInfo_);
	return HandleThorTopology(req.get());
}

//------ method HandleTopology ---------

IClientHandleTopologyRequest * CClientWsDeploy::createHandleTopologyRequest()
{
	CHandleTopologyRequest* request = new CHandleTopologyRequest("WsDeploy");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientHandleTopologyResponse * CClientWsDeploy::HandleTopology(IClientHandleTopologyRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CHandleTopologyRequest* esprequest = static_cast<CHandleTopologyRequest*>(request);
	CHandleTopologyResponse* espresponse = new CHandleTopologyResponse("WsDeploy");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientWsDeploy::async_HandleTopology(IClientHandleTopologyRequest *request, IClientWsDeployEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CHandleTopologyRequest* esprequest = static_cast<CHandleTopologyRequest*>(request);
	esprequest->setMethod("HandleTopology");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientWsDeploy::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientHandleTopologyResponse *CClientWsDeploy::HandleTopologyFn(const char * Operation_, const char * XmlArgs_, IConstWsDeployReqInfo &ReqInfo_)
{
	Owned<IClientHandleTopologyRequest> req =  createHandleTopologyRequest();
	req->setOperation(Operation_);
	req->setXmlArgs(XmlArgs_);
	req->setReqInfo(ReqInfo_);
	return HandleTopology(req.get());
}

//------ method ImportBuild ---------

IClientImportBuildRequest * CClientWsDeploy::createImportBuildRequest()
{
	CImportBuildRequest* request = new CImportBuildRequest("WsDeploy");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientImportBuildResponse * CClientWsDeploy::ImportBuild(IClientImportBuildRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CImportBuildRequest* esprequest = static_cast<CImportBuildRequest*>(request);
	CImportBuildResponse* espresponse = new CImportBuildResponse("WsDeploy");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientWsDeploy::async_ImportBuild(IClientImportBuildRequest *request, IClientWsDeployEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CImportBuildRequest* esprequest = static_cast<CImportBuildRequest*>(request);
	esprequest->setMethod("ImportBuild");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientWsDeploy::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientImportBuildResponse *CClientWsDeploy::ImportBuildFn(const char * BuildName_, const char * BuildUrl_, const char * BuildSets_, IConstWsDeployReqInfo &ReqInfo_)
{
	Owned<IClientImportBuildRequest> req =  createImportBuildRequest();
	req->setBuildName(BuildName_);
	req->setBuildUrl(BuildUrl_);
	req->setBuildSets(BuildSets_);
	req->setReqInfo(ReqInfo_);
	return ImportBuild(req.get());
}

//------ method LockEnvironmentForCloud ---------

IClientLockEnvironmentForCloudRequest * CClientWsDeploy::createLockEnvironmentForCloudRequest()
{
	CLockEnvironmentForCloudRequest* request = new CLockEnvironmentForCloudRequest("WsDeploy");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientLockEnvironmentForCloudResponse * CClientWsDeploy::LockEnvironmentForCloud(IClientLockEnvironmentForCloudRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CLockEnvironmentForCloudRequest* esprequest = static_cast<CLockEnvironmentForCloudRequest*>(request);
	CLockEnvironmentForCloudResponse* espresponse = new CLockEnvironmentForCloudResponse("WsDeploy");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientWsDeploy::async_LockEnvironmentForCloud(IClientLockEnvironmentForCloudRequest *request, IClientWsDeployEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CLockEnvironmentForCloudRequest* esprequest = static_cast<CLockEnvironmentForCloudRequest*>(request);
	esprequest->setMethod("LockEnvironmentForCloud");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientWsDeploy::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientLockEnvironmentForCloudResponse *CClientWsDeploy::LockEnvironmentForCloudFn(const char * Ip_, const char * UserName_, IConstWsDeployReqInfo &ReqInfo_)
{
	Owned<IClientLockEnvironmentForCloudRequest> req =  createLockEnvironmentForCloudRequest();
	req->setIp(Ip_);
	req->setUserName(UserName_);
	req->setReqInfo(ReqInfo_);
	return LockEnvironmentForCloud(req.get());
}

//------ method NavMenuEvent ---------

IClientNavMenuEventRequest * CClientWsDeploy::createNavMenuEventRequest()
{
	CNavMenuEventRequest* request = new CNavMenuEventRequest("WsDeploy");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientNavMenuEventResponse * CClientWsDeploy::NavMenuEvent(IClientNavMenuEventRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CNavMenuEventRequest* esprequest = static_cast<CNavMenuEventRequest*>(request);
	CNavMenuEventResponse* espresponse = new CNavMenuEventResponse("WsDeploy");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientWsDeploy::async_NavMenuEvent(IClientNavMenuEventRequest *request, IClientWsDeployEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CNavMenuEventRequest* esprequest = static_cast<CNavMenuEventRequest*>(request);
	esprequest->setMethod("NavMenuEvent");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientWsDeploy::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientNavMenuEventResponse *CClientWsDeploy::NavMenuEventFn(const char * Cmd_, const char * XmlArgs_, IConstWsDeployReqInfo &ReqInfo_)
{
	Owned<IClientNavMenuEventRequest> req =  createNavMenuEventRequest();
	req->setCmd(Cmd_);
	req->setXmlArgs(XmlArgs_);
	req->setReqInfo(ReqInfo_);
	return NavMenuEvent(req.get());
}

//------ method NotifyInitSystemSaveEnvForCloud ---------

IClientNotifyInitSystemSaveEnvForCloudRequest * CClientWsDeploy::createNotifyInitSystemSaveEnvForCloudRequest()
{
	CNotifyInitSystemSaveEnvForCloudRequest* request = new CNotifyInitSystemSaveEnvForCloudRequest("WsDeploy");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientNotifyInitSystemSaveEnvForCloudResponse * CClientWsDeploy::NotifyInitSystemSaveEnvForCloud(IClientNotifyInitSystemSaveEnvForCloudRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CNotifyInitSystemSaveEnvForCloudRequest* esprequest = static_cast<CNotifyInitSystemSaveEnvForCloudRequest*>(request);
	CNotifyInitSystemSaveEnvForCloudResponse* espresponse = new CNotifyInitSystemSaveEnvForCloudResponse("WsDeploy");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientWsDeploy::async_NotifyInitSystemSaveEnvForCloud(IClientNotifyInitSystemSaveEnvForCloudRequest *request, IClientWsDeployEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CNotifyInitSystemSaveEnvForCloudRequest* esprequest = static_cast<CNotifyInitSystemSaveEnvForCloudRequest*>(request);
	esprequest->setMethod("NotifyInitSystemSaveEnvForCloud");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientWsDeploy::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientNotifyInitSystemSaveEnvForCloudResponse *CClientWsDeploy::NotifyInitSystemSaveEnvForCloudFn(const char * Ip_, const char * UserName_, IConstWsDeployReqInfo &ReqInfo_)
{
	Owned<IClientNotifyInitSystemSaveEnvForCloudRequest> req =  createNotifyInitSystemSaveEnvForCloudRequest();
	req->setIp(Ip_);
	req->setUserName(UserName_);
	req->setReqInfo(ReqInfo_);
	return NotifyInitSystemSaveEnvForCloud(req.get());
}

//------ method Ping ---------

IClientWsDeployPingRequest * CClientWsDeploy::createPingRequest()
{
	CWsDeployPingRequest* request = new CWsDeployPingRequest("WsDeploy");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientWsDeployPingResponse * CClientWsDeploy::Ping(IClientWsDeployPingRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CWsDeployPingRequest* esprequest = static_cast<CWsDeployPingRequest*>(request);
	CWsDeployPingResponse* espresponse = new CWsDeployPingResponse("WsDeploy");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientWsDeploy::async_Ping(IClientWsDeployPingRequest *request, IClientWsDeployEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CWsDeployPingRequest* esprequest = static_cast<CWsDeployPingRequest*>(request);
	esprequest->setMethod("Ping");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientWsDeploy::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientWsDeployPingResponse *CClientWsDeploy::PingFn()
{
	Owned<IClientWsDeployPingRequest> req =  createPingRequest();
	return Ping(req.get());
}

//------ method RollbackEnvironmentForCloud ---------

IClientRollbackEnvironmentForCloudRequest * CClientWsDeploy::createRollbackEnvironmentForCloudRequest()
{
	CRollbackEnvironmentForCloudRequest* request = new CRollbackEnvironmentForCloudRequest("WsDeploy");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientRollbackEnvironmentForCloudResponse * CClientWsDeploy::RollbackEnvironmentForCloud(IClientRollbackEnvironmentForCloudRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CRollbackEnvironmentForCloudRequest* esprequest = static_cast<CRollbackEnvironmentForCloudRequest*>(request);
	CRollbackEnvironmentForCloudResponse* espresponse = new CRollbackEnvironmentForCloudResponse("WsDeploy");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientWsDeploy::async_RollbackEnvironmentForCloud(IClientRollbackEnvironmentForCloudRequest *request, IClientWsDeployEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CRollbackEnvironmentForCloudRequest* esprequest = static_cast<CRollbackEnvironmentForCloudRequest*>(request);
	esprequest->setMethod("RollbackEnvironmentForCloud");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientWsDeploy::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientRollbackEnvironmentForCloudResponse *CClientWsDeploy::RollbackEnvironmentForCloudFn(const char * Ip_, const char * UserName_, const char * Id_, IConstWsDeployReqInfo &ReqInfo_)
{
	Owned<IClientRollbackEnvironmentForCloudRequest> req =  createRollbackEnvironmentForCloudRequest();
	req->setIp(Ip_);
	req->setUserName(UserName_);
	req->setId(Id_);
	req->setReqInfo(ReqInfo_);
	return RollbackEnvironmentForCloud(req.get());
}

//------ method SaveEnvironmentForCloud ---------

IClientSaveEnvironmentForCloudRequest * CClientWsDeploy::createSaveEnvironmentForCloudRequest()
{
	CSaveEnvironmentForCloudRequest* request = new CSaveEnvironmentForCloudRequest("WsDeploy");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientSaveEnvironmentForCloudResponse * CClientWsDeploy::SaveEnvironmentForCloud(IClientSaveEnvironmentForCloudRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CSaveEnvironmentForCloudRequest* esprequest = static_cast<CSaveEnvironmentForCloudRequest*>(request);
	CSaveEnvironmentForCloudResponse* espresponse = new CSaveEnvironmentForCloudResponse("WsDeploy");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientWsDeploy::async_SaveEnvironmentForCloud(IClientSaveEnvironmentForCloudRequest *request, IClientWsDeployEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CSaveEnvironmentForCloudRequest* esprequest = static_cast<CSaveEnvironmentForCloudRequest*>(request);
	esprequest->setMethod("SaveEnvironmentForCloud");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientWsDeploy::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientSaveEnvironmentForCloudResponse *CClientWsDeploy::SaveEnvironmentForCloudFn(const char * Ip_, const char * UserName_, const char * NewEnv_, const char * Id_, IConstWsDeployReqInfo &ReqInfo_)
{
	Owned<IClientSaveEnvironmentForCloudRequest> req =  createSaveEnvironmentForCloudRequest();
	req->setIp(Ip_);
	req->setUserName(UserName_);
	req->setNewEnv(NewEnv_);
	req->setId(Id_);
	req->setReqInfo(ReqInfo_);
	return SaveEnvironmentForCloud(req.get());
}

//------ method SaveSetting ---------

IClientSaveSettingRequest * CClientWsDeploy::createSaveSettingRequest()
{
	CSaveSettingRequest* request = new CSaveSettingRequest("WsDeploy");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientSaveSettingResponse * CClientWsDeploy::SaveSetting(IClientSaveSettingRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CSaveSettingRequest* esprequest = static_cast<CSaveSettingRequest*>(request);
	CSaveSettingResponse* espresponse = new CSaveSettingResponse("WsDeploy");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientWsDeploy::async_SaveSetting(IClientSaveSettingRequest *request, IClientWsDeployEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CSaveSettingRequest* esprequest = static_cast<CSaveSettingRequest*>(request);
	esprequest->setMethod("SaveSetting");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientWsDeploy::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientSaveSettingResponse *CClientWsDeploy::SaveSettingFn(const char * XmlArgs_, IConstWsDeployReqInfo &ReqInfo_)
{
	Owned<IClientSaveSettingRequest> req =  createSaveSettingRequest();
	req->setXmlArgs(XmlArgs_);
	req->setReqInfo(ReqInfo_);
	return SaveSetting(req.get());
}

//------ method SetEnvironment ---------

IClientSetEnvironmentRequest * CClientWsDeploy::createSetEnvironmentRequest()
{
	CSetEnvironmentRequest* request = new CSetEnvironmentRequest("WsDeploy");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientSetEnvironmentResponse * CClientWsDeploy::SetEnvironment(IClientSetEnvironmentRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CSetEnvironmentRequest* esprequest = static_cast<CSetEnvironmentRequest*>(request);
	CSetEnvironmentResponse* espresponse = new CSetEnvironmentResponse("WsDeploy");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientWsDeploy::async_SetEnvironment(IClientSetEnvironmentRequest *request, IClientWsDeployEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CSetEnvironmentRequest* esprequest = static_cast<CSetEnvironmentRequest*>(request);
	esprequest->setMethod("SetEnvironment");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientWsDeploy::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientSetEnvironmentResponse *CClientWsDeploy::SetEnvironmentFn(const char * EnvXml_)
{
	Owned<IClientSetEnvironmentRequest> req =  createSetEnvironmentRequest();
	req->setEnvXml(EnvXml_);
	return SetEnvironment(req.get());
}

//------ method StartDeployment ---------

IClientStartDeploymentRequest * CClientWsDeploy::createStartDeploymentRequest()
{
	CStartDeploymentRequest* request = new CStartDeploymentRequest("WsDeploy");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientStartDeploymentResponse * CClientWsDeploy::StartDeployment(IClientStartDeploymentRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CStartDeploymentRequest* esprequest = static_cast<CStartDeploymentRequest*>(request);
	CStartDeploymentResponse* espresponse = new CStartDeploymentResponse("WsDeploy");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientWsDeploy::async_StartDeployment(IClientStartDeploymentRequest *request, IClientWsDeployEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CStartDeploymentRequest* esprequest = static_cast<CStartDeploymentRequest*>(request);
	esprequest->setMethod("StartDeployment");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientWsDeploy::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientStartDeploymentResponse *CClientWsDeploy::StartDeploymentFn(const char * SelComps_, IConstDeployOptions &Options_, IConstWsDeployReqInfo &ReqInfo_)
{
	Owned<IClientStartDeploymentRequest> req =  createStartDeploymentRequest();
	req->setSelComps(SelComps_);
	req->setOptions(Options_);
	req->setReqInfo(ReqInfo_);
	return StartDeployment(req.get());
}

//------ method UnlockEnvironmentForCloud ---------

IClientUnlockEnvironmentForCloudRequest * CClientWsDeploy::createUnlockEnvironmentForCloudRequest()
{
	CUnlockEnvironmentForCloudRequest* request = new CUnlockEnvironmentForCloudRequest("WsDeploy");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientUnlockEnvironmentForCloudResponse * CClientWsDeploy::UnlockEnvironmentForCloud(IClientUnlockEnvironmentForCloudRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CUnlockEnvironmentForCloudRequest* esprequest = static_cast<CUnlockEnvironmentForCloudRequest*>(request);
	CUnlockEnvironmentForCloudResponse* espresponse = new CUnlockEnvironmentForCloudResponse("WsDeploy");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientWsDeploy::async_UnlockEnvironmentForCloud(IClientUnlockEnvironmentForCloudRequest *request, IClientWsDeployEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CUnlockEnvironmentForCloudRequest* esprequest = static_cast<CUnlockEnvironmentForCloudRequest*>(request);
	esprequest->setMethod("UnlockEnvironmentForCloud");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientWsDeploy::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientUnlockEnvironmentForCloudResponse *CClientWsDeploy::UnlockEnvironmentForCloudFn(const char * Ip_, const char * UserName_, const char * NewEnvXml_, IConstWsDeployReqInfo &ReqInfo_)
{
	Owned<IClientUnlockEnvironmentForCloudRequest> req =  createUnlockEnvironmentForCloudRequest();
	req->setIp(Ip_);
	req->setUserName(UserName_);
	req->setNewEnvXml(NewEnvXml_);
	req->setReqInfo(ReqInfo_);
	return UnlockEnvironmentForCloud(req.get());
}

//------ method UnlockUser ---------

IClientUnlockUserRequest * CClientWsDeploy::createUnlockUserRequest()
{
	CUnlockUserRequest* request = new CUnlockUserRequest("WsDeploy");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientUnlockUserResponse * CClientWsDeploy::UnlockUser(IClientUnlockUserRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CUnlockUserRequest* esprequest = static_cast<CUnlockUserRequest*>(request);
	CUnlockUserResponse* espresponse = new CUnlockUserResponse("WsDeploy");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientWsDeploy::async_UnlockUser(IClientUnlockUserRequest *request, IClientWsDeployEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CUnlockUserRequest* esprequest = static_cast<CUnlockUserRequest*>(request);
	esprequest->setMethod("UnlockUser");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientWsDeploy::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientUnlockUserResponse *CClientWsDeploy::UnlockUserFn(IConstWsDeployReqInfo &ReqInfo_)
{
	Owned<IClientUnlockUserRequest> req =  createUnlockUserRequest();
	req->setReqInfo(ReqInfo_);
	return UnlockUser(req.get());
}

int CClientWsDeploy::transferThunkEvent(void *data)
{
	IRpcResponseBinding *response = (IRpcResponseBinding *)data;
	if (response!=NULL)
	{
		IClientWsDeployEvents *eventSink = (IClientWsDeployEvents *)response->getEventSink();
		response->lock();

		if (stricmp(response->getMethod(), "AddReqdComps")==0)
		{
			IClientAddReqdCompsResponse* icresp = dynamic_cast<IClientAddReqdCompsResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onAddReqdCompsComplete(icresp, response->queryState());
				else
					eventSink->onAddReqdCompsError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "BuildEnvironment")==0)
		{
			IClientBuildEnvironmentResponse* icresp = dynamic_cast<IClientBuildEnvironmentResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onBuildEnvironmentComplete(icresp, response->queryState());
				else
					eventSink->onBuildEnvironmentError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "ClientAlive")==0)
		{
			IClientClientAliveResponse* icresp = dynamic_cast<IClientClientAliveResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onClientAliveComplete(icresp, response->queryState());
				else
					eventSink->onClientAliveError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "DisplaySettings")==0)
		{
			IClientDisplaySettingsResponse* icresp = dynamic_cast<IClientDisplaySettingsResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onDisplaySettingsComplete(icresp, response->queryState());
				else
					eventSink->onDisplaySettingsError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "GetBuildServerDirs")==0)
		{
			IClientGetBuildServerDirsResponse* icresp = dynamic_cast<IClientGetBuildServerDirsResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onGetBuildServerDirsComplete(icresp, response->queryState());
				else
					eventSink->onGetBuildServerDirsError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "GetBuildSetInfo")==0)
		{
			IClientGetBuildSetInfoResponse* icresp = dynamic_cast<IClientGetBuildSetInfoResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onGetBuildSetInfoComplete(icresp, response->queryState());
				else
					eventSink->onGetBuildSetInfoError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "GetComputersForRoxie")==0)
		{
			IClientGetComputersForRoxieResponse* icresp = dynamic_cast<IClientGetComputersForRoxieResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onGetComputersForRoxieComplete(icresp, response->queryState());
				else
					eventSink->onGetComputersForRoxieError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "GetDeployableComps")==0)
		{
			IClientGetDeployableCompsResponse* icresp = dynamic_cast<IClientGetDeployableCompsResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onGetDeployableCompsComplete(icresp, response->queryState());
				else
					eventSink->onGetDeployableCompsError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "GetEnvironment")==0)
		{
			IClientGetEnvironmentResponse* icresp = dynamic_cast<IClientGetEnvironmentResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onGetEnvironmentComplete(icresp, response->queryState());
				else
					eventSink->onGetEnvironmentError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "GetNavTreeDefn")==0)
		{
			IClientGetNavTreeDefnResponse* icresp = dynamic_cast<IClientGetNavTreeDefnResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onGetNavTreeDefnComplete(icresp, response->queryState());
				else
					eventSink->onGetNavTreeDefnError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "GetSubnetIPAddr")==0)
		{
			IClientGetSubnetIPAddrResponse* icresp = dynamic_cast<IClientGetSubnetIPAddrResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onGetSubnetIPAddrComplete(icresp, response->queryState());
				else
					eventSink->onGetSubnetIPAddrError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "GetSummary")==0)
		{
			IClientGetSummaryResponse* icresp = dynamic_cast<IClientGetSummaryResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onGetSummaryComplete(icresp, response->queryState());
				else
					eventSink->onGetSummaryError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "GetValue")==0)
		{
			IClientGetValueResponse* icresp = dynamic_cast<IClientGetValueResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onGetValueComplete(icresp, response->queryState());
				else
					eventSink->onGetValueError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "Graph")==0)
		{
			IClientGraphResponse* icresp = dynamic_cast<IClientGraphResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onGraphComplete(icresp, response->queryState());
				else
					eventSink->onGraphError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "HandleAccessRules")==0)
		{
			IClientHandleAccessRulesResponse* icresp = dynamic_cast<IClientHandleAccessRulesResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onHandleAccessRulesComplete(icresp, response->queryState());
				else
					eventSink->onHandleAccessRulesError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "HandleAttributeAdd")==0)
		{
			IClientHandleAttributeAddResponse* icresp = dynamic_cast<IClientHandleAttributeAddResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onHandleAttributeAddComplete(icresp, response->queryState());
				else
					eventSink->onHandleAttributeAddError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "HandleAttributeDelete")==0)
		{
			IClientHandleAttributeDeleteResponse* icresp = dynamic_cast<IClientHandleAttributeDeleteResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onHandleAttributeDeleteComplete(icresp, response->queryState());
				else
					eventSink->onHandleAttributeDeleteError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "HandleBaseAccessControlList")==0)
		{
			IClientHandleBaseAccessControlListResponse* icresp = dynamic_cast<IClientHandleBaseAccessControlListResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onHandleBaseAccessControlListComplete(icresp, response->queryState());
				else
					eventSink->onHandleBaseAccessControlListError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "HandleComponent")==0)
		{
			IClientHandleComponentResponse* icresp = dynamic_cast<IClientHandleComponentResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onHandleComponentComplete(icresp, response->queryState());
				else
					eventSink->onHandleComponentError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "HandleComputer")==0)
		{
			IClientHandleComputerResponse* icresp = dynamic_cast<IClientHandleComputerResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onHandleComputerComplete(icresp, response->queryState());
				else
					eventSink->onHandleComputerError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "HandleEspServiceBindings")==0)
		{
			IClientHandleEspServiceBindingsResponse* icresp = dynamic_cast<IClientHandleEspServiceBindingsResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onHandleEspServiceBindingsComplete(icresp, response->queryState());
				else
					eventSink->onHandleEspServiceBindingsError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "HandleInstance")==0)
		{
			IClientHandleInstanceResponse* icresp = dynamic_cast<IClientHandleInstanceResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onHandleInstanceComplete(icresp, response->queryState());
				else
					eventSink->onHandleInstanceError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "HandleRows")==0)
		{
			IClientHandleRowsResponse* icresp = dynamic_cast<IClientHandleRowsResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onHandleRowsComplete(icresp, response->queryState());
				else
					eventSink->onHandleRowsError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "HandleRoxieOperation")==0)
		{
			IClientHandleRoxieOperationResponse* icresp = dynamic_cast<IClientHandleRoxieOperationResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onHandleRoxieOperationComplete(icresp, response->queryState());
				else
					eventSink->onHandleRoxieOperationError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "HandleThorTopology")==0)
		{
			IClientHandleThorTopologyResponse* icresp = dynamic_cast<IClientHandleThorTopologyResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onHandleThorTopologyComplete(icresp, response->queryState());
				else
					eventSink->onHandleThorTopologyError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "HandleTopology")==0)
		{
			IClientHandleTopologyResponse* icresp = dynamic_cast<IClientHandleTopologyResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onHandleTopologyComplete(icresp, response->queryState());
				else
					eventSink->onHandleTopologyError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "ImportBuild")==0)
		{
			IClientImportBuildResponse* icresp = dynamic_cast<IClientImportBuildResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onImportBuildComplete(icresp, response->queryState());
				else
					eventSink->onImportBuildError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "LockEnvironmentForCloud")==0)
		{
			IClientLockEnvironmentForCloudResponse* icresp = dynamic_cast<IClientLockEnvironmentForCloudResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onLockEnvironmentForCloudComplete(icresp, response->queryState());
				else
					eventSink->onLockEnvironmentForCloudError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "NavMenuEvent")==0)
		{
			IClientNavMenuEventResponse* icresp = dynamic_cast<IClientNavMenuEventResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onNavMenuEventComplete(icresp, response->queryState());
				else
					eventSink->onNavMenuEventError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "NotifyInitSystemSaveEnvForCloud")==0)
		{
			IClientNotifyInitSystemSaveEnvForCloudResponse* icresp = dynamic_cast<IClientNotifyInitSystemSaveEnvForCloudResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onNotifyInitSystemSaveEnvForCloudComplete(icresp, response->queryState());
				else
					eventSink->onNotifyInitSystemSaveEnvForCloudError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "Ping")==0)
		{
			IClientWsDeployPingResponse* icresp = dynamic_cast<IClientWsDeployPingResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onPingComplete(icresp, response->queryState());
				else
					eventSink->onPingError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "RollbackEnvironmentForCloud")==0)
		{
			IClientRollbackEnvironmentForCloudResponse* icresp = dynamic_cast<IClientRollbackEnvironmentForCloudResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onRollbackEnvironmentForCloudComplete(icresp, response->queryState());
				else
					eventSink->onRollbackEnvironmentForCloudError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "SaveEnvironmentForCloud")==0)
		{
			IClientSaveEnvironmentForCloudResponse* icresp = dynamic_cast<IClientSaveEnvironmentForCloudResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onSaveEnvironmentForCloudComplete(icresp, response->queryState());
				else
					eventSink->onSaveEnvironmentForCloudError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "SaveSetting")==0)
		{
			IClientSaveSettingResponse* icresp = dynamic_cast<IClientSaveSettingResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onSaveSettingComplete(icresp, response->queryState());
				else
					eventSink->onSaveSettingError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "SetEnvironment")==0)
		{
			IClientSetEnvironmentResponse* icresp = dynamic_cast<IClientSetEnvironmentResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onSetEnvironmentComplete(icresp, response->queryState());
				else
					eventSink->onSetEnvironmentError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "StartDeployment")==0)
		{
			IClientStartDeploymentResponse* icresp = dynamic_cast<IClientStartDeploymentResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onStartDeploymentComplete(icresp, response->queryState());
				else
					eventSink->onStartDeploymentError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "UnlockEnvironmentForCloud")==0)
		{
			IClientUnlockEnvironmentForCloudResponse* icresp = dynamic_cast<IClientUnlockEnvironmentForCloudResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onUnlockEnvironmentForCloudComplete(icresp, response->queryState());
				else
					eventSink->onUnlockEnvironmentForCloudError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "UnlockUser")==0)
		{
			IClientUnlockUserResponse* icresp = dynamic_cast<IClientUnlockUserResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onUnlockUserComplete(icresp, response->queryState());
				else
					eventSink->onUnlockUserError(icresp,response->queryState());
			}
		}
		response->unlock();
	}
	return 0;
}

static IRpcResponseBinding* createWsDeployResponseObject(IRpcRequestBinding *request)
{
	const char* method = request->getMethod();
	if (stricmp(method, "AddReqdComps")==0)
		return new CAddReqdCompsResponse("WsDeploy", request);
	if (stricmp(method, "BuildEnvironment")==0)
		return new CBuildEnvironmentResponse("WsDeploy", request);
	if (stricmp(method, "ClientAlive")==0)
		return new CClientAliveResponse("WsDeploy", request);
	if (stricmp(method, "DisplaySettings")==0)
		return new CDisplaySettingsResponse("WsDeploy", request);
	if (stricmp(method, "GetBuildServerDirs")==0)
		return new CGetBuildServerDirsResponse("WsDeploy", request);
	if (stricmp(method, "GetBuildSetInfo")==0)
		return new CGetBuildSetInfoResponse("WsDeploy", request);
	if (stricmp(method, "GetComputersForRoxie")==0)
		return new CGetComputersForRoxieResponse("WsDeploy", request);
	if (stricmp(method, "GetDeployableComps")==0)
		return new CGetDeployableCompsResponse("WsDeploy", request);
	if (stricmp(method, "GetEnvironment")==0)
		return new CGetEnvironmentResponse("WsDeploy", request);
	if (stricmp(method, "GetNavTreeDefn")==0)
		return new CGetNavTreeDefnResponse("WsDeploy", request);
	if (stricmp(method, "GetSubnetIPAddr")==0)
		return new CGetSubnetIPAddrResponse("WsDeploy", request);
	if (stricmp(method, "GetSummary")==0)
		return new CGetSummaryResponse("WsDeploy", request);
	if (stricmp(method, "GetValue")==0)
		return new CGetValueResponse("WsDeploy", request);
	if (stricmp(method, "Graph")==0)
		return new CGraphResponse("WsDeploy", request);
	if (stricmp(method, "HandleAccessRules")==0)
		return new CHandleAccessRulesResponse("WsDeploy", request);
	if (stricmp(method, "HandleAttributeAdd")==0)
		return new CHandleAttributeAddResponse("WsDeploy", request);
	if (stricmp(method, "HandleAttributeDelete")==0)
		return new CHandleAttributeDeleteResponse("WsDeploy", request);
	if (stricmp(method, "HandleBaseAccessControlList")==0)
		return new CHandleBaseAccessControlListResponse("WsDeploy", request);
	if (stricmp(method, "HandleComponent")==0)
		return new CHandleComponentResponse("WsDeploy", request);
	if (stricmp(method, "HandleComputer")==0)
		return new CHandleComputerResponse("WsDeploy", request);
	if (stricmp(method, "HandleEspServiceBindings")==0)
		return new CHandleEspServiceBindingsResponse("WsDeploy", request);
	if (stricmp(method, "HandleInstance")==0)
		return new CHandleInstanceResponse("WsDeploy", request);
	if (stricmp(method, "HandleRows")==0)
		return new CHandleRowsResponse("WsDeploy", request);
	if (stricmp(method, "HandleRoxieOperation")==0)
		return new CHandleRoxieOperationResponse("WsDeploy", request);
	if (stricmp(method, "HandleThorTopology")==0)
		return new CHandleThorTopologyResponse("WsDeploy", request);
	if (stricmp(method, "HandleTopology")==0)
		return new CHandleTopologyResponse("WsDeploy", request);
	if (stricmp(method, "ImportBuild")==0)
		return new CImportBuildResponse("WsDeploy", request);
	if (stricmp(method, "LockEnvironmentForCloud")==0)
		return new CLockEnvironmentForCloudResponse("WsDeploy", request);
	if (stricmp(method, "NavMenuEvent")==0)
		return new CNavMenuEventResponse("WsDeploy", request);
	if (stricmp(method, "NotifyInitSystemSaveEnvForCloud")==0)
		return new CNotifyInitSystemSaveEnvForCloudResponse("WsDeploy", request);
	if (stricmp(method, "Ping")==0)
		return new CWsDeployPingResponse("WsDeploy", request);
	if (stricmp(method, "RollbackEnvironmentForCloud")==0)
		return new CRollbackEnvironmentForCloudResponse("WsDeploy", request);
	if (stricmp(method, "SaveEnvironmentForCloud")==0)
		return new CSaveEnvironmentForCloudResponse("WsDeploy", request);
	if (stricmp(method, "SaveSetting")==0)
		return new CSaveSettingResponse("WsDeploy", request);
	if (stricmp(method, "SetEnvironment")==0)
		return new CSetEnvironmentResponse("WsDeploy", request);
	if (stricmp(method, "StartDeployment")==0)
		return new CStartDeploymentResponse("WsDeploy", request);
	if (stricmp(method, "UnlockEnvironmentForCloud")==0)
		return new CUnlockEnvironmentForCloudResponse("WsDeploy", request);
	if (stricmp(method, "UnlockUser")==0)
		return new CUnlockUserResponse("WsDeploy", request);
	return NULL;
}

#ifdef _WIN32
void CClientWsDeploy::espWorkerThread(void* data)
#else
void *CClientWsDeploy::espWorkerThread(void *data)
#endif
{
	IRpcRequestBinding *request = (IRpcRequestBinding *) data;

	if (request != NULL)
	{
		request->lock();
		IRpcResponseBinding *response=createWsDeployResponseObject(request);
		if (response!=NULL)
		{
			try{
				request->post(*response);
			}
			catch(IException* ex){
				StringBuffer errorStr;
				ex->errorMessage(errorStr);
				ERRLOG("CClientWsDeploy::espWorkerThread(%s)--Exception caught while posting async request: %s", request->getMethod(), errorStr.str());
				ex->Release();
			}
			catch(...){
				ERRLOG("Unknown exception caught while posting async request");
			}
		}
#ifdef USE_CLIENT_THREAD
		ThunkToClientThread(request->getThunkHandle(), transferThunkEvent, (void *)response);
#else
		transferThunkEvent((void *)response);
#endif
		request->unlock();
		if(request->queryState()!=NULL)
			request->queryState()->Release();

		if(response!=NULL)
			response->Release();

		request->Release();
	}
#if defined(_WIN32)
#else
	return (void *) 0 ;
#endif
}



extern "C" IClientWsDeploy * createWsDeployClient() {  return new CClientWsDeploy(); }


#endif //WsDeploy_ESPGEN_INCLUDED
