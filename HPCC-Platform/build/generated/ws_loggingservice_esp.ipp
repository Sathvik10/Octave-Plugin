// *** Source file generated by HIDL Version 1.3 from ws_loggingservice.ecm ***
// *** Not to be hand edited (changes will be lost on re-generation) ***

#ifndef ws_loggingservice_EX_ESPGEN_INCLUDED
#define ws_loggingservice_EX_ESPGEN_INCLUDED

#pragma warning( disable : 4786)

//JLib
#include "jliball.hpp"

//SCM Interfaces
#include "esp.hpp"
#include "soapesp.hpp"
#include "ws_loggingservice.hpp"
//ESP Bindings
#include "SOAP/Platform/soapmessage.hpp"
#include "SOAP/Platform/soapmacro.hpp"
#include "SOAP/Platform/soapservice.hpp"
#include "SOAP/Platform/soapparam.hpp"
#include "SOAP/client/soapclient.hpp"


namespace ws_loggingservice
{

class CLogItem : public CSoapComplexType,
   implements IEspLogItem,
   implements IClientLogItem
{
protected:
	SoapStringParam m_Name;
	SoapStringParam m_Value;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CLogItem(const char *serviceName, const char *bcompat);

	CLogItem(const char *serviceName, IRpcMessageBinding *init=NULL);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "LogItem";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CLogItem &from);

	void copy(IConstLogItem &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstLogItem &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	const char * getName();
	const char * getValue();
	void setName(const char * val);
	void setValue(const char * val);
};

class CGetTransactionSeedRequest : public CSoapRequestBinding,
   implements IEspGetTransactionSeedRequest,
   implements IClientGetTransactionSeedRequest
{
protected:
	SoapStringParam m_Application;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CGetTransactionSeedRequest(const char *serviceName, const char *bcompat);

	CGetTransactionSeedRequest(const char *serviceName, IRpcMessageBinding *init=NULL);
	CGetTransactionSeedRequest(const char *serviceName, IRpcMessage* rpcmsg);
	CGetTransactionSeedRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	IEspClientRpcSettings &rpc(){return *static_cast<IEspClientRpcSettings*>(this);}


	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "GetTransactionSeedRequest";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CGetTransactionSeedRequest &from);

	void copy(IConstGetTransactionSeedRequest &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstGetTransactionSeedRequest &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	const char * getApplication();
	void setApplication(const char * val);
};

class CLoggingServiceResponse : public CSoapResponseBinding,
   implements IEspLoggingServiceResponse,
   implements IClientLoggingServiceResponse
{
protected:
	SoapParam<int> m_StatusCode;
	SoapStringParam m_StatusMessage;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CLoggingServiceResponse(const char *serviceName, const char *bcompat);

	CLoggingServiceResponse(const char *serviceName, IRpcMessageBinding *init=NULL);
	CLoggingServiceResponse(const char *serviceName, IRpcMessage* rpcmsg);
	CLoggingServiceResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "LoggingServiceResponse";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CLoggingServiceResponse &from);

	void copy(IConstLoggingServiceResponse &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstLoggingServiceResponse &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	virtual void setRedirectUrl(const char *url)
	{ CSoapResponseBinding::setRedirectUrl(url); }

	virtual const IMultiException& getExceptions()
	{ return CSoapResponseBinding::getExceptions(); }

	virtual int queryClientStatus()
	{ return CSoapResponseBinding::getRpcState(); }

	virtual void noteException(IException& e)
	{  CSoapResponseBinding::noteException(e); }

	int getStatusCode();
	const char * getStatusMessage();
	void setStatusCode(int val);
	void setStatusMessage(const char * val);
};

class CGetTransactionSeedResponse : public CSoapResponseBinding,
   implements IEspGetTransactionSeedResponse,
   implements IClientGetTransactionSeedResponse
{
protected:
	SoapStringParam m_SeedId;
	SoapParam<int> m_StatusCode;
	SoapStringParam m_StatusMessage;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CGetTransactionSeedResponse(const char *serviceName, const char *bcompat);

	CGetTransactionSeedResponse(const char *serviceName, IRpcMessageBinding *init=NULL);
	CGetTransactionSeedResponse(const char *serviceName, IRpcMessage* rpcmsg);
	CGetTransactionSeedResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "GetTransactionSeedResponse";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CGetTransactionSeedResponse &from);

	void copy(IConstGetTransactionSeedResponse &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstGetTransactionSeedResponse &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	virtual void setRedirectUrl(const char *url)
	{ CSoapResponseBinding::setRedirectUrl(url); }

	virtual const IMultiException& getExceptions()
	{ return CSoapResponseBinding::getExceptions(); }

	virtual int queryClientStatus()
	{ return CSoapResponseBinding::getRpcState(); }

	virtual void noteException(IException& e)
	{  CSoapResponseBinding::noteException(e); }

	const char * getSeedId();
	int getStatusCode();
	const char * getStatusMessage();
	void setSeedId(const char * val);
	void setStatusCode(int val);
	void setStatusMessage(const char * val);
};

class CUpdateLogRequest : public CSoapRequestBinding,
   implements IEspUpdateLogRequest,
   implements IClientUpdateLogRequest
{
protected:
	SoapStringParam m_Option;
	SoapStringParam m_LogContent;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CUpdateLogRequest(const char *serviceName, const char *bcompat);

	CUpdateLogRequest(const char *serviceName, IRpcMessageBinding *init=NULL);
	CUpdateLogRequest(const char *serviceName, IRpcMessage* rpcmsg);
	CUpdateLogRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	IEspClientRpcSettings &rpc(){return *static_cast<IEspClientRpcSettings*>(this);}


	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "UpdateLogRequest";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CUpdateLogRequest &from);

	void copy(IConstUpdateLogRequest &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstUpdateLogRequest &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	const char * getOption();
	const char * getLogContent();
	void setOption(const char * val);
	void setLogContent(const char * val);
};

class CUpdateLogResponse : public CSoapResponseBinding,
   implements IEspUpdateLogResponse,
   implements IClientUpdateLogResponse
{
protected:
	SoapStringParam m_Response;
	SoapParam<int> m_StatusCode;
	SoapStringParam m_StatusMessage;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CUpdateLogResponse(const char *serviceName, const char *bcompat);

	CUpdateLogResponse(const char *serviceName, IRpcMessageBinding *init=NULL);
	CUpdateLogResponse(const char *serviceName, IRpcMessage* rpcmsg);
	CUpdateLogResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "UpdateLogResponse";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CUpdateLogResponse &from);

	void copy(IConstUpdateLogResponse &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstUpdateLogResponse &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	virtual void setRedirectUrl(const char *url)
	{ CSoapResponseBinding::setRedirectUrl(url); }

	virtual const IMultiException& getExceptions()
	{ return CSoapResponseBinding::getExceptions(); }

	virtual int queryClientStatus()
	{ return CSoapResponseBinding::getRpcState(); }

	virtual void noteException(IException& e)
	{  CSoapResponseBinding::noteException(e); }

	const char * getResponse();
	int getStatusCode();
	const char * getStatusMessage();
	void setResponse(const char * val);
	void setStatusCode(int val);
	void setStatusMessage(const char * val);
};

class CWsLoggingServicePingRequest : public CSoapRequestBinding,
   implements IEspWsLoggingServicePingRequest,
   implements IClientWsLoggingServicePingRequest
{
protected:

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CWsLoggingServicePingRequest(const char *serviceName, const char *bcompat);

	CWsLoggingServicePingRequest(const char *serviceName, IRpcMessageBinding *init=NULL);
	CWsLoggingServicePingRequest(const char *serviceName, IRpcMessage* rpcmsg);
	CWsLoggingServicePingRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	IEspClientRpcSettings &rpc(){return *static_cast<IEspClientRpcSettings*>(this);}


	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "WsLoggingServicePingRequest";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CWsLoggingServicePingRequest &from);

	void copy(IConstWsLoggingServicePingRequest &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstWsLoggingServicePingRequest &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

};

class CWsLoggingServicePingResponse : public CSoapResponseBinding,
   implements IEspWsLoggingServicePingResponse,
   implements IClientWsLoggingServicePingResponse
{
protected:

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CWsLoggingServicePingResponse(const char *serviceName, const char *bcompat);

	CWsLoggingServicePingResponse(const char *serviceName, IRpcMessageBinding *init=NULL);
	CWsLoggingServicePingResponse(const char *serviceName, IRpcMessage* rpcmsg);
	CWsLoggingServicePingResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "WsLoggingServicePingResponse";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CWsLoggingServicePingResponse &from);

	void copy(IConstWsLoggingServicePingResponse &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstWsLoggingServicePingResponse &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	virtual void setRedirectUrl(const char *url)
	{ CSoapResponseBinding::setRedirectUrl(url); }

	virtual const IMultiException& getExceptions()
	{ return CSoapResponseBinding::getExceptions(); }

	virtual int queryClientStatus()
	{ return CSoapResponseBinding::getRpcState(); }

	virtual void noteException(IException& e)
	{  CSoapResponseBinding::noteException(e); }

};

class CWsLoggingService : public CInterface,
	implements IEspWsLoggingService
{
private:
	IEspContainer* m_container;
public:
	IMPLEMENT_IINTERFACE;

	CWsLoggingService(){}
	virtual ~CWsLoggingService(){}
	virtual void init(IPropertyTree *cfg, const char *process, const char *service)
	{
	}
	virtual bool init(const char * service, const char * type, IPropertyTree * cfg, const char * process)
	{
		return true;
	}
	virtual void setContainer(IEspContainer *c)
	{
		m_container = c;
	}
	virtual IEspContainer *queryContainer()
	{
		return m_container;
	}
	virtual const char* getServiceType(){return "WsLoggingService";}

	virtual bool unsubscribeServiceFromDali(){return false;}

	virtual bool subscribeServiceToDali(){return false;}

	virtual bool detachServiceFromDali(){return false;}

	virtual bool attachServiceToDali(){return false;}

	virtual bool canDetachFromDali(){return false;}

	//bool onGetTransactionSeed(IEspContext &context, IEspGetTransactionSeedRequest &req, IEspGetTransactionSeedResponse &resp)
	//{
		//return false;
	//}
	bool onPing(IEspContext &context, IEspWsLoggingServicePingRequest &req, IEspWsLoggingServicePingResponse &resp)
	{
		return true;
	}
	//bool onUpdateLog(IEspContext &context, IEspUpdateLogRequest &req, IEspUpdateLogResponse &resp)
	//{
		//return false;
	//}
};





class CWsLoggingServiceSoapBinding : public CHttpSoapBinding
{
public:
	CWsLoggingServiceSoapBinding(http_soap_log_level level=hsl_none);
	CWsLoggingServiceSoapBinding(IPropertyTree* cfg, const char *bindname=NULL, const char *procname=NULL, http_soap_log_level level=hsl_none);
	virtual void init_strings();
	virtual unsigned getCacheMethodCount(){return m_cacheMethodCount;}
	virtual int processRequest(IRpcMessage* rpc_call, IRpcMessage* rpc_response);
	int getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &content, const char *service, const char *method, bool mda);
	virtual int getMethodHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &page, bool bIncludeFormTag);
	int getQualifiedNames(IEspContext& ctx, MethodInfoArray & methods);
	StringBuffer & getServiceName(StringBuffer &resp);
	bool isValidServiceName(IEspContext &context, const char *name);
	bool qualifyMethodName(IEspContext &context, const char *methname, StringBuffer *methQName);
	bool qualifyServiceName(IEspContext &context, const char *servname, const char *methname, StringBuffer &servQName, StringBuffer *methQName);
	virtual int onGetFile(IEspContext &context, CHttpRequest* request, CHttpResponse* response, const char *pathex);
	virtual int onGetForm(IEspContext &context, CHttpRequest* request, CHttpResponse* response, const char *service, const char *method);
	virtual int onGetXForm(IEspContext &context, CHttpRequest* request, CHttpResponse* response, const char *service, const char *method);
	virtual bool supportGeneratedForms(){return false;}
	virtual int onGetService(IEspContext &context, CHttpRequest* request, CHttpResponse* response, const char *service, const char *method, const char *pathex);
	virtual IRpcRequestBinding *createReqBinding(IEspContext &context, IHttpMessage* request, const char *service, const char *method);
	virtual int onGetInstantQuery(IEspContext &context, CHttpRequest* request, CHttpResponse* response, const char *service, const char *method);
	void setXslProcessor(IInterface *xslp){}
	unsigned m_cacheMethodCount = 0;
};



class CClientWsLoggingService : public CInterface,
	implements IClientWsLoggingService
{
protected:
	StringBuffer soap_proxy;
	StringBuffer soap_url;
	StringBuffer soap_userid;
	StringBuffer soap_password;
	StringBuffer soap_realm;
	StringBuffer soap_action;
	long soap_reqid = 0;

public:
	IMPLEMENT_IINTERFACE;

	CClientWsLoggingService()
	{
		soap_reqid=0;
			soap_action.append("WsLoggingService");
	}
	virtual ~CClientWsLoggingService(){}
	virtual void setProxyAddress(const char *address)
	{
		soap_proxy.set(address);
	}
	virtual void addServiceUrl(const char *url)
	{
		soap_url.set(url);
	}
	virtual void removeServiceUrl(const char *url)
	{
	}
	virtual void setUsernameToken(const char *userid,const char *password,const char *realm)
	{
		 soap_userid.set(userid);
		 soap_password.set(password);
		 soap_realm.set(realm);
	}
	virtual void setAction(const char *action)
	{
		soap_action.set(action);
	}

	virtual IClientGetTransactionSeedRequest * createGetTransactionSeedRequest();
	virtual IClientGetTransactionSeedResponse * GetTransactionSeed(IClientGetTransactionSeedRequest *request);
	virtual void async_GetTransactionSeed(IClientGetTransactionSeedRequest *request, IClientWsLoggingServiceEvents *events,IInterface* state=0);

	virtual IClientGetTransactionSeedResponse *GetTransactionSeedFn(const char * Application_);

	virtual IClientWsLoggingServicePingRequest * createPingRequest();
	virtual IClientWsLoggingServicePingResponse * Ping(IClientWsLoggingServicePingRequest *request);
	virtual void async_Ping(IClientWsLoggingServicePingRequest *request, IClientWsLoggingServiceEvents *events,IInterface* state=0);

	virtual IClientWsLoggingServicePingResponse *PingFn();

	virtual IClientUpdateLogRequest * createUpdateLogRequest();
	virtual IClientUpdateLogResponse * UpdateLog(IClientUpdateLogRequest *request);
	virtual void async_UpdateLog(IClientUpdateLogRequest *request, IClientWsLoggingServiceEvents *events,IInterface* state=0);

	virtual IClientUpdateLogResponse *UpdateLogFn(const char * Option_, const char * LogContent_);
	static int transferThunkEvent(void *data);
#ifdef _WIN32
	static void espWorkerThread(void* data);
#else
	static void *espWorkerThread(void *data);
#endif
};



}
using namespace ws_loggingservice;

#endif //ws_loggingservice_ESPGEN_INCLUDED
