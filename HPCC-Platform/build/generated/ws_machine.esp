// *** Source file generated by HIDL Version 1.3 from ws_machine.ecm ***
// *** Not to be hand edited (changes will be lost on re-generation) ***

#ifndef ws_machine_ESPGEN_INCLUDED
#define ws_machine_ESPGEN_INCLUDED

#include "ws_machine_esp.ipp"

#ifdef _WIN32
#include "edwin.h"
#include <process.h>
#endif



//=======================================================
// class CDiskUsage Implementation
//=======================================================

CDiskUsage::CDiskUsage(const char *serviceName, IRpcMessageBinding *init)
	: m_Name(nilRemove),m_Path(nilRemove),m_Description(nilRemove),m_InUse(nilRemove),m_Available(nilRemove),m_PercentAvailable(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("DiskUsage");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CDiskUsage::CDiskUsage(const char *serviceName, const char *bc)
	: m_Name(nilRemove),m_Path(nilRemove),m_Description(nilRemove),m_InUse(nilRemove),m_Available(nilRemove),m_PercentAvailable(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("DiskUsage");
}

StringBuffer &CDiskUsage::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:complexType name=\"%s\">\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Name\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Path\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Description\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"InUse\" type=\"xsd:long\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Available\" type=\"xsd:long\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"PercentAvailable\" type=\"xsd:int\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType>\n");
		}
	}
	return schema;
}

void CDiskUsage::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CDiskUsage::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CDiskUsage::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Name");
	form.appendf("  <tr><td><b>Name: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Path");
	form.appendf("  <tr><td><b>Path: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Description");
	form.appendf("  <tr><td><b>Description: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("InUse");
	form.appendf("  <tr><td><b>InUse: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Available");
	form.appendf("  <tr><td><b>Available: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix) extfix.append(prefix).append(".");
		extfix.append("PercentAvailable");
	form.appendf("  <tr><td><b>PercentAvailable: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CDiskUsage::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CDiskUsage::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_Name.marshall(rpc_resp, "Name", "", "", "");
	m_Path.marshall(rpc_resp, "Path", "", "", "");
	m_Description.marshall(rpc_resp, "Description", "", "", "");
	m_InUse.marshall(rpc_resp, "InUse", "", "", "");
	m_Available.marshall(rpc_resp, "Available", "", "", "");
	m_PercentAvailable.marshall(rpc_resp, "PercentAvailable", "", "", "");
}


void CDiskUsage::copy(CDiskUsage &from)
{
	m_Name.copy(from.m_Name);
	m_Path.copy(from.m_Path);
	m_Description.copy(from.m_Description);
	m_InUse.copy(from.m_InUse);
	m_Available.copy(from.m_Available);
	m_PercentAvailable.copy(from.m_PercentAvailable);
}


void CDiskUsage::copy(IConstDiskUsage &ifrom)
{
	setName(ifrom.getName());
	setPath(ifrom.getPath());
	setDescription(ifrom.getDescription());
	setInUse(ifrom.getInUse());
	setAvailable(ifrom.getAvailable());
	setPercentAvailable(ifrom.getPercentAvailable());
}


void CDiskUsage::getAttributes(IProperties &attributes)
{
}


void CDiskUsage::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_Name.toStr(ctx, buffer, "Name", "", true, "", "");
	m_Path.toStr(ctx, buffer, "Path", "", true, "", "");
	m_Description.toStr(ctx, buffer, "Description", "", true, "", "");
	m_InUse.toStr(ctx, buffer, "InUse", "", true, "", "");
	m_Available.toStr(ctx, buffer, "Available", "", true, "", "");
	m_PercentAvailable.toStr(ctx, buffer, "PercentAvailable", "", true, "", "");
}


void CDiskUsage::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CDiskUsage::serializer(IEspContext* ctx, IConstDiskUsage &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<DiskUsage>");
	// field Name
	{
		const char* s = src.getName();
		if (s && *s)
		{
			buffer.append("<Name>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Name>");
		}
	}
	// field Path
	{
		const char* s = src.getPath();
		if (s && *s)
		{
			buffer.append("<Path>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Path>");
		}
	}
	// field Description
	{
		const char* s = src.getDescription();
		if (s && *s)
		{
			buffer.append("<Description>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Description>");
		}
	}
	// field InUse
	{
		//*** default kind: TK_INT; type=int64, name=InUse
		buffer.append("<InUse>");
		buffer.append(src.getInUse());
		buffer.append("</InUse>");
	}
	// field Available
	{
		//*** default kind: TK_INT; type=int64, name=Available
		buffer.append("<Available>");
		buffer.append(src.getAvailable());
		buffer.append("</Available>");
	}
	// field PercentAvailable
	{
		int n = src.getPercentAvailable();
		if (n)
			buffer.appendf("<PercentAvailable>%d</PercentAvailable>", n);
	}
	if (keepRootTag)
		buffer.append("</DiskUsage>");
}

bool CDiskUsage::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_Name.unmarshall(rpc_request, "Name", basepath);
	hasValue |= m_Path.unmarshall(rpc_request, "Path", basepath);
	hasValue |= m_Description.unmarshall(rpc_request, "Description", basepath);
	hasValue |= m_InUse.unmarshall(rpc_request, "InUse", basepath);
	hasValue |= m_Available.unmarshall(rpc_request, "Available", basepath);
	hasValue |= m_PercentAvailable.unmarshall(rpc_request, "PercentAvailable", basepath);
	return hasValue;
}

bool CDiskUsage::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Name.unmarshall(ctx, soapval, "Name");
	hasValue |= m_Path.unmarshall(ctx, soapval, "Path");
	hasValue |= m_Description.unmarshall(ctx, soapval, "Description");
	hasValue |= m_InUse.unmarshall(ctx, soapval, "InUse");
	hasValue |= m_Available.unmarshall(ctx, soapval, "Available");
	hasValue |= m_PercentAvailable.unmarshall(ctx, soapval, "PercentAvailable");
	return hasValue;
}

bool CDiskUsage::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Name.unmarshall(ctx, params, attachments, "Name", basepath);
	hasValue |= m_Path.unmarshall(ctx, params, attachments, "Path", basepath);
	hasValue |= m_Description.unmarshall(ctx, params, attachments, "Description", basepath);
	hasValue |= m_InUse.unmarshall(ctx, params, attachments, "InUse", basepath);
	hasValue |= m_Available.unmarshall(ctx, params, attachments, "Available", basepath);
	hasValue |= m_PercentAvailable.unmarshall(ctx, params, attachments, "PercentAvailable", basepath);
	return hasValue;
}

const char * CDiskUsage::getName() { return m_Name.query();}
const char * CDiskUsage::getPath() { return m_Path.query();}
const char * CDiskUsage::getDescription() { return m_Description.query();}
bool CDiskUsage::getInUse_isNull(){return m_InUse.is_nil();}
__int64 CDiskUsage::getInUse() { return m_InUse;}
bool CDiskUsage::getAvailable_isNull(){return m_Available.is_nil();}
__int64 CDiskUsage::getAvailable() { return m_Available;}
bool CDiskUsage::getPercentAvailable_isNull(){return m_PercentAvailable.is_nil();}
int CDiskUsage::getPercentAvailable() { return m_PercentAvailable;}
void CDiskUsage::setName(const char * val){ m_Name.set(val); }
void CDiskUsage::setPath(const char * val){ m_Path.set(val); }
void CDiskUsage::setDescription(const char * val){ m_Description.set(val); }
void CDiskUsage::setInUse_null(){ m_InUse.Nil(); }void CDiskUsage::setInUse(__int64 val){ m_InUse=val; }
void CDiskUsage::setAvailable_null(){ m_Available.Nil(); }void CDiskUsage::setAvailable(__int64 val){ m_Available=val; }
void CDiskUsage::setPercentAvailable_null(){ m_PercentAvailable.Nil(); }void CDiskUsage::setPercentAvailable(int val){ m_PercentAvailable=val; }
extern "C"  IEspDiskUsage *createDiskUsage(const char *serv, const char *msgname){return ((IEspDiskUsage *)new CDiskUsage(serv /*, msgname*/));}
extern "C"  IClientDiskUsage *createClientDiskUsage(const char *serv, const char *msgname){return ((IClientDiskUsage *)new CDiskUsage(serv /*, msgname*/));}

//=======================================================
// class CMachineUsage Implementation
//=======================================================

CMachineUsage::CMachineUsage(const char *serviceName, IRpcMessageBinding *init)
	: m_Name(nilRemove),m_NetAddress(nilRemove),m_Description(nilRemove),m_DiskUsages(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("MachineUsage");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CMachineUsage::CMachineUsage(const char *serviceName, const char *bc)
	: m_Name(nilRemove),m_NetAddress(nilRemove),m_Description(nilRemove),m_DiskUsages(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("MachineUsage");
}

StringBuffer &CMachineUsage::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:complexType name=\"%s\">\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Name\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"NetAddress\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Description\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"DiskUsages\" type=\"tns:ArrayOfDiskUsage\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType>\n");
		}
	}
	if (!(flags & 0x10)  || (flags & 0x100))
	{
		CDiskUsage::getXsdDefinition(context, request, schema, added);
	}
	if (added.getValue("DiskUsage") && added.getValue("ArrayOfDiskUsage")==NULL) {
		schema.append("<xsd:complexType name=\"ArrayOfDiskUsage\">\n");
		schema.append("<xsd:sequence>\n");
		schema.append("<xsd:element minOccurs=\"0\" maxOccurs=\"unbounded\" name=\"DiskUsage\" type=\"tns:DiskUsage\"/>\n");
		schema.append("</xsd:sequence>\n");
		schema.append("</xsd:complexType>\n");
		added.setValue("ArrayOfDiskUsage",1);
	}
	return schema;
}

void CMachineUsage::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CMachineUsage::getMapInfo(IMapInfo& info, BoolHash& added)
{
	if (!added.getValue("DiskUsage"))
	{
		added.setValue("DiskUsage",1);
		CDiskUsage::getMapInfo(info,added);
	}
}

StringBuffer &CMachineUsage::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Name");
	form.appendf("  <tr><td><b>Name: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("NetAddress");
	form.appendf("  <tr><td><b>NetAddress: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Description");
	form.appendf("  <tr><td><b>Description: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("DiskUsages");
	form.appendf("<tr><td><b>DiskUsages: </b></td><td>");
	form.appendf("<table><tr><td><textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea></td>", extfix.str());
	form.append("</tr></table>");
	form.append("</td></tr>");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CMachineUsage::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CMachineUsage::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_Name.marshall(rpc_resp, "Name", "", "", "");
	m_NetAddress.marshall(rpc_resp, "NetAddress", "", "", "");
	m_Description.marshall(rpc_resp, "Description", "", "", "");
	m_DiskUsages.marshall(rpc_resp, "DiskUsages", "DiskUsage");
}


void CMachineUsage::copy(CMachineUsage &from)
{
	m_Name.copy(from.m_Name);
	m_NetAddress.copy(from.m_NetAddress);
	m_Description.copy(from.m_Description);
	m_DiskUsages.copy(from.m_DiskUsages);
}


void CMachineUsage::copy(IConstMachineUsage &ifrom)
{
	setName(ifrom.getName());
	setNetAddress(ifrom.getNetAddress());
	setDescription(ifrom.getDescription());
	setDiskUsages(ifrom.getDiskUsages());
}


void CMachineUsage::getAttributes(IProperties &attributes)
{
}


void CMachineUsage::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_Name.toStr(ctx, buffer, "Name", "", true, "", "");
	m_NetAddress.toStr(ctx, buffer, "NetAddress", "", true, "", "");
	m_Description.toStr(ctx, buffer, "Description", "", true, "", "");
	m_DiskUsages.toStr(ctx, buffer, "DiskUsages", "DiskUsage");
}


void CMachineUsage::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CMachineUsage::serializer(IEspContext* ctx, IConstMachineUsage &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<MachineUsage>");
	// field Name
	{
		const char* s = src.getName();
		if (s && *s)
		{
			buffer.append("<Name>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Name>");
		}
	}
	// field NetAddress
	{
		const char* s = src.getNetAddress();
		if (s && *s)
		{
			buffer.append("<NetAddress>");
			encodeUtf8XML(s,buffer);
			buffer.append("</NetAddress>");
		}
	}
	// field Description
	{
		const char* s = src.getDescription();
		if (s && *s)
		{
			buffer.append("<Description>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Description>");
		}
	}
	// field DiskUsages
	{
		IArrayOf<IConstDiskUsage>& v = src.getDiskUsages();
		int size = v.length();
		if (size>0)
			buffer.append("<DiskUsages>");
		for (int i=0;i<size;i++)
		{
			buffer.append("<Item>");
			CDiskUsage::serializer(ctx,v.item(i),buffer,false);
			buffer.append("</Item>");
		}
		if (size>0)
			buffer.append("</DiskUsages>");
	}
	if (keepRootTag)
		buffer.append("</MachineUsage>");
}

bool CMachineUsage::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_Name.unmarshall(rpc_request, "Name", basepath);
	hasValue |= m_NetAddress.unmarshall(rpc_request, "NetAddress", basepath);
	hasValue |= m_Description.unmarshall(rpc_request, "Description", basepath);
	hasValue |= m_DiskUsages.unmarshall(rpc_request, "DiskUsages", basepath);
	return hasValue;
}

bool CMachineUsage::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Name.unmarshall(ctx, soapval, "Name");
	hasValue |= m_NetAddress.unmarshall(ctx, soapval, "NetAddress");
	hasValue |= m_Description.unmarshall(ctx, soapval, "Description");
	hasValue |= m_DiskUsages.unmarshall(ctx, soapval, "DiskUsages");
	return hasValue;
}

bool CMachineUsage::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Name.unmarshall(ctx, params, attachments, "Name", basepath);
	hasValue |= m_NetAddress.unmarshall(ctx, params, attachments, "NetAddress", basepath);
	hasValue |= m_Description.unmarshall(ctx, params, attachments, "Description", basepath);
	hasValue |= m_DiskUsages.unmarshall(ctx, params, attachments, "DiskUsages", basepath);
	return hasValue;
}

const char * CMachineUsage::getName() { return m_Name.query();}
const char * CMachineUsage::getNetAddress() { return m_NetAddress.query();}
const char * CMachineUsage::getDescription() { return m_Description.query();}
IArrayOf<IConstDiskUsage> & CMachineUsage::getDiskUsages() { return (IArrayOf<IConstDiskUsage> &) m_DiskUsages; }
void CMachineUsage::setName(const char * val){ m_Name.set(val); }
void CMachineUsage::setNetAddress(const char * val){ m_NetAddress.set(val); }
void CMachineUsage::setDescription(const char * val){ m_Description.set(val); }
void CMachineUsage::setDiskUsages(IArrayOf<IEspDiskUsage> &val)
{
	m_DiskUsages->kill();
	IArrayOf<IConstDiskUsage> &target = m_DiskUsages.getValue();
	ForEachItemIn(idx, val)
	{
		IEspDiskUsage &item = (val).item(idx);
		item.Link();
		target.append(item);
	}
}
void CMachineUsage::setDiskUsages(IArrayOf<IConstDiskUsage> &val)
{
	m_DiskUsages->kill();
	IArrayOf<IConstDiskUsage> &target = m_DiskUsages.getValue();
	ForEachItemIn(idx, val)
	{
		IConstDiskUsage &item = val.item(idx);
		item.Link();
		target.append(item);
	}
}
extern "C"  IEspMachineUsage *createMachineUsage(const char *serv, const char *msgname){return ((IEspMachineUsage *)new CMachineUsage(serv /*, msgname*/));}
extern "C"  IClientMachineUsage *createClientMachineUsage(const char *serv, const char *msgname){return ((IClientMachineUsage *)new CMachineUsage(serv /*, msgname*/));}

//=======================================================
// class CComponent Implementation
//=======================================================

CComponent::CComponent(const char *serviceName, IRpcMessageBinding *init)
	: m_Type(nilRemove),m_Name(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("Component");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CComponent::CComponent(const char *serviceName, const char *bc)
	: m_Type(nilRemove),m_Name(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("Component");
}

StringBuffer &CComponent::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:complexType name=\"%s\">\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Type\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Name\" type=\"xsd:string\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType>\n");
		}
	}
	return schema;
}

void CComponent::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CComponent::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CComponent::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Type");
	form.appendf("  <tr><td><b>Type: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Name");
	form.appendf("  <tr><td><b>Name: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CComponent::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CComponent::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_Type.marshall(rpc_resp, "Type", "", "", "");
	m_Name.marshall(rpc_resp, "Name", "", "", "");
}


void CComponent::copy(CComponent &from)
{
	m_Type.copy(from.m_Type);
	m_Name.copy(from.m_Name);
}


void CComponent::copy(IConstComponent &ifrom)
{
	setType(ifrom.getType());
	setName(ifrom.getName());
}


void CComponent::getAttributes(IProperties &attributes)
{
}


void CComponent::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_Type.toStr(ctx, buffer, "Type", "", true, "", "");
	m_Name.toStr(ctx, buffer, "Name", "", true, "", "");
}


void CComponent::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CComponent::serializer(IEspContext* ctx, IConstComponent &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<Component>");
	// field Type
	{
		const char* s = src.getType();
		if (s && *s)
		{
			buffer.append("<Type>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Type>");
		}
	}
	// field Name
	{
		const char* s = src.getName();
		if (s && *s)
		{
			buffer.append("<Name>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Name>");
		}
	}
	if (keepRootTag)
		buffer.append("</Component>");
}

bool CComponent::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_Type.unmarshall(rpc_request, "Type", basepath);
	hasValue |= m_Name.unmarshall(rpc_request, "Name", basepath);
	return hasValue;
}

bool CComponent::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Type.unmarshall(ctx, soapval, "Type");
	hasValue |= m_Name.unmarshall(ctx, soapval, "Name");
	return hasValue;
}

bool CComponent::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Type.unmarshall(ctx, params, attachments, "Type", basepath);
	hasValue |= m_Name.unmarshall(ctx, params, attachments, "Name", basepath);
	return hasValue;
}

const char * CComponent::getType() { return m_Type.query();}
const char * CComponent::getName() { return m_Name.query();}
void CComponent::setType(const char * val){ m_Type.set(val); }
void CComponent::setName(const char * val){ m_Name.set(val); }
extern "C"  IEspComponent *createComponent(const char *serv, const char *msgname){return ((IEspComponent *)new CComponent(serv /*, msgname*/));}
extern "C"  IClientComponent *createClientComponent(const char *serv, const char *msgname){return ((IClientComponent *)new CComponent(serv /*, msgname*/));}

//=======================================================
// class CComponentUsage Implementation
//=======================================================

CComponentUsage::CComponentUsage(const char *serviceName, IRpcMessageBinding *init)
	: m_Type(nilRemove),m_Name(nilRemove),m_Description(nilRemove),m_MachineUsages(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ComponentUsage");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CComponentUsage::CComponentUsage(const char *serviceName, const char *bc)
	: m_Type(nilRemove),m_Name(nilRemove),m_Description(nilRemove),m_MachineUsages(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ComponentUsage");
}

StringBuffer &CComponentUsage::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:complexType name=\"%s\">\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Type\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Name\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Description\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"MachineUsages\" type=\"tns:ArrayOfMachineUsage\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType>\n");
		}
	}
	if (!(flags & 0x10)  || (flags & 0x100))
	{
		CMachineUsage::getXsdDefinition(context, request, schema, added);
	}
	if (added.getValue("MachineUsage") && added.getValue("ArrayOfMachineUsage")==NULL) {
		schema.append("<xsd:complexType name=\"ArrayOfMachineUsage\">\n");
		schema.append("<xsd:sequence>\n");
		schema.append("<xsd:element minOccurs=\"0\" maxOccurs=\"unbounded\" name=\"MachineUsage\" type=\"tns:MachineUsage\"/>\n");
		schema.append("</xsd:sequence>\n");
		schema.append("</xsd:complexType>\n");
		added.setValue("ArrayOfMachineUsage",1);
	}
	return schema;
}

void CComponentUsage::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CComponentUsage::getMapInfo(IMapInfo& info, BoolHash& added)
{
	if (!added.getValue("MachineUsage"))
	{
		added.setValue("MachineUsage",1);
		CMachineUsage::getMapInfo(info,added);
	}
}

StringBuffer &CComponentUsage::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Type");
	form.appendf("  <tr><td><b>Type: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Name");
	form.appendf("  <tr><td><b>Name: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Description");
	form.appendf("  <tr><td><b>Description: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("MachineUsages");
	form.appendf("<tr><td><b>MachineUsages: </b></td><td>");
	form.appendf("<table><tr><td><textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea></td>", extfix.str());
	form.append("</tr></table>");
	form.append("</td></tr>");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CComponentUsage::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CComponentUsage::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_Type.marshall(rpc_resp, "Type", "", "", "");
	m_Name.marshall(rpc_resp, "Name", "", "", "");
	m_Description.marshall(rpc_resp, "Description", "", "", "");
	m_MachineUsages.marshall(rpc_resp, "MachineUsages", "MachineUsage");
}


void CComponentUsage::copy(CComponentUsage &from)
{
	m_Type.copy(from.m_Type);
	m_Name.copy(from.m_Name);
	m_Description.copy(from.m_Description);
	m_MachineUsages.copy(from.m_MachineUsages);
}


void CComponentUsage::copy(IConstComponentUsage &ifrom)
{
	setType(ifrom.getType());
	setName(ifrom.getName());
	setDescription(ifrom.getDescription());
	setMachineUsages(ifrom.getMachineUsages());
}


void CComponentUsage::getAttributes(IProperties &attributes)
{
}


void CComponentUsage::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_Type.toStr(ctx, buffer, "Type", "", true, "", "");
	m_Name.toStr(ctx, buffer, "Name", "", true, "", "");
	m_Description.toStr(ctx, buffer, "Description", "", true, "", "");
	m_MachineUsages.toStr(ctx, buffer, "MachineUsages", "MachineUsage");
}


void CComponentUsage::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CComponentUsage::serializer(IEspContext* ctx, IConstComponentUsage &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<ComponentUsage>");
	// field Type
	{
		const char* s = src.getType();
		if (s && *s)
		{
			buffer.append("<Type>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Type>");
		}
	}
	// field Name
	{
		const char* s = src.getName();
		if (s && *s)
		{
			buffer.append("<Name>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Name>");
		}
	}
	// field Description
	{
		const char* s = src.getDescription();
		if (s && *s)
		{
			buffer.append("<Description>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Description>");
		}
	}
	// field MachineUsages
	{
		IArrayOf<IConstMachineUsage>& v = src.getMachineUsages();
		int size = v.length();
		if (size>0)
			buffer.append("<MachineUsages>");
		for (int i=0;i<size;i++)
		{
			buffer.append("<Item>");
			CMachineUsage::serializer(ctx,v.item(i),buffer,false);
			buffer.append("</Item>");
		}
		if (size>0)
			buffer.append("</MachineUsages>");
	}
	if (keepRootTag)
		buffer.append("</ComponentUsage>");
}

bool CComponentUsage::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_Type.unmarshall(rpc_request, "Type", basepath);
	hasValue |= m_Name.unmarshall(rpc_request, "Name", basepath);
	hasValue |= m_Description.unmarshall(rpc_request, "Description", basepath);
	hasValue |= m_MachineUsages.unmarshall(rpc_request, "MachineUsages", basepath);
	return hasValue;
}

bool CComponentUsage::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Type.unmarshall(ctx, soapval, "Type");
	hasValue |= m_Name.unmarshall(ctx, soapval, "Name");
	hasValue |= m_Description.unmarshall(ctx, soapval, "Description");
	hasValue |= m_MachineUsages.unmarshall(ctx, soapval, "MachineUsages");
	return hasValue;
}

bool CComponentUsage::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Type.unmarshall(ctx, params, attachments, "Type", basepath);
	hasValue |= m_Name.unmarshall(ctx, params, attachments, "Name", basepath);
	hasValue |= m_Description.unmarshall(ctx, params, attachments, "Description", basepath);
	hasValue |= m_MachineUsages.unmarshall(ctx, params, attachments, "MachineUsages", basepath);
	return hasValue;
}

const char * CComponentUsage::getType() { return m_Type.query();}
const char * CComponentUsage::getName() { return m_Name.query();}
const char * CComponentUsage::getDescription() { return m_Description.query();}
IArrayOf<IConstMachineUsage> & CComponentUsage::getMachineUsages() { return (IArrayOf<IConstMachineUsage> &) m_MachineUsages; }
void CComponentUsage::setType(const char * val){ m_Type.set(val); }
void CComponentUsage::setName(const char * val){ m_Name.set(val); }
void CComponentUsage::setDescription(const char * val){ m_Description.set(val); }
void CComponentUsage::setMachineUsages(IArrayOf<IEspMachineUsage> &val)
{
	m_MachineUsages->kill();
	IArrayOf<IConstMachineUsage> &target = m_MachineUsages.getValue();
	ForEachItemIn(idx, val)
	{
		IEspMachineUsage &item = (val).item(idx);
		item.Link();
		target.append(item);
	}
}
void CComponentUsage::setMachineUsages(IArrayOf<IConstMachineUsage> &val)
{
	m_MachineUsages->kill();
	IArrayOf<IConstMachineUsage> &target = m_MachineUsages.getValue();
	ForEachItemIn(idx, val)
	{
		IConstMachineUsage &item = val.item(idx);
		item.Link();
		target.append(item);
	}
}
extern "C"  IEspComponentUsage *createComponentUsage(const char *serv, const char *msgname){return ((IEspComponentUsage *)new CComponentUsage(serv /*, msgname*/));}
extern "C"  IClientComponentUsage *createClientComponentUsage(const char *serv, const char *msgname){return ((IClientComponentUsage *)new CComponentUsage(serv /*, msgname*/));}

//=======================================================
// class CTargetClusterUsage Implementation
//=======================================================

CTargetClusterUsage::CTargetClusterUsage(const char *serviceName, IRpcMessageBinding *init)
	: m_Name(nilRemove),m_Description(nilRemove),m_ComponentUsages(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("TargetClusterUsage");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CTargetClusterUsage::CTargetClusterUsage(const char *serviceName, const char *bc)
	: m_Name(nilRemove),m_Description(nilRemove),m_ComponentUsages(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("TargetClusterUsage");
}

StringBuffer &CTargetClusterUsage::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:complexType name=\"%s\">\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Name\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Description\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"ComponentUsages\" type=\"tns:ArrayOfComponentUsage\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType>\n");
		}
	}
	if (!(flags & 0x10)  || (flags & 0x100))
	{
		CComponentUsage::getXsdDefinition(context, request, schema, added);
	}
	if (added.getValue("ComponentUsage") && added.getValue("ArrayOfComponentUsage")==NULL) {
		schema.append("<xsd:complexType name=\"ArrayOfComponentUsage\">\n");
		schema.append("<xsd:sequence>\n");
		schema.append("<xsd:element minOccurs=\"0\" maxOccurs=\"unbounded\" name=\"ComponentUsage\" type=\"tns:ComponentUsage\"/>\n");
		schema.append("</xsd:sequence>\n");
		schema.append("</xsd:complexType>\n");
		added.setValue("ArrayOfComponentUsage",1);
	}
	return schema;
}

void CTargetClusterUsage::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CTargetClusterUsage::getMapInfo(IMapInfo& info, BoolHash& added)
{
	if (!added.getValue("ComponentUsage"))
	{
		added.setValue("ComponentUsage",1);
		CComponentUsage::getMapInfo(info,added);
	}
}

StringBuffer &CTargetClusterUsage::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Name");
	form.appendf("  <tr><td><b>Name: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Description");
	form.appendf("  <tr><td><b>Description: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("ComponentUsages");
	form.appendf("<tr><td><b>ComponentUsages: </b></td><td>");
	form.appendf("<table><tr><td><textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea></td>", extfix.str());
	form.append("</tr></table>");
	form.append("</td></tr>");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CTargetClusterUsage::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CTargetClusterUsage::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_Name.marshall(rpc_resp, "Name", "", "", "");
	m_Description.marshall(rpc_resp, "Description", "", "", "");
	m_ComponentUsages.marshall(rpc_resp, "ComponentUsages", "ComponentUsage");
}


void CTargetClusterUsage::copy(CTargetClusterUsage &from)
{
	m_Name.copy(from.m_Name);
	m_Description.copy(from.m_Description);
	m_ComponentUsages.copy(from.m_ComponentUsages);
}


void CTargetClusterUsage::copy(IConstTargetClusterUsage &ifrom)
{
	setName(ifrom.getName());
	setDescription(ifrom.getDescription());
	setComponentUsages(ifrom.getComponentUsages());
}


void CTargetClusterUsage::getAttributes(IProperties &attributes)
{
}


void CTargetClusterUsage::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_Name.toStr(ctx, buffer, "Name", "", true, "", "");
	m_Description.toStr(ctx, buffer, "Description", "", true, "", "");
	m_ComponentUsages.toStr(ctx, buffer, "ComponentUsages", "ComponentUsage");
}


void CTargetClusterUsage::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CTargetClusterUsage::serializer(IEspContext* ctx, IConstTargetClusterUsage &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<TargetClusterUsage>");
	// field Name
	{
		const char* s = src.getName();
		if (s && *s)
		{
			buffer.append("<Name>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Name>");
		}
	}
	// field Description
	{
		const char* s = src.getDescription();
		if (s && *s)
		{
			buffer.append("<Description>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Description>");
		}
	}
	// field ComponentUsages
	{
		IArrayOf<IConstComponentUsage>& v = src.getComponentUsages();
		int size = v.length();
		if (size>0)
			buffer.append("<ComponentUsages>");
		for (int i=0;i<size;i++)
		{
			buffer.append("<Item>");
			CComponentUsage::serializer(ctx,v.item(i),buffer,false);
			buffer.append("</Item>");
		}
		if (size>0)
			buffer.append("</ComponentUsages>");
	}
	if (keepRootTag)
		buffer.append("</TargetClusterUsage>");
}

bool CTargetClusterUsage::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_Name.unmarshall(rpc_request, "Name", basepath);
	hasValue |= m_Description.unmarshall(rpc_request, "Description", basepath);
	hasValue |= m_ComponentUsages.unmarshall(rpc_request, "ComponentUsages", basepath);
	return hasValue;
}

bool CTargetClusterUsage::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Name.unmarshall(ctx, soapval, "Name");
	hasValue |= m_Description.unmarshall(ctx, soapval, "Description");
	hasValue |= m_ComponentUsages.unmarshall(ctx, soapval, "ComponentUsages");
	return hasValue;
}

bool CTargetClusterUsage::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Name.unmarshall(ctx, params, attachments, "Name", basepath);
	hasValue |= m_Description.unmarshall(ctx, params, attachments, "Description", basepath);
	hasValue |= m_ComponentUsages.unmarshall(ctx, params, attachments, "ComponentUsages", basepath);
	return hasValue;
}

const char * CTargetClusterUsage::getName() { return m_Name.query();}
const char * CTargetClusterUsage::getDescription() { return m_Description.query();}
IArrayOf<IConstComponentUsage> & CTargetClusterUsage::getComponentUsages() { return (IArrayOf<IConstComponentUsage> &) m_ComponentUsages; }
void CTargetClusterUsage::setName(const char * val){ m_Name.set(val); }
void CTargetClusterUsage::setDescription(const char * val){ m_Description.set(val); }
void CTargetClusterUsage::setComponentUsages(IArrayOf<IEspComponentUsage> &val)
{
	m_ComponentUsages->kill();
	IArrayOf<IConstComponentUsage> &target = m_ComponentUsages.getValue();
	ForEachItemIn(idx, val)
	{
		IEspComponentUsage &item = (val).item(idx);
		item.Link();
		target.append(item);
	}
}
void CTargetClusterUsage::setComponentUsages(IArrayOf<IConstComponentUsage> &val)
{
	m_ComponentUsages->kill();
	IArrayOf<IConstComponentUsage> &target = m_ComponentUsages.getValue();
	ForEachItemIn(idx, val)
	{
		IConstComponentUsage &item = val.item(idx);
		item.Link();
		target.append(item);
	}
}
extern "C"  IEspTargetClusterUsage *createTargetClusterUsage(const char *serv, const char *msgname){return ((IEspTargetClusterUsage *)new CTargetClusterUsage(serv /*, msgname*/));}
extern "C"  IClientTargetClusterUsage *createClientTargetClusterUsage(const char *serv, const char *msgname){return ((IClientTargetClusterUsage *)new CTargetClusterUsage(serv /*, msgname*/));}

//=======================================================
// class CNodeGroupUsage Implementation
//=======================================================

CNodeGroupUsage::CNodeGroupUsage(const char *serviceName, IRpcMessageBinding *init)
	: m_Name(nilRemove),m_Description(nilRemove),m_ComponentUsages(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("NodeGroupUsage");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CNodeGroupUsage::CNodeGroupUsage(const char *serviceName, const char *bc)
	: m_Name(nilRemove),m_Description(nilRemove),m_ComponentUsages(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("NodeGroupUsage");
}

StringBuffer &CNodeGroupUsage::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:complexType name=\"%s\">\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Name\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Description\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"ComponentUsages\" type=\"tns:ArrayOfComponentUsage\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType>\n");
		}
	}
	if (!(flags & 0x10)  || (flags & 0x100))
	{
		CComponentUsage::getXsdDefinition(context, request, schema, added);
	}
	if (added.getValue("ComponentUsage") && added.getValue("ArrayOfComponentUsage")==NULL) {
		schema.append("<xsd:complexType name=\"ArrayOfComponentUsage\">\n");
		schema.append("<xsd:sequence>\n");
		schema.append("<xsd:element minOccurs=\"0\" maxOccurs=\"unbounded\" name=\"ComponentUsage\" type=\"tns:ComponentUsage\"/>\n");
		schema.append("</xsd:sequence>\n");
		schema.append("</xsd:complexType>\n");
		added.setValue("ArrayOfComponentUsage",1);
	}
	return schema;
}

void CNodeGroupUsage::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CNodeGroupUsage::getMapInfo(IMapInfo& info, BoolHash& added)
{
	if (!added.getValue("ComponentUsage"))
	{
		added.setValue("ComponentUsage",1);
		CComponentUsage::getMapInfo(info,added);
	}
}

StringBuffer &CNodeGroupUsage::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Name");
	form.appendf("  <tr><td><b>Name: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Description");
	form.appendf("  <tr><td><b>Description: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("ComponentUsages");
	form.appendf("<tr><td><b>ComponentUsages: </b></td><td>");
	form.appendf("<table><tr><td><textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea></td>", extfix.str());
	form.append("</tr></table>");
	form.append("</td></tr>");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CNodeGroupUsage::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CNodeGroupUsage::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_Name.marshall(rpc_resp, "Name", "", "", "");
	m_Description.marshall(rpc_resp, "Description", "", "", "");
	m_ComponentUsages.marshall(rpc_resp, "ComponentUsages", "ComponentUsage");
}


void CNodeGroupUsage::copy(CNodeGroupUsage &from)
{
	m_Name.copy(from.m_Name);
	m_Description.copy(from.m_Description);
	m_ComponentUsages.copy(from.m_ComponentUsages);
}


void CNodeGroupUsage::copy(IConstNodeGroupUsage &ifrom)
{
	setName(ifrom.getName());
	setDescription(ifrom.getDescription());
	setComponentUsages(ifrom.getComponentUsages());
}


void CNodeGroupUsage::getAttributes(IProperties &attributes)
{
}


void CNodeGroupUsage::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_Name.toStr(ctx, buffer, "Name", "", true, "", "");
	m_Description.toStr(ctx, buffer, "Description", "", true, "", "");
	m_ComponentUsages.toStr(ctx, buffer, "ComponentUsages", "ComponentUsage");
}


void CNodeGroupUsage::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CNodeGroupUsage::serializer(IEspContext* ctx, IConstNodeGroupUsage &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<NodeGroupUsage>");
	// field Name
	{
		const char* s = src.getName();
		if (s && *s)
		{
			buffer.append("<Name>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Name>");
		}
	}
	// field Description
	{
		const char* s = src.getDescription();
		if (s && *s)
		{
			buffer.append("<Description>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Description>");
		}
	}
	// field ComponentUsages
	{
		IArrayOf<IConstComponentUsage>& v = src.getComponentUsages();
		int size = v.length();
		if (size>0)
			buffer.append("<ComponentUsages>");
		for (int i=0;i<size;i++)
		{
			buffer.append("<Item>");
			CComponentUsage::serializer(ctx,v.item(i),buffer,false);
			buffer.append("</Item>");
		}
		if (size>0)
			buffer.append("</ComponentUsages>");
	}
	if (keepRootTag)
		buffer.append("</NodeGroupUsage>");
}

bool CNodeGroupUsage::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_Name.unmarshall(rpc_request, "Name", basepath);
	hasValue |= m_Description.unmarshall(rpc_request, "Description", basepath);
	hasValue |= m_ComponentUsages.unmarshall(rpc_request, "ComponentUsages", basepath);
	return hasValue;
}

bool CNodeGroupUsage::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Name.unmarshall(ctx, soapval, "Name");
	hasValue |= m_Description.unmarshall(ctx, soapval, "Description");
	hasValue |= m_ComponentUsages.unmarshall(ctx, soapval, "ComponentUsages");
	return hasValue;
}

bool CNodeGroupUsage::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Name.unmarshall(ctx, params, attachments, "Name", basepath);
	hasValue |= m_Description.unmarshall(ctx, params, attachments, "Description", basepath);
	hasValue |= m_ComponentUsages.unmarshall(ctx, params, attachments, "ComponentUsages", basepath);
	return hasValue;
}

const char * CNodeGroupUsage::getName() { return m_Name.query();}
const char * CNodeGroupUsage::getDescription() { return m_Description.query();}
IArrayOf<IConstComponentUsage> & CNodeGroupUsage::getComponentUsages() { return (IArrayOf<IConstComponentUsage> &) m_ComponentUsages; }
void CNodeGroupUsage::setName(const char * val){ m_Name.set(val); }
void CNodeGroupUsage::setDescription(const char * val){ m_Description.set(val); }
void CNodeGroupUsage::setComponentUsages(IArrayOf<IEspComponentUsage> &val)
{
	m_ComponentUsages->kill();
	IArrayOf<IConstComponentUsage> &target = m_ComponentUsages.getValue();
	ForEachItemIn(idx, val)
	{
		IEspComponentUsage &item = (val).item(idx);
		item.Link();
		target.append(item);
	}
}
void CNodeGroupUsage::setComponentUsages(IArrayOf<IConstComponentUsage> &val)
{
	m_ComponentUsages->kill();
	IArrayOf<IConstComponentUsage> &target = m_ComponentUsages.getValue();
	ForEachItemIn(idx, val)
	{
		IConstComponentUsage &item = val.item(idx);
		item.Link();
		target.append(item);
	}
}
extern "C"  IEspNodeGroupUsage *createNodeGroupUsage(const char *serv, const char *msgname){return ((IEspNodeGroupUsage *)new CNodeGroupUsage(serv /*, msgname*/));}
extern "C"  IClientNodeGroupUsage *createClientNodeGroupUsage(const char *serv, const char *msgname){return ((IClientNodeGroupUsage *)new CNodeGroupUsage(serv /*, msgname*/));}

//=======================================================
// class CGetMachineInfoRequest Implementation
//=======================================================

CGetMachineInfoRequest::CGetMachineInfoRequest(const char *serviceName, IRpcMessageBinding *init)
	: m_Addresses(nilIgnore),m_SortBy(nilIgnore),m_ClusterType(nilIgnore),m_Cluster(nilIgnore),m_OldIP(nilIgnore),m_Path(nilIgnore),m_AddProcessesToFilter(nilIgnore),m_ApplyProcessFilter(nilIgnore),m_GetProcessorInfo(nilIgnore),m_GetStorageInfo(nilIgnore),m_LocalFileSystemsOnly(nilIgnore),m_GetSoftwareInfo(nilIgnore),m_MemThreshold(nilIgnore),m_DiskThreshold(nilIgnore),m_CpuThreshold(nilIgnore),m_AutoRefresh(nilIgnore),m_MemThresholdType(nilIgnore),m_DiskThresholdType(nilIgnore),m_UserName(nilIgnore),m_Password(nilIgnore),m_SecurityString(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetMachineInfoRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CGetMachineInfoRequest::CGetMachineInfoRequest(const char *serviceName, const char *bc)
	: m_Addresses(nilIgnore),m_SortBy(nilIgnore),m_ClusterType(nilIgnore),m_Cluster(nilIgnore),m_OldIP(nilIgnore),m_Path(nilIgnore),m_AddProcessesToFilter(nilIgnore),m_ApplyProcessFilter(nilIgnore),m_GetProcessorInfo(nilIgnore),m_GetStorageInfo(nilIgnore),m_LocalFileSystemsOnly(nilIgnore),m_GetSoftwareInfo(nilIgnore),m_MemThreshold(nilIgnore),m_DiskThreshold(nilIgnore),m_CpuThreshold(nilIgnore),m_AutoRefresh(nilIgnore),m_MemThresholdType(nilIgnore),m_DiskThresholdType(nilIgnore),m_UserName(nilIgnore),m_Password(nilIgnore),m_SecurityString(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetMachineInfoRequest");
}

CGetMachineInfoRequest::CGetMachineInfoRequest(const char *serviceName, IRpcMessage* rpcmsg)
	: m_Addresses(nilIgnore),m_SortBy(nilIgnore),m_ClusterType(nilIgnore),m_Cluster(nilIgnore),m_OldIP(nilIgnore),m_Path(nilIgnore),m_AddProcessesToFilter(nilIgnore),m_ApplyProcessFilter(nilIgnore),m_GetProcessorInfo(nilIgnore),m_GetStorageInfo(nilIgnore),m_LocalFileSystemsOnly(nilIgnore),m_GetSoftwareInfo(nilIgnore),m_MemThreshold(nilIgnore),m_DiskThreshold(nilIgnore),m_CpuThreshold(nilIgnore),m_AutoRefresh(nilIgnore),m_MemThresholdType(nilIgnore),m_DiskThresholdType(nilIgnore),m_UserName(nilIgnore),m_Password(nilIgnore),m_SecurityString(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetMachineInfoRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CGetMachineInfoRequest::CGetMachineInfoRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_Addresses(nilIgnore),m_SortBy(nilIgnore),m_ClusterType(nilIgnore),m_Cluster(nilIgnore),m_OldIP(nilIgnore),m_Path(nilIgnore),m_AddProcessesToFilter(nilIgnore),m_ApplyProcessFilter(nilIgnore),m_GetProcessorInfo(nilIgnore),m_GetStorageInfo(nilIgnore),m_LocalFileSystemsOnly(nilIgnore),m_GetSoftwareInfo(nilIgnore),m_MemThreshold(nilIgnore),m_DiskThreshold(nilIgnore),m_CpuThreshold(nilIgnore),m_AutoRefresh(nilIgnore),m_MemThresholdType(nilIgnore),m_DiskThresholdType(nilIgnore),m_UserName(nilIgnore),m_Password(nilIgnore),m_SecurityString(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetMachineInfoRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CGetMachineInfoRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Addresses\" type=\"tns:EspStringArray\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"ClusterType\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Cluster\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"OldIP\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Path\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"AddProcessesToFilter\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"ApplyProcessFilter\" type=\"xsd:boolean\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"GetProcessorInfo\" type=\"xsd:boolean\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"GetStorageInfo\" type=\"xsd:boolean\"/>\n");
		if (!context.suppressed("GetMachineInfoRequest","LocalFileSystemsOnly")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"LocalFileSystemsOnly\" type=\"xsd:boolean\"/>\n");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"GetSoftwareInfo\" type=\"xsd:boolean\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"MemThreshold\" type=\"xsd:int\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"DiskThreshold\" type=\"xsd:int\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"CpuThreshold\" type=\"xsd:int\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"AutoRefresh\" type=\"xsd:int\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"MemThresholdType\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"DiskThresholdType\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"UserName\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Password\" type=\"xsd:string\"");
		if (context.queryOptions()&ESPCTX_ALL_ANNOTATION)
			schema.append("> <xsd:annotation><xsd:appinfo><form formType=\"password\" formCols=\"20\"/></xsd:appinfo></xsd:annotation></xsd:element>\n");
		else
			schema.append("/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"SecurityString\" type=\"xsd:string\"");
		if (context.queryOptions()&ESPCTX_ALL_ANNOTATION)
			schema.append("> <xsd:annotation><xsd:appinfo><form formType=\"password\" formCols=\"20\"/></xsd:appinfo></xsd:annotation></xsd:element>\n");
		else
			schema.append("/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	if (added.getValue("EspStringArray")==NULL) {
		addEspNativeArray(schema,"string","EspStringArray");
		added.setValue("EspStringArray",1);
	}
	return schema;
}

void CGetMachineInfoRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CGetMachineInfoRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
	info.addMinVersion("GetMachineInfoRequest","LocalFileSystemsOnly",1.11);
}

StringBuffer &CGetMachineInfoRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Addresses");
	form.appendf("<tr><td><b>Addresses: </b></td><td>");
	form.appendf("<textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea>", extfix.str());
	form.append("</td></tr>");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("ClusterType");
	form.appendf("  <tr><td><b>ClusterType: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Cluster");
	form.appendf("  <tr><td><b>Cluster: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("OldIP");
	form.appendf("  <tr><td><b>OldIP: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Path");
	form.appendf("  <tr><td><b>Path: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("AddProcessesToFilter");
	form.appendf("  <tr><td><b>AddProcessesToFilter: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("ApplyProcessFilter");
	
	form.appendf("  <tr><td><b>ApplyProcessFilter? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("GetProcessorInfo");
	
	form.appendf("  <tr><td><b>GetProcessorInfo? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("GetStorageInfo");
	
	form.appendf("  <tr><td><b>GetStorageInfo? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	if (!context.suppressed("GetMachineInfoRequest","LocalFileSystemsOnly")) {
		extfix.clear();
		if (prefix && *prefix)
			extfix.append(prefix).append(".");
		extfix.append("LocalFileSystemsOnly");
		
	form.appendf("  <tr><td><b>LocalFileSystemsOnly? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	}
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("GetSoftwareInfo");
	
	form.appendf("  <tr><td><b>GetSoftwareInfo? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	extfix.clear();
	if (prefix && *prefix) extfix.append(prefix).append(".");
		extfix.append("MemThreshold");
	form.appendf("  <tr><td><b>MemThreshold: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix) extfix.append(prefix).append(".");
		extfix.append("DiskThreshold");
	form.appendf("  <tr><td><b>DiskThreshold: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix) extfix.append(prefix).append(".");
		extfix.append("CpuThreshold");
	form.appendf("  <tr><td><b>CpuThreshold: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix) extfix.append(prefix).append(".");
		extfix.append("AutoRefresh");
	form.appendf("  <tr><td><b>AutoRefresh: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("MemThresholdType");
	form.appendf("  <tr><td><b>MemThresholdType: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("DiskThresholdType");
	form.appendf("  <tr><td><b>DiskThresholdType: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("UserName");
	form.appendf("  <tr><td><b>UserName: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Password");
	form.appendf("  <tr><td><b>Password: </b></td><td><input type=\"password\" name=\"%s\" size=\"20\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("SecurityString");
	form.appendf("  <tr><td><b>SecurityString: </b></td><td><input type=\"password\" name=\"%s\" size=\"20\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CGetMachineInfoRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CGetMachineInfoRequest::serialize(IRpcMessage& rpc_resp)
{
	IEspContext* ctx = rpc_resp.queryContext();
	double clientVer= ctx ? ctx->getClientVersion() : -1; /* no context gets everything */
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_Addresses.marshall(rpc_resp, "Addresses", "Item");
	m_SortBy.marshall(rpc_resp, "SortBy", "", "", "");
	m_ClusterType.marshall(rpc_resp, "ClusterType", "", "", "");
	m_Cluster.marshall(rpc_resp, "Cluster", "", "", "");
	m_OldIP.marshall(rpc_resp, "OldIP", "", "", "");
	m_Path.marshall(rpc_resp, "Path", "", "", "");
	m_AddProcessesToFilter.marshall(rpc_resp, "AddProcessesToFilter", "", "", "");
	m_ApplyProcessFilter.marshall(rpc_resp, "ApplyProcessFilter", "", "", "");
	m_GetProcessorInfo.marshall(rpc_resp, "GetProcessorInfo", "", "", "");
	m_GetStorageInfo.marshall(rpc_resp, "GetStorageInfo", "", "", "");
	if ((clientVer==-1.0 || clientVer>=1.11))
		m_LocalFileSystemsOnly.marshall(rpc_resp, "LocalFileSystemsOnly", "", "", "");
	m_GetSoftwareInfo.marshall(rpc_resp, "GetSoftwareInfo", "", "", "");
	m_MemThreshold.marshall(rpc_resp, "MemThreshold", "", "", "");
	m_DiskThreshold.marshall(rpc_resp, "DiskThreshold", "", "", "");
	m_CpuThreshold.marshall(rpc_resp, "CpuThreshold", "", "", "");
	m_AutoRefresh.marshall(rpc_resp, "AutoRefresh", "", "", "");
	m_MemThresholdType.marshall(rpc_resp, "MemThresholdType", "", "", "");
	m_DiskThresholdType.marshall(rpc_resp, "DiskThresholdType", "", "", "");
	m_UserName.marshall(rpc_resp, "UserName", "", "", "");
	m_Password.marshall(rpc_resp, "Password", "", "", "");
	m_SecurityString.marshall(rpc_resp, "SecurityString", "", "", "");
}


void CGetMachineInfoRequest::copy(CGetMachineInfoRequest &from)
{
	m_Addresses.copy(from.m_Addresses);
	m_SortBy.copy(from.m_SortBy);
	m_ClusterType.copy(from.m_ClusterType);
	m_Cluster.copy(from.m_Cluster);
	m_OldIP.copy(from.m_OldIP);
	m_Path.copy(from.m_Path);
	m_AddProcessesToFilter.copy(from.m_AddProcessesToFilter);
	m_ApplyProcessFilter.copy(from.m_ApplyProcessFilter);
	m_GetProcessorInfo.copy(from.m_GetProcessorInfo);
	m_GetStorageInfo.copy(from.m_GetStorageInfo);
	m_LocalFileSystemsOnly.copy(from.m_LocalFileSystemsOnly);
	m_GetSoftwareInfo.copy(from.m_GetSoftwareInfo);
	m_MemThreshold.copy(from.m_MemThreshold);
	m_DiskThreshold.copy(from.m_DiskThreshold);
	m_CpuThreshold.copy(from.m_CpuThreshold);
	m_AutoRefresh.copy(from.m_AutoRefresh);
	m_MemThresholdType.copy(from.m_MemThresholdType);
	m_DiskThresholdType.copy(from.m_DiskThresholdType);
	m_UserName.copy(from.m_UserName);
	m_Password.copy(from.m_Password);
	m_SecurityString.copy(from.m_SecurityString);
}


void CGetMachineInfoRequest::copy(IConstGetMachineInfoRequest &ifrom)
{
	setAddresses(ifrom.getAddresses());
	setSortBy(ifrom.getSortBy());
	setClusterType(ifrom.getClusterType());
	setCluster(ifrom.getCluster());
	setOldIP(ifrom.getOldIP());
	setPath(ifrom.getPath());
	setAddProcessesToFilter(ifrom.getAddProcessesToFilter());
	setApplyProcessFilter(ifrom.getApplyProcessFilter());
	setGetProcessorInfo(ifrom.getGetProcessorInfo());
	setGetStorageInfo(ifrom.getGetStorageInfo());
	setLocalFileSystemsOnly(ifrom.getLocalFileSystemsOnly());
	setGetSoftwareInfo(ifrom.getGetSoftwareInfo());
	setMemThreshold(ifrom.getMemThreshold());
	setDiskThreshold(ifrom.getDiskThreshold());
	setCpuThreshold(ifrom.getCpuThreshold());
	setAutoRefresh(ifrom.getAutoRefresh());
	setMemThresholdType(ifrom.getMemThresholdType());
	setDiskThresholdType(ifrom.getDiskThresholdType());
	setUserName(ifrom.getUserName());
	setPassword(ifrom.getPassword());
	setSecurityString(ifrom.getSecurityString());
}


void CGetMachineInfoRequest::getAttributes(IProperties &attributes)
{
}


void CGetMachineInfoRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	double clientVer = ctx ? ctx->getClientVersion() : -1;
	m_Addresses.toStr(ctx, buffer, "Addresses", "Item");
	m_SortBy.toStr(ctx, buffer, "SortBy", "", true, "", "");
	m_ClusterType.toStr(ctx, buffer, "ClusterType", "", true, "", "");
	m_Cluster.toStr(ctx, buffer, "Cluster", "", true, "", "");
	m_OldIP.toStr(ctx, buffer, "OldIP", "", true, "", "");
	m_Path.toStr(ctx, buffer, "Path", "", true, "", "");
	m_AddProcessesToFilter.toStr(ctx, buffer, "AddProcessesToFilter", "", true, "", "");
	m_ApplyProcessFilter.toStr(ctx, buffer, "ApplyProcessFilter", "", true, "", "");
	m_GetProcessorInfo.toStr(ctx, buffer, "GetProcessorInfo", "", true, "", "");
	m_GetStorageInfo.toStr(ctx, buffer, "GetStorageInfo", "", true, "", "");
	if ((clientVer==-1.0 || clientVer>=1.11))
		m_LocalFileSystemsOnly.toStr(ctx, buffer, "LocalFileSystemsOnly", "", true, "", "");
	m_GetSoftwareInfo.toStr(ctx, buffer, "GetSoftwareInfo", "", true, "", "");
	m_MemThreshold.toStr(ctx, buffer, "MemThreshold", "", true, "", "");
	m_DiskThreshold.toStr(ctx, buffer, "DiskThreshold", "", true, "", "");
	m_CpuThreshold.toStr(ctx, buffer, "CpuThreshold", "", true, "", "");
	m_AutoRefresh.toStr(ctx, buffer, "AutoRefresh", "", true, "", "");
	m_MemThresholdType.toStr(ctx, buffer, "MemThresholdType", "", true, "", "");
	m_DiskThresholdType.toStr(ctx, buffer, "DiskThresholdType", "", true, "", "");
	m_UserName.toStr(ctx, buffer, "UserName", "", true, "", "");
	m_Password.toStr(ctx, buffer, "Password", "", true, "", "");
	m_SecurityString.toStr(ctx, buffer, "SecurityString", "", true, "", "");
}


void CGetMachineInfoRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CGetMachineInfoRequest::serializer(IEspContext* ctx, IConstGetMachineInfoRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<GetMachineInfoRequest>");
	double clientVer = ctx ? ctx->getClientVersion() : -1;
	// field Addresses
	{
		StringArray& v = src.getAddresses();
		if (v.length()>0)
			buffer.append("<Addresses>");
		for (size32_t i=0;i<v.length();i++)
			buffer.appendf("<Item>%s</Item>",v.item(i));
		if (v.length()>0)
			buffer.append("</Addresses>");
	}
	// field SortBy
	{
		const char* s = src.getSortBy();
		if (s && *s)
		{
			buffer.append("<SortBy>");
			encodeUtf8XML(s,buffer);
			buffer.append("</SortBy>");
		}
	}
	// field ClusterType
	{
		const char* s = src.getClusterType();
		if (s && *s)
		{
			buffer.append("<ClusterType>");
			encodeUtf8XML(s,buffer);
			buffer.append("</ClusterType>");
		}
	}
	// field Cluster
	{
		const char* s = src.getCluster();
		if (s && *s)
		{
			buffer.append("<Cluster>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Cluster>");
		}
	}
	// field OldIP
	{
		const char* s = src.getOldIP();
		if (s && *s)
		{
			buffer.append("<OldIP>");
			encodeUtf8XML(s,buffer);
			buffer.append("</OldIP>");
		}
	}
	// field Path
	{
		const char* s = src.getPath();
		if (s && *s)
		{
			buffer.append("<Path>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Path>");
		}
	}
	// field AddProcessesToFilter
	{
		const char* s = src.getAddProcessesToFilter();
		if (s && *s)
		{
			buffer.append("<AddProcessesToFilter>");
			encodeUtf8XML(s,buffer);
			buffer.append("</AddProcessesToFilter>");
		}
	}
	// field ApplyProcessFilter
	{
		bool b = src.getApplyProcessFilter();
		if (b)
			buffer.appendf("<ApplyProcessFilter>1</ApplyProcessFilter>");
	}
	// field GetProcessorInfo
	{
		bool b = src.getGetProcessorInfo();
		if (b)
			buffer.appendf("<GetProcessorInfo>1</GetProcessorInfo>");
	}
	// field GetStorageInfo
	{
		bool b = src.getGetStorageInfo();
		if (b)
			buffer.appendf("<GetStorageInfo>1</GetStorageInfo>");
	}
	// field LocalFileSystemsOnly
	if ((clientVer==-1.0 || clientVer>=1.11))
	{
		bool b = src.getLocalFileSystemsOnly();
		if (b)
			buffer.appendf("<LocalFileSystemsOnly>1</LocalFileSystemsOnly>");
	}
	// field GetSoftwareInfo
	{
		bool b = src.getGetSoftwareInfo();
		if (b)
			buffer.appendf("<GetSoftwareInfo>1</GetSoftwareInfo>");
	}
	// field MemThreshold
	{
		int n = src.getMemThreshold();
		if (n)
			buffer.appendf("<MemThreshold>%d</MemThreshold>", n);
	}
	// field DiskThreshold
	{
		int n = src.getDiskThreshold();
		if (n)
			buffer.appendf("<DiskThreshold>%d</DiskThreshold>", n);
	}
	// field CpuThreshold
	{
		int n = src.getCpuThreshold();
		if (n)
			buffer.appendf("<CpuThreshold>%d</CpuThreshold>", n);
	}
	// field AutoRefresh
	{
		int n = src.getAutoRefresh();
		if (n)
			buffer.appendf("<AutoRefresh>%d</AutoRefresh>", n);
	}
	// field MemThresholdType
	{
		const char* s = src.getMemThresholdType();
		if (s && *s)
		{
			buffer.append("<MemThresholdType>");
			encodeUtf8XML(s,buffer);
			buffer.append("</MemThresholdType>");
		}
	}
	// field DiskThresholdType
	{
		const char* s = src.getDiskThresholdType();
		if (s && *s)
		{
			buffer.append("<DiskThresholdType>");
			encodeUtf8XML(s,buffer);
			buffer.append("</DiskThresholdType>");
		}
	}
	// field UserName
	{
		const char* s = src.getUserName();
		if (s && *s)
		{
			buffer.append("<UserName>");
			encodeUtf8XML(s,buffer);
			buffer.append("</UserName>");
		}
	}
	// field Password
	{
		const char* s = src.getPassword();
		if (s && *s)
		{
			buffer.append("<Password>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Password>");
		}
	}
	// field SecurityString
	{
		const char* s = src.getSecurityString();
		if (s && *s)
		{
			buffer.append("<SecurityString>");
			encodeUtf8XML(s,buffer);
			buffer.append("</SecurityString>");
		}
	}
	if (keepRootTag)
		buffer.append("</GetMachineInfoRequest>");
}

bool CGetMachineInfoRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_Addresses.unmarshall(rpc_request, "Addresses", basepath);
	hasValue |= m_SortBy.unmarshall(rpc_request, "SortBy", basepath);
	hasValue |= m_ClusterType.unmarshall(rpc_request, "ClusterType", basepath);
	hasValue |= m_Cluster.unmarshall(rpc_request, "Cluster", basepath);
	hasValue |= m_OldIP.unmarshall(rpc_request, "OldIP", basepath);
	hasValue |= m_Path.unmarshall(rpc_request, "Path", basepath);
	hasValue |= m_AddProcessesToFilter.unmarshall(rpc_request, "AddProcessesToFilter", basepath);
	hasValue |= m_ApplyProcessFilter.unmarshall(rpc_request, "ApplyProcessFilter", basepath);
	hasValue |= m_GetProcessorInfo.unmarshall(rpc_request, "GetProcessorInfo", basepath);
	hasValue |= m_GetStorageInfo.unmarshall(rpc_request, "GetStorageInfo", basepath);
	hasValue |= m_LocalFileSystemsOnly.unmarshall(rpc_request, "LocalFileSystemsOnly", basepath);
	hasValue |= m_GetSoftwareInfo.unmarshall(rpc_request, "GetSoftwareInfo", basepath);
	hasValue |= m_MemThreshold.unmarshall(rpc_request, "MemThreshold", basepath);
	hasValue |= m_DiskThreshold.unmarshall(rpc_request, "DiskThreshold", basepath);
	hasValue |= m_CpuThreshold.unmarshall(rpc_request, "CpuThreshold", basepath);
	hasValue |= m_AutoRefresh.unmarshall(rpc_request, "AutoRefresh", basepath);
	hasValue |= m_MemThresholdType.unmarshall(rpc_request, "MemThresholdType", basepath);
	hasValue |= m_DiskThresholdType.unmarshall(rpc_request, "DiskThresholdType", basepath);
	hasValue |= m_UserName.unmarshall(rpc_request, "UserName", basepath);
	hasValue |= m_Password.unmarshall(rpc_request, "Password", basepath);
	hasValue |= m_SecurityString.unmarshall(rpc_request, "SecurityString", basepath);
	return hasValue;
}

bool CGetMachineInfoRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Addresses.unmarshall(ctx, soapval, "Addresses");
	hasValue |= m_SortBy.unmarshall(ctx, soapval, "SortBy");
	hasValue |= m_ClusterType.unmarshall(ctx, soapval, "ClusterType");
	hasValue |= m_Cluster.unmarshall(ctx, soapval, "Cluster");
	hasValue |= m_OldIP.unmarshall(ctx, soapval, "OldIP");
	hasValue |= m_Path.unmarshall(ctx, soapval, "Path");
	hasValue |= m_AddProcessesToFilter.unmarshall(ctx, soapval, "AddProcessesToFilter");
	hasValue |= m_ApplyProcessFilter.unmarshall(ctx, soapval, "ApplyProcessFilter");
	hasValue |= m_GetProcessorInfo.unmarshall(ctx, soapval, "GetProcessorInfo");
	hasValue |= m_GetStorageInfo.unmarshall(ctx, soapval, "GetStorageInfo");
	hasValue |= m_LocalFileSystemsOnly.unmarshall(ctx, soapval, "LocalFileSystemsOnly");
	hasValue |= m_GetSoftwareInfo.unmarshall(ctx, soapval, "GetSoftwareInfo");
	hasValue |= m_MemThreshold.unmarshall(ctx, soapval, "MemThreshold");
	hasValue |= m_DiskThreshold.unmarshall(ctx, soapval, "DiskThreshold");
	hasValue |= m_CpuThreshold.unmarshall(ctx, soapval, "CpuThreshold");
	hasValue |= m_AutoRefresh.unmarshall(ctx, soapval, "AutoRefresh");
	hasValue |= m_MemThresholdType.unmarshall(ctx, soapval, "MemThresholdType");
	hasValue |= m_DiskThresholdType.unmarshall(ctx, soapval, "DiskThresholdType");
	hasValue |= m_UserName.unmarshall(ctx, soapval, "UserName");
	hasValue |= m_Password.unmarshall(ctx, soapval, "Password");
	hasValue |= m_SecurityString.unmarshall(ctx, soapval, "SecurityString");
	return hasValue;
}

bool CGetMachineInfoRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Addresses.unmarshall(ctx, params, attachments, "Addresses", basepath);
	hasValue |= m_SortBy.unmarshall(ctx, params, attachments, "SortBy", basepath);
	hasValue |= m_ClusterType.unmarshall(ctx, params, attachments, "ClusterType", basepath);
	hasValue |= m_Cluster.unmarshall(ctx, params, attachments, "Cluster", basepath);
	hasValue |= m_OldIP.unmarshall(ctx, params, attachments, "OldIP", basepath);
	hasValue |= m_Path.unmarshall(ctx, params, attachments, "Path", basepath);
	hasValue |= m_AddProcessesToFilter.unmarshall(ctx, params, attachments, "AddProcessesToFilter", basepath);
	hasValue |= m_ApplyProcessFilter.unmarshall(ctx, params, attachments, "ApplyProcessFilter", basepath);
	hasValue |= m_GetProcessorInfo.unmarshall(ctx, params, attachments, "GetProcessorInfo", basepath);
	hasValue |= m_GetStorageInfo.unmarshall(ctx, params, attachments, "GetStorageInfo", basepath);
	hasValue |= m_LocalFileSystemsOnly.unmarshall(ctx, params, attachments, "LocalFileSystemsOnly", basepath);
	hasValue |= m_GetSoftwareInfo.unmarshall(ctx, params, attachments, "GetSoftwareInfo", basepath);
	hasValue |= m_MemThreshold.unmarshall(ctx, params, attachments, "MemThreshold", basepath);
	hasValue |= m_DiskThreshold.unmarshall(ctx, params, attachments, "DiskThreshold", basepath);
	hasValue |= m_CpuThreshold.unmarshall(ctx, params, attachments, "CpuThreshold", basepath);
	hasValue |= m_AutoRefresh.unmarshall(ctx, params, attachments, "AutoRefresh", basepath);
	hasValue |= m_MemThresholdType.unmarshall(ctx, params, attachments, "MemThresholdType", basepath);
	hasValue |= m_DiskThresholdType.unmarshall(ctx, params, attachments, "DiskThresholdType", basepath);
	hasValue |= m_UserName.unmarshall(ctx, params, attachments, "UserName", basepath);
	hasValue |= m_Password.unmarshall(ctx, params, attachments, "Password", basepath);
	hasValue |= m_SecurityString.unmarshall(ctx, params, attachments, "SecurityString", basepath);
	return hasValue;
}

StringArray & CGetMachineInfoRequest::getAddresses() { return (StringArray &) m_Addresses; }
const char * CGetMachineInfoRequest::getSortBy() { return m_SortBy.query();}
const char * CGetMachineInfoRequest::getClusterType() { return m_ClusterType.query();}
const char * CGetMachineInfoRequest::getCluster() { return m_Cluster.query();}
const char * CGetMachineInfoRequest::getOldIP() { return m_OldIP.query();}
const char * CGetMachineInfoRequest::getPath() { return m_Path.query();}
const char * CGetMachineInfoRequest::getAddProcessesToFilter() { return m_AddProcessesToFilter.query();}
bool CGetMachineInfoRequest::getApplyProcessFilter() { return m_ApplyProcessFilter;}
bool CGetMachineInfoRequest::getGetProcessorInfo() { return m_GetProcessorInfo;}
bool CGetMachineInfoRequest::getGetStorageInfo() { return m_GetStorageInfo;}
bool CGetMachineInfoRequest::getLocalFileSystemsOnly() { return m_LocalFileSystemsOnly;}
bool CGetMachineInfoRequest::getGetSoftwareInfo() { return m_GetSoftwareInfo;}
int CGetMachineInfoRequest::getMemThreshold() { return m_MemThreshold;}
int CGetMachineInfoRequest::getDiskThreshold() { return m_DiskThreshold;}
int CGetMachineInfoRequest::getCpuThreshold() { return m_CpuThreshold;}
int CGetMachineInfoRequest::getAutoRefresh() { return m_AutoRefresh;}
const char * CGetMachineInfoRequest::getMemThresholdType() { return m_MemThresholdType.query();}
const char * CGetMachineInfoRequest::getDiskThresholdType() { return m_DiskThresholdType.query();}
const char * CGetMachineInfoRequest::getUserName() { return m_UserName.query();}
const char * CGetMachineInfoRequest::getPassword() { return m_Password.query();}
const char * CGetMachineInfoRequest::getSecurityString() { return m_SecurityString.query();}
void CGetMachineInfoRequest::setAddresses(StringArray &val){ m_Addresses->kill();  CloneArray(m_Addresses.getValue(), val); }
void CGetMachineInfoRequest::setSortBy(const char * val){ m_SortBy.set(val); }
void CGetMachineInfoRequest::setClusterType(const char * val){ m_ClusterType.set(val); }
void CGetMachineInfoRequest::setCluster(const char * val){ m_Cluster.set(val); }
void CGetMachineInfoRequest::setOldIP(const char * val){ m_OldIP.set(val); }
void CGetMachineInfoRequest::setPath(const char * val){ m_Path.set(val); }
void CGetMachineInfoRequest::setAddProcessesToFilter(const char * val){ m_AddProcessesToFilter.set(val); }
void CGetMachineInfoRequest::setApplyProcessFilter(bool val){ m_ApplyProcessFilter=val; }
void CGetMachineInfoRequest::setGetProcessorInfo(bool val){ m_GetProcessorInfo=val; }
void CGetMachineInfoRequest::setGetStorageInfo(bool val){ m_GetStorageInfo=val; }
void CGetMachineInfoRequest::setLocalFileSystemsOnly(bool val){ m_LocalFileSystemsOnly=val; }
void CGetMachineInfoRequest::setGetSoftwareInfo(bool val){ m_GetSoftwareInfo=val; }
void CGetMachineInfoRequest::setMemThreshold(int val){ m_MemThreshold=val; }
void CGetMachineInfoRequest::setDiskThreshold(int val){ m_DiskThreshold=val; }
void CGetMachineInfoRequest::setCpuThreshold(int val){ m_CpuThreshold=val; }
void CGetMachineInfoRequest::setAutoRefresh(int val){ m_AutoRefresh=val; }
void CGetMachineInfoRequest::setMemThresholdType(const char * val){ m_MemThresholdType.set(val); }
void CGetMachineInfoRequest::setDiskThresholdType(const char * val){ m_DiskThresholdType.set(val); }
void CGetMachineInfoRequest::setUserName(const char * val){ m_UserName.set(val); }
void CGetMachineInfoRequest::setPassword(const char * val){ m_Password.set(val); }
void CGetMachineInfoRequest::setSecurityString(const char * val){ m_SecurityString.set(val); }
extern "C"  IEspGetMachineInfoRequest *createGetMachineInfoRequest(const char *serv){return ((IEspGetMachineInfoRequest *)new CGetMachineInfoRequest(serv));}
extern "C"  IClientGetMachineInfoRequest *createClientGetMachineInfoRequest(const char *serv){return ((IClientGetMachineInfoRequest *)new CGetMachineInfoRequest(serv));}

//=======================================================
// class CRequestInfoStruct Implementation
//=======================================================

CRequestInfoStruct::CRequestInfoStruct(const char *serviceName, IRpcMessageBinding *init)
	: m_Addresses(nilIgnore),m_SortBy(nilIgnore),m_ClusterType(nilIgnore),m_Cluster(nilIgnore),m_OldIP(nilIgnore),m_Path(nilIgnore),m_AddProcessesToFilter(nilIgnore),m_ApplyProcessFilter(nilIgnore),m_GetProcessorInfo(nilIgnore),m_GetStorageInfo(nilIgnore),m_LocalFileSystemsOnly(nilIgnore),m_GetSoftwareInfo(nilIgnore),m_MemThreshold(nilIgnore),m_DiskThreshold(nilIgnore),m_CpuThreshold(nilIgnore),m_AutoRefresh(nilIgnore),m_MemThresholdType(nilIgnore),m_DiskThresholdType(nilIgnore),m_SecurityString(nilIgnore),m_UserName(nilIgnore),m_Password(nilIgnore),m_EnableSNMP(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("RequestInfoStruct");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CRequestInfoStruct::CRequestInfoStruct(const char *serviceName, const char *bc)
	: m_Addresses(nilIgnore),m_SortBy(nilIgnore),m_ClusterType(nilIgnore),m_Cluster(nilIgnore),m_OldIP(nilIgnore),m_Path(nilIgnore),m_AddProcessesToFilter(nilIgnore),m_ApplyProcessFilter(nilIgnore),m_GetProcessorInfo(nilIgnore),m_GetStorageInfo(nilIgnore),m_LocalFileSystemsOnly(nilIgnore),m_GetSoftwareInfo(nilIgnore),m_MemThreshold(nilIgnore),m_DiskThreshold(nilIgnore),m_CpuThreshold(nilIgnore),m_AutoRefresh(nilIgnore),m_MemThresholdType(nilIgnore),m_DiskThresholdType(nilIgnore),m_SecurityString(nilIgnore),m_UserName(nilIgnore),m_Password(nilIgnore),m_EnableSNMP(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("RequestInfoStruct");
}

StringBuffer &CRequestInfoStruct::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:complexType name=\"%s\">\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Addresses\" type=\"tns:EspStringArray\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"ClusterType\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Cluster\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"OldIP\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Path\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"AddProcessesToFilter\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"ApplyProcessFilter\" type=\"xsd:boolean\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"GetProcessorInfo\" type=\"xsd:boolean\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"GetStorageInfo\" type=\"xsd:boolean\"/>\n");
		if (!context.suppressed("RequestInfoStruct","LocalFileSystemsOnly")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"LocalFileSystemsOnly\" type=\"xsd:boolean\"/>\n");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"GetSoftwareInfo\" type=\"xsd:boolean\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"MemThreshold\" type=\"xsd:int\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"DiskThreshold\" type=\"xsd:int\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"CpuThreshold\" type=\"xsd:int\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"AutoRefresh\" type=\"xsd:int\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"MemThresholdType\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"DiskThresholdType\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"SecurityString\" type=\"xsd:string\"");
		if (context.queryOptions()&ESPCTX_ALL_ANNOTATION)
			schema.append("> <xsd:annotation><xsd:appinfo><form formType=\"password\" formCols=\"20\"/></xsd:appinfo></xsd:annotation></xsd:element>\n");
		else
			schema.append("/>\n");
		if (!context.suppressed("RequestInfoStruct","UserName")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"UserName\" type=\"xsd:string\"/>\n");
		}
		if (!context.suppressed("RequestInfoStruct","Password")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"Password\" type=\"xsd:string\"");
			if (context.queryOptions()&ESPCTX_ALL_ANNOTATION)
				schema.append("> <xsd:annotation><xsd:appinfo><form formType=\"password\" formCols=\"20\"/></xsd:appinfo></xsd:annotation></xsd:element>\n");
			else
				schema.append("/>\n");
		}
		if (!context.suppressed("RequestInfoStruct","EnableSNMP")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"EnableSNMP\" type=\"xsd:boolean\"/>\n");
		}
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType>\n");
		}
	}
	if (added.getValue("EspStringArray")==NULL) {
		addEspNativeArray(schema,"string","EspStringArray");
		added.setValue("EspStringArray",1);
	}
	return schema;
}

void CRequestInfoStruct::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CRequestInfoStruct::getMapInfo(IMapInfo& info, BoolHash& added)
{
	info.addMinVersion("RequestInfoStruct","LocalFileSystemsOnly",1.11);
	info.addMinVersion("RequestInfoStruct","UserName",1.02);
	info.addMinVersion("RequestInfoStruct","Password",1.02);
	info.addMinVersion("RequestInfoStruct","EnableSNMP",1.03);
}

StringBuffer &CRequestInfoStruct::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Addresses");
	form.appendf("<tr><td><b>Addresses: </b></td><td>");
	form.appendf("<textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea>", extfix.str());
	form.append("</td></tr>");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("ClusterType");
	form.appendf("  <tr><td><b>ClusterType: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Cluster");
	form.appendf("  <tr><td><b>Cluster: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("OldIP");
	form.appendf("  <tr><td><b>OldIP: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Path");
	form.appendf("  <tr><td><b>Path: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("AddProcessesToFilter");
	form.appendf("  <tr><td><b>AddProcessesToFilter: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("ApplyProcessFilter");
	
	form.appendf("  <tr><td><b>ApplyProcessFilter? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("GetProcessorInfo");
	
	form.appendf("  <tr><td><b>GetProcessorInfo? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("GetStorageInfo");
	
	form.appendf("  <tr><td><b>GetStorageInfo? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	if (!context.suppressed("RequestInfoStruct","LocalFileSystemsOnly")) {
		extfix.clear();
		if (prefix && *prefix)
			extfix.append(prefix).append(".");
		extfix.append("LocalFileSystemsOnly");
		
	form.appendf("  <tr><td><b>LocalFileSystemsOnly? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	}
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("GetSoftwareInfo");
	
	form.appendf("  <tr><td><b>GetSoftwareInfo? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	extfix.clear();
	if (prefix && *prefix) extfix.append(prefix).append(".");
		extfix.append("MemThreshold");
	form.appendf("  <tr><td><b>MemThreshold: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix) extfix.append(prefix).append(".");
		extfix.append("DiskThreshold");
	form.appendf("  <tr><td><b>DiskThreshold: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix) extfix.append(prefix).append(".");
		extfix.append("CpuThreshold");
	form.appendf("  <tr><td><b>CpuThreshold: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix) extfix.append(prefix).append(".");
		extfix.append("AutoRefresh");
	form.appendf("  <tr><td><b>AutoRefresh: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("MemThresholdType");
	form.appendf("  <tr><td><b>MemThresholdType: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("DiskThresholdType");
	form.appendf("  <tr><td><b>DiskThresholdType: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("SecurityString");
	form.appendf("  <tr><td><b>SecurityString: </b></td><td><input type=\"password\" name=\"%s\" size=\"20\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (!context.suppressed("RequestInfoStruct","UserName")) {
		extfix.clear();
		if (prefix && *prefix)
			extfix.append(prefix).append(".");
		extfix.append("UserName");
		form.appendf("  <tr><td><b>UserName: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
		form.append("</td></tr>\n");
	}
	if (!context.suppressed("RequestInfoStruct","Password")) {
		extfix.clear();
		if (prefix && *prefix)
			extfix.append(prefix).append(".");
		extfix.append("Password");
		form.appendf("  <tr><td><b>Password: </b></td><td><input type=\"password\" name=\"%s\" size=\"20\" value=\"\" />", extfix.str());
		form.append("</td></tr>\n");
	}
	if (!context.suppressed("RequestInfoStruct","EnableSNMP")) {
		extfix.clear();
		if (prefix && *prefix)
			extfix.append(prefix).append(".");
		extfix.append("EnableSNMP");
		
	form.appendf("  <tr><td><b>EnableSNMP? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	}
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CRequestInfoStruct::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CRequestInfoStruct::serialize(IRpcMessage& rpc_resp)
{
	IEspContext* ctx = rpc_resp.queryContext();
	double clientVer= ctx ? ctx->getClientVersion() : -1; /* no context gets everything */
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_Addresses.marshall(rpc_resp, "Addresses", "Item");
	m_SortBy.marshall(rpc_resp, "SortBy", "", "", "");
	m_ClusterType.marshall(rpc_resp, "ClusterType", "", "", "");
	m_Cluster.marshall(rpc_resp, "Cluster", "", "", "");
	m_OldIP.marshall(rpc_resp, "OldIP", "", "", "");
	m_Path.marshall(rpc_resp, "Path", "", "", "");
	m_AddProcessesToFilter.marshall(rpc_resp, "AddProcessesToFilter", "", "", "");
	m_ApplyProcessFilter.marshall(rpc_resp, "ApplyProcessFilter", "", "", "");
	m_GetProcessorInfo.marshall(rpc_resp, "GetProcessorInfo", "", "", "");
	m_GetStorageInfo.marshall(rpc_resp, "GetStorageInfo", "", "", "");
	if ((clientVer==-1.0 || clientVer>=1.11))
		m_LocalFileSystemsOnly.marshall(rpc_resp, "LocalFileSystemsOnly", "", "", "");
	m_GetSoftwareInfo.marshall(rpc_resp, "GetSoftwareInfo", "", "", "");
	m_MemThreshold.marshall(rpc_resp, "MemThreshold", "", "", "");
	m_DiskThreshold.marshall(rpc_resp, "DiskThreshold", "", "", "");
	m_CpuThreshold.marshall(rpc_resp, "CpuThreshold", "", "", "");
	m_AutoRefresh.marshall(rpc_resp, "AutoRefresh", "", "", "");
	m_MemThresholdType.marshall(rpc_resp, "MemThresholdType", "", "", "");
	m_DiskThresholdType.marshall(rpc_resp, "DiskThresholdType", "", "", "");
	m_SecurityString.marshall(rpc_resp, "SecurityString", "", "", "");
	if ((clientVer==-1.0 || clientVer>=1.02))
		m_UserName.marshall(rpc_resp, "UserName", "", "", "");
	if ((clientVer==-1.0 || clientVer>=1.02))
		m_Password.marshall(rpc_resp, "Password", "", "", "");
	if ((clientVer==-1.0 || clientVer>=1.03))
		m_EnableSNMP.marshall(rpc_resp, "EnableSNMP", "", "", "");
}


void CRequestInfoStruct::copy(CRequestInfoStruct &from)
{
	m_Addresses.copy(from.m_Addresses);
	m_SortBy.copy(from.m_SortBy);
	m_ClusterType.copy(from.m_ClusterType);
	m_Cluster.copy(from.m_Cluster);
	m_OldIP.copy(from.m_OldIP);
	m_Path.copy(from.m_Path);
	m_AddProcessesToFilter.copy(from.m_AddProcessesToFilter);
	m_ApplyProcessFilter.copy(from.m_ApplyProcessFilter);
	m_GetProcessorInfo.copy(from.m_GetProcessorInfo);
	m_GetStorageInfo.copy(from.m_GetStorageInfo);
	m_LocalFileSystemsOnly.copy(from.m_LocalFileSystemsOnly);
	m_GetSoftwareInfo.copy(from.m_GetSoftwareInfo);
	m_MemThreshold.copy(from.m_MemThreshold);
	m_DiskThreshold.copy(from.m_DiskThreshold);
	m_CpuThreshold.copy(from.m_CpuThreshold);
	m_AutoRefresh.copy(from.m_AutoRefresh);
	m_MemThresholdType.copy(from.m_MemThresholdType);
	m_DiskThresholdType.copy(from.m_DiskThresholdType);
	m_SecurityString.copy(from.m_SecurityString);
	m_UserName.copy(from.m_UserName);
	m_Password.copy(from.m_Password);
	m_EnableSNMP.copy(from.m_EnableSNMP);
}


void CRequestInfoStruct::copy(IConstRequestInfoStruct &ifrom)
{
	setAddresses(ifrom.getAddresses());
	setSortBy(ifrom.getSortBy());
	setClusterType(ifrom.getClusterType());
	setCluster(ifrom.getCluster());
	setOldIP(ifrom.getOldIP());
	setPath(ifrom.getPath());
	setAddProcessesToFilter(ifrom.getAddProcessesToFilter());
	setApplyProcessFilter(ifrom.getApplyProcessFilter());
	setGetProcessorInfo(ifrom.getGetProcessorInfo());
	setGetStorageInfo(ifrom.getGetStorageInfo());
	setLocalFileSystemsOnly(ifrom.getLocalFileSystemsOnly());
	setGetSoftwareInfo(ifrom.getGetSoftwareInfo());
	setMemThreshold(ifrom.getMemThreshold());
	setDiskThreshold(ifrom.getDiskThreshold());
	setCpuThreshold(ifrom.getCpuThreshold());
	setAutoRefresh(ifrom.getAutoRefresh());
	setMemThresholdType(ifrom.getMemThresholdType());
	setDiskThresholdType(ifrom.getDiskThresholdType());
	setSecurityString(ifrom.getSecurityString());
	setUserName(ifrom.getUserName());
	setPassword(ifrom.getPassword());
	setEnableSNMP(ifrom.getEnableSNMP());
}


void CRequestInfoStruct::getAttributes(IProperties &attributes)
{
}


void CRequestInfoStruct::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	double clientVer = ctx ? ctx->getClientVersion() : -1;
	m_Addresses.toStr(ctx, buffer, "Addresses", "Item");
	m_SortBy.toStr(ctx, buffer, "SortBy", "", true, "", "");
	m_ClusterType.toStr(ctx, buffer, "ClusterType", "", true, "", "");
	m_Cluster.toStr(ctx, buffer, "Cluster", "", true, "", "");
	m_OldIP.toStr(ctx, buffer, "OldIP", "", true, "", "");
	m_Path.toStr(ctx, buffer, "Path", "", true, "", "");
	m_AddProcessesToFilter.toStr(ctx, buffer, "AddProcessesToFilter", "", true, "", "");
	m_ApplyProcessFilter.toStr(ctx, buffer, "ApplyProcessFilter", "", true, "", "");
	m_GetProcessorInfo.toStr(ctx, buffer, "GetProcessorInfo", "", true, "", "");
	m_GetStorageInfo.toStr(ctx, buffer, "GetStorageInfo", "", true, "", "");
	if ((clientVer==-1.0 || clientVer>=1.11))
		m_LocalFileSystemsOnly.toStr(ctx, buffer, "LocalFileSystemsOnly", "", true, "", "");
	m_GetSoftwareInfo.toStr(ctx, buffer, "GetSoftwareInfo", "", true, "", "");
	m_MemThreshold.toStr(ctx, buffer, "MemThreshold", "", true, "", "");
	m_DiskThreshold.toStr(ctx, buffer, "DiskThreshold", "", true, "", "");
	m_CpuThreshold.toStr(ctx, buffer, "CpuThreshold", "", true, "", "");
	m_AutoRefresh.toStr(ctx, buffer, "AutoRefresh", "", true, "", "");
	m_MemThresholdType.toStr(ctx, buffer, "MemThresholdType", "", true, "", "");
	m_DiskThresholdType.toStr(ctx, buffer, "DiskThresholdType", "", true, "", "");
	m_SecurityString.toStr(ctx, buffer, "SecurityString", "", true, "", "");
	if ((clientVer==-1.0 || clientVer>=1.02))
		m_UserName.toStr(ctx, buffer, "UserName", "", true, "", "");
	if ((clientVer==-1.0 || clientVer>=1.02))
		m_Password.toStr(ctx, buffer, "Password", "", true, "", "");
	if ((clientVer==-1.0 || clientVer>=1.03))
		m_EnableSNMP.toStr(ctx, buffer, "EnableSNMP", "", true, "", "");
}


void CRequestInfoStruct::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CRequestInfoStruct::serializer(IEspContext* ctx, IConstRequestInfoStruct &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<RequestInfoStruct>");
	double clientVer = ctx ? ctx->getClientVersion() : -1;
	// field Addresses
	{
		StringArray& v = src.getAddresses();
		if (v.length()>0)
			buffer.append("<Addresses>");
		for (size32_t i=0;i<v.length();i++)
			buffer.appendf("<Item>%s</Item>",v.item(i));
		if (v.length()>0)
			buffer.append("</Addresses>");
	}
	// field SortBy
	{
		const char* s = src.getSortBy();
		if (s && *s)
		{
			buffer.append("<SortBy>");
			encodeUtf8XML(s,buffer);
			buffer.append("</SortBy>");
		}
	}
	// field ClusterType
	{
		const char* s = src.getClusterType();
		if (s && *s)
		{
			buffer.append("<ClusterType>");
			encodeUtf8XML(s,buffer);
			buffer.append("</ClusterType>");
		}
	}
	// field Cluster
	{
		const char* s = src.getCluster();
		if (s && *s)
		{
			buffer.append("<Cluster>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Cluster>");
		}
	}
	// field OldIP
	{
		const char* s = src.getOldIP();
		if (s && *s)
		{
			buffer.append("<OldIP>");
			encodeUtf8XML(s,buffer);
			buffer.append("</OldIP>");
		}
	}
	// field Path
	{
		const char* s = src.getPath();
		if (s && *s)
		{
			buffer.append("<Path>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Path>");
		}
	}
	// field AddProcessesToFilter
	{
		const char* s = src.getAddProcessesToFilter();
		if (s && *s)
		{
			buffer.append("<AddProcessesToFilter>");
			encodeUtf8XML(s,buffer);
			buffer.append("</AddProcessesToFilter>");
		}
	}
	// field ApplyProcessFilter
	{
		bool b = src.getApplyProcessFilter();
		if (b)
			buffer.appendf("<ApplyProcessFilter>1</ApplyProcessFilter>");
	}
	// field GetProcessorInfo
	{
		bool b = src.getGetProcessorInfo();
		if (b)
			buffer.appendf("<GetProcessorInfo>1</GetProcessorInfo>");
	}
	// field GetStorageInfo
	{
		bool b = src.getGetStorageInfo();
		if (b)
			buffer.appendf("<GetStorageInfo>1</GetStorageInfo>");
	}
	// field LocalFileSystemsOnly
	if ((clientVer==-1.0 || clientVer>=1.11))
	{
		bool b = src.getLocalFileSystemsOnly();
		if (b)
			buffer.appendf("<LocalFileSystemsOnly>1</LocalFileSystemsOnly>");
	}
	// field GetSoftwareInfo
	{
		bool b = src.getGetSoftwareInfo();
		if (b)
			buffer.appendf("<GetSoftwareInfo>1</GetSoftwareInfo>");
	}
	// field MemThreshold
	{
		int n = src.getMemThreshold();
		if (n)
			buffer.appendf("<MemThreshold>%d</MemThreshold>", n);
	}
	// field DiskThreshold
	{
		int n = src.getDiskThreshold();
		if (n)
			buffer.appendf("<DiskThreshold>%d</DiskThreshold>", n);
	}
	// field CpuThreshold
	{
		int n = src.getCpuThreshold();
		if (n)
			buffer.appendf("<CpuThreshold>%d</CpuThreshold>", n);
	}
	// field AutoRefresh
	{
		int n = src.getAutoRefresh();
		if (n)
			buffer.appendf("<AutoRefresh>%d</AutoRefresh>", n);
	}
	// field MemThresholdType
	{
		const char* s = src.getMemThresholdType();
		if (s && *s)
		{
			buffer.append("<MemThresholdType>");
			encodeUtf8XML(s,buffer);
			buffer.append("</MemThresholdType>");
		}
	}
	// field DiskThresholdType
	{
		const char* s = src.getDiskThresholdType();
		if (s && *s)
		{
			buffer.append("<DiskThresholdType>");
			encodeUtf8XML(s,buffer);
			buffer.append("</DiskThresholdType>");
		}
	}
	// field SecurityString
	{
		const char* s = src.getSecurityString();
		if (s && *s)
		{
			buffer.append("<SecurityString>");
			encodeUtf8XML(s,buffer);
			buffer.append("</SecurityString>");
		}
	}
	// field UserName
	if ((clientVer==-1.0 || clientVer>=1.02))
	{
		const char* s = src.getUserName();
		if (s && *s)
		{
			buffer.append("<UserName>");
			encodeUtf8XML(s,buffer);
			buffer.append("</UserName>");
		}
	}
	// field Password
	if ((clientVer==-1.0 || clientVer>=1.02))
	{
		const char* s = src.getPassword();
		if (s && *s)
		{
			buffer.append("<Password>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Password>");
		}
	}
	// field EnableSNMP
	if ((clientVer==-1.0 || clientVer>=1.03))
	{
		bool b = src.getEnableSNMP();
		if (b)
			buffer.appendf("<EnableSNMP>1</EnableSNMP>");
	}
	if (keepRootTag)
		buffer.append("</RequestInfoStruct>");
}

bool CRequestInfoStruct::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_Addresses.unmarshall(rpc_request, "Addresses", basepath);
	hasValue |= m_SortBy.unmarshall(rpc_request, "SortBy", basepath);
	hasValue |= m_ClusterType.unmarshall(rpc_request, "ClusterType", basepath);
	hasValue |= m_Cluster.unmarshall(rpc_request, "Cluster", basepath);
	hasValue |= m_OldIP.unmarshall(rpc_request, "OldIP", basepath);
	hasValue |= m_Path.unmarshall(rpc_request, "Path", basepath);
	hasValue |= m_AddProcessesToFilter.unmarshall(rpc_request, "AddProcessesToFilter", basepath);
	hasValue |= m_ApplyProcessFilter.unmarshall(rpc_request, "ApplyProcessFilter", basepath);
	hasValue |= m_GetProcessorInfo.unmarshall(rpc_request, "GetProcessorInfo", basepath);
	hasValue |= m_GetStorageInfo.unmarshall(rpc_request, "GetStorageInfo", basepath);
	hasValue |= m_LocalFileSystemsOnly.unmarshall(rpc_request, "LocalFileSystemsOnly", basepath);
	hasValue |= m_GetSoftwareInfo.unmarshall(rpc_request, "GetSoftwareInfo", basepath);
	hasValue |= m_MemThreshold.unmarshall(rpc_request, "MemThreshold", basepath);
	hasValue |= m_DiskThreshold.unmarshall(rpc_request, "DiskThreshold", basepath);
	hasValue |= m_CpuThreshold.unmarshall(rpc_request, "CpuThreshold", basepath);
	hasValue |= m_AutoRefresh.unmarshall(rpc_request, "AutoRefresh", basepath);
	hasValue |= m_MemThresholdType.unmarshall(rpc_request, "MemThresholdType", basepath);
	hasValue |= m_DiskThresholdType.unmarshall(rpc_request, "DiskThresholdType", basepath);
	hasValue |= m_SecurityString.unmarshall(rpc_request, "SecurityString", basepath);
	hasValue |= m_UserName.unmarshall(rpc_request, "UserName", basepath);
	hasValue |= m_Password.unmarshall(rpc_request, "Password", basepath);
	hasValue |= m_EnableSNMP.unmarshall(rpc_request, "EnableSNMP", basepath);
	return hasValue;
}

bool CRequestInfoStruct::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Addresses.unmarshall(ctx, soapval, "Addresses");
	hasValue |= m_SortBy.unmarshall(ctx, soapval, "SortBy");
	hasValue |= m_ClusterType.unmarshall(ctx, soapval, "ClusterType");
	hasValue |= m_Cluster.unmarshall(ctx, soapval, "Cluster");
	hasValue |= m_OldIP.unmarshall(ctx, soapval, "OldIP");
	hasValue |= m_Path.unmarshall(ctx, soapval, "Path");
	hasValue |= m_AddProcessesToFilter.unmarshall(ctx, soapval, "AddProcessesToFilter");
	hasValue |= m_ApplyProcessFilter.unmarshall(ctx, soapval, "ApplyProcessFilter");
	hasValue |= m_GetProcessorInfo.unmarshall(ctx, soapval, "GetProcessorInfo");
	hasValue |= m_GetStorageInfo.unmarshall(ctx, soapval, "GetStorageInfo");
	hasValue |= m_LocalFileSystemsOnly.unmarshall(ctx, soapval, "LocalFileSystemsOnly");
	hasValue |= m_GetSoftwareInfo.unmarshall(ctx, soapval, "GetSoftwareInfo");
	hasValue |= m_MemThreshold.unmarshall(ctx, soapval, "MemThreshold");
	hasValue |= m_DiskThreshold.unmarshall(ctx, soapval, "DiskThreshold");
	hasValue |= m_CpuThreshold.unmarshall(ctx, soapval, "CpuThreshold");
	hasValue |= m_AutoRefresh.unmarshall(ctx, soapval, "AutoRefresh");
	hasValue |= m_MemThresholdType.unmarshall(ctx, soapval, "MemThresholdType");
	hasValue |= m_DiskThresholdType.unmarshall(ctx, soapval, "DiskThresholdType");
	hasValue |= m_SecurityString.unmarshall(ctx, soapval, "SecurityString");
	hasValue |= m_UserName.unmarshall(ctx, soapval, "UserName");
	hasValue |= m_Password.unmarshall(ctx, soapval, "Password");
	hasValue |= m_EnableSNMP.unmarshall(ctx, soapval, "EnableSNMP");
	return hasValue;
}

bool CRequestInfoStruct::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Addresses.unmarshall(ctx, params, attachments, "Addresses", basepath);
	hasValue |= m_SortBy.unmarshall(ctx, params, attachments, "SortBy", basepath);
	hasValue |= m_ClusterType.unmarshall(ctx, params, attachments, "ClusterType", basepath);
	hasValue |= m_Cluster.unmarshall(ctx, params, attachments, "Cluster", basepath);
	hasValue |= m_OldIP.unmarshall(ctx, params, attachments, "OldIP", basepath);
	hasValue |= m_Path.unmarshall(ctx, params, attachments, "Path", basepath);
	hasValue |= m_AddProcessesToFilter.unmarshall(ctx, params, attachments, "AddProcessesToFilter", basepath);
	hasValue |= m_ApplyProcessFilter.unmarshall(ctx, params, attachments, "ApplyProcessFilter", basepath);
	hasValue |= m_GetProcessorInfo.unmarshall(ctx, params, attachments, "GetProcessorInfo", basepath);
	hasValue |= m_GetStorageInfo.unmarshall(ctx, params, attachments, "GetStorageInfo", basepath);
	hasValue |= m_LocalFileSystemsOnly.unmarshall(ctx, params, attachments, "LocalFileSystemsOnly", basepath);
	hasValue |= m_GetSoftwareInfo.unmarshall(ctx, params, attachments, "GetSoftwareInfo", basepath);
	hasValue |= m_MemThreshold.unmarshall(ctx, params, attachments, "MemThreshold", basepath);
	hasValue |= m_DiskThreshold.unmarshall(ctx, params, attachments, "DiskThreshold", basepath);
	hasValue |= m_CpuThreshold.unmarshall(ctx, params, attachments, "CpuThreshold", basepath);
	hasValue |= m_AutoRefresh.unmarshall(ctx, params, attachments, "AutoRefresh", basepath);
	hasValue |= m_MemThresholdType.unmarshall(ctx, params, attachments, "MemThresholdType", basepath);
	hasValue |= m_DiskThresholdType.unmarshall(ctx, params, attachments, "DiskThresholdType", basepath);
	hasValue |= m_SecurityString.unmarshall(ctx, params, attachments, "SecurityString", basepath);
	hasValue |= m_UserName.unmarshall(ctx, params, attachments, "UserName", basepath);
	hasValue |= m_Password.unmarshall(ctx, params, attachments, "Password", basepath);
	hasValue |= m_EnableSNMP.unmarshall(ctx, params, attachments, "EnableSNMP", basepath);
	return hasValue;
}

StringArray & CRequestInfoStruct::getAddresses() { return (StringArray &) m_Addresses; }
const char * CRequestInfoStruct::getSortBy() { return m_SortBy.query();}
const char * CRequestInfoStruct::getClusterType() { return m_ClusterType.query();}
const char * CRequestInfoStruct::getCluster() { return m_Cluster.query();}
const char * CRequestInfoStruct::getOldIP() { return m_OldIP.query();}
const char * CRequestInfoStruct::getPath() { return m_Path.query();}
const char * CRequestInfoStruct::getAddProcessesToFilter() { return m_AddProcessesToFilter.query();}
bool CRequestInfoStruct::getApplyProcessFilter() { return m_ApplyProcessFilter;}
bool CRequestInfoStruct::getGetProcessorInfo() { return m_GetProcessorInfo;}
bool CRequestInfoStruct::getGetStorageInfo() { return m_GetStorageInfo;}
bool CRequestInfoStruct::getLocalFileSystemsOnly() { return m_LocalFileSystemsOnly;}
bool CRequestInfoStruct::getGetSoftwareInfo() { return m_GetSoftwareInfo;}
int CRequestInfoStruct::getMemThreshold() { return m_MemThreshold;}
int CRequestInfoStruct::getDiskThreshold() { return m_DiskThreshold;}
int CRequestInfoStruct::getCpuThreshold() { return m_CpuThreshold;}
int CRequestInfoStruct::getAutoRefresh() { return m_AutoRefresh;}
const char * CRequestInfoStruct::getMemThresholdType() { return m_MemThresholdType.query();}
const char * CRequestInfoStruct::getDiskThresholdType() { return m_DiskThresholdType.query();}
const char * CRequestInfoStruct::getSecurityString() { return m_SecurityString.query();}
const char * CRequestInfoStruct::getUserName() { return m_UserName.query();}
const char * CRequestInfoStruct::getPassword() { return m_Password.query();}
bool CRequestInfoStruct::getEnableSNMP() { return m_EnableSNMP;}
void CRequestInfoStruct::setAddresses(StringArray &val){ m_Addresses->kill();  CloneArray(m_Addresses.getValue(), val); }
void CRequestInfoStruct::setSortBy(const char * val){ m_SortBy.set(val); }
void CRequestInfoStruct::setClusterType(const char * val){ m_ClusterType.set(val); }
void CRequestInfoStruct::setCluster(const char * val){ m_Cluster.set(val); }
void CRequestInfoStruct::setOldIP(const char * val){ m_OldIP.set(val); }
void CRequestInfoStruct::setPath(const char * val){ m_Path.set(val); }
void CRequestInfoStruct::setAddProcessesToFilter(const char * val){ m_AddProcessesToFilter.set(val); }
void CRequestInfoStruct::setApplyProcessFilter(bool val){ m_ApplyProcessFilter=val; }
void CRequestInfoStruct::setGetProcessorInfo(bool val){ m_GetProcessorInfo=val; }
void CRequestInfoStruct::setGetStorageInfo(bool val){ m_GetStorageInfo=val; }
void CRequestInfoStruct::setLocalFileSystemsOnly(bool val){ m_LocalFileSystemsOnly=val; }
void CRequestInfoStruct::setGetSoftwareInfo(bool val){ m_GetSoftwareInfo=val; }
void CRequestInfoStruct::setMemThreshold(int val){ m_MemThreshold=val; }
void CRequestInfoStruct::setDiskThreshold(int val){ m_DiskThreshold=val; }
void CRequestInfoStruct::setCpuThreshold(int val){ m_CpuThreshold=val; }
void CRequestInfoStruct::setAutoRefresh(int val){ m_AutoRefresh=val; }
void CRequestInfoStruct::setMemThresholdType(const char * val){ m_MemThresholdType.set(val); }
void CRequestInfoStruct::setDiskThresholdType(const char * val){ m_DiskThresholdType.set(val); }
void CRequestInfoStruct::setSecurityString(const char * val){ m_SecurityString.set(val); }
void CRequestInfoStruct::setUserName(const char * val){ m_UserName.set(val); }
void CRequestInfoStruct::setPassword(const char * val){ m_Password.set(val); }
void CRequestInfoStruct::setEnableSNMP(bool val){ m_EnableSNMP=val; }
extern "C"  IEspRequestInfoStruct *createRequestInfoStruct(const char *serv, const char *msgname){return ((IEspRequestInfoStruct *)new CRequestInfoStruct(serv /*, msgname*/));}
extern "C"  IClientRequestInfoStruct *createClientRequestInfoStruct(const char *serv, const char *msgname){return ((IClientRequestInfoStruct *)new CRequestInfoStruct(serv /*, msgname*/));}

//=======================================================
// class CProcessorInfo Implementation
//=======================================================

CProcessorInfo::CProcessorInfo(const char *serviceName, IRpcMessageBinding *init)
	: m_Type(nilIgnore),m_Load(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ProcessorInfo");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CProcessorInfo::CProcessorInfo(const char *serviceName, const char *bc)
	: m_Type(nilIgnore),m_Load(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ProcessorInfo");
}

StringBuffer &CProcessorInfo::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:complexType name=\"%s\">\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Type\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Load\" type=\"xsd:int\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType>\n");
		}
	}
	return schema;
}

void CProcessorInfo::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CProcessorInfo::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CProcessorInfo::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Type");
	form.appendf("  <tr><td><b>Type: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix) extfix.append(prefix).append(".");
		extfix.append("Load");
	form.appendf("  <tr><td><b>Load: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CProcessorInfo::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CProcessorInfo::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_Type.marshall(rpc_resp, "Type", "", "", "");
	m_Load.marshall(rpc_resp, "Load", "", "", "");
}


void CProcessorInfo::copy(CProcessorInfo &from)
{
	m_Type.copy(from.m_Type);
	m_Load.copy(from.m_Load);
}


void CProcessorInfo::copy(IConstProcessorInfo &ifrom)
{
	setType(ifrom.getType());
	setLoad(ifrom.getLoad());
}


void CProcessorInfo::getAttributes(IProperties &attributes)
{
}


void CProcessorInfo::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_Type.toStr(ctx, buffer, "Type", "", true, "", "");
	m_Load.toStr(ctx, buffer, "Load", "", true, "", "");
}


void CProcessorInfo::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CProcessorInfo::serializer(IEspContext* ctx, IConstProcessorInfo &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<ProcessorInfo>");
	// field Type
	{
		const char* s = src.getType();
		if (s && *s)
		{
			buffer.append("<Type>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Type>");
		}
	}
	// field Load
	{
		int n = src.getLoad();
		if (n)
			buffer.appendf("<Load>%d</Load>", n);
	}
	if (keepRootTag)
		buffer.append("</ProcessorInfo>");
}

bool CProcessorInfo::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_Type.unmarshall(rpc_request, "Type", basepath);
	hasValue |= m_Load.unmarshall(rpc_request, "Load", basepath);
	return hasValue;
}

bool CProcessorInfo::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Type.unmarshall(ctx, soapval, "Type");
	hasValue |= m_Load.unmarshall(ctx, soapval, "Load");
	return hasValue;
}

bool CProcessorInfo::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Type.unmarshall(ctx, params, attachments, "Type", basepath);
	hasValue |= m_Load.unmarshall(ctx, params, attachments, "Load", basepath);
	return hasValue;
}

const char * CProcessorInfo::getType() { return m_Type.query();}
int CProcessorInfo::getLoad() { return m_Load;}
void CProcessorInfo::setType(const char * val){ m_Type.set(val); }
void CProcessorInfo::setLoad(int val){ m_Load=val; }
extern "C"  IEspProcessorInfo *createProcessorInfo(const char *serv, const char *msgname){return ((IEspProcessorInfo *)new CProcessorInfo(serv /*, msgname*/));}
extern "C"  IClientProcessorInfo *createClientProcessorInfo(const char *serv, const char *msgname){return ((IClientProcessorInfo *)new CProcessorInfo(serv /*, msgname*/));}

//=======================================================
// class CStorageInfo Implementation
//=======================================================

CStorageInfo::CStorageInfo(const char *serviceName, IRpcMessageBinding *init)
	: m_Description(nilIgnore),m_Type(nilIgnore),m_Available(nilIgnore),m_PercentAvail(nilIgnore),m_Total(nilIgnore),m_Failures(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("StorageInfo");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CStorageInfo::CStorageInfo(const char *serviceName, const char *bc)
	: m_Description(nilIgnore),m_Type(nilIgnore),m_Available(nilIgnore),m_PercentAvail(nilIgnore),m_Total(nilIgnore),m_Failures(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("StorageInfo");
}

StringBuffer &CStorageInfo::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:complexType name=\"%s\">\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Description\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Type\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Available\" type=\"xsd:long\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"PercentAvail\" type=\"xsd:int\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Total\" type=\"xsd:long\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Failures\" type=\"xsd:int\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType>\n");
		}
	}
	return schema;
}

void CStorageInfo::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CStorageInfo::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CStorageInfo::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Description");
	form.appendf("  <tr><td><b>Description: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Type");
	form.appendf("  <tr><td><b>Type: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Available");
	form.appendf("  <tr><td><b>Available: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix) extfix.append(prefix).append(".");
		extfix.append("PercentAvail");
	form.appendf("  <tr><td><b>PercentAvail: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Total");
	form.appendf("  <tr><td><b>Total: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix) extfix.append(prefix).append(".");
		extfix.append("Failures");
	form.appendf("  <tr><td><b>Failures: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CStorageInfo::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CStorageInfo::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_Description.marshall(rpc_resp, "Description", "", "", "");
	m_Type.marshall(rpc_resp, "Type", "", "", "");
	m_Available.marshall(rpc_resp, "Available", "", "", "");
	m_PercentAvail.marshall(rpc_resp, "PercentAvail", "", "", "");
	m_Total.marshall(rpc_resp, "Total", "", "", "");
	m_Failures.marshall(rpc_resp, "Failures", "", "", "");
}


void CStorageInfo::copy(CStorageInfo &from)
{
	m_Description.copy(from.m_Description);
	m_Type.copy(from.m_Type);
	m_Available.copy(from.m_Available);
	m_PercentAvail.copy(from.m_PercentAvail);
	m_Total.copy(from.m_Total);
	m_Failures.copy(from.m_Failures);
}


void CStorageInfo::copy(IConstStorageInfo &ifrom)
{
	setDescription(ifrom.getDescription());
	setType(ifrom.getType());
	setAvailable(ifrom.getAvailable());
	setPercentAvail(ifrom.getPercentAvail());
	setTotal(ifrom.getTotal());
	setFailures(ifrom.getFailures());
}


void CStorageInfo::getAttributes(IProperties &attributes)
{
}


void CStorageInfo::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_Description.toStr(ctx, buffer, "Description", "", true, "", "");
	m_Type.toStr(ctx, buffer, "Type", "", true, "", "");
	m_Available.toStr(ctx, buffer, "Available", "", true, "", "");
	m_PercentAvail.toStr(ctx, buffer, "PercentAvail", "", true, "", "");
	m_Total.toStr(ctx, buffer, "Total", "", true, "", "");
	m_Failures.toStr(ctx, buffer, "Failures", "", true, "", "");
}


void CStorageInfo::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CStorageInfo::serializer(IEspContext* ctx, IConstStorageInfo &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<StorageInfo>");
	// field Description
	{
		const char* s = src.getDescription();
		if (s && *s)
		{
			buffer.append("<Description>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Description>");
		}
	}
	// field Type
	{
		const char* s = src.getType();
		if (s && *s)
		{
			buffer.append("<Type>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Type>");
		}
	}
	// field Available
	{
		//*** default kind: TK_INT; type=int64, name=Available
		buffer.append("<Available>");
		buffer.append(src.getAvailable());
		buffer.append("</Available>");
	}
	// field PercentAvail
	{
		int n = src.getPercentAvail();
		if (n)
			buffer.appendf("<PercentAvail>%d</PercentAvail>", n);
	}
	// field Total
	{
		//*** default kind: TK_INT; type=int64, name=Total
		buffer.append("<Total>");
		buffer.append(src.getTotal());
		buffer.append("</Total>");
	}
	// field Failures
	{
		int n = src.getFailures();
		if (n)
			buffer.appendf("<Failures>%d</Failures>", n);
	}
	if (keepRootTag)
		buffer.append("</StorageInfo>");
}

bool CStorageInfo::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_Description.unmarshall(rpc_request, "Description", basepath);
	hasValue |= m_Type.unmarshall(rpc_request, "Type", basepath);
	hasValue |= m_Available.unmarshall(rpc_request, "Available", basepath);
	hasValue |= m_PercentAvail.unmarshall(rpc_request, "PercentAvail", basepath);
	hasValue |= m_Total.unmarshall(rpc_request, "Total", basepath);
	hasValue |= m_Failures.unmarshall(rpc_request, "Failures", basepath);
	return hasValue;
}

bool CStorageInfo::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Description.unmarshall(ctx, soapval, "Description");
	hasValue |= m_Type.unmarshall(ctx, soapval, "Type");
	hasValue |= m_Available.unmarshall(ctx, soapval, "Available");
	hasValue |= m_PercentAvail.unmarshall(ctx, soapval, "PercentAvail");
	hasValue |= m_Total.unmarshall(ctx, soapval, "Total");
	hasValue |= m_Failures.unmarshall(ctx, soapval, "Failures");
	return hasValue;
}

bool CStorageInfo::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Description.unmarshall(ctx, params, attachments, "Description", basepath);
	hasValue |= m_Type.unmarshall(ctx, params, attachments, "Type", basepath);
	hasValue |= m_Available.unmarshall(ctx, params, attachments, "Available", basepath);
	hasValue |= m_PercentAvail.unmarshall(ctx, params, attachments, "PercentAvail", basepath);
	hasValue |= m_Total.unmarshall(ctx, params, attachments, "Total", basepath);
	hasValue |= m_Failures.unmarshall(ctx, params, attachments, "Failures", basepath);
	return hasValue;
}

const char * CStorageInfo::getDescription() { return m_Description.query();}
const char * CStorageInfo::getType() { return m_Type.query();}
__int64 CStorageInfo::getAvailable() { return m_Available;}
int CStorageInfo::getPercentAvail() { return m_PercentAvail;}
__int64 CStorageInfo::getTotal() { return m_Total;}
int CStorageInfo::getFailures() { return m_Failures;}
void CStorageInfo::setDescription(const char * val){ m_Description.set(val); }
void CStorageInfo::setType(const char * val){ m_Type.set(val); }
void CStorageInfo::setAvailable(__int64 val){ m_Available=val; }
void CStorageInfo::setPercentAvail(int val){ m_PercentAvail=val; }
void CStorageInfo::setTotal(__int64 val){ m_Total=val; }
void CStorageInfo::setFailures(int val){ m_Failures=val; }
extern "C"  IEspStorageInfo *createStorageInfo(const char *serv, const char *msgname){return ((IEspStorageInfo *)new CStorageInfo(serv /*, msgname*/));}
extern "C"  IClientStorageInfo *createClientStorageInfo(const char *serv, const char *msgname){return ((IClientStorageInfo *)new CStorageInfo(serv /*, msgname*/));}

//=======================================================
// class CSWRunInfo Implementation
//=======================================================

CSWRunInfo::CSWRunInfo(const char *serviceName, IRpcMessageBinding *init)
	: m_Name(nilIgnore),m_Instances(nilIgnore),m_State(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("SWRunInfo");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CSWRunInfo::CSWRunInfo(const char *serviceName, const char *bc)
	: m_Name(nilIgnore),m_Instances(nilIgnore),m_State(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("SWRunInfo");
}

StringBuffer &CSWRunInfo::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:complexType name=\"%s\">\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Name\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Instances\" type=\"xsd:int\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"State\" type=\"xsd:int\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType>\n");
		}
	}
	return schema;
}

void CSWRunInfo::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CSWRunInfo::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CSWRunInfo::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Name");
	form.appendf("  <tr><td><b>Name: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix) extfix.append(prefix).append(".");
		extfix.append("Instances");
	form.appendf("  <tr><td><b>Instances: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix) extfix.append(prefix).append(".");
		extfix.append("State");
	form.appendf("  <tr><td><b>State: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CSWRunInfo::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CSWRunInfo::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_Name.marshall(rpc_resp, "Name", "", "", "");
	m_Instances.marshall(rpc_resp, "Instances", "", "", "");
	m_State.marshall(rpc_resp, "State", "", "", "");
}


void CSWRunInfo::copy(CSWRunInfo &from)
{
	m_Name.copy(from.m_Name);
	m_Instances.copy(from.m_Instances);
	m_State.copy(from.m_State);
}


void CSWRunInfo::copy(IConstSWRunInfo &ifrom)
{
	setName(ifrom.getName());
	setInstances(ifrom.getInstances());
	setState(ifrom.getState());
}


void CSWRunInfo::getAttributes(IProperties &attributes)
{
}


void CSWRunInfo::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_Name.toStr(ctx, buffer, "Name", "", true, "", "");
	m_Instances.toStr(ctx, buffer, "Instances", "", true, "", "");
	m_State.toStr(ctx, buffer, "State", "", true, "", "");
}


void CSWRunInfo::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CSWRunInfo::serializer(IEspContext* ctx, IConstSWRunInfo &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<SWRunInfo>");
	// field Name
	{
		const char* s = src.getName();
		if (s && *s)
		{
			buffer.append("<Name>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Name>");
		}
	}
	// field Instances
	{
		int n = src.getInstances();
		if (n)
			buffer.appendf("<Instances>%d</Instances>", n);
	}
	// field State
	{
		int n = src.getState();
		if (n)
			buffer.appendf("<State>%d</State>", n);
	}
	if (keepRootTag)
		buffer.append("</SWRunInfo>");
}

bool CSWRunInfo::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_Name.unmarshall(rpc_request, "Name", basepath);
	hasValue |= m_Instances.unmarshall(rpc_request, "Instances", basepath);
	hasValue |= m_State.unmarshall(rpc_request, "State", basepath);
	return hasValue;
}

bool CSWRunInfo::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Name.unmarshall(ctx, soapval, "Name");
	hasValue |= m_Instances.unmarshall(ctx, soapval, "Instances");
	hasValue |= m_State.unmarshall(ctx, soapval, "State");
	return hasValue;
}

bool CSWRunInfo::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Name.unmarshall(ctx, params, attachments, "Name", basepath);
	hasValue |= m_Instances.unmarshall(ctx, params, attachments, "Instances", basepath);
	hasValue |= m_State.unmarshall(ctx, params, attachments, "State", basepath);
	return hasValue;
}

const char * CSWRunInfo::getName() { return m_Name.query();}
int CSWRunInfo::getInstances() { return m_Instances;}
int CSWRunInfo::getState() { return m_State;}
void CSWRunInfo::setName(const char * val){ m_Name.set(val); }
void CSWRunInfo::setInstances(int val){ m_Instances=val; }
void CSWRunInfo::setState(int val){ m_State=val; }
extern "C"  IEspSWRunInfo *createSWRunInfo(const char *serv, const char *msgname){return ((IEspSWRunInfo *)new CSWRunInfo(serv /*, msgname*/));}
extern "C"  IClientSWRunInfo *createClientSWRunInfo(const char *serv, const char *msgname){return ((IClientSWRunInfo *)new CSWRunInfo(serv /*, msgname*/));}

//=======================================================
// class CProcessInfo Implementation
//=======================================================

CProcessInfo::CProcessInfo(const char *serviceName, IRpcMessageBinding *init)
	: m_PID(nilIgnore),m_Description(nilIgnore),m_Parameter(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ProcessInfo");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CProcessInfo::CProcessInfo(const char *serviceName, const char *bc)
	: m_PID(nilIgnore),m_Description(nilIgnore),m_Parameter(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ProcessInfo");
}

StringBuffer &CProcessInfo::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:complexType name=\"%s\">\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"PID\" type=\"xsd:int\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Description\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Parameter\" type=\"xsd:string\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType>\n");
		}
	}
	return schema;
}

void CProcessInfo::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CProcessInfo::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CProcessInfo::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix) extfix.append(prefix).append(".");
		extfix.append("PID");
	form.appendf("  <tr><td><b>PID: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Description");
	form.appendf("  <tr><td><b>Description: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Parameter");
	form.appendf("  <tr><td><b>Parameter: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CProcessInfo::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CProcessInfo::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_PID.marshall(rpc_resp, "PID", "", "", "");
	m_Description.marshall(rpc_resp, "Description", "", "", "");
	m_Parameter.marshall(rpc_resp, "Parameter", "", "", "");
}


void CProcessInfo::copy(CProcessInfo &from)
{
	m_PID.copy(from.m_PID);
	m_Description.copy(from.m_Description);
	m_Parameter.copy(from.m_Parameter);
}


void CProcessInfo::copy(IConstProcessInfo &ifrom)
{
	setPID(ifrom.getPID());
	setDescription(ifrom.getDescription());
	setParameter(ifrom.getParameter());
}


void CProcessInfo::getAttributes(IProperties &attributes)
{
}


void CProcessInfo::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_PID.toStr(ctx, buffer, "PID", "", true, "", "");
	m_Description.toStr(ctx, buffer, "Description", "", true, "", "");
	m_Parameter.toStr(ctx, buffer, "Parameter", "", true, "", "");
}


void CProcessInfo::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CProcessInfo::serializer(IEspContext* ctx, IConstProcessInfo &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<ProcessInfo>");
	// field PID
	{
		int n = src.getPID();
		if (n)
			buffer.appendf("<PID>%d</PID>", n);
	}
	// field Description
	{
		const char* s = src.getDescription();
		if (s && *s)
		{
			buffer.append("<Description>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Description>");
		}
	}
	// field Parameter
	{
		const char* s = src.getParameter();
		if (s && *s)
		{
			buffer.append("<Parameter>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Parameter>");
		}
	}
	if (keepRootTag)
		buffer.append("</ProcessInfo>");
}

bool CProcessInfo::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_PID.unmarshall(rpc_request, "PID", basepath);
	hasValue |= m_Description.unmarshall(rpc_request, "Description", basepath);
	hasValue |= m_Parameter.unmarshall(rpc_request, "Parameter", basepath);
	return hasValue;
}

bool CProcessInfo::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_PID.unmarshall(ctx, soapval, "PID");
	hasValue |= m_Description.unmarshall(ctx, soapval, "Description");
	hasValue |= m_Parameter.unmarshall(ctx, soapval, "Parameter");
	return hasValue;
}

bool CProcessInfo::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_PID.unmarshall(ctx, params, attachments, "PID", basepath);
	hasValue |= m_Description.unmarshall(ctx, params, attachments, "Description", basepath);
	hasValue |= m_Parameter.unmarshall(ctx, params, attachments, "Parameter", basepath);
	return hasValue;
}

int CProcessInfo::getPID() { return m_PID;}
const char * CProcessInfo::getDescription() { return m_Description.query();}
const char * CProcessInfo::getParameter() { return m_Parameter.query();}
void CProcessInfo::setPID(int val){ m_PID=val; }
void CProcessInfo::setDescription(const char * val){ m_Description.set(val); }
void CProcessInfo::setParameter(const char * val){ m_Parameter.set(val); }
extern "C"  IEspProcessInfo *createProcessInfo(const char *serv, const char *msgname){return ((IEspProcessInfo *)new CProcessInfo(serv /*, msgname*/));}
extern "C"  IClientProcessInfo *createClientProcessInfo(const char *serv, const char *msgname){return ((IClientProcessInfo *)new CProcessInfo(serv /*, msgname*/));}

//=======================================================
// class CComponentInfo Implementation
//=======================================================

CComponentInfo::CComponentInfo(const char *serviceName, IRpcMessageBinding *init)
	: m_Condition(nilRemove),m_State(nilRemove),m_UpTime(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ComponentInfo");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CComponentInfo::CComponentInfo(const char *serviceName, const char *bc)
	: m_Condition(nilRemove),m_State(nilRemove),m_UpTime(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ComponentInfo");
}

StringBuffer &CComponentInfo::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:complexType name=\"%s\">\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Condition\" type=\"xsd:int\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"State\" type=\"xsd:int\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"UpTime\" type=\"xsd:string\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType>\n");
		}
	}
	return schema;
}

void CComponentInfo::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CComponentInfo::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CComponentInfo::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix) extfix.append(prefix).append(".");
		extfix.append("Condition");
	form.appendf("  <tr><td><b>Condition: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix) extfix.append(prefix).append(".");
		extfix.append("State");
	form.appendf("  <tr><td><b>State: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("UpTime");
	form.appendf("  <tr><td><b>UpTime: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CComponentInfo::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CComponentInfo::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_Condition.marshall(rpc_resp, "Condition", "", "", "");
	m_State.marshall(rpc_resp, "State", "", "", "");
	m_UpTime.marshall(rpc_resp, "UpTime", "", "", "");
}


void CComponentInfo::copy(CComponentInfo &from)
{
	m_Condition.copy(from.m_Condition);
	m_State.copy(from.m_State);
	m_UpTime.copy(from.m_UpTime);
}


void CComponentInfo::copy(IConstComponentInfo &ifrom)
{
	setCondition(ifrom.getCondition());
	setState(ifrom.getState());
	setUpTime(ifrom.getUpTime());
}


void CComponentInfo::getAttributes(IProperties &attributes)
{
}


void CComponentInfo::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_Condition.toStr(ctx, buffer, "Condition", "", true, "", "");
	m_State.toStr(ctx, buffer, "State", "", true, "", "");
	m_UpTime.toStr(ctx, buffer, "UpTime", "", true, "", "");
}


void CComponentInfo::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CComponentInfo::serializer(IEspContext* ctx, IConstComponentInfo &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<ComponentInfo>");
	// field Condition
	{
		int n = src.getCondition();
		if (n)
			buffer.appendf("<Condition>%d</Condition>", n);
	}
	// field State
	{
		int n = src.getState();
		if (n)
			buffer.appendf("<State>%d</State>", n);
	}
	// field UpTime
	{
		const char* s = src.getUpTime();
		if (s && *s)
		{
			buffer.append("<UpTime>");
			encodeUtf8XML(s,buffer);
			buffer.append("</UpTime>");
		}
	}
	if (keepRootTag)
		buffer.append("</ComponentInfo>");
}

bool CComponentInfo::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_Condition.unmarshall(rpc_request, "Condition", basepath);
	hasValue |= m_State.unmarshall(rpc_request, "State", basepath);
	hasValue |= m_UpTime.unmarshall(rpc_request, "UpTime", basepath);
	return hasValue;
}

bool CComponentInfo::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Condition.unmarshall(ctx, soapval, "Condition");
	hasValue |= m_State.unmarshall(ctx, soapval, "State");
	hasValue |= m_UpTime.unmarshall(ctx, soapval, "UpTime");
	return hasValue;
}

bool CComponentInfo::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Condition.unmarshall(ctx, params, attachments, "Condition", basepath);
	hasValue |= m_State.unmarshall(ctx, params, attachments, "State", basepath);
	hasValue |= m_UpTime.unmarshall(ctx, params, attachments, "UpTime", basepath);
	return hasValue;
}

bool CComponentInfo::getCondition_isNull(){return m_Condition.is_nil();}
int CComponentInfo::getCondition() { return m_Condition;}
bool CComponentInfo::getState_isNull(){return m_State.is_nil();}
int CComponentInfo::getState() { return m_State;}
const char * CComponentInfo::getUpTime() { return m_UpTime.query();}
void CComponentInfo::setCondition_null(){ m_Condition.Nil(); }void CComponentInfo::setCondition(int val){ m_Condition=val; }
void CComponentInfo::setState_null(){ m_State.Nil(); }void CComponentInfo::setState(int val){ m_State=val; }
void CComponentInfo::setUpTime(const char * val){ m_UpTime.set(val); }
extern "C"  IEspComponentInfo *createComponentInfo(const char *serv, const char *msgname){return ((IEspComponentInfo *)new CComponentInfo(serv /*, msgname*/));}
extern "C"  IClientComponentInfo *createClientComponentInfo(const char *serv, const char *msgname){return ((IClientComponentInfo *)new CComponentInfo(serv /*, msgname*/));}

//=======================================================
// class CMachineInfoEx Implementation
//=======================================================

CMachineInfoEx::CMachineInfoEx(const char *serviceName, IRpcMessageBinding *init)
	: m_Address(nilIgnore),m_ConfigAddress(nilIgnore),m_Name(nilIgnore),m_ProcessType(nilIgnore),m_DisplayType(nilIgnore),m_Description(nilIgnore),m_AgentVersion(nilIgnore),m_Contact(nilIgnore),m_Location(nilIgnore),m_UpTime(nilIgnore),m_ComponentName(nilIgnore),m_ComponentPath(nilIgnore),m_RoxieState(nilIgnore),m_RoxieStateDetails(nilIgnore),m_OS(nilIgnore),m_ProcessNumber(nilIgnore),m_Processors(nilIgnore),m_Storage(nilIgnore),m_Running(nilIgnore),m_PhysicalMemory(serviceName, nilIgnore),m_VirtualMemory(serviceName, nilIgnore),m_ComponentInfo(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("MachineInfoEx");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CMachineInfoEx::CMachineInfoEx(const char *serviceName, const char *bc)
	: m_Address(nilIgnore),m_ConfigAddress(nilIgnore),m_Name(nilIgnore),m_ProcessType(nilIgnore),m_DisplayType(nilIgnore),m_Description(nilIgnore),m_AgentVersion(nilIgnore),m_Contact(nilIgnore),m_Location(nilIgnore),m_UpTime(nilIgnore),m_ComponentName(nilIgnore),m_ComponentPath(nilIgnore),m_RoxieState(nilIgnore),m_RoxieStateDetails(nilIgnore),m_OS(nilIgnore),m_ProcessNumber(nilIgnore),m_Processors(nilIgnore),m_Storage(nilIgnore),m_Running(nilIgnore),m_PhysicalMemory(serviceName, nilIgnore),m_VirtualMemory(serviceName, nilIgnore),m_ComponentInfo(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("MachineInfoEx");
}

StringBuffer &CMachineInfoEx::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:complexType name=\"%s\">\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Address\" type=\"xsd:string\"/>\n");
		if (!context.suppressed("MachineInfoEx","ConfigAddress")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"ConfigAddress\" type=\"xsd:string\"/>\n");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Name\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"ProcessType\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"DisplayType\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Description\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"AgentVersion\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Contact\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Location\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"UpTime\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"ComponentName\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"ComponentPath\" type=\"xsd:string\"/>\n");
		if (!context.suppressed("MachineInfoEx","RoxieState")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"RoxieState\" type=\"xsd:string\"/>\n");
		}
		if (!context.suppressed("MachineInfoEx","RoxieStateDetails")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"RoxieStateDetails\" type=\"xsd:string\"/>\n");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"OS\" type=\"xsd:int\"/>\n");
		if (!context.suppressed("MachineInfoEx","ProcessNumber")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"ProcessNumber\" type=\"xsd:int\"/>\n");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Processors\" type=\"tns:ArrayOfProcessorInfo\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Storage\" type=\"tns:ArrayOfStorageInfo\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Running\" type=\"tns:ArrayOfSWRunInfo\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"PhysicalMemory\" type=\"tns:StorageInfo\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"VirtualMemory\" type=\"tns:StorageInfo\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"ComponentInfo\" type=\"tns:ComponentInfo\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType>\n");
		}
	}
	if (!(flags & 0x10)  || (flags & 0x100))
	{
		CProcessorInfo::getXsdDefinition(context, request, schema, added);
		CStorageInfo::getXsdDefinition(context, request, schema, added);
		CSWRunInfo::getXsdDefinition(context, request, schema, added);
		CComponentInfo::getXsdDefinition(context, request, schema, added);
	}
	if (added.getValue("ProcessorInfo") && added.getValue("ArrayOfProcessorInfo")==NULL) {
		schema.append("<xsd:complexType name=\"ArrayOfProcessorInfo\">\n");
		schema.append("<xsd:sequence>\n");
		schema.append("<xsd:element minOccurs=\"0\" maxOccurs=\"unbounded\" name=\"ProcessorInfo\" type=\"tns:ProcessorInfo\"/>\n");
		schema.append("</xsd:sequence>\n");
		schema.append("</xsd:complexType>\n");
		added.setValue("ArrayOfProcessorInfo",1);
	}
	if (added.getValue("SWRunInfo") && added.getValue("ArrayOfSWRunInfo")==NULL) {
		schema.append("<xsd:complexType name=\"ArrayOfSWRunInfo\">\n");
		schema.append("<xsd:sequence>\n");
		schema.append("<xsd:element minOccurs=\"0\" maxOccurs=\"unbounded\" name=\"SWRunInfo\" type=\"tns:SWRunInfo\"/>\n");
		schema.append("</xsd:sequence>\n");
		schema.append("</xsd:complexType>\n");
		added.setValue("ArrayOfSWRunInfo",1);
	}
	if (added.getValue("StorageInfo") && added.getValue("ArrayOfStorageInfo")==NULL) {
		schema.append("<xsd:complexType name=\"ArrayOfStorageInfo\">\n");
		schema.append("<xsd:sequence>\n");
		schema.append("<xsd:element minOccurs=\"0\" maxOccurs=\"unbounded\" name=\"StorageInfo\" type=\"tns:StorageInfo\"/>\n");
		schema.append("</xsd:sequence>\n");
		schema.append("</xsd:complexType>\n");
		added.setValue("ArrayOfStorageInfo",1);
	}
	return schema;
}

void CMachineInfoEx::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CMachineInfoEx::getMapInfo(IMapInfo& info, BoolHash& added)
{
	info.addMinVersion("MachineInfoEx","ConfigAddress",1.04);
	info.addMinVersion("MachineInfoEx","RoxieState",1.13);
	info.addMinVersion("MachineInfoEx","RoxieStateDetails",1.13);
	info.addMinVersion("MachineInfoEx","ProcessNumber",1.1);
	if (!added.getValue("ComponentInfo"))
	{
		added.setValue("ComponentInfo",1);
		CComponentInfo::getMapInfo(info,added);
	}
	if (!added.getValue("ProcessorInfo"))
	{
		added.setValue("ProcessorInfo",1);
		CProcessorInfo::getMapInfo(info,added);
	}
	if (!added.getValue("SWRunInfo"))
	{
		added.setValue("SWRunInfo",1);
		CSWRunInfo::getMapInfo(info,added);
	}
	if (!added.getValue("StorageInfo"))
	{
		added.setValue("StorageInfo",1);
		CStorageInfo::getMapInfo(info,added);
	}
}

StringBuffer &CMachineInfoEx::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Address");
	form.appendf("  <tr><td><b>Address: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (!context.suppressed("MachineInfoEx","ConfigAddress")) {
		extfix.clear();
		if (prefix && *prefix)
			extfix.append(prefix).append(".");
		extfix.append("ConfigAddress");
		form.appendf("  <tr><td><b>ConfigAddress: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
		form.append("</td></tr>\n");
	}
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Name");
	form.appendf("  <tr><td><b>Name: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("ProcessType");
	form.appendf("  <tr><td><b>ProcessType: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("DisplayType");
	form.appendf("  <tr><td><b>DisplayType: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Description");
	form.appendf("  <tr><td><b>Description: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("AgentVersion");
	form.appendf("  <tr><td><b>AgentVersion: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Contact");
	form.appendf("  <tr><td><b>Contact: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Location");
	form.appendf("  <tr><td><b>Location: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("UpTime");
	form.appendf("  <tr><td><b>UpTime: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("ComponentName");
	form.appendf("  <tr><td><b>ComponentName: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("ComponentPath");
	form.appendf("  <tr><td><b>ComponentPath: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (!context.suppressed("MachineInfoEx","RoxieState")) {
		extfix.clear();
		if (prefix && *prefix)
			extfix.append(prefix).append(".");
		extfix.append("RoxieState");
		form.appendf("  <tr><td><b>RoxieState: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
		form.append("</td></tr>\n");
	}
	if (!context.suppressed("MachineInfoEx","RoxieStateDetails")) {
		extfix.clear();
		if (prefix && *prefix)
			extfix.append(prefix).append(".");
		extfix.append("RoxieStateDetails");
		form.appendf("  <tr><td><b>RoxieStateDetails: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
		form.append("</td></tr>\n");
	}
	extfix.clear();
	if (prefix && *prefix) extfix.append(prefix).append(".");
		extfix.append("OS");
	form.appendf("  <tr><td><b>OS: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
	form.append("</td></tr>\n");
	if (!context.suppressed("MachineInfoEx","ProcessNumber")) {
		extfix.clear();
		if (prefix && *prefix) extfix.append(prefix).append(".");
			extfix.append("ProcessNumber");
		form.appendf("  <tr><td><b>ProcessNumber: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
		form.append("</td></tr>\n");
	}
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Processors");
	form.appendf("<tr><td><b>Processors: </b></td><td>");
	form.appendf("<table><tr><td><textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea></td>", extfix.str());
	form.append("</tr></table>");
	form.append("</td></tr>");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Storage");
	form.appendf("<tr><td><b>Storage: </b></td><td>");
	form.appendf("<table><tr><td><textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea></td>", extfix.str());
	form.append("</tr></table>");
	form.append("</td></tr>");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Running");
	form.appendf("<tr><td><b>Running: </b></td><td>");
	form.appendf("<table><tr><td><textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea></td>", extfix.str());
	form.append("</tr></table>");
	form.append("</td></tr>");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("PhysicalMemory");
	form.append("<tr>").append("<td><b>PhysicalMemory: </b></td><td><hr/>");
	CStorageInfo::getHtmlForm(context, request, serv, method, form, false, extfix.str());
	form.append("<hr/></td></tr>");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("VirtualMemory");
	form.append("<tr>").append("<td><b>VirtualMemory: </b></td><td><hr/>");
	CStorageInfo::getHtmlForm(context, request, serv, method, form, false, extfix.str());
	form.append("<hr/></td></tr>");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("ComponentInfo");
	form.append("<tr>").append("<td><b>ComponentInfo: </b></td><td><hr/>");
	CComponentInfo::getHtmlForm(context, request, serv, method, form, false, extfix.str());
	form.append("<hr/></td></tr>");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CMachineInfoEx::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CMachineInfoEx::serialize(IRpcMessage& rpc_resp)
{
	IEspContext* ctx = rpc_resp.queryContext();
	double clientVer= ctx ? ctx->getClientVersion() : -1; /* no context gets everything */
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_Address.marshall(rpc_resp, "Address", "", "", "");
	if ((clientVer==-1.0 || clientVer>=1.04))
		m_ConfigAddress.marshall(rpc_resp, "ConfigAddress", "", "", "");
	m_Name.marshall(rpc_resp, "Name", "", "", "");
	m_ProcessType.marshall(rpc_resp, "ProcessType", "", "", "");
	m_DisplayType.marshall(rpc_resp, "DisplayType", "", "", "");
	m_Description.marshall(rpc_resp, "Description", "", "", "");
	m_AgentVersion.marshall(rpc_resp, "AgentVersion", "", "", "");
	m_Contact.marshall(rpc_resp, "Contact", "", "", "");
	m_Location.marshall(rpc_resp, "Location", "", "", "");
	m_UpTime.marshall(rpc_resp, "UpTime", "", "", "");
	m_ComponentName.marshall(rpc_resp, "ComponentName", "", "", "");
	m_ComponentPath.marshall(rpc_resp, "ComponentPath", "", "", "");
	if ((clientVer==-1.0 || clientVer>=1.13))
		m_RoxieState.marshall(rpc_resp, "RoxieState", "", "", "");
	if ((clientVer==-1.0 || clientVer>=1.13))
		m_RoxieStateDetails.marshall(rpc_resp, "RoxieStateDetails", "", "", "");
	m_OS.marshall(rpc_resp, "OS", "", "", "");
	if ((clientVer==-1.0 || clientVer>=1.1))
		m_ProcessNumber.marshall(rpc_resp, "ProcessNumber", "", "", "");
	m_Processors.marshall(rpc_resp, "Processors", "ProcessorInfo");
	m_Storage.marshall(rpc_resp, "Storage", "StorageInfo");
	m_Running.marshall(rpc_resp, "Running", "SWRunInfo");
	m_PhysicalMemory.marshall(rpc_resp, "PhysicalMemory", "", "", "");
	m_VirtualMemory.marshall(rpc_resp, "VirtualMemory", "", "", "");
	m_ComponentInfo.marshall(rpc_resp, "ComponentInfo", "", "", "");
}


void CMachineInfoEx::copy(CMachineInfoEx &from)
{
	m_Address.copy(from.m_Address);
	m_ConfigAddress.copy(from.m_ConfigAddress);
	m_Name.copy(from.m_Name);
	m_ProcessType.copy(from.m_ProcessType);
	m_DisplayType.copy(from.m_DisplayType);
	m_Description.copy(from.m_Description);
	m_AgentVersion.copy(from.m_AgentVersion);
	m_Contact.copy(from.m_Contact);
	m_Location.copy(from.m_Location);
	m_UpTime.copy(from.m_UpTime);
	m_ComponentName.copy(from.m_ComponentName);
	m_ComponentPath.copy(from.m_ComponentPath);
	m_RoxieState.copy(from.m_RoxieState);
	m_RoxieStateDetails.copy(from.m_RoxieStateDetails);
	m_OS.copy(from.m_OS);
	m_ProcessNumber.copy(from.m_ProcessNumber);
	m_Processors.copy(from.m_Processors);
	m_Storage.copy(from.m_Storage);
	m_Running.copy(from.m_Running);
	m_PhysicalMemory.copy(from.m_PhysicalMemory);
	m_VirtualMemory.copy(from.m_VirtualMemory);
	m_ComponentInfo.copy(from.m_ComponentInfo);
}


void CMachineInfoEx::copy(IConstMachineInfoEx &ifrom)
{
	setAddress(ifrom.getAddress());
	setConfigAddress(ifrom.getConfigAddress());
	setName(ifrom.getName());
	setProcessType(ifrom.getProcessType());
	setDisplayType(ifrom.getDisplayType());
	setDescription(ifrom.getDescription());
	setAgentVersion(ifrom.getAgentVersion());
	setContact(ifrom.getContact());
	setLocation(ifrom.getLocation());
	setUpTime(ifrom.getUpTime());
	setComponentName(ifrom.getComponentName());
	setComponentPath(ifrom.getComponentPath());
	setRoxieState(ifrom.getRoxieState());
	setRoxieStateDetails(ifrom.getRoxieStateDetails());
	setOS(ifrom.getOS());
	setProcessNumber(ifrom.getProcessNumber());
	setProcessors(ifrom.getProcessors());
	setStorage(ifrom.getStorage());
	setRunning(ifrom.getRunning());
	setPhysicalMemory(ifrom.getPhysicalMemory());
	setVirtualMemory(ifrom.getVirtualMemory());
	setComponentInfo(ifrom.getComponentInfo());
}


void CMachineInfoEx::getAttributes(IProperties &attributes)
{
}


void CMachineInfoEx::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	double clientVer = ctx ? ctx->getClientVersion() : -1;
	m_Address.toStr(ctx, buffer, "Address", "", true, "", "");
	if ((clientVer==-1.0 || clientVer>=1.04))
		m_ConfigAddress.toStr(ctx, buffer, "ConfigAddress", "", true, "", "");
	m_Name.toStr(ctx, buffer, "Name", "", true, "", "");
	m_ProcessType.toStr(ctx, buffer, "ProcessType", "", true, "", "");
	m_DisplayType.toStr(ctx, buffer, "DisplayType", "", true, "", "");
	m_Description.toStr(ctx, buffer, "Description", "", true, "", "");
	m_AgentVersion.toStr(ctx, buffer, "AgentVersion", "", true, "", "");
	m_Contact.toStr(ctx, buffer, "Contact", "", true, "", "");
	m_Location.toStr(ctx, buffer, "Location", "", true, "", "");
	m_UpTime.toStr(ctx, buffer, "UpTime", "", true, "", "");
	m_ComponentName.toStr(ctx, buffer, "ComponentName", "", true, "", "");
	m_ComponentPath.toStr(ctx, buffer, "ComponentPath", "", true, "", "");
	if ((clientVer==-1.0 || clientVer>=1.13))
		m_RoxieState.toStr(ctx, buffer, "RoxieState", "", true, "", "");
	if ((clientVer==-1.0 || clientVer>=1.13))
		m_RoxieStateDetails.toStr(ctx, buffer, "RoxieStateDetails", "", true, "", "");
	m_OS.toStr(ctx, buffer, "OS", "", true, "", "");
	if ((clientVer==-1.0 || clientVer>=1.1))
		m_ProcessNumber.toStr(ctx, buffer, "ProcessNumber", "", true, "", "");
	m_Processors.toStr(ctx, buffer, "Processors", "ProcessorInfo");
	m_Storage.toStr(ctx, buffer, "Storage", "StorageInfo");
	m_Running.toStr(ctx, buffer, "Running", "SWRunInfo");
	m_PhysicalMemory.toStr(ctx, buffer, "PhysicalMemory", "", false, "", "");
	m_VirtualMemory.toStr(ctx, buffer, "VirtualMemory", "", false, "", "");
	m_ComponentInfo.toStr(ctx, buffer, "ComponentInfo", "", false, "", "");
}


void CMachineInfoEx::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CMachineInfoEx::serializer(IEspContext* ctx, IConstMachineInfoEx &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<MachineInfoEx>");
	double clientVer = ctx ? ctx->getClientVersion() : -1;
	// field Address
	{
		const char* s = src.getAddress();
		if (s && *s)
		{
			buffer.append("<Address>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Address>");
		}
	}
	// field ConfigAddress
	if ((clientVer==-1.0 || clientVer>=1.04))
	{
		const char* s = src.getConfigAddress();
		if (s && *s)
		{
			buffer.append("<ConfigAddress>");
			encodeUtf8XML(s,buffer);
			buffer.append("</ConfigAddress>");
		}
	}
	// field Name
	{
		const char* s = src.getName();
		if (s && *s)
		{
			buffer.append("<Name>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Name>");
		}
	}
	// field ProcessType
	{
		const char* s = src.getProcessType();
		if (s && *s)
		{
			buffer.append("<ProcessType>");
			encodeUtf8XML(s,buffer);
			buffer.append("</ProcessType>");
		}
	}
	// field DisplayType
	{
		const char* s = src.getDisplayType();
		if (s && *s)
		{
			buffer.append("<DisplayType>");
			encodeUtf8XML(s,buffer);
			buffer.append("</DisplayType>");
		}
	}
	// field Description
	{
		const char* s = src.getDescription();
		if (s && *s)
		{
			buffer.append("<Description>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Description>");
		}
	}
	// field AgentVersion
	{
		const char* s = src.getAgentVersion();
		if (s && *s)
		{
			buffer.append("<AgentVersion>");
			encodeUtf8XML(s,buffer);
			buffer.append("</AgentVersion>");
		}
	}
	// field Contact
	{
		const char* s = src.getContact();
		if (s && *s)
		{
			buffer.append("<Contact>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Contact>");
		}
	}
	// field Location
	{
		const char* s = src.getLocation();
		if (s && *s)
		{
			buffer.append("<Location>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Location>");
		}
	}
	// field UpTime
	{
		const char* s = src.getUpTime();
		if (s && *s)
		{
			buffer.append("<UpTime>");
			encodeUtf8XML(s,buffer);
			buffer.append("</UpTime>");
		}
	}
	// field ComponentName
	{
		const char* s = src.getComponentName();
		if (s && *s)
		{
			buffer.append("<ComponentName>");
			encodeUtf8XML(s,buffer);
			buffer.append("</ComponentName>");
		}
	}
	// field ComponentPath
	{
		const char* s = src.getComponentPath();
		if (s && *s)
		{
			buffer.append("<ComponentPath>");
			encodeUtf8XML(s,buffer);
			buffer.append("</ComponentPath>");
		}
	}
	// field RoxieState
	if ((clientVer==-1.0 || clientVer>=1.13))
	{
		const char* s = src.getRoxieState();
		if (s && *s)
		{
			buffer.append("<RoxieState>");
			encodeUtf8XML(s,buffer);
			buffer.append("</RoxieState>");
		}
	}
	// field RoxieStateDetails
	if ((clientVer==-1.0 || clientVer>=1.13))
	{
		const char* s = src.getRoxieStateDetails();
		if (s && *s)
		{
			buffer.append("<RoxieStateDetails>");
			encodeUtf8XML(s,buffer);
			buffer.append("</RoxieStateDetails>");
		}
	}
	// field OS
	{
		int n = src.getOS();
		if (n)
			buffer.appendf("<OS>%d</OS>", n);
	}
	// field ProcessNumber
	if ((clientVer==-1.0 || clientVer>=1.1))
	{
		int n = src.getProcessNumber();
		if (n)
			buffer.appendf("<ProcessNumber>%d</ProcessNumber>", n);
	}
	// field Processors
	{
		IArrayOf<IConstProcessorInfo>& v = src.getProcessors();
		int size = v.length();
		if (size>0)
			buffer.append("<Processors>");
		for (int i=0;i<size;i++)
		{
			buffer.append("<Item>");
			CProcessorInfo::serializer(ctx,v.item(i),buffer,false);
			buffer.append("</Item>");
		}
		if (size>0)
			buffer.append("</Processors>");
	}
	// field Storage
	{
		IArrayOf<IConstStorageInfo>& v = src.getStorage();
		int size = v.length();
		if (size>0)
			buffer.append("<Storage>");
		for (int i=0;i<size;i++)
		{
			buffer.append("<Item>");
			CStorageInfo::serializer(ctx,v.item(i),buffer,false);
			buffer.append("</Item>");
		}
		if (size>0)
			buffer.append("</Storage>");
	}
	// field Running
	{
		IArrayOf<IConstSWRunInfo>& v = src.getRunning();
		int size = v.length();
		if (size>0)
			buffer.append("<Running>");
		for (int i=0;i<size;i++)
		{
			buffer.append("<Item>");
			CSWRunInfo::serializer(ctx,v.item(i),buffer,false);
			buffer.append("</Item>");
		}
		if (size>0)
			buffer.append("</Running>");
	}
	// field PhysicalMemory
	{
		StringBuffer tmp;
		CStorageInfo::serializer(ctx,src.getPhysicalMemory(), tmp, false);
		if (tmp.length()>0)
			buffer.appendf("<PhysicalMemory>%s</PhysicalMemory>",tmp.str());
	}
	// field VirtualMemory
	{
		StringBuffer tmp;
		CStorageInfo::serializer(ctx,src.getVirtualMemory(), tmp, false);
		if (tmp.length()>0)
			buffer.appendf("<VirtualMemory>%s</VirtualMemory>",tmp.str());
	}
	// field ComponentInfo
	{
		StringBuffer tmp;
		CComponentInfo::serializer(ctx,src.getComponentInfo(), tmp, false);
		if (tmp.length()>0)
			buffer.appendf("<ComponentInfo>%s</ComponentInfo>",tmp.str());
	}
	if (keepRootTag)
		buffer.append("</MachineInfoEx>");
}

bool CMachineInfoEx::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_Address.unmarshall(rpc_request, "Address", basepath);
	hasValue |= m_ConfigAddress.unmarshall(rpc_request, "ConfigAddress", basepath);
	hasValue |= m_Name.unmarshall(rpc_request, "Name", basepath);
	hasValue |= m_ProcessType.unmarshall(rpc_request, "ProcessType", basepath);
	hasValue |= m_DisplayType.unmarshall(rpc_request, "DisplayType", basepath);
	hasValue |= m_Description.unmarshall(rpc_request, "Description", basepath);
	hasValue |= m_AgentVersion.unmarshall(rpc_request, "AgentVersion", basepath);
	hasValue |= m_Contact.unmarshall(rpc_request, "Contact", basepath);
	hasValue |= m_Location.unmarshall(rpc_request, "Location", basepath);
	hasValue |= m_UpTime.unmarshall(rpc_request, "UpTime", basepath);
	hasValue |= m_ComponentName.unmarshall(rpc_request, "ComponentName", basepath);
	hasValue |= m_ComponentPath.unmarshall(rpc_request, "ComponentPath", basepath);
	hasValue |= m_RoxieState.unmarshall(rpc_request, "RoxieState", basepath);
	hasValue |= m_RoxieStateDetails.unmarshall(rpc_request, "RoxieStateDetails", basepath);
	hasValue |= m_OS.unmarshall(rpc_request, "OS", basepath);
	hasValue |= m_ProcessNumber.unmarshall(rpc_request, "ProcessNumber", basepath);
	hasValue |= m_Processors.unmarshall(rpc_request, "Processors", basepath);
	hasValue |= m_Storage.unmarshall(rpc_request, "Storage", basepath);
	hasValue |= m_Running.unmarshall(rpc_request, "Running", basepath);
	hasValue |= m_PhysicalMemory.unmarshall(rpc_request, "PhysicalMemory", basepath);
	hasValue |= m_VirtualMemory.unmarshall(rpc_request, "VirtualMemory", basepath);
	hasValue |= m_ComponentInfo.unmarshall(rpc_request, "ComponentInfo", basepath);
	return hasValue;
}

bool CMachineInfoEx::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Address.unmarshall(ctx, soapval, "Address");
	hasValue |= m_ConfigAddress.unmarshall(ctx, soapval, "ConfigAddress");
	hasValue |= m_Name.unmarshall(ctx, soapval, "Name");
	hasValue |= m_ProcessType.unmarshall(ctx, soapval, "ProcessType");
	hasValue |= m_DisplayType.unmarshall(ctx, soapval, "DisplayType");
	hasValue |= m_Description.unmarshall(ctx, soapval, "Description");
	hasValue |= m_AgentVersion.unmarshall(ctx, soapval, "AgentVersion");
	hasValue |= m_Contact.unmarshall(ctx, soapval, "Contact");
	hasValue |= m_Location.unmarshall(ctx, soapval, "Location");
	hasValue |= m_UpTime.unmarshall(ctx, soapval, "UpTime");
	hasValue |= m_ComponentName.unmarshall(ctx, soapval, "ComponentName");
	hasValue |= m_ComponentPath.unmarshall(ctx, soapval, "ComponentPath");
	hasValue |= m_RoxieState.unmarshall(ctx, soapval, "RoxieState");
	hasValue |= m_RoxieStateDetails.unmarshall(ctx, soapval, "RoxieStateDetails");
	hasValue |= m_OS.unmarshall(ctx, soapval, "OS");
	hasValue |= m_ProcessNumber.unmarshall(ctx, soapval, "ProcessNumber");
	hasValue |= m_Processors.unmarshall(ctx, soapval, "Processors");
	hasValue |= m_Storage.unmarshall(ctx, soapval, "Storage");
	hasValue |= m_Running.unmarshall(ctx, soapval, "Running");
	hasValue |= m_PhysicalMemory.unmarshall(ctx, soapval, "PhysicalMemory");
	hasValue |= m_VirtualMemory.unmarshall(ctx, soapval, "VirtualMemory");
	hasValue |= m_ComponentInfo.unmarshall(ctx, soapval, "ComponentInfo");
	return hasValue;
}

bool CMachineInfoEx::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Address.unmarshall(ctx, params, attachments, "Address", basepath);
	hasValue |= m_ConfigAddress.unmarshall(ctx, params, attachments, "ConfigAddress", basepath);
	hasValue |= m_Name.unmarshall(ctx, params, attachments, "Name", basepath);
	hasValue |= m_ProcessType.unmarshall(ctx, params, attachments, "ProcessType", basepath);
	hasValue |= m_DisplayType.unmarshall(ctx, params, attachments, "DisplayType", basepath);
	hasValue |= m_Description.unmarshall(ctx, params, attachments, "Description", basepath);
	hasValue |= m_AgentVersion.unmarshall(ctx, params, attachments, "AgentVersion", basepath);
	hasValue |= m_Contact.unmarshall(ctx, params, attachments, "Contact", basepath);
	hasValue |= m_Location.unmarshall(ctx, params, attachments, "Location", basepath);
	hasValue |= m_UpTime.unmarshall(ctx, params, attachments, "UpTime", basepath);
	hasValue |= m_ComponentName.unmarshall(ctx, params, attachments, "ComponentName", basepath);
	hasValue |= m_ComponentPath.unmarshall(ctx, params, attachments, "ComponentPath", basepath);
	hasValue |= m_RoxieState.unmarshall(ctx, params, attachments, "RoxieState", basepath);
	hasValue |= m_RoxieStateDetails.unmarshall(ctx, params, attachments, "RoxieStateDetails", basepath);
	hasValue |= m_OS.unmarshall(ctx, params, attachments, "OS", basepath);
	hasValue |= m_ProcessNumber.unmarshall(ctx, params, attachments, "ProcessNumber", basepath);
	hasValue |= m_Processors.unmarshall(ctx, params, attachments, "Processors", basepath);
	hasValue |= m_Storage.unmarshall(ctx, params, attachments, "Storage", basepath);
	hasValue |= m_Running.unmarshall(ctx, params, attachments, "Running", basepath);
	hasValue |= m_PhysicalMemory.unmarshall(ctx, params, attachments, "PhysicalMemory", basepath);
	hasValue |= m_VirtualMemory.unmarshall(ctx, params, attachments, "VirtualMemory", basepath);
	hasValue |= m_ComponentInfo.unmarshall(ctx, params, attachments, "ComponentInfo", basepath);
	return hasValue;
}

const char * CMachineInfoEx::getAddress() { return m_Address.query();}
const char * CMachineInfoEx::getConfigAddress() { return m_ConfigAddress.query();}
const char * CMachineInfoEx::getName() { return m_Name.query();}
const char * CMachineInfoEx::getProcessType() { return m_ProcessType.query();}
const char * CMachineInfoEx::getDisplayType() { return m_DisplayType.query();}
const char * CMachineInfoEx::getDescription() { return m_Description.query();}
const char * CMachineInfoEx::getAgentVersion() { return m_AgentVersion.query();}
const char * CMachineInfoEx::getContact() { return m_Contact.query();}
const char * CMachineInfoEx::getLocation() { return m_Location.query();}
const char * CMachineInfoEx::getUpTime() { return m_UpTime.query();}
const char * CMachineInfoEx::getComponentName() { return m_ComponentName.query();}
const char * CMachineInfoEx::getComponentPath() { return m_ComponentPath.query();}
const char * CMachineInfoEx::getRoxieState() { return m_RoxieState.query();}
const char * CMachineInfoEx::getRoxieStateDetails() { return m_RoxieStateDetails.query();}
int CMachineInfoEx::getOS() { return m_OS;}
int CMachineInfoEx::getProcessNumber() { return m_ProcessNumber;}
IArrayOf<IConstProcessorInfo> & CMachineInfoEx::getProcessors() { return (IArrayOf<IConstProcessorInfo> &) m_Processors; }
IArrayOf<IConstStorageInfo> & CMachineInfoEx::getStorage() { return (IArrayOf<IConstStorageInfo> &) m_Storage; }
IArrayOf<IConstSWRunInfo> & CMachineInfoEx::getRunning() { return (IArrayOf<IConstSWRunInfo> &) m_Running; }
IConstStorageInfo & CMachineInfoEx::getPhysicalMemory() { return (IConstStorageInfo &) m_PhysicalMemory.getValue();}
IConstStorageInfo & CMachineInfoEx::getVirtualMemory() { return (IConstStorageInfo &) m_VirtualMemory.getValue();}
IConstComponentInfo & CMachineInfoEx::getComponentInfo() { return (IConstComponentInfo &) m_ComponentInfo.getValue();}
void CMachineInfoEx::setAddress(const char * val){ m_Address.set(val); }
void CMachineInfoEx::setConfigAddress(const char * val){ m_ConfigAddress.set(val); }
void CMachineInfoEx::setName(const char * val){ m_Name.set(val); }
void CMachineInfoEx::setProcessType(const char * val){ m_ProcessType.set(val); }
void CMachineInfoEx::setDisplayType(const char * val){ m_DisplayType.set(val); }
void CMachineInfoEx::setDescription(const char * val){ m_Description.set(val); }
void CMachineInfoEx::setAgentVersion(const char * val){ m_AgentVersion.set(val); }
void CMachineInfoEx::setContact(const char * val){ m_Contact.set(val); }
void CMachineInfoEx::setLocation(const char * val){ m_Location.set(val); }
void CMachineInfoEx::setUpTime(const char * val){ m_UpTime.set(val); }
void CMachineInfoEx::setComponentName(const char * val){ m_ComponentName.set(val); }
void CMachineInfoEx::setComponentPath(const char * val){ m_ComponentPath.set(val); }
void CMachineInfoEx::setRoxieState(const char * val){ m_RoxieState.set(val); }
void CMachineInfoEx::setRoxieStateDetails(const char * val){ m_RoxieStateDetails.set(val); }
void CMachineInfoEx::setOS(int val){ m_OS=val; }
void CMachineInfoEx::setProcessNumber(int val){ m_ProcessNumber=val; }
void CMachineInfoEx::setProcessors(IArrayOf<IEspProcessorInfo> &val)
{
	m_Processors->kill();
	IArrayOf<IConstProcessorInfo> &target = m_Processors.getValue();
	ForEachItemIn(idx, val)
	{
		IEspProcessorInfo &item = (val).item(idx);
		item.Link();
		target.append(item);
	}
}
void CMachineInfoEx::setProcessors(IArrayOf<IConstProcessorInfo> &val)
{
	m_Processors->kill();
	IArrayOf<IConstProcessorInfo> &target = m_Processors.getValue();
	ForEachItemIn(idx, val)
	{
		IConstProcessorInfo &item = val.item(idx);
		item.Link();
		target.append(item);
	}
}
void CMachineInfoEx::setStorage(IArrayOf<IEspStorageInfo> &val)
{
	m_Storage->kill();
	IArrayOf<IConstStorageInfo> &target = m_Storage.getValue();
	ForEachItemIn(idx, val)
	{
		IEspStorageInfo &item = (val).item(idx);
		item.Link();
		target.append(item);
	}
}
void CMachineInfoEx::setStorage(IArrayOf<IConstStorageInfo> &val)
{
	m_Storage->kill();
	IArrayOf<IConstStorageInfo> &target = m_Storage.getValue();
	ForEachItemIn(idx, val)
	{
		IConstStorageInfo &item = val.item(idx);
		item.Link();
		target.append(item);
	}
}
void CMachineInfoEx::setRunning(IArrayOf<IEspSWRunInfo> &val)
{
	m_Running->kill();
	IArrayOf<IConstSWRunInfo> &target = m_Running.getValue();
	ForEachItemIn(idx, val)
	{
		IEspSWRunInfo &item = (val).item(idx);
		item.Link();
		target.append(item);
	}
}
void CMachineInfoEx::setRunning(IArrayOf<IConstSWRunInfo> &val)
{
	m_Running->kill();
	IArrayOf<IConstSWRunInfo> &target = m_Running.getValue();
	ForEachItemIn(idx, val)
	{
		IConstSWRunInfo &item = val.item(idx);
		item.Link();
		target.append(item);
	}
}
IEspStorageInfo & CMachineInfoEx::updatePhysicalMemory(){ return (IEspStorageInfo &) m_PhysicalMemory.getValue(); }
void CMachineInfoEx::setPhysicalMemory(IConstStorageInfo &ifrom){ m_PhysicalMemory.copy(ifrom); }
IEspStorageInfo & CMachineInfoEx::updateVirtualMemory(){ return (IEspStorageInfo &) m_VirtualMemory.getValue(); }
void CMachineInfoEx::setVirtualMemory(IConstStorageInfo &ifrom){ m_VirtualMemory.copy(ifrom); }
IEspComponentInfo & CMachineInfoEx::updateComponentInfo(){ return (IEspComponentInfo &) m_ComponentInfo.getValue(); }
void CMachineInfoEx::setComponentInfo(IConstComponentInfo &ifrom){ m_ComponentInfo.copy(ifrom); }
extern "C"  IEspMachineInfoEx *createMachineInfoEx(const char *serv, const char *msgname){return ((IEspMachineInfoEx *)new CMachineInfoEx(serv /*, msgname*/));}
extern "C"  IClientMachineInfoEx *createClientMachineInfoEx(const char *serv, const char *msgname){return ((IClientMachineInfoEx *)new CMachineInfoEx(serv /*, msgname*/));}

//=======================================================
// class CGetMachineInfoResponse Implementation
//=======================================================

CGetMachineInfoResponse::CGetMachineInfoResponse(const char *serviceName, IRpcMessageBinding *init)
	: m_RequestInfo(serviceName, nilIgnore),m_Columns(nilIgnore),m_Machines(nilIgnore),m_TimeStamp(nilIgnore),m_UserName(nilIgnore),m_Password(nilIgnore),m_AcceptLanguage(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetMachineInfoResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CGetMachineInfoResponse::CGetMachineInfoResponse(const char *serviceName, const char *bc)
	: m_RequestInfo(serviceName, nilIgnore),m_Columns(nilIgnore),m_Machines(nilIgnore),m_TimeStamp(nilIgnore),m_UserName(nilIgnore),m_Password(nilIgnore),m_AcceptLanguage(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetMachineInfoResponse");
}

CGetMachineInfoResponse::CGetMachineInfoResponse(const char *serviceName, IRpcMessage* rpcmsg)
	: m_RequestInfo(serviceName, nilIgnore),m_Columns(nilIgnore),m_Machines(nilIgnore),m_TimeStamp(nilIgnore),m_UserName(nilIgnore),m_Password(nilIgnore),m_AcceptLanguage(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetMachineInfoResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CGetMachineInfoResponse::CGetMachineInfoResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_RequestInfo(serviceName, nilIgnore),m_Columns(nilIgnore),m_Machines(nilIgnore),m_TimeStamp(nilIgnore),m_UserName(nilIgnore),m_Password(nilIgnore),m_AcceptLanguage(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetMachineInfoResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CGetMachineInfoResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		schema.append("<xsd:element name=\"Exceptions\" type=\"tns:ArrayOfEspException\" minOccurs=\"0\" maxOccurs=\"1\"/>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"RequestInfo\" type=\"tns:RequestInfoStruct\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Columns\" type=\"tns:EspStringArray\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Machines\" type=\"tns:ArrayOfMachineInfoEx\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"TimeStamp\" type=\"xsd:string\"/>\n");
		if (!context.suppressed("GetMachineInfoResponse","UserName")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"UserName\" type=\"xsd:string\"/>\n");
		}
		if (!context.suppressed("GetMachineInfoResponse","Password")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"Password\" type=\"xsd:string\"");
			if (context.queryOptions()&ESPCTX_ALL_ANNOTATION)
				schema.append("> <xsd:annotation><xsd:appinfo><form formType=\"password\" formCols=\"20\"/></xsd:appinfo></xsd:annotation></xsd:element>\n");
			else
				schema.append("/>\n");
		}
		if (!context.suppressed("GetMachineInfoResponse","AcceptLanguage")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"AcceptLanguage\" type=\"xsd:string\"/>\n");
		}
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	if (!(flags & 0x10)  || (flags & 0x100))
	{
		CRequestInfoStruct::getXsdDefinition(context, request, schema, added);
		CMachineInfoEx::getXsdDefinition(context, request, schema, added);
	}
	if (added.getValue("EspStringArray")==NULL) {
		addEspNativeArray(schema,"string","EspStringArray");
		added.setValue("EspStringArray",1);
	}
	if (added.getValue("MachineInfoEx") && added.getValue("ArrayOfMachineInfoEx")==NULL) {
		schema.append("<xsd:complexType name=\"ArrayOfMachineInfoEx\">\n");
		schema.append("<xsd:sequence>\n");
		schema.append("<xsd:element minOccurs=\"0\" maxOccurs=\"unbounded\" name=\"MachineInfoEx\" type=\"tns:MachineInfoEx\"/>\n");
		schema.append("</xsd:sequence>\n");
		schema.append("</xsd:complexType>\n");
		added.setValue("ArrayOfMachineInfoEx",1);
	}
	return schema;
}

void CGetMachineInfoResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CGetMachineInfoResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
	info.addMinVersion("GetMachineInfoResponse","UserName",1.02);
	info.addMinVersion("GetMachineInfoResponse","Password",1.02);
	info.addMinVersion("GetMachineInfoResponse","AcceptLanguage",1.12);
	if (!added.getValue("MachineInfoEx"))
	{
		added.setValue("MachineInfoEx",1);
		CMachineInfoEx::getMapInfo(info,added);
	}
	if (!added.getValue("RequestInfoStruct"))
	{
		added.setValue("RequestInfoStruct",1);
		CRequestInfoStruct::getMapInfo(info,added);
	}
}

StringBuffer &CGetMachineInfoResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("RequestInfo");
	form.append("<tr>").append("<td><b>RequestInfo: </b></td><td><hr/>");
	CRequestInfoStruct::getHtmlForm(context, request, serv, method, form, false, extfix.str());
	form.append("<hr/></td></tr>");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Columns");
	form.appendf("<tr><td><b>Columns: </b></td><td>");
	form.appendf("<textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea>", extfix.str());
	form.append("</td></tr>");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Machines");
	form.appendf("<tr><td><b>Machines: </b></td><td>");
	form.appendf("<table><tr><td><textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea></td>", extfix.str());
	form.append("</tr></table>");
	form.append("</td></tr>");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("TimeStamp");
	form.appendf("  <tr><td><b>TimeStamp: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (!context.suppressed("GetMachineInfoResponse","UserName")) {
		extfix.clear();
		if (prefix && *prefix)
			extfix.append(prefix).append(".");
		extfix.append("UserName");
		form.appendf("  <tr><td><b>UserName: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
		form.append("</td></tr>\n");
	}
	if (!context.suppressed("GetMachineInfoResponse","Password")) {
		extfix.clear();
		if (prefix && *prefix)
			extfix.append(prefix).append(".");
		extfix.append("Password");
		form.appendf("  <tr><td><b>Password: </b></td><td><input type=\"password\" name=\"%s\" size=\"20\" value=\"\" />", extfix.str());
		form.append("</td></tr>\n");
	}
	if (!context.suppressed("GetMachineInfoResponse","AcceptLanguage")) {
		extfix.clear();
		if (prefix && *prefix)
			extfix.append(prefix).append(".");
		extfix.append("AcceptLanguage");
		form.appendf("  <tr><td><b>AcceptLanguage: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
		form.append("</td></tr>\n");
	}
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CGetMachineInfoResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CGetMachineInfoResponse::serialize(IRpcMessage& rpc_resp)
{
	IEspContext* ctx = rpc_resp.queryContext();
	double clientVer= ctx ? ctx->getClientVersion() : -1; /* no context gets everything */
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	rpc_resp.setEncodeXml(false);
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
		m_RequestInfo.marshall(rpc_resp, "RequestInfo", "", "", "");
		m_Columns.marshall(rpc_resp, "Columns", "Item");
		m_Machines.marshall(rpc_resp, "Machines", "MachineInfoEx");
		m_TimeStamp.marshall(rpc_resp, "TimeStamp", "", "", "");
		if ((clientVer==-1.0 || clientVer>=1.02))
			m_UserName.marshall(rpc_resp, "UserName", "", "", "");
		if ((clientVer==-1.0 || clientVer>=1.02))
			m_Password.marshall(rpc_resp, "Password", "", "", "");
		if ((clientVer==-1.0 || clientVer>=1.12))
			m_AcceptLanguage.marshall(rpc_resp, "AcceptLanguage", "", "", "");
	}
}


void CGetMachineInfoResponse::copy(CGetMachineInfoResponse &from)
{
	m_RequestInfo.copy(from.m_RequestInfo);
	m_Columns.copy(from.m_Columns);
	m_Machines.copy(from.m_Machines);
	m_TimeStamp.copy(from.m_TimeStamp);
	m_UserName.copy(from.m_UserName);
	m_Password.copy(from.m_Password);
	m_AcceptLanguage.copy(from.m_AcceptLanguage);
}


void CGetMachineInfoResponse::copy(IConstGetMachineInfoResponse &ifrom)
{
	setRequestInfo(ifrom.getRequestInfo());
	setColumns(ifrom.getColumns());
	setMachines(ifrom.getMachines());
	setTimeStamp(ifrom.getTimeStamp());
	setUserName(ifrom.getUserName());
	setPassword(ifrom.getPassword());
	setAcceptLanguage(ifrom.getAcceptLanguage());
}


void CGetMachineInfoResponse::getAttributes(IProperties &attributes)
{
}


void CGetMachineInfoResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
		double clientVer = ctx ? ctx->getClientVersion() : -1;
		m_RequestInfo.toStr(ctx, buffer, "RequestInfo", "", false, "", "");
		m_Columns.toStr(ctx, buffer, "Columns", "Item");
		m_Machines.toStr(ctx, buffer, "Machines", "MachineInfoEx");
		m_TimeStamp.toStr(ctx, buffer, "TimeStamp", "", false, "", "");
		if ((clientVer==-1.0 || clientVer>=1.02))
			m_UserName.toStr(ctx, buffer, "UserName", "", false, "", "");
		if ((clientVer==-1.0 || clientVer>=1.02))
			m_Password.toStr(ctx, buffer, "Password", "", false, "", "");
		if ((clientVer==-1.0 || clientVer>=1.12))
			m_AcceptLanguage.toStr(ctx, buffer, "AcceptLanguage", "", false, "", "");
	}
}


void CGetMachineInfoResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CGetMachineInfoResponse::serializer(IEspContext* ctx, IConstGetMachineInfoResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<GetMachineInfoResponse>");
	double clientVer = ctx ? ctx->getClientVersion() : -1;
	// field RequestInfo
	{
		StringBuffer tmp;
		CRequestInfoStruct::serializer(ctx,src.getRequestInfo(), tmp, false);
		if (tmp.length()>0)
			buffer.appendf("<RequestInfo>%s</RequestInfo>",tmp.str());
	}
	// field Columns
	{
		StringArray& v = src.getColumns();
		if (v.length()>0)
			buffer.append("<Columns>");
		for (size32_t i=0;i<v.length();i++)
			buffer.appendf("<Item>%s</Item>",v.item(i));
		if (v.length()>0)
			buffer.append("</Columns>");
	}
	// field Machines
	{
		IArrayOf<IConstMachineInfoEx>& v = src.getMachines();
		int size = v.length();
		if (size>0)
			buffer.append("<Machines>");
		for (int i=0;i<size;i++)
		{
			buffer.append("<Item>");
			CMachineInfoEx::serializer(ctx,v.item(i),buffer,false);
			buffer.append("</Item>");
		}
		if (size>0)
			buffer.append("</Machines>");
	}
	// field TimeStamp
	{
		const char* s = src.getTimeStamp();
		if (s && *s)
		buffer.appendf("<TimeStamp>%s</TimeStamp>",s);
	}
	// field UserName
	if ((clientVer==-1.0 || clientVer>=1.02))
	{
		const char* s = src.getUserName();
		if (s && *s)
		buffer.appendf("<UserName>%s</UserName>",s);
	}
	// field Password
	if ((clientVer==-1.0 || clientVer>=1.02))
	{
		const char* s = src.getPassword();
		if (s && *s)
		buffer.appendf("<Password>%s</Password>",s);
	}
	// field AcceptLanguage
	if ((clientVer==-1.0 || clientVer>=1.12))
	{
		const char* s = src.getAcceptLanguage();
		if (s && *s)
		buffer.appendf("<AcceptLanguage>%s</AcceptLanguage>",s);
	}
	if (keepRootTag)
		buffer.append("</GetMachineInfoResponse>");
}

bool CGetMachineInfoResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
		hasValue |= m_RequestInfo.unmarshall(rpc_request, "RequestInfo", basepath);
		hasValue |= m_Columns.unmarshall(rpc_request, "Columns", basepath);
		hasValue |= m_Machines.unmarshall(rpc_request, "Machines", basepath);
		hasValue |= m_TimeStamp.unmarshall(rpc_request, "TimeStamp", basepath);
		hasValue |= m_UserName.unmarshall(rpc_request, "UserName", basepath);
		hasValue |= m_Password.unmarshall(rpc_request, "Password", basepath);
		hasValue |= m_AcceptLanguage.unmarshall(rpc_request, "AcceptLanguage", basepath);
	}
	return hasValue;
}

bool CGetMachineInfoResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_RequestInfo.unmarshall(ctx, soapval, "RequestInfo");
	hasValue |= m_Columns.unmarshall(ctx, soapval, "Columns");
	hasValue |= m_Machines.unmarshall(ctx, soapval, "Machines");
	hasValue |= m_TimeStamp.unmarshall(ctx, soapval, "TimeStamp");
	hasValue |= m_UserName.unmarshall(ctx, soapval, "UserName");
	hasValue |= m_Password.unmarshall(ctx, soapval, "Password");
	hasValue |= m_AcceptLanguage.unmarshall(ctx, soapval, "AcceptLanguage");
	return hasValue;
}

bool CGetMachineInfoResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_RequestInfo.unmarshall(ctx, params, attachments, "RequestInfo", basepath);
	hasValue |= m_Columns.unmarshall(ctx, params, attachments, "Columns", basepath);
	hasValue |= m_Machines.unmarshall(ctx, params, attachments, "Machines", basepath);
	hasValue |= m_TimeStamp.unmarshall(ctx, params, attachments, "TimeStamp", basepath);
	hasValue |= m_UserName.unmarshall(ctx, params, attachments, "UserName", basepath);
	hasValue |= m_Password.unmarshall(ctx, params, attachments, "Password", basepath);
	hasValue |= m_AcceptLanguage.unmarshall(ctx, params, attachments, "AcceptLanguage", basepath);
	return hasValue;
}

IConstRequestInfoStruct & CGetMachineInfoResponse::getRequestInfo() { return (IConstRequestInfoStruct &) m_RequestInfo.getValue();}
StringArray & CGetMachineInfoResponse::getColumns() { return (StringArray &) m_Columns; }
IArrayOf<IConstMachineInfoEx> & CGetMachineInfoResponse::getMachines() { return (IArrayOf<IConstMachineInfoEx> &) m_Machines; }
const char * CGetMachineInfoResponse::getTimeStamp() { return m_TimeStamp.query();}
const char * CGetMachineInfoResponse::getUserName() { return m_UserName.query();}
const char * CGetMachineInfoResponse::getPassword() { return m_Password.query();}
const char * CGetMachineInfoResponse::getAcceptLanguage() { return m_AcceptLanguage.query();}
IEspRequestInfoStruct & CGetMachineInfoResponse::updateRequestInfo(){ return (IEspRequestInfoStruct &) m_RequestInfo.getValue(); }
void CGetMachineInfoResponse::setRequestInfo(IConstRequestInfoStruct &ifrom){ m_RequestInfo.copy(ifrom); }
void CGetMachineInfoResponse::setColumns(StringArray &val){ m_Columns->kill();  CloneArray(m_Columns.getValue(), val); }
void CGetMachineInfoResponse::setMachines(IArrayOf<IEspMachineInfoEx> &val)
{
	m_Machines->kill();
	IArrayOf<IConstMachineInfoEx> &target = m_Machines.getValue();
	ForEachItemIn(idx, val)
	{
		IEspMachineInfoEx &item = (val).item(idx);
		item.Link();
		target.append(item);
	}
}
void CGetMachineInfoResponse::setMachines(IArrayOf<IConstMachineInfoEx> &val)
{
	m_Machines->kill();
	IArrayOf<IConstMachineInfoEx> &target = m_Machines.getValue();
	ForEachItemIn(idx, val)
	{
		IConstMachineInfoEx &item = val.item(idx);
		item.Link();
		target.append(item);
	}
}
void CGetMachineInfoResponse::setTimeStamp(const char * val){ m_TimeStamp.set(val); }
void CGetMachineInfoResponse::setUserName(const char * val){ m_UserName.set(val); }
void CGetMachineInfoResponse::setPassword(const char * val){ m_Password.set(val); }
void CGetMachineInfoResponse::setAcceptLanguage(const char * val){ m_AcceptLanguage.set(val); }
extern "C"  IEspGetMachineInfoResponse *createGetMachineInfoResponse(const char *serv){return ((IEspGetMachineInfoResponse *)new CGetMachineInfoResponse(serv));}
extern "C"  IClientGetMachineInfoResponse *createClientGetMachineInfoResponse(const char *serv){return ((IClientGetMachineInfoResponse *)new CGetMachineInfoResponse(serv));}

//=======================================================
// class CGetMachineInfoRequestEx Implementation
//=======================================================

CGetMachineInfoRequestEx::CGetMachineInfoRequestEx(const char *serviceName, IRpcMessageBinding *init)
	: m_Addresses(nilIgnore),m_ClusterType(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetMachineInfoRequestEx");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CGetMachineInfoRequestEx::CGetMachineInfoRequestEx(const char *serviceName, const char *bc)
	: m_Addresses(nilIgnore),m_ClusterType(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetMachineInfoRequestEx");
}

CGetMachineInfoRequestEx::CGetMachineInfoRequestEx(const char *serviceName, IRpcMessage* rpcmsg)
	: m_Addresses(nilIgnore),m_ClusterType(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetMachineInfoRequestEx");
	unserialize(*rpcmsg,NULL,NULL);
}

CGetMachineInfoRequestEx::CGetMachineInfoRequestEx(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_Addresses(nilIgnore),m_ClusterType(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetMachineInfoRequestEx");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CGetMachineInfoRequestEx::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Addresses\" type=\"tns:EspStringArray\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"ClusterType\" type=\"xsd:string\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	if (added.getValue("EspStringArray")==NULL) {
		addEspNativeArray(schema,"string","EspStringArray");
		added.setValue("EspStringArray",1);
	}
	return schema;
}

void CGetMachineInfoRequestEx::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CGetMachineInfoRequestEx::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CGetMachineInfoRequestEx::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Addresses");
	form.appendf("<tr><td><b>Addresses: </b></td><td>");
	form.appendf("<textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea>", extfix.str());
	form.append("</td></tr>");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("ClusterType");
	form.appendf("  <tr><td><b>ClusterType: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CGetMachineInfoRequestEx::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CGetMachineInfoRequestEx::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_Addresses.marshall(rpc_resp, "Addresses", "Item");
	m_ClusterType.marshall(rpc_resp, "ClusterType", "", "", "");
}


void CGetMachineInfoRequestEx::copy(CGetMachineInfoRequestEx &from)
{
	m_Addresses.copy(from.m_Addresses);
	m_ClusterType.copy(from.m_ClusterType);
}


void CGetMachineInfoRequestEx::copy(IConstGetMachineInfoRequestEx &ifrom)
{
	setAddresses(ifrom.getAddresses());
	setClusterType(ifrom.getClusterType());
}


void CGetMachineInfoRequestEx::getAttributes(IProperties &attributes)
{
}


void CGetMachineInfoRequestEx::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_Addresses.toStr(ctx, buffer, "Addresses", "Item");
	m_ClusterType.toStr(ctx, buffer, "ClusterType", "", true, "", "");
}


void CGetMachineInfoRequestEx::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CGetMachineInfoRequestEx::serializer(IEspContext* ctx, IConstGetMachineInfoRequestEx &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<GetMachineInfoRequestEx>");
	// field Addresses
	{
		StringArray& v = src.getAddresses();
		if (v.length()>0)
			buffer.append("<Addresses>");
		for (size32_t i=0;i<v.length();i++)
			buffer.appendf("<Item>%s</Item>",v.item(i));
		if (v.length()>0)
			buffer.append("</Addresses>");
	}
	// field ClusterType
	{
		const char* s = src.getClusterType();
		if (s && *s)
		{
			buffer.append("<ClusterType>");
			encodeUtf8XML(s,buffer);
			buffer.append("</ClusterType>");
		}
	}
	if (keepRootTag)
		buffer.append("</GetMachineInfoRequestEx>");
}

bool CGetMachineInfoRequestEx::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_Addresses.unmarshall(rpc_request, "Addresses", basepath);
	hasValue |= m_ClusterType.unmarshall(rpc_request, "ClusterType", basepath);
	return hasValue;
}

bool CGetMachineInfoRequestEx::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Addresses.unmarshall(ctx, soapval, "Addresses");
	hasValue |= m_ClusterType.unmarshall(ctx, soapval, "ClusterType");
	return hasValue;
}

bool CGetMachineInfoRequestEx::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Addresses.unmarshall(ctx, params, attachments, "Addresses", basepath);
	hasValue |= m_ClusterType.unmarshall(ctx, params, attachments, "ClusterType", basepath);
	return hasValue;
}

StringArray & CGetMachineInfoRequestEx::getAddresses() { return (StringArray &) m_Addresses; }
const char * CGetMachineInfoRequestEx::getClusterType() { return m_ClusterType.query();}
void CGetMachineInfoRequestEx::setAddresses(StringArray &val){ m_Addresses->kill();  CloneArray(m_Addresses.getValue(), val); }
void CGetMachineInfoRequestEx::setClusterType(const char * val){ m_ClusterType.set(val); }
extern "C"  IEspGetMachineInfoRequestEx *createGetMachineInfoRequestEx(const char *serv){return ((IEspGetMachineInfoRequestEx *)new CGetMachineInfoRequestEx(serv));}
extern "C"  IClientGetMachineInfoRequestEx *createClientGetMachineInfoRequestEx(const char *serv){return ((IClientGetMachineInfoRequestEx *)new CGetMachineInfoRequestEx(serv));}

//=======================================================
// class CGetMachineInfoResponseEx Implementation
//=======================================================

CGetMachineInfoResponseEx::CGetMachineInfoResponseEx(const char *serviceName, IRpcMessageBinding *init)
	: m_AcceptLanguage(nilIgnore),m_Machines(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetMachineInfoResponseEx");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CGetMachineInfoResponseEx::CGetMachineInfoResponseEx(const char *serviceName, const char *bc)
	: m_AcceptLanguage(nilIgnore),m_Machines(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetMachineInfoResponseEx");
}

CGetMachineInfoResponseEx::CGetMachineInfoResponseEx(const char *serviceName, IRpcMessage* rpcmsg)
	: m_AcceptLanguage(nilIgnore),m_Machines(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetMachineInfoResponseEx");
	unserialize(*rpcmsg,NULL,NULL);
}

CGetMachineInfoResponseEx::CGetMachineInfoResponseEx(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_AcceptLanguage(nilIgnore),m_Machines(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetMachineInfoResponseEx");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CGetMachineInfoResponseEx::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		schema.append("<xsd:element name=\"Exceptions\" type=\"tns:ArrayOfEspException\" minOccurs=\"0\" maxOccurs=\"1\"/>");
		}
		if (!context.suppressed("GetMachineInfoResponseEx","AcceptLanguage")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"AcceptLanguage\" type=\"xsd:string\"/>\n");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Machines\" type=\"tns:ArrayOfMachineInfoEx\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	if (!(flags & 0x10)  || (flags & 0x100))
	{
		CMachineInfoEx::getXsdDefinition(context, request, schema, added);
	}
	if (added.getValue("MachineInfoEx") && added.getValue("ArrayOfMachineInfoEx")==NULL) {
		schema.append("<xsd:complexType name=\"ArrayOfMachineInfoEx\">\n");
		schema.append("<xsd:sequence>\n");
		schema.append("<xsd:element minOccurs=\"0\" maxOccurs=\"unbounded\" name=\"MachineInfoEx\" type=\"tns:MachineInfoEx\"/>\n");
		schema.append("</xsd:sequence>\n");
		schema.append("</xsd:complexType>\n");
		added.setValue("ArrayOfMachineInfoEx",1);
	}
	return schema;
}

void CGetMachineInfoResponseEx::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CGetMachineInfoResponseEx::getMapInfo(IMapInfo& info, BoolHash& added)
{
	info.addMinVersion("GetMachineInfoResponseEx","AcceptLanguage",1.12);
	if (!added.getValue("MachineInfoEx"))
	{
		added.setValue("MachineInfoEx",1);
		CMachineInfoEx::getMapInfo(info,added);
	}
}

StringBuffer &CGetMachineInfoResponseEx::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	if (!context.suppressed("GetMachineInfoResponseEx","AcceptLanguage")) {
		extfix.clear();
		if (prefix && *prefix)
			extfix.append(prefix).append(".");
		extfix.append("AcceptLanguage");
		form.appendf("  <tr><td><b>AcceptLanguage: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
		form.append("</td></tr>\n");
	}
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Machines");
	form.appendf("<tr><td><b>Machines: </b></td><td>");
	form.appendf("<table><tr><td><textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea></td>", extfix.str());
	form.append("</tr></table>");
	form.append("</td></tr>");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CGetMachineInfoResponseEx::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CGetMachineInfoResponseEx::serialize(IRpcMessage& rpc_resp)
{
	IEspContext* ctx = rpc_resp.queryContext();
	double clientVer= ctx ? ctx->getClientVersion() : -1; /* no context gets everything */
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	rpc_resp.setEncodeXml(false);
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
		if ((clientVer==-1.0 || clientVer>=1.12))
			m_AcceptLanguage.marshall(rpc_resp, "AcceptLanguage", "", "", "");
		m_Machines.marshall(rpc_resp, "Machines", "MachineInfoEx");
	}
}


void CGetMachineInfoResponseEx::copy(CGetMachineInfoResponseEx &from)
{
	m_AcceptLanguage.copy(from.m_AcceptLanguage);
	m_Machines.copy(from.m_Machines);
}


void CGetMachineInfoResponseEx::copy(IConstGetMachineInfoResponseEx &ifrom)
{
	setAcceptLanguage(ifrom.getAcceptLanguage());
	setMachines(ifrom.getMachines());
}


void CGetMachineInfoResponseEx::getAttributes(IProperties &attributes)
{
}


void CGetMachineInfoResponseEx::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
		double clientVer = ctx ? ctx->getClientVersion() : -1;
		if ((clientVer==-1.0 || clientVer>=1.12))
			m_AcceptLanguage.toStr(ctx, buffer, "AcceptLanguage", "", false, "", "");
		m_Machines.toStr(ctx, buffer, "Machines", "MachineInfoEx");
	}
}


void CGetMachineInfoResponseEx::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CGetMachineInfoResponseEx::serializer(IEspContext* ctx, IConstGetMachineInfoResponseEx &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<GetMachineInfoResponseEx>");
	double clientVer = ctx ? ctx->getClientVersion() : -1;
	// field AcceptLanguage
	if ((clientVer==-1.0 || clientVer>=1.12))
	{
		const char* s = src.getAcceptLanguage();
		if (s && *s)
		buffer.appendf("<AcceptLanguage>%s</AcceptLanguage>",s);
	}
	// field Machines
	{
		IArrayOf<IConstMachineInfoEx>& v = src.getMachines();
		int size = v.length();
		if (size>0)
			buffer.append("<Machines>");
		for (int i=0;i<size;i++)
		{
			buffer.append("<Item>");
			CMachineInfoEx::serializer(ctx,v.item(i),buffer,false);
			buffer.append("</Item>");
		}
		if (size>0)
			buffer.append("</Machines>");
	}
	if (keepRootTag)
		buffer.append("</GetMachineInfoResponseEx>");
}

bool CGetMachineInfoResponseEx::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
		hasValue |= m_AcceptLanguage.unmarshall(rpc_request, "AcceptLanguage", basepath);
		hasValue |= m_Machines.unmarshall(rpc_request, "Machines", basepath);
	}
	return hasValue;
}

bool CGetMachineInfoResponseEx::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_AcceptLanguage.unmarshall(ctx, soapval, "AcceptLanguage");
	hasValue |= m_Machines.unmarshall(ctx, soapval, "Machines");
	return hasValue;
}

bool CGetMachineInfoResponseEx::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_AcceptLanguage.unmarshall(ctx, params, attachments, "AcceptLanguage", basepath);
	hasValue |= m_Machines.unmarshall(ctx, params, attachments, "Machines", basepath);
	return hasValue;
}

const char * CGetMachineInfoResponseEx::getAcceptLanguage() { return m_AcceptLanguage.query();}
IArrayOf<IConstMachineInfoEx> & CGetMachineInfoResponseEx::getMachines() { return (IArrayOf<IConstMachineInfoEx> &) m_Machines; }
void CGetMachineInfoResponseEx::setAcceptLanguage(const char * val){ m_AcceptLanguage.set(val); }
void CGetMachineInfoResponseEx::setMachines(IArrayOf<IEspMachineInfoEx> &val)
{
	m_Machines->kill();
	IArrayOf<IConstMachineInfoEx> &target = m_Machines.getValue();
	ForEachItemIn(idx, val)
	{
		IEspMachineInfoEx &item = (val).item(idx);
		item.Link();
		target.append(item);
	}
}
void CGetMachineInfoResponseEx::setMachines(IArrayOf<IConstMachineInfoEx> &val)
{
	m_Machines->kill();
	IArrayOf<IConstMachineInfoEx> &target = m_Machines.getValue();
	ForEachItemIn(idx, val)
	{
		IConstMachineInfoEx &item = val.item(idx);
		item.Link();
		target.append(item);
	}
}
extern "C"  IEspGetMachineInfoResponseEx *createGetMachineInfoResponseEx(const char *serv){return ((IEspGetMachineInfoResponseEx *)new CGetMachineInfoResponseEx(serv));}
extern "C"  IClientGetMachineInfoResponseEx *createClientGetMachineInfoResponseEx(const char *serv){return ((IClientGetMachineInfoResponseEx *)new CGetMachineInfoResponseEx(serv));}

//=======================================================
// class CMetricsRequest Implementation
//=======================================================

CMetricsRequest::CMetricsRequest(const char *serviceName, IRpcMessageBinding *init)
	: m_SecurityString(nilIgnore),m_Addresses(nilIgnore),m_ShowColumns(nilIgnore),m_AutoRefresh(nilIgnore),m_SelectAllChecked(0, nilIgnore,false),m_Cluster(nilIgnore),m_AutoUpdate(1, nilIgnore,false)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("MetricsRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CMetricsRequest::CMetricsRequest(const char *serviceName, const char *bc)
	: m_SecurityString(nilIgnore),m_Addresses(nilIgnore),m_ShowColumns(nilIgnore),m_AutoRefresh(nilIgnore),m_SelectAllChecked(0, nilIgnore,false),m_Cluster(nilIgnore),m_AutoUpdate(1, nilIgnore,false)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("MetricsRequest");
}

CMetricsRequest::CMetricsRequest(const char *serviceName, IRpcMessage* rpcmsg)
	: m_SecurityString(nilIgnore),m_Addresses(nilIgnore),m_ShowColumns(nilIgnore),m_AutoRefresh(nilIgnore),m_SelectAllChecked(0, nilIgnore,false),m_Cluster(nilIgnore),m_AutoUpdate(1, nilIgnore,false)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("MetricsRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CMetricsRequest::CMetricsRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_SecurityString(nilIgnore),m_Addresses(nilIgnore),m_ShowColumns(nilIgnore),m_AutoRefresh(nilIgnore),m_SelectAllChecked(0, nilIgnore,false),m_Cluster(nilIgnore),m_AutoUpdate(1, nilIgnore,false)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("MetricsRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CMetricsRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"SecurityString\" type=\"xsd:string\"");
		if (context.queryOptions()&ESPCTX_ALL_ANNOTATION)
			schema.append("> <xsd:annotation><xsd:appinfo><form formType=\"password\" formCols=\"20\"/></xsd:appinfo></xsd:annotation></xsd:element>\n");
		else
			schema.append("/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Addresses\" type=\"tns:EspStringArray\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"ShowColumns\" type=\"tns:EspStringArray\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"AutoRefresh\" type=\"xsd:int\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" default=\"false\" name=\"SelectAllChecked\" type=\"xsd:boolean\"/>\n");
		if (!context.suppressed("MetricsRequest","Cluster")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"Cluster\" type=\"xsd:string\"/>\n");
		}
		if (!context.suppressed("MetricsRequest","AutoUpdate")) {
			schema.append("<xsd:element minOccurs=\"0\" default=\"true\" name=\"AutoUpdate\" type=\"xsd:boolean\"/>\n");
		}
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	if (added.getValue("EspStringArray")==NULL) {
		addEspNativeArray(schema,"string","EspStringArray");
		added.setValue("EspStringArray",1);
	}
	return schema;
}

void CMetricsRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CMetricsRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
	info.addMinVersion("MetricsRequest","Cluster",1.02);
	info.addMinVersion("MetricsRequest","AutoUpdate",1.07);
}

StringBuffer &CMetricsRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("SecurityString");
	form.appendf("  <tr><td><b>SecurityString: </b></td><td><input type=\"password\" name=\"%s\" size=\"20\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Addresses");
	form.appendf("<tr><td><b>Addresses: </b></td><td>");
	form.appendf("<textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea>", extfix.str());
	form.append("</td></tr>");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("ShowColumns");
	form.appendf("<tr><td><b>ShowColumns: </b></td><td>");
	form.appendf("<textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea>", extfix.str());
	form.append("</td></tr>");
	extfix.clear();
	if (prefix && *prefix) extfix.append(prefix).append(".");
		extfix.append("AutoRefresh");
	form.appendf("  <tr><td><b>AutoRefresh: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("SelectAllChecked");
	
	form.appendf("  <tr><td><b>SelectAllChecked? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	if (!context.suppressed("MetricsRequest","Cluster")) {
		extfix.clear();
		if (prefix && *prefix)
			extfix.append(prefix).append(".");
		extfix.append("Cluster");
		form.appendf("  <tr><td><b>Cluster: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
		form.append("</td></tr>\n");
	}
	if (!context.suppressed("MetricsRequest","AutoUpdate")) {
		extfix.clear();
		if (prefix && *prefix)
			extfix.append(prefix).append(".");
		extfix.append("AutoUpdate");
		
	form.appendf("  <tr><td><b>AutoUpdate? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\" checked=\"1\" /></td></tr>\n", extfix.str());
	}
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CMetricsRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CMetricsRequest::serialize(IRpcMessage& rpc_resp)
{
	IEspContext* ctx = rpc_resp.queryContext();
	double clientVer= ctx ? ctx->getClientVersion() : -1; /* no context gets everything */
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_SecurityString.marshall(rpc_resp, "SecurityString", "", "", "");
	m_Addresses.marshall(rpc_resp, "Addresses", "Item");
	m_ShowColumns.marshall(rpc_resp, "ShowColumns", "Item");
	m_AutoRefresh.marshall(rpc_resp, "AutoRefresh", "", "", "");
	m_SelectAllChecked.marshall(rpc_resp, "SelectAllChecked", "", "", "");
	if ((clientVer==-1.0 || clientVer>=1.02))
		m_Cluster.marshall(rpc_resp, "Cluster", "", "", "");
	if ((clientVer==-1.0 || clientVer>=1.07))
		m_AutoUpdate.marshall(rpc_resp, "AutoUpdate", "", "", "");
}


void CMetricsRequest::copy(CMetricsRequest &from)
{
	m_SecurityString.copy(from.m_SecurityString);
	m_Addresses.copy(from.m_Addresses);
	m_ShowColumns.copy(from.m_ShowColumns);
	m_AutoRefresh.copy(from.m_AutoRefresh);
	m_SelectAllChecked.copy(from.m_SelectAllChecked);
	m_Cluster.copy(from.m_Cluster);
	m_AutoUpdate.copy(from.m_AutoUpdate);
}


void CMetricsRequest::copy(IConstMetricsRequest &ifrom)
{
	setSecurityString(ifrom.getSecurityString());
	setAddresses(ifrom.getAddresses());
	setShowColumns(ifrom.getShowColumns());
	setAutoRefresh(ifrom.getAutoRefresh());
	setSelectAllChecked(ifrom.getSelectAllChecked());
	setCluster(ifrom.getCluster());
	setAutoUpdate(ifrom.getAutoUpdate());
}


void CMetricsRequest::getAttributes(IProperties &attributes)
{
}


void CMetricsRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	double clientVer = ctx ? ctx->getClientVersion() : -1;
	m_SecurityString.toStr(ctx, buffer, "SecurityString", "", true, "", "");
	m_Addresses.toStr(ctx, buffer, "Addresses", "Item");
	m_ShowColumns.toStr(ctx, buffer, "ShowColumns", "Item");
	m_AutoRefresh.toStr(ctx, buffer, "AutoRefresh", "", true, "", "");
	m_SelectAllChecked.toStr(ctx, buffer, "SelectAllChecked", "", true, "", "");
	if ((clientVer==-1.0 || clientVer>=1.02))
		m_Cluster.toStr(ctx, buffer, "Cluster", "", true, "", "");
	if ((clientVer==-1.0 || clientVer>=1.07))
		m_AutoUpdate.toStr(ctx, buffer, "AutoUpdate", "", true, "", "");
}


void CMetricsRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CMetricsRequest::serializer(IEspContext* ctx, IConstMetricsRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<MetricsRequest>");
	double clientVer = ctx ? ctx->getClientVersion() : -1;
	// field SecurityString
	{
		const char* s = src.getSecurityString();
		if (s && *s)
		{
			buffer.append("<SecurityString>");
			encodeUtf8XML(s,buffer);
			buffer.append("</SecurityString>");
		}
	}
	// field Addresses
	{
		StringArray& v = src.getAddresses();
		if (v.length()>0)
			buffer.append("<Addresses>");
		for (size32_t i=0;i<v.length();i++)
			buffer.appendf("<Item>%s</Item>",v.item(i));
		if (v.length()>0)
			buffer.append("</Addresses>");
	}
	// field ShowColumns
	{
		StringArray& v = src.getShowColumns();
		if (v.length()>0)
			buffer.append("<ShowColumns>");
		for (size32_t i=0;i<v.length();i++)
			buffer.appendf("<Item>%s</Item>",v.item(i));
		if (v.length()>0)
			buffer.append("</ShowColumns>");
	}
	// field AutoRefresh
	{
		int n = src.getAutoRefresh();
		if (n)
			buffer.appendf("<AutoRefresh>%d</AutoRefresh>", n);
	}
	// field SelectAllChecked
	{
		bool b = src.getSelectAllChecked();
		if (b)
			buffer.appendf("<SelectAllChecked>1</SelectAllChecked>");
	}
	// field Cluster
	if ((clientVer==-1.0 || clientVer>=1.02))
	{
		const char* s = src.getCluster();
		if (s && *s)
		{
			buffer.append("<Cluster>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Cluster>");
		}
	}
	// field AutoUpdate
	if ((clientVer==-1.0 || clientVer>=1.07))
	{
		bool b = src.getAutoUpdate();
		if (b)
			buffer.appendf("<AutoUpdate>1</AutoUpdate>");
	}
	if (keepRootTag)
		buffer.append("</MetricsRequest>");
}

bool CMetricsRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_SecurityString.unmarshall(rpc_request, "SecurityString", basepath);
	hasValue |= m_Addresses.unmarshall(rpc_request, "Addresses", basepath);
	hasValue |= m_ShowColumns.unmarshall(rpc_request, "ShowColumns", basepath);
	hasValue |= m_AutoRefresh.unmarshall(rpc_request, "AutoRefresh", basepath);
	hasValue |= m_SelectAllChecked.unmarshall(rpc_request, "SelectAllChecked", basepath);
	hasValue |= m_Cluster.unmarshall(rpc_request, "Cluster", basepath);
	hasValue |= m_AutoUpdate.unmarshall(rpc_request, "AutoUpdate", basepath);
	return hasValue;
}

bool CMetricsRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_SecurityString.unmarshall(ctx, soapval, "SecurityString");
	hasValue |= m_Addresses.unmarshall(ctx, soapval, "Addresses");
	hasValue |= m_ShowColumns.unmarshall(ctx, soapval, "ShowColumns");
	hasValue |= m_AutoRefresh.unmarshall(ctx, soapval, "AutoRefresh");
	hasValue |= m_SelectAllChecked.unmarshall(ctx, soapval, "SelectAllChecked");
	hasValue |= m_Cluster.unmarshall(ctx, soapval, "Cluster");
	hasValue |= m_AutoUpdate.unmarshall(ctx, soapval, "AutoUpdate");
	return hasValue;
}

bool CMetricsRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_SecurityString.unmarshall(ctx, params, attachments, "SecurityString", basepath);
	hasValue |= m_Addresses.unmarshall(ctx, params, attachments, "Addresses", basepath);
	hasValue |= m_ShowColumns.unmarshall(ctx, params, attachments, "ShowColumns", basepath);
	hasValue |= m_AutoRefresh.unmarshall(ctx, params, attachments, "AutoRefresh", basepath);
	hasValue |= m_SelectAllChecked.unmarshall(ctx, params, attachments, "SelectAllChecked", basepath);
	hasValue |= m_Cluster.unmarshall(ctx, params, attachments, "Cluster", basepath);
	hasValue |= m_AutoUpdate.unmarshall(ctx, params, attachments, "AutoUpdate", basepath);
	return hasValue;
}

const char * CMetricsRequest::getSecurityString() { return m_SecurityString.query();}
StringArray & CMetricsRequest::getAddresses() { return (StringArray &) m_Addresses; }
StringArray & CMetricsRequest::getShowColumns() { return (StringArray &) m_ShowColumns; }
int CMetricsRequest::getAutoRefresh() { return m_AutoRefresh;}
bool CMetricsRequest::getSelectAllChecked() { return m_SelectAllChecked;}
const char * CMetricsRequest::getCluster() { return m_Cluster.query();}
bool CMetricsRequest::getAutoUpdate() { return m_AutoUpdate;}
void CMetricsRequest::setSecurityString(const char * val){ m_SecurityString.set(val); }
void CMetricsRequest::setAddresses(StringArray &val){ m_Addresses->kill();  CloneArray(m_Addresses.getValue(), val); }
void CMetricsRequest::setShowColumns(StringArray &val){ m_ShowColumns->kill();  CloneArray(m_ShowColumns.getValue(), val); }
void CMetricsRequest::setAutoRefresh(int val){ m_AutoRefresh=val; }
void CMetricsRequest::setSelectAllChecked(bool val){ m_SelectAllChecked=val; }
void CMetricsRequest::setCluster(const char * val){ m_Cluster.set(val); }
void CMetricsRequest::setAutoUpdate(bool val){ m_AutoUpdate=val; }
extern "C"  IEspMetricsRequest *createMetricsRequest(const char *serv){return ((IEspMetricsRequest *)new CMetricsRequest(serv));}
extern "C"  IClientMetricsRequest *createClientMetricsRequest(const char *serv){return ((IClientMetricsRequest *)new CMetricsRequest(serv));}

//=======================================================
// class CMetricsResponse Implementation
//=======================================================

CMetricsResponse::CMetricsResponse(const char *serviceName, IRpcMessageBinding *init)
	: m_FieldInformation(nilIgnore),m_Metrics(nilIgnore),m_AutoRefresh(nilIgnore),m_Cluster(nilIgnore),m_SelectAllChecked(0, nilIgnore,false),m_AutoUpdate(1, nilIgnore,false),m_AcceptLanguage(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("MetricsResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CMetricsResponse::CMetricsResponse(const char *serviceName, const char *bc)
	: m_FieldInformation(nilIgnore),m_Metrics(nilIgnore),m_AutoRefresh(nilIgnore),m_Cluster(nilIgnore),m_SelectAllChecked(0, nilIgnore,false),m_AutoUpdate(1, nilIgnore,false),m_AcceptLanguage(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("MetricsResponse");
}

CMetricsResponse::CMetricsResponse(const char *serviceName, IRpcMessage* rpcmsg)
	: m_FieldInformation(nilIgnore),m_Metrics(nilIgnore),m_AutoRefresh(nilIgnore),m_Cluster(nilIgnore),m_SelectAllChecked(0, nilIgnore,false),m_AutoUpdate(1, nilIgnore,false),m_AcceptLanguage(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("MetricsResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CMetricsResponse::CMetricsResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_FieldInformation(nilIgnore),m_Metrics(nilIgnore),m_AutoRefresh(nilIgnore),m_Cluster(nilIgnore),m_SelectAllChecked(0, nilIgnore,false),m_AutoUpdate(1, nilIgnore,false),m_AcceptLanguage(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("MetricsResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CMetricsResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		schema.append("<xsd:element name=\"Exceptions\" type=\"tns:ArrayOfEspException\" minOccurs=\"0\" maxOccurs=\"1\"/>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"FieldInformation\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Metrics\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"AutoRefresh\" type=\"xsd:int\"/>\n");
		if (!context.suppressed("MetricsResponse","Cluster")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"Cluster\" type=\"xsd:string\"/>\n");
		}
		if (!context.suppressed("MetricsResponse","SelectAllChecked")) {
			schema.append("<xsd:element minOccurs=\"0\" default=\"false\" name=\"SelectAllChecked\" type=\"xsd:boolean\"/>\n");
		}
		if (!context.suppressed("MetricsResponse","AutoUpdate")) {
			schema.append("<xsd:element minOccurs=\"0\" default=\"true\" name=\"AutoUpdate\" type=\"xsd:boolean\"/>\n");
		}
		if (!context.suppressed("MetricsResponse","AcceptLanguage")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"AcceptLanguage\" type=\"xsd:string\"/>\n");
		}
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CMetricsResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CMetricsResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
	info.addMinVersion("MetricsResponse","Cluster",1.02);
	info.addMinVersion("MetricsResponse","SelectAllChecked",1.06);
	info.addMinVersion("MetricsResponse","AutoUpdate",1.07);
	info.addMinVersion("MetricsResponse","AcceptLanguage",1.12);
}

StringBuffer &CMetricsResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("FieldInformation");
	form.appendf("  <tr><td><b>FieldInformation: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Metrics");
	form.appendf("  <tr><td><b>Metrics: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix) extfix.append(prefix).append(".");
		extfix.append("AutoRefresh");
	form.appendf("  <tr><td><b>AutoRefresh: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
	form.append("</td></tr>\n");
	if (!context.suppressed("MetricsResponse","Cluster")) {
		extfix.clear();
		if (prefix && *prefix)
			extfix.append(prefix).append(".");
		extfix.append("Cluster");
		form.appendf("  <tr><td><b>Cluster: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
		form.append("</td></tr>\n");
	}
	if (!context.suppressed("MetricsResponse","SelectAllChecked")) {
		extfix.clear();
		if (prefix && *prefix)
			extfix.append(prefix).append(".");
		extfix.append("SelectAllChecked");
		
	form.appendf("  <tr><td><b>SelectAllChecked? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	}
	if (!context.suppressed("MetricsResponse","AutoUpdate")) {
		extfix.clear();
		if (prefix && *prefix)
			extfix.append(prefix).append(".");
		extfix.append("AutoUpdate");
		
	form.appendf("  <tr><td><b>AutoUpdate? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\" checked=\"1\" /></td></tr>\n", extfix.str());
	}
	if (!context.suppressed("MetricsResponse","AcceptLanguage")) {
		extfix.clear();
		if (prefix && *prefix)
			extfix.append(prefix).append(".");
		extfix.append("AcceptLanguage");
		form.appendf("  <tr><td><b>AcceptLanguage: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
		form.append("</td></tr>\n");
	}
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CMetricsResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CMetricsResponse::serialize(IRpcMessage& rpc_resp)
{
	IEspContext* ctx = rpc_resp.queryContext();
	double clientVer= ctx ? ctx->getClientVersion() : -1; /* no context gets everything */
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	rpc_resp.setEncodeXml(false);
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
		m_FieldInformation.marshall(rpc_resp, "FieldInformation", "", "", "");
		m_Metrics.marshall(rpc_resp, "Metrics", "", "", "");
		m_AutoRefresh.marshall(rpc_resp, "AutoRefresh", "", "", "");
		if ((clientVer==-1.0 || clientVer>=1.02))
			m_Cluster.marshall(rpc_resp, "Cluster", "", "", "");
		if ((clientVer==-1.0 || clientVer>=1.06))
			m_SelectAllChecked.marshall(rpc_resp, "SelectAllChecked", "", "", "");
		if ((clientVer==-1.0 || clientVer>=1.07))
			m_AutoUpdate.marshall(rpc_resp, "AutoUpdate", "", "", "");
		if ((clientVer==-1.0 || clientVer>=1.12))
			m_AcceptLanguage.marshall(rpc_resp, "AcceptLanguage", "", "", "");
	}
}


void CMetricsResponse::copy(CMetricsResponse &from)
{
	m_FieldInformation.copy(from.m_FieldInformation);
	m_Metrics.copy(from.m_Metrics);
	m_AutoRefresh.copy(from.m_AutoRefresh);
	m_Cluster.copy(from.m_Cluster);
	m_SelectAllChecked.copy(from.m_SelectAllChecked);
	m_AutoUpdate.copy(from.m_AutoUpdate);
	m_AcceptLanguage.copy(from.m_AcceptLanguage);
}


void CMetricsResponse::copy(IConstMetricsResponse &ifrom)
{
	setFieldInformation(ifrom.getFieldInformation());
	setMetrics(ifrom.getMetrics());
	setAutoRefresh(ifrom.getAutoRefresh());
	setCluster(ifrom.getCluster());
	setSelectAllChecked(ifrom.getSelectAllChecked());
	setAutoUpdate(ifrom.getAutoUpdate());
	setAcceptLanguage(ifrom.getAcceptLanguage());
}


void CMetricsResponse::getAttributes(IProperties &attributes)
{
}


void CMetricsResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
		double clientVer = ctx ? ctx->getClientVersion() : -1;
		m_FieldInformation.toStr(ctx, buffer, "FieldInformation", "", false, "", "");
		m_Metrics.toStr(ctx, buffer, "Metrics", "", false, "", "");
		m_AutoRefresh.toStr(ctx, buffer, "AutoRefresh", "", false, "", "");
		if ((clientVer==-1.0 || clientVer>=1.02))
			m_Cluster.toStr(ctx, buffer, "Cluster", "", false, "", "");
		if ((clientVer==-1.0 || clientVer>=1.06))
			m_SelectAllChecked.toStr(ctx, buffer, "SelectAllChecked", "", false, "", "");
		if ((clientVer==-1.0 || clientVer>=1.07))
			m_AutoUpdate.toStr(ctx, buffer, "AutoUpdate", "", false, "", "");
		if ((clientVer==-1.0 || clientVer>=1.12))
			m_AcceptLanguage.toStr(ctx, buffer, "AcceptLanguage", "", false, "", "");
	}
}


void CMetricsResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CMetricsResponse::serializer(IEspContext* ctx, IConstMetricsResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<MetricsResponse>");
	double clientVer = ctx ? ctx->getClientVersion() : -1;
	// field FieldInformation
	{
		const char* s = src.getFieldInformation();
		if (s && *s)
		buffer.appendf("<FieldInformation>%s</FieldInformation>",s);
	}
	// field Metrics
	{
		const char* s = src.getMetrics();
		if (s && *s)
		buffer.appendf("<Metrics>%s</Metrics>",s);
	}
	// field AutoRefresh
	{
		int n = src.getAutoRefresh();
		if (n)
			buffer.appendf("<AutoRefresh>%d</AutoRefresh>", n);
	}
	// field Cluster
	if ((clientVer==-1.0 || clientVer>=1.02))
	{
		const char* s = src.getCluster();
		if (s && *s)
		buffer.appendf("<Cluster>%s</Cluster>",s);
	}
	// field SelectAllChecked
	if ((clientVer==-1.0 || clientVer>=1.06))
	{
		bool b = src.getSelectAllChecked();
		if (b)
			buffer.appendf("<SelectAllChecked>1</SelectAllChecked>");
	}
	// field AutoUpdate
	if ((clientVer==-1.0 || clientVer>=1.07))
	{
		bool b = src.getAutoUpdate();
		if (b)
			buffer.appendf("<AutoUpdate>1</AutoUpdate>");
	}
	// field AcceptLanguage
	if ((clientVer==-1.0 || clientVer>=1.12))
	{
		const char* s = src.getAcceptLanguage();
		if (s && *s)
		buffer.appendf("<AcceptLanguage>%s</AcceptLanguage>",s);
	}
	if (keepRootTag)
		buffer.append("</MetricsResponse>");
}

bool CMetricsResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
		hasValue |= m_FieldInformation.unmarshall(rpc_request, "FieldInformation", basepath);
		hasValue |= m_Metrics.unmarshall(rpc_request, "Metrics", basepath);
		hasValue |= m_AutoRefresh.unmarshall(rpc_request, "AutoRefresh", basepath);
		hasValue |= m_Cluster.unmarshall(rpc_request, "Cluster", basepath);
		hasValue |= m_SelectAllChecked.unmarshall(rpc_request, "SelectAllChecked", basepath);
		hasValue |= m_AutoUpdate.unmarshall(rpc_request, "AutoUpdate", basepath);
		hasValue |= m_AcceptLanguage.unmarshall(rpc_request, "AcceptLanguage", basepath);
	}
	return hasValue;
}

bool CMetricsResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_FieldInformation.unmarshall(ctx, soapval, "FieldInformation");
	hasValue |= m_Metrics.unmarshall(ctx, soapval, "Metrics");
	hasValue |= m_AutoRefresh.unmarshall(ctx, soapval, "AutoRefresh");
	hasValue |= m_Cluster.unmarshall(ctx, soapval, "Cluster");
	hasValue |= m_SelectAllChecked.unmarshall(ctx, soapval, "SelectAllChecked");
	hasValue |= m_AutoUpdate.unmarshall(ctx, soapval, "AutoUpdate");
	hasValue |= m_AcceptLanguage.unmarshall(ctx, soapval, "AcceptLanguage");
	return hasValue;
}

bool CMetricsResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_FieldInformation.unmarshall(ctx, params, attachments, "FieldInformation", basepath);
	hasValue |= m_Metrics.unmarshall(ctx, params, attachments, "Metrics", basepath);
	hasValue |= m_AutoRefresh.unmarshall(ctx, params, attachments, "AutoRefresh", basepath);
	hasValue |= m_Cluster.unmarshall(ctx, params, attachments, "Cluster", basepath);
	hasValue |= m_SelectAllChecked.unmarshall(ctx, params, attachments, "SelectAllChecked", basepath);
	hasValue |= m_AutoUpdate.unmarshall(ctx, params, attachments, "AutoUpdate", basepath);
	hasValue |= m_AcceptLanguage.unmarshall(ctx, params, attachments, "AcceptLanguage", basepath);
	return hasValue;
}

const char * CMetricsResponse::getFieldInformation() { return m_FieldInformation.query();}
const char * CMetricsResponse::getMetrics() { return m_Metrics.query();}
int CMetricsResponse::getAutoRefresh() { return m_AutoRefresh;}
const char * CMetricsResponse::getCluster() { return m_Cluster.query();}
bool CMetricsResponse::getSelectAllChecked() { return m_SelectAllChecked;}
bool CMetricsResponse::getAutoUpdate() { return m_AutoUpdate;}
const char * CMetricsResponse::getAcceptLanguage() { return m_AcceptLanguage.query();}
void CMetricsResponse::setFieldInformation(const char * val){ m_FieldInformation.set(val); }
void CMetricsResponse::setMetrics(const char * val){ m_Metrics.set(val); }
void CMetricsResponse::setAutoRefresh(int val){ m_AutoRefresh=val; }
void CMetricsResponse::setCluster(const char * val){ m_Cluster.set(val); }
void CMetricsResponse::setSelectAllChecked(bool val){ m_SelectAllChecked=val; }
void CMetricsResponse::setAutoUpdate(bool val){ m_AutoUpdate=val; }
void CMetricsResponse::setAcceptLanguage(const char * val){ m_AcceptLanguage.set(val); }
extern "C"  IEspMetricsResponse *createMetricsResponse(const char *serv){return ((IEspMetricsResponse *)new CMetricsResponse(serv));}
extern "C"  IClientMetricsResponse *createClientMetricsResponse(const char *serv){return ((IClientMetricsResponse *)new CMetricsResponse(serv));}

//=======================================================
// class CRemoteExecResult Implementation
//=======================================================

CRemoteExecResult::CRemoteExecResult(const char *serviceName, IRpcMessageBinding *init)
	: m_ClusterType(nilIgnore),m_AddressOrig(nilIgnore),m_Address(nilIgnore),m_Response(nilIgnore),m_ResultCode(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("RemoteExecResult");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CRemoteExecResult::CRemoteExecResult(const char *serviceName, const char *bc)
	: m_ClusterType(nilIgnore),m_AddressOrig(nilIgnore),m_Address(nilIgnore),m_Response(nilIgnore),m_ResultCode(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("RemoteExecResult");
}

StringBuffer &CRemoteExecResult::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:complexType name=\"%s\">\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"ClusterType\" type=\"xsd:string\"/>\n");
		if (!context.suppressed("RemoteExecResult","AddressOrig")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"AddressOrig\" type=\"xsd:string\"/>\n");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Address\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Response\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"ResultCode\" type=\"xsd:int\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType>\n");
		}
	}
	return schema;
}

void CRemoteExecResult::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CRemoteExecResult::getMapInfo(IMapInfo& info, BoolHash& added)
{
	info.addMinVersion("RemoteExecResult","AddressOrig",1.01);
}

StringBuffer &CRemoteExecResult::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("ClusterType");
	form.appendf("  <tr><td><b>ClusterType: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (!context.suppressed("RemoteExecResult","AddressOrig")) {
		extfix.clear();
		if (prefix && *prefix)
			extfix.append(prefix).append(".");
		extfix.append("AddressOrig");
		form.appendf("  <tr><td><b>AddressOrig: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
		form.append("</td></tr>\n");
	}
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Address");
	form.appendf("  <tr><td><b>Address: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Response");
	form.appendf("  <tr><td><b>Response: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix) extfix.append(prefix).append(".");
		extfix.append("ResultCode");
	form.appendf("  <tr><td><b>ResultCode: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CRemoteExecResult::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CRemoteExecResult::serialize(IRpcMessage& rpc_resp)
{
	IEspContext* ctx = rpc_resp.queryContext();
	double clientVer= ctx ? ctx->getClientVersion() : -1; /* no context gets everything */
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_ClusterType.marshall(rpc_resp, "ClusterType", "", "", "");
	if ((clientVer==-1.0 || clientVer>=1.01))
		m_AddressOrig.marshall(rpc_resp, "AddressOrig", "", "", "");
	m_Address.marshall(rpc_resp, "Address", "", "", "");
	m_Response.marshall(rpc_resp, "Response", "", "", "");
	m_ResultCode.marshall(rpc_resp, "ResultCode", "", "", "");
}


void CRemoteExecResult::copy(CRemoteExecResult &from)
{
	m_ClusterType.copy(from.m_ClusterType);
	m_AddressOrig.copy(from.m_AddressOrig);
	m_Address.copy(from.m_Address);
	m_Response.copy(from.m_Response);
	m_ResultCode.copy(from.m_ResultCode);
}


void CRemoteExecResult::copy(IConstRemoteExecResult &ifrom)
{
	setClusterType(ifrom.getClusterType());
	setAddressOrig(ifrom.getAddressOrig());
	setAddress(ifrom.getAddress());
	setResponse(ifrom.getResponse());
	setResultCode(ifrom.getResultCode());
}


void CRemoteExecResult::getAttributes(IProperties &attributes)
{
}


void CRemoteExecResult::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	double clientVer = ctx ? ctx->getClientVersion() : -1;
	m_ClusterType.toStr(ctx, buffer, "ClusterType", "", true, "", "");
	if ((clientVer==-1.0 || clientVer>=1.01))
		m_AddressOrig.toStr(ctx, buffer, "AddressOrig", "", true, "", "");
	m_Address.toStr(ctx, buffer, "Address", "", true, "", "");
	m_Response.toStr(ctx, buffer, "Response", "", true, "", "");
	m_ResultCode.toStr(ctx, buffer, "ResultCode", "", true, "", "");
}


void CRemoteExecResult::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CRemoteExecResult::serializer(IEspContext* ctx, IConstRemoteExecResult &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<RemoteExecResult>");
	double clientVer = ctx ? ctx->getClientVersion() : -1;
	// field ClusterType
	{
		const char* s = src.getClusterType();
		if (s && *s)
		{
			buffer.append("<ClusterType>");
			encodeUtf8XML(s,buffer);
			buffer.append("</ClusterType>");
		}
	}
	// field AddressOrig
	if ((clientVer==-1.0 || clientVer>=1.01))
	{
		const char* s = src.getAddressOrig();
		if (s && *s)
		{
			buffer.append("<AddressOrig>");
			encodeUtf8XML(s,buffer);
			buffer.append("</AddressOrig>");
		}
	}
	// field Address
	{
		const char* s = src.getAddress();
		if (s && *s)
		{
			buffer.append("<Address>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Address>");
		}
	}
	// field Response
	{
		const char* s = src.getResponse();
		if (s && *s)
		{
			buffer.append("<Response>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Response>");
		}
	}
	// field ResultCode
	{
		int n = src.getResultCode();
		if (n)
			buffer.appendf("<ResultCode>%d</ResultCode>", n);
	}
	if (keepRootTag)
		buffer.append("</RemoteExecResult>");
}

bool CRemoteExecResult::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_ClusterType.unmarshall(rpc_request, "ClusterType", basepath);
	hasValue |= m_AddressOrig.unmarshall(rpc_request, "AddressOrig", basepath);
	hasValue |= m_Address.unmarshall(rpc_request, "Address", basepath);
	hasValue |= m_Response.unmarshall(rpc_request, "Response", basepath);
	hasValue |= m_ResultCode.unmarshall(rpc_request, "ResultCode", basepath);
	return hasValue;
}

bool CRemoteExecResult::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_ClusterType.unmarshall(ctx, soapval, "ClusterType");
	hasValue |= m_AddressOrig.unmarshall(ctx, soapval, "AddressOrig");
	hasValue |= m_Address.unmarshall(ctx, soapval, "Address");
	hasValue |= m_Response.unmarshall(ctx, soapval, "Response");
	hasValue |= m_ResultCode.unmarshall(ctx, soapval, "ResultCode");
	return hasValue;
}

bool CRemoteExecResult::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_ClusterType.unmarshall(ctx, params, attachments, "ClusterType", basepath);
	hasValue |= m_AddressOrig.unmarshall(ctx, params, attachments, "AddressOrig", basepath);
	hasValue |= m_Address.unmarshall(ctx, params, attachments, "Address", basepath);
	hasValue |= m_Response.unmarshall(ctx, params, attachments, "Response", basepath);
	hasValue |= m_ResultCode.unmarshall(ctx, params, attachments, "ResultCode", basepath);
	return hasValue;
}

const char * CRemoteExecResult::getClusterType() { return m_ClusterType.query();}
const char * CRemoteExecResult::getAddressOrig() { return m_AddressOrig.query();}
const char * CRemoteExecResult::getAddress() { return m_Address.query();}
const char * CRemoteExecResult::getResponse() { return m_Response.query();}
int CRemoteExecResult::getResultCode() { return m_ResultCode;}
void CRemoteExecResult::setClusterType(const char * val){ m_ClusterType.set(val); }
void CRemoteExecResult::setAddressOrig(const char * val){ m_AddressOrig.set(val); }
void CRemoteExecResult::setAddress(const char * val){ m_Address.set(val); }
void CRemoteExecResult::setResponse(const char * val){ m_Response.set(val); }
void CRemoteExecResult::setResultCode(int val){ m_ResultCode=val; }
extern "C"  IEspRemoteExecResult *createRemoteExecResult(const char *serv, const char *msgname){return ((IEspRemoteExecResult *)new CRemoteExecResult(serv /*, msgname*/));}
extern "C"  IClientRemoteExecResult *createClientRemoteExecResult(const char *serv, const char *msgname){return ((IClientRemoteExecResult *)new CRemoteExecResult(serv /*, msgname*/));}

//=======================================================
// class CStartStopBeginRequest Implementation
//=======================================================

CStartStopBeginRequest::CStartStopBeginRequest(const char *serviceName, IRpcMessageBinding *init)
	: m_Addresses(nilIgnore),m_Key1(nilIgnore),m_Key2(nilIgnore),m_Stop(nilIgnore),m_MemThreshold(nilIgnore),m_DiskThreshold(nilIgnore),m_CpuThreshold(nilIgnore),m_AutoRefresh(nilIgnore),m_MemThresholdType(nilIgnore),m_DiskThresholdType(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("StartStopBeginRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CStartStopBeginRequest::CStartStopBeginRequest(const char *serviceName, const char *bc)
	: m_Addresses(nilIgnore),m_Key1(nilIgnore),m_Key2(nilIgnore),m_Stop(nilIgnore),m_MemThreshold(nilIgnore),m_DiskThreshold(nilIgnore),m_CpuThreshold(nilIgnore),m_AutoRefresh(nilIgnore),m_MemThresholdType(nilIgnore),m_DiskThresholdType(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("StartStopBeginRequest");
}

CStartStopBeginRequest::CStartStopBeginRequest(const char *serviceName, IRpcMessage* rpcmsg)
	: m_Addresses(nilIgnore),m_Key1(nilIgnore),m_Key2(nilIgnore),m_Stop(nilIgnore),m_MemThreshold(nilIgnore),m_DiskThreshold(nilIgnore),m_CpuThreshold(nilIgnore),m_AutoRefresh(nilIgnore),m_MemThresholdType(nilIgnore),m_DiskThresholdType(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("StartStopBeginRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CStartStopBeginRequest::CStartStopBeginRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_Addresses(nilIgnore),m_Key1(nilIgnore),m_Key2(nilIgnore),m_Stop(nilIgnore),m_MemThreshold(nilIgnore),m_DiskThreshold(nilIgnore),m_CpuThreshold(nilIgnore),m_AutoRefresh(nilIgnore),m_MemThresholdType(nilIgnore),m_DiskThresholdType(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("StartStopBeginRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CStartStopBeginRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Addresses\" type=\"tns:EspStringArray\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Key1\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Key2\" type=\"xsd:string\"");
		if (context.queryOptions()&ESPCTX_ALL_ANNOTATION)
			schema.append("> <xsd:annotation><xsd:appinfo><form formType=\"password\" formCols=\"20\"/></xsd:appinfo></xsd:annotation></xsd:element>\n");
		else
			schema.append("/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Stop\" type=\"xsd:boolean\"/>\n");
		if (!context.suppressed("StartStopBeginRequest","MemThreshold")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"MemThreshold\" type=\"xsd:int\"/>\n");
		}
		if (!context.suppressed("StartStopBeginRequest","DiskThreshold")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"DiskThreshold\" type=\"xsd:int\"/>\n");
		}
		if (!context.suppressed("StartStopBeginRequest","CpuThreshold")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"CpuThreshold\" type=\"xsd:int\"/>\n");
		}
		if (!context.suppressed("StartStopBeginRequest","AutoRefresh")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"AutoRefresh\" type=\"xsd:int\"/>\n");
		}
		if (!context.suppressed("StartStopBeginRequest","MemThresholdType")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"MemThresholdType\" type=\"xsd:string\"/>\n");
		}
		if (!context.suppressed("StartStopBeginRequest","DiskThresholdType")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"DiskThresholdType\" type=\"xsd:string\"/>\n");
		}
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	if (added.getValue("EspStringArray")==NULL) {
		addEspNativeArray(schema,"string","EspStringArray");
		added.setValue("EspStringArray",1);
	}
	return schema;
}

void CStartStopBeginRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CStartStopBeginRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
	info.addMinVersion("StartStopBeginRequest","MemThreshold",1.08);
	info.addMinVersion("StartStopBeginRequest","DiskThreshold",1.08);
	info.addMinVersion("StartStopBeginRequest","CpuThreshold",1.08);
	info.addMinVersion("StartStopBeginRequest","AutoRefresh",1.08);
	info.addMinVersion("StartStopBeginRequest","MemThresholdType",1.08);
	info.addMinVersion("StartStopBeginRequest","DiskThresholdType",1.08);
}

StringBuffer &CStartStopBeginRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Addresses");
	form.appendf("<tr><td><b>Addresses: </b></td><td>");
	form.appendf("<textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea>", extfix.str());
	form.append("</td></tr>");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Key1");
	form.appendf("  <tr><td><b>Key1: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Key2");
	form.appendf("  <tr><td><b>Key2: </b></td><td><input type=\"password\" name=\"%s\" size=\"20\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Stop");
	
	form.appendf("  <tr><td><b>Stop? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	if (!context.suppressed("StartStopBeginRequest","MemThreshold")) {
		extfix.clear();
		if (prefix && *prefix) extfix.append(prefix).append(".");
			extfix.append("MemThreshold");
		form.appendf("  <tr><td><b>MemThreshold: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
		form.append("</td></tr>\n");
	}
	if (!context.suppressed("StartStopBeginRequest","DiskThreshold")) {
		extfix.clear();
		if (prefix && *prefix) extfix.append(prefix).append(".");
			extfix.append("DiskThreshold");
		form.appendf("  <tr><td><b>DiskThreshold: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
		form.append("</td></tr>\n");
	}
	if (!context.suppressed("StartStopBeginRequest","CpuThreshold")) {
		extfix.clear();
		if (prefix && *prefix) extfix.append(prefix).append(".");
			extfix.append("CpuThreshold");
		form.appendf("  <tr><td><b>CpuThreshold: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
		form.append("</td></tr>\n");
	}
	if (!context.suppressed("StartStopBeginRequest","AutoRefresh")) {
		extfix.clear();
		if (prefix && *prefix) extfix.append(prefix).append(".");
			extfix.append("AutoRefresh");
		form.appendf("  <tr><td><b>AutoRefresh: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
		form.append("</td></tr>\n");
	}
	if (!context.suppressed("StartStopBeginRequest","MemThresholdType")) {
		extfix.clear();
		if (prefix && *prefix)
			extfix.append(prefix).append(".");
		extfix.append("MemThresholdType");
		form.appendf("  <tr><td><b>MemThresholdType: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
		form.append("</td></tr>\n");
	}
	if (!context.suppressed("StartStopBeginRequest","DiskThresholdType")) {
		extfix.clear();
		if (prefix && *prefix)
			extfix.append(prefix).append(".");
		extfix.append("DiskThresholdType");
		form.appendf("  <tr><td><b>DiskThresholdType: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
		form.append("</td></tr>\n");
	}
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CStartStopBeginRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CStartStopBeginRequest::serialize(IRpcMessage& rpc_resp)
{
	IEspContext* ctx = rpc_resp.queryContext();
	double clientVer= ctx ? ctx->getClientVersion() : -1; /* no context gets everything */
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_Addresses.marshall(rpc_resp, "Addresses", "Item");
	m_Key1.marshall(rpc_resp, "Key1", "", "", "");
	m_Key2.marshall(rpc_resp, "Key2", "", "", "");
	m_Stop.marshall(rpc_resp, "Stop", "", "", "");
	if ((clientVer==-1.0 || clientVer>=1.08))
		m_MemThreshold.marshall(rpc_resp, "MemThreshold", "", "", "");
	if ((clientVer==-1.0 || clientVer>=1.08))
		m_DiskThreshold.marshall(rpc_resp, "DiskThreshold", "", "", "");
	if ((clientVer==-1.0 || clientVer>=1.08))
		m_CpuThreshold.marshall(rpc_resp, "CpuThreshold", "", "", "");
	if ((clientVer==-1.0 || clientVer>=1.08))
		m_AutoRefresh.marshall(rpc_resp, "AutoRefresh", "", "", "");
	if ((clientVer==-1.0 || clientVer>=1.08))
		m_MemThresholdType.marshall(rpc_resp, "MemThresholdType", "", "", "");
	if ((clientVer==-1.0 || clientVer>=1.08))
		m_DiskThresholdType.marshall(rpc_resp, "DiskThresholdType", "", "", "");
}


void CStartStopBeginRequest::copy(CStartStopBeginRequest &from)
{
	m_Addresses.copy(from.m_Addresses);
	m_Key1.copy(from.m_Key1);
	m_Key2.copy(from.m_Key2);
	m_Stop.copy(from.m_Stop);
	m_MemThreshold.copy(from.m_MemThreshold);
	m_DiskThreshold.copy(from.m_DiskThreshold);
	m_CpuThreshold.copy(from.m_CpuThreshold);
	m_AutoRefresh.copy(from.m_AutoRefresh);
	m_MemThresholdType.copy(from.m_MemThresholdType);
	m_DiskThresholdType.copy(from.m_DiskThresholdType);
}


void CStartStopBeginRequest::copy(IConstStartStopBeginRequest &ifrom)
{
	setAddresses(ifrom.getAddresses());
	setKey1(ifrom.getKey1());
	setKey2(ifrom.getKey2());
	setStop(ifrom.getStop());
	setMemThreshold(ifrom.getMemThreshold());
	setDiskThreshold(ifrom.getDiskThreshold());
	setCpuThreshold(ifrom.getCpuThreshold());
	setAutoRefresh(ifrom.getAutoRefresh());
	setMemThresholdType(ifrom.getMemThresholdType());
	setDiskThresholdType(ifrom.getDiskThresholdType());
}


void CStartStopBeginRequest::getAttributes(IProperties &attributes)
{
}


void CStartStopBeginRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	double clientVer = ctx ? ctx->getClientVersion() : -1;
	m_Addresses.toStr(ctx, buffer, "Addresses", "Item");
	m_Key1.toStr(ctx, buffer, "Key1", "", true, "", "");
	m_Key2.toStr(ctx, buffer, "Key2", "", true, "", "");
	m_Stop.toStr(ctx, buffer, "Stop", "", true, "", "");
	if ((clientVer==-1.0 || clientVer>=1.08))
		m_MemThreshold.toStr(ctx, buffer, "MemThreshold", "", true, "", "");
	if ((clientVer==-1.0 || clientVer>=1.08))
		m_DiskThreshold.toStr(ctx, buffer, "DiskThreshold", "", true, "", "");
	if ((clientVer==-1.0 || clientVer>=1.08))
		m_CpuThreshold.toStr(ctx, buffer, "CpuThreshold", "", true, "", "");
	if ((clientVer==-1.0 || clientVer>=1.08))
		m_AutoRefresh.toStr(ctx, buffer, "AutoRefresh", "", true, "", "");
	if ((clientVer==-1.0 || clientVer>=1.08))
		m_MemThresholdType.toStr(ctx, buffer, "MemThresholdType", "", true, "", "");
	if ((clientVer==-1.0 || clientVer>=1.08))
		m_DiskThresholdType.toStr(ctx, buffer, "DiskThresholdType", "", true, "", "");
}


void CStartStopBeginRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CStartStopBeginRequest::serializer(IEspContext* ctx, IConstStartStopBeginRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<StartStopBeginRequest>");
	double clientVer = ctx ? ctx->getClientVersion() : -1;
	// field Addresses
	{
		StringArray& v = src.getAddresses();
		if (v.length()>0)
			buffer.append("<Addresses>");
		for (size32_t i=0;i<v.length();i++)
			buffer.appendf("<Item>%s</Item>",v.item(i));
		if (v.length()>0)
			buffer.append("</Addresses>");
	}
	// field Key1
	{
		const char* s = src.getKey1();
		if (s && *s)
		{
			buffer.append("<Key1>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Key1>");
		}
	}
	// field Key2
	{
		const char* s = src.getKey2();
		if (s && *s)
		{
			buffer.append("<Key2>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Key2>");
		}
	}
	// field Stop
	{
		bool b = src.getStop();
		if (b)
			buffer.appendf("<Stop>1</Stop>");
	}
	// field MemThreshold
	if ((clientVer==-1.0 || clientVer>=1.08))
	{
		int n = src.getMemThreshold();
		if (n)
			buffer.appendf("<MemThreshold>%d</MemThreshold>", n);
	}
	// field DiskThreshold
	if ((clientVer==-1.0 || clientVer>=1.08))
	{
		int n = src.getDiskThreshold();
		if (n)
			buffer.appendf("<DiskThreshold>%d</DiskThreshold>", n);
	}
	// field CpuThreshold
	if ((clientVer==-1.0 || clientVer>=1.08))
	{
		int n = src.getCpuThreshold();
		if (n)
			buffer.appendf("<CpuThreshold>%d</CpuThreshold>", n);
	}
	// field AutoRefresh
	if ((clientVer==-1.0 || clientVer>=1.08))
	{
		int n = src.getAutoRefresh();
		if (n)
			buffer.appendf("<AutoRefresh>%d</AutoRefresh>", n);
	}
	// field MemThresholdType
	if ((clientVer==-1.0 || clientVer>=1.08))
	{
		const char* s = src.getMemThresholdType();
		if (s && *s)
		{
			buffer.append("<MemThresholdType>");
			encodeUtf8XML(s,buffer);
			buffer.append("</MemThresholdType>");
		}
	}
	// field DiskThresholdType
	if ((clientVer==-1.0 || clientVer>=1.08))
	{
		const char* s = src.getDiskThresholdType();
		if (s && *s)
		{
			buffer.append("<DiskThresholdType>");
			encodeUtf8XML(s,buffer);
			buffer.append("</DiskThresholdType>");
		}
	}
	if (keepRootTag)
		buffer.append("</StartStopBeginRequest>");
}

bool CStartStopBeginRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_Addresses.unmarshall(rpc_request, "Addresses", basepath);
	hasValue |= m_Key1.unmarshall(rpc_request, "Key1", basepath);
	hasValue |= m_Key2.unmarshall(rpc_request, "Key2", basepath);
	hasValue |= m_Stop.unmarshall(rpc_request, "Stop", basepath);
	hasValue |= m_MemThreshold.unmarshall(rpc_request, "MemThreshold", basepath);
	hasValue |= m_DiskThreshold.unmarshall(rpc_request, "DiskThreshold", basepath);
	hasValue |= m_CpuThreshold.unmarshall(rpc_request, "CpuThreshold", basepath);
	hasValue |= m_AutoRefresh.unmarshall(rpc_request, "AutoRefresh", basepath);
	hasValue |= m_MemThresholdType.unmarshall(rpc_request, "MemThresholdType", basepath);
	hasValue |= m_DiskThresholdType.unmarshall(rpc_request, "DiskThresholdType", basepath);
	return hasValue;
}

bool CStartStopBeginRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Addresses.unmarshall(ctx, soapval, "Addresses");
	hasValue |= m_Key1.unmarshall(ctx, soapval, "Key1");
	hasValue |= m_Key2.unmarshall(ctx, soapval, "Key2");
	hasValue |= m_Stop.unmarshall(ctx, soapval, "Stop");
	hasValue |= m_MemThreshold.unmarshall(ctx, soapval, "MemThreshold");
	hasValue |= m_DiskThreshold.unmarshall(ctx, soapval, "DiskThreshold");
	hasValue |= m_CpuThreshold.unmarshall(ctx, soapval, "CpuThreshold");
	hasValue |= m_AutoRefresh.unmarshall(ctx, soapval, "AutoRefresh");
	hasValue |= m_MemThresholdType.unmarshall(ctx, soapval, "MemThresholdType");
	hasValue |= m_DiskThresholdType.unmarshall(ctx, soapval, "DiskThresholdType");
	return hasValue;
}

bool CStartStopBeginRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Addresses.unmarshall(ctx, params, attachments, "Addresses", basepath);
	hasValue |= m_Key1.unmarshall(ctx, params, attachments, "Key1", basepath);
	hasValue |= m_Key2.unmarshall(ctx, params, attachments, "Key2", basepath);
	hasValue |= m_Stop.unmarshall(ctx, params, attachments, "Stop", basepath);
	hasValue |= m_MemThreshold.unmarshall(ctx, params, attachments, "MemThreshold", basepath);
	hasValue |= m_DiskThreshold.unmarshall(ctx, params, attachments, "DiskThreshold", basepath);
	hasValue |= m_CpuThreshold.unmarshall(ctx, params, attachments, "CpuThreshold", basepath);
	hasValue |= m_AutoRefresh.unmarshall(ctx, params, attachments, "AutoRefresh", basepath);
	hasValue |= m_MemThresholdType.unmarshall(ctx, params, attachments, "MemThresholdType", basepath);
	hasValue |= m_DiskThresholdType.unmarshall(ctx, params, attachments, "DiskThresholdType", basepath);
	return hasValue;
}

StringArray & CStartStopBeginRequest::getAddresses() { return (StringArray &) m_Addresses; }
const char * CStartStopBeginRequest::getKey1() { return m_Key1.query();}
const char * CStartStopBeginRequest::getKey2() { return m_Key2.query();}
bool CStartStopBeginRequest::getStop() { return m_Stop;}
int CStartStopBeginRequest::getMemThreshold() { return m_MemThreshold;}
int CStartStopBeginRequest::getDiskThreshold() { return m_DiskThreshold;}
int CStartStopBeginRequest::getCpuThreshold() { return m_CpuThreshold;}
int CStartStopBeginRequest::getAutoRefresh() { return m_AutoRefresh;}
const char * CStartStopBeginRequest::getMemThresholdType() { return m_MemThresholdType.query();}
const char * CStartStopBeginRequest::getDiskThresholdType() { return m_DiskThresholdType.query();}
void CStartStopBeginRequest::setAddresses(StringArray &val){ m_Addresses->kill();  CloneArray(m_Addresses.getValue(), val); }
void CStartStopBeginRequest::setKey1(const char * val){ m_Key1.set(val); }
void CStartStopBeginRequest::setKey2(const char * val){ m_Key2.set(val); }
void CStartStopBeginRequest::setStop(bool val){ m_Stop=val; }
void CStartStopBeginRequest::setMemThreshold(int val){ m_MemThreshold=val; }
void CStartStopBeginRequest::setDiskThreshold(int val){ m_DiskThreshold=val; }
void CStartStopBeginRequest::setCpuThreshold(int val){ m_CpuThreshold=val; }
void CStartStopBeginRequest::setAutoRefresh(int val){ m_AutoRefresh=val; }
void CStartStopBeginRequest::setMemThresholdType(const char * val){ m_MemThresholdType.set(val); }
void CStartStopBeginRequest::setDiskThresholdType(const char * val){ m_DiskThresholdType.set(val); }
extern "C"  IEspStartStopBeginRequest *createStartStopBeginRequest(const char *serv){return ((IEspStartStopBeginRequest *)new CStartStopBeginRequest(serv));}
extern "C"  IClientStartStopBeginRequest *createClientStartStopBeginRequest(const char *serv){return ((IClientStartStopBeginRequest *)new CStartStopBeginRequest(serv));}

//=======================================================
// class CStartStopBeginResponse Implementation
//=======================================================

CStartStopBeginResponse::CStartStopBeginResponse(const char *serviceName, IRpcMessageBinding *init)
	: m_Addresses(nilIgnore),m_Key1(nilIgnore),m_Key2(nilIgnore),m_Stop(nilIgnore),m_MemThreshold(nilIgnore),m_DiskThreshold(nilIgnore),m_CpuThreshold(nilIgnore),m_AutoRefresh(nilIgnore),m_MemThresholdType(nilIgnore),m_DiskThresholdType(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("StartStopBeginResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CStartStopBeginResponse::CStartStopBeginResponse(const char *serviceName, const char *bc)
	: m_Addresses(nilIgnore),m_Key1(nilIgnore),m_Key2(nilIgnore),m_Stop(nilIgnore),m_MemThreshold(nilIgnore),m_DiskThreshold(nilIgnore),m_CpuThreshold(nilIgnore),m_AutoRefresh(nilIgnore),m_MemThresholdType(nilIgnore),m_DiskThresholdType(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("StartStopBeginResponse");
}

CStartStopBeginResponse::CStartStopBeginResponse(const char *serviceName, IRpcMessage* rpcmsg)
	: m_Addresses(nilIgnore),m_Key1(nilIgnore),m_Key2(nilIgnore),m_Stop(nilIgnore),m_MemThreshold(nilIgnore),m_DiskThreshold(nilIgnore),m_CpuThreshold(nilIgnore),m_AutoRefresh(nilIgnore),m_MemThresholdType(nilIgnore),m_DiskThresholdType(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("StartStopBeginResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CStartStopBeginResponse::CStartStopBeginResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_Addresses(nilIgnore),m_Key1(nilIgnore),m_Key2(nilIgnore),m_Stop(nilIgnore),m_MemThreshold(nilIgnore),m_DiskThreshold(nilIgnore),m_CpuThreshold(nilIgnore),m_AutoRefresh(nilIgnore),m_MemThresholdType(nilIgnore),m_DiskThresholdType(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("StartStopBeginResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CStartStopBeginResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		schema.append("<xsd:element name=\"Exceptions\" type=\"tns:ArrayOfEspException\" minOccurs=\"0\" maxOccurs=\"1\"/>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Addresses\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Key1\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Key2\" type=\"xsd:string\"");
		if (context.queryOptions()&ESPCTX_ALL_ANNOTATION)
			schema.append("> <xsd:annotation><xsd:appinfo><form formType=\"password\" formCols=\"20\"/></xsd:appinfo></xsd:annotation></xsd:element>\n");
		else
			schema.append("/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Stop\" type=\"xsd:boolean\"/>\n");
		if (!context.suppressed("StartStopBeginResponse","MemThreshold")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"MemThreshold\" type=\"xsd:int\"/>\n");
		}
		if (!context.suppressed("StartStopBeginResponse","DiskThreshold")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"DiskThreshold\" type=\"xsd:int\"/>\n");
		}
		if (!context.suppressed("StartStopBeginResponse","CpuThreshold")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"CpuThreshold\" type=\"xsd:int\"/>\n");
		}
		if (!context.suppressed("StartStopBeginResponse","AutoRefresh")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"AutoRefresh\" type=\"xsd:int\"/>\n");
		}
		if (!context.suppressed("StartStopBeginResponse","MemThresholdType")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"MemThresholdType\" type=\"xsd:string\"/>\n");
		}
		if (!context.suppressed("StartStopBeginResponse","DiskThresholdType")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"DiskThresholdType\" type=\"xsd:string\"/>\n");
		}
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CStartStopBeginResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CStartStopBeginResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
	info.addMinVersion("StartStopBeginResponse","MemThreshold",1.08);
	info.addMinVersion("StartStopBeginResponse","DiskThreshold",1.08);
	info.addMinVersion("StartStopBeginResponse","CpuThreshold",1.08);
	info.addMinVersion("StartStopBeginResponse","AutoRefresh",1.08);
	info.addMinVersion("StartStopBeginResponse","MemThresholdType",1.08);
	info.addMinVersion("StartStopBeginResponse","DiskThresholdType",1.08);
}

StringBuffer &CStartStopBeginResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Addresses");
	form.appendf("  <tr><td><b>Addresses: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Key1");
	form.appendf("  <tr><td><b>Key1: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Key2");
	form.appendf("  <tr><td><b>Key2: </b></td><td><input type=\"password\" name=\"%s\" size=\"20\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Stop");
	
	form.appendf("  <tr><td><b>Stop? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	if (!context.suppressed("StartStopBeginResponse","MemThreshold")) {
		extfix.clear();
		if (prefix && *prefix) extfix.append(prefix).append(".");
			extfix.append("MemThreshold");
		form.appendf("  <tr><td><b>MemThreshold: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
		form.append("</td></tr>\n");
	}
	if (!context.suppressed("StartStopBeginResponse","DiskThreshold")) {
		extfix.clear();
		if (prefix && *prefix) extfix.append(prefix).append(".");
			extfix.append("DiskThreshold");
		form.appendf("  <tr><td><b>DiskThreshold: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
		form.append("</td></tr>\n");
	}
	if (!context.suppressed("StartStopBeginResponse","CpuThreshold")) {
		extfix.clear();
		if (prefix && *prefix) extfix.append(prefix).append(".");
			extfix.append("CpuThreshold");
		form.appendf("  <tr><td><b>CpuThreshold: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
		form.append("</td></tr>\n");
	}
	if (!context.suppressed("StartStopBeginResponse","AutoRefresh")) {
		extfix.clear();
		if (prefix && *prefix) extfix.append(prefix).append(".");
			extfix.append("AutoRefresh");
		form.appendf("  <tr><td><b>AutoRefresh: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
		form.append("</td></tr>\n");
	}
	if (!context.suppressed("StartStopBeginResponse","MemThresholdType")) {
		extfix.clear();
		if (prefix && *prefix)
			extfix.append(prefix).append(".");
		extfix.append("MemThresholdType");
		form.appendf("  <tr><td><b>MemThresholdType: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
		form.append("</td></tr>\n");
	}
	if (!context.suppressed("StartStopBeginResponse","DiskThresholdType")) {
		extfix.clear();
		if (prefix && *prefix)
			extfix.append(prefix).append(".");
		extfix.append("DiskThresholdType");
		form.appendf("  <tr><td><b>DiskThresholdType: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
		form.append("</td></tr>\n");
	}
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CStartStopBeginResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CStartStopBeginResponse::serialize(IRpcMessage& rpc_resp)
{
	IEspContext* ctx = rpc_resp.queryContext();
	double clientVer= ctx ? ctx->getClientVersion() : -1; /* no context gets everything */
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
		m_Addresses.marshall(rpc_resp, "Addresses", "", "", "");
		m_Key1.marshall(rpc_resp, "Key1", "", "", "");
		m_Key2.marshall(rpc_resp, "Key2", "", "", "");
		m_Stop.marshall(rpc_resp, "Stop", "", "", "");
		if ((clientVer==-1.0 || clientVer>=1.08))
			m_MemThreshold.marshall(rpc_resp, "MemThreshold", "", "", "");
		if ((clientVer==-1.0 || clientVer>=1.08))
			m_DiskThreshold.marshall(rpc_resp, "DiskThreshold", "", "", "");
		if ((clientVer==-1.0 || clientVer>=1.08))
			m_CpuThreshold.marshall(rpc_resp, "CpuThreshold", "", "", "");
		if ((clientVer==-1.0 || clientVer>=1.08))
			m_AutoRefresh.marshall(rpc_resp, "AutoRefresh", "", "", "");
		if ((clientVer==-1.0 || clientVer>=1.08))
			m_MemThresholdType.marshall(rpc_resp, "MemThresholdType", "", "", "");
		if ((clientVer==-1.0 || clientVer>=1.08))
			m_DiskThresholdType.marshall(rpc_resp, "DiskThresholdType", "", "", "");
	}
}


void CStartStopBeginResponse::copy(CStartStopBeginResponse &from)
{
	m_Addresses.copy(from.m_Addresses);
	m_Key1.copy(from.m_Key1);
	m_Key2.copy(from.m_Key2);
	m_Stop.copy(from.m_Stop);
	m_MemThreshold.copy(from.m_MemThreshold);
	m_DiskThreshold.copy(from.m_DiskThreshold);
	m_CpuThreshold.copy(from.m_CpuThreshold);
	m_AutoRefresh.copy(from.m_AutoRefresh);
	m_MemThresholdType.copy(from.m_MemThresholdType);
	m_DiskThresholdType.copy(from.m_DiskThresholdType);
}


void CStartStopBeginResponse::copy(IConstStartStopBeginResponse &ifrom)
{
	setAddresses(ifrom.getAddresses());
	setKey1(ifrom.getKey1());
	setKey2(ifrom.getKey2());
	setStop(ifrom.getStop());
	setMemThreshold(ifrom.getMemThreshold());
	setDiskThreshold(ifrom.getDiskThreshold());
	setCpuThreshold(ifrom.getCpuThreshold());
	setAutoRefresh(ifrom.getAutoRefresh());
	setMemThresholdType(ifrom.getMemThresholdType());
	setDiskThresholdType(ifrom.getDiskThresholdType());
}


void CStartStopBeginResponse::getAttributes(IProperties &attributes)
{
}


void CStartStopBeginResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
		double clientVer = ctx ? ctx->getClientVersion() : -1;
		m_Addresses.toStr(ctx, buffer, "Addresses", "", true, "", "");
		m_Key1.toStr(ctx, buffer, "Key1", "", true, "", "");
		m_Key2.toStr(ctx, buffer, "Key2", "", true, "", "");
		m_Stop.toStr(ctx, buffer, "Stop", "", true, "", "");
		if ((clientVer==-1.0 || clientVer>=1.08))
			m_MemThreshold.toStr(ctx, buffer, "MemThreshold", "", true, "", "");
		if ((clientVer==-1.0 || clientVer>=1.08))
			m_DiskThreshold.toStr(ctx, buffer, "DiskThreshold", "", true, "", "");
		if ((clientVer==-1.0 || clientVer>=1.08))
			m_CpuThreshold.toStr(ctx, buffer, "CpuThreshold", "", true, "", "");
		if ((clientVer==-1.0 || clientVer>=1.08))
			m_AutoRefresh.toStr(ctx, buffer, "AutoRefresh", "", true, "", "");
		if ((clientVer==-1.0 || clientVer>=1.08))
			m_MemThresholdType.toStr(ctx, buffer, "MemThresholdType", "", true, "", "");
		if ((clientVer==-1.0 || clientVer>=1.08))
			m_DiskThresholdType.toStr(ctx, buffer, "DiskThresholdType", "", true, "", "");
	}
}


void CStartStopBeginResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CStartStopBeginResponse::serializer(IEspContext* ctx, IConstStartStopBeginResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<StartStopBeginResponse>");
	double clientVer = ctx ? ctx->getClientVersion() : -1;
	// field Addresses
	{
		const char* s = src.getAddresses();
		if (s && *s)
		{
			buffer.append("<Addresses>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Addresses>");
		}
	}
	// field Key1
	{
		const char* s = src.getKey1();
		if (s && *s)
		{
			buffer.append("<Key1>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Key1>");
		}
	}
	// field Key2
	{
		const char* s = src.getKey2();
		if (s && *s)
		{
			buffer.append("<Key2>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Key2>");
		}
	}
	// field Stop
	{
		bool b = src.getStop();
		if (b)
			buffer.appendf("<Stop>1</Stop>");
	}
	// field MemThreshold
	if ((clientVer==-1.0 || clientVer>=1.08))
	{
		int n = src.getMemThreshold();
		if (n)
			buffer.appendf("<MemThreshold>%d</MemThreshold>", n);
	}
	// field DiskThreshold
	if ((clientVer==-1.0 || clientVer>=1.08))
	{
		int n = src.getDiskThreshold();
		if (n)
			buffer.appendf("<DiskThreshold>%d</DiskThreshold>", n);
	}
	// field CpuThreshold
	if ((clientVer==-1.0 || clientVer>=1.08))
	{
		int n = src.getCpuThreshold();
		if (n)
			buffer.appendf("<CpuThreshold>%d</CpuThreshold>", n);
	}
	// field AutoRefresh
	if ((clientVer==-1.0 || clientVer>=1.08))
	{
		int n = src.getAutoRefresh();
		if (n)
			buffer.appendf("<AutoRefresh>%d</AutoRefresh>", n);
	}
	// field MemThresholdType
	if ((clientVer==-1.0 || clientVer>=1.08))
	{
		const char* s = src.getMemThresholdType();
		if (s && *s)
		{
			buffer.append("<MemThresholdType>");
			encodeUtf8XML(s,buffer);
			buffer.append("</MemThresholdType>");
		}
	}
	// field DiskThresholdType
	if ((clientVer==-1.0 || clientVer>=1.08))
	{
		const char* s = src.getDiskThresholdType();
		if (s && *s)
		{
			buffer.append("<DiskThresholdType>");
			encodeUtf8XML(s,buffer);
			buffer.append("</DiskThresholdType>");
		}
	}
	if (keepRootTag)
		buffer.append("</StartStopBeginResponse>");
}

bool CStartStopBeginResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
		hasValue |= m_Addresses.unmarshall(rpc_request, "Addresses", basepath);
		hasValue |= m_Key1.unmarshall(rpc_request, "Key1", basepath);
		hasValue |= m_Key2.unmarshall(rpc_request, "Key2", basepath);
		hasValue |= m_Stop.unmarshall(rpc_request, "Stop", basepath);
		hasValue |= m_MemThreshold.unmarshall(rpc_request, "MemThreshold", basepath);
		hasValue |= m_DiskThreshold.unmarshall(rpc_request, "DiskThreshold", basepath);
		hasValue |= m_CpuThreshold.unmarshall(rpc_request, "CpuThreshold", basepath);
		hasValue |= m_AutoRefresh.unmarshall(rpc_request, "AutoRefresh", basepath);
		hasValue |= m_MemThresholdType.unmarshall(rpc_request, "MemThresholdType", basepath);
		hasValue |= m_DiskThresholdType.unmarshall(rpc_request, "DiskThresholdType", basepath);
	}
	return hasValue;
}

bool CStartStopBeginResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Addresses.unmarshall(ctx, soapval, "Addresses");
	hasValue |= m_Key1.unmarshall(ctx, soapval, "Key1");
	hasValue |= m_Key2.unmarshall(ctx, soapval, "Key2");
	hasValue |= m_Stop.unmarshall(ctx, soapval, "Stop");
	hasValue |= m_MemThreshold.unmarshall(ctx, soapval, "MemThreshold");
	hasValue |= m_DiskThreshold.unmarshall(ctx, soapval, "DiskThreshold");
	hasValue |= m_CpuThreshold.unmarshall(ctx, soapval, "CpuThreshold");
	hasValue |= m_AutoRefresh.unmarshall(ctx, soapval, "AutoRefresh");
	hasValue |= m_MemThresholdType.unmarshall(ctx, soapval, "MemThresholdType");
	hasValue |= m_DiskThresholdType.unmarshall(ctx, soapval, "DiskThresholdType");
	return hasValue;
}

bool CStartStopBeginResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Addresses.unmarshall(ctx, params, attachments, "Addresses", basepath);
	hasValue |= m_Key1.unmarshall(ctx, params, attachments, "Key1", basepath);
	hasValue |= m_Key2.unmarshall(ctx, params, attachments, "Key2", basepath);
	hasValue |= m_Stop.unmarshall(ctx, params, attachments, "Stop", basepath);
	hasValue |= m_MemThreshold.unmarshall(ctx, params, attachments, "MemThreshold", basepath);
	hasValue |= m_DiskThreshold.unmarshall(ctx, params, attachments, "DiskThreshold", basepath);
	hasValue |= m_CpuThreshold.unmarshall(ctx, params, attachments, "CpuThreshold", basepath);
	hasValue |= m_AutoRefresh.unmarshall(ctx, params, attachments, "AutoRefresh", basepath);
	hasValue |= m_MemThresholdType.unmarshall(ctx, params, attachments, "MemThresholdType", basepath);
	hasValue |= m_DiskThresholdType.unmarshall(ctx, params, attachments, "DiskThresholdType", basepath);
	return hasValue;
}

const char * CStartStopBeginResponse::getAddresses() { return m_Addresses.query();}
const char * CStartStopBeginResponse::getKey1() { return m_Key1.query();}
const char * CStartStopBeginResponse::getKey2() { return m_Key2.query();}
bool CStartStopBeginResponse::getStop() { return m_Stop;}
int CStartStopBeginResponse::getMemThreshold() { return m_MemThreshold;}
int CStartStopBeginResponse::getDiskThreshold() { return m_DiskThreshold;}
int CStartStopBeginResponse::getCpuThreshold() { return m_CpuThreshold;}
int CStartStopBeginResponse::getAutoRefresh() { return m_AutoRefresh;}
const char * CStartStopBeginResponse::getMemThresholdType() { return m_MemThresholdType.query();}
const char * CStartStopBeginResponse::getDiskThresholdType() { return m_DiskThresholdType.query();}
void CStartStopBeginResponse::setAddresses(const char * val){ m_Addresses.set(val); }
void CStartStopBeginResponse::setKey1(const char * val){ m_Key1.set(val); }
void CStartStopBeginResponse::setKey2(const char * val){ m_Key2.set(val); }
void CStartStopBeginResponse::setStop(bool val){ m_Stop=val; }
void CStartStopBeginResponse::setMemThreshold(int val){ m_MemThreshold=val; }
void CStartStopBeginResponse::setDiskThreshold(int val){ m_DiskThreshold=val; }
void CStartStopBeginResponse::setCpuThreshold(int val){ m_CpuThreshold=val; }
void CStartStopBeginResponse::setAutoRefresh(int val){ m_AutoRefresh=val; }
void CStartStopBeginResponse::setMemThresholdType(const char * val){ m_MemThresholdType.set(val); }
void CStartStopBeginResponse::setDiskThresholdType(const char * val){ m_DiskThresholdType.set(val); }
extern "C"  IEspStartStopBeginResponse *createStartStopBeginResponse(const char *serv){return ((IEspStartStopBeginResponse *)new CStartStopBeginResponse(serv));}
extern "C"  IClientStartStopBeginResponse *createClientStartStopBeginResponse(const char *serv){return ((IClientStartStopBeginResponse *)new CStartStopBeginResponse(serv));}

//=======================================================
// class CStartStopDoneRequest Implementation
//=======================================================

CStartStopDoneRequest::CStartStopDoneRequest(const char *serviceName, IRpcMessageBinding *init)
	: m_Addresses(nilIgnore),m_Key1(nilIgnore),m_Key2(nilIgnore),m_Stop(nilIgnore),m_MemThreshold(nilIgnore),m_DiskThreshold(nilIgnore),m_CpuThreshold(nilIgnore),m_AutoRefresh(nilIgnore),m_MemThresholdType(nilIgnore),m_DiskThresholdType(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("StartStopDoneRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CStartStopDoneRequest::CStartStopDoneRequest(const char *serviceName, const char *bc)
	: m_Addresses(nilIgnore),m_Key1(nilIgnore),m_Key2(nilIgnore),m_Stop(nilIgnore),m_MemThreshold(nilIgnore),m_DiskThreshold(nilIgnore),m_CpuThreshold(nilIgnore),m_AutoRefresh(nilIgnore),m_MemThresholdType(nilIgnore),m_DiskThresholdType(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("StartStopDoneRequest");
}

CStartStopDoneRequest::CStartStopDoneRequest(const char *serviceName, IRpcMessage* rpcmsg)
	: m_Addresses(nilIgnore),m_Key1(nilIgnore),m_Key2(nilIgnore),m_Stop(nilIgnore),m_MemThreshold(nilIgnore),m_DiskThreshold(nilIgnore),m_CpuThreshold(nilIgnore),m_AutoRefresh(nilIgnore),m_MemThresholdType(nilIgnore),m_DiskThresholdType(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("StartStopDoneRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CStartStopDoneRequest::CStartStopDoneRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_Addresses(nilIgnore),m_Key1(nilIgnore),m_Key2(nilIgnore),m_Stop(nilIgnore),m_MemThreshold(nilIgnore),m_DiskThreshold(nilIgnore),m_CpuThreshold(nilIgnore),m_AutoRefresh(nilIgnore),m_MemThresholdType(nilIgnore),m_DiskThresholdType(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("StartStopDoneRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CStartStopDoneRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Addresses\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Key1\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Key2\" type=\"xsd:string\"");
		if (context.queryOptions()&ESPCTX_ALL_ANNOTATION)
			schema.append("> <xsd:annotation><xsd:appinfo><form formType=\"password\" formCols=\"20\"/></xsd:appinfo></xsd:annotation></xsd:element>\n");
		else
			schema.append("/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Stop\" type=\"xsd:boolean\"/>\n");
		if (!context.suppressed("StartStopDoneRequest","MemThreshold")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"MemThreshold\" type=\"xsd:int\"/>\n");
		}
		if (!context.suppressed("StartStopDoneRequest","DiskThreshold")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"DiskThreshold\" type=\"xsd:int\"/>\n");
		}
		if (!context.suppressed("StartStopDoneRequest","CpuThreshold")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"CpuThreshold\" type=\"xsd:int\"/>\n");
		}
		if (!context.suppressed("StartStopDoneRequest","AutoRefresh")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"AutoRefresh\" type=\"xsd:int\"/>\n");
		}
		if (!context.suppressed("StartStopDoneRequest","MemThresholdType")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"MemThresholdType\" type=\"xsd:string\"/>\n");
		}
		if (!context.suppressed("StartStopDoneRequest","DiskThresholdType")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"DiskThresholdType\" type=\"xsd:string\"/>\n");
		}
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CStartStopDoneRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CStartStopDoneRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
	info.addMinVersion("StartStopDoneRequest","MemThreshold",1.08);
	info.addMinVersion("StartStopDoneRequest","DiskThreshold",1.08);
	info.addMinVersion("StartStopDoneRequest","CpuThreshold",1.08);
	info.addMinVersion("StartStopDoneRequest","AutoRefresh",1.08);
	info.addMinVersion("StartStopDoneRequest","MemThresholdType",1.08);
	info.addMinVersion("StartStopDoneRequest","DiskThresholdType",1.08);
}

StringBuffer &CStartStopDoneRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Addresses");
	form.appendf("  <tr><td><b>Addresses: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Key1");
	form.appendf("  <tr><td><b>Key1: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Key2");
	form.appendf("  <tr><td><b>Key2: </b></td><td><input type=\"password\" name=\"%s\" size=\"20\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Stop");
	
	form.appendf("  <tr><td><b>Stop? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	if (!context.suppressed("StartStopDoneRequest","MemThreshold")) {
		extfix.clear();
		if (prefix && *prefix) extfix.append(prefix).append(".");
			extfix.append("MemThreshold");
		form.appendf("  <tr><td><b>MemThreshold: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
		form.append("</td></tr>\n");
	}
	if (!context.suppressed("StartStopDoneRequest","DiskThreshold")) {
		extfix.clear();
		if (prefix && *prefix) extfix.append(prefix).append(".");
			extfix.append("DiskThreshold");
		form.appendf("  <tr><td><b>DiskThreshold: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
		form.append("</td></tr>\n");
	}
	if (!context.suppressed("StartStopDoneRequest","CpuThreshold")) {
		extfix.clear();
		if (prefix && *prefix) extfix.append(prefix).append(".");
			extfix.append("CpuThreshold");
		form.appendf("  <tr><td><b>CpuThreshold: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
		form.append("</td></tr>\n");
	}
	if (!context.suppressed("StartStopDoneRequest","AutoRefresh")) {
		extfix.clear();
		if (prefix && *prefix) extfix.append(prefix).append(".");
			extfix.append("AutoRefresh");
		form.appendf("  <tr><td><b>AutoRefresh: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
		form.append("</td></tr>\n");
	}
	if (!context.suppressed("StartStopDoneRequest","MemThresholdType")) {
		extfix.clear();
		if (prefix && *prefix)
			extfix.append(prefix).append(".");
		extfix.append("MemThresholdType");
		form.appendf("  <tr><td><b>MemThresholdType: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
		form.append("</td></tr>\n");
	}
	if (!context.suppressed("StartStopDoneRequest","DiskThresholdType")) {
		extfix.clear();
		if (prefix && *prefix)
			extfix.append(prefix).append(".");
		extfix.append("DiskThresholdType");
		form.appendf("  <tr><td><b>DiskThresholdType: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
		form.append("</td></tr>\n");
	}
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CStartStopDoneRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CStartStopDoneRequest::serialize(IRpcMessage& rpc_resp)
{
	IEspContext* ctx = rpc_resp.queryContext();
	double clientVer= ctx ? ctx->getClientVersion() : -1; /* no context gets everything */
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_Addresses.marshall(rpc_resp, "Addresses", "", "", "");
	m_Key1.marshall(rpc_resp, "Key1", "", "", "");
	m_Key2.marshall(rpc_resp, "Key2", "", "", "");
	m_Stop.marshall(rpc_resp, "Stop", "", "", "");
	if ((clientVer==-1.0 || clientVer>=1.08))
		m_MemThreshold.marshall(rpc_resp, "MemThreshold", "", "", "");
	if ((clientVer==-1.0 || clientVer>=1.08))
		m_DiskThreshold.marshall(rpc_resp, "DiskThreshold", "", "", "");
	if ((clientVer==-1.0 || clientVer>=1.08))
		m_CpuThreshold.marshall(rpc_resp, "CpuThreshold", "", "", "");
	if ((clientVer==-1.0 || clientVer>=1.08))
		m_AutoRefresh.marshall(rpc_resp, "AutoRefresh", "", "", "");
	if ((clientVer==-1.0 || clientVer>=1.08))
		m_MemThresholdType.marshall(rpc_resp, "MemThresholdType", "", "", "");
	if ((clientVer==-1.0 || clientVer>=1.08))
		m_DiskThresholdType.marshall(rpc_resp, "DiskThresholdType", "", "", "");
}


void CStartStopDoneRequest::copy(CStartStopDoneRequest &from)
{
	m_Addresses.copy(from.m_Addresses);
	m_Key1.copy(from.m_Key1);
	m_Key2.copy(from.m_Key2);
	m_Stop.copy(from.m_Stop);
	m_MemThreshold.copy(from.m_MemThreshold);
	m_DiskThreshold.copy(from.m_DiskThreshold);
	m_CpuThreshold.copy(from.m_CpuThreshold);
	m_AutoRefresh.copy(from.m_AutoRefresh);
	m_MemThresholdType.copy(from.m_MemThresholdType);
	m_DiskThresholdType.copy(from.m_DiskThresholdType);
}


void CStartStopDoneRequest::copy(IConstStartStopDoneRequest &ifrom)
{
	setAddresses(ifrom.getAddresses());
	setKey1(ifrom.getKey1());
	setKey2(ifrom.getKey2());
	setStop(ifrom.getStop());
	setMemThreshold(ifrom.getMemThreshold());
	setDiskThreshold(ifrom.getDiskThreshold());
	setCpuThreshold(ifrom.getCpuThreshold());
	setAutoRefresh(ifrom.getAutoRefresh());
	setMemThresholdType(ifrom.getMemThresholdType());
	setDiskThresholdType(ifrom.getDiskThresholdType());
}


void CStartStopDoneRequest::getAttributes(IProperties &attributes)
{
}


void CStartStopDoneRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	double clientVer = ctx ? ctx->getClientVersion() : -1;
	m_Addresses.toStr(ctx, buffer, "Addresses", "", true, "", "");
	m_Key1.toStr(ctx, buffer, "Key1", "", true, "", "");
	m_Key2.toStr(ctx, buffer, "Key2", "", true, "", "");
	m_Stop.toStr(ctx, buffer, "Stop", "", true, "", "");
	if ((clientVer==-1.0 || clientVer>=1.08))
		m_MemThreshold.toStr(ctx, buffer, "MemThreshold", "", true, "", "");
	if ((clientVer==-1.0 || clientVer>=1.08))
		m_DiskThreshold.toStr(ctx, buffer, "DiskThreshold", "", true, "", "");
	if ((clientVer==-1.0 || clientVer>=1.08))
		m_CpuThreshold.toStr(ctx, buffer, "CpuThreshold", "", true, "", "");
	if ((clientVer==-1.0 || clientVer>=1.08))
		m_AutoRefresh.toStr(ctx, buffer, "AutoRefresh", "", true, "", "");
	if ((clientVer==-1.0 || clientVer>=1.08))
		m_MemThresholdType.toStr(ctx, buffer, "MemThresholdType", "", true, "", "");
	if ((clientVer==-1.0 || clientVer>=1.08))
		m_DiskThresholdType.toStr(ctx, buffer, "DiskThresholdType", "", true, "", "");
}


void CStartStopDoneRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CStartStopDoneRequest::serializer(IEspContext* ctx, IConstStartStopDoneRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<StartStopDoneRequest>");
	double clientVer = ctx ? ctx->getClientVersion() : -1;
	// field Addresses
	{
		const char* s = src.getAddresses();
		if (s && *s)
		{
			buffer.append("<Addresses>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Addresses>");
		}
	}
	// field Key1
	{
		const char* s = src.getKey1();
		if (s && *s)
		{
			buffer.append("<Key1>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Key1>");
		}
	}
	// field Key2
	{
		const char* s = src.getKey2();
		if (s && *s)
		{
			buffer.append("<Key2>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Key2>");
		}
	}
	// field Stop
	{
		bool b = src.getStop();
		if (b)
			buffer.appendf("<Stop>1</Stop>");
	}
	// field MemThreshold
	if ((clientVer==-1.0 || clientVer>=1.08))
	{
		int n = src.getMemThreshold();
		if (n)
			buffer.appendf("<MemThreshold>%d</MemThreshold>", n);
	}
	// field DiskThreshold
	if ((clientVer==-1.0 || clientVer>=1.08))
	{
		int n = src.getDiskThreshold();
		if (n)
			buffer.appendf("<DiskThreshold>%d</DiskThreshold>", n);
	}
	// field CpuThreshold
	if ((clientVer==-1.0 || clientVer>=1.08))
	{
		int n = src.getCpuThreshold();
		if (n)
			buffer.appendf("<CpuThreshold>%d</CpuThreshold>", n);
	}
	// field AutoRefresh
	if ((clientVer==-1.0 || clientVer>=1.08))
	{
		int n = src.getAutoRefresh();
		if (n)
			buffer.appendf("<AutoRefresh>%d</AutoRefresh>", n);
	}
	// field MemThresholdType
	if ((clientVer==-1.0 || clientVer>=1.08))
	{
		const char* s = src.getMemThresholdType();
		if (s && *s)
		{
			buffer.append("<MemThresholdType>");
			encodeUtf8XML(s,buffer);
			buffer.append("</MemThresholdType>");
		}
	}
	// field DiskThresholdType
	if ((clientVer==-1.0 || clientVer>=1.08))
	{
		const char* s = src.getDiskThresholdType();
		if (s && *s)
		{
			buffer.append("<DiskThresholdType>");
			encodeUtf8XML(s,buffer);
			buffer.append("</DiskThresholdType>");
		}
	}
	if (keepRootTag)
		buffer.append("</StartStopDoneRequest>");
}

bool CStartStopDoneRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_Addresses.unmarshall(rpc_request, "Addresses", basepath);
	hasValue |= m_Key1.unmarshall(rpc_request, "Key1", basepath);
	hasValue |= m_Key2.unmarshall(rpc_request, "Key2", basepath);
	hasValue |= m_Stop.unmarshall(rpc_request, "Stop", basepath);
	hasValue |= m_MemThreshold.unmarshall(rpc_request, "MemThreshold", basepath);
	hasValue |= m_DiskThreshold.unmarshall(rpc_request, "DiskThreshold", basepath);
	hasValue |= m_CpuThreshold.unmarshall(rpc_request, "CpuThreshold", basepath);
	hasValue |= m_AutoRefresh.unmarshall(rpc_request, "AutoRefresh", basepath);
	hasValue |= m_MemThresholdType.unmarshall(rpc_request, "MemThresholdType", basepath);
	hasValue |= m_DiskThresholdType.unmarshall(rpc_request, "DiskThresholdType", basepath);
	return hasValue;
}

bool CStartStopDoneRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Addresses.unmarshall(ctx, soapval, "Addresses");
	hasValue |= m_Key1.unmarshall(ctx, soapval, "Key1");
	hasValue |= m_Key2.unmarshall(ctx, soapval, "Key2");
	hasValue |= m_Stop.unmarshall(ctx, soapval, "Stop");
	hasValue |= m_MemThreshold.unmarshall(ctx, soapval, "MemThreshold");
	hasValue |= m_DiskThreshold.unmarshall(ctx, soapval, "DiskThreshold");
	hasValue |= m_CpuThreshold.unmarshall(ctx, soapval, "CpuThreshold");
	hasValue |= m_AutoRefresh.unmarshall(ctx, soapval, "AutoRefresh");
	hasValue |= m_MemThresholdType.unmarshall(ctx, soapval, "MemThresholdType");
	hasValue |= m_DiskThresholdType.unmarshall(ctx, soapval, "DiskThresholdType");
	return hasValue;
}

bool CStartStopDoneRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Addresses.unmarshall(ctx, params, attachments, "Addresses", basepath);
	hasValue |= m_Key1.unmarshall(ctx, params, attachments, "Key1", basepath);
	hasValue |= m_Key2.unmarshall(ctx, params, attachments, "Key2", basepath);
	hasValue |= m_Stop.unmarshall(ctx, params, attachments, "Stop", basepath);
	hasValue |= m_MemThreshold.unmarshall(ctx, params, attachments, "MemThreshold", basepath);
	hasValue |= m_DiskThreshold.unmarshall(ctx, params, attachments, "DiskThreshold", basepath);
	hasValue |= m_CpuThreshold.unmarshall(ctx, params, attachments, "CpuThreshold", basepath);
	hasValue |= m_AutoRefresh.unmarshall(ctx, params, attachments, "AutoRefresh", basepath);
	hasValue |= m_MemThresholdType.unmarshall(ctx, params, attachments, "MemThresholdType", basepath);
	hasValue |= m_DiskThresholdType.unmarshall(ctx, params, attachments, "DiskThresholdType", basepath);
	return hasValue;
}

const char * CStartStopDoneRequest::getAddresses() { return m_Addresses.query();}
const char * CStartStopDoneRequest::getKey1() { return m_Key1.query();}
const char * CStartStopDoneRequest::getKey2() { return m_Key2.query();}
bool CStartStopDoneRequest::getStop() { return m_Stop;}
int CStartStopDoneRequest::getMemThreshold() { return m_MemThreshold;}
int CStartStopDoneRequest::getDiskThreshold() { return m_DiskThreshold;}
int CStartStopDoneRequest::getCpuThreshold() { return m_CpuThreshold;}
int CStartStopDoneRequest::getAutoRefresh() { return m_AutoRefresh;}
const char * CStartStopDoneRequest::getMemThresholdType() { return m_MemThresholdType.query();}
const char * CStartStopDoneRequest::getDiskThresholdType() { return m_DiskThresholdType.query();}
void CStartStopDoneRequest::setAddresses(const char * val){ m_Addresses.set(val); }
void CStartStopDoneRequest::setKey1(const char * val){ m_Key1.set(val); }
void CStartStopDoneRequest::setKey2(const char * val){ m_Key2.set(val); }
void CStartStopDoneRequest::setStop(bool val){ m_Stop=val; }
void CStartStopDoneRequest::setMemThreshold(int val){ m_MemThreshold=val; }
void CStartStopDoneRequest::setDiskThreshold(int val){ m_DiskThreshold=val; }
void CStartStopDoneRequest::setCpuThreshold(int val){ m_CpuThreshold=val; }
void CStartStopDoneRequest::setAutoRefresh(int val){ m_AutoRefresh=val; }
void CStartStopDoneRequest::setMemThresholdType(const char * val){ m_MemThresholdType.set(val); }
void CStartStopDoneRequest::setDiskThresholdType(const char * val){ m_DiskThresholdType.set(val); }
extern "C"  IEspStartStopDoneRequest *createStartStopDoneRequest(const char *serv){return ((IEspStartStopDoneRequest *)new CStartStopDoneRequest(serv));}
extern "C"  IClientStartStopDoneRequest *createClientStartStopDoneRequest(const char *serv){return ((IClientStartStopDoneRequest *)new CStartStopDoneRequest(serv));}

//=======================================================
// class CStartStopRequest Implementation
//=======================================================

CStartStopRequest::CStartStopRequest(const char *serviceName, IRpcMessageBinding *init)
	: m_Addresses(nilIgnore),m_Key1(nilIgnore),m_Key2(nilIgnore),m_Stop(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("StartStopRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CStartStopRequest::CStartStopRequest(const char *serviceName, const char *bc)
	: m_Addresses(nilIgnore),m_Key1(nilIgnore),m_Key2(nilIgnore),m_Stop(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("StartStopRequest");
}

CStartStopRequest::CStartStopRequest(const char *serviceName, IRpcMessage* rpcmsg)
	: m_Addresses(nilIgnore),m_Key1(nilIgnore),m_Key2(nilIgnore),m_Stop(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("StartStopRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CStartStopRequest::CStartStopRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_Addresses(nilIgnore),m_Key1(nilIgnore),m_Key2(nilIgnore),m_Stop(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("StartStopRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CStartStopRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Addresses\" type=\"tns:EspStringArray\"/>\n");
		if (!context.suppressed("StartStopRequest","Key1")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"Key1\" type=\"xsd:string\"/>\n");
		}
		if (!context.suppressed("StartStopRequest","Key2")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"Key2\" type=\"xsd:string\"");
			if (context.queryOptions()&ESPCTX_ALL_ANNOTATION)
				schema.append("> <xsd:annotation><xsd:appinfo><form formType=\"password\" formCols=\"20\"/></xsd:appinfo></xsd:annotation></xsd:element>\n");
			else
				schema.append("/>\n");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Stop\" type=\"xsd:boolean\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	if (added.getValue("EspStringArray")==NULL) {
		addEspNativeArray(schema,"string","EspStringArray");
		added.setValue("EspStringArray",1);
	}
	return schema;
}

void CStartStopRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CStartStopRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
	info.addMinVersion("StartStopRequest","Key1",1.01);
	info.addMinVersion("StartStopRequest","Key2",1.01);
}

StringBuffer &CStartStopRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Addresses");
	form.appendf("<tr><td><b>Addresses: </b></td><td>");
	form.appendf("<textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea>", extfix.str());
	form.append("</td></tr>");
	if (!context.suppressed("StartStopRequest","Key1")) {
		extfix.clear();
		if (prefix && *prefix)
			extfix.append(prefix).append(".");
		extfix.append("Key1");
		form.appendf("  <tr><td><b>Key1: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
		form.append("</td></tr>\n");
	}
	if (!context.suppressed("StartStopRequest","Key2")) {
		extfix.clear();
		if (prefix && *prefix)
			extfix.append(prefix).append(".");
		extfix.append("Key2");
		form.appendf("  <tr><td><b>Key2: </b></td><td><input type=\"password\" name=\"%s\" size=\"20\" value=\"\" />", extfix.str());
		form.append("</td></tr>\n");
	}
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Stop");
	
	form.appendf("  <tr><td><b>Stop? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CStartStopRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CStartStopRequest::serialize(IRpcMessage& rpc_resp)
{
	IEspContext* ctx = rpc_resp.queryContext();
	double clientVer= ctx ? ctx->getClientVersion() : -1; /* no context gets everything */
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_Addresses.marshall(rpc_resp, "Addresses", "Item");
	if ((clientVer==-1.0 || clientVer>=1.01))
		m_Key1.marshall(rpc_resp, "Key1", "", "", "");
	if ((clientVer==-1.0 || clientVer>=1.01))
		m_Key2.marshall(rpc_resp, "Key2", "", "", "");
	m_Stop.marshall(rpc_resp, "Stop", "", "", "");
}


void CStartStopRequest::copy(CStartStopRequest &from)
{
	m_Addresses.copy(from.m_Addresses);
	m_Key1.copy(from.m_Key1);
	m_Key2.copy(from.m_Key2);
	m_Stop.copy(from.m_Stop);
}


void CStartStopRequest::copy(IConstStartStopRequest &ifrom)
{
	setAddresses(ifrom.getAddresses());
	setKey1(ifrom.getKey1());
	setKey2(ifrom.getKey2());
	setStop(ifrom.getStop());
}


void CStartStopRequest::getAttributes(IProperties &attributes)
{
}


void CStartStopRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	double clientVer = ctx ? ctx->getClientVersion() : -1;
	m_Addresses.toStr(ctx, buffer, "Addresses", "Item");
	if ((clientVer==-1.0 || clientVer>=1.01))
		m_Key1.toStr(ctx, buffer, "Key1", "", true, "", "");
	if ((clientVer==-1.0 || clientVer>=1.01))
		m_Key2.toStr(ctx, buffer, "Key2", "", true, "", "");
	m_Stop.toStr(ctx, buffer, "Stop", "", true, "", "");
}


void CStartStopRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CStartStopRequest::serializer(IEspContext* ctx, IConstStartStopRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<StartStopRequest>");
	double clientVer = ctx ? ctx->getClientVersion() : -1;
	// field Addresses
	{
		StringArray& v = src.getAddresses();
		if (v.length()>0)
			buffer.append("<Addresses>");
		for (size32_t i=0;i<v.length();i++)
			buffer.appendf("<Item>%s</Item>",v.item(i));
		if (v.length()>0)
			buffer.append("</Addresses>");
	}
	// field Key1
	if ((clientVer==-1.0 || clientVer>=1.01))
	{
		const char* s = src.getKey1();
		if (s && *s)
		{
			buffer.append("<Key1>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Key1>");
		}
	}
	// field Key2
	if ((clientVer==-1.0 || clientVer>=1.01))
	{
		const char* s = src.getKey2();
		if (s && *s)
		{
			buffer.append("<Key2>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Key2>");
		}
	}
	// field Stop
	{
		bool b = src.getStop();
		if (b)
			buffer.appendf("<Stop>1</Stop>");
	}
	if (keepRootTag)
		buffer.append("</StartStopRequest>");
}

bool CStartStopRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_Addresses.unmarshall(rpc_request, "Addresses", basepath);
	hasValue |= m_Key1.unmarshall(rpc_request, "Key1", basepath);
	hasValue |= m_Key2.unmarshall(rpc_request, "Key2", basepath);
	hasValue |= m_Stop.unmarshall(rpc_request, "Stop", basepath);
	return hasValue;
}

bool CStartStopRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Addresses.unmarshall(ctx, soapval, "Addresses");
	hasValue |= m_Key1.unmarshall(ctx, soapval, "Key1");
	hasValue |= m_Key2.unmarshall(ctx, soapval, "Key2");
	hasValue |= m_Stop.unmarshall(ctx, soapval, "Stop");
	return hasValue;
}

bool CStartStopRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Addresses.unmarshall(ctx, params, attachments, "Addresses", basepath);
	hasValue |= m_Key1.unmarshall(ctx, params, attachments, "Key1", basepath);
	hasValue |= m_Key2.unmarshall(ctx, params, attachments, "Key2", basepath);
	hasValue |= m_Stop.unmarshall(ctx, params, attachments, "Stop", basepath);
	return hasValue;
}

StringArray & CStartStopRequest::getAddresses() { return (StringArray &) m_Addresses; }
const char * CStartStopRequest::getKey1() { return m_Key1.query();}
const char * CStartStopRequest::getKey2() { return m_Key2.query();}
bool CStartStopRequest::getStop() { return m_Stop;}
void CStartStopRequest::setAddresses(StringArray &val){ m_Addresses->kill();  CloneArray(m_Addresses.getValue(), val); }
void CStartStopRequest::setKey1(const char * val){ m_Key1.set(val); }
void CStartStopRequest::setKey2(const char * val){ m_Key2.set(val); }
void CStartStopRequest::setStop(bool val){ m_Stop=val; }
extern "C"  IEspStartStopRequest *createStartStopRequest(const char *serv){return ((IEspStartStopRequest *)new CStartStopRequest(serv));}
extern "C"  IClientStartStopRequest *createClientStartStopRequest(const char *serv){return ((IClientStartStopRequest *)new CStartStopRequest(serv));}

//=======================================================
// class CStartStopResult Implementation
//=======================================================

CStartStopResult::CStartStopResult(const char *serviceName, IRpcMessageBinding *init)
	: m_AddressOrig(nilIgnore),m_Address(nilIgnore),m_CompType(nilIgnore),m_Name(nilIgnore),m_Path(nilIgnore),m_Command(nilIgnore),m_Response(nilIgnore),m_ResultCode(nilIgnore),m_OS(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("StartStopResult");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CStartStopResult::CStartStopResult(const char *serviceName, const char *bc)
	: m_AddressOrig(nilIgnore),m_Address(nilIgnore),m_CompType(nilIgnore),m_Name(nilIgnore),m_Path(nilIgnore),m_Command(nilIgnore),m_Response(nilIgnore),m_ResultCode(nilIgnore),m_OS(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("StartStopResult");
}

StringBuffer &CStartStopResult::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:complexType name=\"%s\">\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"AddressOrig\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Address\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"CompType\" type=\"xsd:string\"/>\n");
		if (!context.suppressed("StartStopResult","Name")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"Name\" type=\"xsd:string\"/>\n");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Path\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Command\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Response\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"ResultCode\" type=\"xsd:int\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"OS\" type=\"xsd:int\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType>\n");
		}
	}
	return schema;
}

void CStartStopResult::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CStartStopResult::getMapInfo(IMapInfo& info, BoolHash& added)
{
	info.addMinVersion("StartStopResult","Name",1.05);
}

StringBuffer &CStartStopResult::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("AddressOrig");
	form.appendf("  <tr><td><b>AddressOrig: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Address");
	form.appendf("  <tr><td><b>Address: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("CompType");
	form.appendf("  <tr><td><b>CompType: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (!context.suppressed("StartStopResult","Name")) {
		extfix.clear();
		if (prefix && *prefix)
			extfix.append(prefix).append(".");
		extfix.append("Name");
		form.appendf("  <tr><td><b>Name: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
		form.append("</td></tr>\n");
	}
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Path");
	form.appendf("  <tr><td><b>Path: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Command");
	form.appendf("  <tr><td><b>Command: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Response");
	form.appendf("  <tr><td><b>Response: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix) extfix.append(prefix).append(".");
		extfix.append("ResultCode");
	form.appendf("  <tr><td><b>ResultCode: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix) extfix.append(prefix).append(".");
		extfix.append("OS");
	form.appendf("  <tr><td><b>OS: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CStartStopResult::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CStartStopResult::serialize(IRpcMessage& rpc_resp)
{
	IEspContext* ctx = rpc_resp.queryContext();
	double clientVer= ctx ? ctx->getClientVersion() : -1; /* no context gets everything */
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_AddressOrig.marshall(rpc_resp, "AddressOrig", "", "", "");
	m_Address.marshall(rpc_resp, "Address", "", "", "");
	m_CompType.marshall(rpc_resp, "CompType", "", "", "");
	if ((clientVer==-1.0 || clientVer>=1.05))
		m_Name.marshall(rpc_resp, "Name", "", "", "");
	m_Path.marshall(rpc_resp, "Path", "", "", "");
	m_Command.marshall(rpc_resp, "Command", "", "", "");
	m_Response.marshall(rpc_resp, "Response", "", "", "");
	m_ResultCode.marshall(rpc_resp, "ResultCode", "", "", "");
	m_OS.marshall(rpc_resp, "OS", "", "", "");
}


void CStartStopResult::copy(CStartStopResult &from)
{
	m_AddressOrig.copy(from.m_AddressOrig);
	m_Address.copy(from.m_Address);
	m_CompType.copy(from.m_CompType);
	m_Name.copy(from.m_Name);
	m_Path.copy(from.m_Path);
	m_Command.copy(from.m_Command);
	m_Response.copy(from.m_Response);
	m_ResultCode.copy(from.m_ResultCode);
	m_OS.copy(from.m_OS);
}


void CStartStopResult::copy(IConstStartStopResult &ifrom)
{
	setAddressOrig(ifrom.getAddressOrig());
	setAddress(ifrom.getAddress());
	setCompType(ifrom.getCompType());
	setName(ifrom.getName());
	setPath(ifrom.getPath());
	setCommand(ifrom.getCommand());
	setResponse(ifrom.getResponse());
	setResultCode(ifrom.getResultCode());
	setOS(ifrom.getOS());
}


void CStartStopResult::getAttributes(IProperties &attributes)
{
}


void CStartStopResult::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	double clientVer = ctx ? ctx->getClientVersion() : -1;
	m_AddressOrig.toStr(ctx, buffer, "AddressOrig", "", true, "", "");
	m_Address.toStr(ctx, buffer, "Address", "", true, "", "");
	m_CompType.toStr(ctx, buffer, "CompType", "", true, "", "");
	if ((clientVer==-1.0 || clientVer>=1.05))
		m_Name.toStr(ctx, buffer, "Name", "", true, "", "");
	m_Path.toStr(ctx, buffer, "Path", "", true, "", "");
	m_Command.toStr(ctx, buffer, "Command", "", true, "", "");
	m_Response.toStr(ctx, buffer, "Response", "", true, "", "");
	m_ResultCode.toStr(ctx, buffer, "ResultCode", "", true, "", "");
	m_OS.toStr(ctx, buffer, "OS", "", true, "", "");
}


void CStartStopResult::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CStartStopResult::serializer(IEspContext* ctx, IConstStartStopResult &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<StartStopResult>");
	double clientVer = ctx ? ctx->getClientVersion() : -1;
	// field AddressOrig
	{
		const char* s = src.getAddressOrig();
		if (s && *s)
		{
			buffer.append("<AddressOrig>");
			encodeUtf8XML(s,buffer);
			buffer.append("</AddressOrig>");
		}
	}
	// field Address
	{
		const char* s = src.getAddress();
		if (s && *s)
		{
			buffer.append("<Address>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Address>");
		}
	}
	// field CompType
	{
		const char* s = src.getCompType();
		if (s && *s)
		{
			buffer.append("<CompType>");
			encodeUtf8XML(s,buffer);
			buffer.append("</CompType>");
		}
	}
	// field Name
	if ((clientVer==-1.0 || clientVer>=1.05))
	{
		const char* s = src.getName();
		if (s && *s)
		{
			buffer.append("<Name>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Name>");
		}
	}
	// field Path
	{
		const char* s = src.getPath();
		if (s && *s)
		{
			buffer.append("<Path>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Path>");
		}
	}
	// field Command
	{
		const char* s = src.getCommand();
		if (s && *s)
		{
			buffer.append("<Command>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Command>");
		}
	}
	// field Response
	{
		const char* s = src.getResponse();
		if (s && *s)
		{
			buffer.append("<Response>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Response>");
		}
	}
	// field ResultCode
	{
		int n = src.getResultCode();
		if (n)
			buffer.appendf("<ResultCode>%d</ResultCode>", n);
	}
	// field OS
	{
		int n = src.getOS();
		if (n)
			buffer.appendf("<OS>%d</OS>", n);
	}
	if (keepRootTag)
		buffer.append("</StartStopResult>");
}

bool CStartStopResult::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_AddressOrig.unmarshall(rpc_request, "AddressOrig", basepath);
	hasValue |= m_Address.unmarshall(rpc_request, "Address", basepath);
	hasValue |= m_CompType.unmarshall(rpc_request, "CompType", basepath);
	hasValue |= m_Name.unmarshall(rpc_request, "Name", basepath);
	hasValue |= m_Path.unmarshall(rpc_request, "Path", basepath);
	hasValue |= m_Command.unmarshall(rpc_request, "Command", basepath);
	hasValue |= m_Response.unmarshall(rpc_request, "Response", basepath);
	hasValue |= m_ResultCode.unmarshall(rpc_request, "ResultCode", basepath);
	hasValue |= m_OS.unmarshall(rpc_request, "OS", basepath);
	return hasValue;
}

bool CStartStopResult::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_AddressOrig.unmarshall(ctx, soapval, "AddressOrig");
	hasValue |= m_Address.unmarshall(ctx, soapval, "Address");
	hasValue |= m_CompType.unmarshall(ctx, soapval, "CompType");
	hasValue |= m_Name.unmarshall(ctx, soapval, "Name");
	hasValue |= m_Path.unmarshall(ctx, soapval, "Path");
	hasValue |= m_Command.unmarshall(ctx, soapval, "Command");
	hasValue |= m_Response.unmarshall(ctx, soapval, "Response");
	hasValue |= m_ResultCode.unmarshall(ctx, soapval, "ResultCode");
	hasValue |= m_OS.unmarshall(ctx, soapval, "OS");
	return hasValue;
}

bool CStartStopResult::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_AddressOrig.unmarshall(ctx, params, attachments, "AddressOrig", basepath);
	hasValue |= m_Address.unmarshall(ctx, params, attachments, "Address", basepath);
	hasValue |= m_CompType.unmarshall(ctx, params, attachments, "CompType", basepath);
	hasValue |= m_Name.unmarshall(ctx, params, attachments, "Name", basepath);
	hasValue |= m_Path.unmarshall(ctx, params, attachments, "Path", basepath);
	hasValue |= m_Command.unmarshall(ctx, params, attachments, "Command", basepath);
	hasValue |= m_Response.unmarshall(ctx, params, attachments, "Response", basepath);
	hasValue |= m_ResultCode.unmarshall(ctx, params, attachments, "ResultCode", basepath);
	hasValue |= m_OS.unmarshall(ctx, params, attachments, "OS", basepath);
	return hasValue;
}

const char * CStartStopResult::getAddressOrig() { return m_AddressOrig.query();}
const char * CStartStopResult::getAddress() { return m_Address.query();}
const char * CStartStopResult::getCompType() { return m_CompType.query();}
const char * CStartStopResult::getName() { return m_Name.query();}
const char * CStartStopResult::getPath() { return m_Path.query();}
const char * CStartStopResult::getCommand() { return m_Command.query();}
const char * CStartStopResult::getResponse() { return m_Response.query();}
int CStartStopResult::getResultCode() { return m_ResultCode;}
int CStartStopResult::getOS() { return m_OS;}
void CStartStopResult::setAddressOrig(const char * val){ m_AddressOrig.set(val); }
void CStartStopResult::setAddress(const char * val){ m_Address.set(val); }
void CStartStopResult::setCompType(const char * val){ m_CompType.set(val); }
void CStartStopResult::setName(const char * val){ m_Name.set(val); }
void CStartStopResult::setPath(const char * val){ m_Path.set(val); }
void CStartStopResult::setCommand(const char * val){ m_Command.set(val); }
void CStartStopResult::setResponse(const char * val){ m_Response.set(val); }
void CStartStopResult::setResultCode(int val){ m_ResultCode=val; }
void CStartStopResult::setOS(int val){ m_OS=val; }
extern "C"  IEspStartStopResult *createStartStopResult(const char *serv, const char *msgname){return ((IEspStartStopResult *)new CStartStopResult(serv /*, msgname*/));}
extern "C"  IClientStartStopResult *createClientStartStopResult(const char *serv, const char *msgname){return ((IClientStartStopResult *)new CStartStopResult(serv /*, msgname*/));}

//=======================================================
// class CStartStopResponse Implementation
//=======================================================

CStartStopResponse::CStartStopResponse(const char *serviceName, IRpcMessageBinding *init)
	: m_StartStopResults(nilIgnore),m_Stop(nilIgnore),m_ContainCluster(nilIgnore),m_MemThreshold(nilIgnore),m_DiskThreshold(nilIgnore),m_CpuThreshold(nilIgnore),m_AutoRefresh(nilIgnore),m_MemThresholdType(nilIgnore),m_DiskThresholdType(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("StartStopResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CStartStopResponse::CStartStopResponse(const char *serviceName, const char *bc)
	: m_StartStopResults(nilIgnore),m_Stop(nilIgnore),m_ContainCluster(nilIgnore),m_MemThreshold(nilIgnore),m_DiskThreshold(nilIgnore),m_CpuThreshold(nilIgnore),m_AutoRefresh(nilIgnore),m_MemThresholdType(nilIgnore),m_DiskThresholdType(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("StartStopResponse");
}

CStartStopResponse::CStartStopResponse(const char *serviceName, IRpcMessage* rpcmsg)
	: m_StartStopResults(nilIgnore),m_Stop(nilIgnore),m_ContainCluster(nilIgnore),m_MemThreshold(nilIgnore),m_DiskThreshold(nilIgnore),m_CpuThreshold(nilIgnore),m_AutoRefresh(nilIgnore),m_MemThresholdType(nilIgnore),m_DiskThresholdType(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("StartStopResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CStartStopResponse::CStartStopResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_StartStopResults(nilIgnore),m_Stop(nilIgnore),m_ContainCluster(nilIgnore),m_MemThreshold(nilIgnore),m_DiskThreshold(nilIgnore),m_CpuThreshold(nilIgnore),m_AutoRefresh(nilIgnore),m_MemThresholdType(nilIgnore),m_DiskThresholdType(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("StartStopResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CStartStopResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		schema.append("<xsd:element name=\"Exceptions\" type=\"tns:ArrayOfEspException\" minOccurs=\"0\" maxOccurs=\"1\"/>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"StartStopResults\" type=\"tns:ArrayOfStartStopResult\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Stop\" type=\"xsd:boolean\"/>\n");
		if (!context.suppressed("StartStopResponse","ContainCluster")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"ContainCluster\" type=\"xsd:boolean\"/>\n");
		}
		if (!context.suppressed("StartStopResponse","MemThreshold")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"MemThreshold\" type=\"xsd:int\"/>\n");
		}
		if (!context.suppressed("StartStopResponse","DiskThreshold")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"DiskThreshold\" type=\"xsd:int\"/>\n");
		}
		if (!context.suppressed("StartStopResponse","CpuThreshold")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"CpuThreshold\" type=\"xsd:int\"/>\n");
		}
		if (!context.suppressed("StartStopResponse","AutoRefresh")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"AutoRefresh\" type=\"xsd:int\"/>\n");
		}
		if (!context.suppressed("StartStopResponse","MemThresholdType")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"MemThresholdType\" type=\"xsd:string\"/>\n");
		}
		if (!context.suppressed("StartStopResponse","DiskThresholdType")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"DiskThresholdType\" type=\"xsd:string\"/>\n");
		}
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	if (!(flags & 0x10)  || (flags & 0x100))
	{
		CStartStopResult::getXsdDefinition(context, request, schema, added);
	}
	if (added.getValue("StartStopResult") && added.getValue("ArrayOfStartStopResult")==NULL) {
		schema.append("<xsd:complexType name=\"ArrayOfStartStopResult\">\n");
		schema.append("<xsd:sequence>\n");
		schema.append("<xsd:element minOccurs=\"0\" maxOccurs=\"unbounded\" name=\"StartStopResult\" type=\"tns:StartStopResult\"/>\n");
		schema.append("</xsd:sequence>\n");
		schema.append("</xsd:complexType>\n");
		added.setValue("ArrayOfStartStopResult",1);
	}
	return schema;
}

void CStartStopResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CStartStopResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
	info.addMinVersion("StartStopResponse","ContainCluster",1.09);
	info.addMinVersion("StartStopResponse","MemThreshold",1.08);
	info.addMinVersion("StartStopResponse","DiskThreshold",1.08);
	info.addMinVersion("StartStopResponse","CpuThreshold",1.08);
	info.addMinVersion("StartStopResponse","AutoRefresh",1.08);
	info.addMinVersion("StartStopResponse","MemThresholdType",1.08);
	info.addMinVersion("StartStopResponse","DiskThresholdType",1.08);
	if (!added.getValue("StartStopResult"))
	{
		added.setValue("StartStopResult",1);
		CStartStopResult::getMapInfo(info,added);
	}
}

StringBuffer &CStartStopResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("StartStopResults");
	form.appendf("<tr><td><b>StartStopResults: </b></td><td>");
	form.appendf("<table><tr><td><textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea></td>", extfix.str());
	form.append("</tr></table>");
	form.append("</td></tr>");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Stop");
	
	form.appendf("  <tr><td><b>Stop? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	if (!context.suppressed("StartStopResponse","ContainCluster")) {
		extfix.clear();
		if (prefix && *prefix)
			extfix.append(prefix).append(".");
		extfix.append("ContainCluster");
		
	form.appendf("  <tr><td><b>ContainCluster? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	}
	if (!context.suppressed("StartStopResponse","MemThreshold")) {
		extfix.clear();
		if (prefix && *prefix) extfix.append(prefix).append(".");
			extfix.append("MemThreshold");
		form.appendf("  <tr><td><b>MemThreshold: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
		form.append("</td></tr>\n");
	}
	if (!context.suppressed("StartStopResponse","DiskThreshold")) {
		extfix.clear();
		if (prefix && *prefix) extfix.append(prefix).append(".");
			extfix.append("DiskThreshold");
		form.appendf("  <tr><td><b>DiskThreshold: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
		form.append("</td></tr>\n");
	}
	if (!context.suppressed("StartStopResponse","CpuThreshold")) {
		extfix.clear();
		if (prefix && *prefix) extfix.append(prefix).append(".");
			extfix.append("CpuThreshold");
		form.appendf("  <tr><td><b>CpuThreshold: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
		form.append("</td></tr>\n");
	}
	if (!context.suppressed("StartStopResponse","AutoRefresh")) {
		extfix.clear();
		if (prefix && *prefix) extfix.append(prefix).append(".");
			extfix.append("AutoRefresh");
		form.appendf("  <tr><td><b>AutoRefresh: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
		form.append("</td></tr>\n");
	}
	if (!context.suppressed("StartStopResponse","MemThresholdType")) {
		extfix.clear();
		if (prefix && *prefix)
			extfix.append(prefix).append(".");
		extfix.append("MemThresholdType");
		form.appendf("  <tr><td><b>MemThresholdType: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
		form.append("</td></tr>\n");
	}
	if (!context.suppressed("StartStopResponse","DiskThresholdType")) {
		extfix.clear();
		if (prefix && *prefix)
			extfix.append(prefix).append(".");
		extfix.append("DiskThresholdType");
		form.appendf("  <tr><td><b>DiskThresholdType: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
		form.append("</td></tr>\n");
	}
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CStartStopResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CStartStopResponse::serialize(IRpcMessage& rpc_resp)
{
	IEspContext* ctx = rpc_resp.queryContext();
	double clientVer= ctx ? ctx->getClientVersion() : -1; /* no context gets everything */
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	rpc_resp.setEncodeXml(false);
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
		m_StartStopResults.marshall(rpc_resp, "StartStopResults", "StartStopResult");
		m_Stop.marshall(rpc_resp, "Stop", "", "", "");
		if ((clientVer==-1.0 || clientVer>=1.09))
			m_ContainCluster.marshall(rpc_resp, "ContainCluster", "", "", "");
		if ((clientVer==-1.0 || clientVer>=1.08))
			m_MemThreshold.marshall(rpc_resp, "MemThreshold", "", "", "");
		if ((clientVer==-1.0 || clientVer>=1.08))
			m_DiskThreshold.marshall(rpc_resp, "DiskThreshold", "", "", "");
		if ((clientVer==-1.0 || clientVer>=1.08))
			m_CpuThreshold.marshall(rpc_resp, "CpuThreshold", "", "", "");
		if ((clientVer==-1.0 || clientVer>=1.08))
			m_AutoRefresh.marshall(rpc_resp, "AutoRefresh", "", "", "");
		if ((clientVer==-1.0 || clientVer>=1.08))
			m_MemThresholdType.marshall(rpc_resp, "MemThresholdType", "", "", "");
		if ((clientVer==-1.0 || clientVer>=1.08))
			m_DiskThresholdType.marshall(rpc_resp, "DiskThresholdType", "", "", "");
	}
}


void CStartStopResponse::copy(CStartStopResponse &from)
{
	m_StartStopResults.copy(from.m_StartStopResults);
	m_Stop.copy(from.m_Stop);
	m_ContainCluster.copy(from.m_ContainCluster);
	m_MemThreshold.copy(from.m_MemThreshold);
	m_DiskThreshold.copy(from.m_DiskThreshold);
	m_CpuThreshold.copy(from.m_CpuThreshold);
	m_AutoRefresh.copy(from.m_AutoRefresh);
	m_MemThresholdType.copy(from.m_MemThresholdType);
	m_DiskThresholdType.copy(from.m_DiskThresholdType);
}


void CStartStopResponse::copy(IConstStartStopResponse &ifrom)
{
	setStartStopResults(ifrom.getStartStopResults());
	setStop(ifrom.getStop());
	setContainCluster(ifrom.getContainCluster());
	setMemThreshold(ifrom.getMemThreshold());
	setDiskThreshold(ifrom.getDiskThreshold());
	setCpuThreshold(ifrom.getCpuThreshold());
	setAutoRefresh(ifrom.getAutoRefresh());
	setMemThresholdType(ifrom.getMemThresholdType());
	setDiskThresholdType(ifrom.getDiskThresholdType());
}


void CStartStopResponse::getAttributes(IProperties &attributes)
{
}


void CStartStopResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
		double clientVer = ctx ? ctx->getClientVersion() : -1;
		m_StartStopResults.toStr(ctx, buffer, "StartStopResults", "StartStopResult");
		m_Stop.toStr(ctx, buffer, "Stop", "", false, "", "");
		if ((clientVer==-1.0 || clientVer>=1.09))
			m_ContainCluster.toStr(ctx, buffer, "ContainCluster", "", false, "", "");
		if ((clientVer==-1.0 || clientVer>=1.08))
			m_MemThreshold.toStr(ctx, buffer, "MemThreshold", "", false, "", "");
		if ((clientVer==-1.0 || clientVer>=1.08))
			m_DiskThreshold.toStr(ctx, buffer, "DiskThreshold", "", false, "", "");
		if ((clientVer==-1.0 || clientVer>=1.08))
			m_CpuThreshold.toStr(ctx, buffer, "CpuThreshold", "", false, "", "");
		if ((clientVer==-1.0 || clientVer>=1.08))
			m_AutoRefresh.toStr(ctx, buffer, "AutoRefresh", "", false, "", "");
		if ((clientVer==-1.0 || clientVer>=1.08))
			m_MemThresholdType.toStr(ctx, buffer, "MemThresholdType", "", false, "", "");
		if ((clientVer==-1.0 || clientVer>=1.08))
			m_DiskThresholdType.toStr(ctx, buffer, "DiskThresholdType", "", false, "", "");
	}
}


void CStartStopResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CStartStopResponse::serializer(IEspContext* ctx, IConstStartStopResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<StartStopResponse>");
	double clientVer = ctx ? ctx->getClientVersion() : -1;
	// field StartStopResults
	{
		IArrayOf<IConstStartStopResult>& v = src.getStartStopResults();
		int size = v.length();
		if (size>0)
			buffer.append("<StartStopResults>");
		for (int i=0;i<size;i++)
		{
			buffer.append("<Item>");
			CStartStopResult::serializer(ctx,v.item(i),buffer,false);
			buffer.append("</Item>");
		}
		if (size>0)
			buffer.append("</StartStopResults>");
	}
	// field Stop
	{
		bool b = src.getStop();
		if (b)
			buffer.appendf("<Stop>1</Stop>");
	}
	// field ContainCluster
	if ((clientVer==-1.0 || clientVer>=1.09))
	{
		bool b = src.getContainCluster();
		if (b)
			buffer.appendf("<ContainCluster>1</ContainCluster>");
	}
	// field MemThreshold
	if ((clientVer==-1.0 || clientVer>=1.08))
	{
		int n = src.getMemThreshold();
		if (n)
			buffer.appendf("<MemThreshold>%d</MemThreshold>", n);
	}
	// field DiskThreshold
	if ((clientVer==-1.0 || clientVer>=1.08))
	{
		int n = src.getDiskThreshold();
		if (n)
			buffer.appendf("<DiskThreshold>%d</DiskThreshold>", n);
	}
	// field CpuThreshold
	if ((clientVer==-1.0 || clientVer>=1.08))
	{
		int n = src.getCpuThreshold();
		if (n)
			buffer.appendf("<CpuThreshold>%d</CpuThreshold>", n);
	}
	// field AutoRefresh
	if ((clientVer==-1.0 || clientVer>=1.08))
	{
		int n = src.getAutoRefresh();
		if (n)
			buffer.appendf("<AutoRefresh>%d</AutoRefresh>", n);
	}
	// field MemThresholdType
	if ((clientVer==-1.0 || clientVer>=1.08))
	{
		const char* s = src.getMemThresholdType();
		if (s && *s)
		buffer.appendf("<MemThresholdType>%s</MemThresholdType>",s);
	}
	// field DiskThresholdType
	if ((clientVer==-1.0 || clientVer>=1.08))
	{
		const char* s = src.getDiskThresholdType();
		if (s && *s)
		buffer.appendf("<DiskThresholdType>%s</DiskThresholdType>",s);
	}
	if (keepRootTag)
		buffer.append("</StartStopResponse>");
}

bool CStartStopResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
		hasValue |= m_StartStopResults.unmarshall(rpc_request, "StartStopResults", basepath);
		hasValue |= m_Stop.unmarshall(rpc_request, "Stop", basepath);
		hasValue |= m_ContainCluster.unmarshall(rpc_request, "ContainCluster", basepath);
		hasValue |= m_MemThreshold.unmarshall(rpc_request, "MemThreshold", basepath);
		hasValue |= m_DiskThreshold.unmarshall(rpc_request, "DiskThreshold", basepath);
		hasValue |= m_CpuThreshold.unmarshall(rpc_request, "CpuThreshold", basepath);
		hasValue |= m_AutoRefresh.unmarshall(rpc_request, "AutoRefresh", basepath);
		hasValue |= m_MemThresholdType.unmarshall(rpc_request, "MemThresholdType", basepath);
		hasValue |= m_DiskThresholdType.unmarshall(rpc_request, "DiskThresholdType", basepath);
	}
	return hasValue;
}

bool CStartStopResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_StartStopResults.unmarshall(ctx, soapval, "StartStopResults");
	hasValue |= m_Stop.unmarshall(ctx, soapval, "Stop");
	hasValue |= m_ContainCluster.unmarshall(ctx, soapval, "ContainCluster");
	hasValue |= m_MemThreshold.unmarshall(ctx, soapval, "MemThreshold");
	hasValue |= m_DiskThreshold.unmarshall(ctx, soapval, "DiskThreshold");
	hasValue |= m_CpuThreshold.unmarshall(ctx, soapval, "CpuThreshold");
	hasValue |= m_AutoRefresh.unmarshall(ctx, soapval, "AutoRefresh");
	hasValue |= m_MemThresholdType.unmarshall(ctx, soapval, "MemThresholdType");
	hasValue |= m_DiskThresholdType.unmarshall(ctx, soapval, "DiskThresholdType");
	return hasValue;
}

bool CStartStopResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_StartStopResults.unmarshall(ctx, params, attachments, "StartStopResults", basepath);
	hasValue |= m_Stop.unmarshall(ctx, params, attachments, "Stop", basepath);
	hasValue |= m_ContainCluster.unmarshall(ctx, params, attachments, "ContainCluster", basepath);
	hasValue |= m_MemThreshold.unmarshall(ctx, params, attachments, "MemThreshold", basepath);
	hasValue |= m_DiskThreshold.unmarshall(ctx, params, attachments, "DiskThreshold", basepath);
	hasValue |= m_CpuThreshold.unmarshall(ctx, params, attachments, "CpuThreshold", basepath);
	hasValue |= m_AutoRefresh.unmarshall(ctx, params, attachments, "AutoRefresh", basepath);
	hasValue |= m_MemThresholdType.unmarshall(ctx, params, attachments, "MemThresholdType", basepath);
	hasValue |= m_DiskThresholdType.unmarshall(ctx, params, attachments, "DiskThresholdType", basepath);
	return hasValue;
}

IArrayOf<IConstStartStopResult> & CStartStopResponse::getStartStopResults() { return (IArrayOf<IConstStartStopResult> &) m_StartStopResults; }
bool CStartStopResponse::getStop() { return m_Stop;}
bool CStartStopResponse::getContainCluster() { return m_ContainCluster;}
int CStartStopResponse::getMemThreshold() { return m_MemThreshold;}
int CStartStopResponse::getDiskThreshold() { return m_DiskThreshold;}
int CStartStopResponse::getCpuThreshold() { return m_CpuThreshold;}
int CStartStopResponse::getAutoRefresh() { return m_AutoRefresh;}
const char * CStartStopResponse::getMemThresholdType() { return m_MemThresholdType.query();}
const char * CStartStopResponse::getDiskThresholdType() { return m_DiskThresholdType.query();}
void CStartStopResponse::setStartStopResults(IArrayOf<IEspStartStopResult> &val)
{
	m_StartStopResults->kill();
	IArrayOf<IConstStartStopResult> &target = m_StartStopResults.getValue();
	ForEachItemIn(idx, val)
	{
		IEspStartStopResult &item = (val).item(idx);
		item.Link();
		target.append(item);
	}
}
void CStartStopResponse::setStartStopResults(IArrayOf<IConstStartStopResult> &val)
{
	m_StartStopResults->kill();
	IArrayOf<IConstStartStopResult> &target = m_StartStopResults.getValue();
	ForEachItemIn(idx, val)
	{
		IConstStartStopResult &item = val.item(idx);
		item.Link();
		target.append(item);
	}
}
void CStartStopResponse::setStop(bool val){ m_Stop=val; }
void CStartStopResponse::setContainCluster(bool val){ m_ContainCluster=val; }
void CStartStopResponse::setMemThreshold(int val){ m_MemThreshold=val; }
void CStartStopResponse::setDiskThreshold(int val){ m_DiskThreshold=val; }
void CStartStopResponse::setCpuThreshold(int val){ m_CpuThreshold=val; }
void CStartStopResponse::setAutoRefresh(int val){ m_AutoRefresh=val; }
void CStartStopResponse::setMemThresholdType(const char * val){ m_MemThresholdType.set(val); }
void CStartStopResponse::setDiskThresholdType(const char * val){ m_DiskThresholdType.set(val); }
extern "C"  IEspStartStopResponse *createStartStopResponse(const char *serv){return ((IEspStartStopResponse *)new CStartStopResponse(serv));}
extern "C"  IClientStartStopResponse *createClientStartStopResponse(const char *serv){return ((IClientStartStopResponse *)new CStartStopResponse(serv));}

//=======================================================
// class CGetTargetClusterInfoRequest Implementation
//=======================================================

CGetTargetClusterInfoRequest::CGetTargetClusterInfoRequest(const char *serviceName, IRpcMessageBinding *init)
	: m_TargetClusters(nilIgnore),m_AddProcessesToFilter(nilIgnore),m_ApplyProcessFilter(nilIgnore),m_GetProcessorInfo(nilIgnore),m_GetStorageInfo(nilIgnore),m_LocalFileSystemsOnly(nilIgnore),m_GetSoftwareInfo(nilIgnore),m_MemThreshold(nilIgnore),m_DiskThreshold(nilIgnore),m_CpuThreshold(nilIgnore),m_AutoRefresh(nilIgnore),m_MemThresholdType(nilIgnore),m_DiskThresholdType(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetTargetClusterInfoRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CGetTargetClusterInfoRequest::CGetTargetClusterInfoRequest(const char *serviceName, const char *bc)
	: m_TargetClusters(nilIgnore),m_AddProcessesToFilter(nilIgnore),m_ApplyProcessFilter(nilIgnore),m_GetProcessorInfo(nilIgnore),m_GetStorageInfo(nilIgnore),m_LocalFileSystemsOnly(nilIgnore),m_GetSoftwareInfo(nilIgnore),m_MemThreshold(nilIgnore),m_DiskThreshold(nilIgnore),m_CpuThreshold(nilIgnore),m_AutoRefresh(nilIgnore),m_MemThresholdType(nilIgnore),m_DiskThresholdType(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetTargetClusterInfoRequest");
}

CGetTargetClusterInfoRequest::CGetTargetClusterInfoRequest(const char *serviceName, IRpcMessage* rpcmsg)
	: m_TargetClusters(nilIgnore),m_AddProcessesToFilter(nilIgnore),m_ApplyProcessFilter(nilIgnore),m_GetProcessorInfo(nilIgnore),m_GetStorageInfo(nilIgnore),m_LocalFileSystemsOnly(nilIgnore),m_GetSoftwareInfo(nilIgnore),m_MemThreshold(nilIgnore),m_DiskThreshold(nilIgnore),m_CpuThreshold(nilIgnore),m_AutoRefresh(nilIgnore),m_MemThresholdType(nilIgnore),m_DiskThresholdType(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetTargetClusterInfoRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CGetTargetClusterInfoRequest::CGetTargetClusterInfoRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_TargetClusters(nilIgnore),m_AddProcessesToFilter(nilIgnore),m_ApplyProcessFilter(nilIgnore),m_GetProcessorInfo(nilIgnore),m_GetStorageInfo(nilIgnore),m_LocalFileSystemsOnly(nilIgnore),m_GetSoftwareInfo(nilIgnore),m_MemThreshold(nilIgnore),m_DiskThreshold(nilIgnore),m_CpuThreshold(nilIgnore),m_AutoRefresh(nilIgnore),m_MemThresholdType(nilIgnore),m_DiskThresholdType(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetTargetClusterInfoRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CGetTargetClusterInfoRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"TargetClusters\" type=\"tns:EspStringArray\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"AddProcessesToFilter\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"ApplyProcessFilter\" type=\"xsd:boolean\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"GetProcessorInfo\" type=\"xsd:boolean\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"GetStorageInfo\" type=\"xsd:boolean\"/>\n");
		if (!context.suppressed("GetTargetClusterInfoRequest","LocalFileSystemsOnly")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"LocalFileSystemsOnly\" type=\"xsd:boolean\"/>\n");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"GetSoftwareInfo\" type=\"xsd:boolean\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"MemThreshold\" type=\"xsd:int\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"DiskThreshold\" type=\"xsd:int\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"CpuThreshold\" type=\"xsd:int\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"AutoRefresh\" type=\"xsd:int\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"MemThresholdType\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"DiskThresholdType\" type=\"xsd:string\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	if (added.getValue("EspStringArray")==NULL) {
		addEspNativeArray(schema,"string","EspStringArray");
		added.setValue("EspStringArray",1);
	}
	return schema;
}

void CGetTargetClusterInfoRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CGetTargetClusterInfoRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
	info.addMinVersion("GetTargetClusterInfoRequest","LocalFileSystemsOnly",1.11);
}

StringBuffer &CGetTargetClusterInfoRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("TargetClusters");
	form.appendf("<tr><td><b>TargetClusters: </b></td><td>");
	form.appendf("<textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea>", extfix.str());
	form.append("</td></tr>");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("AddProcessesToFilter");
	form.appendf("  <tr><td><b>AddProcessesToFilter: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("ApplyProcessFilter");
	
	form.appendf("  <tr><td><b>ApplyProcessFilter? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("GetProcessorInfo");
	
	form.appendf("  <tr><td><b>GetProcessorInfo? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("GetStorageInfo");
	
	form.appendf("  <tr><td><b>GetStorageInfo? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	if (!context.suppressed("GetTargetClusterInfoRequest","LocalFileSystemsOnly")) {
		extfix.clear();
		if (prefix && *prefix)
			extfix.append(prefix).append(".");
		extfix.append("LocalFileSystemsOnly");
		
	form.appendf("  <tr><td><b>LocalFileSystemsOnly? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	}
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("GetSoftwareInfo");
	
	form.appendf("  <tr><td><b>GetSoftwareInfo? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	extfix.clear();
	if (prefix && *prefix) extfix.append(prefix).append(".");
		extfix.append("MemThreshold");
	form.appendf("  <tr><td><b>MemThreshold: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix) extfix.append(prefix).append(".");
		extfix.append("DiskThreshold");
	form.appendf("  <tr><td><b>DiskThreshold: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix) extfix.append(prefix).append(".");
		extfix.append("CpuThreshold");
	form.appendf("  <tr><td><b>CpuThreshold: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix) extfix.append(prefix).append(".");
		extfix.append("AutoRefresh");
	form.appendf("  <tr><td><b>AutoRefresh: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("MemThresholdType");
	form.appendf("  <tr><td><b>MemThresholdType: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("DiskThresholdType");
	form.appendf("  <tr><td><b>DiskThresholdType: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CGetTargetClusterInfoRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CGetTargetClusterInfoRequest::serialize(IRpcMessage& rpc_resp)
{
	IEspContext* ctx = rpc_resp.queryContext();
	double clientVer= ctx ? ctx->getClientVersion() : -1; /* no context gets everything */
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_TargetClusters.marshall(rpc_resp, "TargetClusters", "Item");
	m_AddProcessesToFilter.marshall(rpc_resp, "AddProcessesToFilter", "", "", "");
	m_ApplyProcessFilter.marshall(rpc_resp, "ApplyProcessFilter", "", "", "");
	m_GetProcessorInfo.marshall(rpc_resp, "GetProcessorInfo", "", "", "");
	m_GetStorageInfo.marshall(rpc_resp, "GetStorageInfo", "", "", "");
	if ((clientVer==-1.0 || clientVer>=1.11))
		m_LocalFileSystemsOnly.marshall(rpc_resp, "LocalFileSystemsOnly", "", "", "");
	m_GetSoftwareInfo.marshall(rpc_resp, "GetSoftwareInfo", "", "", "");
	m_MemThreshold.marshall(rpc_resp, "MemThreshold", "", "", "");
	m_DiskThreshold.marshall(rpc_resp, "DiskThreshold", "", "", "");
	m_CpuThreshold.marshall(rpc_resp, "CpuThreshold", "", "", "");
	m_AutoRefresh.marshall(rpc_resp, "AutoRefresh", "", "", "");
	m_MemThresholdType.marshall(rpc_resp, "MemThresholdType", "", "", "");
	m_DiskThresholdType.marshall(rpc_resp, "DiskThresholdType", "", "", "");
}


void CGetTargetClusterInfoRequest::copy(CGetTargetClusterInfoRequest &from)
{
	m_TargetClusters.copy(from.m_TargetClusters);
	m_AddProcessesToFilter.copy(from.m_AddProcessesToFilter);
	m_ApplyProcessFilter.copy(from.m_ApplyProcessFilter);
	m_GetProcessorInfo.copy(from.m_GetProcessorInfo);
	m_GetStorageInfo.copy(from.m_GetStorageInfo);
	m_LocalFileSystemsOnly.copy(from.m_LocalFileSystemsOnly);
	m_GetSoftwareInfo.copy(from.m_GetSoftwareInfo);
	m_MemThreshold.copy(from.m_MemThreshold);
	m_DiskThreshold.copy(from.m_DiskThreshold);
	m_CpuThreshold.copy(from.m_CpuThreshold);
	m_AutoRefresh.copy(from.m_AutoRefresh);
	m_MemThresholdType.copy(from.m_MemThresholdType);
	m_DiskThresholdType.copy(from.m_DiskThresholdType);
}


void CGetTargetClusterInfoRequest::copy(IConstGetTargetClusterInfoRequest &ifrom)
{
	setTargetClusters(ifrom.getTargetClusters());
	setAddProcessesToFilter(ifrom.getAddProcessesToFilter());
	setApplyProcessFilter(ifrom.getApplyProcessFilter());
	setGetProcessorInfo(ifrom.getGetProcessorInfo());
	setGetStorageInfo(ifrom.getGetStorageInfo());
	setLocalFileSystemsOnly(ifrom.getLocalFileSystemsOnly());
	setGetSoftwareInfo(ifrom.getGetSoftwareInfo());
	setMemThreshold(ifrom.getMemThreshold());
	setDiskThreshold(ifrom.getDiskThreshold());
	setCpuThreshold(ifrom.getCpuThreshold());
	setAutoRefresh(ifrom.getAutoRefresh());
	setMemThresholdType(ifrom.getMemThresholdType());
	setDiskThresholdType(ifrom.getDiskThresholdType());
}


void CGetTargetClusterInfoRequest::getAttributes(IProperties &attributes)
{
}


void CGetTargetClusterInfoRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	double clientVer = ctx ? ctx->getClientVersion() : -1;
	m_TargetClusters.toStr(ctx, buffer, "TargetClusters", "Item");
	m_AddProcessesToFilter.toStr(ctx, buffer, "AddProcessesToFilter", "", true, "", "");
	m_ApplyProcessFilter.toStr(ctx, buffer, "ApplyProcessFilter", "", true, "", "");
	m_GetProcessorInfo.toStr(ctx, buffer, "GetProcessorInfo", "", true, "", "");
	m_GetStorageInfo.toStr(ctx, buffer, "GetStorageInfo", "", true, "", "");
	if ((clientVer==-1.0 || clientVer>=1.11))
		m_LocalFileSystemsOnly.toStr(ctx, buffer, "LocalFileSystemsOnly", "", true, "", "");
	m_GetSoftwareInfo.toStr(ctx, buffer, "GetSoftwareInfo", "", true, "", "");
	m_MemThreshold.toStr(ctx, buffer, "MemThreshold", "", true, "", "");
	m_DiskThreshold.toStr(ctx, buffer, "DiskThreshold", "", true, "", "");
	m_CpuThreshold.toStr(ctx, buffer, "CpuThreshold", "", true, "", "");
	m_AutoRefresh.toStr(ctx, buffer, "AutoRefresh", "", true, "", "");
	m_MemThresholdType.toStr(ctx, buffer, "MemThresholdType", "", true, "", "");
	m_DiskThresholdType.toStr(ctx, buffer, "DiskThresholdType", "", true, "", "");
}


void CGetTargetClusterInfoRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CGetTargetClusterInfoRequest::serializer(IEspContext* ctx, IConstGetTargetClusterInfoRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<GetTargetClusterInfoRequest>");
	double clientVer = ctx ? ctx->getClientVersion() : -1;
	// field TargetClusters
	{
		StringArray& v = src.getTargetClusters();
		if (v.length()>0)
			buffer.append("<TargetClusters>");
		for (size32_t i=0;i<v.length();i++)
			buffer.appendf("<Item>%s</Item>",v.item(i));
		if (v.length()>0)
			buffer.append("</TargetClusters>");
	}
	// field AddProcessesToFilter
	{
		const char* s = src.getAddProcessesToFilter();
		if (s && *s)
		{
			buffer.append("<AddProcessesToFilter>");
			encodeUtf8XML(s,buffer);
			buffer.append("</AddProcessesToFilter>");
		}
	}
	// field ApplyProcessFilter
	{
		bool b = src.getApplyProcessFilter();
		if (b)
			buffer.appendf("<ApplyProcessFilter>1</ApplyProcessFilter>");
	}
	// field GetProcessorInfo
	{
		bool b = src.getGetProcessorInfo();
		if (b)
			buffer.appendf("<GetProcessorInfo>1</GetProcessorInfo>");
	}
	// field GetStorageInfo
	{
		bool b = src.getGetStorageInfo();
		if (b)
			buffer.appendf("<GetStorageInfo>1</GetStorageInfo>");
	}
	// field LocalFileSystemsOnly
	if ((clientVer==-1.0 || clientVer>=1.11))
	{
		bool b = src.getLocalFileSystemsOnly();
		if (b)
			buffer.appendf("<LocalFileSystemsOnly>1</LocalFileSystemsOnly>");
	}
	// field GetSoftwareInfo
	{
		bool b = src.getGetSoftwareInfo();
		if (b)
			buffer.appendf("<GetSoftwareInfo>1</GetSoftwareInfo>");
	}
	// field MemThreshold
	{
		int n = src.getMemThreshold();
		if (n)
			buffer.appendf("<MemThreshold>%d</MemThreshold>", n);
	}
	// field DiskThreshold
	{
		int n = src.getDiskThreshold();
		if (n)
			buffer.appendf("<DiskThreshold>%d</DiskThreshold>", n);
	}
	// field CpuThreshold
	{
		int n = src.getCpuThreshold();
		if (n)
			buffer.appendf("<CpuThreshold>%d</CpuThreshold>", n);
	}
	// field AutoRefresh
	{
		int n = src.getAutoRefresh();
		if (n)
			buffer.appendf("<AutoRefresh>%d</AutoRefresh>", n);
	}
	// field MemThresholdType
	{
		const char* s = src.getMemThresholdType();
		if (s && *s)
		{
			buffer.append("<MemThresholdType>");
			encodeUtf8XML(s,buffer);
			buffer.append("</MemThresholdType>");
		}
	}
	// field DiskThresholdType
	{
		const char* s = src.getDiskThresholdType();
		if (s && *s)
		{
			buffer.append("<DiskThresholdType>");
			encodeUtf8XML(s,buffer);
			buffer.append("</DiskThresholdType>");
		}
	}
	if (keepRootTag)
		buffer.append("</GetTargetClusterInfoRequest>");
}

bool CGetTargetClusterInfoRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_TargetClusters.unmarshall(rpc_request, "TargetClusters", basepath);
	hasValue |= m_AddProcessesToFilter.unmarshall(rpc_request, "AddProcessesToFilter", basepath);
	hasValue |= m_ApplyProcessFilter.unmarshall(rpc_request, "ApplyProcessFilter", basepath);
	hasValue |= m_GetProcessorInfo.unmarshall(rpc_request, "GetProcessorInfo", basepath);
	hasValue |= m_GetStorageInfo.unmarshall(rpc_request, "GetStorageInfo", basepath);
	hasValue |= m_LocalFileSystemsOnly.unmarshall(rpc_request, "LocalFileSystemsOnly", basepath);
	hasValue |= m_GetSoftwareInfo.unmarshall(rpc_request, "GetSoftwareInfo", basepath);
	hasValue |= m_MemThreshold.unmarshall(rpc_request, "MemThreshold", basepath);
	hasValue |= m_DiskThreshold.unmarshall(rpc_request, "DiskThreshold", basepath);
	hasValue |= m_CpuThreshold.unmarshall(rpc_request, "CpuThreshold", basepath);
	hasValue |= m_AutoRefresh.unmarshall(rpc_request, "AutoRefresh", basepath);
	hasValue |= m_MemThresholdType.unmarshall(rpc_request, "MemThresholdType", basepath);
	hasValue |= m_DiskThresholdType.unmarshall(rpc_request, "DiskThresholdType", basepath);
	return hasValue;
}

bool CGetTargetClusterInfoRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_TargetClusters.unmarshall(ctx, soapval, "TargetClusters");
	hasValue |= m_AddProcessesToFilter.unmarshall(ctx, soapval, "AddProcessesToFilter");
	hasValue |= m_ApplyProcessFilter.unmarshall(ctx, soapval, "ApplyProcessFilter");
	hasValue |= m_GetProcessorInfo.unmarshall(ctx, soapval, "GetProcessorInfo");
	hasValue |= m_GetStorageInfo.unmarshall(ctx, soapval, "GetStorageInfo");
	hasValue |= m_LocalFileSystemsOnly.unmarshall(ctx, soapval, "LocalFileSystemsOnly");
	hasValue |= m_GetSoftwareInfo.unmarshall(ctx, soapval, "GetSoftwareInfo");
	hasValue |= m_MemThreshold.unmarshall(ctx, soapval, "MemThreshold");
	hasValue |= m_DiskThreshold.unmarshall(ctx, soapval, "DiskThreshold");
	hasValue |= m_CpuThreshold.unmarshall(ctx, soapval, "CpuThreshold");
	hasValue |= m_AutoRefresh.unmarshall(ctx, soapval, "AutoRefresh");
	hasValue |= m_MemThresholdType.unmarshall(ctx, soapval, "MemThresholdType");
	hasValue |= m_DiskThresholdType.unmarshall(ctx, soapval, "DiskThresholdType");
	return hasValue;
}

bool CGetTargetClusterInfoRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_TargetClusters.unmarshall(ctx, params, attachments, "TargetClusters", basepath);
	hasValue |= m_AddProcessesToFilter.unmarshall(ctx, params, attachments, "AddProcessesToFilter", basepath);
	hasValue |= m_ApplyProcessFilter.unmarshall(ctx, params, attachments, "ApplyProcessFilter", basepath);
	hasValue |= m_GetProcessorInfo.unmarshall(ctx, params, attachments, "GetProcessorInfo", basepath);
	hasValue |= m_GetStorageInfo.unmarshall(ctx, params, attachments, "GetStorageInfo", basepath);
	hasValue |= m_LocalFileSystemsOnly.unmarshall(ctx, params, attachments, "LocalFileSystemsOnly", basepath);
	hasValue |= m_GetSoftwareInfo.unmarshall(ctx, params, attachments, "GetSoftwareInfo", basepath);
	hasValue |= m_MemThreshold.unmarshall(ctx, params, attachments, "MemThreshold", basepath);
	hasValue |= m_DiskThreshold.unmarshall(ctx, params, attachments, "DiskThreshold", basepath);
	hasValue |= m_CpuThreshold.unmarshall(ctx, params, attachments, "CpuThreshold", basepath);
	hasValue |= m_AutoRefresh.unmarshall(ctx, params, attachments, "AutoRefresh", basepath);
	hasValue |= m_MemThresholdType.unmarshall(ctx, params, attachments, "MemThresholdType", basepath);
	hasValue |= m_DiskThresholdType.unmarshall(ctx, params, attachments, "DiskThresholdType", basepath);
	return hasValue;
}

StringArray & CGetTargetClusterInfoRequest::getTargetClusters() { return (StringArray &) m_TargetClusters; }
const char * CGetTargetClusterInfoRequest::getAddProcessesToFilter() { return m_AddProcessesToFilter.query();}
bool CGetTargetClusterInfoRequest::getApplyProcessFilter() { return m_ApplyProcessFilter;}
bool CGetTargetClusterInfoRequest::getGetProcessorInfo() { return m_GetProcessorInfo;}
bool CGetTargetClusterInfoRequest::getGetStorageInfo() { return m_GetStorageInfo;}
bool CGetTargetClusterInfoRequest::getLocalFileSystemsOnly() { return m_LocalFileSystemsOnly;}
bool CGetTargetClusterInfoRequest::getGetSoftwareInfo() { return m_GetSoftwareInfo;}
int CGetTargetClusterInfoRequest::getMemThreshold() { return m_MemThreshold;}
int CGetTargetClusterInfoRequest::getDiskThreshold() { return m_DiskThreshold;}
int CGetTargetClusterInfoRequest::getCpuThreshold() { return m_CpuThreshold;}
int CGetTargetClusterInfoRequest::getAutoRefresh() { return m_AutoRefresh;}
const char * CGetTargetClusterInfoRequest::getMemThresholdType() { return m_MemThresholdType.query();}
const char * CGetTargetClusterInfoRequest::getDiskThresholdType() { return m_DiskThresholdType.query();}
void CGetTargetClusterInfoRequest::setTargetClusters(StringArray &val){ m_TargetClusters->kill();  CloneArray(m_TargetClusters.getValue(), val); }
void CGetTargetClusterInfoRequest::setAddProcessesToFilter(const char * val){ m_AddProcessesToFilter.set(val); }
void CGetTargetClusterInfoRequest::setApplyProcessFilter(bool val){ m_ApplyProcessFilter=val; }
void CGetTargetClusterInfoRequest::setGetProcessorInfo(bool val){ m_GetProcessorInfo=val; }
void CGetTargetClusterInfoRequest::setGetStorageInfo(bool val){ m_GetStorageInfo=val; }
void CGetTargetClusterInfoRequest::setLocalFileSystemsOnly(bool val){ m_LocalFileSystemsOnly=val; }
void CGetTargetClusterInfoRequest::setGetSoftwareInfo(bool val){ m_GetSoftwareInfo=val; }
void CGetTargetClusterInfoRequest::setMemThreshold(int val){ m_MemThreshold=val; }
void CGetTargetClusterInfoRequest::setDiskThreshold(int val){ m_DiskThreshold=val; }
void CGetTargetClusterInfoRequest::setCpuThreshold(int val){ m_CpuThreshold=val; }
void CGetTargetClusterInfoRequest::setAutoRefresh(int val){ m_AutoRefresh=val; }
void CGetTargetClusterInfoRequest::setMemThresholdType(const char * val){ m_MemThresholdType.set(val); }
void CGetTargetClusterInfoRequest::setDiskThresholdType(const char * val){ m_DiskThresholdType.set(val); }
extern "C"  IEspGetTargetClusterInfoRequest *createGetTargetClusterInfoRequest(const char *serv){return ((IEspGetTargetClusterInfoRequest *)new CGetTargetClusterInfoRequest(serv));}
extern "C"  IClientGetTargetClusterInfoRequest *createClientGetTargetClusterInfoRequest(const char *serv){return ((IClientGetTargetClusterInfoRequest *)new CGetTargetClusterInfoRequest(serv));}

//=======================================================
// class CTargetClusterInfo Implementation
//=======================================================

CTargetClusterInfo::CTargetClusterInfo(const char *serviceName, IRpcMessageBinding *init)
	: m_Name(nilIgnore),m_Type(nilIgnore),m_Processes(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("TargetClusterInfo");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CTargetClusterInfo::CTargetClusterInfo(const char *serviceName, const char *bc)
	: m_Name(nilIgnore),m_Type(nilIgnore),m_Processes(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("TargetClusterInfo");
}

StringBuffer &CTargetClusterInfo::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:complexType name=\"%s\">\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Name\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Type\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Processes\" type=\"tns:ArrayOfMachineInfoEx\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType>\n");
		}
	}
	if (!(flags & 0x10)  || (flags & 0x100))
	{
		CMachineInfoEx::getXsdDefinition(context, request, schema, added);
	}
	if (added.getValue("MachineInfoEx") && added.getValue("ArrayOfMachineInfoEx")==NULL) {
		schema.append("<xsd:complexType name=\"ArrayOfMachineInfoEx\">\n");
		schema.append("<xsd:sequence>\n");
		schema.append("<xsd:element minOccurs=\"0\" maxOccurs=\"unbounded\" name=\"MachineInfoEx\" type=\"tns:MachineInfoEx\"/>\n");
		schema.append("</xsd:sequence>\n");
		schema.append("</xsd:complexType>\n");
		added.setValue("ArrayOfMachineInfoEx",1);
	}
	return schema;
}

void CTargetClusterInfo::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CTargetClusterInfo::getMapInfo(IMapInfo& info, BoolHash& added)
{
	if (!added.getValue("MachineInfoEx"))
	{
		added.setValue("MachineInfoEx",1);
		CMachineInfoEx::getMapInfo(info,added);
	}
}

StringBuffer &CTargetClusterInfo::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Name");
	form.appendf("  <tr><td><b>Name: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Type");
	form.appendf("  <tr><td><b>Type: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Processes");
	form.appendf("<tr><td><b>Processes: </b></td><td>");
	form.appendf("<table><tr><td><textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea></td>", extfix.str());
	form.append("</tr></table>");
	form.append("</td></tr>");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CTargetClusterInfo::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CTargetClusterInfo::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_Name.marshall(rpc_resp, "Name", "", "", "");
	m_Type.marshall(rpc_resp, "Type", "", "", "");
	m_Processes.marshall(rpc_resp, "Processes", "MachineInfoEx");
}


void CTargetClusterInfo::copy(CTargetClusterInfo &from)
{
	m_Name.copy(from.m_Name);
	m_Type.copy(from.m_Type);
	m_Processes.copy(from.m_Processes);
}


void CTargetClusterInfo::copy(IConstTargetClusterInfo &ifrom)
{
	setName(ifrom.getName());
	setType(ifrom.getType());
	setProcesses(ifrom.getProcesses());
}


void CTargetClusterInfo::getAttributes(IProperties &attributes)
{
}


void CTargetClusterInfo::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_Name.toStr(ctx, buffer, "Name", "", true, "", "");
	m_Type.toStr(ctx, buffer, "Type", "", true, "", "");
	m_Processes.toStr(ctx, buffer, "Processes", "MachineInfoEx");
}


void CTargetClusterInfo::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CTargetClusterInfo::serializer(IEspContext* ctx, IConstTargetClusterInfo &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<TargetClusterInfo>");
	// field Name
	{
		const char* s = src.getName();
		if (s && *s)
		{
			buffer.append("<Name>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Name>");
		}
	}
	// field Type
	{
		const char* s = src.getType();
		if (s && *s)
		{
			buffer.append("<Type>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Type>");
		}
	}
	// field Processes
	{
		IArrayOf<IConstMachineInfoEx>& v = src.getProcesses();
		int size = v.length();
		if (size>0)
			buffer.append("<Processes>");
		for (int i=0;i<size;i++)
		{
			buffer.append("<Item>");
			CMachineInfoEx::serializer(ctx,v.item(i),buffer,false);
			buffer.append("</Item>");
		}
		if (size>0)
			buffer.append("</Processes>");
	}
	if (keepRootTag)
		buffer.append("</TargetClusterInfo>");
}

bool CTargetClusterInfo::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_Name.unmarshall(rpc_request, "Name", basepath);
	hasValue |= m_Type.unmarshall(rpc_request, "Type", basepath);
	hasValue |= m_Processes.unmarshall(rpc_request, "Processes", basepath);
	return hasValue;
}

bool CTargetClusterInfo::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Name.unmarshall(ctx, soapval, "Name");
	hasValue |= m_Type.unmarshall(ctx, soapval, "Type");
	hasValue |= m_Processes.unmarshall(ctx, soapval, "Processes");
	return hasValue;
}

bool CTargetClusterInfo::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Name.unmarshall(ctx, params, attachments, "Name", basepath);
	hasValue |= m_Type.unmarshall(ctx, params, attachments, "Type", basepath);
	hasValue |= m_Processes.unmarshall(ctx, params, attachments, "Processes", basepath);
	return hasValue;
}

const char * CTargetClusterInfo::getName() { return m_Name.query();}
const char * CTargetClusterInfo::getType() { return m_Type.query();}
IArrayOf<IConstMachineInfoEx> & CTargetClusterInfo::getProcesses() { return (IArrayOf<IConstMachineInfoEx> &) m_Processes; }
void CTargetClusterInfo::setName(const char * val){ m_Name.set(val); }
void CTargetClusterInfo::setType(const char * val){ m_Type.set(val); }
void CTargetClusterInfo::setProcesses(IArrayOf<IEspMachineInfoEx> &val)
{
	m_Processes->kill();
	IArrayOf<IConstMachineInfoEx> &target = m_Processes.getValue();
	ForEachItemIn(idx, val)
	{
		IEspMachineInfoEx &item = (val).item(idx);
		item.Link();
		target.append(item);
	}
}
void CTargetClusterInfo::setProcesses(IArrayOf<IConstMachineInfoEx> &val)
{
	m_Processes->kill();
	IArrayOf<IConstMachineInfoEx> &target = m_Processes.getValue();
	ForEachItemIn(idx, val)
	{
		IConstMachineInfoEx &item = val.item(idx);
		item.Link();
		target.append(item);
	}
}
extern "C"  IEspTargetClusterInfo *createTargetClusterInfo(const char *serv, const char *msgname){return ((IEspTargetClusterInfo *)new CTargetClusterInfo(serv /*, msgname*/));}
extern "C"  IClientTargetClusterInfo *createClientTargetClusterInfo(const char *serv, const char *msgname){return ((IClientTargetClusterInfo *)new CTargetClusterInfo(serv /*, msgname*/));}

//=======================================================
// class CGetTargetClusterInfoResponse Implementation
//=======================================================

CGetTargetClusterInfoResponse::CGetTargetClusterInfoResponse(const char *serviceName, IRpcMessageBinding *init)
	: m_Columns(nilIgnore),m_RequestInfo(serviceName, nilIgnore),m_TargetClusterInfoList(nilIgnore),m_TimeStamp(nilIgnore),m_AcceptLanguage(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetTargetClusterInfoResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CGetTargetClusterInfoResponse::CGetTargetClusterInfoResponse(const char *serviceName, const char *bc)
	: m_Columns(nilIgnore),m_RequestInfo(serviceName, nilIgnore),m_TargetClusterInfoList(nilIgnore),m_TimeStamp(nilIgnore),m_AcceptLanguage(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetTargetClusterInfoResponse");
}

CGetTargetClusterInfoResponse::CGetTargetClusterInfoResponse(const char *serviceName, IRpcMessage* rpcmsg)
	: m_Columns(nilIgnore),m_RequestInfo(serviceName, nilIgnore),m_TargetClusterInfoList(nilIgnore),m_TimeStamp(nilIgnore),m_AcceptLanguage(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetTargetClusterInfoResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CGetTargetClusterInfoResponse::CGetTargetClusterInfoResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_Columns(nilIgnore),m_RequestInfo(serviceName, nilIgnore),m_TargetClusterInfoList(nilIgnore),m_TimeStamp(nilIgnore),m_AcceptLanguage(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetTargetClusterInfoResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CGetTargetClusterInfoResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		schema.append("<xsd:element name=\"Exceptions\" type=\"tns:ArrayOfEspException\" minOccurs=\"0\" maxOccurs=\"1\"/>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Columns\" type=\"tns:EspStringArray\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"RequestInfo\" type=\"tns:RequestInfoStruct\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"TargetClusterInfoList\" type=\"tns:ArrayOfTargetClusterInfo\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"TimeStamp\" type=\"xsd:string\"/>\n");
		if (!context.suppressed("GetTargetClusterInfoResponse","AcceptLanguage")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"AcceptLanguage\" type=\"xsd:string\"/>\n");
		}
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	if (!(flags & 0x10)  || (flags & 0x100))
	{
		CRequestInfoStruct::getXsdDefinition(context, request, schema, added);
		CTargetClusterInfo::getXsdDefinition(context, request, schema, added);
	}
	if (added.getValue("EspStringArray")==NULL) {
		addEspNativeArray(schema,"string","EspStringArray");
		added.setValue("EspStringArray",1);
	}
	if (added.getValue("TargetClusterInfo") && added.getValue("ArrayOfTargetClusterInfo")==NULL) {
		schema.append("<xsd:complexType name=\"ArrayOfTargetClusterInfo\">\n");
		schema.append("<xsd:sequence>\n");
		schema.append("<xsd:element minOccurs=\"0\" maxOccurs=\"unbounded\" name=\"TargetClusterInfo\" type=\"tns:TargetClusterInfo\"/>\n");
		schema.append("</xsd:sequence>\n");
		schema.append("</xsd:complexType>\n");
		added.setValue("ArrayOfTargetClusterInfo",1);
	}
	return schema;
}

void CGetTargetClusterInfoResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CGetTargetClusterInfoResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
	info.addMinVersion("GetTargetClusterInfoResponse","AcceptLanguage",1.12);
	if (!added.getValue("RequestInfoStruct"))
	{
		added.setValue("RequestInfoStruct",1);
		CRequestInfoStruct::getMapInfo(info,added);
	}
	if (!added.getValue("TargetClusterInfo"))
	{
		added.setValue("TargetClusterInfo",1);
		CTargetClusterInfo::getMapInfo(info,added);
	}
}

StringBuffer &CGetTargetClusterInfoResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Columns");
	form.appendf("<tr><td><b>Columns: </b></td><td>");
	form.appendf("<textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea>", extfix.str());
	form.append("</td></tr>");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("RequestInfo");
	form.append("<tr>").append("<td><b>RequestInfo: </b></td><td><hr/>");
	CRequestInfoStruct::getHtmlForm(context, request, serv, method, form, false, extfix.str());
	form.append("<hr/></td></tr>");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("TargetClusterInfoList");
	form.appendf("<tr><td><b>TargetClusterInfoList: </b></td><td>");
	form.appendf("<table><tr><td><textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea></td>", extfix.str());
	form.append("</tr></table>");
	form.append("</td></tr>");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("TimeStamp");
	form.appendf("  <tr><td><b>TimeStamp: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (!context.suppressed("GetTargetClusterInfoResponse","AcceptLanguage")) {
		extfix.clear();
		if (prefix && *prefix)
			extfix.append(prefix).append(".");
		extfix.append("AcceptLanguage");
		form.appendf("  <tr><td><b>AcceptLanguage: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
		form.append("</td></tr>\n");
	}
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CGetTargetClusterInfoResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CGetTargetClusterInfoResponse::serialize(IRpcMessage& rpc_resp)
{
	IEspContext* ctx = rpc_resp.queryContext();
	double clientVer= ctx ? ctx->getClientVersion() : -1; /* no context gets everything */
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	rpc_resp.setEncodeXml(false);
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
		m_Columns.marshall(rpc_resp, "Columns", "Item");
		m_RequestInfo.marshall(rpc_resp, "RequestInfo", "", "", "");
		m_TargetClusterInfoList.marshall(rpc_resp, "TargetClusterInfoList", "TargetClusterInfo");
		m_TimeStamp.marshall(rpc_resp, "TimeStamp", "", "", "");
		if ((clientVer==-1.0 || clientVer>=1.12))
			m_AcceptLanguage.marshall(rpc_resp, "AcceptLanguage", "", "", "");
	}
}


void CGetTargetClusterInfoResponse::copy(CGetTargetClusterInfoResponse &from)
{
	m_Columns.copy(from.m_Columns);
	m_RequestInfo.copy(from.m_RequestInfo);
	m_TargetClusterInfoList.copy(from.m_TargetClusterInfoList);
	m_TimeStamp.copy(from.m_TimeStamp);
	m_AcceptLanguage.copy(from.m_AcceptLanguage);
}


void CGetTargetClusterInfoResponse::copy(IConstGetTargetClusterInfoResponse &ifrom)
{
	setColumns(ifrom.getColumns());
	setRequestInfo(ifrom.getRequestInfo());
	setTargetClusterInfoList(ifrom.getTargetClusterInfoList());
	setTimeStamp(ifrom.getTimeStamp());
	setAcceptLanguage(ifrom.getAcceptLanguage());
}


void CGetTargetClusterInfoResponse::getAttributes(IProperties &attributes)
{
}


void CGetTargetClusterInfoResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
		double clientVer = ctx ? ctx->getClientVersion() : -1;
		m_Columns.toStr(ctx, buffer, "Columns", "Item");
		m_RequestInfo.toStr(ctx, buffer, "RequestInfo", "", false, "", "");
		m_TargetClusterInfoList.toStr(ctx, buffer, "TargetClusterInfoList", "TargetClusterInfo");
		m_TimeStamp.toStr(ctx, buffer, "TimeStamp", "", false, "", "");
		if ((clientVer==-1.0 || clientVer>=1.12))
			m_AcceptLanguage.toStr(ctx, buffer, "AcceptLanguage", "", false, "", "");
	}
}


void CGetTargetClusterInfoResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CGetTargetClusterInfoResponse::serializer(IEspContext* ctx, IConstGetTargetClusterInfoResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<GetTargetClusterInfoResponse>");
	double clientVer = ctx ? ctx->getClientVersion() : -1;
	// field Columns
	{
		StringArray& v = src.getColumns();
		if (v.length()>0)
			buffer.append("<Columns>");
		for (size32_t i=0;i<v.length();i++)
			buffer.appendf("<Item>%s</Item>",v.item(i));
		if (v.length()>0)
			buffer.append("</Columns>");
	}
	// field RequestInfo
	{
		StringBuffer tmp;
		CRequestInfoStruct::serializer(ctx,src.getRequestInfo(), tmp, false);
		if (tmp.length()>0)
			buffer.appendf("<RequestInfo>%s</RequestInfo>",tmp.str());
	}
	// field TargetClusterInfoList
	{
		IArrayOf<IConstTargetClusterInfo>& v = src.getTargetClusterInfoList();
		int size = v.length();
		if (size>0)
			buffer.append("<TargetClusterInfoList>");
		for (int i=0;i<size;i++)
		{
			buffer.append("<Item>");
			CTargetClusterInfo::serializer(ctx,v.item(i),buffer,false);
			buffer.append("</Item>");
		}
		if (size>0)
			buffer.append("</TargetClusterInfoList>");
	}
	// field TimeStamp
	{
		const char* s = src.getTimeStamp();
		if (s && *s)
		buffer.appendf("<TimeStamp>%s</TimeStamp>",s);
	}
	// field AcceptLanguage
	if ((clientVer==-1.0 || clientVer>=1.12))
	{
		const char* s = src.getAcceptLanguage();
		if (s && *s)
		buffer.appendf("<AcceptLanguage>%s</AcceptLanguage>",s);
	}
	if (keepRootTag)
		buffer.append("</GetTargetClusterInfoResponse>");
}

bool CGetTargetClusterInfoResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
		hasValue |= m_Columns.unmarshall(rpc_request, "Columns", basepath);
		hasValue |= m_RequestInfo.unmarshall(rpc_request, "RequestInfo", basepath);
		hasValue |= m_TargetClusterInfoList.unmarshall(rpc_request, "TargetClusterInfoList", basepath);
		hasValue |= m_TimeStamp.unmarshall(rpc_request, "TimeStamp", basepath);
		hasValue |= m_AcceptLanguage.unmarshall(rpc_request, "AcceptLanguage", basepath);
	}
	return hasValue;
}

bool CGetTargetClusterInfoResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Columns.unmarshall(ctx, soapval, "Columns");
	hasValue |= m_RequestInfo.unmarshall(ctx, soapval, "RequestInfo");
	hasValue |= m_TargetClusterInfoList.unmarshall(ctx, soapval, "TargetClusterInfoList");
	hasValue |= m_TimeStamp.unmarshall(ctx, soapval, "TimeStamp");
	hasValue |= m_AcceptLanguage.unmarshall(ctx, soapval, "AcceptLanguage");
	return hasValue;
}

bool CGetTargetClusterInfoResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Columns.unmarshall(ctx, params, attachments, "Columns", basepath);
	hasValue |= m_RequestInfo.unmarshall(ctx, params, attachments, "RequestInfo", basepath);
	hasValue |= m_TargetClusterInfoList.unmarshall(ctx, params, attachments, "TargetClusterInfoList", basepath);
	hasValue |= m_TimeStamp.unmarshall(ctx, params, attachments, "TimeStamp", basepath);
	hasValue |= m_AcceptLanguage.unmarshall(ctx, params, attachments, "AcceptLanguage", basepath);
	return hasValue;
}

StringArray & CGetTargetClusterInfoResponse::getColumns() { return (StringArray &) m_Columns; }
IConstRequestInfoStruct & CGetTargetClusterInfoResponse::getRequestInfo() { return (IConstRequestInfoStruct &) m_RequestInfo.getValue();}
IArrayOf<IConstTargetClusterInfo> & CGetTargetClusterInfoResponse::getTargetClusterInfoList() { return (IArrayOf<IConstTargetClusterInfo> &) m_TargetClusterInfoList; }
const char * CGetTargetClusterInfoResponse::getTimeStamp() { return m_TimeStamp.query();}
const char * CGetTargetClusterInfoResponse::getAcceptLanguage() { return m_AcceptLanguage.query();}
void CGetTargetClusterInfoResponse::setColumns(StringArray &val){ m_Columns->kill();  CloneArray(m_Columns.getValue(), val); }
IEspRequestInfoStruct & CGetTargetClusterInfoResponse::updateRequestInfo(){ return (IEspRequestInfoStruct &) m_RequestInfo.getValue(); }
void CGetTargetClusterInfoResponse::setRequestInfo(IConstRequestInfoStruct &ifrom){ m_RequestInfo.copy(ifrom); }
void CGetTargetClusterInfoResponse::setTargetClusterInfoList(IArrayOf<IEspTargetClusterInfo> &val)
{
	m_TargetClusterInfoList->kill();
	IArrayOf<IConstTargetClusterInfo> &target = m_TargetClusterInfoList.getValue();
	ForEachItemIn(idx, val)
	{
		IEspTargetClusterInfo &item = (val).item(idx);
		item.Link();
		target.append(item);
	}
}
void CGetTargetClusterInfoResponse::setTargetClusterInfoList(IArrayOf<IConstTargetClusterInfo> &val)
{
	m_TargetClusterInfoList->kill();
	IArrayOf<IConstTargetClusterInfo> &target = m_TargetClusterInfoList.getValue();
	ForEachItemIn(idx, val)
	{
		IConstTargetClusterInfo &item = val.item(idx);
		item.Link();
		target.append(item);
	}
}
void CGetTargetClusterInfoResponse::setTimeStamp(const char * val){ m_TimeStamp.set(val); }
void CGetTargetClusterInfoResponse::setAcceptLanguage(const char * val){ m_AcceptLanguage.set(val); }
extern "C"  IEspGetTargetClusterInfoResponse *createGetTargetClusterInfoResponse(const char *serv){return ((IEspGetTargetClusterInfoResponse *)new CGetTargetClusterInfoResponse(serv));}
extern "C"  IClientGetTargetClusterInfoResponse *createClientGetTargetClusterInfoResponse(const char *serv){return ((IClientGetTargetClusterInfoResponse *)new CGetTargetClusterInfoResponse(serv));}

//=======================================================
// class CStatusReport Implementation
//=======================================================

CStatusReport::CStatusReport(const char *serviceName, IRpcMessageBinding *init)
	: m_StatusID(nilRemove),m_Status(nilRemove),m_StatusDetails(nilRemove),m_Reporter(nilRemove),m_TimeReported(nilRemove),m_TimeReportedStr(nilRemove),m_TimeCached(nilRemove),m_URL(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("StatusReport");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CStatusReport::CStatusReport(const char *serviceName, const char *bc)
	: m_StatusID(nilRemove),m_Status(nilRemove),m_StatusDetails(nilRemove),m_Reporter(nilRemove),m_TimeReported(nilRemove),m_TimeReportedStr(nilRemove),m_TimeCached(nilRemove),m_URL(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("StatusReport");
}

StringBuffer &CStatusReport::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:complexType name=\"%s\">\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"StatusID\" type=\"xsd:int\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Status\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"StatusDetails\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Reporter\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"TimeReported\" type=\"xsd:long\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"TimeReportedStr\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"TimeCached\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"URL\" type=\"xsd:string\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType>\n");
		}
	}
	return schema;
}

void CStatusReport::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CStatusReport::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CStatusReport::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix) extfix.append(prefix).append(".");
		extfix.append("StatusID");
	form.appendf("  <tr><td><b>StatusID: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Status");
	form.appendf("  <tr><td><b>Status: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("StatusDetails");
	form.appendf("  <tr><td><b>StatusDetails: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Reporter");
	form.appendf("  <tr><td><b>Reporter: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("TimeReported");
	form.appendf("  <tr><td><b>TimeReported: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("TimeReportedStr");
	form.appendf("  <tr><td><b>TimeReportedStr: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("TimeCached");
	form.appendf("  <tr><td><b>TimeCached: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("URL");
	form.appendf("  <tr><td><b>URL: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CStatusReport::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CStatusReport::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_StatusID.marshall(rpc_resp, "StatusID", "", "", "");
	m_Status.marshall(rpc_resp, "Status", "", "", "");
	m_StatusDetails.marshall(rpc_resp, "StatusDetails", "", "", "");
	m_Reporter.marshall(rpc_resp, "Reporter", "", "", "");
	m_TimeReported.marshall(rpc_resp, "TimeReported", "", "", "");
	m_TimeReportedStr.marshall(rpc_resp, "TimeReportedStr", "", "", "");
	m_TimeCached.marshall(rpc_resp, "TimeCached", "", "", "");
	m_URL.marshall(rpc_resp, "URL", "", "", "");
}


void CStatusReport::copy(CStatusReport &from)
{
	m_StatusID.copy(from.m_StatusID);
	m_Status.copy(from.m_Status);
	m_StatusDetails.copy(from.m_StatusDetails);
	m_Reporter.copy(from.m_Reporter);
	m_TimeReported.copy(from.m_TimeReported);
	m_TimeReportedStr.copy(from.m_TimeReportedStr);
	m_TimeCached.copy(from.m_TimeCached);
	m_URL.copy(from.m_URL);
}


void CStatusReport::copy(IConstStatusReport &ifrom)
{
	setStatusID(ifrom.getStatusID());
	setStatus(ifrom.getStatus());
	setStatusDetails(ifrom.getStatusDetails());
	setReporter(ifrom.getReporter());
	setTimeReported(ifrom.getTimeReported());
	setTimeReportedStr(ifrom.getTimeReportedStr());
	setTimeCached(ifrom.getTimeCached());
	setURL(ifrom.getURL());
}


void CStatusReport::getAttributes(IProperties &attributes)
{
}


void CStatusReport::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_StatusID.toStr(ctx, buffer, "StatusID", "", true, "", "");
	m_Status.toStr(ctx, buffer, "Status", "", true, "", "");
	m_StatusDetails.toStr(ctx, buffer, "StatusDetails", "", true, "", "");
	m_Reporter.toStr(ctx, buffer, "Reporter", "", true, "", "");
	m_TimeReported.toStr(ctx, buffer, "TimeReported", "", true, "", "");
	m_TimeReportedStr.toStr(ctx, buffer, "TimeReportedStr", "", true, "", "");
	m_TimeCached.toStr(ctx, buffer, "TimeCached", "", true, "", "");
	m_URL.toStr(ctx, buffer, "URL", "", true, "", "");
}


void CStatusReport::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CStatusReport::serializer(IEspContext* ctx, IConstStatusReport &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<StatusReport>");
	// field StatusID
	{
		int n = src.getStatusID();
		if (n)
			buffer.appendf("<StatusID>%d</StatusID>", n);
	}
	// field Status
	{
		const char* s = src.getStatus();
		if (s && *s)
		{
			buffer.append("<Status>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Status>");
		}
	}
	// field StatusDetails
	{
		const char* s = src.getStatusDetails();
		if (s && *s)
		{
			buffer.append("<StatusDetails>");
			encodeUtf8XML(s,buffer);
			buffer.append("</StatusDetails>");
		}
	}
	// field Reporter
	{
		const char* s = src.getReporter();
		if (s && *s)
		{
			buffer.append("<Reporter>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Reporter>");
		}
	}
	// field TimeReported
	{
		//*** default kind: TK_INT; type=int64, name=TimeReported
		buffer.append("<TimeReported>");
		buffer.append(src.getTimeReported());
		buffer.append("</TimeReported>");
	}
	// field TimeReportedStr
	{
		const char* s = src.getTimeReportedStr();
		if (s && *s)
		{
			buffer.append("<TimeReportedStr>");
			encodeUtf8XML(s,buffer);
			buffer.append("</TimeReportedStr>");
		}
	}
	// field TimeCached
	{
		const char* s = src.getTimeCached();
		if (s && *s)
		{
			buffer.append("<TimeCached>");
			encodeUtf8XML(s,buffer);
			buffer.append("</TimeCached>");
		}
	}
	// field URL
	{
		const char* s = src.getURL();
		if (s && *s)
		{
			buffer.append("<URL>");
			encodeUtf8XML(s,buffer);
			buffer.append("</URL>");
		}
	}
	if (keepRootTag)
		buffer.append("</StatusReport>");
}

bool CStatusReport::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_StatusID.unmarshall(rpc_request, "StatusID", basepath);
	hasValue |= m_Status.unmarshall(rpc_request, "Status", basepath);
	hasValue |= m_StatusDetails.unmarshall(rpc_request, "StatusDetails", basepath);
	hasValue |= m_Reporter.unmarshall(rpc_request, "Reporter", basepath);
	hasValue |= m_TimeReported.unmarshall(rpc_request, "TimeReported", basepath);
	hasValue |= m_TimeReportedStr.unmarshall(rpc_request, "TimeReportedStr", basepath);
	hasValue |= m_TimeCached.unmarshall(rpc_request, "TimeCached", basepath);
	hasValue |= m_URL.unmarshall(rpc_request, "URL", basepath);
	return hasValue;
}

bool CStatusReport::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_StatusID.unmarshall(ctx, soapval, "StatusID");
	hasValue |= m_Status.unmarshall(ctx, soapval, "Status");
	hasValue |= m_StatusDetails.unmarshall(ctx, soapval, "StatusDetails");
	hasValue |= m_Reporter.unmarshall(ctx, soapval, "Reporter");
	hasValue |= m_TimeReported.unmarshall(ctx, soapval, "TimeReported");
	hasValue |= m_TimeReportedStr.unmarshall(ctx, soapval, "TimeReportedStr");
	hasValue |= m_TimeCached.unmarshall(ctx, soapval, "TimeCached");
	hasValue |= m_URL.unmarshall(ctx, soapval, "URL");
	return hasValue;
}

bool CStatusReport::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_StatusID.unmarshall(ctx, params, attachments, "StatusID", basepath);
	hasValue |= m_Status.unmarshall(ctx, params, attachments, "Status", basepath);
	hasValue |= m_StatusDetails.unmarshall(ctx, params, attachments, "StatusDetails", basepath);
	hasValue |= m_Reporter.unmarshall(ctx, params, attachments, "Reporter", basepath);
	hasValue |= m_TimeReported.unmarshall(ctx, params, attachments, "TimeReported", basepath);
	hasValue |= m_TimeReportedStr.unmarshall(ctx, params, attachments, "TimeReportedStr", basepath);
	hasValue |= m_TimeCached.unmarshall(ctx, params, attachments, "TimeCached", basepath);
	hasValue |= m_URL.unmarshall(ctx, params, attachments, "URL", basepath);
	return hasValue;
}

bool CStatusReport::getStatusID_isNull(){return m_StatusID.is_nil();}
int CStatusReport::getStatusID() { return m_StatusID;}
const char * CStatusReport::getStatus() { return m_Status.query();}
const char * CStatusReport::getStatusDetails() { return m_StatusDetails.query();}
const char * CStatusReport::getReporter() { return m_Reporter.query();}
bool CStatusReport::getTimeReported_isNull(){return m_TimeReported.is_nil();}
__int64 CStatusReport::getTimeReported() { return m_TimeReported;}
const char * CStatusReport::getTimeReportedStr() { return m_TimeReportedStr.query();}
const char * CStatusReport::getTimeCached() { return m_TimeCached.query();}
const char * CStatusReport::getURL() { return m_URL.query();}
void CStatusReport::setStatusID_null(){ m_StatusID.Nil(); }void CStatusReport::setStatusID(int val){ m_StatusID=val; }
void CStatusReport::setStatus(const char * val){ m_Status.set(val); }
void CStatusReport::setStatusDetails(const char * val){ m_StatusDetails.set(val); }
void CStatusReport::setReporter(const char * val){ m_Reporter.set(val); }
void CStatusReport::setTimeReported_null(){ m_TimeReported.Nil(); }void CStatusReport::setTimeReported(__int64 val){ m_TimeReported=val; }
void CStatusReport::setTimeReportedStr(const char * val){ m_TimeReportedStr.set(val); }
void CStatusReport::setTimeCached(const char * val){ m_TimeCached.set(val); }
void CStatusReport::setURL(const char * val){ m_URL.set(val); }
extern "C"  IEspStatusReport *createStatusReport(const char *serv, const char *msgname){return ((IEspStatusReport *)new CStatusReport(serv /*, msgname*/));}
extern "C"  IClientStatusReport *createClientStatusReport(const char *serv, const char *msgname){return ((IClientStatusReport *)new CStatusReport(serv /*, msgname*/));}

//=======================================================
// class CComponentStatus Implementation
//=======================================================

CComponentStatus::CComponentStatus(const char *serviceName, IRpcMessageBinding *init)
	: m_ComponentTypeID(nilRemove),m_ComponentType(nilRemove),m_EndPoint(nilRemove),m_StatusID(nilRemove),m_Status(nilRemove),m_TimeReported(nilRemove),m_TimeReportedStr(nilRemove),m_Reporter(nilRemove),m_StatusReports(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ComponentStatus");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CComponentStatus::CComponentStatus(const char *serviceName, const char *bc)
	: m_ComponentTypeID(nilRemove),m_ComponentType(nilRemove),m_EndPoint(nilRemove),m_StatusID(nilRemove),m_Status(nilRemove),m_TimeReported(nilRemove),m_TimeReportedStr(nilRemove),m_Reporter(nilRemove),m_StatusReports(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ComponentStatus");
}

StringBuffer &CComponentStatus::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:complexType name=\"%s\">\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"ComponentTypeID\" type=\"xsd:int\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"ComponentType\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"EndPoint\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"StatusID\" type=\"xsd:int\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Status\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"TimeReported\" type=\"xsd:long\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"TimeReportedStr\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Reporter\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"StatusReports\" type=\"tns:ArrayOfStatusReport\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType>\n");
		}
	}
	if (!(flags & 0x10)  || (flags & 0x100))
	{
		CStatusReport::getXsdDefinition(context, request, schema, added);
	}
	if (added.getValue("StatusReport") && added.getValue("ArrayOfStatusReport")==NULL) {
		schema.append("<xsd:complexType name=\"ArrayOfStatusReport\">\n");
		schema.append("<xsd:sequence>\n");
		schema.append("<xsd:element minOccurs=\"0\" maxOccurs=\"unbounded\" name=\"StatusReport\" type=\"tns:StatusReport\"/>\n");
		schema.append("</xsd:sequence>\n");
		schema.append("</xsd:complexType>\n");
		added.setValue("ArrayOfStatusReport",1);
	}
	return schema;
}

void CComponentStatus::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CComponentStatus::getMapInfo(IMapInfo& info, BoolHash& added)
{
	if (!added.getValue("StatusReport"))
	{
		added.setValue("StatusReport",1);
		CStatusReport::getMapInfo(info,added);
	}
}

StringBuffer &CComponentStatus::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix) extfix.append(prefix).append(".");
		extfix.append("ComponentTypeID");
	form.appendf("  <tr><td><b>ComponentTypeID: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("ComponentType");
	form.appendf("  <tr><td><b>ComponentType: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("EndPoint");
	form.appendf("  <tr><td><b>EndPoint: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix) extfix.append(prefix).append(".");
		extfix.append("StatusID");
	form.appendf("  <tr><td><b>StatusID: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Status");
	form.appendf("  <tr><td><b>Status: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("TimeReported");
	form.appendf("  <tr><td><b>TimeReported: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("TimeReportedStr");
	form.appendf("  <tr><td><b>TimeReportedStr: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Reporter");
	form.appendf("  <tr><td><b>Reporter: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("StatusReports");
	form.appendf("<tr><td><b>StatusReports: </b></td><td>");
	form.appendf("<table><tr><td><textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea></td>", extfix.str());
	form.append("</tr></table>");
	form.append("</td></tr>");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CComponentStatus::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CComponentStatus::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_ComponentTypeID.marshall(rpc_resp, "ComponentTypeID", "", "", "");
	m_ComponentType.marshall(rpc_resp, "ComponentType", "", "", "");
	m_EndPoint.marshall(rpc_resp, "EndPoint", "", "", "");
	m_StatusID.marshall(rpc_resp, "StatusID", "", "", "");
	m_Status.marshall(rpc_resp, "Status", "", "", "");
	m_TimeReported.marshall(rpc_resp, "TimeReported", "", "", "");
	m_TimeReportedStr.marshall(rpc_resp, "TimeReportedStr", "", "", "");
	m_Reporter.marshall(rpc_resp, "Reporter", "", "", "");
	m_StatusReports.marshall(rpc_resp, "StatusReports", "StatusReport");
}


void CComponentStatus::copy(CComponentStatus &from)
{
	m_ComponentTypeID.copy(from.m_ComponentTypeID);
	m_ComponentType.copy(from.m_ComponentType);
	m_EndPoint.copy(from.m_EndPoint);
	m_StatusID.copy(from.m_StatusID);
	m_Status.copy(from.m_Status);
	m_TimeReported.copy(from.m_TimeReported);
	m_TimeReportedStr.copy(from.m_TimeReportedStr);
	m_Reporter.copy(from.m_Reporter);
	m_StatusReports.copy(from.m_StatusReports);
}


void CComponentStatus::copy(IConstComponentStatus &ifrom)
{
	setComponentTypeID(ifrom.getComponentTypeID());
	setComponentType(ifrom.getComponentType());
	setEndPoint(ifrom.getEndPoint());
	setStatusID(ifrom.getStatusID());
	setStatus(ifrom.getStatus());
	setTimeReported(ifrom.getTimeReported());
	setTimeReportedStr(ifrom.getTimeReportedStr());
	setReporter(ifrom.getReporter());
	setStatusReports(ifrom.getStatusReports());
}


void CComponentStatus::getAttributes(IProperties &attributes)
{
}


void CComponentStatus::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_ComponentTypeID.toStr(ctx, buffer, "ComponentTypeID", "", true, "", "");
	m_ComponentType.toStr(ctx, buffer, "ComponentType", "", true, "", "");
	m_EndPoint.toStr(ctx, buffer, "EndPoint", "", true, "", "");
	m_StatusID.toStr(ctx, buffer, "StatusID", "", true, "", "");
	m_Status.toStr(ctx, buffer, "Status", "", true, "", "");
	m_TimeReported.toStr(ctx, buffer, "TimeReported", "", true, "", "");
	m_TimeReportedStr.toStr(ctx, buffer, "TimeReportedStr", "", true, "", "");
	m_Reporter.toStr(ctx, buffer, "Reporter", "", true, "", "");
	m_StatusReports.toStr(ctx, buffer, "StatusReports", "StatusReport");
}


void CComponentStatus::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CComponentStatus::serializer(IEspContext* ctx, IConstComponentStatus &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<ComponentStatus>");
	// field ComponentTypeID
	{
		int n = src.getComponentTypeID();
		if (n)
			buffer.appendf("<ComponentTypeID>%d</ComponentTypeID>", n);
	}
	// field ComponentType
	{
		const char* s = src.getComponentType();
		if (s && *s)
		{
			buffer.append("<ComponentType>");
			encodeUtf8XML(s,buffer);
			buffer.append("</ComponentType>");
		}
	}
	// field EndPoint
	{
		const char* s = src.getEndPoint();
		if (s && *s)
		{
			buffer.append("<EndPoint>");
			encodeUtf8XML(s,buffer);
			buffer.append("</EndPoint>");
		}
	}
	// field StatusID
	{
		int n = src.getStatusID();
		if (n)
			buffer.appendf("<StatusID>%d</StatusID>", n);
	}
	// field Status
	{
		const char* s = src.getStatus();
		if (s && *s)
		{
			buffer.append("<Status>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Status>");
		}
	}
	// field TimeReported
	{
		//*** default kind: TK_INT; type=int64, name=TimeReported
		buffer.append("<TimeReported>");
		buffer.append(src.getTimeReported());
		buffer.append("</TimeReported>");
	}
	// field TimeReportedStr
	{
		const char* s = src.getTimeReportedStr();
		if (s && *s)
		{
			buffer.append("<TimeReportedStr>");
			encodeUtf8XML(s,buffer);
			buffer.append("</TimeReportedStr>");
		}
	}
	// field Reporter
	{
		const char* s = src.getReporter();
		if (s && *s)
		{
			buffer.append("<Reporter>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Reporter>");
		}
	}
	// field StatusReports
	{
		IArrayOf<IConstStatusReport>& v = src.getStatusReports();
		int size = v.length();
		if (size>0)
			buffer.append("<StatusReports>");
		for (int i=0;i<size;i++)
		{
			buffer.append("<Item>");
			CStatusReport::serializer(ctx,v.item(i),buffer,false);
			buffer.append("</Item>");
		}
		if (size>0)
			buffer.append("</StatusReports>");
	}
	if (keepRootTag)
		buffer.append("</ComponentStatus>");
}

bool CComponentStatus::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_ComponentTypeID.unmarshall(rpc_request, "ComponentTypeID", basepath);
	hasValue |= m_ComponentType.unmarshall(rpc_request, "ComponentType", basepath);
	hasValue |= m_EndPoint.unmarshall(rpc_request, "EndPoint", basepath);
	hasValue |= m_StatusID.unmarshall(rpc_request, "StatusID", basepath);
	hasValue |= m_Status.unmarshall(rpc_request, "Status", basepath);
	hasValue |= m_TimeReported.unmarshall(rpc_request, "TimeReported", basepath);
	hasValue |= m_TimeReportedStr.unmarshall(rpc_request, "TimeReportedStr", basepath);
	hasValue |= m_Reporter.unmarshall(rpc_request, "Reporter", basepath);
	hasValue |= m_StatusReports.unmarshall(rpc_request, "StatusReports", basepath);
	return hasValue;
}

bool CComponentStatus::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_ComponentTypeID.unmarshall(ctx, soapval, "ComponentTypeID");
	hasValue |= m_ComponentType.unmarshall(ctx, soapval, "ComponentType");
	hasValue |= m_EndPoint.unmarshall(ctx, soapval, "EndPoint");
	hasValue |= m_StatusID.unmarshall(ctx, soapval, "StatusID");
	hasValue |= m_Status.unmarshall(ctx, soapval, "Status");
	hasValue |= m_TimeReported.unmarshall(ctx, soapval, "TimeReported");
	hasValue |= m_TimeReportedStr.unmarshall(ctx, soapval, "TimeReportedStr");
	hasValue |= m_Reporter.unmarshall(ctx, soapval, "Reporter");
	hasValue |= m_StatusReports.unmarshall(ctx, soapval, "StatusReports");
	return hasValue;
}

bool CComponentStatus::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_ComponentTypeID.unmarshall(ctx, params, attachments, "ComponentTypeID", basepath);
	hasValue |= m_ComponentType.unmarshall(ctx, params, attachments, "ComponentType", basepath);
	hasValue |= m_EndPoint.unmarshall(ctx, params, attachments, "EndPoint", basepath);
	hasValue |= m_StatusID.unmarshall(ctx, params, attachments, "StatusID", basepath);
	hasValue |= m_Status.unmarshall(ctx, params, attachments, "Status", basepath);
	hasValue |= m_TimeReported.unmarshall(ctx, params, attachments, "TimeReported", basepath);
	hasValue |= m_TimeReportedStr.unmarshall(ctx, params, attachments, "TimeReportedStr", basepath);
	hasValue |= m_Reporter.unmarshall(ctx, params, attachments, "Reporter", basepath);
	hasValue |= m_StatusReports.unmarshall(ctx, params, attachments, "StatusReports", basepath);
	return hasValue;
}

bool CComponentStatus::getComponentTypeID_isNull(){return m_ComponentTypeID.is_nil();}
int CComponentStatus::getComponentTypeID() { return m_ComponentTypeID;}
const char * CComponentStatus::getComponentType() { return m_ComponentType.query();}
const char * CComponentStatus::getEndPoint() { return m_EndPoint.query();}
bool CComponentStatus::getStatusID_isNull(){return m_StatusID.is_nil();}
int CComponentStatus::getStatusID() { return m_StatusID;}
const char * CComponentStatus::getStatus() { return m_Status.query();}
bool CComponentStatus::getTimeReported_isNull(){return m_TimeReported.is_nil();}
__int64 CComponentStatus::getTimeReported() { return m_TimeReported;}
const char * CComponentStatus::getTimeReportedStr() { return m_TimeReportedStr.query();}
const char * CComponentStatus::getReporter() { return m_Reporter.query();}
IArrayOf<IConstStatusReport> & CComponentStatus::getStatusReports() { return (IArrayOf<IConstStatusReport> &) m_StatusReports; }
void CComponentStatus::setComponentTypeID_null(){ m_ComponentTypeID.Nil(); }void CComponentStatus::setComponentTypeID(int val){ m_ComponentTypeID=val; }
void CComponentStatus::setComponentType(const char * val){ m_ComponentType.set(val); }
void CComponentStatus::setEndPoint(const char * val){ m_EndPoint.set(val); }
void CComponentStatus::setStatusID_null(){ m_StatusID.Nil(); }void CComponentStatus::setStatusID(int val){ m_StatusID=val; }
void CComponentStatus::setStatus(const char * val){ m_Status.set(val); }
void CComponentStatus::setTimeReported_null(){ m_TimeReported.Nil(); }void CComponentStatus::setTimeReported(__int64 val){ m_TimeReported=val; }
void CComponentStatus::setTimeReportedStr(const char * val){ m_TimeReportedStr.set(val); }
void CComponentStatus::setReporter(const char * val){ m_Reporter.set(val); }
void CComponentStatus::setStatusReports(IArrayOf<IEspStatusReport> &val)
{
	m_StatusReports->kill();
	IArrayOf<IConstStatusReport> &target = m_StatusReports.getValue();
	ForEachItemIn(idx, val)
	{
		IEspStatusReport &item = (val).item(idx);
		item.Link();
		target.append(item);
	}
}
void CComponentStatus::setStatusReports(IArrayOf<IConstStatusReport> &val)
{
	m_StatusReports->kill();
	IArrayOf<IConstStatusReport> &target = m_StatusReports.getValue();
	ForEachItemIn(idx, val)
	{
		IConstStatusReport &item = val.item(idx);
		item.Link();
		target.append(item);
	}
}
extern "C"  IEspComponentStatus *createComponentStatus(const char *serv, const char *msgname){return ((IEspComponentStatus *)new CComponentStatus(serv /*, msgname*/));}
extern "C"  IClientComponentStatus *createClientComponentStatus(const char *serv, const char *msgname){return ((IClientComponentStatus *)new CComponentStatus(serv /*, msgname*/));}

//=======================================================
// class CGetComponentStatusRequest Implementation
//=======================================================

CGetComponentStatusRequest::CGetComponentStatusRequest(const char *serviceName, IRpcMessageBinding *init)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetComponentStatusRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CGetComponentStatusRequest::CGetComponentStatusRequest(const char *serviceName, const char *bc)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetComponentStatusRequest");
}

CGetComponentStatusRequest::CGetComponentStatusRequest(const char *serviceName, IRpcMessage* rpcmsg)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetComponentStatusRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CGetComponentStatusRequest::CGetComponentStatusRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetComponentStatusRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CGetComponentStatusRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType><xsd:all/></xsd:complexType></xsd:element>\n", msgTypeName);
		}
	}
	return schema;
}

void CGetComponentStatusRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CGetComponentStatusRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CGetComponentStatusRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CGetComponentStatusRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CGetComponentStatusRequest::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

}


void CGetComponentStatusRequest::copy(CGetComponentStatusRequest &from)
{
}


void CGetComponentStatusRequest::copy(IConstGetComponentStatusRequest &ifrom)
{
}


void CGetComponentStatusRequest::getAttributes(IProperties &attributes)
{
}


void CGetComponentStatusRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
}


void CGetComponentStatusRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CGetComponentStatusRequest::serializer(IEspContext* ctx, IConstGetComponentStatusRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<GetComponentStatusRequest>");
	if (keepRootTag)
		buffer.append("</GetComponentStatusRequest>");
}

bool CGetComponentStatusRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	return hasValue;
}

bool CGetComponentStatusRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	return hasValue;
}

bool CGetComponentStatusRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	return hasValue;
}

extern "C"  IEspGetComponentStatusRequest *createGetComponentStatusRequest(const char *serv){return ((IEspGetComponentStatusRequest *)new CGetComponentStatusRequest(serv));}
extern "C"  IClientGetComponentStatusRequest *createClientGetComponentStatusRequest(const char *serv){return ((IClientGetComponentStatusRequest *)new CGetComponentStatusRequest(serv));}

//=======================================================
// class CGetComponentStatusResponse Implementation
//=======================================================

CGetComponentStatusResponse::CGetComponentStatusResponse(const char *serviceName, IRpcMessageBinding *init)
	: m_StatusCode(nilRemove),m_Status(nilRemove),m_ComponentType(nilRemove),m_EndPoint(nilRemove),m_ComponentStatusID(nilRemove),m_ComponentStatus(nilRemove),m_TimeReported(nilRemove),m_TimeReportedStr(nilRemove),m_Reporter(nilRemove),m_StatusReport(serviceName, nilRemove),m_ComponentStatusList(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetComponentStatusResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CGetComponentStatusResponse::CGetComponentStatusResponse(const char *serviceName, const char *bc)
	: m_StatusCode(nilRemove),m_Status(nilRemove),m_ComponentType(nilRemove),m_EndPoint(nilRemove),m_ComponentStatusID(nilRemove),m_ComponentStatus(nilRemove),m_TimeReported(nilRemove),m_TimeReportedStr(nilRemove),m_Reporter(nilRemove),m_StatusReport(serviceName, nilRemove),m_ComponentStatusList(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetComponentStatusResponse");
}

CGetComponentStatusResponse::CGetComponentStatusResponse(const char *serviceName, IRpcMessage* rpcmsg)
	: m_StatusCode(nilRemove),m_Status(nilRemove),m_ComponentType(nilRemove),m_EndPoint(nilRemove),m_ComponentStatusID(nilRemove),m_ComponentStatus(nilRemove),m_TimeReported(nilRemove),m_TimeReportedStr(nilRemove),m_Reporter(nilRemove),m_StatusReport(serviceName, nilRemove),m_ComponentStatusList(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetComponentStatusResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CGetComponentStatusResponse::CGetComponentStatusResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_StatusCode(nilRemove),m_Status(nilRemove),m_ComponentType(nilRemove),m_EndPoint(nilRemove),m_ComponentStatusID(nilRemove),m_ComponentStatus(nilRemove),m_TimeReported(nilRemove),m_TimeReportedStr(nilRemove),m_Reporter(nilRemove),m_StatusReport(serviceName, nilRemove),m_ComponentStatusList(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetComponentStatusResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CGetComponentStatusResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		schema.append("<xsd:element name=\"Exceptions\" type=\"tns:ArrayOfEspException\" minOccurs=\"0\" maxOccurs=\"1\"/>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"StatusCode\" type=\"xsd:int\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Status\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"ComponentType\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"EndPoint\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"ComponentStatusID\" type=\"xsd:int\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"ComponentStatus\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"TimeReported\" type=\"xsd:long\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"TimeReportedStr\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Reporter\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"StatusReport\" type=\"tns:StatusReport\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"ComponentStatusList\">\n");
		schema.append("<xsd:complexType><xsd:sequence>\n");
		schema.append("<xsd:element minOccurs=\"0\" maxOccurs=\"unbounded\" name=\"ComponentStatus\" type=\"tns:ComponentStatus\"/>");
		schema.append("</xsd:sequence></xsd:complexType>");
		schema.append("</xsd:element>");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	if (!(flags & 0x10)  || (flags & 0x100))
	{
		CStatusReport::getXsdDefinition(context, request, schema, added);
		CComponentStatus::getXsdDefinition(context, request, schema, added);
	}
	return schema;
}

void CGetComponentStatusResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CGetComponentStatusResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
	if (!added.getValue("ComponentStatus"))
	{
		added.setValue("ComponentStatus",1);
		CComponentStatus::getMapInfo(info,added);
	}
	if (!added.getValue("StatusReport"))
	{
		added.setValue("StatusReport",1);
		CStatusReport::getMapInfo(info,added);
	}
}

StringBuffer &CGetComponentStatusResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix) extfix.append(prefix).append(".");
		extfix.append("StatusCode");
	form.appendf("  <tr><td><b>StatusCode: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Status");
	form.appendf("  <tr><td><b>Status: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("ComponentType");
	form.appendf("  <tr><td><b>ComponentType: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("EndPoint");
	form.appendf("  <tr><td><b>EndPoint: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix) extfix.append(prefix).append(".");
		extfix.append("ComponentStatusID");
	form.appendf("  <tr><td><b>ComponentStatusID: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("ComponentStatus");
	form.appendf("  <tr><td><b>ComponentStatus: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("TimeReported");
	form.appendf("  <tr><td><b>TimeReported: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("TimeReportedStr");
	form.appendf("  <tr><td><b>TimeReportedStr: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Reporter");
	form.appendf("  <tr><td><b>Reporter: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("StatusReport");
	form.append("<tr>").append("<td><b>StatusReport: </b></td><td><hr/>");
	CStatusReport::getHtmlForm(context, request, serv, method, form, false, extfix.str());
	form.append("<hr/></td></tr>");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("ComponentStatusList");
	form.appendf("<tr><td><b>ComponentStatusList: </b></td><td>");
	form.appendf("<table><tr><td><textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea></td>", extfix.str());
	form.append("</tr></table>");
	form.append("</td></tr>");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CGetComponentStatusResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CGetComponentStatusResponse::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	rpc_resp.setEncodeXml(false);
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
		m_StatusCode.marshall(rpc_resp, "StatusCode", "", "", "");
		m_Status.marshall(rpc_resp, "Status", "", "", "");
		m_ComponentType.marshall(rpc_resp, "ComponentType", "", "", "");
		m_EndPoint.marshall(rpc_resp, "EndPoint", "", "", "");
		m_ComponentStatusID.marshall(rpc_resp, "ComponentStatusID", "", "", "");
		m_ComponentStatus.marshall(rpc_resp, "ComponentStatus", "", "", "");
		m_TimeReported.marshall(rpc_resp, "TimeReported", "", "", "");
		m_TimeReportedStr.marshall(rpc_resp, "TimeReportedStr", "", "", "");
		m_Reporter.marshall(rpc_resp, "Reporter", "", "", "");
		m_StatusReport.marshall(rpc_resp, "StatusReport", "", "", "");
		m_ComponentStatusList.marshall(rpc_resp, "ComponentStatusList", "ComponentStatus");
	}
}


void CGetComponentStatusResponse::copy(CGetComponentStatusResponse &from)
{
	m_StatusCode.copy(from.m_StatusCode);
	m_Status.copy(from.m_Status);
	m_ComponentType.copy(from.m_ComponentType);
	m_EndPoint.copy(from.m_EndPoint);
	m_ComponentStatusID.copy(from.m_ComponentStatusID);
	m_ComponentStatus.copy(from.m_ComponentStatus);
	m_TimeReported.copy(from.m_TimeReported);
	m_TimeReportedStr.copy(from.m_TimeReportedStr);
	m_Reporter.copy(from.m_Reporter);
	m_StatusReport.copy(from.m_StatusReport);
	m_ComponentStatusList.copy(from.m_ComponentStatusList);
}


void CGetComponentStatusResponse::copy(IConstGetComponentStatusResponse &ifrom)
{
	setStatusCode(ifrom.getStatusCode());
	setStatus(ifrom.getStatus());
	setComponentType(ifrom.getComponentType());
	setEndPoint(ifrom.getEndPoint());
	setComponentStatusID(ifrom.getComponentStatusID());
	setComponentStatus(ifrom.getComponentStatus());
	setTimeReported(ifrom.getTimeReported());
	setTimeReportedStr(ifrom.getTimeReportedStr());
	setReporter(ifrom.getReporter());
	setStatusReport(ifrom.getStatusReport());
	setComponentStatusList(ifrom.getComponentStatusList());
}


void CGetComponentStatusResponse::getAttributes(IProperties &attributes)
{
}


void CGetComponentStatusResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
		m_StatusCode.toStr(ctx, buffer, "StatusCode", "", false, "", "");
		m_Status.toStr(ctx, buffer, "Status", "", false, "", "");
		m_ComponentType.toStr(ctx, buffer, "ComponentType", "", false, "", "");
		m_EndPoint.toStr(ctx, buffer, "EndPoint", "", false, "", "");
		m_ComponentStatusID.toStr(ctx, buffer, "ComponentStatusID", "", false, "", "");
		m_ComponentStatus.toStr(ctx, buffer, "ComponentStatus", "", false, "", "");
		m_TimeReported.toStr(ctx, buffer, "TimeReported", "", false, "", "");
		m_TimeReportedStr.toStr(ctx, buffer, "TimeReportedStr", "", false, "", "");
		m_Reporter.toStr(ctx, buffer, "Reporter", "", false, "", "");
		m_StatusReport.toStr(ctx, buffer, "StatusReport", "", false, "", "");
		m_ComponentStatusList.toStr(ctx, buffer, "ComponentStatusList", "ComponentStatus");
	}
}


void CGetComponentStatusResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CGetComponentStatusResponse::serializer(IEspContext* ctx, IConstGetComponentStatusResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<GetComponentStatusResponse>");
	// field StatusCode
	{
		int n = src.getStatusCode();
		if (n)
			buffer.appendf("<StatusCode>%d</StatusCode>", n);
	}
	// field Status
	{
		const char* s = src.getStatus();
		if (s && *s)
		buffer.appendf("<Status>%s</Status>",s);
	}
	// field ComponentType
	{
		const char* s = src.getComponentType();
		if (s && *s)
		buffer.appendf("<ComponentType>%s</ComponentType>",s);
	}
	// field EndPoint
	{
		const char* s = src.getEndPoint();
		if (s && *s)
		buffer.appendf("<EndPoint>%s</EndPoint>",s);
	}
	// field ComponentStatusID
	{
		int n = src.getComponentStatusID();
		if (n)
			buffer.appendf("<ComponentStatusID>%d</ComponentStatusID>", n);
	}
	// field ComponentStatus
	{
		const char* s = src.getComponentStatus();
		if (s && *s)
		buffer.appendf("<ComponentStatus>%s</ComponentStatus>",s);
	}
	// field TimeReported
	{
		//*** default kind: TK_INT; type=int64, name=TimeReported
		buffer.append("<TimeReported>");
		buffer.append(src.getTimeReported());
		buffer.append("</TimeReported>");
	}
	// field TimeReportedStr
	{
		const char* s = src.getTimeReportedStr();
		if (s && *s)
		buffer.appendf("<TimeReportedStr>%s</TimeReportedStr>",s);
	}
	// field Reporter
	{
		const char* s = src.getReporter();
		if (s && *s)
		buffer.appendf("<Reporter>%s</Reporter>",s);
	}
	// field StatusReport
	{
		StringBuffer tmp;
		CStatusReport::serializer(ctx,src.getStatusReport(), tmp, false);
		if (tmp.length()>0)
			buffer.appendf("<StatusReport>%s</StatusReport>",tmp.str());
	}
	// field ComponentStatusList
	{
		IArrayOf<IConstComponentStatus>& v = src.getComponentStatusList();
		int size = v.length();
		if (size>0)
			buffer.append("<ComponentStatusList>");
		for (int i=0;i<size;i++)
		{
			buffer.append("<ComponentStatus>");
			CComponentStatus::serializer(ctx,v.item(i),buffer,false);
			buffer.append("</ComponentStatus>");
		}
		if (size>0)
			buffer.append("</ComponentStatusList>");
	}
	if (keepRootTag)
		buffer.append("</GetComponentStatusResponse>");
}

bool CGetComponentStatusResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
		hasValue |= m_StatusCode.unmarshall(rpc_request, "StatusCode", basepath);
		hasValue |= m_Status.unmarshall(rpc_request, "Status", basepath);
		hasValue |= m_ComponentType.unmarshall(rpc_request, "ComponentType", basepath);
		hasValue |= m_EndPoint.unmarshall(rpc_request, "EndPoint", basepath);
		hasValue |= m_ComponentStatusID.unmarshall(rpc_request, "ComponentStatusID", basepath);
		hasValue |= m_ComponentStatus.unmarshall(rpc_request, "ComponentStatus", basepath);
		hasValue |= m_TimeReported.unmarshall(rpc_request, "TimeReported", basepath);
		hasValue |= m_TimeReportedStr.unmarshall(rpc_request, "TimeReportedStr", basepath);
		hasValue |= m_Reporter.unmarshall(rpc_request, "Reporter", basepath);
		hasValue |= m_StatusReport.unmarshall(rpc_request, "StatusReport", basepath);
		hasValue |= m_ComponentStatusList.unmarshall(rpc_request, "ComponentStatusList", basepath);
	}
	return hasValue;
}

bool CGetComponentStatusResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_StatusCode.unmarshall(ctx, soapval, "StatusCode");
	hasValue |= m_Status.unmarshall(ctx, soapval, "Status");
	hasValue |= m_ComponentType.unmarshall(ctx, soapval, "ComponentType");
	hasValue |= m_EndPoint.unmarshall(ctx, soapval, "EndPoint");
	hasValue |= m_ComponentStatusID.unmarshall(ctx, soapval, "ComponentStatusID");
	hasValue |= m_ComponentStatus.unmarshall(ctx, soapval, "ComponentStatus");
	hasValue |= m_TimeReported.unmarshall(ctx, soapval, "TimeReported");
	hasValue |= m_TimeReportedStr.unmarshall(ctx, soapval, "TimeReportedStr");
	hasValue |= m_Reporter.unmarshall(ctx, soapval, "Reporter");
	hasValue |= m_StatusReport.unmarshall(ctx, soapval, "StatusReport");
	hasValue |= m_ComponentStatusList.unmarshall(ctx, soapval, "ComponentStatusList");
	return hasValue;
}

bool CGetComponentStatusResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_StatusCode.unmarshall(ctx, params, attachments, "StatusCode", basepath);
	hasValue |= m_Status.unmarshall(ctx, params, attachments, "Status", basepath);
	hasValue |= m_ComponentType.unmarshall(ctx, params, attachments, "ComponentType", basepath);
	hasValue |= m_EndPoint.unmarshall(ctx, params, attachments, "EndPoint", basepath);
	hasValue |= m_ComponentStatusID.unmarshall(ctx, params, attachments, "ComponentStatusID", basepath);
	hasValue |= m_ComponentStatus.unmarshall(ctx, params, attachments, "ComponentStatus", basepath);
	hasValue |= m_TimeReported.unmarshall(ctx, params, attachments, "TimeReported", basepath);
	hasValue |= m_TimeReportedStr.unmarshall(ctx, params, attachments, "TimeReportedStr", basepath);
	hasValue |= m_Reporter.unmarshall(ctx, params, attachments, "Reporter", basepath);
	hasValue |= m_StatusReport.unmarshall(ctx, params, attachments, "StatusReport", basepath);
	hasValue |= m_ComponentStatusList.unmarshall(ctx, params, attachments, "ComponentStatusList", basepath);
	return hasValue;
}

bool CGetComponentStatusResponse::getStatusCode_isNull(){return m_StatusCode.is_nil();}
int CGetComponentStatusResponse::getStatusCode() { return m_StatusCode;}
const char * CGetComponentStatusResponse::getStatus() { return m_Status.query();}
const char * CGetComponentStatusResponse::getComponentType() { return m_ComponentType.query();}
const char * CGetComponentStatusResponse::getEndPoint() { return m_EndPoint.query();}
bool CGetComponentStatusResponse::getComponentStatusID_isNull(){return m_ComponentStatusID.is_nil();}
int CGetComponentStatusResponse::getComponentStatusID() { return m_ComponentStatusID;}
const char * CGetComponentStatusResponse::getComponentStatus() { return m_ComponentStatus.query();}
bool CGetComponentStatusResponse::getTimeReported_isNull(){return m_TimeReported.is_nil();}
__int64 CGetComponentStatusResponse::getTimeReported() { return m_TimeReported;}
const char * CGetComponentStatusResponse::getTimeReportedStr() { return m_TimeReportedStr.query();}
const char * CGetComponentStatusResponse::getReporter() { return m_Reporter.query();}
IConstStatusReport & CGetComponentStatusResponse::getStatusReport() { return (IConstStatusReport &) m_StatusReport.getValue();}
IArrayOf<IConstComponentStatus> & CGetComponentStatusResponse::getComponentStatusList() { return (IArrayOf<IConstComponentStatus> &) m_ComponentStatusList; }
void CGetComponentStatusResponse::setStatusCode_null(){ m_StatusCode.Nil(); }void CGetComponentStatusResponse::setStatusCode(int val){ m_StatusCode=val; }
void CGetComponentStatusResponse::setStatus(const char * val){ m_Status.set(val); }
void CGetComponentStatusResponse::setComponentType(const char * val){ m_ComponentType.set(val); }
void CGetComponentStatusResponse::setEndPoint(const char * val){ m_EndPoint.set(val); }
void CGetComponentStatusResponse::setComponentStatusID_null(){ m_ComponentStatusID.Nil(); }void CGetComponentStatusResponse::setComponentStatusID(int val){ m_ComponentStatusID=val; }
void CGetComponentStatusResponse::setComponentStatus(const char * val){ m_ComponentStatus.set(val); }
void CGetComponentStatusResponse::setTimeReported_null(){ m_TimeReported.Nil(); }void CGetComponentStatusResponse::setTimeReported(__int64 val){ m_TimeReported=val; }
void CGetComponentStatusResponse::setTimeReportedStr(const char * val){ m_TimeReportedStr.set(val); }
void CGetComponentStatusResponse::setReporter(const char * val){ m_Reporter.set(val); }
IEspStatusReport & CGetComponentStatusResponse::updateStatusReport(){ return (IEspStatusReport &) m_StatusReport.getValue(); }
void CGetComponentStatusResponse::setStatusReport(IConstStatusReport &ifrom){ m_StatusReport.copy(ifrom); }
void CGetComponentStatusResponse::setComponentStatusList(IArrayOf<IEspComponentStatus> &val)
{
	m_ComponentStatusList->kill();
	IArrayOf<IConstComponentStatus> &target = m_ComponentStatusList.getValue();
	ForEachItemIn(idx, val)
	{
		IEspComponentStatus &item = (val).item(idx);
		item.Link();
		target.append(item);
	}
}
void CGetComponentStatusResponse::setComponentStatusList(IArrayOf<IConstComponentStatus> &val)
{
	m_ComponentStatusList->kill();
	IArrayOf<IConstComponentStatus> &target = m_ComponentStatusList.getValue();
	ForEachItemIn(idx, val)
	{
		IConstComponentStatus &item = val.item(idx);
		item.Link();
		target.append(item);
	}
}
extern "C"  IEspGetComponentStatusResponse *createGetComponentStatusResponse(const char *serv){return ((IEspGetComponentStatusResponse *)new CGetComponentStatusResponse(serv));}
extern "C"  IClientGetComponentStatusResponse *createClientGetComponentStatusResponse(const char *serv){return ((IClientGetComponentStatusResponse *)new CGetComponentStatusResponse(serv));}

//=======================================================
// class CUpdateComponentStatusRequest Implementation
//=======================================================

CUpdateComponentStatusRequest::CUpdateComponentStatusRequest(const char *serviceName, IRpcMessageBinding *init)
	: m_Reporter(nilRemove),m_ComponentStatusList(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("UpdateComponentStatusRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CUpdateComponentStatusRequest::CUpdateComponentStatusRequest(const char *serviceName, const char *bc)
	: m_Reporter(nilRemove),m_ComponentStatusList(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("UpdateComponentStatusRequest");
}

CUpdateComponentStatusRequest::CUpdateComponentStatusRequest(const char *serviceName, IRpcMessage* rpcmsg)
	: m_Reporter(nilRemove),m_ComponentStatusList(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("UpdateComponentStatusRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CUpdateComponentStatusRequest::CUpdateComponentStatusRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_Reporter(nilRemove),m_ComponentStatusList(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("UpdateComponentStatusRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CUpdateComponentStatusRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Reporter\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"ComponentStatusList\">\n");
		schema.append("<xsd:complexType><xsd:sequence>\n");
		schema.append("<xsd:element minOccurs=\"0\" maxOccurs=\"unbounded\" name=\"ComponentStatus\" type=\"tns:ComponentStatus\"/>");
		schema.append("</xsd:sequence></xsd:complexType>");
		schema.append("</xsd:element>");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	if (!(flags & 0x10)  || (flags & 0x100))
	{
		CComponentStatus::getXsdDefinition(context, request, schema, added);
	}
	return schema;
}

void CUpdateComponentStatusRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CUpdateComponentStatusRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
	if (!added.getValue("ComponentStatus"))
	{
		added.setValue("ComponentStatus",1);
		CComponentStatus::getMapInfo(info,added);
	}
}

StringBuffer &CUpdateComponentStatusRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Reporter");
	form.appendf("  <tr><td><b>Reporter: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("ComponentStatusList");
	form.appendf("<tr><td><b>ComponentStatusList: </b></td><td>");
	form.appendf("<table><tr><td><textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea></td>", extfix.str());
	form.append("</tr></table>");
	form.append("</td></tr>");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CUpdateComponentStatusRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CUpdateComponentStatusRequest::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_Reporter.marshall(rpc_resp, "Reporter", "", "", "");
	m_ComponentStatusList.marshall(rpc_resp, "ComponentStatusList", "ComponentStatus");
}


void CUpdateComponentStatusRequest::copy(CUpdateComponentStatusRequest &from)
{
	m_Reporter.copy(from.m_Reporter);
	m_ComponentStatusList.copy(from.m_ComponentStatusList);
}


void CUpdateComponentStatusRequest::copy(IConstUpdateComponentStatusRequest &ifrom)
{
	setReporter(ifrom.getReporter());
	setComponentStatusList(ifrom.getComponentStatusList());
}


void CUpdateComponentStatusRequest::getAttributes(IProperties &attributes)
{
}


void CUpdateComponentStatusRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_Reporter.toStr(ctx, buffer, "Reporter", "", true, "", "");
	m_ComponentStatusList.toStr(ctx, buffer, "ComponentStatusList", "ComponentStatus");
}


void CUpdateComponentStatusRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CUpdateComponentStatusRequest::serializer(IEspContext* ctx, IConstUpdateComponentStatusRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<UpdateComponentStatusRequest>");
	// field Reporter
	{
		const char* s = src.getReporter();
		if (s && *s)
		{
			buffer.append("<Reporter>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Reporter>");
		}
	}
	// field ComponentStatusList
	{
		IArrayOf<IConstComponentStatus>& v = src.getComponentStatusList();
		int size = v.length();
		if (size>0)
			buffer.append("<ComponentStatusList>");
		for (int i=0;i<size;i++)
		{
			buffer.append("<ComponentStatus>");
			CComponentStatus::serializer(ctx,v.item(i),buffer,false);
			buffer.append("</ComponentStatus>");
		}
		if (size>0)
			buffer.append("</ComponentStatusList>");
	}
	if (keepRootTag)
		buffer.append("</UpdateComponentStatusRequest>");
}

bool CUpdateComponentStatusRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_Reporter.unmarshall(rpc_request, "Reporter", basepath);
	hasValue |= m_ComponentStatusList.unmarshall(rpc_request, "ComponentStatusList", basepath);
	return hasValue;
}

bool CUpdateComponentStatusRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Reporter.unmarshall(ctx, soapval, "Reporter");
	hasValue |= m_ComponentStatusList.unmarshall(ctx, soapval, "ComponentStatusList");
	return hasValue;
}

bool CUpdateComponentStatusRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Reporter.unmarshall(ctx, params, attachments, "Reporter", basepath);
	hasValue |= m_ComponentStatusList.unmarshall(ctx, params, attachments, "ComponentStatusList", basepath);
	return hasValue;
}

const char * CUpdateComponentStatusRequest::getReporter() { return m_Reporter.query();}
IArrayOf<IConstComponentStatus> & CUpdateComponentStatusRequest::getComponentStatusList() { return (IArrayOf<IConstComponentStatus> &) m_ComponentStatusList; }
void CUpdateComponentStatusRequest::setReporter(const char * val){ m_Reporter.set(val); }
void CUpdateComponentStatusRequest::setComponentStatusList(IArrayOf<IEspComponentStatus> &val)
{
	m_ComponentStatusList->kill();
	IArrayOf<IConstComponentStatus> &target = m_ComponentStatusList.getValue();
	ForEachItemIn(idx, val)
	{
		IEspComponentStatus &item = (val).item(idx);
		item.Link();
		target.append(item);
	}
}
void CUpdateComponentStatusRequest::setComponentStatusList(IArrayOf<IConstComponentStatus> &val)
{
	m_ComponentStatusList->kill();
	IArrayOf<IConstComponentStatus> &target = m_ComponentStatusList.getValue();
	ForEachItemIn(idx, val)
	{
		IConstComponentStatus &item = val.item(idx);
		item.Link();
		target.append(item);
	}
}
extern "C"  IEspUpdateComponentStatusRequest *createUpdateComponentStatusRequest(const char *serv){return ((IEspUpdateComponentStatusRequest *)new CUpdateComponentStatusRequest(serv));}
extern "C"  IClientUpdateComponentStatusRequest *createClientUpdateComponentStatusRequest(const char *serv){return ((IClientUpdateComponentStatusRequest *)new CUpdateComponentStatusRequest(serv));}

//=======================================================
// class CUpdateComponentStatusResponse Implementation
//=======================================================

CUpdateComponentStatusResponse::CUpdateComponentStatusResponse(const char *serviceName, IRpcMessageBinding *init)
	: m_StatusCode(nilRemove),m_Status(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("UpdateComponentStatusResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CUpdateComponentStatusResponse::CUpdateComponentStatusResponse(const char *serviceName, const char *bc)
	: m_StatusCode(nilRemove),m_Status(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("UpdateComponentStatusResponse");
}

CUpdateComponentStatusResponse::CUpdateComponentStatusResponse(const char *serviceName, IRpcMessage* rpcmsg)
	: m_StatusCode(nilRemove),m_Status(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("UpdateComponentStatusResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CUpdateComponentStatusResponse::CUpdateComponentStatusResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_StatusCode(nilRemove),m_Status(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("UpdateComponentStatusResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CUpdateComponentStatusResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		schema.append("<xsd:element name=\"Exceptions\" type=\"tns:ArrayOfEspException\" minOccurs=\"0\" maxOccurs=\"1\"/>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"StatusCode\" type=\"xsd:int\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Status\" type=\"xsd:string\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CUpdateComponentStatusResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CUpdateComponentStatusResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CUpdateComponentStatusResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix) extfix.append(prefix).append(".");
		extfix.append("StatusCode");
	form.appendf("  <tr><td><b>StatusCode: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Status");
	form.appendf("  <tr><td><b>Status: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CUpdateComponentStatusResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CUpdateComponentStatusResponse::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	rpc_resp.setEncodeXml(false);
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
		m_StatusCode.marshall(rpc_resp, "StatusCode", "", "", "");
		m_Status.marshall(rpc_resp, "Status", "", "", "");
	}
}


void CUpdateComponentStatusResponse::copy(CUpdateComponentStatusResponse &from)
{
	m_StatusCode.copy(from.m_StatusCode);
	m_Status.copy(from.m_Status);
}


void CUpdateComponentStatusResponse::copy(IConstUpdateComponentStatusResponse &ifrom)
{
	setStatusCode(ifrom.getStatusCode());
	setStatus(ifrom.getStatus());
}


void CUpdateComponentStatusResponse::getAttributes(IProperties &attributes)
{
}


void CUpdateComponentStatusResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
		m_StatusCode.toStr(ctx, buffer, "StatusCode", "", false, "", "");
		m_Status.toStr(ctx, buffer, "Status", "", false, "", "");
	}
}


void CUpdateComponentStatusResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CUpdateComponentStatusResponse::serializer(IEspContext* ctx, IConstUpdateComponentStatusResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<UpdateComponentStatusResponse>");
	// field StatusCode
	{
		int n = src.getStatusCode();
		if (n)
			buffer.appendf("<StatusCode>%d</StatusCode>", n);
	}
	// field Status
	{
		const char* s = src.getStatus();
		if (s && *s)
		buffer.appendf("<Status>%s</Status>",s);
	}
	if (keepRootTag)
		buffer.append("</UpdateComponentStatusResponse>");
}

bool CUpdateComponentStatusResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
		hasValue |= m_StatusCode.unmarshall(rpc_request, "StatusCode", basepath);
		hasValue |= m_Status.unmarshall(rpc_request, "Status", basepath);
	}
	return hasValue;
}

bool CUpdateComponentStatusResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_StatusCode.unmarshall(ctx, soapval, "StatusCode");
	hasValue |= m_Status.unmarshall(ctx, soapval, "Status");
	return hasValue;
}

bool CUpdateComponentStatusResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_StatusCode.unmarshall(ctx, params, attachments, "StatusCode", basepath);
	hasValue |= m_Status.unmarshall(ctx, params, attachments, "Status", basepath);
	return hasValue;
}

bool CUpdateComponentStatusResponse::getStatusCode_isNull(){return m_StatusCode.is_nil();}
int CUpdateComponentStatusResponse::getStatusCode() { return m_StatusCode;}
const char * CUpdateComponentStatusResponse::getStatus() { return m_Status.query();}
void CUpdateComponentStatusResponse::setStatusCode_null(){ m_StatusCode.Nil(); }void CUpdateComponentStatusResponse::setStatusCode(int val){ m_StatusCode=val; }
void CUpdateComponentStatusResponse::setStatus(const char * val){ m_Status.set(val); }
extern "C"  IEspUpdateComponentStatusResponse *createUpdateComponentStatusResponse(const char *serv){return ((IEspUpdateComponentStatusResponse *)new CUpdateComponentStatusResponse(serv));}
extern "C"  IClientUpdateComponentStatusResponse *createClientUpdateComponentStatusResponse(const char *serv){return ((IClientUpdateComponentStatusResponse *)new CUpdateComponentStatusResponse(serv));}

//=======================================================
// class CGetComponentUsageRequest Implementation
//=======================================================

CGetComponentUsageRequest::CGetComponentUsageRequest(const char *serviceName, IRpcMessageBinding *init)
	: m_Components(nilRemove),m_BypassCachedResult(0, nilRemove,false)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetComponentUsageRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CGetComponentUsageRequest::CGetComponentUsageRequest(const char *serviceName, const char *bc)
	: m_Components(nilRemove),m_BypassCachedResult(0, nilRemove,false)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetComponentUsageRequest");
}

CGetComponentUsageRequest::CGetComponentUsageRequest(const char *serviceName, IRpcMessage* rpcmsg)
	: m_Components(nilRemove),m_BypassCachedResult(0, nilRemove,false)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetComponentUsageRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CGetComponentUsageRequest::CGetComponentUsageRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_Components(nilRemove),m_BypassCachedResult(0, nilRemove,false)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetComponentUsageRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CGetComponentUsageRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Components\" type=\"tns:ArrayOfComponent\"/>\n");
		if (!context.suppressed("GetComponentUsageRequest","BypassCachedResult")) {
			schema.append("<xsd:element minOccurs=\"0\" default=\"false\" name=\"BypassCachedResult\" type=\"xsd:boolean\"/>\n");
		}
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	if (!(flags & 0x10)  || (flags & 0x100))
	{
		CComponent::getXsdDefinition(context, request, schema, added);
	}
	if (added.getValue("Component") && added.getValue("ArrayOfComponent")==NULL) {
		schema.append("<xsd:complexType name=\"ArrayOfComponent\">\n");
		schema.append("<xsd:sequence>\n");
		schema.append("<xsd:element minOccurs=\"0\" maxOccurs=\"unbounded\" name=\"Component\" type=\"tns:Component\"/>\n");
		schema.append("</xsd:sequence>\n");
		schema.append("</xsd:complexType>\n");
		added.setValue("ArrayOfComponent",1);
	}
	return schema;
}

void CGetComponentUsageRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CGetComponentUsageRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
	info.addMinVersion("GetComponentUsageRequest","BypassCachedResult",1.15);
	if (!added.getValue("Component"))
	{
		added.setValue("Component",1);
		CComponent::getMapInfo(info,added);
	}
}

StringBuffer &CGetComponentUsageRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Components");
	form.appendf("<tr><td><b>Components: </b></td><td>");
	form.appendf("<table><tr><td><textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea></td>", extfix.str());
	form.append("</tr></table>");
	form.append("</td></tr>");
	if (!context.suppressed("GetComponentUsageRequest","BypassCachedResult")) {
		extfix.clear();
		if (prefix && *prefix)
			extfix.append(prefix).append(".");
		extfix.append("BypassCachedResult");
		
	form.appendf("  <tr><td><b>BypassCachedResult? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	}
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CGetComponentUsageRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CGetComponentUsageRequest::serialize(IRpcMessage& rpc_resp)
{
	IEspContext* ctx = rpc_resp.queryContext();
	double clientVer= ctx ? ctx->getClientVersion() : -1; /* no context gets everything */
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_Components.marshall(rpc_resp, "Components", "Component");
	if ((clientVer==-1.0 || clientVer>=1.15))
		m_BypassCachedResult.marshall(rpc_resp, "BypassCachedResult", "", "", "");
}


void CGetComponentUsageRequest::copy(CGetComponentUsageRequest &from)
{
	m_Components.copy(from.m_Components);
	m_BypassCachedResult.copy(from.m_BypassCachedResult);
}


void CGetComponentUsageRequest::copy(IConstGetComponentUsageRequest &ifrom)
{
	setComponents(ifrom.getComponents());
	setBypassCachedResult(ifrom.getBypassCachedResult());
}


void CGetComponentUsageRequest::getAttributes(IProperties &attributes)
{
}


void CGetComponentUsageRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	double clientVer = ctx ? ctx->getClientVersion() : -1;
	m_Components.toStr(ctx, buffer, "Components", "Component");
	if ((clientVer==-1.0 || clientVer>=1.15))
		m_BypassCachedResult.toStr(ctx, buffer, "BypassCachedResult", "", true, "", "");
}


void CGetComponentUsageRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CGetComponentUsageRequest::serializer(IEspContext* ctx, IConstGetComponentUsageRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<GetComponentUsageRequest>");
	double clientVer = ctx ? ctx->getClientVersion() : -1;
	// field Components
	{
		IArrayOf<IConstComponent>& v = src.getComponents();
		int size = v.length();
		if (size>0)
			buffer.append("<Components>");
		for (int i=0;i<size;i++)
		{
			buffer.append("<Item>");
			CComponent::serializer(ctx,v.item(i),buffer,false);
			buffer.append("</Item>");
		}
		if (size>0)
			buffer.append("</Components>");
	}
	// field BypassCachedResult
	if ((clientVer==-1.0 || clientVer>=1.15))
	{
		bool b = src.getBypassCachedResult();
		if (b)
			buffer.appendf("<BypassCachedResult>1</BypassCachedResult>");
	}
	if (keepRootTag)
		buffer.append("</GetComponentUsageRequest>");
}

bool CGetComponentUsageRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_Components.unmarshall(rpc_request, "Components", basepath);
	hasValue |= m_BypassCachedResult.unmarshall(rpc_request, "BypassCachedResult", basepath);
	return hasValue;
}

bool CGetComponentUsageRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Components.unmarshall(ctx, soapval, "Components");
	hasValue |= m_BypassCachedResult.unmarshall(ctx, soapval, "BypassCachedResult");
	return hasValue;
}

bool CGetComponentUsageRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Components.unmarshall(ctx, params, attachments, "Components", basepath);
	hasValue |= m_BypassCachedResult.unmarshall(ctx, params, attachments, "BypassCachedResult", basepath);
	return hasValue;
}

IArrayOf<IConstComponent> & CGetComponentUsageRequest::getComponents() { return (IArrayOf<IConstComponent> &) m_Components; }
bool CGetComponentUsageRequest::getBypassCachedResult_isNull(){return m_BypassCachedResult.is_nil();}
bool CGetComponentUsageRequest::getBypassCachedResult() { return m_BypassCachedResult;}
void CGetComponentUsageRequest::setComponents(IArrayOf<IEspComponent> &val)
{
	m_Components->kill();
	IArrayOf<IConstComponent> &target = m_Components.getValue();
	ForEachItemIn(idx, val)
	{
		IEspComponent &item = (val).item(idx);
		item.Link();
		target.append(item);
	}
}
void CGetComponentUsageRequest::setComponents(IArrayOf<IConstComponent> &val)
{
	m_Components->kill();
	IArrayOf<IConstComponent> &target = m_Components.getValue();
	ForEachItemIn(idx, val)
	{
		IConstComponent &item = val.item(idx);
		item.Link();
		target.append(item);
	}
}
void CGetComponentUsageRequest::setBypassCachedResult_null(){ m_BypassCachedResult.Nil(); }void CGetComponentUsageRequest::setBypassCachedResult(bool val){ m_BypassCachedResult=val; }
extern "C"  IEspGetComponentUsageRequest *createGetComponentUsageRequest(const char *serv){return ((IEspGetComponentUsageRequest *)new CGetComponentUsageRequest(serv));}
extern "C"  IClientGetComponentUsageRequest *createClientGetComponentUsageRequest(const char *serv){return ((IClientGetComponentUsageRequest *)new CGetComponentUsageRequest(serv));}

//=======================================================
// class CGetComponentUsageResponse Implementation
//=======================================================

CGetComponentUsageResponse::CGetComponentUsageResponse(const char *serviceName, IRpcMessageBinding *init)
	: m_ComponentUsages(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetComponentUsageResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CGetComponentUsageResponse::CGetComponentUsageResponse(const char *serviceName, const char *bc)
	: m_ComponentUsages(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetComponentUsageResponse");
}

CGetComponentUsageResponse::CGetComponentUsageResponse(const char *serviceName, IRpcMessage* rpcmsg)
	: m_ComponentUsages(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetComponentUsageResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CGetComponentUsageResponse::CGetComponentUsageResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_ComponentUsages(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetComponentUsageResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CGetComponentUsageResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		schema.append("<xsd:element name=\"Exceptions\" type=\"tns:ArrayOfEspException\" minOccurs=\"0\" maxOccurs=\"1\"/>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"ComponentUsages\" type=\"tns:ArrayOfComponentUsage\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	if (!(flags & 0x10)  || (flags & 0x100))
	{
		CComponentUsage::getXsdDefinition(context, request, schema, added);
	}
	if (added.getValue("ComponentUsage") && added.getValue("ArrayOfComponentUsage")==NULL) {
		schema.append("<xsd:complexType name=\"ArrayOfComponentUsage\">\n");
		schema.append("<xsd:sequence>\n");
		schema.append("<xsd:element minOccurs=\"0\" maxOccurs=\"unbounded\" name=\"ComponentUsage\" type=\"tns:ComponentUsage\"/>\n");
		schema.append("</xsd:sequence>\n");
		schema.append("</xsd:complexType>\n");
		added.setValue("ArrayOfComponentUsage",1);
	}
	return schema;
}

void CGetComponentUsageResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CGetComponentUsageResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
	if (!added.getValue("ComponentUsage"))
	{
		added.setValue("ComponentUsage",1);
		CComponentUsage::getMapInfo(info,added);
	}
}

StringBuffer &CGetComponentUsageResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("ComponentUsages");
	form.appendf("<tr><td><b>ComponentUsages: </b></td><td>");
	form.appendf("<table><tr><td><textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea></td>", extfix.str());
	form.append("</tr></table>");
	form.append("</td></tr>");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CGetComponentUsageResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CGetComponentUsageResponse::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	rpc_resp.setEncodeXml(false);
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
		m_ComponentUsages.marshall(rpc_resp, "ComponentUsages", "ComponentUsage");
	}
}


void CGetComponentUsageResponse::copy(CGetComponentUsageResponse &from)
{
	m_ComponentUsages.copy(from.m_ComponentUsages);
}


void CGetComponentUsageResponse::copy(IConstGetComponentUsageResponse &ifrom)
{
	setComponentUsages(ifrom.getComponentUsages());
}


void CGetComponentUsageResponse::getAttributes(IProperties &attributes)
{
}


void CGetComponentUsageResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
		m_ComponentUsages.toStr(ctx, buffer, "ComponentUsages", "ComponentUsage");
	}
}


void CGetComponentUsageResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CGetComponentUsageResponse::serializer(IEspContext* ctx, IConstGetComponentUsageResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<GetComponentUsageResponse>");
	// field ComponentUsages
	{
		IArrayOf<IConstComponentUsage>& v = src.getComponentUsages();
		int size = v.length();
		if (size>0)
			buffer.append("<ComponentUsages>");
		for (int i=0;i<size;i++)
		{
			buffer.append("<Item>");
			CComponentUsage::serializer(ctx,v.item(i),buffer,false);
			buffer.append("</Item>");
		}
		if (size>0)
			buffer.append("</ComponentUsages>");
	}
	if (keepRootTag)
		buffer.append("</GetComponentUsageResponse>");
}

bool CGetComponentUsageResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
		hasValue |= m_ComponentUsages.unmarshall(rpc_request, "ComponentUsages", basepath);
	}
	return hasValue;
}

bool CGetComponentUsageResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_ComponentUsages.unmarshall(ctx, soapval, "ComponentUsages");
	return hasValue;
}

bool CGetComponentUsageResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_ComponentUsages.unmarshall(ctx, params, attachments, "ComponentUsages", basepath);
	return hasValue;
}

IArrayOf<IConstComponentUsage> & CGetComponentUsageResponse::getComponentUsages() { return (IArrayOf<IConstComponentUsage> &) m_ComponentUsages; }
void CGetComponentUsageResponse::setComponentUsages(IArrayOf<IEspComponentUsage> &val)
{
	m_ComponentUsages->kill();
	IArrayOf<IConstComponentUsage> &target = m_ComponentUsages.getValue();
	ForEachItemIn(idx, val)
	{
		IEspComponentUsage &item = (val).item(idx);
		item.Link();
		target.append(item);
	}
}
void CGetComponentUsageResponse::setComponentUsages(IArrayOf<IConstComponentUsage> &val)
{
	m_ComponentUsages->kill();
	IArrayOf<IConstComponentUsage> &target = m_ComponentUsages.getValue();
	ForEachItemIn(idx, val)
	{
		IConstComponentUsage &item = val.item(idx);
		item.Link();
		target.append(item);
	}
}
extern "C"  IEspGetComponentUsageResponse *createGetComponentUsageResponse(const char *serv){return ((IEspGetComponentUsageResponse *)new CGetComponentUsageResponse(serv));}
extern "C"  IClientGetComponentUsageResponse *createClientGetComponentUsageResponse(const char *serv){return ((IClientGetComponentUsageResponse *)new CGetComponentUsageResponse(serv));}

//=======================================================
// class CGetTargetClusterUsageRequest Implementation
//=======================================================

CGetTargetClusterUsageRequest::CGetTargetClusterUsageRequest(const char *serviceName, IRpcMessageBinding *init)
	: m_TargetClusters(nilRemove),m_BypassCachedResult(0, nilRemove,false)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetTargetClusterUsageRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CGetTargetClusterUsageRequest::CGetTargetClusterUsageRequest(const char *serviceName, const char *bc)
	: m_TargetClusters(nilRemove),m_BypassCachedResult(0, nilRemove,false)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetTargetClusterUsageRequest");
}

CGetTargetClusterUsageRequest::CGetTargetClusterUsageRequest(const char *serviceName, IRpcMessage* rpcmsg)
	: m_TargetClusters(nilRemove),m_BypassCachedResult(0, nilRemove,false)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetTargetClusterUsageRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CGetTargetClusterUsageRequest::CGetTargetClusterUsageRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_TargetClusters(nilRemove),m_BypassCachedResult(0, nilRemove,false)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetTargetClusterUsageRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CGetTargetClusterUsageRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"TargetClusters\" type=\"tns:EspStringArray\"/>\n");
		if (!context.suppressed("GetTargetClusterUsageRequest","BypassCachedResult")) {
			schema.append("<xsd:element minOccurs=\"0\" default=\"false\" name=\"BypassCachedResult\" type=\"xsd:boolean\"/>\n");
		}
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	if (added.getValue("EspStringArray")==NULL) {
		addEspNativeArray(schema,"string","EspStringArray");
		added.setValue("EspStringArray",1);
	}
	return schema;
}

void CGetTargetClusterUsageRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CGetTargetClusterUsageRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
	info.addMinVersion("GetTargetClusterUsageRequest","BypassCachedResult",1.15);
}

StringBuffer &CGetTargetClusterUsageRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("TargetClusters");
	form.appendf("<tr><td><b>TargetClusters: </b></td><td>");
	form.appendf("<textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea>", extfix.str());
	form.append("</td></tr>");
	if (!context.suppressed("GetTargetClusterUsageRequest","BypassCachedResult")) {
		extfix.clear();
		if (prefix && *prefix)
			extfix.append(prefix).append(".");
		extfix.append("BypassCachedResult");
		
	form.appendf("  <tr><td><b>BypassCachedResult? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	}
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CGetTargetClusterUsageRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CGetTargetClusterUsageRequest::serialize(IRpcMessage& rpc_resp)
{
	IEspContext* ctx = rpc_resp.queryContext();
	double clientVer= ctx ? ctx->getClientVersion() : -1; /* no context gets everything */
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_TargetClusters.marshall(rpc_resp, "TargetClusters", "Item");
	if ((clientVer==-1.0 || clientVer>=1.15))
		m_BypassCachedResult.marshall(rpc_resp, "BypassCachedResult", "", "", "");
}


void CGetTargetClusterUsageRequest::copy(CGetTargetClusterUsageRequest &from)
{
	m_TargetClusters.copy(from.m_TargetClusters);
	m_BypassCachedResult.copy(from.m_BypassCachedResult);
}


void CGetTargetClusterUsageRequest::copy(IConstGetTargetClusterUsageRequest &ifrom)
{
	setTargetClusters(ifrom.getTargetClusters());
	setBypassCachedResult(ifrom.getBypassCachedResult());
}


void CGetTargetClusterUsageRequest::getAttributes(IProperties &attributes)
{
}


void CGetTargetClusterUsageRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	double clientVer = ctx ? ctx->getClientVersion() : -1;
	m_TargetClusters.toStr(ctx, buffer, "TargetClusters", "Item");
	if ((clientVer==-1.0 || clientVer>=1.15))
		m_BypassCachedResult.toStr(ctx, buffer, "BypassCachedResult", "", true, "", "");
}


void CGetTargetClusterUsageRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CGetTargetClusterUsageRequest::serializer(IEspContext* ctx, IConstGetTargetClusterUsageRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<GetTargetClusterUsageRequest>");
	double clientVer = ctx ? ctx->getClientVersion() : -1;
	// field TargetClusters
	{
		StringArray& v = src.getTargetClusters();
		if (v.length()>0)
			buffer.append("<TargetClusters>");
		for (size32_t i=0;i<v.length();i++)
			buffer.appendf("<Item>%s</Item>",v.item(i));
		if (v.length()>0)
			buffer.append("</TargetClusters>");
	}
	// field BypassCachedResult
	if ((clientVer==-1.0 || clientVer>=1.15))
	{
		bool b = src.getBypassCachedResult();
		if (b)
			buffer.appendf("<BypassCachedResult>1</BypassCachedResult>");
	}
	if (keepRootTag)
		buffer.append("</GetTargetClusterUsageRequest>");
}

bool CGetTargetClusterUsageRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_TargetClusters.unmarshall(rpc_request, "TargetClusters", basepath);
	hasValue |= m_BypassCachedResult.unmarshall(rpc_request, "BypassCachedResult", basepath);
	return hasValue;
}

bool CGetTargetClusterUsageRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_TargetClusters.unmarshall(ctx, soapval, "TargetClusters");
	hasValue |= m_BypassCachedResult.unmarshall(ctx, soapval, "BypassCachedResult");
	return hasValue;
}

bool CGetTargetClusterUsageRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_TargetClusters.unmarshall(ctx, params, attachments, "TargetClusters", basepath);
	hasValue |= m_BypassCachedResult.unmarshall(ctx, params, attachments, "BypassCachedResult", basepath);
	return hasValue;
}

StringArray & CGetTargetClusterUsageRequest::getTargetClusters() { return (StringArray &) m_TargetClusters; }
bool CGetTargetClusterUsageRequest::getBypassCachedResult_isNull(){return m_BypassCachedResult.is_nil();}
bool CGetTargetClusterUsageRequest::getBypassCachedResult() { return m_BypassCachedResult;}
void CGetTargetClusterUsageRequest::setTargetClusters(StringArray &val){ m_TargetClusters->kill();  CloneArray(m_TargetClusters.getValue(), val); }
void CGetTargetClusterUsageRequest::setBypassCachedResult_null(){ m_BypassCachedResult.Nil(); }void CGetTargetClusterUsageRequest::setBypassCachedResult(bool val){ m_BypassCachedResult=val; }
extern "C"  IEspGetTargetClusterUsageRequest *createGetTargetClusterUsageRequest(const char *serv){return ((IEspGetTargetClusterUsageRequest *)new CGetTargetClusterUsageRequest(serv));}
extern "C"  IClientGetTargetClusterUsageRequest *createClientGetTargetClusterUsageRequest(const char *serv){return ((IClientGetTargetClusterUsageRequest *)new CGetTargetClusterUsageRequest(serv));}

//=======================================================
// class CGetTargetClusterUsageResponse Implementation
//=======================================================

CGetTargetClusterUsageResponse::CGetTargetClusterUsageResponse(const char *serviceName, IRpcMessageBinding *init)
	: m_TargetClusterUsages(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetTargetClusterUsageResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CGetTargetClusterUsageResponse::CGetTargetClusterUsageResponse(const char *serviceName, const char *bc)
	: m_TargetClusterUsages(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetTargetClusterUsageResponse");
}

CGetTargetClusterUsageResponse::CGetTargetClusterUsageResponse(const char *serviceName, IRpcMessage* rpcmsg)
	: m_TargetClusterUsages(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetTargetClusterUsageResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CGetTargetClusterUsageResponse::CGetTargetClusterUsageResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_TargetClusterUsages(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetTargetClusterUsageResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CGetTargetClusterUsageResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		schema.append("<xsd:element name=\"Exceptions\" type=\"tns:ArrayOfEspException\" minOccurs=\"0\" maxOccurs=\"1\"/>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"TargetClusterUsages\" type=\"tns:ArrayOfTargetClusterUsage\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	if (!(flags & 0x10)  || (flags & 0x100))
	{
		CTargetClusterUsage::getXsdDefinition(context, request, schema, added);
	}
	if (added.getValue("TargetClusterUsage") && added.getValue("ArrayOfTargetClusterUsage")==NULL) {
		schema.append("<xsd:complexType name=\"ArrayOfTargetClusterUsage\">\n");
		schema.append("<xsd:sequence>\n");
		schema.append("<xsd:element minOccurs=\"0\" maxOccurs=\"unbounded\" name=\"TargetClusterUsage\" type=\"tns:TargetClusterUsage\"/>\n");
		schema.append("</xsd:sequence>\n");
		schema.append("</xsd:complexType>\n");
		added.setValue("ArrayOfTargetClusterUsage",1);
	}
	return schema;
}

void CGetTargetClusterUsageResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CGetTargetClusterUsageResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
	if (!added.getValue("TargetClusterUsage"))
	{
		added.setValue("TargetClusterUsage",1);
		CTargetClusterUsage::getMapInfo(info,added);
	}
}

StringBuffer &CGetTargetClusterUsageResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("TargetClusterUsages");
	form.appendf("<tr><td><b>TargetClusterUsages: </b></td><td>");
	form.appendf("<table><tr><td><textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea></td>", extfix.str());
	form.append("</tr></table>");
	form.append("</td></tr>");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CGetTargetClusterUsageResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CGetTargetClusterUsageResponse::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	rpc_resp.setEncodeXml(false);
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
		m_TargetClusterUsages.marshall(rpc_resp, "TargetClusterUsages", "TargetClusterUsage");
	}
}


void CGetTargetClusterUsageResponse::copy(CGetTargetClusterUsageResponse &from)
{
	m_TargetClusterUsages.copy(from.m_TargetClusterUsages);
}


void CGetTargetClusterUsageResponse::copy(IConstGetTargetClusterUsageResponse &ifrom)
{
	setTargetClusterUsages(ifrom.getTargetClusterUsages());
}


void CGetTargetClusterUsageResponse::getAttributes(IProperties &attributes)
{
}


void CGetTargetClusterUsageResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
		m_TargetClusterUsages.toStr(ctx, buffer, "TargetClusterUsages", "TargetClusterUsage");
	}
}


void CGetTargetClusterUsageResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CGetTargetClusterUsageResponse::serializer(IEspContext* ctx, IConstGetTargetClusterUsageResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<GetTargetClusterUsageResponse>");
	// field TargetClusterUsages
	{
		IArrayOf<IConstTargetClusterUsage>& v = src.getTargetClusterUsages();
		int size = v.length();
		if (size>0)
			buffer.append("<TargetClusterUsages>");
		for (int i=0;i<size;i++)
		{
			buffer.append("<Item>");
			CTargetClusterUsage::serializer(ctx,v.item(i),buffer,false);
			buffer.append("</Item>");
		}
		if (size>0)
			buffer.append("</TargetClusterUsages>");
	}
	if (keepRootTag)
		buffer.append("</GetTargetClusterUsageResponse>");
}

bool CGetTargetClusterUsageResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
		hasValue |= m_TargetClusterUsages.unmarshall(rpc_request, "TargetClusterUsages", basepath);
	}
	return hasValue;
}

bool CGetTargetClusterUsageResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_TargetClusterUsages.unmarshall(ctx, soapval, "TargetClusterUsages");
	return hasValue;
}

bool CGetTargetClusterUsageResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_TargetClusterUsages.unmarshall(ctx, params, attachments, "TargetClusterUsages", basepath);
	return hasValue;
}

IArrayOf<IConstTargetClusterUsage> & CGetTargetClusterUsageResponse::getTargetClusterUsages() { return (IArrayOf<IConstTargetClusterUsage> &) m_TargetClusterUsages; }
void CGetTargetClusterUsageResponse::setTargetClusterUsages(IArrayOf<IEspTargetClusterUsage> &val)
{
	m_TargetClusterUsages->kill();
	IArrayOf<IConstTargetClusterUsage> &target = m_TargetClusterUsages.getValue();
	ForEachItemIn(idx, val)
	{
		IEspTargetClusterUsage &item = (val).item(idx);
		item.Link();
		target.append(item);
	}
}
void CGetTargetClusterUsageResponse::setTargetClusterUsages(IArrayOf<IConstTargetClusterUsage> &val)
{
	m_TargetClusterUsages->kill();
	IArrayOf<IConstTargetClusterUsage> &target = m_TargetClusterUsages.getValue();
	ForEachItemIn(idx, val)
	{
		IConstTargetClusterUsage &item = val.item(idx);
		item.Link();
		target.append(item);
	}
}
extern "C"  IEspGetTargetClusterUsageResponse *createGetTargetClusterUsageResponse(const char *serv){return ((IEspGetTargetClusterUsageResponse *)new CGetTargetClusterUsageResponse(serv));}
extern "C"  IClientGetTargetClusterUsageResponse *createClientGetTargetClusterUsageResponse(const char *serv){return ((IClientGetTargetClusterUsageResponse *)new CGetTargetClusterUsageResponse(serv));}

//=======================================================
// class CGetNodeGroupUsageRequest Implementation
//=======================================================

CGetNodeGroupUsageRequest::CGetNodeGroupUsageRequest(const char *serviceName, IRpcMessageBinding *init)
	: m_NodeGroups(nilRemove),m_BypassCachedResult(0, nilRemove,false)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetNodeGroupUsageRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CGetNodeGroupUsageRequest::CGetNodeGroupUsageRequest(const char *serviceName, const char *bc)
	: m_NodeGroups(nilRemove),m_BypassCachedResult(0, nilRemove,false)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetNodeGroupUsageRequest");
}

CGetNodeGroupUsageRequest::CGetNodeGroupUsageRequest(const char *serviceName, IRpcMessage* rpcmsg)
	: m_NodeGroups(nilRemove),m_BypassCachedResult(0, nilRemove,false)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetNodeGroupUsageRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CGetNodeGroupUsageRequest::CGetNodeGroupUsageRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_NodeGroups(nilRemove),m_BypassCachedResult(0, nilRemove,false)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetNodeGroupUsageRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CGetNodeGroupUsageRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"NodeGroups\" type=\"tns:EspStringArray\"/>\n");
		if (!context.suppressed("GetNodeGroupUsageRequest","BypassCachedResult")) {
			schema.append("<xsd:element minOccurs=\"0\" default=\"false\" name=\"BypassCachedResult\" type=\"xsd:boolean\"/>\n");
		}
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	if (added.getValue("EspStringArray")==NULL) {
		addEspNativeArray(schema,"string","EspStringArray");
		added.setValue("EspStringArray",1);
	}
	return schema;
}

void CGetNodeGroupUsageRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CGetNodeGroupUsageRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
	info.addMinVersion("GetNodeGroupUsageRequest","BypassCachedResult",1.15);
}

StringBuffer &CGetNodeGroupUsageRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("NodeGroups");
	form.appendf("<tr><td><b>NodeGroups: </b></td><td>");
	form.appendf("<textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea>", extfix.str());
	form.append("</td></tr>");
	if (!context.suppressed("GetNodeGroupUsageRequest","BypassCachedResult")) {
		extfix.clear();
		if (prefix && *prefix)
			extfix.append(prefix).append(".");
		extfix.append("BypassCachedResult");
		
	form.appendf("  <tr><td><b>BypassCachedResult? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	}
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CGetNodeGroupUsageRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CGetNodeGroupUsageRequest::serialize(IRpcMessage& rpc_resp)
{
	IEspContext* ctx = rpc_resp.queryContext();
	double clientVer= ctx ? ctx->getClientVersion() : -1; /* no context gets everything */
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_NodeGroups.marshall(rpc_resp, "NodeGroups", "Item");
	if ((clientVer==-1.0 || clientVer>=1.15))
		m_BypassCachedResult.marshall(rpc_resp, "BypassCachedResult", "", "", "");
}


void CGetNodeGroupUsageRequest::copy(CGetNodeGroupUsageRequest &from)
{
	m_NodeGroups.copy(from.m_NodeGroups);
	m_BypassCachedResult.copy(from.m_BypassCachedResult);
}


void CGetNodeGroupUsageRequest::copy(IConstGetNodeGroupUsageRequest &ifrom)
{
	setNodeGroups(ifrom.getNodeGroups());
	setBypassCachedResult(ifrom.getBypassCachedResult());
}


void CGetNodeGroupUsageRequest::getAttributes(IProperties &attributes)
{
}


void CGetNodeGroupUsageRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	double clientVer = ctx ? ctx->getClientVersion() : -1;
	m_NodeGroups.toStr(ctx, buffer, "NodeGroups", "Item");
	if ((clientVer==-1.0 || clientVer>=1.15))
		m_BypassCachedResult.toStr(ctx, buffer, "BypassCachedResult", "", true, "", "");
}


void CGetNodeGroupUsageRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CGetNodeGroupUsageRequest::serializer(IEspContext* ctx, IConstGetNodeGroupUsageRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<GetNodeGroupUsageRequest>");
	double clientVer = ctx ? ctx->getClientVersion() : -1;
	// field NodeGroups
	{
		StringArray& v = src.getNodeGroups();
		if (v.length()>0)
			buffer.append("<NodeGroups>");
		for (size32_t i=0;i<v.length();i++)
			buffer.appendf("<Item>%s</Item>",v.item(i));
		if (v.length()>0)
			buffer.append("</NodeGroups>");
	}
	// field BypassCachedResult
	if ((clientVer==-1.0 || clientVer>=1.15))
	{
		bool b = src.getBypassCachedResult();
		if (b)
			buffer.appendf("<BypassCachedResult>1</BypassCachedResult>");
	}
	if (keepRootTag)
		buffer.append("</GetNodeGroupUsageRequest>");
}

bool CGetNodeGroupUsageRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_NodeGroups.unmarshall(rpc_request, "NodeGroups", basepath);
	hasValue |= m_BypassCachedResult.unmarshall(rpc_request, "BypassCachedResult", basepath);
	return hasValue;
}

bool CGetNodeGroupUsageRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_NodeGroups.unmarshall(ctx, soapval, "NodeGroups");
	hasValue |= m_BypassCachedResult.unmarshall(ctx, soapval, "BypassCachedResult");
	return hasValue;
}

bool CGetNodeGroupUsageRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_NodeGroups.unmarshall(ctx, params, attachments, "NodeGroups", basepath);
	hasValue |= m_BypassCachedResult.unmarshall(ctx, params, attachments, "BypassCachedResult", basepath);
	return hasValue;
}

StringArray & CGetNodeGroupUsageRequest::getNodeGroups() { return (StringArray &) m_NodeGroups; }
bool CGetNodeGroupUsageRequest::getBypassCachedResult_isNull(){return m_BypassCachedResult.is_nil();}
bool CGetNodeGroupUsageRequest::getBypassCachedResult() { return m_BypassCachedResult;}
void CGetNodeGroupUsageRequest::setNodeGroups(StringArray &val){ m_NodeGroups->kill();  CloneArray(m_NodeGroups.getValue(), val); }
void CGetNodeGroupUsageRequest::setBypassCachedResult_null(){ m_BypassCachedResult.Nil(); }void CGetNodeGroupUsageRequest::setBypassCachedResult(bool val){ m_BypassCachedResult=val; }
extern "C"  IEspGetNodeGroupUsageRequest *createGetNodeGroupUsageRequest(const char *serv){return ((IEspGetNodeGroupUsageRequest *)new CGetNodeGroupUsageRequest(serv));}
extern "C"  IClientGetNodeGroupUsageRequest *createClientGetNodeGroupUsageRequest(const char *serv){return ((IClientGetNodeGroupUsageRequest *)new CGetNodeGroupUsageRequest(serv));}

//=======================================================
// class CGetNodeGroupUsageResponse Implementation
//=======================================================

CGetNodeGroupUsageResponse::CGetNodeGroupUsageResponse(const char *serviceName, IRpcMessageBinding *init)
	: m_NodeGroupUsages(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetNodeGroupUsageResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CGetNodeGroupUsageResponse::CGetNodeGroupUsageResponse(const char *serviceName, const char *bc)
	: m_NodeGroupUsages(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetNodeGroupUsageResponse");
}

CGetNodeGroupUsageResponse::CGetNodeGroupUsageResponse(const char *serviceName, IRpcMessage* rpcmsg)
	: m_NodeGroupUsages(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetNodeGroupUsageResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CGetNodeGroupUsageResponse::CGetNodeGroupUsageResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_NodeGroupUsages(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetNodeGroupUsageResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CGetNodeGroupUsageResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		schema.append("<xsd:element name=\"Exceptions\" type=\"tns:ArrayOfEspException\" minOccurs=\"0\" maxOccurs=\"1\"/>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"NodeGroupUsages\" type=\"tns:ArrayOfNodeGroupUsage\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	if (!(flags & 0x10)  || (flags & 0x100))
	{
		CNodeGroupUsage::getXsdDefinition(context, request, schema, added);
	}
	if (added.getValue("NodeGroupUsage") && added.getValue("ArrayOfNodeGroupUsage")==NULL) {
		schema.append("<xsd:complexType name=\"ArrayOfNodeGroupUsage\">\n");
		schema.append("<xsd:sequence>\n");
		schema.append("<xsd:element minOccurs=\"0\" maxOccurs=\"unbounded\" name=\"NodeGroupUsage\" type=\"tns:NodeGroupUsage\"/>\n");
		schema.append("</xsd:sequence>\n");
		schema.append("</xsd:complexType>\n");
		added.setValue("ArrayOfNodeGroupUsage",1);
	}
	return schema;
}

void CGetNodeGroupUsageResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CGetNodeGroupUsageResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
	if (!added.getValue("NodeGroupUsage"))
	{
		added.setValue("NodeGroupUsage",1);
		CNodeGroupUsage::getMapInfo(info,added);
	}
}

StringBuffer &CGetNodeGroupUsageResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("NodeGroupUsages");
	form.appendf("<tr><td><b>NodeGroupUsages: </b></td><td>");
	form.appendf("<table><tr><td><textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea></td>", extfix.str());
	form.append("</tr></table>");
	form.append("</td></tr>");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CGetNodeGroupUsageResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CGetNodeGroupUsageResponse::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	rpc_resp.setEncodeXml(false);
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
		m_NodeGroupUsages.marshall(rpc_resp, "NodeGroupUsages", "NodeGroupUsage");
	}
}


void CGetNodeGroupUsageResponse::copy(CGetNodeGroupUsageResponse &from)
{
	m_NodeGroupUsages.copy(from.m_NodeGroupUsages);
}


void CGetNodeGroupUsageResponse::copy(IConstGetNodeGroupUsageResponse &ifrom)
{
	setNodeGroupUsages(ifrom.getNodeGroupUsages());
}


void CGetNodeGroupUsageResponse::getAttributes(IProperties &attributes)
{
}


void CGetNodeGroupUsageResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
		m_NodeGroupUsages.toStr(ctx, buffer, "NodeGroupUsages", "NodeGroupUsage");
	}
}


void CGetNodeGroupUsageResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CGetNodeGroupUsageResponse::serializer(IEspContext* ctx, IConstGetNodeGroupUsageResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<GetNodeGroupUsageResponse>");
	// field NodeGroupUsages
	{
		IArrayOf<IConstNodeGroupUsage>& v = src.getNodeGroupUsages();
		int size = v.length();
		if (size>0)
			buffer.append("<NodeGroupUsages>");
		for (int i=0;i<size;i++)
		{
			buffer.append("<Item>");
			CNodeGroupUsage::serializer(ctx,v.item(i),buffer,false);
			buffer.append("</Item>");
		}
		if (size>0)
			buffer.append("</NodeGroupUsages>");
	}
	if (keepRootTag)
		buffer.append("</GetNodeGroupUsageResponse>");
}

bool CGetNodeGroupUsageResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
		hasValue |= m_NodeGroupUsages.unmarshall(rpc_request, "NodeGroupUsages", basepath);
	}
	return hasValue;
}

bool CGetNodeGroupUsageResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_NodeGroupUsages.unmarshall(ctx, soapval, "NodeGroupUsages");
	return hasValue;
}

bool CGetNodeGroupUsageResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_NodeGroupUsages.unmarshall(ctx, params, attachments, "NodeGroupUsages", basepath);
	return hasValue;
}

IArrayOf<IConstNodeGroupUsage> & CGetNodeGroupUsageResponse::getNodeGroupUsages() { return (IArrayOf<IConstNodeGroupUsage> &) m_NodeGroupUsages; }
void CGetNodeGroupUsageResponse::setNodeGroupUsages(IArrayOf<IEspNodeGroupUsage> &val)
{
	m_NodeGroupUsages->kill();
	IArrayOf<IConstNodeGroupUsage> &target = m_NodeGroupUsages.getValue();
	ForEachItemIn(idx, val)
	{
		IEspNodeGroupUsage &item = (val).item(idx);
		item.Link();
		target.append(item);
	}
}
void CGetNodeGroupUsageResponse::setNodeGroupUsages(IArrayOf<IConstNodeGroupUsage> &val)
{
	m_NodeGroupUsages->kill();
	IArrayOf<IConstNodeGroupUsage> &target = m_NodeGroupUsages.getValue();
	ForEachItemIn(idx, val)
	{
		IConstNodeGroupUsage &item = val.item(idx);
		item.Link();
		target.append(item);
	}
}
extern "C"  IEspGetNodeGroupUsageResponse *createGetNodeGroupUsageResponse(const char *serv){return ((IEspGetNodeGroupUsageResponse *)new CGetNodeGroupUsageResponse(serv));}
extern "C"  IClientGetNodeGroupUsageResponse *createClientGetNodeGroupUsageResponse(const char *serv){return ((IClientGetNodeGroupUsageResponse *)new CGetNodeGroupUsageResponse(serv));}

//=======================================================
// class Cws_machinePingRequest Implementation
//=======================================================

Cws_machinePingRequest::Cws_machinePingRequest(const char *serviceName, IRpcMessageBinding *init)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ws_machinePingRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

Cws_machinePingRequest::Cws_machinePingRequest(const char *serviceName, const char *bc)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ws_machinePingRequest");
}

Cws_machinePingRequest::Cws_machinePingRequest(const char *serviceName, IRpcMessage* rpcmsg)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ws_machinePingRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

Cws_machinePingRequest::Cws_machinePingRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ws_machinePingRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &Cws_machinePingRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType><xsd:all/></xsd:complexType></xsd:element>\n", msgTypeName);
		}
	}
	return schema;
}

void Cws_machinePingRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void Cws_machinePingRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &Cws_machinePingRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &Cws_machinePingRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void Cws_machinePingRequest::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

}


void Cws_machinePingRequest::copy(Cws_machinePingRequest &from)
{
}


void Cws_machinePingRequest::copy(IConstws_machinePingRequest &ifrom)
{
}


void Cws_machinePingRequest::getAttributes(IProperties &attributes)
{
}


void Cws_machinePingRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
}


void Cws_machinePingRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void Cws_machinePingRequest::serializer(IEspContext* ctx, IConstws_machinePingRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<ws_machinePingRequest>");
	if (keepRootTag)
		buffer.append("</ws_machinePingRequest>");
}

bool Cws_machinePingRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	return hasValue;
}

bool Cws_machinePingRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	return hasValue;
}

bool Cws_machinePingRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	return hasValue;
}

extern "C"  IEspws_machinePingRequest *createws_machinePingRequest(const char *serv){return ((IEspws_machinePingRequest *)new Cws_machinePingRequest(serv));}
extern "C"  IClientws_machinePingRequest *createClientws_machinePingRequest(const char *serv){return ((IClientws_machinePingRequest *)new Cws_machinePingRequest(serv));}

//=======================================================
// class Cws_machinePingResponse Implementation
//=======================================================

Cws_machinePingResponse::Cws_machinePingResponse(const char *serviceName, IRpcMessageBinding *init)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ws_machinePingResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

Cws_machinePingResponse::Cws_machinePingResponse(const char *serviceName, const char *bc)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ws_machinePingResponse");
}

Cws_machinePingResponse::Cws_machinePingResponse(const char *serviceName, IRpcMessage* rpcmsg)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ws_machinePingResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

Cws_machinePingResponse::Cws_machinePingResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ws_machinePingResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &Cws_machinePingResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType><xsd:all/></xsd:complexType></xsd:element>\n", msgTypeName);
		}
	}
	return schema;
}

void Cws_machinePingResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void Cws_machinePingResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &Cws_machinePingResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &Cws_machinePingResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void Cws_machinePingResponse::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
	}
}


void Cws_machinePingResponse::copy(Cws_machinePingResponse &from)
{
}


void Cws_machinePingResponse::copy(IConstws_machinePingResponse &ifrom)
{
}


void Cws_machinePingResponse::getAttributes(IProperties &attributes)
{
}


void Cws_machinePingResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
	}
}


void Cws_machinePingResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void Cws_machinePingResponse::serializer(IEspContext* ctx, IConstws_machinePingResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<ws_machinePingResponse>");
	if (keepRootTag)
		buffer.append("</ws_machinePingResponse>");
}

bool Cws_machinePingResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
	}
	return hasValue;
}

bool Cws_machinePingResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	return hasValue;
}

bool Cws_machinePingResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	return hasValue;
}

extern "C"  IEspws_machinePingResponse *createws_machinePingResponse(const char *serv){return ((IEspws_machinePingResponse *)new Cws_machinePingResponse(serv));}
extern "C"  IClientws_machinePingResponse *createClientws_machinePingResponse(const char *serv){return ((IClientws_machinePingResponse *)new Cws_machinePingResponse(serv));}

//=======================================================
// class Cws_machineSoapBinding Implementation
//=======================================================

Cws_machineSoapBinding::Cws_machineSoapBinding(http_soap_log_level level):CHttpSoapBinding(NULL, NULL, NULL, level)
{
	init_strings();
	setWsdlVersion(1.15);
}

Cws_machineSoapBinding::Cws_machineSoapBinding(IPropertyTree* cfg, const char *bindname, const char *procname, http_soap_log_level level):CHttpSoapBinding(cfg, bindname, procname, level)
{
	init_strings(); 
	setWsdlVersion(1.15);

}

void Cws_machineSoapBinding::init_strings()
{
}

int Cws_machineSoapBinding::processRequest(IRpcMessage* rpc_call, IRpcMessage* rpc_response)
{
	if(rpc_call == NULL || rpc_response == NULL)
		return -1;

	IEspContext *ctx=rpc_call->queryContext();
	DBGLOG("Client version: %g", ctx->getClientVersion());
	StringBuffer serviceName;
	double clientVer=(ctx) ? ctx->getClientVersion() : 0.0;
	qualifyServiceName(*ctx, ctx->queryServiceName(NULL), NULL, serviceName, NULL);
	CRpcCall* thecall = static_cast<CRpcCall *>(rpc_call);
	CRpcResponse* response = static_cast<CRpcResponse*>(rpc_response);
	CHttpRequest* httprequest = thecall->getHttpReq();
	CHttpResponse* httpresponse = response->getHttpResp();

	Owned<IEspws_machine> iserv = (IEspws_machine*)getService();
	if(iserv == NULL)
	{
		response->set_status(SOAP_SERVER_ERROR);
		response->set_err("Service not available");
		DBGLOG("Service not available");
		return -1;
	}
	if (thecall->get_name() == NULL)
	{
		response->set_status(SOAP_CLIENT_ERROR);
		response->set_err("No service method specified");
		ERRLOG("No service method specified");
		return -1;
	}

	IEspContext& context = *rpc_call->queryContext();

	if(!stricmp(thecall->get_name(), "GetComponentStatus")||!stricmp(thecall->get_name(), "GetComponentStatusRequest"))
	{
		Owned<CGetComponentStatusRequest> esp_request = new CGetComponentStatusRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CGetComponentStatusResponse> esp_response = new CGetComponentStatusResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		if( accessmap.ordinality() > 0 )
			onFeaturesAuthorize(context, accessmap, "ws_machine", "GetComponentStatus");
		iserv->onGetComponentStatus(*rpc_call->queryContext(), *esp_request, *esp_response);
		response->set_status(SOAP_OK);
		response->set_name("GetComponentStatusResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "GetComponentUsage")||!stricmp(thecall->get_name(), "GetComponentUsageRequest"))
	{
		Owned<CGetComponentUsageRequest> esp_request = new CGetComponentUsageRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CGetComponentUsageResponse> esp_response = new CGetComponentUsageResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		if (clientVer!=-1.0 && clientVer<1.14)
			throw MakeStringException(-1, "Client version is too old (can't pass exception to client)");
		if( accessmap.ordinality() > 0 )
			onFeaturesAuthorize(context, accessmap, "ws_machine", "GetComponentUsage");
		iserv->onGetComponentUsage(*rpc_call->queryContext(), *esp_request, *esp_response);
		response->set_status(SOAP_OK);
		response->set_name("GetComponentUsageResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "GetMachineInfo")||!stricmp(thecall->get_name(), "GetMachineInfoRequest"))
	{
		Owned<CGetMachineInfoRequest> esp_request = new CGetMachineInfoRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CGetMachineInfoResponse> esp_response = new CGetMachineInfoResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		StringBuffer source;
		source.appendf("ws_machine::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "ws_machine", "GetMachineInfo");
			iserv->onGetMachineInfo(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "ws_machine", "GetMachineInfo");
		response->set_name("GetMachineInfoResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "GetMachineInfoEx")||!stricmp(thecall->get_name(), "GetMachineInfoRequestEx"))
	{
		Owned<CGetMachineInfoRequestEx> esp_request = new CGetMachineInfoRequestEx(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CGetMachineInfoResponseEx> esp_response = new CGetMachineInfoResponseEx(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		StringBuffer source;
		source.appendf("ws_machine::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "ws_machine", "GetMachineInfoEx");
			iserv->onGetMachineInfoEx(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "ws_machine", "GetMachineInfoEx");
		response->set_name("GetMachineInfoResponseEx");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "GetMetrics")||!stricmp(thecall->get_name(), "MetricsRequest"))
	{
		Owned<CMetricsRequest> esp_request = new CMetricsRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CMetricsResponse> esp_response = new CMetricsResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		StringBuffer source;
		source.appendf("ws_machine::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "ws_machine", "GetMetrics");
			iserv->onGetMetrics(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "ws_machine", "GetMetrics");
		response->set_name("MetricsResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "GetNodeGroupUsage")||!stricmp(thecall->get_name(), "GetNodeGroupUsageRequest"))
	{
		Owned<CGetNodeGroupUsageRequest> esp_request = new CGetNodeGroupUsageRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CGetNodeGroupUsageResponse> esp_response = new CGetNodeGroupUsageResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		if (clientVer!=-1.0 && clientVer<1.14)
			throw MakeStringException(-1, "Client version is too old (can't pass exception to client)");
		if( accessmap.ordinality() > 0 )
			onFeaturesAuthorize(context, accessmap, "ws_machine", "GetNodeGroupUsage");
		iserv->onGetNodeGroupUsage(*rpc_call->queryContext(), *esp_request, *esp_response);
		response->set_status(SOAP_OK);
		response->set_name("GetNodeGroupUsageResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "GetTargetClusterInfo")||!stricmp(thecall->get_name(), "GetTargetClusterInfoRequest"))
	{
		Owned<CGetTargetClusterInfoRequest> esp_request = new CGetTargetClusterInfoRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CGetTargetClusterInfoResponse> esp_response = new CGetTargetClusterInfoResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		StringBuffer source;
		source.appendf("ws_machine::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "ws_machine", "GetTargetClusterInfo");
			iserv->onGetTargetClusterInfo(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "ws_machine", "GetTargetClusterInfo");
		response->set_name("GetTargetClusterInfoResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "GetTargetClusterUsage")||!stricmp(thecall->get_name(), "GetTargetClusterUsageRequest"))
	{
		Owned<CGetTargetClusterUsageRequest> esp_request = new CGetTargetClusterUsageRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CGetTargetClusterUsageResponse> esp_response = new CGetTargetClusterUsageResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		if (clientVer!=-1.0 && clientVer<1.14)
			throw MakeStringException(-1, "Client version is too old (can't pass exception to client)");
		if( accessmap.ordinality() > 0 )
			onFeaturesAuthorize(context, accessmap, "ws_machine", "GetTargetClusterUsage");
		iserv->onGetTargetClusterUsage(*rpc_call->queryContext(), *esp_request, *esp_response);
		response->set_status(SOAP_OK);
		response->set_name("GetTargetClusterUsageResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "Ping")||!stricmp(thecall->get_name(), "ws_machinePingRequest"))
	{
		Owned<Cws_machinePingRequest> esp_request = new Cws_machinePingRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<Cws_machinePingResponse> esp_response = new Cws_machinePingResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		if( accessmap.ordinality() > 0 )
			onFeaturesAuthorize(context, accessmap, "ws_machine", "Ping");
		iserv->onPing(*rpc_call->queryContext(), *esp_request, *esp_response);
		response->set_status(SOAP_OK);
		response->set_name("ws_machinePingResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "UpdateComponentStatus")||!stricmp(thecall->get_name(), "UpdateComponentStatusRequest"))
	{
		Owned<CUpdateComponentStatusRequest> esp_request = new CUpdateComponentStatusRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CUpdateComponentStatusResponse> esp_response = new CUpdateComponentStatusResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		if( accessmap.ordinality() > 0 )
			onFeaturesAuthorize(context, accessmap, "ws_machine", "UpdateComponentStatus");
		iserv->onUpdateComponentStatus(*rpc_call->queryContext(), *esp_request, *esp_response);
		response->set_status(SOAP_OK);
		response->set_name("UpdateComponentStatusResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	response->set_status(SOAP_CLIENT_ERROR);
	StringBuffer msg, svcName;
	msg.appendf("Method %s not available in service %s",thecall->get_name(),getServiceName(svcName).str());
	ERRLOG("%s", msg.str());
	response->set_err(msg);
	return -1;
}

int Cws_machineSoapBinding::getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &content, const char *service, const char *method, bool mda)
{
	BoolHash added;
	if (context.getClientVersion()<=0)
		context.setClientVersion(1.15);

	DBGLOG("Client version: %g", context.getClientVersion());
	bool fullservice = (!Utils::strcasecmp(service, "ws_machine"));
	bool allMethods = (method==NULL || *method==0);
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "GetComponentStatus"))) || Utils::strcasecmp(method, "GetComponentStatus")==0)
	{
		CGetComponentStatusRequest::getMapInfo(context.queryMapInfo());
		CGetComponentStatusResponse::getMapInfo(context.queryMapInfo());
		CGetComponentStatusRequest::getXsdDefinition(context, request, "GetComponentStatusRequest", content, added);
		CGetComponentStatusResponse::getXsdDefinition(context, request, content, added);
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "GetComponentUsage"))) || Utils::strcasecmp(method, "GetComponentUsage")==0)
	{
		if (context.getClientVersion()>=1.14) {
			CGetComponentUsageRequest::getMapInfo(context.queryMapInfo());
			CGetComponentUsageResponse::getMapInfo(context.queryMapInfo());
			CGetComponentUsageRequest::getXsdDefinition(context, request, "GetComponentUsageRequest", content, added);
			CGetComponentUsageResponse::getXsdDefinition(context, request, content, added);
		}
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "GetMachineInfo"))) || Utils::strcasecmp(method, "GetMachineInfo")==0)
	{
		CGetMachineInfoRequest::getMapInfo(context.queryMapInfo());
		CGetMachineInfoResponse::getMapInfo(context.queryMapInfo());
		CGetMachineInfoRequest::getXsdDefinition(context, request, "GetMachineInfoRequest", content, added);
		CGetMachineInfoResponse::getXsdDefinition(context, request, content, added);
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "GetMachineInfoEx"))) || Utils::strcasecmp(method, "GetMachineInfoEx")==0)
	{
		CGetMachineInfoRequestEx::getMapInfo(context.queryMapInfo());
		CGetMachineInfoResponseEx::getMapInfo(context.queryMapInfo());
		CGetMachineInfoRequestEx::getXsdDefinition(context, request, "GetMachineInfoRequestEx", content, added);
		CGetMachineInfoResponseEx::getXsdDefinition(context, request, content, added);
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "GetMetrics"))) || Utils::strcasecmp(method, "GetMetrics")==0)
	{
		CMetricsRequest::getMapInfo(context.queryMapInfo());
		CMetricsResponse::getMapInfo(context.queryMapInfo());
		CMetricsRequest::getXsdDefinition(context, request, "MetricsRequest", content, added);
		CMetricsResponse::getXsdDefinition(context, request, content, added);
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "GetNodeGroupUsage"))) || Utils::strcasecmp(method, "GetNodeGroupUsage")==0)
	{
		if (context.getClientVersion()>=1.14) {
			CGetNodeGroupUsageRequest::getMapInfo(context.queryMapInfo());
			CGetNodeGroupUsageResponse::getMapInfo(context.queryMapInfo());
			CGetNodeGroupUsageRequest::getXsdDefinition(context, request, "GetNodeGroupUsageRequest", content, added);
			CGetNodeGroupUsageResponse::getXsdDefinition(context, request, content, added);
		}
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "GetTargetClusterInfo"))) || Utils::strcasecmp(method, "GetTargetClusterInfo")==0)
	{
		CGetTargetClusterInfoRequest::getMapInfo(context.queryMapInfo());
		CGetTargetClusterInfoResponse::getMapInfo(context.queryMapInfo());
		CGetTargetClusterInfoRequest::getXsdDefinition(context, request, "GetTargetClusterInfoRequest", content, added);
		CGetTargetClusterInfoResponse::getXsdDefinition(context, request, content, added);
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "GetTargetClusterUsage"))) || Utils::strcasecmp(method, "GetTargetClusterUsage")==0)
	{
		if (context.getClientVersion()>=1.14) {
			CGetTargetClusterUsageRequest::getMapInfo(context.queryMapInfo());
			CGetTargetClusterUsageResponse::getMapInfo(context.queryMapInfo());
			CGetTargetClusterUsageRequest::getXsdDefinition(context, request, "GetTargetClusterUsageRequest", content, added);
			CGetTargetClusterUsageResponse::getXsdDefinition(context, request, content, added);
		}
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "Ping"))) || Utils::strcasecmp(method, "Ping")==0)
	{
		Cws_machinePingRequest::getMapInfo(context.queryMapInfo());
		Cws_machinePingResponse::getMapInfo(context.queryMapInfo());
		Cws_machinePingRequest::getXsdDefinition(context, request, "ws_machinePingRequest", content, added);
		Cws_machinePingResponse::getXsdDefinition(context, request, content, added);
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "UpdateComponentStatus"))) || Utils::strcasecmp(method, "UpdateComponentStatus")==0)
	{
		CUpdateComponentStatusRequest::getMapInfo(context.queryMapInfo());
		CUpdateComponentStatusResponse::getMapInfo(context.queryMapInfo());
		CUpdateComponentStatusRequest::getXsdDefinition(context, request, "UpdateComponentStatusRequest", content, added);
		CUpdateComponentStatusResponse::getXsdDefinition(context, request, content, added);
	}
	return 0;
}

int Cws_machineSoapBinding::getMethodHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &page, bool bIncludeFormTag)
{
	DBGLOG("Client version: %g", context.getClientVersion());
	if (Utils::strcasecmp(method, "GetComponentStatus")==0)
	{
		CGetComponentStatusRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "GetComponentUsage")==0)
	{
		CGetComponentUsageRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "GetMachineInfo")==0)
	{
		CGetMachineInfoRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "GetMachineInfoEx")==0)
	{
		CGetMachineInfoRequestEx::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "GetMetrics")==0)
	{
		CMetricsRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "GetNodeGroupUsage")==0)
	{
		CGetNodeGroupUsageRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "GetTargetClusterInfo")==0)
	{
		CGetTargetClusterInfoRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "GetTargetClusterUsage")==0)
	{
		CGetTargetClusterUsageRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "Ping")==0)
	{
		Cws_machinePingRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "UpdateComponentStatus")==0)
	{
		CUpdateComponentStatusRequest::getHtmlForm(context, request, serv, method, page);
	}
	return 0;
}

int Cws_machineSoapBinding::getQualifiedNames(IEspContext& ctx, MethodInfoArray & methods)
{
	double ver = ctx.getClientVersion();
	if (ver<=0)
		ver = getWsdlVersion();
	const char *servname=ctx.queryServiceName(NULL);
	bool fullservice = (!stricmp(servname, "esp")||!stricmp(servname, "ws_machine"));
	if ((fullservice || isMethodInSubService(ctx, servname, "GetComponentStatus")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("GetComponentStatus", "GetComponentStatusRequest", "GetComponentStatusResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "GetComponentUsage")) && ctx.isMethodAllowed(ver,NULL, NULL, 1.14, -1))
		methods.append(*new CMethodInfo("GetComponentUsage", "GetComponentUsageRequest", "GetComponentUsageResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "GetMachineInfo")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("GetMachineInfo", "GetMachineInfoRequest", "GetMachineInfoResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "GetMachineInfoEx")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("GetMachineInfoEx", "GetMachineInfoRequestEx", "GetMachineInfoResponseEx"));
	if ((fullservice || isMethodInSubService(ctx, servname, "GetMetrics")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("GetMetrics", "MetricsRequest", "MetricsResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "GetNodeGroupUsage")) && ctx.isMethodAllowed(ver,NULL, NULL, 1.14, -1))
		methods.append(*new CMethodInfo("GetNodeGroupUsage", "GetNodeGroupUsageRequest", "GetNodeGroupUsageResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "GetTargetClusterInfo")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("GetTargetClusterInfo", "GetTargetClusterInfoRequest", "GetTargetClusterInfoResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "GetTargetClusterUsage")) && ctx.isMethodAllowed(ver,NULL, NULL, 1.14, -1))
		methods.append(*new CMethodInfo("GetTargetClusterUsage", "GetTargetClusterUsageRequest", "GetTargetClusterUsageResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "Ping")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("Ping", "ws_machinePingRequest", "ws_machinePingResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "UpdateComponentStatus")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("UpdateComponentStatus", "UpdateComponentStatusRequest", "UpdateComponentStatusResponse"));
	return methods.ordinality();
}

StringBuffer & Cws_machineSoapBinding::getServiceName(StringBuffer &resp)
{
	resp.append("ws_machine");
	return resp;
}

bool Cws_machineSoapBinding::isValidServiceName(IEspContext &context, const char *name)
{
	if (!Utils::strcasecmp(name, "ws_machine"))
		return true;
	else
		return (hasSubService(context, name));
}

bool Cws_machineSoapBinding::qualifyMethodName(IEspContext &context, const char *methname, StringBuffer *methQName)
{
	if (!methname || !*methname)
	{
		if (methQName!=NULL)
			methQName->clear();
		return true;
	}
	if (Utils::strcasecmp(methname, "GetComponentStatus")==0)
	{
		if (methQName!=NULL)
			methQName->set("GetComponentStatus");
		return true;
	}
	if (Utils::strcasecmp(methname, "GetComponentUsage")==0)
	{
		if (methQName!=NULL)
			methQName->set("GetComponentUsage");
		return true;
	}
	if (Utils::strcasecmp(methname, "GetMachineInfo")==0)
	{
		if (methQName!=NULL)
			methQName->set("GetMachineInfo");
		return true;
	}
	if (Utils::strcasecmp(methname, "GetMachineInfoEx")==0)
	{
		if (methQName!=NULL)
			methQName->set("GetMachineInfoEx");
		return true;
	}
	if (Utils::strcasecmp(methname, "GetMetrics")==0)
	{
		if (methQName!=NULL)
			methQName->set("GetMetrics");
		return true;
	}
	if (Utils::strcasecmp(methname, "GetNodeGroupUsage")==0)
	{
		if (methQName!=NULL)
			methQName->set("GetNodeGroupUsage");
		return true;
	}
	if (Utils::strcasecmp(methname, "GetTargetClusterInfo")==0)
	{
		if (methQName!=NULL)
			methQName->set("GetTargetClusterInfo");
		return true;
	}
	if (Utils::strcasecmp(methname, "GetTargetClusterUsage")==0)
	{
		if (methQName!=NULL)
			methQName->set("GetTargetClusterUsage");
		return true;
	}
	if (Utils::strcasecmp(methname, "Ping")==0)
	{
		if (methQName!=NULL)
			methQName->set("Ping");
		return true;
	}
	if (Utils::strcasecmp(methname, "UpdateComponentStatus")==0)
	{
		if (methQName!=NULL)
			methQName->set("UpdateComponentStatus");
		return true;
	}
	return false;
}

bool Cws_machineSoapBinding::qualifyServiceName(IEspContext &context, const char *servname, const char *methname, StringBuffer &servQName, StringBuffer *methQName)
{
	servQName.clear();
	if (!Utils::strcasecmp(servname, "ws_machine"))
	{
		servQName.append("ws_machine");
		return qualifyMethodName(context, methname, methQName);
	}
	return qualifySubServiceName(context, servname, methname, servQName, methQName);
}

int Cws_machineSoapBinding::onGetFile(IEspContext &context, CHttpRequest* request, CHttpResponse* response, const char *pathex)
{
	if(request == NULL || response == NULL)
		return -1;
	StringBuffer mimetype;
	MemoryBuffer content;

	StringBuffer filepath;
	getBaseFilePath(filepath);
	if (strchr("\\/", filepath.charAt(filepath.length()-1))==NULL)
		filepath.append("/");
	filepath.append(pathex);
	response->httpContentFromFile(filepath.str());
	response->send();
	return 0;
}

int Cws_machineSoapBinding::onGetForm(IEspContext &context, CHttpRequest* request, CHttpResponse* response, const char *service, const char *method)
{
	if (context.getClientVersion()<=0)
		context.setClientVersion(1.15);

	if (!stricmp("GetComponentStatus", method)) {
		CGetComponentStatusRequest::getMapInfo(context.queryMapInfo());
		CGetComponentStatusResponse::getMapInfo(context.queryMapInfo());
	}
	if (!stricmp("GetComponentUsage", method)) {
		CGetComponentUsageRequest::getMapInfo(context.queryMapInfo());
		CGetComponentUsageResponse::getMapInfo(context.queryMapInfo());
	}
	if (!stricmp("GetMachineInfo", method)) {
		CGetMachineInfoRequest::getMapInfo(context.queryMapInfo());
		CGetMachineInfoResponse::getMapInfo(context.queryMapInfo());
	}
	if (!stricmp("GetMachineInfoEx", method)) {
		CGetMachineInfoRequestEx::getMapInfo(context.queryMapInfo());
		CGetMachineInfoResponseEx::getMapInfo(context.queryMapInfo());
	}
	if (!stricmp("GetMetrics", method)) {
		CMetricsRequest::getMapInfo(context.queryMapInfo());
		CMetricsResponse::getMapInfo(context.queryMapInfo());
	}
	if (!stricmp("GetNodeGroupUsage", method)) {
		CGetNodeGroupUsageRequest::getMapInfo(context.queryMapInfo());
		CGetNodeGroupUsageResponse::getMapInfo(context.queryMapInfo());
	}
	if (!stricmp("GetTargetClusterInfo", method)) {
		CGetTargetClusterInfoRequest::getMapInfo(context.queryMapInfo());
		CGetTargetClusterInfoResponse::getMapInfo(context.queryMapInfo());
	}
	if (!stricmp("GetTargetClusterUsage", method)) {
		CGetTargetClusterUsageRequest::getMapInfo(context.queryMapInfo());
		CGetTargetClusterUsageResponse::getMapInfo(context.queryMapInfo());
	}
	if (!stricmp("Ping", method)) {
		Cws_machinePingRequest::getMapInfo(context.queryMapInfo());
		Cws_machinePingResponse::getMapInfo(context.queryMapInfo());
	}
	if (!stricmp("UpdateComponentStatus", method)) {
		CUpdateComponentStatusRequest::getMapInfo(context.queryMapInfo());
		CUpdateComponentStatusResponse::getMapInfo(context.queryMapInfo());
	}

	return EspHttpBinding::onGetForm(context, request, response, service, method);
}
int Cws_machineSoapBinding::onGetXForm(IEspContext &context, CHttpRequest* request, CHttpResponse* response, const char *service, const char *method)
{
	return EspHttpBinding::onGetXForm(context, request, response, service, method);
}

int Cws_machineSoapBinding::onGetService(IEspContext &context, CHttpRequest* request, CHttpResponse* response, const char *service, const char *method, const char *pathex)
{
	if(request == NULL || response == NULL)
		return -1;
	return onGetQuery(context, request, response, service, method);
}

 IRpcRequestBinding *Cws_machineSoapBinding::createReqBinding(IEspContext &context, IHttpMessage *ireq, const char *service, const char *method)
{
	CHttpRequest *request=static_cast<CHttpRequest*>(ireq);
	IProperties *props = (request) ? request->queryParameters() : NULL;

	if (!stricmp(method, "GetComponentStatus") || !stricmp(method, "GetComponentStatusRequest"))
		return new CGetComponentStatusRequest(&context, "ws_machine", props, NULL);
	if (!stricmp(method, "GetComponentUsage") || !stricmp(method, "GetComponentUsageRequest"))
		return new CGetComponentUsageRequest(&context, "ws_machine", props, NULL);
	if (!stricmp(method, "GetMachineInfo") || !stricmp(method, "GetMachineInfoRequest"))
		return new CGetMachineInfoRequest(&context, "ws_machine", props, NULL);
	if (!stricmp(method, "GetMachineInfoEx") || !stricmp(method, "GetMachineInfoRequestEx"))
		return new CGetMachineInfoRequestEx(&context, "ws_machine", props, NULL);
	if (!stricmp(method, "GetMetrics") || !stricmp(method, "MetricsRequest"))
		return new CMetricsRequest(&context, "ws_machine", props, NULL);
	if (!stricmp(method, "GetNodeGroupUsage") || !stricmp(method, "GetNodeGroupUsageRequest"))
		return new CGetNodeGroupUsageRequest(&context, "ws_machine", props, NULL);
	if (!stricmp(method, "GetTargetClusterInfo") || !stricmp(method, "GetTargetClusterInfoRequest"))
		return new CGetTargetClusterInfoRequest(&context, "ws_machine", props, NULL);
	if (!stricmp(method, "GetTargetClusterUsage") || !stricmp(method, "GetTargetClusterUsageRequest"))
		return new CGetTargetClusterUsageRequest(&context, "ws_machine", props, NULL);
	if (!stricmp(method, "Ping") || !stricmp(method, "ws_machinePingRequest"))
		return new Cws_machinePingRequest(&context, "ws_machine", props, NULL);
	if (!stricmp(method, "UpdateComponentStatus") || !stricmp(method, "UpdateComponentStatusRequest"))
		return new CUpdateComponentStatusRequest(&context, "ws_machine", props, NULL);
	return NULL;
}

int Cws_machineSoapBinding::onGetInstantQuery(IEspContext &context, CHttpRequest* request, CHttpResponse* response, const char *service, const char *method)
{
	if (context.getClientVersion()<=0)
		context.setClientVersion(1.15);

	if(request == NULL || response == NULL)
		return -1;
	StringBuffer respStr;
	Owned<IEspws_machine> iserv = (IEspws_machine*)getService();
	if(iserv == NULL)
	{
		respStr.append("Service not available");
		response->setContent(respStr.str());
		response->setContentType("text/html");
		response->send();
	}
	else
	{
		Owned<CSoapResponseBinding> esp_response;
		StringBuffer source;
		IEspContext& context = *request->queryContext();
		if(!stricmp(method, "GetComponentStatus")||!stricmp(method, "GetComponentStatusRequest"))
		{
			Owned<CGetComponentStatusRequest> esp_request = new CGetComponentStatusRequest(&context, "ws_machine", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			CGetComponentStatusResponse* resp = new CGetComponentStatusResponse("ws_machine");
			esp_response.setown(resp);
			MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
			if(accessmap.ordinality()>0)
				onFeaturesAuthorize(context, accessmap, "ws_machine", "GetComponentStatus");
			iserv->onGetComponentStatus(*request->queryContext(), *esp_request.get(), *resp);
		}
		if(!stricmp(method, "GetComponentUsage")||!stricmp(method, "GetComponentUsageRequest"))
		{
			Owned<CGetComponentUsageRequest> esp_request = new CGetComponentUsageRequest(&context, "ws_machine", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			CGetComponentUsageResponse* resp = new CGetComponentUsageResponse("ws_machine");
			esp_response.setown(resp);
			MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
			if(accessmap.ordinality()>0)
				onFeaturesAuthorize(context, accessmap, "ws_machine", "GetComponentUsage");
			iserv->onGetComponentUsage(*request->queryContext(), *esp_request.get(), *resp);
		}
		if(!stricmp(method, "GetMachineInfo")||!stricmp(method, "GetMachineInfoRequest"))
		{
			Owned<CGetMachineInfoRequest> esp_request = new CGetMachineInfoRequest(&context, "ws_machine", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			Owned<CGetMachineInfoResponse> esp_response = new CGetMachineInfoResponse("ws_machine");
			StringBuffer source;
			source.appendf("ws_machine::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				iserv->onGetMachineInfo(*request->queryContext(), *esp_request.get(), *esp_response.get());
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "ws_machine", "GetMachineInfo", StringBuffer(getCFD()).append("./smc_xslt/exceptions.xslt").str()))
				return 0;
			if (canRedirect(*request) && esp_response->getRedirectUrl() && *esp_response->getRedirectUrl())
			{
				response->redirect(*request, esp_response->getRedirectUrl());
			}
			else
			{
				IProperties *props=request->queryParameters();
				if (skipXslt(context))
				{
					MemoryBuffer content;
					StringBuffer mimetype;
					esp_response->appendContent(&context,content, mimetype);
					onBeforeSendResponse(context,request,content,service,method);
					response->setContent(content.length(), content.toByteArray());
					response->setContentType(mimetype.str());
				}
				else
				{
					StringBuffer xml;
					StringBuffer sResponse;
					esp_response->serializeStruct(&context, xml, NULL);

					xslTransform(xml.str(), StringBuffer(getCFD()).append("./smc_xslt/ws_machine/machines.xslt").str(), sResponse.clear(), context.queryXslParameters());
					response->setContentType("text/html");
					response->setContent(sResponse.str());
				}
				response->send();
			}
			return 0;
		}
		if(!stricmp(method, "GetMachineInfoEx")||!stricmp(method, "GetMachineInfoRequestEx"))
		{
			Owned<CGetMachineInfoRequestEx> esp_request = new CGetMachineInfoRequestEx(&context, "ws_machine", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			Owned<CGetMachineInfoResponseEx> esp_response = new CGetMachineInfoResponseEx("ws_machine");
			StringBuffer source;
			source.appendf("ws_machine::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				iserv->onGetMachineInfoEx(*request->queryContext(), *esp_request.get(), *esp_response.get());
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "ws_machine", "GetMachineInfoEx", StringBuffer(getCFD()).append("./smc_xslt/exceptions.xslt").str()))
				return 0;
			if (canRedirect(*request) && esp_response->getRedirectUrl() && *esp_response->getRedirectUrl())
			{
				response->redirect(*request, esp_response->getRedirectUrl());
			}
			else
			{
				IProperties *props=request->queryParameters();
				if (skipXslt(context))
				{
					MemoryBuffer content;
					StringBuffer mimetype;
					esp_response->appendContent(&context,content, mimetype);
					onBeforeSendResponse(context,request,content,service,method);
					response->setContent(content.length(), content.toByteArray());
					response->setContentType(mimetype.str());
				}
				else
				{
					StringBuffer xml;
					StringBuffer sResponse;
					esp_response->serializeStruct(&context, xml, NULL);

					xslTransform(xml.str(), StringBuffer(getCFD()).append("./smc_xslt/ws_machine/machines.xslt").str(), sResponse.clear(), context.queryXslParameters());
					response->setContentType("text/html");
					response->setContent(sResponse.str());
				}
				response->send();
			}
			return 0;
		}
		if(!stricmp(method, "GetMetrics")||!stricmp(method, "MetricsRequest"))
		{
			Owned<CMetricsRequest> esp_request = new CMetricsRequest(&context, "ws_machine", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			Owned<CMetricsResponse> esp_response = new CMetricsResponse("ws_machine");
			StringBuffer source;
			source.appendf("ws_machine::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				iserv->onGetMetrics(*request->queryContext(), *esp_request.get(), *esp_response.get());
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "ws_machine", "GetMetrics", StringBuffer(getCFD()).append("./smc_xslt/exceptions.xslt").str()))
				return 0;
			if (canRedirect(*request) && esp_response->getRedirectUrl() && *esp_response->getRedirectUrl())
			{
				response->redirect(*request, esp_response->getRedirectUrl());
			}
			else
			{
				IProperties *props=request->queryParameters();
				if (skipXslt(context))
				{
					MemoryBuffer content;
					StringBuffer mimetype;
					esp_response->appendContent(&context,content, mimetype);
					onBeforeSendResponse(context,request,content,service,method);
					response->setContent(content.length(), content.toByteArray());
					response->setContentType(mimetype.str());
				}
				else
				{
					StringBuffer xml;
					StringBuffer sResponse;
					esp_response->serializeStruct(&context, xml, NULL);

					xslTransform(xml.str(), StringBuffer(getCFD()).append("./smc_xslt/ws_machine/metrics.xslt").str(), sResponse.clear(), context.queryXslParameters());
					response->setContentType("text/html");
					response->setContent(sResponse.str());
				}
				response->send();
			}
			return 0;
		}
		if(!stricmp(method, "GetNodeGroupUsage")||!stricmp(method, "GetNodeGroupUsageRequest"))
		{
			Owned<CGetNodeGroupUsageRequest> esp_request = new CGetNodeGroupUsageRequest(&context, "ws_machine", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			CGetNodeGroupUsageResponse* resp = new CGetNodeGroupUsageResponse("ws_machine");
			esp_response.setown(resp);
			MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
			if(accessmap.ordinality()>0)
				onFeaturesAuthorize(context, accessmap, "ws_machine", "GetNodeGroupUsage");
			iserv->onGetNodeGroupUsage(*request->queryContext(), *esp_request.get(), *resp);
		}
		if(!stricmp(method, "GetTargetClusterInfo")||!stricmp(method, "GetTargetClusterInfoRequest"))
		{
			Owned<CGetTargetClusterInfoRequest> esp_request = new CGetTargetClusterInfoRequest(&context, "ws_machine", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			Owned<CGetTargetClusterInfoResponse> esp_response = new CGetTargetClusterInfoResponse("ws_machine");
			StringBuffer source;
			source.appendf("ws_machine::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				iserv->onGetTargetClusterInfo(*request->queryContext(), *esp_request.get(), *esp_response.get());
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "ws_machine", "GetTargetClusterInfo", StringBuffer(getCFD()).append("./smc_xslt/exceptions.xslt").str()))
				return 0;
			if (canRedirect(*request) && esp_response->getRedirectUrl() && *esp_response->getRedirectUrl())
			{
				response->redirect(*request, esp_response->getRedirectUrl());
			}
			else
			{
				IProperties *props=request->queryParameters();
				if (skipXslt(context))
				{
					MemoryBuffer content;
					StringBuffer mimetype;
					esp_response->appendContent(&context,content, mimetype);
					onBeforeSendResponse(context,request,content,service,method);
					response->setContent(content.length(), content.toByteArray());
					response->setContentType(mimetype.str());
				}
				else
				{
					StringBuffer xml;
					StringBuffer sResponse;
					esp_response->serializeStruct(&context, xml, NULL);

					xslTransform(xml.str(), StringBuffer(getCFD()).append("./smc_xslt/clusterprocesses.xslt").str(), sResponse.clear(), context.queryXslParameters());
					response->setContentType("text/html");
					response->setContent(sResponse.str());
				}
				response->send();
			}
			return 0;
		}
		if(!stricmp(method, "GetTargetClusterUsage")||!stricmp(method, "GetTargetClusterUsageRequest"))
		{
			Owned<CGetTargetClusterUsageRequest> esp_request = new CGetTargetClusterUsageRequest(&context, "ws_machine", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			CGetTargetClusterUsageResponse* resp = new CGetTargetClusterUsageResponse("ws_machine");
			esp_response.setown(resp);
			MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
			if(accessmap.ordinality()>0)
				onFeaturesAuthorize(context, accessmap, "ws_machine", "GetTargetClusterUsage");
			iserv->onGetTargetClusterUsage(*request->queryContext(), *esp_request.get(), *resp);
		}
		if(!stricmp(method, "Ping")||!stricmp(method, "ws_machinePingRequest"))
		{
			Owned<Cws_machinePingRequest> esp_request = new Cws_machinePingRequest(&context, "ws_machine", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			Cws_machinePingResponse* resp = new Cws_machinePingResponse("ws_machine");
			esp_response.setown(resp);
			MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
			if(accessmap.ordinality()>0)
				onFeaturesAuthorize(context, accessmap, "ws_machine", "Ping");
			iserv->onPing(*request->queryContext(), *esp_request.get(), *resp);
		}
		if(!stricmp(method, "UpdateComponentStatus")||!stricmp(method, "UpdateComponentStatusRequest"))
		{
			Owned<CUpdateComponentStatusRequest> esp_request = new CUpdateComponentStatusRequest(&context, "ws_machine", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			CUpdateComponentStatusResponse* resp = new CUpdateComponentStatusResponse("ws_machine");
			esp_response.setown(resp);
			MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
			if(accessmap.ordinality()>0)
				onFeaturesAuthorize(context, accessmap, "ws_machine", "UpdateComponentStatus");
			iserv->onUpdateComponentStatus(*request->queryContext(), *esp_request.get(), *resp);
		}

		if (esp_response.get())
		{
			if (canRedirect(*request) && esp_response->getRedirectUrl() && *esp_response->getRedirectUrl())
				response->redirect(*request, esp_response->getRedirectUrl());
			else
			{
				MemoryBuffer content;
				StringBuffer mimetype;
				esp_response->appendContent(&context,content, mimetype);
				onBeforeSendResponse(context,request,content,service,method);
				response->setContent(content.length(), content.toByteArray());
				response->setContentType(mimetype.str());
				response->send();
			}
			return 0;
		}
	}
	return onGetNotFound(context, request,  response, service);
}





//=======================================================
// client util methods
//=======================================================

//------ method GetComponentStatus ---------

IClientGetComponentStatusRequest * CClientws_machine::createGetComponentStatusRequest()
{
	CGetComponentStatusRequest* request = new CGetComponentStatusRequest("ws_machine");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientGetComponentStatusResponse * CClientws_machine::GetComponentStatus(IClientGetComponentStatusRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CGetComponentStatusRequest* esprequest = static_cast<CGetComponentStatusRequest*>(request);
	CGetComponentStatusResponse* espresponse = new CGetComponentStatusResponse("ws_machine");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientws_machine::async_GetComponentStatus(IClientGetComponentStatusRequest *request, IClientws_machineEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CGetComponentStatusRequest* esprequest = static_cast<CGetComponentStatusRequest*>(request);
	esprequest->setMethod("GetComponentStatus");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientws_machine::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientGetComponentStatusResponse *CClientws_machine::GetComponentStatusFn()
{
	Owned<IClientGetComponentStatusRequest> req =  createGetComponentStatusRequest();
	return GetComponentStatus(req.get());
}

//------ method GetComponentUsage ---------

IClientGetComponentUsageRequest * CClientws_machine::createGetComponentUsageRequest()
{
	CGetComponentUsageRequest* request = new CGetComponentUsageRequest("ws_machine");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientGetComponentUsageResponse * CClientws_machine::GetComponentUsage(IClientGetComponentUsageRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CGetComponentUsageRequest* esprequest = static_cast<CGetComponentUsageRequest*>(request);
	CGetComponentUsageResponse* espresponse = new CGetComponentUsageResponse("ws_machine");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientws_machine::async_GetComponentUsage(IClientGetComponentUsageRequest *request, IClientws_machineEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CGetComponentUsageRequest* esprequest = static_cast<CGetComponentUsageRequest*>(request);
	esprequest->setMethod("GetComponentUsage");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientws_machine::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientGetComponentUsageResponse *CClientws_machine::GetComponentUsageFn(IArrayOf<IConstComponent> &Components_, bool BypassCachedResult_)
{
	Owned<IClientGetComponentUsageRequest> req =  createGetComponentUsageRequest();
	req->setComponents(Components_);
	req->setBypassCachedResult(BypassCachedResult_);
	return GetComponentUsage(req.get());
}

//------ method GetMachineInfo ---------

IClientGetMachineInfoRequest * CClientws_machine::createGetMachineInfoRequest()
{
	CGetMachineInfoRequest* request = new CGetMachineInfoRequest("ws_machine");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientGetMachineInfoResponse * CClientws_machine::GetMachineInfo(IClientGetMachineInfoRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CGetMachineInfoRequest* esprequest = static_cast<CGetMachineInfoRequest*>(request);
	CGetMachineInfoResponse* espresponse = new CGetMachineInfoResponse("ws_machine");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientws_machine::async_GetMachineInfo(IClientGetMachineInfoRequest *request, IClientws_machineEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CGetMachineInfoRequest* esprequest = static_cast<CGetMachineInfoRequest*>(request);
	esprequest->setMethod("GetMachineInfo");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientws_machine::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientGetMachineInfoResponse *CClientws_machine::GetMachineInfoFn(StringArray &Addresses_, const char * SortBy_, const char * ClusterType_, const char * Cluster_, const char * OldIP_, const char * Path_, const char * AddProcessesToFilter_, bool ApplyProcessFilter_, bool GetProcessorInfo_, bool GetStorageInfo_, bool LocalFileSystemsOnly_, bool GetSoftwareInfo_, int MemThreshold_, int DiskThreshold_, int CpuThreshold_, int AutoRefresh_, const char * MemThresholdType_, const char * DiskThresholdType_, const char * UserName_, const char * Password_, const char * SecurityString_)
{
	Owned<IClientGetMachineInfoRequest> req =  createGetMachineInfoRequest();
	req->setAddresses(Addresses_);
	req->setSortBy(SortBy_);
	req->setClusterType(ClusterType_);
	req->setCluster(Cluster_);
	req->setOldIP(OldIP_);
	req->setPath(Path_);
	req->setAddProcessesToFilter(AddProcessesToFilter_);
	req->setApplyProcessFilter(ApplyProcessFilter_);
	req->setGetProcessorInfo(GetProcessorInfo_);
	req->setGetStorageInfo(GetStorageInfo_);
	req->setLocalFileSystemsOnly(LocalFileSystemsOnly_);
	req->setGetSoftwareInfo(GetSoftwareInfo_);
	req->setMemThreshold(MemThreshold_);
	req->setDiskThreshold(DiskThreshold_);
	req->setCpuThreshold(CpuThreshold_);
	req->setAutoRefresh(AutoRefresh_);
	req->setMemThresholdType(MemThresholdType_);
	req->setDiskThresholdType(DiskThresholdType_);
	req->setUserName(UserName_);
	req->setPassword(Password_);
	req->setSecurityString(SecurityString_);
	return GetMachineInfo(req.get());
}

//------ method GetMachineInfoEx ---------

IClientGetMachineInfoRequestEx * CClientws_machine::createGetMachineInfoExRequest()
{
	CGetMachineInfoRequestEx* request = new CGetMachineInfoRequestEx("ws_machine");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientGetMachineInfoResponseEx * CClientws_machine::GetMachineInfoEx(IClientGetMachineInfoRequestEx *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CGetMachineInfoRequestEx* esprequest = static_cast<CGetMachineInfoRequestEx*>(request);
	CGetMachineInfoResponseEx* espresponse = new CGetMachineInfoResponseEx("ws_machine");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientws_machine::async_GetMachineInfoEx(IClientGetMachineInfoRequestEx *request, IClientws_machineEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CGetMachineInfoRequestEx* esprequest = static_cast<CGetMachineInfoRequestEx*>(request);
	esprequest->setMethod("GetMachineInfoEx");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientws_machine::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientGetMachineInfoResponseEx *CClientws_machine::GetMachineInfoExFn(StringArray &Addresses_, const char * ClusterType_)
{
	Owned<IClientGetMachineInfoRequestEx> req =  createGetMachineInfoExRequest();
	req->setAddresses(Addresses_);
	req->setClusterType(ClusterType_);
	return GetMachineInfoEx(req.get());
}

//------ method GetMetrics ---------

IClientMetricsRequest * CClientws_machine::createGetMetricsRequest()
{
	CMetricsRequest* request = new CMetricsRequest("ws_machine");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientMetricsResponse * CClientws_machine::GetMetrics(IClientMetricsRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CMetricsRequest* esprequest = static_cast<CMetricsRequest*>(request);
	CMetricsResponse* espresponse = new CMetricsResponse("ws_machine");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientws_machine::async_GetMetrics(IClientMetricsRequest *request, IClientws_machineEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CMetricsRequest* esprequest = static_cast<CMetricsRequest*>(request);
	esprequest->setMethod("GetMetrics");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientws_machine::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientMetricsResponse *CClientws_machine::GetMetricsFn(const char * SecurityString_, StringArray &Addresses_, StringArray &ShowColumns_, int AutoRefresh_, bool SelectAllChecked_, const char * Cluster_, bool AutoUpdate_)
{
	Owned<IClientMetricsRequest> req =  createGetMetricsRequest();
	req->setSecurityString(SecurityString_);
	req->setAddresses(Addresses_);
	req->setShowColumns(ShowColumns_);
	req->setAutoRefresh(AutoRefresh_);
	req->setSelectAllChecked(SelectAllChecked_);
	req->setCluster(Cluster_);
	req->setAutoUpdate(AutoUpdate_);
	return GetMetrics(req.get());
}

//------ method GetNodeGroupUsage ---------

IClientGetNodeGroupUsageRequest * CClientws_machine::createGetNodeGroupUsageRequest()
{
	CGetNodeGroupUsageRequest* request = new CGetNodeGroupUsageRequest("ws_machine");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientGetNodeGroupUsageResponse * CClientws_machine::GetNodeGroupUsage(IClientGetNodeGroupUsageRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CGetNodeGroupUsageRequest* esprequest = static_cast<CGetNodeGroupUsageRequest*>(request);
	CGetNodeGroupUsageResponse* espresponse = new CGetNodeGroupUsageResponse("ws_machine");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientws_machine::async_GetNodeGroupUsage(IClientGetNodeGroupUsageRequest *request, IClientws_machineEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CGetNodeGroupUsageRequest* esprequest = static_cast<CGetNodeGroupUsageRequest*>(request);
	esprequest->setMethod("GetNodeGroupUsage");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientws_machine::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientGetNodeGroupUsageResponse *CClientws_machine::GetNodeGroupUsageFn(StringArray &NodeGroups_, bool BypassCachedResult_)
{
	Owned<IClientGetNodeGroupUsageRequest> req =  createGetNodeGroupUsageRequest();
	req->setNodeGroups(NodeGroups_);
	req->setBypassCachedResult(BypassCachedResult_);
	return GetNodeGroupUsage(req.get());
}

//------ method GetTargetClusterInfo ---------

IClientGetTargetClusterInfoRequest * CClientws_machine::createGetTargetClusterInfoRequest()
{
	CGetTargetClusterInfoRequest* request = new CGetTargetClusterInfoRequest("ws_machine");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientGetTargetClusterInfoResponse * CClientws_machine::GetTargetClusterInfo(IClientGetTargetClusterInfoRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CGetTargetClusterInfoRequest* esprequest = static_cast<CGetTargetClusterInfoRequest*>(request);
	CGetTargetClusterInfoResponse* espresponse = new CGetTargetClusterInfoResponse("ws_machine");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientws_machine::async_GetTargetClusterInfo(IClientGetTargetClusterInfoRequest *request, IClientws_machineEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CGetTargetClusterInfoRequest* esprequest = static_cast<CGetTargetClusterInfoRequest*>(request);
	esprequest->setMethod("GetTargetClusterInfo");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientws_machine::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientGetTargetClusterInfoResponse *CClientws_machine::GetTargetClusterInfoFn(StringArray &TargetClusters_, const char * AddProcessesToFilter_, bool ApplyProcessFilter_, bool GetProcessorInfo_, bool GetStorageInfo_, bool LocalFileSystemsOnly_, bool GetSoftwareInfo_, int MemThreshold_, int DiskThreshold_, int CpuThreshold_, int AutoRefresh_, const char * MemThresholdType_, const char * DiskThresholdType_)
{
	Owned<IClientGetTargetClusterInfoRequest> req =  createGetTargetClusterInfoRequest();
	req->setTargetClusters(TargetClusters_);
	req->setAddProcessesToFilter(AddProcessesToFilter_);
	req->setApplyProcessFilter(ApplyProcessFilter_);
	req->setGetProcessorInfo(GetProcessorInfo_);
	req->setGetStorageInfo(GetStorageInfo_);
	req->setLocalFileSystemsOnly(LocalFileSystemsOnly_);
	req->setGetSoftwareInfo(GetSoftwareInfo_);
	req->setMemThreshold(MemThreshold_);
	req->setDiskThreshold(DiskThreshold_);
	req->setCpuThreshold(CpuThreshold_);
	req->setAutoRefresh(AutoRefresh_);
	req->setMemThresholdType(MemThresholdType_);
	req->setDiskThresholdType(DiskThresholdType_);
	return GetTargetClusterInfo(req.get());
}

//------ method GetTargetClusterUsage ---------

IClientGetTargetClusterUsageRequest * CClientws_machine::createGetTargetClusterUsageRequest()
{
	CGetTargetClusterUsageRequest* request = new CGetTargetClusterUsageRequest("ws_machine");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientGetTargetClusterUsageResponse * CClientws_machine::GetTargetClusterUsage(IClientGetTargetClusterUsageRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CGetTargetClusterUsageRequest* esprequest = static_cast<CGetTargetClusterUsageRequest*>(request);
	CGetTargetClusterUsageResponse* espresponse = new CGetTargetClusterUsageResponse("ws_machine");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientws_machine::async_GetTargetClusterUsage(IClientGetTargetClusterUsageRequest *request, IClientws_machineEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CGetTargetClusterUsageRequest* esprequest = static_cast<CGetTargetClusterUsageRequest*>(request);
	esprequest->setMethod("GetTargetClusterUsage");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientws_machine::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientGetTargetClusterUsageResponse *CClientws_machine::GetTargetClusterUsageFn(StringArray &TargetClusters_, bool BypassCachedResult_)
{
	Owned<IClientGetTargetClusterUsageRequest> req =  createGetTargetClusterUsageRequest();
	req->setTargetClusters(TargetClusters_);
	req->setBypassCachedResult(BypassCachedResult_);
	return GetTargetClusterUsage(req.get());
}

//------ method Ping ---------

IClientws_machinePingRequest * CClientws_machine::createPingRequest()
{
	Cws_machinePingRequest* request = new Cws_machinePingRequest("ws_machine");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientws_machinePingResponse * CClientws_machine::Ping(IClientws_machinePingRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	Cws_machinePingRequest* esprequest = static_cast<Cws_machinePingRequest*>(request);
	Cws_machinePingResponse* espresponse = new Cws_machinePingResponse("ws_machine");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientws_machine::async_Ping(IClientws_machinePingRequest *request, IClientws_machineEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	Cws_machinePingRequest* esprequest = static_cast<Cws_machinePingRequest*>(request);
	esprequest->setMethod("Ping");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientws_machine::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientws_machinePingResponse *CClientws_machine::PingFn()
{
	Owned<IClientws_machinePingRequest> req =  createPingRequest();
	return Ping(req.get());
}

//------ method UpdateComponentStatus ---------

IClientUpdateComponentStatusRequest * CClientws_machine::createUpdateComponentStatusRequest()
{
	CUpdateComponentStatusRequest* request = new CUpdateComponentStatusRequest("ws_machine");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientUpdateComponentStatusResponse * CClientws_machine::UpdateComponentStatus(IClientUpdateComponentStatusRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CUpdateComponentStatusRequest* esprequest = static_cast<CUpdateComponentStatusRequest*>(request);
	CUpdateComponentStatusResponse* espresponse = new CUpdateComponentStatusResponse("ws_machine");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientws_machine::async_UpdateComponentStatus(IClientUpdateComponentStatusRequest *request, IClientws_machineEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CUpdateComponentStatusRequest* esprequest = static_cast<CUpdateComponentStatusRequest*>(request);
	esprequest->setMethod("UpdateComponentStatus");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientws_machine::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientUpdateComponentStatusResponse *CClientws_machine::UpdateComponentStatusFn(const char * Reporter_, IArrayOf<IConstComponentStatus> &ComponentStatusList_)
{
	Owned<IClientUpdateComponentStatusRequest> req =  createUpdateComponentStatusRequest();
	req->setReporter(Reporter_);
	req->setComponentStatusList(ComponentStatusList_);
	return UpdateComponentStatus(req.get());
}

int CClientws_machine::transferThunkEvent(void *data)
{
	IRpcResponseBinding *response = (IRpcResponseBinding *)data;
	if (response!=NULL)
	{
		IClientws_machineEvents *eventSink = (IClientws_machineEvents *)response->getEventSink();
		response->lock();

		if (stricmp(response->getMethod(), "GetComponentStatus")==0)
		{
			IClientGetComponentStatusResponse* icresp = dynamic_cast<IClientGetComponentStatusResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onGetComponentStatusComplete(icresp, response->queryState());
				else
					eventSink->onGetComponentStatusError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "GetComponentUsage")==0)
		{
			IClientGetComponentUsageResponse* icresp = dynamic_cast<IClientGetComponentUsageResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onGetComponentUsageComplete(icresp, response->queryState());
				else
					eventSink->onGetComponentUsageError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "GetMachineInfo")==0)
		{
			IClientGetMachineInfoResponse* icresp = dynamic_cast<IClientGetMachineInfoResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onGetMachineInfoComplete(icresp, response->queryState());
				else
					eventSink->onGetMachineInfoError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "GetMachineInfoEx")==0)
		{
			IClientGetMachineInfoResponseEx* icresp = dynamic_cast<IClientGetMachineInfoResponseEx*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onGetMachineInfoExComplete(icresp, response->queryState());
				else
					eventSink->onGetMachineInfoExError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "GetMetrics")==0)
		{
			IClientMetricsResponse* icresp = dynamic_cast<IClientMetricsResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onGetMetricsComplete(icresp, response->queryState());
				else
					eventSink->onGetMetricsError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "GetNodeGroupUsage")==0)
		{
			IClientGetNodeGroupUsageResponse* icresp = dynamic_cast<IClientGetNodeGroupUsageResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onGetNodeGroupUsageComplete(icresp, response->queryState());
				else
					eventSink->onGetNodeGroupUsageError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "GetTargetClusterInfo")==0)
		{
			IClientGetTargetClusterInfoResponse* icresp = dynamic_cast<IClientGetTargetClusterInfoResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onGetTargetClusterInfoComplete(icresp, response->queryState());
				else
					eventSink->onGetTargetClusterInfoError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "GetTargetClusterUsage")==0)
		{
			IClientGetTargetClusterUsageResponse* icresp = dynamic_cast<IClientGetTargetClusterUsageResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onGetTargetClusterUsageComplete(icresp, response->queryState());
				else
					eventSink->onGetTargetClusterUsageError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "Ping")==0)
		{
			IClientws_machinePingResponse* icresp = dynamic_cast<IClientws_machinePingResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onPingComplete(icresp, response->queryState());
				else
					eventSink->onPingError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "UpdateComponentStatus")==0)
		{
			IClientUpdateComponentStatusResponse* icresp = dynamic_cast<IClientUpdateComponentStatusResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onUpdateComponentStatusComplete(icresp, response->queryState());
				else
					eventSink->onUpdateComponentStatusError(icresp,response->queryState());
			}
		}
		response->unlock();
	}
	return 0;
}

static IRpcResponseBinding* createws_machineResponseObject(IRpcRequestBinding *request)
{
	const char* method = request->getMethod();
	if (stricmp(method, "GetComponentStatus")==0)
		return new CGetComponentStatusResponse("ws_machine", request);
	if (stricmp(method, "GetComponentUsage")==0)
		return new CGetComponentUsageResponse("ws_machine", request);
	if (stricmp(method, "GetMachineInfo")==0)
		return new CGetMachineInfoResponse("ws_machine", request);
	if (stricmp(method, "GetMachineInfoEx")==0)
		return new CGetMachineInfoResponseEx("ws_machine", request);
	if (stricmp(method, "GetMetrics")==0)
		return new CMetricsResponse("ws_machine", request);
	if (stricmp(method, "GetNodeGroupUsage")==0)
		return new CGetNodeGroupUsageResponse("ws_machine", request);
	if (stricmp(method, "GetTargetClusterInfo")==0)
		return new CGetTargetClusterInfoResponse("ws_machine", request);
	if (stricmp(method, "GetTargetClusterUsage")==0)
		return new CGetTargetClusterUsageResponse("ws_machine", request);
	if (stricmp(method, "Ping")==0)
		return new Cws_machinePingResponse("ws_machine", request);
	if (stricmp(method, "UpdateComponentStatus")==0)
		return new CUpdateComponentStatusResponse("ws_machine", request);
	return NULL;
}

#ifdef _WIN32
void CClientws_machine::espWorkerThread(void* data)
#else
void *CClientws_machine::espWorkerThread(void *data)
#endif
{
	IRpcRequestBinding *request = (IRpcRequestBinding *) data;

	if (request != NULL)
	{
		request->lock();
		IRpcResponseBinding *response=createws_machineResponseObject(request);
		if (response!=NULL)
		{
			try{
				request->post(*response);
			}
			catch(IException* ex){
				StringBuffer errorStr;
				ex->errorMessage(errorStr);
				ERRLOG("CClientws_machine::espWorkerThread(%s)--Exception caught while posting async request: %s", request->getMethod(), errorStr.str());
				ex->Release();
			}
			catch(...){
				ERRLOG("Unknown exception caught while posting async request");
			}
		}
#ifdef USE_CLIENT_THREAD
		ThunkToClientThread(request->getThunkHandle(), transferThunkEvent, (void *)response);
#else
		transferThunkEvent((void *)response);
#endif
		request->unlock();
		if(request->queryState()!=NULL)
			request->queryState()->Release();

		if(response!=NULL)
			response->Release();

		request->Release();
	}
#if defined(_WIN32)
#else
	return (void *) 0 ;
#endif
}



extern "C" IClientws_machine * createws_machineClient() {  return new CClientws_machine(); }


#endif //ws_machine_ESPGEN_INCLUDED
