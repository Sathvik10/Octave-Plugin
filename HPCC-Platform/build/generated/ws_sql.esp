// *** Source file generated by HIDL Version 1.3 from ws_sql.ecm ***
// *** Not to be hand edited (changes will be lost on re-generation) ***

#ifndef ws_sql_ESPGEN_INCLUDED
#define ws_sql_ESPGEN_INCLUDED

#include "ws_sql_esp.ipp"

#ifdef _WIN32
#include "edwin.h"
#include <process.h>
#endif



//=======================================================
// class CHPCCColumn Implementation
//=======================================================

CHPCCColumn::CHPCCColumn(const char *serviceName, IRpcMessageBinding *init)
	: m_Name(nilIgnore),m_Type(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("HPCCColumn");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CHPCCColumn::CHPCCColumn(const char *serviceName, const char *bc)
	: m_Name(nilIgnore),m_Type(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("HPCCColumn");
}

StringBuffer &CHPCCColumn::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:complexType name=\"%s\">\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Name\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Type\" type=\"xsd:string\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType>\n");
		}
	}
	return schema;
}

void CHPCCColumn::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CHPCCColumn::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CHPCCColumn::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Name");
	form.appendf("  <tr><td><b>Name: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Type");
	form.appendf("  <tr><td><b>Type: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CHPCCColumn::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CHPCCColumn::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_Name.marshall(rpc_resp, "Name", "", "", "");
	m_Type.marshall(rpc_resp, "Type", "", "", "");
}


void CHPCCColumn::copy(CHPCCColumn &from)
{
	m_Name.copy(from.m_Name);
	m_Type.copy(from.m_Type);
}


void CHPCCColumn::copy(IConstHPCCColumn &ifrom)
{
	setName(ifrom.getName());
	setType(ifrom.getType());
}


void CHPCCColumn::getAttributes(IProperties &attributes)
{
}


void CHPCCColumn::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_Name.toStr(ctx, buffer, "Name", "", true, "", "");
	m_Type.toStr(ctx, buffer, "Type", "", true, "", "");
}


void CHPCCColumn::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CHPCCColumn::serializer(IEspContext* ctx, IConstHPCCColumn &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<HPCCColumn>");
	// field Name
	{
		const char* s = src.getName();
		if (s && *s)
		{
			buffer.append("<Name>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Name>");
		}
	}
	// field Type
	{
		const char* s = src.getType();
		if (s && *s)
		{
			buffer.append("<Type>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Type>");
		}
	}
	if (keepRootTag)
		buffer.append("</HPCCColumn>");
}

bool CHPCCColumn::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_Name.unmarshall(rpc_request, "Name", basepath);
	hasValue |= m_Type.unmarshall(rpc_request, "Type", basepath);
	return hasValue;
}

bool CHPCCColumn::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Name.unmarshall(ctx, soapval, "Name");
	hasValue |= m_Type.unmarshall(ctx, soapval, "Type");
	return hasValue;
}

bool CHPCCColumn::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Name.unmarshall(ctx, params, attachments, "Name", basepath);
	hasValue |= m_Type.unmarshall(ctx, params, attachments, "Type", basepath);
	return hasValue;
}

const char * CHPCCColumn::getName() { return m_Name.query();}
const char * CHPCCColumn::getType() { return m_Type.query();}
void CHPCCColumn::setName(const char * val){ m_Name.set(val); }
void CHPCCColumn::setType(const char * val){ m_Type.set(val); }
extern "C"  IEspHPCCColumn *createHPCCColumn(const char *serv, const char *msgname){return ((IEspHPCCColumn *)new CHPCCColumn(serv /*, msgname*/));}
extern "C"  IClientHPCCColumn *createClientHPCCColumn(const char *serv, const char *msgname){return ((IClientHPCCColumn *)new CHPCCColumn(serv /*, msgname*/));}

//=======================================================
// class CHPCCTable Implementation
//=======================================================

CHPCCTable::CHPCCTable(const char *serviceName, IRpcMessageBinding *init)
	: m_Name(nilIgnore),m_Columns(nilIgnore),m_ECL(nilIgnore),m_Format(nilIgnore),m_ContentType(nilIgnore),m_Description(nilIgnore),m_IsKeyed(nilIgnore),m_IsSuper(nilIgnore),m_CsvQuote(nilIgnore),m_CsvSeparate(nilIgnore),m_CsvTerminate(nilIgnore),m_Group(nilIgnore),m_MaxRecordSize(nilIgnore),m_Modified(nilIgnore),m_NumParts(nilIgnore),m_Owner(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("HPCCTable");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CHPCCTable::CHPCCTable(const char *serviceName, const char *bc)
	: m_Name(nilIgnore),m_Columns(nilIgnore),m_ECL(nilIgnore),m_Format(nilIgnore),m_ContentType(nilIgnore),m_Description(nilIgnore),m_IsKeyed(nilIgnore),m_IsSuper(nilIgnore),m_CsvQuote(nilIgnore),m_CsvSeparate(nilIgnore),m_CsvTerminate(nilIgnore),m_Group(nilIgnore),m_MaxRecordSize(nilIgnore),m_Modified(nilIgnore),m_NumParts(nilIgnore),m_Owner(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("HPCCTable");
}

StringBuffer &CHPCCTable::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:complexType name=\"%s\">\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Name\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Columns\">\n");
		schema.append("<xsd:complexType><xsd:sequence>\n");
		schema.append("<xsd:element minOccurs=\"0\" maxOccurs=\"unbounded\" name=\"Column\" type=\"tns:HPCCColumn\"/>");
		schema.append("</xsd:sequence></xsd:complexType>");
		schema.append("</xsd:element>");
		schema.append("<xsd:element minOccurs=\"0\" name=\"ECL\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Format\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"ContentType\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Description\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"IsKeyed\" type=\"xsd:boolean\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"IsSuper\" type=\"xsd:boolean\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"CsvQuote\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"CsvSeparate\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"CsvTerminate\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Group\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"MaxRecordSize\" type=\"xsd:integer\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Modified\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"NumParts\" type=\"xsd:integer\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Owner\" type=\"xsd:string\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType>\n");
		}
	}
	if (!(flags & 0x10)  || (flags & 0x100))
	{
		CHPCCColumn::getXsdDefinition(context, request, schema, added);
	}
	return schema;
}

void CHPCCTable::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CHPCCTable::getMapInfo(IMapInfo& info, BoolHash& added)
{
	if (!added.getValue("HPCCColumn"))
	{
		added.setValue("HPCCColumn",1);
		CHPCCColumn::getMapInfo(info,added);
	}
}

StringBuffer &CHPCCTable::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Name");
	form.appendf("  <tr><td><b>Name: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Columns");
	form.appendf("<tr><td><b>Columns: </b></td><td>");
	form.appendf("<table><tr><td><textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea></td>", extfix.str());
	form.append("</tr></table>");
	form.append("</td></tr>");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("ECL");
	form.appendf("  <tr><td><b>ECL: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Format");
	form.appendf("  <tr><td><b>Format: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("ContentType");
	form.appendf("  <tr><td><b>ContentType: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Description");
	form.appendf("  <tr><td><b>Description: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("IsKeyed");
	
	form.appendf("  <tr><td><b>IsKeyed? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("IsSuper");
	
	form.appendf("  <tr><td><b>IsSuper? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("CsvQuote");
	form.appendf("  <tr><td><b>CsvQuote: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("CsvSeparate");
	form.appendf("  <tr><td><b>CsvSeparate: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("CsvTerminate");
	form.appendf("  <tr><td><b>CsvTerminate: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Group");
	form.appendf("  <tr><td><b>Group: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix) extfix.append(prefix).append(".");
		extfix.append("MaxRecordSize");
	form.appendf("  <tr><td><b>MaxRecordSize: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Modified");
	form.appendf("  <tr><td><b>Modified: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix) extfix.append(prefix).append(".");
		extfix.append("NumParts");
	form.appendf("  <tr><td><b>NumParts: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Owner");
	form.appendf("  <tr><td><b>Owner: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CHPCCTable::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CHPCCTable::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_Name.marshall(rpc_resp, "Name", "", "", "");
	m_Columns.marshall(rpc_resp, "Columns", "Column");
	m_ECL.marshall(rpc_resp, "ECL", "", "", "");
	m_Format.marshall(rpc_resp, "Format", "", "", "");
	m_ContentType.marshall(rpc_resp, "ContentType", "", "", "");
	m_Description.marshall(rpc_resp, "Description", "", "", "");
	m_IsKeyed.marshall(rpc_resp, "IsKeyed", "", "", "");
	m_IsSuper.marshall(rpc_resp, "IsSuper", "", "", "");
	m_CsvQuote.marshall(rpc_resp, "CsvQuote", "", "", "");
	m_CsvSeparate.marshall(rpc_resp, "CsvSeparate", "", "", "");
	m_CsvTerminate.marshall(rpc_resp, "CsvTerminate", "", "", "");
	m_Group.marshall(rpc_resp, "Group", "", "", "");
	m_MaxRecordSize.marshall(rpc_resp, "MaxRecordSize", "", "", "");
	m_Modified.marshall(rpc_resp, "Modified", "", "", "");
	m_NumParts.marshall(rpc_resp, "NumParts", "", "", "");
	m_Owner.marshall(rpc_resp, "Owner", "", "", "");
}


void CHPCCTable::copy(CHPCCTable &from)
{
	m_Name.copy(from.m_Name);
	m_Columns.copy(from.m_Columns);
	m_ECL.copy(from.m_ECL);
	m_Format.copy(from.m_Format);
	m_ContentType.copy(from.m_ContentType);
	m_Description.copy(from.m_Description);
	m_IsKeyed.copy(from.m_IsKeyed);
	m_IsSuper.copy(from.m_IsSuper);
	m_CsvQuote.copy(from.m_CsvQuote);
	m_CsvSeparate.copy(from.m_CsvSeparate);
	m_CsvTerminate.copy(from.m_CsvTerminate);
	m_Group.copy(from.m_Group);
	m_MaxRecordSize.copy(from.m_MaxRecordSize);
	m_Modified.copy(from.m_Modified);
	m_NumParts.copy(from.m_NumParts);
	m_Owner.copy(from.m_Owner);
}


void CHPCCTable::copy(IConstHPCCTable &ifrom)
{
	setName(ifrom.getName());
	setColumns(ifrom.getColumns());
	setECL(ifrom.getECL());
	setFormat(ifrom.getFormat());
	setContentType(ifrom.getContentType());
	setDescription(ifrom.getDescription());
	setIsKeyed(ifrom.getIsKeyed());
	setIsSuper(ifrom.getIsSuper());
	setCsvQuote(ifrom.getCsvQuote());
	setCsvSeparate(ifrom.getCsvSeparate());
	setCsvTerminate(ifrom.getCsvTerminate());
	setGroup(ifrom.getGroup());
	setMaxRecordSize(ifrom.getMaxRecordSize());
	setModified(ifrom.getModified());
	setNumParts(ifrom.getNumParts());
	setOwner(ifrom.getOwner());
}


void CHPCCTable::getAttributes(IProperties &attributes)
{
}


void CHPCCTable::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_Name.toStr(ctx, buffer, "Name", "", true, "", "");
	m_Columns.toStr(ctx, buffer, "Columns", "Column");
	m_ECL.toStr(ctx, buffer, "ECL", "", true, "", "");
	m_Format.toStr(ctx, buffer, "Format", "", true, "", "");
	m_ContentType.toStr(ctx, buffer, "ContentType", "", true, "", "");
	m_Description.toStr(ctx, buffer, "Description", "", true, "", "");
	m_IsKeyed.toStr(ctx, buffer, "IsKeyed", "", true, "", "");
	m_IsSuper.toStr(ctx, buffer, "IsSuper", "", true, "", "");
	m_CsvQuote.toStr(ctx, buffer, "CsvQuote", "", true, "", "");
	m_CsvSeparate.toStr(ctx, buffer, "CsvSeparate", "", true, "", "");
	m_CsvTerminate.toStr(ctx, buffer, "CsvTerminate", "", true, "", "");
	m_Group.toStr(ctx, buffer, "Group", "", true, "", "");
	m_MaxRecordSize.toStr(ctx, buffer, "MaxRecordSize", "", true, "", "");
	m_Modified.toStr(ctx, buffer, "Modified", "", true, "", "");
	m_NumParts.toStr(ctx, buffer, "NumParts", "", true, "", "");
	m_Owner.toStr(ctx, buffer, "Owner", "", true, "", "");
}


void CHPCCTable::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CHPCCTable::serializer(IEspContext* ctx, IConstHPCCTable &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<HPCCTable>");
	// field Name
	{
		const char* s = src.getName();
		if (s && *s)
		{
			buffer.append("<Name>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Name>");
		}
	}
	// field Columns
	{
		IArrayOf<IConstHPCCColumn>& v = src.getColumns();
		int size = v.length();
		if (size>0)
			buffer.append("<Columns>");
		for (int i=0;i<size;i++)
		{
			buffer.append("<Column>");
			CHPCCColumn::serializer(ctx,v.item(i),buffer,false);
			buffer.append("</Column>");
		}
		if (size>0)
			buffer.append("</Columns>");
	}
	// field ECL
	{
		const char* s = src.getECL();
		if (s && *s)
		{
			buffer.append("<ECL>");
			encodeUtf8XML(s,buffer);
			buffer.append("</ECL>");
		}
	}
	// field Format
	{
		const char* s = src.getFormat();
		if (s && *s)
		{
			buffer.append("<Format>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Format>");
		}
	}
	// field ContentType
	{
		const char* s = src.getContentType();
		if (s && *s)
		{
			buffer.append("<ContentType>");
			encodeUtf8XML(s,buffer);
			buffer.append("</ContentType>");
		}
	}
	// field Description
	{
		const char* s = src.getDescription();
		if (s && *s)
		{
			buffer.append("<Description>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Description>");
		}
	}
	// field IsKeyed
	{
		bool b = src.getIsKeyed();
		if (b)
			buffer.appendf("<IsKeyed>1</IsKeyed>");
	}
	// field IsSuper
	{
		bool b = src.getIsSuper();
		if (b)
			buffer.appendf("<IsSuper>1</IsSuper>");
	}
	// field CsvQuote
	{
		const char* s = src.getCsvQuote();
		if (s && *s)
		{
			buffer.append("<CsvQuote>");
			encodeUtf8XML(s,buffer);
			buffer.append("</CsvQuote>");
		}
	}
	// field CsvSeparate
	{
		const char* s = src.getCsvSeparate();
		if (s && *s)
		{
			buffer.append("<CsvSeparate>");
			encodeUtf8XML(s,buffer);
			buffer.append("</CsvSeparate>");
		}
	}
	// field CsvTerminate
	{
		const char* s = src.getCsvTerminate();
		if (s && *s)
		{
			buffer.append("<CsvTerminate>");
			encodeUtf8XML(s,buffer);
			buffer.append("</CsvTerminate>");
		}
	}
	// field Group
	{
		const char* s = src.getGroup();
		if (s && *s)
		{
			buffer.append("<Group>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Group>");
		}
	}
	// field MaxRecordSize
	{
		int n = src.getMaxRecordSize();
		if (n)
			buffer.appendf("<MaxRecordSize>%d</MaxRecordSize>", n);
	}
	// field Modified
	{
		const char* s = src.getModified();
		if (s && *s)
		{
			buffer.append("<Modified>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Modified>");
		}
	}
	// field NumParts
	{
		int n = src.getNumParts();
		if (n)
			buffer.appendf("<NumParts>%d</NumParts>", n);
	}
	// field Owner
	{
		const char* s = src.getOwner();
		if (s && *s)
		{
			buffer.append("<Owner>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Owner>");
		}
	}
	if (keepRootTag)
		buffer.append("</HPCCTable>");
}

bool CHPCCTable::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_Name.unmarshall(rpc_request, "Name", basepath);
	hasValue |= m_Columns.unmarshall(rpc_request, "Columns", basepath);
	hasValue |= m_ECL.unmarshall(rpc_request, "ECL", basepath);
	hasValue |= m_Format.unmarshall(rpc_request, "Format", basepath);
	hasValue |= m_ContentType.unmarshall(rpc_request, "ContentType", basepath);
	hasValue |= m_Description.unmarshall(rpc_request, "Description", basepath);
	hasValue |= m_IsKeyed.unmarshall(rpc_request, "IsKeyed", basepath);
	hasValue |= m_IsSuper.unmarshall(rpc_request, "IsSuper", basepath);
	hasValue |= m_CsvQuote.unmarshall(rpc_request, "CsvQuote", basepath);
	hasValue |= m_CsvSeparate.unmarshall(rpc_request, "CsvSeparate", basepath);
	hasValue |= m_CsvTerminate.unmarshall(rpc_request, "CsvTerminate", basepath);
	hasValue |= m_Group.unmarshall(rpc_request, "Group", basepath);
	hasValue |= m_MaxRecordSize.unmarshall(rpc_request, "MaxRecordSize", basepath);
	hasValue |= m_Modified.unmarshall(rpc_request, "Modified", basepath);
	hasValue |= m_NumParts.unmarshall(rpc_request, "NumParts", basepath);
	hasValue |= m_Owner.unmarshall(rpc_request, "Owner", basepath);
	return hasValue;
}

bool CHPCCTable::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Name.unmarshall(ctx, soapval, "Name");
	hasValue |= m_Columns.unmarshall(ctx, soapval, "Columns");
	hasValue |= m_ECL.unmarshall(ctx, soapval, "ECL");
	hasValue |= m_Format.unmarshall(ctx, soapval, "Format");
	hasValue |= m_ContentType.unmarshall(ctx, soapval, "ContentType");
	hasValue |= m_Description.unmarshall(ctx, soapval, "Description");
	hasValue |= m_IsKeyed.unmarshall(ctx, soapval, "IsKeyed");
	hasValue |= m_IsSuper.unmarshall(ctx, soapval, "IsSuper");
	hasValue |= m_CsvQuote.unmarshall(ctx, soapval, "CsvQuote");
	hasValue |= m_CsvSeparate.unmarshall(ctx, soapval, "CsvSeparate");
	hasValue |= m_CsvTerminate.unmarshall(ctx, soapval, "CsvTerminate");
	hasValue |= m_Group.unmarshall(ctx, soapval, "Group");
	hasValue |= m_MaxRecordSize.unmarshall(ctx, soapval, "MaxRecordSize");
	hasValue |= m_Modified.unmarshall(ctx, soapval, "Modified");
	hasValue |= m_NumParts.unmarshall(ctx, soapval, "NumParts");
	hasValue |= m_Owner.unmarshall(ctx, soapval, "Owner");
	return hasValue;
}

bool CHPCCTable::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Name.unmarshall(ctx, params, attachments, "Name", basepath);
	hasValue |= m_Columns.unmarshall(ctx, params, attachments, "Columns", basepath);
	hasValue |= m_ECL.unmarshall(ctx, params, attachments, "ECL", basepath);
	hasValue |= m_Format.unmarshall(ctx, params, attachments, "Format", basepath);
	hasValue |= m_ContentType.unmarshall(ctx, params, attachments, "ContentType", basepath);
	hasValue |= m_Description.unmarshall(ctx, params, attachments, "Description", basepath);
	hasValue |= m_IsKeyed.unmarshall(ctx, params, attachments, "IsKeyed", basepath);
	hasValue |= m_IsSuper.unmarshall(ctx, params, attachments, "IsSuper", basepath);
	hasValue |= m_CsvQuote.unmarshall(ctx, params, attachments, "CsvQuote", basepath);
	hasValue |= m_CsvSeparate.unmarshall(ctx, params, attachments, "CsvSeparate", basepath);
	hasValue |= m_CsvTerminate.unmarshall(ctx, params, attachments, "CsvTerminate", basepath);
	hasValue |= m_Group.unmarshall(ctx, params, attachments, "Group", basepath);
	hasValue |= m_MaxRecordSize.unmarshall(ctx, params, attachments, "MaxRecordSize", basepath);
	hasValue |= m_Modified.unmarshall(ctx, params, attachments, "Modified", basepath);
	hasValue |= m_NumParts.unmarshall(ctx, params, attachments, "NumParts", basepath);
	hasValue |= m_Owner.unmarshall(ctx, params, attachments, "Owner", basepath);
	return hasValue;
}

const char * CHPCCTable::getName() { return m_Name.query();}
IArrayOf<IConstHPCCColumn> & CHPCCTable::getColumns() { return (IArrayOf<IConstHPCCColumn> &) m_Columns; }
const char * CHPCCTable::getECL() { return m_ECL.query();}
const char * CHPCCTable::getFormat() { return m_Format.query();}
const char * CHPCCTable::getContentType() { return m_ContentType.query();}
const char * CHPCCTable::getDescription() { return m_Description.query();}
bool CHPCCTable::getIsKeyed() { return m_IsKeyed;}
bool CHPCCTable::getIsSuper() { return m_IsSuper;}
const char * CHPCCTable::getCsvQuote() { return m_CsvQuote.query();}
const char * CHPCCTable::getCsvSeparate() { return m_CsvSeparate.query();}
const char * CHPCCTable::getCsvTerminate() { return m_CsvTerminate.query();}
const char * CHPCCTable::getGroup() { return m_Group.query();}
int CHPCCTable::getMaxRecordSize() { return m_MaxRecordSize;}
const char * CHPCCTable::getModified() { return m_Modified.query();}
int CHPCCTable::getNumParts() { return m_NumParts;}
const char * CHPCCTable::getOwner() { return m_Owner.query();}
void CHPCCTable::setName(const char * val){ m_Name.set(val); }
void CHPCCTable::setColumns(IArrayOf<IEspHPCCColumn> &val)
{
	m_Columns->kill();
	IArrayOf<IConstHPCCColumn> &target = m_Columns.getValue();
	ForEachItemIn(idx, val)
	{
		IEspHPCCColumn &item = (val).item(idx);
		item.Link();
		target.append(item);
	}
}
void CHPCCTable::setColumns(IArrayOf<IConstHPCCColumn> &val)
{
	m_Columns->kill();
	IArrayOf<IConstHPCCColumn> &target = m_Columns.getValue();
	ForEachItemIn(idx, val)
	{
		IConstHPCCColumn &item = val.item(idx);
		item.Link();
		target.append(item);
	}
}
void CHPCCTable::setECL(const char * val){ m_ECL.set(val); }
void CHPCCTable::setFormat(const char * val){ m_Format.set(val); }
void CHPCCTable::setContentType(const char * val){ m_ContentType.set(val); }
void CHPCCTable::setDescription(const char * val){ m_Description.set(val); }
void CHPCCTable::setIsKeyed(bool val){ m_IsKeyed=val; }
void CHPCCTable::setIsSuper(bool val){ m_IsSuper=val; }
void CHPCCTable::setCsvQuote(const char * val){ m_CsvQuote.set(val); }
void CHPCCTable::setCsvSeparate(const char * val){ m_CsvSeparate.set(val); }
void CHPCCTable::setCsvTerminate(const char * val){ m_CsvTerminate.set(val); }
void CHPCCTable::setGroup(const char * val){ m_Group.set(val); }
void CHPCCTable::setMaxRecordSize(int val){ m_MaxRecordSize=val; }
void CHPCCTable::setModified(const char * val){ m_Modified.set(val); }
void CHPCCTable::setNumParts(int val){ m_NumParts=val; }
void CHPCCTable::setOwner(const char * val){ m_Owner.set(val); }
extern "C"  IEspHPCCTable *createHPCCTable(const char *serv, const char *msgname){return ((IEspHPCCTable *)new CHPCCTable(serv /*, msgname*/));}
extern "C"  IClientHPCCTable *createClientHPCCTable(const char *serv, const char *msgname){return ((IClientHPCCTable *)new CHPCCTable(serv /*, msgname*/));}

//=======================================================
// class COutputDataset Implementation
//=======================================================

COutputDataset::COutputDataset(const char *serviceName, IRpcMessageBinding *init)
	: m_name(nilIgnore),m_OutParams(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("OutputDataset");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

COutputDataset::COutputDataset(const char *serviceName, const char *bc)
	: m_name(nilIgnore),m_OutParams(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("OutputDataset");
}

StringBuffer &COutputDataset::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:complexType name=\"%s\">\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"name\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"OutParams\">\n");
		schema.append("<xsd:complexType><xsd:sequence>\n");
		schema.append("<xsd:element minOccurs=\"0\" maxOccurs=\"unbounded\" name=\"OutParam\" type=\"tns:HPCCColumn\"/>");
		schema.append("</xsd:sequence></xsd:complexType>");
		schema.append("</xsd:element>");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType>\n");
		}
	}
	if (!(flags & 0x10)  || (flags & 0x100))
	{
		CHPCCColumn::getXsdDefinition(context, request, schema, added);
	}
	return schema;
}

void COutputDataset::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void COutputDataset::getMapInfo(IMapInfo& info, BoolHash& added)
{
	if (!added.getValue("HPCCColumn"))
	{
		added.setValue("HPCCColumn",1);
		CHPCCColumn::getMapInfo(info,added);
	}
}

StringBuffer &COutputDataset::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("name");
	form.appendf("  <tr><td><b>name: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("OutParams");
	form.appendf("<tr><td><b>OutParams: </b></td><td>");
	form.appendf("<table><tr><td><textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea></td>", extfix.str());
	form.append("</tr></table>");
	form.append("</td></tr>");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &COutputDataset::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void COutputDataset::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_name.marshall(rpc_resp, "name", "", "", "");
	m_OutParams.marshall(rpc_resp, "OutParams", "OutParam");
}


void COutputDataset::copy(COutputDataset &from)
{
	m_name.copy(from.m_name);
	m_OutParams.copy(from.m_OutParams);
}


void COutputDataset::copy(IConstOutputDataset &ifrom)
{
	setName(ifrom.getName());
	setOutParams(ifrom.getOutParams());
}


void COutputDataset::getAttributes(IProperties &attributes)
{
}


void COutputDataset::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_name.toStr(ctx, buffer, "name", "", true, "", "");
	m_OutParams.toStr(ctx, buffer, "OutParams", "OutParam");
}


void COutputDataset::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void COutputDataset::serializer(IEspContext* ctx, IConstOutputDataset &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<OutputDataset>");
	// field name
	{
		const char* s = src.getName();
		if (s && *s)
		{
			buffer.append("<name>");
			encodeUtf8XML(s,buffer);
			buffer.append("</name>");
		}
	}
	// field OutParams
	{
		IArrayOf<IConstHPCCColumn>& v = src.getOutParams();
		int size = v.length();
		if (size>0)
			buffer.append("<OutParams>");
		for (int i=0;i<size;i++)
		{
			buffer.append("<OutParam>");
			CHPCCColumn::serializer(ctx,v.item(i),buffer,false);
			buffer.append("</OutParam>");
		}
		if (size>0)
			buffer.append("</OutParams>");
	}
	if (keepRootTag)
		buffer.append("</OutputDataset>");
}

bool COutputDataset::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_name.unmarshall(rpc_request, "name", basepath);
	hasValue |= m_OutParams.unmarshall(rpc_request, "OutParams", basepath);
	return hasValue;
}

bool COutputDataset::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_name.unmarshall(ctx, soapval, "name");
	hasValue |= m_OutParams.unmarshall(ctx, soapval, "OutParams");
	return hasValue;
}

bool COutputDataset::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_name.unmarshall(ctx, params, attachments, "name", basepath);
	hasValue |= m_OutParams.unmarshall(ctx, params, attachments, "OutParams", basepath);
	return hasValue;
}

const char * COutputDataset::getName() { return m_name.query();}
IArrayOf<IConstHPCCColumn> & COutputDataset::getOutParams() { return (IArrayOf<IConstHPCCColumn> &) m_OutParams; }
void COutputDataset::setName(const char * val){ m_name.set(val); }
void COutputDataset::setOutParams(IArrayOf<IEspHPCCColumn> &val)
{
	m_OutParams->kill();
	IArrayOf<IConstHPCCColumn> &target = m_OutParams.getValue();
	ForEachItemIn(idx, val)
	{
		IEspHPCCColumn &item = (val).item(idx);
		item.Link();
		target.append(item);
	}
}
void COutputDataset::setOutParams(IArrayOf<IConstHPCCColumn> &val)
{
	m_OutParams->kill();
	IArrayOf<IConstHPCCColumn> &target = m_OutParams.getValue();
	ForEachItemIn(idx, val)
	{
		IConstHPCCColumn &item = val.item(idx);
		item.Link();
		target.append(item);
	}
}
extern "C"  IEspOutputDataset *createOutputDataset(const char *serv, const char *msgname){return ((IEspOutputDataset *)new COutputDataset(serv /*, msgname*/));}
extern "C"  IClientOutputDataset *createClientOutputDataset(const char *serv, const char *msgname){return ((IClientOutputDataset *)new COutputDataset(serv /*, msgname*/));}

//=======================================================
// class CQuerySignature Implementation
//=======================================================

CQuerySignature::CQuerySignature(const char *serviceName, IRpcMessageBinding *init)
	: m_InParams(nilIgnore),m_ResultSets(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("QuerySignature");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CQuerySignature::CQuerySignature(const char *serviceName, const char *bc)
	: m_InParams(nilIgnore),m_ResultSets(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("QuerySignature");
}

StringBuffer &CQuerySignature::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:complexType name=\"%s\">\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"InParams\">\n");
		schema.append("<xsd:complexType><xsd:sequence>\n");
		schema.append("<xsd:element minOccurs=\"0\" maxOccurs=\"unbounded\" name=\"InParam\" type=\"tns:HPCCColumn\"/>");
		schema.append("</xsd:sequence></xsd:complexType>");
		schema.append("</xsd:element>");
		schema.append("<xsd:element minOccurs=\"0\" name=\"ResultSets\">\n");
		schema.append("<xsd:complexType><xsd:sequence>\n");
		schema.append("<xsd:element minOccurs=\"0\" maxOccurs=\"unbounded\" name=\"ResultSet\" type=\"tns:OutputDataset\"/>");
		schema.append("</xsd:sequence></xsd:complexType>");
		schema.append("</xsd:element>");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType>\n");
		}
	}
	if (!(flags & 0x10)  || (flags & 0x100))
	{
		CHPCCColumn::getXsdDefinition(context, request, schema, added);
		COutputDataset::getXsdDefinition(context, request, schema, added);
	}
	return schema;
}

void CQuerySignature::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CQuerySignature::getMapInfo(IMapInfo& info, BoolHash& added)
{
	if (!added.getValue("HPCCColumn"))
	{
		added.setValue("HPCCColumn",1);
		CHPCCColumn::getMapInfo(info,added);
	}
	if (!added.getValue("OutputDataset"))
	{
		added.setValue("OutputDataset",1);
		COutputDataset::getMapInfo(info,added);
	}
}

StringBuffer &CQuerySignature::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("InParams");
	form.appendf("<tr><td><b>InParams: </b></td><td>");
	form.appendf("<table><tr><td><textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea></td>", extfix.str());
	form.append("</tr></table>");
	form.append("</td></tr>");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("ResultSets");
	form.appendf("<tr><td><b>ResultSets: </b></td><td>");
	form.appendf("<table><tr><td><textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea></td>", extfix.str());
	form.append("</tr></table>");
	form.append("</td></tr>");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CQuerySignature::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CQuerySignature::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_InParams.marshall(rpc_resp, "InParams", "InParam");
	m_ResultSets.marshall(rpc_resp, "ResultSets", "ResultSet");
}


void CQuerySignature::copy(CQuerySignature &from)
{
	m_InParams.copy(from.m_InParams);
	m_ResultSets.copy(from.m_ResultSets);
}


void CQuerySignature::copy(IConstQuerySignature &ifrom)
{
	setInParams(ifrom.getInParams());
	setResultSets(ifrom.getResultSets());
}


void CQuerySignature::getAttributes(IProperties &attributes)
{
}


void CQuerySignature::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_InParams.toStr(ctx, buffer, "InParams", "InParam");
	m_ResultSets.toStr(ctx, buffer, "ResultSets", "ResultSet");
}


void CQuerySignature::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CQuerySignature::serializer(IEspContext* ctx, IConstQuerySignature &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<QuerySignature>");
	// field InParams
	{
		IArrayOf<IConstHPCCColumn>& v = src.getInParams();
		int size = v.length();
		if (size>0)
			buffer.append("<InParams>");
		for (int i=0;i<size;i++)
		{
			buffer.append("<InParam>");
			CHPCCColumn::serializer(ctx,v.item(i),buffer,false);
			buffer.append("</InParam>");
		}
		if (size>0)
			buffer.append("</InParams>");
	}
	// field ResultSets
	{
		IArrayOf<IConstOutputDataset>& v = src.getResultSets();
		int size = v.length();
		if (size>0)
			buffer.append("<ResultSets>");
		for (int i=0;i<size;i++)
		{
			buffer.append("<ResultSet>");
			COutputDataset::serializer(ctx,v.item(i),buffer,false);
			buffer.append("</ResultSet>");
		}
		if (size>0)
			buffer.append("</ResultSets>");
	}
	if (keepRootTag)
		buffer.append("</QuerySignature>");
}

bool CQuerySignature::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_InParams.unmarshall(rpc_request, "InParams", basepath);
	hasValue |= m_ResultSets.unmarshall(rpc_request, "ResultSets", basepath);
	return hasValue;
}

bool CQuerySignature::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_InParams.unmarshall(ctx, soapval, "InParams");
	hasValue |= m_ResultSets.unmarshall(ctx, soapval, "ResultSets");
	return hasValue;
}

bool CQuerySignature::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_InParams.unmarshall(ctx, params, attachments, "InParams", basepath);
	hasValue |= m_ResultSets.unmarshall(ctx, params, attachments, "ResultSets", basepath);
	return hasValue;
}

IArrayOf<IConstHPCCColumn> & CQuerySignature::getInParams() { return (IArrayOf<IConstHPCCColumn> &) m_InParams; }
IArrayOf<IConstOutputDataset> & CQuerySignature::getResultSets() { return (IArrayOf<IConstOutputDataset> &) m_ResultSets; }
void CQuerySignature::setInParams(IArrayOf<IEspHPCCColumn> &val)
{
	m_InParams->kill();
	IArrayOf<IConstHPCCColumn> &target = m_InParams.getValue();
	ForEachItemIn(idx, val)
	{
		IEspHPCCColumn &item = (val).item(idx);
		item.Link();
		target.append(item);
	}
}
void CQuerySignature::setInParams(IArrayOf<IConstHPCCColumn> &val)
{
	m_InParams->kill();
	IArrayOf<IConstHPCCColumn> &target = m_InParams.getValue();
	ForEachItemIn(idx, val)
	{
		IConstHPCCColumn &item = val.item(idx);
		item.Link();
		target.append(item);
	}
}
void CQuerySignature::setResultSets(IArrayOf<IEspOutputDataset> &val)
{
	m_ResultSets->kill();
	IArrayOf<IConstOutputDataset> &target = m_ResultSets.getValue();
	ForEachItemIn(idx, val)
	{
		IEspOutputDataset &item = (val).item(idx);
		item.Link();
		target.append(item);
	}
}
void CQuerySignature::setResultSets(IArrayOf<IConstOutputDataset> &val)
{
	m_ResultSets->kill();
	IArrayOf<IConstOutputDataset> &target = m_ResultSets.getValue();
	ForEachItemIn(idx, val)
	{
		IConstOutputDataset &item = val.item(idx);
		item.Link();
		target.append(item);
	}
}
extern "C"  IEspQuerySignature *createQuerySignature(const char *serv, const char *msgname){return ((IEspQuerySignature *)new CQuerySignature(serv /*, msgname*/));}
extern "C"  IClientQuerySignature *createClientQuerySignature(const char *serv, const char *msgname){return ((IClientQuerySignature *)new CQuerySignature(serv /*, msgname*/));}

//=======================================================
// class CPublishedQuery Implementation
//=======================================================

CPublishedQuery::CPublishedQuery(const char *serviceName, IRpcMessageBinding *init)
	: m_Name(nilIgnore),m_Id(nilIgnore),m_Wuid(nilIgnore),m_Suspended(nilIgnore),m_Signature(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("PublishedQuery");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CPublishedQuery::CPublishedQuery(const char *serviceName, const char *bc)
	: m_Name(nilIgnore),m_Id(nilIgnore),m_Wuid(nilIgnore),m_Suspended(nilIgnore),m_Signature(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("PublishedQuery");
}

StringBuffer &CPublishedQuery::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:complexType name=\"%s\">\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Name\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Id\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Wuid\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Suspended\" type=\"xsd:boolean\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Signature\" type=\"tns:QuerySignature\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType>\n");
		}
	}
	if (!(flags & 0x10)  || (flags & 0x100))
	{
		CQuerySignature::getXsdDefinition(context, request, schema, added);
	}
	return schema;
}

void CPublishedQuery::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CPublishedQuery::getMapInfo(IMapInfo& info, BoolHash& added)
{
	if (!added.getValue("QuerySignature"))
	{
		added.setValue("QuerySignature",1);
		CQuerySignature::getMapInfo(info,added);
	}
}

StringBuffer &CPublishedQuery::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Name");
	form.appendf("  <tr><td><b>Name: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Id");
	form.appendf("  <tr><td><b>Id: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Wuid");
	form.appendf("  <tr><td><b>Wuid: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Suspended");
	
	form.appendf("  <tr><td><b>Suspended? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Signature");
	form.append("<tr>").append("<td><b>Signature: </b></td><td><hr/>");
	CQuerySignature::getHtmlForm(context, request, serv, method, form, false, extfix.str());
	form.append("<hr/></td></tr>");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CPublishedQuery::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CPublishedQuery::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_Name.marshall(rpc_resp, "Name", "", "", "");
	m_Id.marshall(rpc_resp, "Id", "", "", "");
	m_Wuid.marshall(rpc_resp, "Wuid", "", "", "");
	m_Suspended.marshall(rpc_resp, "Suspended", "", "", "");
	m_Signature.marshall(rpc_resp, "Signature", "", "", "");
}


void CPublishedQuery::copy(CPublishedQuery &from)
{
	m_Name.copy(from.m_Name);
	m_Id.copy(from.m_Id);
	m_Wuid.copy(from.m_Wuid);
	m_Suspended.copy(from.m_Suspended);
	m_Signature.copy(from.m_Signature);
}


void CPublishedQuery::copy(IConstPublishedQuery &ifrom)
{
	setName(ifrom.getName());
	setId(ifrom.getId());
	setWuid(ifrom.getWuid());
	setSuspended(ifrom.getSuspended());
	setSignature(ifrom.getSignature());
}


void CPublishedQuery::getAttributes(IProperties &attributes)
{
}


void CPublishedQuery::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_Name.toStr(ctx, buffer, "Name", "", true, "", "");
	m_Id.toStr(ctx, buffer, "Id", "", true, "", "");
	m_Wuid.toStr(ctx, buffer, "Wuid", "", true, "", "");
	m_Suspended.toStr(ctx, buffer, "Suspended", "", true, "", "");
	m_Signature.toStr(ctx, buffer, "Signature", "", false, "", "");
}


void CPublishedQuery::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CPublishedQuery::serializer(IEspContext* ctx, IConstPublishedQuery &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<PublishedQuery>");
	// field Name
	{
		const char* s = src.getName();
		if (s && *s)
		{
			buffer.append("<Name>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Name>");
		}
	}
	// field Id
	{
		const char* s = src.getId();
		if (s && *s)
		{
			buffer.append("<Id>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Id>");
		}
	}
	// field Wuid
	{
		const char* s = src.getWuid();
		if (s && *s)
		{
			buffer.append("<Wuid>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Wuid>");
		}
	}
	// field Suspended
	{
		bool b = src.getSuspended();
		if (b)
			buffer.appendf("<Suspended>1</Suspended>");
	}
	// field Signature
	{
		StringBuffer tmp;
		CQuerySignature::serializer(ctx,src.getSignature(), tmp, false);
		if (tmp.length()>0)
			buffer.appendf("<Signature>%s</Signature>",tmp.str());
	}
	if (keepRootTag)
		buffer.append("</PublishedQuery>");
}

bool CPublishedQuery::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_Name.unmarshall(rpc_request, "Name", basepath);
	hasValue |= m_Id.unmarshall(rpc_request, "Id", basepath);
	hasValue |= m_Wuid.unmarshall(rpc_request, "Wuid", basepath);
	hasValue |= m_Suspended.unmarshall(rpc_request, "Suspended", basepath);
	hasValue |= m_Signature.unmarshall(rpc_request, "Signature", basepath);
	return hasValue;
}

bool CPublishedQuery::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Name.unmarshall(ctx, soapval, "Name");
	hasValue |= m_Id.unmarshall(ctx, soapval, "Id");
	hasValue |= m_Wuid.unmarshall(ctx, soapval, "Wuid");
	hasValue |= m_Suspended.unmarshall(ctx, soapval, "Suspended");
	hasValue |= m_Signature.unmarshall(ctx, soapval, "Signature");
	return hasValue;
}

bool CPublishedQuery::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Name.unmarshall(ctx, params, attachments, "Name", basepath);
	hasValue |= m_Id.unmarshall(ctx, params, attachments, "Id", basepath);
	hasValue |= m_Wuid.unmarshall(ctx, params, attachments, "Wuid", basepath);
	hasValue |= m_Suspended.unmarshall(ctx, params, attachments, "Suspended", basepath);
	hasValue |= m_Signature.unmarshall(ctx, params, attachments, "Signature", basepath);
	return hasValue;
}

const char * CPublishedQuery::getName() { return m_Name.query();}
const char * CPublishedQuery::getId() { return m_Id.query();}
const char * CPublishedQuery::getWuid() { return m_Wuid.query();}
bool CPublishedQuery::getSuspended() { return m_Suspended;}
IConstQuerySignature & CPublishedQuery::getSignature() { return (IConstQuerySignature &) m_Signature.getValue();}
void CPublishedQuery::setName(const char * val){ m_Name.set(val); }
void CPublishedQuery::setId(const char * val){ m_Id.set(val); }
void CPublishedQuery::setWuid(const char * val){ m_Wuid.set(val); }
void CPublishedQuery::setSuspended(bool val){ m_Suspended=val; }
IEspQuerySignature & CPublishedQuery::updateSignature(){ return (IEspQuerySignature &) m_Signature.getValue(); }
void CPublishedQuery::setSignature(IConstQuerySignature &ifrom){ m_Signature.copy(ifrom); }
extern "C"  IEspPublishedQuery *createPublishedQuery(const char *serv, const char *msgname){return ((IEspPublishedQuery *)new CPublishedQuery(serv /*, msgname*/));}
extern "C"  IClientPublishedQuery *createClientPublishedQuery(const char *serv, const char *msgname){return ((IClientPublishedQuery *)new CPublishedQuery(serv /*, msgname*/));}

//=======================================================
// class CQuerySetAliasMap Implementation
//=======================================================

CQuerySetAliasMap::CQuerySetAliasMap(const char *serviceName, IRpcMessageBinding *init)
	: m_Id(nilIgnore),m_Name(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("QuerySetAliasMap");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CQuerySetAliasMap::CQuerySetAliasMap(const char *serviceName, const char *bc)
	: m_Id(nilIgnore),m_Name(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("QuerySetAliasMap");
}

StringBuffer &CQuerySetAliasMap::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:complexType name=\"%s\">\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Id\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Name\" type=\"xsd:string\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType>\n");
		}
	}
	return schema;
}

void CQuerySetAliasMap::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CQuerySetAliasMap::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CQuerySetAliasMap::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Id");
	form.appendf("  <tr><td><b>Id: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Name");
	form.appendf("  <tr><td><b>Name: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CQuerySetAliasMap::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CQuerySetAliasMap::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_Id.marshall(rpc_resp, "Id", "", "", "");
	m_Name.marshall(rpc_resp, "Name", "", "", "");
}


void CQuerySetAliasMap::copy(CQuerySetAliasMap &from)
{
	m_Id.copy(from.m_Id);
	m_Name.copy(from.m_Name);
}


void CQuerySetAliasMap::copy(IConstQuerySetAliasMap &ifrom)
{
	setId(ifrom.getId());
	setName(ifrom.getName());
}


void CQuerySetAliasMap::getAttributes(IProperties &attributes)
{
}


void CQuerySetAliasMap::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_Id.toStr(ctx, buffer, "Id", "", true, "", "");
	m_Name.toStr(ctx, buffer, "Name", "", true, "", "");
}


void CQuerySetAliasMap::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CQuerySetAliasMap::serializer(IEspContext* ctx, IConstQuerySetAliasMap &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<QuerySetAliasMap>");
	// field Id
	{
		const char* s = src.getId();
		if (s && *s)
		{
			buffer.append("<Id>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Id>");
		}
	}
	// field Name
	{
		const char* s = src.getName();
		if (s && *s)
		{
			buffer.append("<Name>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Name>");
		}
	}
	if (keepRootTag)
		buffer.append("</QuerySetAliasMap>");
}

bool CQuerySetAliasMap::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_Id.unmarshall(rpc_request, "Id", basepath);
	hasValue |= m_Name.unmarshall(rpc_request, "Name", basepath);
	return hasValue;
}

bool CQuerySetAliasMap::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Id.unmarshall(ctx, soapval, "Id");
	hasValue |= m_Name.unmarshall(ctx, soapval, "Name");
	return hasValue;
}

bool CQuerySetAliasMap::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Id.unmarshall(ctx, params, attachments, "Id", basepath);
	hasValue |= m_Name.unmarshall(ctx, params, attachments, "Name", basepath);
	return hasValue;
}

const char * CQuerySetAliasMap::getId() { return m_Id.query();}
const char * CQuerySetAliasMap::getName() { return m_Name.query();}
void CQuerySetAliasMap::setId(const char * val){ m_Id.set(val); }
void CQuerySetAliasMap::setName(const char * val){ m_Name.set(val); }
extern "C"  IEspQuerySetAliasMap *createQuerySetAliasMap(const char *serv, const char *msgname){return ((IEspQuerySetAliasMap *)new CQuerySetAliasMap(serv /*, msgname*/));}
extern "C"  IClientQuerySetAliasMap *createClientQuerySetAliasMap(const char *serv, const char *msgname){return ((IClientQuerySetAliasMap *)new CQuerySetAliasMap(serv /*, msgname*/));}

//=======================================================
// class CHPCCQuerySet Implementation
//=======================================================

CHPCCQuerySet::CHPCCQuerySet(const char *serviceName, IRpcMessageBinding *init)
	: m_Name(nilIgnore),m_QuerySetQueries(nilIgnore),m_QuerySetAliases(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("HPCCQuerySet");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CHPCCQuerySet::CHPCCQuerySet(const char *serviceName, const char *bc)
	: m_Name(nilIgnore),m_QuerySetQueries(nilIgnore),m_QuerySetAliases(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("HPCCQuerySet");
}

StringBuffer &CHPCCQuerySet::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:complexType name=\"%s\">\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Name\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"QuerySetQueries\">\n");
		schema.append("<xsd:complexType><xsd:sequence>\n");
		schema.append("<xsd:element minOccurs=\"0\" maxOccurs=\"unbounded\" name=\"QuerySetQuery\" type=\"tns:PublishedQuery\"/>");
		schema.append("</xsd:sequence></xsd:complexType>");
		schema.append("</xsd:element>");
		schema.append("<xsd:element minOccurs=\"0\" name=\"QuerySetAliases\">\n");
		schema.append("<xsd:complexType><xsd:sequence>\n");
		schema.append("<xsd:element minOccurs=\"0\" maxOccurs=\"unbounded\" name=\"QuerySetAlias\" type=\"tns:QuerySetAliasMap\"/>");
		schema.append("</xsd:sequence></xsd:complexType>");
		schema.append("</xsd:element>");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType>\n");
		}
	}
	if (!(flags & 0x10)  || (flags & 0x100))
	{
		CPublishedQuery::getXsdDefinition(context, request, schema, added);
		CQuerySetAliasMap::getXsdDefinition(context, request, schema, added);
	}
	return schema;
}

void CHPCCQuerySet::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CHPCCQuerySet::getMapInfo(IMapInfo& info, BoolHash& added)
{
	if (!added.getValue("PublishedQuery"))
	{
		added.setValue("PublishedQuery",1);
		CPublishedQuery::getMapInfo(info,added);
	}
	if (!added.getValue("QuerySetAliasMap"))
	{
		added.setValue("QuerySetAliasMap",1);
		CQuerySetAliasMap::getMapInfo(info,added);
	}
}

StringBuffer &CHPCCQuerySet::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Name");
	form.appendf("  <tr><td><b>Name: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("QuerySetQueries");
	form.appendf("<tr><td><b>QuerySetQueries: </b></td><td>");
	form.appendf("<table><tr><td><textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea></td>", extfix.str());
	form.append("</tr></table>");
	form.append("</td></tr>");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("QuerySetAliases");
	form.appendf("<tr><td><b>QuerySetAliases: </b></td><td>");
	form.appendf("<table><tr><td><textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea></td>", extfix.str());
	form.append("</tr></table>");
	form.append("</td></tr>");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CHPCCQuerySet::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CHPCCQuerySet::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_Name.marshall(rpc_resp, "Name", "", "", "");
	m_QuerySetQueries.marshall(rpc_resp, "QuerySetQueries", "QuerySetQuery");
	m_QuerySetAliases.marshall(rpc_resp, "QuerySetAliases", "QuerySetAlias");
}


void CHPCCQuerySet::copy(CHPCCQuerySet &from)
{
	m_Name.copy(from.m_Name);
	m_QuerySetQueries.copy(from.m_QuerySetQueries);
	m_QuerySetAliases.copy(from.m_QuerySetAliases);
}


void CHPCCQuerySet::copy(IConstHPCCQuerySet &ifrom)
{
	setName(ifrom.getName());
	setQuerySetQueries(ifrom.getQuerySetQueries());
	setQuerySetAliases(ifrom.getQuerySetAliases());
}


void CHPCCQuerySet::getAttributes(IProperties &attributes)
{
}


void CHPCCQuerySet::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_Name.toStr(ctx, buffer, "Name", "", true, "", "");
	m_QuerySetQueries.toStr(ctx, buffer, "QuerySetQueries", "QuerySetQuery");
	m_QuerySetAliases.toStr(ctx, buffer, "QuerySetAliases", "QuerySetAlias");
}


void CHPCCQuerySet::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CHPCCQuerySet::serializer(IEspContext* ctx, IConstHPCCQuerySet &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<HPCCQuerySet>");
	// field Name
	{
		const char* s = src.getName();
		if (s && *s)
		{
			buffer.append("<Name>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Name>");
		}
	}
	// field QuerySetQueries
	{
		IArrayOf<IConstPublishedQuery>& v = src.getQuerySetQueries();
		int size = v.length();
		if (size>0)
			buffer.append("<QuerySetQueries>");
		for (int i=0;i<size;i++)
		{
			buffer.append("<QuerySetQuery>");
			CPublishedQuery::serializer(ctx,v.item(i),buffer,false);
			buffer.append("</QuerySetQuery>");
		}
		if (size>0)
			buffer.append("</QuerySetQueries>");
	}
	// field QuerySetAliases
	{
		IArrayOf<IConstQuerySetAliasMap>& v = src.getQuerySetAliases();
		int size = v.length();
		if (size>0)
			buffer.append("<QuerySetAliases>");
		for (int i=0;i<size;i++)
		{
			buffer.append("<QuerySetAlias>");
			CQuerySetAliasMap::serializer(ctx,v.item(i),buffer,false);
			buffer.append("</QuerySetAlias>");
		}
		if (size>0)
			buffer.append("</QuerySetAliases>");
	}
	if (keepRootTag)
		buffer.append("</HPCCQuerySet>");
}

bool CHPCCQuerySet::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_Name.unmarshall(rpc_request, "Name", basepath);
	hasValue |= m_QuerySetQueries.unmarshall(rpc_request, "QuerySetQueries", basepath);
	hasValue |= m_QuerySetAliases.unmarshall(rpc_request, "QuerySetAliases", basepath);
	return hasValue;
}

bool CHPCCQuerySet::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Name.unmarshall(ctx, soapval, "Name");
	hasValue |= m_QuerySetQueries.unmarshall(ctx, soapval, "QuerySetQueries");
	hasValue |= m_QuerySetAliases.unmarshall(ctx, soapval, "QuerySetAliases");
	return hasValue;
}

bool CHPCCQuerySet::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Name.unmarshall(ctx, params, attachments, "Name", basepath);
	hasValue |= m_QuerySetQueries.unmarshall(ctx, params, attachments, "QuerySetQueries", basepath);
	hasValue |= m_QuerySetAliases.unmarshall(ctx, params, attachments, "QuerySetAliases", basepath);
	return hasValue;
}

const char * CHPCCQuerySet::getName() { return m_Name.query();}
IArrayOf<IConstPublishedQuery> & CHPCCQuerySet::getQuerySetQueries() { return (IArrayOf<IConstPublishedQuery> &) m_QuerySetQueries; }
IArrayOf<IConstQuerySetAliasMap> & CHPCCQuerySet::getQuerySetAliases() { return (IArrayOf<IConstQuerySetAliasMap> &) m_QuerySetAliases; }
void CHPCCQuerySet::setName(const char * val){ m_Name.set(val); }
void CHPCCQuerySet::setQuerySetQueries(IArrayOf<IEspPublishedQuery> &val)
{
	m_QuerySetQueries->kill();
	IArrayOf<IConstPublishedQuery> &target = m_QuerySetQueries.getValue();
	ForEachItemIn(idx, val)
	{
		IEspPublishedQuery &item = (val).item(idx);
		item.Link();
		target.append(item);
	}
}
void CHPCCQuerySet::setQuerySetQueries(IArrayOf<IConstPublishedQuery> &val)
{
	m_QuerySetQueries->kill();
	IArrayOf<IConstPublishedQuery> &target = m_QuerySetQueries.getValue();
	ForEachItemIn(idx, val)
	{
		IConstPublishedQuery &item = val.item(idx);
		item.Link();
		target.append(item);
	}
}
void CHPCCQuerySet::setQuerySetAliases(IArrayOf<IEspQuerySetAliasMap> &val)
{
	m_QuerySetAliases->kill();
	IArrayOf<IConstQuerySetAliasMap> &target = m_QuerySetAliases.getValue();
	ForEachItemIn(idx, val)
	{
		IEspQuerySetAliasMap &item = (val).item(idx);
		item.Link();
		target.append(item);
	}
}
void CHPCCQuerySet::setQuerySetAliases(IArrayOf<IConstQuerySetAliasMap> &val)
{
	m_QuerySetAliases->kill();
	IArrayOf<IConstQuerySetAliasMap> &target = m_QuerySetAliases.getValue();
	ForEachItemIn(idx, val)
	{
		IConstQuerySetAliasMap &item = val.item(idx);
		item.Link();
		target.append(item);
	}
}
extern "C"  IEspHPCCQuerySet *createHPCCQuerySet(const char *serv, const char *msgname){return ((IEspHPCCQuerySet *)new CHPCCQuerySet(serv /*, msgname*/));}
extern "C"  IClientHPCCQuerySet *createClientHPCCQuerySet(const char *serv, const char *msgname){return ((IClientHPCCQuerySet *)new CHPCCQuerySet(serv /*, msgname*/));}

//=======================================================
// class CHPCCTargetCluster Implementation
//=======================================================

CHPCCTargetCluster::CHPCCTargetCluster(const char *serviceName, IRpcMessageBinding *init)
	: m_Name(nilIgnore),m_QuerySetQueries(nilIgnore),m_QuerySetAliases(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("HPCCTargetCluster");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CHPCCTargetCluster::CHPCCTargetCluster(const char *serviceName, const char *bc)
	: m_Name(nilIgnore),m_QuerySetQueries(nilIgnore),m_QuerySetAliases(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("HPCCTargetCluster");
}

StringBuffer &CHPCCTargetCluster::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:complexType name=\"%s\">\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Name\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"QuerySetQueries\">\n");
		schema.append("<xsd:complexType><xsd:sequence>\n");
		schema.append("<xsd:element minOccurs=\"0\" maxOccurs=\"unbounded\" name=\"QuerySetQuery\" type=\"tns:PublishedQuery\"/>");
		schema.append("</xsd:sequence></xsd:complexType>");
		schema.append("</xsd:element>");
		schema.append("<xsd:element minOccurs=\"0\" name=\"QuerySetAliases\">\n");
		schema.append("<xsd:complexType><xsd:sequence>\n");
		schema.append("<xsd:element minOccurs=\"0\" maxOccurs=\"unbounded\" name=\"QuerySetAlias\" type=\"tns:QuerySetAliasMap\"/>");
		schema.append("</xsd:sequence></xsd:complexType>");
		schema.append("</xsd:element>");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType>\n");
		}
	}
	if (!(flags & 0x10)  || (flags & 0x100))
	{
		CPublishedQuery::getXsdDefinition(context, request, schema, added);
		CQuerySetAliasMap::getXsdDefinition(context, request, schema, added);
	}
	return schema;
}

void CHPCCTargetCluster::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CHPCCTargetCluster::getMapInfo(IMapInfo& info, BoolHash& added)
{
	if (!added.getValue("PublishedQuery"))
	{
		added.setValue("PublishedQuery",1);
		CPublishedQuery::getMapInfo(info,added);
	}
	if (!added.getValue("QuerySetAliasMap"))
	{
		added.setValue("QuerySetAliasMap",1);
		CQuerySetAliasMap::getMapInfo(info,added);
	}
}

StringBuffer &CHPCCTargetCluster::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Name");
	form.appendf("  <tr><td><b>Name: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("QuerySetQueries");
	form.appendf("<tr><td><b>QuerySetQueries: </b></td><td>");
	form.appendf("<table><tr><td><textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea></td>", extfix.str());
	form.append("</tr></table>");
	form.append("</td></tr>");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("QuerySetAliases");
	form.appendf("<tr><td><b>QuerySetAliases: </b></td><td>");
	form.appendf("<table><tr><td><textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea></td>", extfix.str());
	form.append("</tr></table>");
	form.append("</td></tr>");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CHPCCTargetCluster::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CHPCCTargetCluster::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_Name.marshall(rpc_resp, "Name", "", "", "");
	m_QuerySetQueries.marshall(rpc_resp, "QuerySetQueries", "QuerySetQuery");
	m_QuerySetAliases.marshall(rpc_resp, "QuerySetAliases", "QuerySetAlias");
}


void CHPCCTargetCluster::copy(CHPCCTargetCluster &from)
{
	m_Name.copy(from.m_Name);
	m_QuerySetQueries.copy(from.m_QuerySetQueries);
	m_QuerySetAliases.copy(from.m_QuerySetAliases);
}


void CHPCCTargetCluster::copy(IConstHPCCTargetCluster &ifrom)
{
	setName(ifrom.getName());
	setQuerySetQueries(ifrom.getQuerySetQueries());
	setQuerySetAliases(ifrom.getQuerySetAliases());
}


void CHPCCTargetCluster::getAttributes(IProperties &attributes)
{
}


void CHPCCTargetCluster::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_Name.toStr(ctx, buffer, "Name", "", true, "", "");
	m_QuerySetQueries.toStr(ctx, buffer, "QuerySetQueries", "QuerySetQuery");
	m_QuerySetAliases.toStr(ctx, buffer, "QuerySetAliases", "QuerySetAlias");
}


void CHPCCTargetCluster::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CHPCCTargetCluster::serializer(IEspContext* ctx, IConstHPCCTargetCluster &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<HPCCTargetCluster>");
	// field Name
	{
		const char* s = src.getName();
		if (s && *s)
		{
			buffer.append("<Name>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Name>");
		}
	}
	// field QuerySetQueries
	{
		IArrayOf<IConstPublishedQuery>& v = src.getQuerySetQueries();
		int size = v.length();
		if (size>0)
			buffer.append("<QuerySetQueries>");
		for (int i=0;i<size;i++)
		{
			buffer.append("<QuerySetQuery>");
			CPublishedQuery::serializer(ctx,v.item(i),buffer,false);
			buffer.append("</QuerySetQuery>");
		}
		if (size>0)
			buffer.append("</QuerySetQueries>");
	}
	// field QuerySetAliases
	{
		IArrayOf<IConstQuerySetAliasMap>& v = src.getQuerySetAliases();
		int size = v.length();
		if (size>0)
			buffer.append("<QuerySetAliases>");
		for (int i=0;i<size;i++)
		{
			buffer.append("<QuerySetAlias>");
			CQuerySetAliasMap::serializer(ctx,v.item(i),buffer,false);
			buffer.append("</QuerySetAlias>");
		}
		if (size>0)
			buffer.append("</QuerySetAliases>");
	}
	if (keepRootTag)
		buffer.append("</HPCCTargetCluster>");
}

bool CHPCCTargetCluster::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_Name.unmarshall(rpc_request, "Name", basepath);
	hasValue |= m_QuerySetQueries.unmarshall(rpc_request, "QuerySetQueries", basepath);
	hasValue |= m_QuerySetAliases.unmarshall(rpc_request, "QuerySetAliases", basepath);
	return hasValue;
}

bool CHPCCTargetCluster::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Name.unmarshall(ctx, soapval, "Name");
	hasValue |= m_QuerySetQueries.unmarshall(ctx, soapval, "QuerySetQueries");
	hasValue |= m_QuerySetAliases.unmarshall(ctx, soapval, "QuerySetAliases");
	return hasValue;
}

bool CHPCCTargetCluster::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Name.unmarshall(ctx, params, attachments, "Name", basepath);
	hasValue |= m_QuerySetQueries.unmarshall(ctx, params, attachments, "QuerySetQueries", basepath);
	hasValue |= m_QuerySetAliases.unmarshall(ctx, params, attachments, "QuerySetAliases", basepath);
	return hasValue;
}

const char * CHPCCTargetCluster::getName() { return m_Name.query();}
IArrayOf<IConstPublishedQuery> & CHPCCTargetCluster::getQuerySetQueries() { return (IArrayOf<IConstPublishedQuery> &) m_QuerySetQueries; }
IArrayOf<IConstQuerySetAliasMap> & CHPCCTargetCluster::getQuerySetAliases() { return (IArrayOf<IConstQuerySetAliasMap> &) m_QuerySetAliases; }
void CHPCCTargetCluster::setName(const char * val){ m_Name.set(val); }
void CHPCCTargetCluster::setQuerySetQueries(IArrayOf<IEspPublishedQuery> &val)
{
	m_QuerySetQueries->kill();
	IArrayOf<IConstPublishedQuery> &target = m_QuerySetQueries.getValue();
	ForEachItemIn(idx, val)
	{
		IEspPublishedQuery &item = (val).item(idx);
		item.Link();
		target.append(item);
	}
}
void CHPCCTargetCluster::setQuerySetQueries(IArrayOf<IConstPublishedQuery> &val)
{
	m_QuerySetQueries->kill();
	IArrayOf<IConstPublishedQuery> &target = m_QuerySetQueries.getValue();
	ForEachItemIn(idx, val)
	{
		IConstPublishedQuery &item = val.item(idx);
		item.Link();
		target.append(item);
	}
}
void CHPCCTargetCluster::setQuerySetAliases(IArrayOf<IEspQuerySetAliasMap> &val)
{
	m_QuerySetAliases->kill();
	IArrayOf<IConstQuerySetAliasMap> &target = m_QuerySetAliases.getValue();
	ForEachItemIn(idx, val)
	{
		IEspQuerySetAliasMap &item = (val).item(idx);
		item.Link();
		target.append(item);
	}
}
void CHPCCTargetCluster::setQuerySetAliases(IArrayOf<IConstQuerySetAliasMap> &val)
{
	m_QuerySetAliases->kill();
	IArrayOf<IConstQuerySetAliasMap> &target = m_QuerySetAliases.getValue();
	ForEachItemIn(idx, val)
	{
		IConstQuerySetAliasMap &item = val.item(idx);
		item.Link();
		target.append(item);
	}
}
extern "C"  IEspHPCCTargetCluster *createHPCCTargetCluster(const char *serv, const char *msgname){return ((IEspHPCCTargetCluster *)new CHPCCTargetCluster(serv /*, msgname*/));}
extern "C"  IClientHPCCTargetCluster *createClientHPCCTargetCluster(const char *serv, const char *msgname){return ((IClientHPCCTargetCluster *)new CHPCCTargetCluster(serv /*, msgname*/));}

//=======================================================
// class CPrepareSQLRequest Implementation
//=======================================================

CPrepareSQLRequest::CPrepareSQLRequest(const char *serviceName, IRpcMessageBinding *init)
	: m_SqlText(nilIgnore),m_TargetCluster(nilIgnore),m_AlternateClusters(nilIgnore),m_TargetQuerySet(nilIgnore),m_Wait(-1, nilIgnore,false)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("PrepareSQLRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CPrepareSQLRequest::CPrepareSQLRequest(const char *serviceName, const char *bc)
	: m_SqlText(nilIgnore),m_TargetCluster(nilIgnore),m_AlternateClusters(nilIgnore),m_TargetQuerySet(nilIgnore),m_Wait(-1, nilIgnore,false)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("PrepareSQLRequest");
}

CPrepareSQLRequest::CPrepareSQLRequest(const char *serviceName, IRpcMessage* rpcmsg)
	: m_SqlText(nilIgnore),m_TargetCluster(nilIgnore),m_AlternateClusters(nilIgnore),m_TargetQuerySet(nilIgnore),m_Wait(-1, nilIgnore,false)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("PrepareSQLRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CPrepareSQLRequest::CPrepareSQLRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_SqlText(nilIgnore),m_TargetCluster(nilIgnore),m_AlternateClusters(nilIgnore),m_TargetQuerySet(nilIgnore),m_Wait(-1, nilIgnore,false)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("PrepareSQLRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CPrepareSQLRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"SqlText\" type=\"xsd:string\"");
		if (context.queryOptions()&ESPCTX_ALL_ANNOTATION)
			schema.append("> <xsd:annotation><xsd:appinfo><form formCols=\"80\" formRows=\"28\"/></xsd:appinfo></xsd:annotation></xsd:element>\n");
		else
			schema.append("/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"TargetCluster\" type=\"xsd:string\"/>\n");
		if (!context.suppressed("PrepareSQLRequest","AlternateClusters")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"AlternateClusters\">");
			schema.append("<xsd:complexType><xsd:sequence>");
			schema.append("<xsd:element name=\"AlternateCluster\" type=\"xsd:string\" minOccurs=\"0\" maxOccurs=\"unbounded\"/>\n");
			schema.append("</xsd:sequence></xsd:complexType>\n");
			schema.append("</xsd:element>\n");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"TargetQuerySet\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" default=\"-1\" name=\"Wait\" type=\"xsd:int\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CPrepareSQLRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CPrepareSQLRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
	info.addMinVersion("PrepareSQLRequest","AlternateClusters",3.04);
}

StringBuffer &CPrepareSQLRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("SqlText");
	form.appendf("<tr><td><b>SqlText: </b></td><td>");
	form.appendf("<table><tr><td><textarea name=\"%s\" cols=\"80\" rows=\"28\"></textarea></td>", extfix.str());
	form.append("</tr></table>");
	form.append("</td></tr>");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("TargetCluster");
	form.appendf("  <tr><td><b>TargetCluster: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (!context.suppressed("PrepareSQLRequest","AlternateClusters")) {
		extfix.clear();
		if (prefix && *prefix)
			extfix.append(prefix).append(".");
		extfix.append("AlternateClusters");
		form.appendf("<tr><td><b>AlternateClusters: </b></td><td>");
		form.appendf("<textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea>", extfix.str());
		form.append("</td></tr>");
	}
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("TargetQuerySet");
	form.appendf("  <tr><td><b>TargetQuerySet: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix) extfix.append(prefix).append(".");
		extfix.append("Wait");
	form.appendf("  <tr><td><b>Wait: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"	 value=\"-1\"/>", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CPrepareSQLRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CPrepareSQLRequest::serialize(IRpcMessage& rpc_resp)
{
	IEspContext* ctx = rpc_resp.queryContext();
	double clientVer= ctx ? ctx->getClientVersion() : -1; /* no context gets everything */
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_SqlText.marshall(rpc_resp, "SqlText", "", "", "");
	m_TargetCluster.marshall(rpc_resp, "TargetCluster", "", "", "");
	if ((clientVer==-1.0 || clientVer>=3.04))
		m_AlternateClusters.marshall(rpc_resp, "AlternateClusters", "AlternateCluster");
	m_TargetQuerySet.marshall(rpc_resp, "TargetQuerySet", "", "", "");
	m_Wait.marshall(rpc_resp, "Wait", "", "", "");
}


void CPrepareSQLRequest::copy(CPrepareSQLRequest &from)
{
	m_SqlText.copy(from.m_SqlText);
	m_TargetCluster.copy(from.m_TargetCluster);
	m_AlternateClusters.copy(from.m_AlternateClusters);
	m_TargetQuerySet.copy(from.m_TargetQuerySet);
	m_Wait.copy(from.m_Wait);
}


void CPrepareSQLRequest::copy(IConstPrepareSQLRequest &ifrom)
{
	setSqlText(ifrom.getSqlText());
	setTargetCluster(ifrom.getTargetCluster());
	setAlternateClusters(ifrom.getAlternateClusters());
	setTargetQuerySet(ifrom.getTargetQuerySet());
	setWait(ifrom.getWait());
}


void CPrepareSQLRequest::getAttributes(IProperties &attributes)
{
}


void CPrepareSQLRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	double clientVer = ctx ? ctx->getClientVersion() : -1;
	m_SqlText.toStr(ctx, buffer, "SqlText", "", true, "", "");
	m_TargetCluster.toStr(ctx, buffer, "TargetCluster", "", true, "", "");
	if ((clientVer==-1.0 || clientVer>=3.04))
		m_AlternateClusters.toStr(ctx, buffer, "AlternateClusters", "AlternateCluster");
	m_TargetQuerySet.toStr(ctx, buffer, "TargetQuerySet", "", true, "", "");
	m_Wait.toStr(ctx, buffer, "Wait", "", true, "", "");
}


void CPrepareSQLRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CPrepareSQLRequest::serializer(IEspContext* ctx, IConstPrepareSQLRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<PrepareSQLRequest>");
	double clientVer = ctx ? ctx->getClientVersion() : -1;
	// field SqlText
	{
		const char* s = src.getSqlText();
		if (s && *s)
		{
			buffer.append("<SqlText>");
			encodeUtf8XML(s,buffer);
			buffer.append("</SqlText>");
		}
	}
	// field TargetCluster
	{
		const char* s = src.getTargetCluster();
		if (s && *s)
		{
			buffer.append("<TargetCluster>");
			encodeUtf8XML(s,buffer);
			buffer.append("</TargetCluster>");
		}
	}
	// field AlternateClusters
	if ((clientVer==-1.0 || clientVer>=3.04))
	{
		StringArray& v = src.getAlternateClusters();
		if (v.length()>0)
			buffer.append("<AlternateClusters>");
		for (size32_t i=0;i<v.length();i++)
			buffer.appendf("<AlternateCluster>%s</AlternateCluster>",v.item(i));
		if (v.length()>0)
			buffer.append("</AlternateClusters>");
	}
	// field TargetQuerySet
	{
		const char* s = src.getTargetQuerySet();
		if (s && *s)
		{
			buffer.append("<TargetQuerySet>");
			encodeUtf8XML(s,buffer);
			buffer.append("</TargetQuerySet>");
		}
	}
	// field Wait
	{
		int n = src.getWait();
		if (n)
			buffer.appendf("<Wait>%d</Wait>", n);
	}
	if (keepRootTag)
		buffer.append("</PrepareSQLRequest>");
}

bool CPrepareSQLRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_SqlText.unmarshall(rpc_request, "SqlText", basepath);
	hasValue |= m_TargetCluster.unmarshall(rpc_request, "TargetCluster", basepath);
	hasValue |= m_AlternateClusters.unmarshall(rpc_request, "AlternateClusters", basepath);
	hasValue |= m_TargetQuerySet.unmarshall(rpc_request, "TargetQuerySet", basepath);
	hasValue |= m_Wait.unmarshall(rpc_request, "Wait", basepath);
	return hasValue;
}

bool CPrepareSQLRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_SqlText.unmarshall(ctx, soapval, "SqlText");
	hasValue |= m_TargetCluster.unmarshall(ctx, soapval, "TargetCluster");
	hasValue |= m_AlternateClusters.unmarshall(ctx, soapval, "AlternateClusters");
	hasValue |= m_TargetQuerySet.unmarshall(ctx, soapval, "TargetQuerySet");
	hasValue |= m_Wait.unmarshall(ctx, soapval, "Wait");
	return hasValue;
}

bool CPrepareSQLRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_SqlText.unmarshall(ctx, params, attachments, "SqlText", basepath);
	hasValue |= m_TargetCluster.unmarshall(ctx, params, attachments, "TargetCluster", basepath);
	hasValue |= m_AlternateClusters.unmarshall(ctx, params, attachments, "AlternateClusters", basepath);
	hasValue |= m_TargetQuerySet.unmarshall(ctx, params, attachments, "TargetQuerySet", basepath);
	hasValue |= m_Wait.unmarshall(ctx, params, attachments, "Wait", basepath);
	return hasValue;
}

const char * CPrepareSQLRequest::getSqlText() { return m_SqlText.query();}
const char * CPrepareSQLRequest::getTargetCluster() { return m_TargetCluster.query();}
StringArray & CPrepareSQLRequest::getAlternateClusters() { return (StringArray &) m_AlternateClusters; }
const char * CPrepareSQLRequest::getTargetQuerySet() { return m_TargetQuerySet.query();}
int CPrepareSQLRequest::getWait() { return m_Wait;}
void CPrepareSQLRequest::setSqlText(const char * val){ m_SqlText.set(val); }
void CPrepareSQLRequest::setTargetCluster(const char * val){ m_TargetCluster.set(val); }
void CPrepareSQLRequest::setAlternateClusters(StringArray &val){ m_AlternateClusters->kill();  CloneArray(m_AlternateClusters.getValue(), val); }
void CPrepareSQLRequest::setTargetQuerySet(const char * val){ m_TargetQuerySet.set(val); }
void CPrepareSQLRequest::setWait(int val){ m_Wait=val; }
extern "C"  IEspPrepareSQLRequest *createPrepareSQLRequest(const char *serv){return ((IEspPrepareSQLRequest *)new CPrepareSQLRequest(serv));}
extern "C"  IClientPrepareSQLRequest *createClientPrepareSQLRequest(const char *serv){return ((IClientPrepareSQLRequest *)new CPrepareSQLRequest(serv));}

//=======================================================
// class CPrepareSQLResponse Implementation
//=======================================================

CPrepareSQLResponse::CPrepareSQLResponse(const char *serviceName, IRpcMessageBinding *init)
	: m_Workunit(serviceName, nilIgnore),m_Result(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("PrepareSQLResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CPrepareSQLResponse::CPrepareSQLResponse(const char *serviceName, const char *bc)
	: m_Workunit(serviceName, nilIgnore),m_Result(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("PrepareSQLResponse");
}

CPrepareSQLResponse::CPrepareSQLResponse(const char *serviceName, IRpcMessage* rpcmsg)
	: m_Workunit(serviceName, nilIgnore),m_Result(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("PrepareSQLResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CPrepareSQLResponse::CPrepareSQLResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_Workunit(serviceName, nilIgnore),m_Result(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("PrepareSQLResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CPrepareSQLResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		schema.append("<xsd:element name=\"Exceptions\" type=\"tns:ArrayOfEspException\" minOccurs=\"0\" maxOccurs=\"1\"/>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Workunit\" type=\"tns:ECLWorkunit\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Result\" type=\"xsd:string\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	if (!(flags & 0x10)  || (flags & 0x100))
	{
		CECLWorkunit::getXsdDefinition(context, request, schema, added);
	}
	return schema;
}

void CPrepareSQLResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CPrepareSQLResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
	if (!added.getValue("ECLWorkunit"))
	{
		added.setValue("ECLWorkunit",1);
		CECLWorkunit::getMapInfo(info,added);
	}
}

StringBuffer &CPrepareSQLResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Workunit");
	form.append("<tr>").append("<td><b>Workunit: </b></td><td><hr/>");
	CECLWorkunit::getHtmlForm(context, request, serv, method, form, false, extfix.str());
	form.append("<hr/></td></tr>");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Result");
	form.appendf("  <tr><td><b>Result: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CPrepareSQLResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CPrepareSQLResponse::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
		m_Workunit.marshall(rpc_resp, "Workunit", "", "", "");
		m_Result.marshall(rpc_resp, "Result", "", "", "");
	}
}


void CPrepareSQLResponse::copy(CPrepareSQLResponse &from)
{
	m_Workunit.copy(from.m_Workunit);
	m_Result.copy(from.m_Result);
}


void CPrepareSQLResponse::copy(IConstPrepareSQLResponse &ifrom)
{
	setWorkunit(ifrom.getWorkunit());
	setResult(ifrom.getResult());
}


void CPrepareSQLResponse::getAttributes(IProperties &attributes)
{
}


void CPrepareSQLResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
		m_Workunit.toStr(ctx, buffer, "Workunit", "", false, "", "");
		m_Result.toStr(ctx, buffer, "Result", "", true, "", "");
	}
}


void CPrepareSQLResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CPrepareSQLResponse::serializer(IEspContext* ctx, IConstPrepareSQLResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<PrepareSQLResponse>");
	// field Workunit
	{
		StringBuffer tmp;
		CECLWorkunit::serializer(ctx,src.getWorkunit(), tmp, false);
		if (tmp.length()>0)
			buffer.appendf("<Workunit>%s</Workunit>",tmp.str());
	}
	// field Result
	{
		const char* s = src.getResult();
		if (s && *s)
		{
			buffer.append("<Result>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Result>");
		}
	}
	if (keepRootTag)
		buffer.append("</PrepareSQLResponse>");
}

bool CPrepareSQLResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
		hasValue |= m_Workunit.unmarshall(rpc_request, "Workunit", basepath);
		hasValue |= m_Result.unmarshall(rpc_request, "Result", basepath);
	}
	return hasValue;
}

bool CPrepareSQLResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Workunit.unmarshall(ctx, soapval, "Workunit");
	hasValue |= m_Result.unmarshall(ctx, soapval, "Result");
	return hasValue;
}

bool CPrepareSQLResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Workunit.unmarshall(ctx, params, attachments, "Workunit", basepath);
	hasValue |= m_Result.unmarshall(ctx, params, attachments, "Result", basepath);
	return hasValue;
}

IConstECLWorkunit & CPrepareSQLResponse::getWorkunit() { return (IConstECLWorkunit &) m_Workunit.getValue();}
const char * CPrepareSQLResponse::getResult() { return m_Result.query();}
IEspECLWorkunit & CPrepareSQLResponse::updateWorkunit(){ return (IEspECLWorkunit &) m_Workunit.getValue(); }
void CPrepareSQLResponse::setWorkunit(IConstECLWorkunit &ifrom){ m_Workunit.copy(ifrom); }
void CPrepareSQLResponse::setResult(const char * val){ m_Result.set(val); }
extern "C"  IEspPrepareSQLResponse *createPrepareSQLResponse(const char *serv){return ((IEspPrepareSQLResponse *)new CPrepareSQLResponse(serv));}
extern "C"  IClientPrepareSQLResponse *createClientPrepareSQLResponse(const char *serv){return ((IClientPrepareSQLResponse *)new CPrepareSQLResponse(serv));}

//=======================================================
// class CExecuteSQLRequest Implementation
//=======================================================

CExecuteSQLRequest::CExecuteSQLRequest(const char *serviceName, IRpcMessageBinding *init)
	: m_SqlText(nilIgnore),m_UserName(nilIgnore),m_TargetCluster(nilIgnore),m_AlternateClusters(nilIgnore),m_TargetQuerySet(nilIgnore),m_SuppressResults(nilIgnore),m_SuppressXmlSchema(nilIgnore),m_Wait(-1, nilIgnore,false),m_resultLimit(0, nilIgnore,false),m_ResultWindowStart(0, nilIgnore,false),m_ResultWindowCount(0, nilIgnore,false),m_IgnoreCache(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ExecuteSQLRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CExecuteSQLRequest::CExecuteSQLRequest(const char *serviceName, const char *bc)
	: m_SqlText(nilIgnore),m_UserName(nilIgnore),m_TargetCluster(nilIgnore),m_AlternateClusters(nilIgnore),m_TargetQuerySet(nilIgnore),m_SuppressResults(nilIgnore),m_SuppressXmlSchema(nilIgnore),m_Wait(-1, nilIgnore,false),m_resultLimit(0, nilIgnore,false),m_ResultWindowStart(0, nilIgnore,false),m_ResultWindowCount(0, nilIgnore,false),m_IgnoreCache(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ExecuteSQLRequest");
}

CExecuteSQLRequest::CExecuteSQLRequest(const char *serviceName, IRpcMessage* rpcmsg)
	: m_SqlText(nilIgnore),m_UserName(nilIgnore),m_TargetCluster(nilIgnore),m_AlternateClusters(nilIgnore),m_TargetQuerySet(nilIgnore),m_SuppressResults(nilIgnore),m_SuppressXmlSchema(nilIgnore),m_Wait(-1, nilIgnore,false),m_resultLimit(0, nilIgnore,false),m_ResultWindowStart(0, nilIgnore,false),m_ResultWindowCount(0, nilIgnore,false),m_IgnoreCache(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ExecuteSQLRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CExecuteSQLRequest::CExecuteSQLRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_SqlText(nilIgnore),m_UserName(nilIgnore),m_TargetCluster(nilIgnore),m_AlternateClusters(nilIgnore),m_TargetQuerySet(nilIgnore),m_SuppressResults(nilIgnore),m_SuppressXmlSchema(nilIgnore),m_Wait(-1, nilIgnore,false),m_resultLimit(0, nilIgnore,false),m_ResultWindowStart(0, nilIgnore,false),m_ResultWindowCount(0, nilIgnore,false),m_IgnoreCache(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ExecuteSQLRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CExecuteSQLRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"SqlText\" type=\"xsd:string\"");
		if (context.queryOptions()&ESPCTX_ALL_ANNOTATION)
			schema.append("> <xsd:annotation><xsd:appinfo><form formCols=\"80\" formRows=\"28\"/></xsd:appinfo></xsd:annotation></xsd:element>\n");
		else
			schema.append("/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"UserName\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"TargetCluster\" type=\"xsd:string\"/>\n");
		if (!context.suppressed("ExecuteSQLRequest","AlternateClusters")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"AlternateClusters\">");
			schema.append("<xsd:complexType><xsd:sequence>");
			schema.append("<xsd:element name=\"AlternateCluster\" type=\"xsd:string\" minOccurs=\"0\" maxOccurs=\"unbounded\"/>\n");
			schema.append("</xsd:sequence></xsd:complexType>\n");
			schema.append("</xsd:element>\n");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"TargetQuerySet\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"SuppressResults\" type=\"xsd:boolean\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" default=\"1\" name=\"SuppressXmlSchema\" type=\"xsd:boolean\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" default=\"-1\" name=\"Wait\" type=\"xsd:int\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"resultLimit\" type=\"xsd:int\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"ResultWindowStart\" type=\"xsd:int\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"ResultWindowCount\" type=\"xsd:int\"/>\n");
		if (!context.suppressed("ExecuteSQLRequest","IgnoreCache")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"IgnoreCache\" type=\"xsd:boolean\"/>\n");
		}
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CExecuteSQLRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CExecuteSQLRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
	info.addMinVersion("ExecuteSQLRequest","AlternateClusters",3.04);
	info.addMinVersion("ExecuteSQLRequest","IgnoreCache",3.05);
}

StringBuffer &CExecuteSQLRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("SqlText");
	form.appendf("<tr><td><b>SqlText: </b></td><td>");
	form.appendf("<table><tr><td><textarea name=\"%s\" cols=\"80\" rows=\"28\"></textarea></td>", extfix.str());
	form.append("</tr></table>");
	form.append("</td></tr>");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("UserName");
	form.appendf("  <tr><td><b>UserName: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("TargetCluster");
	form.appendf("  <tr><td><b>TargetCluster: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (!context.suppressed("ExecuteSQLRequest","AlternateClusters")) {
		extfix.clear();
		if (prefix && *prefix)
			extfix.append(prefix).append(".");
		extfix.append("AlternateClusters");
		form.appendf("<tr><td><b>AlternateClusters: </b></td><td>");
		form.appendf("<textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea>", extfix.str());
		form.append("</td></tr>");
	}
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("TargetQuerySet");
	form.appendf("  <tr><td><b>TargetQuerySet: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("SuppressResults");
	
	form.appendf("  <tr><td><b>SuppressResults? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("SuppressXmlSchema");
	
	form.appendf("  <tr><td><b>SuppressXmlSchema? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\" checked=\"1\" /></td></tr>\n", extfix.str());
	extfix.clear();
	if (prefix && *prefix) extfix.append(prefix).append(".");
		extfix.append("Wait");
	form.appendf("  <tr><td><b>Wait: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"	 value=\"-1\"/>", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix) extfix.append(prefix).append(".");
		extfix.append("resultLimit");
	form.appendf("  <tr><td><b>resultLimit: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix) extfix.append(prefix).append(".");
		extfix.append("ResultWindowStart");
	form.appendf("  <tr><td><b>ResultWindowStart: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix) extfix.append(prefix).append(".");
		extfix.append("ResultWindowCount");
	form.appendf("  <tr><td><b>ResultWindowCount: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
	form.append("</td></tr>\n");
	if (!context.suppressed("ExecuteSQLRequest","IgnoreCache")) {
		extfix.clear();
		if (prefix && *prefix)
			extfix.append(prefix).append(".");
		extfix.append("IgnoreCache");
		
	form.appendf("  <tr><td><b>IgnoreCache? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	}
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CExecuteSQLRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CExecuteSQLRequest::serialize(IRpcMessage& rpc_resp)
{
	IEspContext* ctx = rpc_resp.queryContext();
	double clientVer= ctx ? ctx->getClientVersion() : -1; /* no context gets everything */
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_SqlText.marshall(rpc_resp, "SqlText", "", "", "");
	m_UserName.marshall(rpc_resp, "UserName", "", "", "");
	m_TargetCluster.marshall(rpc_resp, "TargetCluster", "", "", "");
	if ((clientVer==-1.0 || clientVer>=3.04))
		m_AlternateClusters.marshall(rpc_resp, "AlternateClusters", "AlternateCluster");
	m_TargetQuerySet.marshall(rpc_resp, "TargetQuerySet", "", "", "");
	m_SuppressResults.marshall(rpc_resp, "SuppressResults", "", "", "");
	m_SuppressXmlSchema.marshall(rpc_resp, "SuppressXmlSchema", "", "", "");
	m_Wait.marshall(rpc_resp, "Wait", "", "", "");
	m_resultLimit.marshall(rpc_resp, "resultLimit", "", "", "");
	m_ResultWindowStart.marshall(rpc_resp, "ResultWindowStart", "", "", "");
	m_ResultWindowCount.marshall(rpc_resp, "ResultWindowCount", "", "", "");
	if ((clientVer==-1.0 || clientVer>=3.05))
		m_IgnoreCache.marshall(rpc_resp, "IgnoreCache", "", "", "");
}


void CExecuteSQLRequest::copy(CExecuteSQLRequest &from)
{
	m_SqlText.copy(from.m_SqlText);
	m_UserName.copy(from.m_UserName);
	m_TargetCluster.copy(from.m_TargetCluster);
	m_AlternateClusters.copy(from.m_AlternateClusters);
	m_TargetQuerySet.copy(from.m_TargetQuerySet);
	m_SuppressResults.copy(from.m_SuppressResults);
	m_SuppressXmlSchema.copy(from.m_SuppressXmlSchema);
	m_Wait.copy(from.m_Wait);
	m_resultLimit.copy(from.m_resultLimit);
	m_ResultWindowStart.copy(from.m_ResultWindowStart);
	m_ResultWindowCount.copy(from.m_ResultWindowCount);
	m_IgnoreCache.copy(from.m_IgnoreCache);
}


void CExecuteSQLRequest::copy(IConstExecuteSQLRequest &ifrom)
{
	setSqlText(ifrom.getSqlText());
	setUserName(ifrom.getUserName());
	setTargetCluster(ifrom.getTargetCluster());
	setAlternateClusters(ifrom.getAlternateClusters());
	setTargetQuerySet(ifrom.getTargetQuerySet());
	setSuppressResults(ifrom.getSuppressResults());
	setSuppressXmlSchema(ifrom.getSuppressXmlSchema());
	setWait(ifrom.getWait());
	setResultLimit(ifrom.getResultLimit());
	setResultWindowStart(ifrom.getResultWindowStart());
	setResultWindowCount(ifrom.getResultWindowCount());
	setIgnoreCache(ifrom.getIgnoreCache());
}


void CExecuteSQLRequest::getAttributes(IProperties &attributes)
{
}


void CExecuteSQLRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	double clientVer = ctx ? ctx->getClientVersion() : -1;
	m_SqlText.toStr(ctx, buffer, "SqlText", "", true, "", "");
	m_UserName.toStr(ctx, buffer, "UserName", "", true, "", "");
	m_TargetCluster.toStr(ctx, buffer, "TargetCluster", "", true, "", "");
	if ((clientVer==-1.0 || clientVer>=3.04))
		m_AlternateClusters.toStr(ctx, buffer, "AlternateClusters", "AlternateCluster");
	m_TargetQuerySet.toStr(ctx, buffer, "TargetQuerySet", "", true, "", "");
	m_SuppressResults.toStr(ctx, buffer, "SuppressResults", "", true, "", "");
	m_SuppressXmlSchema.toStr(ctx, buffer, "SuppressXmlSchema", "", true, "", "");
	m_Wait.toStr(ctx, buffer, "Wait", "", true, "", "");
	m_resultLimit.toStr(ctx, buffer, "resultLimit", "", true, "", "");
	m_ResultWindowStart.toStr(ctx, buffer, "ResultWindowStart", "", true, "", "");
	m_ResultWindowCount.toStr(ctx, buffer, "ResultWindowCount", "", true, "", "");
	if ((clientVer==-1.0 || clientVer>=3.05))
		m_IgnoreCache.toStr(ctx, buffer, "IgnoreCache", "", true, "", "");
}


void CExecuteSQLRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CExecuteSQLRequest::serializer(IEspContext* ctx, IConstExecuteSQLRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<ExecuteSQLRequest>");
	double clientVer = ctx ? ctx->getClientVersion() : -1;
	// field SqlText
	{
		const char* s = src.getSqlText();
		if (s && *s)
		{
			buffer.append("<SqlText>");
			encodeUtf8XML(s,buffer);
			buffer.append("</SqlText>");
		}
	}
	// field UserName
	{
		const char* s = src.getUserName();
		if (s && *s)
		{
			buffer.append("<UserName>");
			encodeUtf8XML(s,buffer);
			buffer.append("</UserName>");
		}
	}
	// field TargetCluster
	{
		const char* s = src.getTargetCluster();
		if (s && *s)
		{
			buffer.append("<TargetCluster>");
			encodeUtf8XML(s,buffer);
			buffer.append("</TargetCluster>");
		}
	}
	// field AlternateClusters
	if ((clientVer==-1.0 || clientVer>=3.04))
	{
		StringArray& v = src.getAlternateClusters();
		if (v.length()>0)
			buffer.append("<AlternateClusters>");
		for (size32_t i=0;i<v.length();i++)
			buffer.appendf("<AlternateCluster>%s</AlternateCluster>",v.item(i));
		if (v.length()>0)
			buffer.append("</AlternateClusters>");
	}
	// field TargetQuerySet
	{
		const char* s = src.getTargetQuerySet();
		if (s && *s)
		{
			buffer.append("<TargetQuerySet>");
			encodeUtf8XML(s,buffer);
			buffer.append("</TargetQuerySet>");
		}
	}
	// field SuppressResults
	{
		bool b = src.getSuppressResults();
		if (b)
			buffer.appendf("<SuppressResults>1</SuppressResults>");
	}
	// field SuppressXmlSchema
	{
		bool b = src.getSuppressXmlSchema();
		if (b)
			buffer.appendf("<SuppressXmlSchema>1</SuppressXmlSchema>");
	}
	// field Wait
	{
		int n = src.getWait();
		if (n)
			buffer.appendf("<Wait>%d</Wait>", n);
	}
	// field resultLimit
	{
		int n = src.getResultLimit();
		if (n)
			buffer.appendf("<resultLimit>%d</resultLimit>", n);
	}
	// field ResultWindowStart
	{
		int n = src.getResultWindowStart();
		if (n)
			buffer.appendf("<ResultWindowStart>%d</ResultWindowStart>", n);
	}
	// field ResultWindowCount
	{
		int n = src.getResultWindowCount();
		if (n)
			buffer.appendf("<ResultWindowCount>%d</ResultWindowCount>", n);
	}
	// field IgnoreCache
	if ((clientVer==-1.0 || clientVer>=3.05))
	{
		bool b = src.getIgnoreCache();
		if (b)
			buffer.appendf("<IgnoreCache>1</IgnoreCache>");
	}
	if (keepRootTag)
		buffer.append("</ExecuteSQLRequest>");
}

bool CExecuteSQLRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_SqlText.unmarshall(rpc_request, "SqlText", basepath);
	hasValue |= m_UserName.unmarshall(rpc_request, "UserName", basepath);
	hasValue |= m_TargetCluster.unmarshall(rpc_request, "TargetCluster", basepath);
	hasValue |= m_AlternateClusters.unmarshall(rpc_request, "AlternateClusters", basepath);
	hasValue |= m_TargetQuerySet.unmarshall(rpc_request, "TargetQuerySet", basepath);
	hasValue |= m_SuppressResults.unmarshall(rpc_request, "SuppressResults", basepath);
	hasValue |= m_SuppressXmlSchema.unmarshall(rpc_request, "SuppressXmlSchema", basepath);
	hasValue |= m_Wait.unmarshall(rpc_request, "Wait", basepath);
	hasValue |= m_resultLimit.unmarshall(rpc_request, "resultLimit", basepath);
	hasValue |= m_ResultWindowStart.unmarshall(rpc_request, "ResultWindowStart", basepath);
	hasValue |= m_ResultWindowCount.unmarshall(rpc_request, "ResultWindowCount", basepath);
	hasValue |= m_IgnoreCache.unmarshall(rpc_request, "IgnoreCache", basepath);
	return hasValue;
}

bool CExecuteSQLRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_SqlText.unmarshall(ctx, soapval, "SqlText");
	hasValue |= m_UserName.unmarshall(ctx, soapval, "UserName");
	hasValue |= m_TargetCluster.unmarshall(ctx, soapval, "TargetCluster");
	hasValue |= m_AlternateClusters.unmarshall(ctx, soapval, "AlternateClusters");
	hasValue |= m_TargetQuerySet.unmarshall(ctx, soapval, "TargetQuerySet");
	hasValue |= m_SuppressResults.unmarshall(ctx, soapval, "SuppressResults");
	hasValue |= m_SuppressXmlSchema.unmarshall(ctx, soapval, "SuppressXmlSchema");
	hasValue |= m_Wait.unmarshall(ctx, soapval, "Wait");
	hasValue |= m_resultLimit.unmarshall(ctx, soapval, "resultLimit");
	hasValue |= m_ResultWindowStart.unmarshall(ctx, soapval, "ResultWindowStart");
	hasValue |= m_ResultWindowCount.unmarshall(ctx, soapval, "ResultWindowCount");
	hasValue |= m_IgnoreCache.unmarshall(ctx, soapval, "IgnoreCache");
	return hasValue;
}

bool CExecuteSQLRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_SqlText.unmarshall(ctx, params, attachments, "SqlText", basepath);
	hasValue |= m_UserName.unmarshall(ctx, params, attachments, "UserName", basepath);
	hasValue |= m_TargetCluster.unmarshall(ctx, params, attachments, "TargetCluster", basepath);
	hasValue |= m_AlternateClusters.unmarshall(ctx, params, attachments, "AlternateClusters", basepath);
	hasValue |= m_TargetQuerySet.unmarshall(ctx, params, attachments, "TargetQuerySet", basepath);
	hasValue |= m_SuppressResults.unmarshall(ctx, params, attachments, "SuppressResults", basepath);
	hasValue |= m_SuppressXmlSchema.unmarshall(ctx, params, attachments, "SuppressXmlSchema", basepath);
	hasValue |= m_Wait.unmarshall(ctx, params, attachments, "Wait", basepath);
	hasValue |= m_resultLimit.unmarshall(ctx, params, attachments, "resultLimit", basepath);
	hasValue |= m_ResultWindowStart.unmarshall(ctx, params, attachments, "ResultWindowStart", basepath);
	hasValue |= m_ResultWindowCount.unmarshall(ctx, params, attachments, "ResultWindowCount", basepath);
	hasValue |= m_IgnoreCache.unmarshall(ctx, params, attachments, "IgnoreCache", basepath);
	return hasValue;
}

const char * CExecuteSQLRequest::getSqlText() { return m_SqlText.query();}
const char * CExecuteSQLRequest::getUserName() { return m_UserName.query();}
const char * CExecuteSQLRequest::getTargetCluster() { return m_TargetCluster.query();}
StringArray & CExecuteSQLRequest::getAlternateClusters() { return (StringArray &) m_AlternateClusters; }
const char * CExecuteSQLRequest::getTargetQuerySet() { return m_TargetQuerySet.query();}
bool CExecuteSQLRequest::getSuppressResults() { return m_SuppressResults;}
bool CExecuteSQLRequest::getSuppressXmlSchema() { return m_SuppressXmlSchema;}
int CExecuteSQLRequest::getWait() { return m_Wait;}
int CExecuteSQLRequest::getResultLimit() { return m_resultLimit;}
int CExecuteSQLRequest::getResultWindowStart() { return m_ResultWindowStart;}
int CExecuteSQLRequest::getResultWindowCount() { return m_ResultWindowCount;}
bool CExecuteSQLRequest::getIgnoreCache() { return m_IgnoreCache;}
void CExecuteSQLRequest::setSqlText(const char * val){ m_SqlText.set(val); }
void CExecuteSQLRequest::setUserName(const char * val){ m_UserName.set(val); }
void CExecuteSQLRequest::setTargetCluster(const char * val){ m_TargetCluster.set(val); }
void CExecuteSQLRequest::setAlternateClusters(StringArray &val){ m_AlternateClusters->kill();  CloneArray(m_AlternateClusters.getValue(), val); }
void CExecuteSQLRequest::setTargetQuerySet(const char * val){ m_TargetQuerySet.set(val); }
void CExecuteSQLRequest::setSuppressResults(bool val){ m_SuppressResults=val; }
void CExecuteSQLRequest::setSuppressXmlSchema(bool val){ m_SuppressXmlSchema=val; }
void CExecuteSQLRequest::setWait(int val){ m_Wait=val; }
void CExecuteSQLRequest::setResultLimit(int val){ m_resultLimit=val; }
void CExecuteSQLRequest::setResultWindowStart(int val){ m_ResultWindowStart=val; }
void CExecuteSQLRequest::setResultWindowCount(int val){ m_ResultWindowCount=val; }
void CExecuteSQLRequest::setIgnoreCache(bool val){ m_IgnoreCache=val; }
extern "C"  IEspExecuteSQLRequest *createExecuteSQLRequest(const char *serv){return ((IEspExecuteSQLRequest *)new CExecuteSQLRequest(serv));}
extern "C"  IClientExecuteSQLRequest *createClientExecuteSQLRequest(const char *serv){return ((IClientExecuteSQLRequest *)new CExecuteSQLRequest(serv));}

//=======================================================
// class CExecuteSQLResponse Implementation
//=======================================================

CExecuteSQLResponse::CExecuteSQLResponse(const char *serviceName, IRpcMessageBinding *init)
	: m_ParentWuId(nilIgnore),m_Result(nilIgnore),m_Workunit(serviceName, nilIgnore),m_resultLimit(nilIgnore),m_ResultWindowStart(nilIgnore),m_ResultWindowCount(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ExecuteSQLResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CExecuteSQLResponse::CExecuteSQLResponse(const char *serviceName, const char *bc)
	: m_ParentWuId(nilIgnore),m_Result(nilIgnore),m_Workunit(serviceName, nilIgnore),m_resultLimit(nilIgnore),m_ResultWindowStart(nilIgnore),m_ResultWindowCount(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ExecuteSQLResponse");
}

CExecuteSQLResponse::CExecuteSQLResponse(const char *serviceName, IRpcMessage* rpcmsg)
	: m_ParentWuId(nilIgnore),m_Result(nilIgnore),m_Workunit(serviceName, nilIgnore),m_resultLimit(nilIgnore),m_ResultWindowStart(nilIgnore),m_ResultWindowCount(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ExecuteSQLResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CExecuteSQLResponse::CExecuteSQLResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_ParentWuId(nilIgnore),m_Result(nilIgnore),m_Workunit(serviceName, nilIgnore),m_resultLimit(nilIgnore),m_ResultWindowStart(nilIgnore),m_ResultWindowCount(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ExecuteSQLResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CExecuteSQLResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		schema.append("<xsd:element name=\"Exceptions\" type=\"tns:ArrayOfEspException\" minOccurs=\"0\" maxOccurs=\"1\"/>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"ParentWuId\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Result\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Workunit\" type=\"tns:ECLWorkunit\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"resultLimit\" type=\"xsd:int\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"ResultWindowStart\" type=\"xsd:unsignedInt\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"ResultWindowCount\" type=\"xsd:unsignedInt\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	if (!(flags & 0x10)  || (flags & 0x100))
	{
		CECLWorkunit::getXsdDefinition(context, request, schema, added);
	}
	return schema;
}

void CExecuteSQLResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CExecuteSQLResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
	if (!added.getValue("ECLWorkunit"))
	{
		added.setValue("ECLWorkunit",1);
		CECLWorkunit::getMapInfo(info,added);
	}
}

StringBuffer &CExecuteSQLResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("ParentWuId");
	form.appendf("  <tr><td><b>ParentWuId: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Result");
	form.appendf("  <tr><td><b>Result: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Workunit");
	form.append("<tr>").append("<td><b>Workunit: </b></td><td><hr/>");
	CECLWorkunit::getHtmlForm(context, request, serv, method, form, false, extfix.str());
	form.append("<hr/></td></tr>");
	extfix.clear();
	if (prefix && *prefix) extfix.append(prefix).append(".");
		extfix.append("resultLimit");
	form.appendf("  <tr><td><b>resultLimit: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix) extfix.append(prefix).append(".");
		extfix.append("ResultWindowStart");
	form.appendf("  <tr><td><b>ResultWindowStart: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix) extfix.append(prefix).append(".");
		extfix.append("ResultWindowCount");
	form.appendf("  <tr><td><b>ResultWindowCount: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CExecuteSQLResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CExecuteSQLResponse::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
		m_ParentWuId.marshall(rpc_resp, "ParentWuId", "", "", "");
		m_Result.marshall(rpc_resp, "Result", "", "", "");
		m_Workunit.marshall(rpc_resp, "Workunit", "", "", "");
		m_resultLimit.marshall(rpc_resp, "resultLimit", "", "", "");
		m_ResultWindowStart.marshall(rpc_resp, "ResultWindowStart", "", "", "");
		m_ResultWindowCount.marshall(rpc_resp, "ResultWindowCount", "", "", "");
	}
}


void CExecuteSQLResponse::copy(CExecuteSQLResponse &from)
{
	m_ParentWuId.copy(from.m_ParentWuId);
	m_Result.copy(from.m_Result);
	m_Workunit.copy(from.m_Workunit);
	m_resultLimit.copy(from.m_resultLimit);
	m_ResultWindowStart.copy(from.m_ResultWindowStart);
	m_ResultWindowCount.copy(from.m_ResultWindowCount);
}


void CExecuteSQLResponse::copy(IConstExecuteSQLResponse &ifrom)
{
	setParentWuId(ifrom.getParentWuId());
	setResult(ifrom.getResult());
	setWorkunit(ifrom.getWorkunit());
	setResultLimit(ifrom.getResultLimit());
	setResultWindowStart(ifrom.getResultWindowStart());
	setResultWindowCount(ifrom.getResultWindowCount());
}


void CExecuteSQLResponse::getAttributes(IProperties &attributes)
{
}


void CExecuteSQLResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
		m_ParentWuId.toStr(ctx, buffer, "ParentWuId", "", true, "", "");
		m_Result.toStr(ctx, buffer, "Result", "", true, "", "");
		m_Workunit.toStr(ctx, buffer, "Workunit", "", false, "", "");
		m_resultLimit.toStr(ctx, buffer, "resultLimit", "", true, "", "");
		m_ResultWindowStart.toStr(ctx, buffer, "ResultWindowStart", "", true, "", "");
		m_ResultWindowCount.toStr(ctx, buffer, "ResultWindowCount", "", true, "", "");
	}
}


void CExecuteSQLResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CExecuteSQLResponse::serializer(IEspContext* ctx, IConstExecuteSQLResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<ExecuteSQLResponse>");
	// field ParentWuId
	{
		const char* s = src.getParentWuId();
		if (s && *s)
		{
			buffer.append("<ParentWuId>");
			encodeUtf8XML(s,buffer);
			buffer.append("</ParentWuId>");
		}
	}
	// field Result
	{
		const char* s = src.getResult();
		if (s && *s)
		{
			buffer.append("<Result>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Result>");
		}
	}
	// field Workunit
	{
		StringBuffer tmp;
		CECLWorkunit::serializer(ctx,src.getWorkunit(), tmp, false);
		if (tmp.length()>0)
			buffer.appendf("<Workunit>%s</Workunit>",tmp.str());
	}
	// field resultLimit
	{
		int n = src.getResultLimit();
		if (n)
			buffer.appendf("<resultLimit>%d</resultLimit>", n);
	}
	// field ResultWindowStart
	{
		//*** default kind: TK_UNSIGNED; type=(null), name=ResultWindowStart
		buffer.append("<ResultWindowStart>");
		buffer.append(src.getResultWindowStart());
		buffer.append("</ResultWindowStart>");
	}
	// field ResultWindowCount
	{
		//*** default kind: TK_UNSIGNED; type=(null), name=ResultWindowCount
		buffer.append("<ResultWindowCount>");
		buffer.append(src.getResultWindowCount());
		buffer.append("</ResultWindowCount>");
	}
	if (keepRootTag)
		buffer.append("</ExecuteSQLResponse>");
}

bool CExecuteSQLResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
		hasValue |= m_ParentWuId.unmarshall(rpc_request, "ParentWuId", basepath);
		hasValue |= m_Result.unmarshall(rpc_request, "Result", basepath);
		hasValue |= m_Workunit.unmarshall(rpc_request, "Workunit", basepath);
		hasValue |= m_resultLimit.unmarshall(rpc_request, "resultLimit", basepath);
		hasValue |= m_ResultWindowStart.unmarshall(rpc_request, "ResultWindowStart", basepath);
		hasValue |= m_ResultWindowCount.unmarshall(rpc_request, "ResultWindowCount", basepath);
	}
	return hasValue;
}

bool CExecuteSQLResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_ParentWuId.unmarshall(ctx, soapval, "ParentWuId");
	hasValue |= m_Result.unmarshall(ctx, soapval, "Result");
	hasValue |= m_Workunit.unmarshall(ctx, soapval, "Workunit");
	hasValue |= m_resultLimit.unmarshall(ctx, soapval, "resultLimit");
	hasValue |= m_ResultWindowStart.unmarshall(ctx, soapval, "ResultWindowStart");
	hasValue |= m_ResultWindowCount.unmarshall(ctx, soapval, "ResultWindowCount");
	return hasValue;
}

bool CExecuteSQLResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_ParentWuId.unmarshall(ctx, params, attachments, "ParentWuId", basepath);
	hasValue |= m_Result.unmarshall(ctx, params, attachments, "Result", basepath);
	hasValue |= m_Workunit.unmarshall(ctx, params, attachments, "Workunit", basepath);
	hasValue |= m_resultLimit.unmarshall(ctx, params, attachments, "resultLimit", basepath);
	hasValue |= m_ResultWindowStart.unmarshall(ctx, params, attachments, "ResultWindowStart", basepath);
	hasValue |= m_ResultWindowCount.unmarshall(ctx, params, attachments, "ResultWindowCount", basepath);
	return hasValue;
}

const char * CExecuteSQLResponse::getParentWuId() { return m_ParentWuId.query();}
const char * CExecuteSQLResponse::getResult() { return m_Result.query();}
IConstECLWorkunit & CExecuteSQLResponse::getWorkunit() { return (IConstECLWorkunit &) m_Workunit.getValue();}
int CExecuteSQLResponse::getResultLimit() { return m_resultLimit;}
unsigned int CExecuteSQLResponse::getResultWindowStart() { return m_ResultWindowStart;}
unsigned int CExecuteSQLResponse::getResultWindowCount() { return m_ResultWindowCount;}
void CExecuteSQLResponse::setParentWuId(const char * val){ m_ParentWuId.set(val); }
void CExecuteSQLResponse::setResult(const char * val){ m_Result.set(val); }
IEspECLWorkunit & CExecuteSQLResponse::updateWorkunit(){ return (IEspECLWorkunit &) m_Workunit.getValue(); }
void CExecuteSQLResponse::setWorkunit(IConstECLWorkunit &ifrom){ m_Workunit.copy(ifrom); }
void CExecuteSQLResponse::setResultLimit(int val){ m_resultLimit=val; }
void CExecuteSQLResponse::setResultWindowStart(unsigned int val){ m_ResultWindowStart=val; }
void CExecuteSQLResponse::setResultWindowCount(unsigned int val){ m_ResultWindowCount=val; }
extern "C"  IEspExecuteSQLResponse *createExecuteSQLResponse(const char *serv){return ((IEspExecuteSQLResponse *)new CExecuteSQLResponse(serv));}
extern "C"  IClientExecuteSQLResponse *createClientExecuteSQLResponse(const char *serv){return ((IClientExecuteSQLResponse *)new CExecuteSQLResponse(serv));}

//=======================================================
// class CExecutePreparedSQLRequest Implementation
//=======================================================

CExecutePreparedSQLRequest::CExecutePreparedSQLRequest(const char *serviceName, IRpcMessageBinding *init)
	: m_WuId(nilIgnore),m_UserName(nilIgnore),m_TargetCluster(nilIgnore),m_SuppressResults(nilIgnore),m_SuppressXmlSchema(nilIgnore),m_Wait(-1, nilIgnore,false),m_ResultWindowStart(0, nilIgnore,false),m_ResultWindowCount(0, nilIgnore,false),m_Variables(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ExecutePreparedSQLRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CExecutePreparedSQLRequest::CExecutePreparedSQLRequest(const char *serviceName, const char *bc)
	: m_WuId(nilIgnore),m_UserName(nilIgnore),m_TargetCluster(nilIgnore),m_SuppressResults(nilIgnore),m_SuppressXmlSchema(nilIgnore),m_Wait(-1, nilIgnore,false),m_ResultWindowStart(0, nilIgnore,false),m_ResultWindowCount(0, nilIgnore,false),m_Variables(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ExecutePreparedSQLRequest");
}

CExecutePreparedSQLRequest::CExecutePreparedSQLRequest(const char *serviceName, IRpcMessage* rpcmsg)
	: m_WuId(nilIgnore),m_UserName(nilIgnore),m_TargetCluster(nilIgnore),m_SuppressResults(nilIgnore),m_SuppressXmlSchema(nilIgnore),m_Wait(-1, nilIgnore,false),m_ResultWindowStart(0, nilIgnore,false),m_ResultWindowCount(0, nilIgnore,false),m_Variables(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ExecutePreparedSQLRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CExecutePreparedSQLRequest::CExecutePreparedSQLRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_WuId(nilIgnore),m_UserName(nilIgnore),m_TargetCluster(nilIgnore),m_SuppressResults(nilIgnore),m_SuppressXmlSchema(nilIgnore),m_Wait(-1, nilIgnore,false),m_ResultWindowStart(0, nilIgnore,false),m_ResultWindowCount(0, nilIgnore,false),m_Variables(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ExecutePreparedSQLRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CExecutePreparedSQLRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"WuId\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"UserName\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"TargetCluster\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"SuppressResults\" type=\"xsd:boolean\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" default=\"1\" name=\"SuppressXmlSchema\" type=\"xsd:boolean\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" default=\"-1\" name=\"Wait\" type=\"xsd:int\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"ResultWindowStart\" type=\"xsd:int\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"ResultWindowCount\" type=\"xsd:int\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Variables\" type=\"tns:ArrayOfNamedValue\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	if (!(flags & 0x10)  || (flags & 0x100))
	{
		CNamedValue::getXsdDefinition(context, request, schema, added);
	}
	if (added.getValue("NamedValue") && added.getValue("ArrayOfNamedValue")==NULL) {
		schema.append("<xsd:complexType name=\"ArrayOfNamedValue\">\n");
		schema.append("<xsd:sequence>\n");
		schema.append("<xsd:element minOccurs=\"0\" maxOccurs=\"unbounded\" name=\"NamedValue\" type=\"tns:NamedValue\"/>\n");
		schema.append("</xsd:sequence>\n");
		schema.append("</xsd:complexType>\n");
		added.setValue("ArrayOfNamedValue",1);
	}
	return schema;
}

void CExecutePreparedSQLRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CExecutePreparedSQLRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
	if (!added.getValue("NamedValue"))
	{
		added.setValue("NamedValue",1);
		CNamedValue::getMapInfo(info,added);
	}
}

StringBuffer &CExecutePreparedSQLRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("WuId");
	form.appendf("  <tr><td><b>WuId: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("UserName");
	form.appendf("  <tr><td><b>UserName: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("TargetCluster");
	form.appendf("  <tr><td><b>TargetCluster: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("SuppressResults");
	
	form.appendf("  <tr><td><b>SuppressResults? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("SuppressXmlSchema");
	
	form.appendf("  <tr><td><b>SuppressXmlSchema? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\" checked=\"1\" /></td></tr>\n", extfix.str());
	extfix.clear();
	if (prefix && *prefix) extfix.append(prefix).append(".");
		extfix.append("Wait");
	form.appendf("  <tr><td><b>Wait: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"	 value=\"-1\"/>", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix) extfix.append(prefix).append(".");
		extfix.append("ResultWindowStart");
	form.appendf("  <tr><td><b>ResultWindowStart: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix) extfix.append(prefix).append(".");
		extfix.append("ResultWindowCount");
	form.appendf("  <tr><td><b>ResultWindowCount: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Variables");
	form.appendf("<tr><td><b>Variables: </b></td><td>");
	form.appendf("<table><tr><td><textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea></td>", extfix.str());
	form.append("</tr></table>");
	form.append("</td></tr>");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CExecutePreparedSQLRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CExecutePreparedSQLRequest::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_WuId.marshall(rpc_resp, "WuId", "", "", "");
	m_UserName.marshall(rpc_resp, "UserName", "", "", "");
	m_TargetCluster.marshall(rpc_resp, "TargetCluster", "", "", "");
	m_SuppressResults.marshall(rpc_resp, "SuppressResults", "", "", "");
	m_SuppressXmlSchema.marshall(rpc_resp, "SuppressXmlSchema", "", "", "");
	m_Wait.marshall(rpc_resp, "Wait", "", "", "");
	m_ResultWindowStart.marshall(rpc_resp, "ResultWindowStart", "", "", "");
	m_ResultWindowCount.marshall(rpc_resp, "ResultWindowCount", "", "", "");
	m_Variables.marshall(rpc_resp, "Variables", "NamedValue");
}


void CExecutePreparedSQLRequest::copy(CExecutePreparedSQLRequest &from)
{
	m_WuId.copy(from.m_WuId);
	m_UserName.copy(from.m_UserName);
	m_TargetCluster.copy(from.m_TargetCluster);
	m_SuppressResults.copy(from.m_SuppressResults);
	m_SuppressXmlSchema.copy(from.m_SuppressXmlSchema);
	m_Wait.copy(from.m_Wait);
	m_ResultWindowStart.copy(from.m_ResultWindowStart);
	m_ResultWindowCount.copy(from.m_ResultWindowCount);
	m_Variables.copy(from.m_Variables);
}


void CExecutePreparedSQLRequest::copy(IConstExecutePreparedSQLRequest &ifrom)
{
	setWuId(ifrom.getWuId());
	setUserName(ifrom.getUserName());
	setTargetCluster(ifrom.getTargetCluster());
	setSuppressResults(ifrom.getSuppressResults());
	setSuppressXmlSchema(ifrom.getSuppressXmlSchema());
	setWait(ifrom.getWait());
	setResultWindowStart(ifrom.getResultWindowStart());
	setResultWindowCount(ifrom.getResultWindowCount());
	setVariables(ifrom.getVariables());
}


void CExecutePreparedSQLRequest::getAttributes(IProperties &attributes)
{
}


void CExecutePreparedSQLRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_WuId.toStr(ctx, buffer, "WuId", "", true, "", "");
	m_UserName.toStr(ctx, buffer, "UserName", "", true, "", "");
	m_TargetCluster.toStr(ctx, buffer, "TargetCluster", "", true, "", "");
	m_SuppressResults.toStr(ctx, buffer, "SuppressResults", "", true, "", "");
	m_SuppressXmlSchema.toStr(ctx, buffer, "SuppressXmlSchema", "", true, "", "");
	m_Wait.toStr(ctx, buffer, "Wait", "", true, "", "");
	m_ResultWindowStart.toStr(ctx, buffer, "ResultWindowStart", "", true, "", "");
	m_ResultWindowCount.toStr(ctx, buffer, "ResultWindowCount", "", true, "", "");
	m_Variables.toStr(ctx, buffer, "Variables", "NamedValue");
}


void CExecutePreparedSQLRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CExecutePreparedSQLRequest::serializer(IEspContext* ctx, IConstExecutePreparedSQLRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<ExecutePreparedSQLRequest>");
	// field WuId
	{
		const char* s = src.getWuId();
		if (s && *s)
		{
			buffer.append("<WuId>");
			encodeUtf8XML(s,buffer);
			buffer.append("</WuId>");
		}
	}
	// field UserName
	{
		const char* s = src.getUserName();
		if (s && *s)
		{
			buffer.append("<UserName>");
			encodeUtf8XML(s,buffer);
			buffer.append("</UserName>");
		}
	}
	// field TargetCluster
	{
		const char* s = src.getTargetCluster();
		if (s && *s)
		{
			buffer.append("<TargetCluster>");
			encodeUtf8XML(s,buffer);
			buffer.append("</TargetCluster>");
		}
	}
	// field SuppressResults
	{
		bool b = src.getSuppressResults();
		if (b)
			buffer.appendf("<SuppressResults>1</SuppressResults>");
	}
	// field SuppressXmlSchema
	{
		bool b = src.getSuppressXmlSchema();
		if (b)
			buffer.appendf("<SuppressXmlSchema>1</SuppressXmlSchema>");
	}
	// field Wait
	{
		int n = src.getWait();
		if (n)
			buffer.appendf("<Wait>%d</Wait>", n);
	}
	// field ResultWindowStart
	{
		int n = src.getResultWindowStart();
		if (n)
			buffer.appendf("<ResultWindowStart>%d</ResultWindowStart>", n);
	}
	// field ResultWindowCount
	{
		int n = src.getResultWindowCount();
		if (n)
			buffer.appendf("<ResultWindowCount>%d</ResultWindowCount>", n);
	}
	// field Variables
	{
		IArrayOf<IConstNamedValue>& v = src.getVariables();
		int size = v.length();
		if (size>0)
			buffer.append("<Variables>");
		for (int i=0;i<size;i++)
		{
			buffer.append("<Item>");
			CNamedValue::serializer(ctx,v.item(i),buffer,false);
			buffer.append("</Item>");
		}
		if (size>0)
			buffer.append("</Variables>");
	}
	if (keepRootTag)
		buffer.append("</ExecutePreparedSQLRequest>");
}

bool CExecutePreparedSQLRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_WuId.unmarshall(rpc_request, "WuId", basepath);
	hasValue |= m_UserName.unmarshall(rpc_request, "UserName", basepath);
	hasValue |= m_TargetCluster.unmarshall(rpc_request, "TargetCluster", basepath);
	hasValue |= m_SuppressResults.unmarshall(rpc_request, "SuppressResults", basepath);
	hasValue |= m_SuppressXmlSchema.unmarshall(rpc_request, "SuppressXmlSchema", basepath);
	hasValue |= m_Wait.unmarshall(rpc_request, "Wait", basepath);
	hasValue |= m_ResultWindowStart.unmarshall(rpc_request, "ResultWindowStart", basepath);
	hasValue |= m_ResultWindowCount.unmarshall(rpc_request, "ResultWindowCount", basepath);
	hasValue |= m_Variables.unmarshall(rpc_request, "Variables", basepath);
	return hasValue;
}

bool CExecutePreparedSQLRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_WuId.unmarshall(ctx, soapval, "WuId");
	hasValue |= m_UserName.unmarshall(ctx, soapval, "UserName");
	hasValue |= m_TargetCluster.unmarshall(ctx, soapval, "TargetCluster");
	hasValue |= m_SuppressResults.unmarshall(ctx, soapval, "SuppressResults");
	hasValue |= m_SuppressXmlSchema.unmarshall(ctx, soapval, "SuppressXmlSchema");
	hasValue |= m_Wait.unmarshall(ctx, soapval, "Wait");
	hasValue |= m_ResultWindowStart.unmarshall(ctx, soapval, "ResultWindowStart");
	hasValue |= m_ResultWindowCount.unmarshall(ctx, soapval, "ResultWindowCount");
	hasValue |= m_Variables.unmarshall(ctx, soapval, "Variables");
	return hasValue;
}

bool CExecutePreparedSQLRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_WuId.unmarshall(ctx, params, attachments, "WuId", basepath);
	hasValue |= m_UserName.unmarshall(ctx, params, attachments, "UserName", basepath);
	hasValue |= m_TargetCluster.unmarshall(ctx, params, attachments, "TargetCluster", basepath);
	hasValue |= m_SuppressResults.unmarshall(ctx, params, attachments, "SuppressResults", basepath);
	hasValue |= m_SuppressXmlSchema.unmarshall(ctx, params, attachments, "SuppressXmlSchema", basepath);
	hasValue |= m_Wait.unmarshall(ctx, params, attachments, "Wait", basepath);
	hasValue |= m_ResultWindowStart.unmarshall(ctx, params, attachments, "ResultWindowStart", basepath);
	hasValue |= m_ResultWindowCount.unmarshall(ctx, params, attachments, "ResultWindowCount", basepath);
	hasValue |= m_Variables.unmarshall(ctx, params, attachments, "Variables", basepath);
	return hasValue;
}

const char * CExecutePreparedSQLRequest::getWuId() { return m_WuId.query();}
const char * CExecutePreparedSQLRequest::getUserName() { return m_UserName.query();}
const char * CExecutePreparedSQLRequest::getTargetCluster() { return m_TargetCluster.query();}
bool CExecutePreparedSQLRequest::getSuppressResults() { return m_SuppressResults;}
bool CExecutePreparedSQLRequest::getSuppressXmlSchema() { return m_SuppressXmlSchema;}
int CExecutePreparedSQLRequest::getWait() { return m_Wait;}
int CExecutePreparedSQLRequest::getResultWindowStart() { return m_ResultWindowStart;}
int CExecutePreparedSQLRequest::getResultWindowCount() { return m_ResultWindowCount;}
IArrayOf<IConstNamedValue> & CExecutePreparedSQLRequest::getVariables() { return (IArrayOf<IConstNamedValue> &) m_Variables; }
void CExecutePreparedSQLRequest::setWuId(const char * val){ m_WuId.set(val); }
void CExecutePreparedSQLRequest::setUserName(const char * val){ m_UserName.set(val); }
void CExecutePreparedSQLRequest::setTargetCluster(const char * val){ m_TargetCluster.set(val); }
void CExecutePreparedSQLRequest::setSuppressResults(bool val){ m_SuppressResults=val; }
void CExecutePreparedSQLRequest::setSuppressXmlSchema(bool val){ m_SuppressXmlSchema=val; }
void CExecutePreparedSQLRequest::setWait(int val){ m_Wait=val; }
void CExecutePreparedSQLRequest::setResultWindowStart(int val){ m_ResultWindowStart=val; }
void CExecutePreparedSQLRequest::setResultWindowCount(int val){ m_ResultWindowCount=val; }
void CExecutePreparedSQLRequest::setVariables(IArrayOf<IEspNamedValue> &val)
{
	m_Variables->kill();
	IArrayOf<IConstNamedValue> &target = m_Variables.getValue();
	ForEachItemIn(idx, val)
	{
		IEspNamedValue &item = (val).item(idx);
		item.Link();
		target.append(item);
	}
}
void CExecutePreparedSQLRequest::setVariables(IArrayOf<IConstNamedValue> &val)
{
	m_Variables->kill();
	IArrayOf<IConstNamedValue> &target = m_Variables.getValue();
	ForEachItemIn(idx, val)
	{
		IConstNamedValue &item = val.item(idx);
		item.Link();
		target.append(item);
	}
}
extern "C"  IEspExecutePreparedSQLRequest *createExecutePreparedSQLRequest(const char *serv){return ((IEspExecutePreparedSQLRequest *)new CExecutePreparedSQLRequest(serv));}
extern "C"  IClientExecutePreparedSQLRequest *createClientExecutePreparedSQLRequest(const char *serv){return ((IClientExecutePreparedSQLRequest *)new CExecutePreparedSQLRequest(serv));}

//=======================================================
// class CExecutePreparedSQLResponse Implementation
//=======================================================

CExecutePreparedSQLResponse::CExecutePreparedSQLResponse(const char *serviceName, IRpcMessageBinding *init)
	: m_ParentWuId(nilIgnore),m_Result(nilIgnore),m_ResultWindowStart(nilIgnore),m_ResultWindowCount(nilIgnore),m_Workunit(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ExecutePreparedSQLResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CExecutePreparedSQLResponse::CExecutePreparedSQLResponse(const char *serviceName, const char *bc)
	: m_ParentWuId(nilIgnore),m_Result(nilIgnore),m_ResultWindowStart(nilIgnore),m_ResultWindowCount(nilIgnore),m_Workunit(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ExecutePreparedSQLResponse");
}

CExecutePreparedSQLResponse::CExecutePreparedSQLResponse(const char *serviceName, IRpcMessage* rpcmsg)
	: m_ParentWuId(nilIgnore),m_Result(nilIgnore),m_ResultWindowStart(nilIgnore),m_ResultWindowCount(nilIgnore),m_Workunit(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ExecutePreparedSQLResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CExecutePreparedSQLResponse::CExecutePreparedSQLResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_ParentWuId(nilIgnore),m_Result(nilIgnore),m_ResultWindowStart(nilIgnore),m_ResultWindowCount(nilIgnore),m_Workunit(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ExecutePreparedSQLResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CExecutePreparedSQLResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		schema.append("<xsd:element name=\"Exceptions\" type=\"tns:ArrayOfEspException\" minOccurs=\"0\" maxOccurs=\"1\"/>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"ParentWuId\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Result\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"ResultWindowStart\" type=\"xsd:unsignedInt\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"ResultWindowCount\" type=\"xsd:unsignedInt\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Workunit\" type=\"tns:ECLWorkunit\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	if (!(flags & 0x10)  || (flags & 0x100))
	{
		CECLWorkunit::getXsdDefinition(context, request, schema, added);
	}
	return schema;
}

void CExecutePreparedSQLResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CExecutePreparedSQLResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
	if (!added.getValue("ECLWorkunit"))
	{
		added.setValue("ECLWorkunit",1);
		CECLWorkunit::getMapInfo(info,added);
	}
}

StringBuffer &CExecutePreparedSQLResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("ParentWuId");
	form.appendf("  <tr><td><b>ParentWuId: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Result");
	form.appendf("  <tr><td><b>Result: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix) extfix.append(prefix).append(".");
		extfix.append("ResultWindowStart");
	form.appendf("  <tr><td><b>ResultWindowStart: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix) extfix.append(prefix).append(".");
		extfix.append("ResultWindowCount");
	form.appendf("  <tr><td><b>ResultWindowCount: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Workunit");
	form.append("<tr>").append("<td><b>Workunit: </b></td><td><hr/>");
	CECLWorkunit::getHtmlForm(context, request, serv, method, form, false, extfix.str());
	form.append("<hr/></td></tr>");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CExecutePreparedSQLResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CExecutePreparedSQLResponse::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
		m_ParentWuId.marshall(rpc_resp, "ParentWuId", "", "", "");
		m_Result.marshall(rpc_resp, "Result", "", "", "");
		m_ResultWindowStart.marshall(rpc_resp, "ResultWindowStart", "", "", "");
		m_ResultWindowCount.marshall(rpc_resp, "ResultWindowCount", "", "", "");
		m_Workunit.marshall(rpc_resp, "Workunit", "", "", "");
	}
}


void CExecutePreparedSQLResponse::copy(CExecutePreparedSQLResponse &from)
{
	m_ParentWuId.copy(from.m_ParentWuId);
	m_Result.copy(from.m_Result);
	m_ResultWindowStart.copy(from.m_ResultWindowStart);
	m_ResultWindowCount.copy(from.m_ResultWindowCount);
	m_Workunit.copy(from.m_Workunit);
}


void CExecutePreparedSQLResponse::copy(IConstExecutePreparedSQLResponse &ifrom)
{
	setParentWuId(ifrom.getParentWuId());
	setResult(ifrom.getResult());
	setResultWindowStart(ifrom.getResultWindowStart());
	setResultWindowCount(ifrom.getResultWindowCount());
	setWorkunit(ifrom.getWorkunit());
}


void CExecutePreparedSQLResponse::getAttributes(IProperties &attributes)
{
}


void CExecutePreparedSQLResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
		m_ParentWuId.toStr(ctx, buffer, "ParentWuId", "", true, "", "");
		m_Result.toStr(ctx, buffer, "Result", "", true, "", "");
		m_ResultWindowStart.toStr(ctx, buffer, "ResultWindowStart", "", true, "", "");
		m_ResultWindowCount.toStr(ctx, buffer, "ResultWindowCount", "", true, "", "");
		m_Workunit.toStr(ctx, buffer, "Workunit", "", false, "", "");
	}
}


void CExecutePreparedSQLResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CExecutePreparedSQLResponse::serializer(IEspContext* ctx, IConstExecutePreparedSQLResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<ExecutePreparedSQLResponse>");
	// field ParentWuId
	{
		const char* s = src.getParentWuId();
		if (s && *s)
		{
			buffer.append("<ParentWuId>");
			encodeUtf8XML(s,buffer);
			buffer.append("</ParentWuId>");
		}
	}
	// field Result
	{
		const char* s = src.getResult();
		if (s && *s)
		{
			buffer.append("<Result>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Result>");
		}
	}
	// field ResultWindowStart
	{
		//*** default kind: TK_UNSIGNED; type=(null), name=ResultWindowStart
		buffer.append("<ResultWindowStart>");
		buffer.append(src.getResultWindowStart());
		buffer.append("</ResultWindowStart>");
	}
	// field ResultWindowCount
	{
		//*** default kind: TK_UNSIGNED; type=(null), name=ResultWindowCount
		buffer.append("<ResultWindowCount>");
		buffer.append(src.getResultWindowCount());
		buffer.append("</ResultWindowCount>");
	}
	// field Workunit
	{
		StringBuffer tmp;
		CECLWorkunit::serializer(ctx,src.getWorkunit(), tmp, false);
		if (tmp.length()>0)
			buffer.appendf("<Workunit>%s</Workunit>",tmp.str());
	}
	if (keepRootTag)
		buffer.append("</ExecutePreparedSQLResponse>");
}

bool CExecutePreparedSQLResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
		hasValue |= m_ParentWuId.unmarshall(rpc_request, "ParentWuId", basepath);
		hasValue |= m_Result.unmarshall(rpc_request, "Result", basepath);
		hasValue |= m_ResultWindowStart.unmarshall(rpc_request, "ResultWindowStart", basepath);
		hasValue |= m_ResultWindowCount.unmarshall(rpc_request, "ResultWindowCount", basepath);
		hasValue |= m_Workunit.unmarshall(rpc_request, "Workunit", basepath);
	}
	return hasValue;
}

bool CExecutePreparedSQLResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_ParentWuId.unmarshall(ctx, soapval, "ParentWuId");
	hasValue |= m_Result.unmarshall(ctx, soapval, "Result");
	hasValue |= m_ResultWindowStart.unmarshall(ctx, soapval, "ResultWindowStart");
	hasValue |= m_ResultWindowCount.unmarshall(ctx, soapval, "ResultWindowCount");
	hasValue |= m_Workunit.unmarshall(ctx, soapval, "Workunit");
	return hasValue;
}

bool CExecutePreparedSQLResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_ParentWuId.unmarshall(ctx, params, attachments, "ParentWuId", basepath);
	hasValue |= m_Result.unmarshall(ctx, params, attachments, "Result", basepath);
	hasValue |= m_ResultWindowStart.unmarshall(ctx, params, attachments, "ResultWindowStart", basepath);
	hasValue |= m_ResultWindowCount.unmarshall(ctx, params, attachments, "ResultWindowCount", basepath);
	hasValue |= m_Workunit.unmarshall(ctx, params, attachments, "Workunit", basepath);
	return hasValue;
}

const char * CExecutePreparedSQLResponse::getParentWuId() { return m_ParentWuId.query();}
const char * CExecutePreparedSQLResponse::getResult() { return m_Result.query();}
unsigned int CExecutePreparedSQLResponse::getResultWindowStart() { return m_ResultWindowStart;}
unsigned int CExecutePreparedSQLResponse::getResultWindowCount() { return m_ResultWindowCount;}
IConstECLWorkunit & CExecutePreparedSQLResponse::getWorkunit() { return (IConstECLWorkunit &) m_Workunit.getValue();}
void CExecutePreparedSQLResponse::setParentWuId(const char * val){ m_ParentWuId.set(val); }
void CExecutePreparedSQLResponse::setResult(const char * val){ m_Result.set(val); }
void CExecutePreparedSQLResponse::setResultWindowStart(unsigned int val){ m_ResultWindowStart=val; }
void CExecutePreparedSQLResponse::setResultWindowCount(unsigned int val){ m_ResultWindowCount=val; }
IEspECLWorkunit & CExecutePreparedSQLResponse::updateWorkunit(){ return (IEspECLWorkunit &) m_Workunit.getValue(); }
void CExecutePreparedSQLResponse::setWorkunit(IConstECLWorkunit &ifrom){ m_Workunit.copy(ifrom); }
extern "C"  IEspExecutePreparedSQLResponse *createExecutePreparedSQLResponse(const char *serv){return ((IEspExecutePreparedSQLResponse *)new CExecutePreparedSQLResponse(serv));}
extern "C"  IClientExecutePreparedSQLResponse *createClientExecutePreparedSQLResponse(const char *serv){return ((IClientExecutePreparedSQLResponse *)new CExecutePreparedSQLResponse(serv));}

//=======================================================
// class CGetDBSystemInfoRequest Implementation
//=======================================================

CGetDBSystemInfoRequest::CGetDBSystemInfoRequest(const char *serviceName, IRpcMessageBinding *init)
	: m_IncludeAll(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetDBSystemInfoRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CGetDBSystemInfoRequest::CGetDBSystemInfoRequest(const char *serviceName, const char *bc)
	: m_IncludeAll(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetDBSystemInfoRequest");
}

CGetDBSystemInfoRequest::CGetDBSystemInfoRequest(const char *serviceName, IRpcMessage* rpcmsg)
	: m_IncludeAll(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetDBSystemInfoRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CGetDBSystemInfoRequest::CGetDBSystemInfoRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_IncludeAll(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetDBSystemInfoRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CGetDBSystemInfoRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" default=\"1\" name=\"IncludeAll\" type=\"xsd:boolean\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CGetDBSystemInfoRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CGetDBSystemInfoRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CGetDBSystemInfoRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("IncludeAll");
	
	form.appendf("  <tr><td><b>IncludeAll? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\" checked=\"1\" /></td></tr>\n", extfix.str());
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CGetDBSystemInfoRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CGetDBSystemInfoRequest::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_IncludeAll.marshall(rpc_resp, "IncludeAll", "", "", "");
}


void CGetDBSystemInfoRequest::copy(CGetDBSystemInfoRequest &from)
{
	m_IncludeAll.copy(from.m_IncludeAll);
}


void CGetDBSystemInfoRequest::copy(IConstGetDBSystemInfoRequest &ifrom)
{
	setIncludeAll(ifrom.getIncludeAll());
}


void CGetDBSystemInfoRequest::getAttributes(IProperties &attributes)
{
}


void CGetDBSystemInfoRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_IncludeAll.toStr(ctx, buffer, "IncludeAll", "", true, "", "");
}


void CGetDBSystemInfoRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CGetDBSystemInfoRequest::serializer(IEspContext* ctx, IConstGetDBSystemInfoRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<GetDBSystemInfoRequest>");
	// field IncludeAll
	{
		bool b = src.getIncludeAll();
		if (b)
			buffer.appendf("<IncludeAll>1</IncludeAll>");
	}
	if (keepRootTag)
		buffer.append("</GetDBSystemInfoRequest>");
}

bool CGetDBSystemInfoRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_IncludeAll.unmarshall(rpc_request, "IncludeAll", basepath);
	return hasValue;
}

bool CGetDBSystemInfoRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_IncludeAll.unmarshall(ctx, soapval, "IncludeAll");
	return hasValue;
}

bool CGetDBSystemInfoRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_IncludeAll.unmarshall(ctx, params, attachments, "IncludeAll", basepath);
	return hasValue;
}

bool CGetDBSystemInfoRequest::getIncludeAll() { return m_IncludeAll;}
void CGetDBSystemInfoRequest::setIncludeAll(bool val){ m_IncludeAll=val; }
extern "C"  IEspGetDBSystemInfoRequest *createGetDBSystemInfoRequest(const char *serv){return ((IEspGetDBSystemInfoRequest *)new CGetDBSystemInfoRequest(serv));}
extern "C"  IClientGetDBSystemInfoRequest *createClientGetDBSystemInfoRequest(const char *serv){return ((IClientGetDBSystemInfoRequest *)new CGetDBSystemInfoRequest(serv));}

//=======================================================
// class CGetDBSystemInfoResponse Implementation
//=======================================================

CGetDBSystemInfoResponse::CGetDBSystemInfoResponse(const char *serviceName, IRpcMessageBinding *init)
	: m_Name(nilIgnore),m_FullVersion(nilIgnore),m_Major(nilIgnore),m_Minor(nilIgnore),m_Point(nilIgnore),m_Project(nilIgnore),m_Maturity(nilIgnore),m_WsSQLFullVersion(nilIgnore),m_WsSQLMajor(nilIgnore),m_WsSQLMinor(nilIgnore),m_WsSQLPoint(nilIgnore),m_WsSQLProject(nilIgnore),m_WsSQLMaturity(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetDBSystemInfoResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CGetDBSystemInfoResponse::CGetDBSystemInfoResponse(const char *serviceName, const char *bc)
	: m_Name(nilIgnore),m_FullVersion(nilIgnore),m_Major(nilIgnore),m_Minor(nilIgnore),m_Point(nilIgnore),m_Project(nilIgnore),m_Maturity(nilIgnore),m_WsSQLFullVersion(nilIgnore),m_WsSQLMajor(nilIgnore),m_WsSQLMinor(nilIgnore),m_WsSQLPoint(nilIgnore),m_WsSQLProject(nilIgnore),m_WsSQLMaturity(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetDBSystemInfoResponse");
}

CGetDBSystemInfoResponse::CGetDBSystemInfoResponse(const char *serviceName, IRpcMessage* rpcmsg)
	: m_Name(nilIgnore),m_FullVersion(nilIgnore),m_Major(nilIgnore),m_Minor(nilIgnore),m_Point(nilIgnore),m_Project(nilIgnore),m_Maturity(nilIgnore),m_WsSQLFullVersion(nilIgnore),m_WsSQLMajor(nilIgnore),m_WsSQLMinor(nilIgnore),m_WsSQLPoint(nilIgnore),m_WsSQLProject(nilIgnore),m_WsSQLMaturity(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetDBSystemInfoResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CGetDBSystemInfoResponse::CGetDBSystemInfoResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_Name(nilIgnore),m_FullVersion(nilIgnore),m_Major(nilIgnore),m_Minor(nilIgnore),m_Point(nilIgnore),m_Project(nilIgnore),m_Maturity(nilIgnore),m_WsSQLFullVersion(nilIgnore),m_WsSQLMajor(nilIgnore),m_WsSQLMinor(nilIgnore),m_WsSQLPoint(nilIgnore),m_WsSQLProject(nilIgnore),m_WsSQLMaturity(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetDBSystemInfoResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CGetDBSystemInfoResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		schema.append("<xsd:element name=\"Exceptions\" type=\"tns:ArrayOfEspException\" minOccurs=\"0\" maxOccurs=\"1\"/>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Name\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"FullVersion\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Major\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Minor\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Point\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Project\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Maturity\" type=\"xsd:string\"/>\n");
		if (!context.suppressed("GetDBSystemInfoResponse","WsSQLFullVersion")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"WsSQLFullVersion\" type=\"xsd:string\"/>\n");
		}
		if (!context.suppressed("GetDBSystemInfoResponse","WsSQLMajor")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"WsSQLMajor\" type=\"xsd:string\"/>\n");
		}
		if (!context.suppressed("GetDBSystemInfoResponse","WsSQLMinor")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"WsSQLMinor\" type=\"xsd:string\"/>\n");
		}
		if (!context.suppressed("GetDBSystemInfoResponse","WsSQLPoint")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"WsSQLPoint\" type=\"xsd:string\"/>\n");
		}
		if (!context.suppressed("GetDBSystemInfoResponse","WsSQLProject")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"WsSQLProject\" type=\"xsd:string\"/>\n");
		}
		if (!context.suppressed("GetDBSystemInfoResponse","WsSQLMaturity")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"WsSQLMaturity\" type=\"xsd:string\"/>\n");
		}
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CGetDBSystemInfoResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CGetDBSystemInfoResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
	info.addMinVersion("GetDBSystemInfoResponse","WsSQLFullVersion",3.01);
	info.addMinVersion("GetDBSystemInfoResponse","WsSQLMajor",3.01);
	info.addMinVersion("GetDBSystemInfoResponse","WsSQLMinor",3.01);
	info.addMinVersion("GetDBSystemInfoResponse","WsSQLPoint",3.01);
	info.addMinVersion("GetDBSystemInfoResponse","WsSQLProject",3.01);
	info.addMinVersion("GetDBSystemInfoResponse","WsSQLMaturity",3.01);
}

StringBuffer &CGetDBSystemInfoResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Name");
	form.appendf("  <tr><td><b>Name: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("FullVersion");
	form.appendf("  <tr><td><b>FullVersion: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Major");
	form.appendf("  <tr><td><b>Major: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Minor");
	form.appendf("  <tr><td><b>Minor: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Point");
	form.appendf("  <tr><td><b>Point: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Project");
	form.appendf("  <tr><td><b>Project: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Maturity");
	form.appendf("  <tr><td><b>Maturity: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (!context.suppressed("GetDBSystemInfoResponse","WsSQLFullVersion")) {
		extfix.clear();
		if (prefix && *prefix)
			extfix.append(prefix).append(".");
		extfix.append("WsSQLFullVersion");
		form.appendf("  <tr><td><b>WsSQLFullVersion: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
		form.append("</td></tr>\n");
	}
	if (!context.suppressed("GetDBSystemInfoResponse","WsSQLMajor")) {
		extfix.clear();
		if (prefix && *prefix)
			extfix.append(prefix).append(".");
		extfix.append("WsSQLMajor");
		form.appendf("  <tr><td><b>WsSQLMajor: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
		form.append("</td></tr>\n");
	}
	if (!context.suppressed("GetDBSystemInfoResponse","WsSQLMinor")) {
		extfix.clear();
		if (prefix && *prefix)
			extfix.append(prefix).append(".");
		extfix.append("WsSQLMinor");
		form.appendf("  <tr><td><b>WsSQLMinor: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
		form.append("</td></tr>\n");
	}
	if (!context.suppressed("GetDBSystemInfoResponse","WsSQLPoint")) {
		extfix.clear();
		if (prefix && *prefix)
			extfix.append(prefix).append(".");
		extfix.append("WsSQLPoint");
		form.appendf("  <tr><td><b>WsSQLPoint: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
		form.append("</td></tr>\n");
	}
	if (!context.suppressed("GetDBSystemInfoResponse","WsSQLProject")) {
		extfix.clear();
		if (prefix && *prefix)
			extfix.append(prefix).append(".");
		extfix.append("WsSQLProject");
		form.appendf("  <tr><td><b>WsSQLProject: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
		form.append("</td></tr>\n");
	}
	if (!context.suppressed("GetDBSystemInfoResponse","WsSQLMaturity")) {
		extfix.clear();
		if (prefix && *prefix)
			extfix.append(prefix).append(".");
		extfix.append("WsSQLMaturity");
		form.appendf("  <tr><td><b>WsSQLMaturity: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
		form.append("</td></tr>\n");
	}
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CGetDBSystemInfoResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CGetDBSystemInfoResponse::serialize(IRpcMessage& rpc_resp)
{
	IEspContext* ctx = rpc_resp.queryContext();
	double clientVer= ctx ? ctx->getClientVersion() : -1; /* no context gets everything */
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
		m_Name.marshall(rpc_resp, "Name", "", "", "");
		m_FullVersion.marshall(rpc_resp, "FullVersion", "", "", "");
		m_Major.marshall(rpc_resp, "Major", "", "", "");
		m_Minor.marshall(rpc_resp, "Minor", "", "", "");
		m_Point.marshall(rpc_resp, "Point", "", "", "");
		m_Project.marshall(rpc_resp, "Project", "", "", "");
		m_Maturity.marshall(rpc_resp, "Maturity", "", "", "");
		if ((clientVer==-1.0 || clientVer>=3.01))
			m_WsSQLFullVersion.marshall(rpc_resp, "WsSQLFullVersion", "", "", "");
		if ((clientVer==-1.0 || clientVer>=3.01))
			m_WsSQLMajor.marshall(rpc_resp, "WsSQLMajor", "", "", "");
		if ((clientVer==-1.0 || clientVer>=3.01))
			m_WsSQLMinor.marshall(rpc_resp, "WsSQLMinor", "", "", "");
		if ((clientVer==-1.0 || clientVer>=3.01))
			m_WsSQLPoint.marshall(rpc_resp, "WsSQLPoint", "", "", "");
		if ((clientVer==-1.0 || clientVer>=3.01))
			m_WsSQLProject.marshall(rpc_resp, "WsSQLProject", "", "", "");
		if ((clientVer==-1.0 || clientVer>=3.01))
			m_WsSQLMaturity.marshall(rpc_resp, "WsSQLMaturity", "", "", "");
	}
}


void CGetDBSystemInfoResponse::copy(CGetDBSystemInfoResponse &from)
{
	m_Name.copy(from.m_Name);
	m_FullVersion.copy(from.m_FullVersion);
	m_Major.copy(from.m_Major);
	m_Minor.copy(from.m_Minor);
	m_Point.copy(from.m_Point);
	m_Project.copy(from.m_Project);
	m_Maturity.copy(from.m_Maturity);
	m_WsSQLFullVersion.copy(from.m_WsSQLFullVersion);
	m_WsSQLMajor.copy(from.m_WsSQLMajor);
	m_WsSQLMinor.copy(from.m_WsSQLMinor);
	m_WsSQLPoint.copy(from.m_WsSQLPoint);
	m_WsSQLProject.copy(from.m_WsSQLProject);
	m_WsSQLMaturity.copy(from.m_WsSQLMaturity);
}


void CGetDBSystemInfoResponse::copy(IConstGetDBSystemInfoResponse &ifrom)
{
	setName(ifrom.getName());
	setFullVersion(ifrom.getFullVersion());
	setMajor(ifrom.getMajor());
	setMinor(ifrom.getMinor());
	setPoint(ifrom.getPoint());
	setProject(ifrom.getProject());
	setMaturity(ifrom.getMaturity());
	setWsSQLFullVersion(ifrom.getWsSQLFullVersion());
	setWsSQLMajor(ifrom.getWsSQLMajor());
	setWsSQLMinor(ifrom.getWsSQLMinor());
	setWsSQLPoint(ifrom.getWsSQLPoint());
	setWsSQLProject(ifrom.getWsSQLProject());
	setWsSQLMaturity(ifrom.getWsSQLMaturity());
}


void CGetDBSystemInfoResponse::getAttributes(IProperties &attributes)
{
}


void CGetDBSystemInfoResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
		double clientVer = ctx ? ctx->getClientVersion() : -1;
		m_Name.toStr(ctx, buffer, "Name", "", true, "", "");
		m_FullVersion.toStr(ctx, buffer, "FullVersion", "", true, "", "");
		m_Major.toStr(ctx, buffer, "Major", "", true, "", "");
		m_Minor.toStr(ctx, buffer, "Minor", "", true, "", "");
		m_Point.toStr(ctx, buffer, "Point", "", true, "", "");
		m_Project.toStr(ctx, buffer, "Project", "", true, "", "");
		m_Maturity.toStr(ctx, buffer, "Maturity", "", true, "", "");
		if ((clientVer==-1.0 || clientVer>=3.01))
			m_WsSQLFullVersion.toStr(ctx, buffer, "WsSQLFullVersion", "", true, "", "");
		if ((clientVer==-1.0 || clientVer>=3.01))
			m_WsSQLMajor.toStr(ctx, buffer, "WsSQLMajor", "", true, "", "");
		if ((clientVer==-1.0 || clientVer>=3.01))
			m_WsSQLMinor.toStr(ctx, buffer, "WsSQLMinor", "", true, "", "");
		if ((clientVer==-1.0 || clientVer>=3.01))
			m_WsSQLPoint.toStr(ctx, buffer, "WsSQLPoint", "", true, "", "");
		if ((clientVer==-1.0 || clientVer>=3.01))
			m_WsSQLProject.toStr(ctx, buffer, "WsSQLProject", "", true, "", "");
		if ((clientVer==-1.0 || clientVer>=3.01))
			m_WsSQLMaturity.toStr(ctx, buffer, "WsSQLMaturity", "", true, "", "");
	}
}


void CGetDBSystemInfoResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CGetDBSystemInfoResponse::serializer(IEspContext* ctx, IConstGetDBSystemInfoResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<GetDBSystemInfoResponse>");
	double clientVer = ctx ? ctx->getClientVersion() : -1;
	// field Name
	{
		const char* s = src.getName();
		if (s && *s)
		{
			buffer.append("<Name>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Name>");
		}
	}
	// field FullVersion
	{
		const char* s = src.getFullVersion();
		if (s && *s)
		{
			buffer.append("<FullVersion>");
			encodeUtf8XML(s,buffer);
			buffer.append("</FullVersion>");
		}
	}
	// field Major
	{
		const char* s = src.getMajor();
		if (s && *s)
		{
			buffer.append("<Major>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Major>");
		}
	}
	// field Minor
	{
		const char* s = src.getMinor();
		if (s && *s)
		{
			buffer.append("<Minor>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Minor>");
		}
	}
	// field Point
	{
		const char* s = src.getPoint();
		if (s && *s)
		{
			buffer.append("<Point>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Point>");
		}
	}
	// field Project
	{
		const char* s = src.getProject();
		if (s && *s)
		{
			buffer.append("<Project>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Project>");
		}
	}
	// field Maturity
	{
		const char* s = src.getMaturity();
		if (s && *s)
		{
			buffer.append("<Maturity>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Maturity>");
		}
	}
	// field WsSQLFullVersion
	if ((clientVer==-1.0 || clientVer>=3.01))
	{
		const char* s = src.getWsSQLFullVersion();
		if (s && *s)
		{
			buffer.append("<WsSQLFullVersion>");
			encodeUtf8XML(s,buffer);
			buffer.append("</WsSQLFullVersion>");
		}
	}
	// field WsSQLMajor
	if ((clientVer==-1.0 || clientVer>=3.01))
	{
		const char* s = src.getWsSQLMajor();
		if (s && *s)
		{
			buffer.append("<WsSQLMajor>");
			encodeUtf8XML(s,buffer);
			buffer.append("</WsSQLMajor>");
		}
	}
	// field WsSQLMinor
	if ((clientVer==-1.0 || clientVer>=3.01))
	{
		const char* s = src.getWsSQLMinor();
		if (s && *s)
		{
			buffer.append("<WsSQLMinor>");
			encodeUtf8XML(s,buffer);
			buffer.append("</WsSQLMinor>");
		}
	}
	// field WsSQLPoint
	if ((clientVer==-1.0 || clientVer>=3.01))
	{
		const char* s = src.getWsSQLPoint();
		if (s && *s)
		{
			buffer.append("<WsSQLPoint>");
			encodeUtf8XML(s,buffer);
			buffer.append("</WsSQLPoint>");
		}
	}
	// field WsSQLProject
	if ((clientVer==-1.0 || clientVer>=3.01))
	{
		const char* s = src.getWsSQLProject();
		if (s && *s)
		{
			buffer.append("<WsSQLProject>");
			encodeUtf8XML(s,buffer);
			buffer.append("</WsSQLProject>");
		}
	}
	// field WsSQLMaturity
	if ((clientVer==-1.0 || clientVer>=3.01))
	{
		const char* s = src.getWsSQLMaturity();
		if (s && *s)
		{
			buffer.append("<WsSQLMaturity>");
			encodeUtf8XML(s,buffer);
			buffer.append("</WsSQLMaturity>");
		}
	}
	if (keepRootTag)
		buffer.append("</GetDBSystemInfoResponse>");
}

bool CGetDBSystemInfoResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
		hasValue |= m_Name.unmarshall(rpc_request, "Name", basepath);
		hasValue |= m_FullVersion.unmarshall(rpc_request, "FullVersion", basepath);
		hasValue |= m_Major.unmarshall(rpc_request, "Major", basepath);
		hasValue |= m_Minor.unmarshall(rpc_request, "Minor", basepath);
		hasValue |= m_Point.unmarshall(rpc_request, "Point", basepath);
		hasValue |= m_Project.unmarshall(rpc_request, "Project", basepath);
		hasValue |= m_Maturity.unmarshall(rpc_request, "Maturity", basepath);
		hasValue |= m_WsSQLFullVersion.unmarshall(rpc_request, "WsSQLFullVersion", basepath);
		hasValue |= m_WsSQLMajor.unmarshall(rpc_request, "WsSQLMajor", basepath);
		hasValue |= m_WsSQLMinor.unmarshall(rpc_request, "WsSQLMinor", basepath);
		hasValue |= m_WsSQLPoint.unmarshall(rpc_request, "WsSQLPoint", basepath);
		hasValue |= m_WsSQLProject.unmarshall(rpc_request, "WsSQLProject", basepath);
		hasValue |= m_WsSQLMaturity.unmarshall(rpc_request, "WsSQLMaturity", basepath);
	}
	return hasValue;
}

bool CGetDBSystemInfoResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Name.unmarshall(ctx, soapval, "Name");
	hasValue |= m_FullVersion.unmarshall(ctx, soapval, "FullVersion");
	hasValue |= m_Major.unmarshall(ctx, soapval, "Major");
	hasValue |= m_Minor.unmarshall(ctx, soapval, "Minor");
	hasValue |= m_Point.unmarshall(ctx, soapval, "Point");
	hasValue |= m_Project.unmarshall(ctx, soapval, "Project");
	hasValue |= m_Maturity.unmarshall(ctx, soapval, "Maturity");
	hasValue |= m_WsSQLFullVersion.unmarshall(ctx, soapval, "WsSQLFullVersion");
	hasValue |= m_WsSQLMajor.unmarshall(ctx, soapval, "WsSQLMajor");
	hasValue |= m_WsSQLMinor.unmarshall(ctx, soapval, "WsSQLMinor");
	hasValue |= m_WsSQLPoint.unmarshall(ctx, soapval, "WsSQLPoint");
	hasValue |= m_WsSQLProject.unmarshall(ctx, soapval, "WsSQLProject");
	hasValue |= m_WsSQLMaturity.unmarshall(ctx, soapval, "WsSQLMaturity");
	return hasValue;
}

bool CGetDBSystemInfoResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Name.unmarshall(ctx, params, attachments, "Name", basepath);
	hasValue |= m_FullVersion.unmarshall(ctx, params, attachments, "FullVersion", basepath);
	hasValue |= m_Major.unmarshall(ctx, params, attachments, "Major", basepath);
	hasValue |= m_Minor.unmarshall(ctx, params, attachments, "Minor", basepath);
	hasValue |= m_Point.unmarshall(ctx, params, attachments, "Point", basepath);
	hasValue |= m_Project.unmarshall(ctx, params, attachments, "Project", basepath);
	hasValue |= m_Maturity.unmarshall(ctx, params, attachments, "Maturity", basepath);
	hasValue |= m_WsSQLFullVersion.unmarshall(ctx, params, attachments, "WsSQLFullVersion", basepath);
	hasValue |= m_WsSQLMajor.unmarshall(ctx, params, attachments, "WsSQLMajor", basepath);
	hasValue |= m_WsSQLMinor.unmarshall(ctx, params, attachments, "WsSQLMinor", basepath);
	hasValue |= m_WsSQLPoint.unmarshall(ctx, params, attachments, "WsSQLPoint", basepath);
	hasValue |= m_WsSQLProject.unmarshall(ctx, params, attachments, "WsSQLProject", basepath);
	hasValue |= m_WsSQLMaturity.unmarshall(ctx, params, attachments, "WsSQLMaturity", basepath);
	return hasValue;
}

const char * CGetDBSystemInfoResponse::getName() { return m_Name.query();}
const char * CGetDBSystemInfoResponse::getFullVersion() { return m_FullVersion.query();}
const char * CGetDBSystemInfoResponse::getMajor() { return m_Major.query();}
const char * CGetDBSystemInfoResponse::getMinor() { return m_Minor.query();}
const char * CGetDBSystemInfoResponse::getPoint() { return m_Point.query();}
const char * CGetDBSystemInfoResponse::getProject() { return m_Project.query();}
const char * CGetDBSystemInfoResponse::getMaturity() { return m_Maturity.query();}
const char * CGetDBSystemInfoResponse::getWsSQLFullVersion() { return m_WsSQLFullVersion.query();}
const char * CGetDBSystemInfoResponse::getWsSQLMajor() { return m_WsSQLMajor.query();}
const char * CGetDBSystemInfoResponse::getWsSQLMinor() { return m_WsSQLMinor.query();}
const char * CGetDBSystemInfoResponse::getWsSQLPoint() { return m_WsSQLPoint.query();}
const char * CGetDBSystemInfoResponse::getWsSQLProject() { return m_WsSQLProject.query();}
const char * CGetDBSystemInfoResponse::getWsSQLMaturity() { return m_WsSQLMaturity.query();}
void CGetDBSystemInfoResponse::setName(const char * val){ m_Name.set(val); }
void CGetDBSystemInfoResponse::setFullVersion(const char * val){ m_FullVersion.set(val); }
void CGetDBSystemInfoResponse::setMajor(const char * val){ m_Major.set(val); }
void CGetDBSystemInfoResponse::setMinor(const char * val){ m_Minor.set(val); }
void CGetDBSystemInfoResponse::setPoint(const char * val){ m_Point.set(val); }
void CGetDBSystemInfoResponse::setProject(const char * val){ m_Project.set(val); }
void CGetDBSystemInfoResponse::setMaturity(const char * val){ m_Maturity.set(val); }
void CGetDBSystemInfoResponse::setWsSQLFullVersion(const char * val){ m_WsSQLFullVersion.set(val); }
void CGetDBSystemInfoResponse::setWsSQLMajor(const char * val){ m_WsSQLMajor.set(val); }
void CGetDBSystemInfoResponse::setWsSQLMinor(const char * val){ m_WsSQLMinor.set(val); }
void CGetDBSystemInfoResponse::setWsSQLPoint(const char * val){ m_WsSQLPoint.set(val); }
void CGetDBSystemInfoResponse::setWsSQLProject(const char * val){ m_WsSQLProject.set(val); }
void CGetDBSystemInfoResponse::setWsSQLMaturity(const char * val){ m_WsSQLMaturity.set(val); }
extern "C"  IEspGetDBSystemInfoResponse *createGetDBSystemInfoResponse(const char *serv){return ((IEspGetDBSystemInfoResponse *)new CGetDBSystemInfoResponse(serv));}
extern "C"  IClientGetDBSystemInfoResponse *createClientGetDBSystemInfoResponse(const char *serv){return ((IClientGetDBSystemInfoResponse *)new CGetDBSystemInfoResponse(serv));}

//=======================================================
// class CGetDBMetaDataRequest Implementation
//=======================================================

CGetDBMetaDataRequest::CGetDBMetaDataRequest(const char *serviceName, IRpcMessageBinding *init)
	: m_IncludeTables(nilIgnore),m_TableFilter(nilIgnore),m_IncludeStoredProcedures(nilIgnore),m_QuerySet(nilIgnore),m_IncludeTargetClusters(nilIgnore),m_ClusterType(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetDBMetaDataRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CGetDBMetaDataRequest::CGetDBMetaDataRequest(const char *serviceName, const char *bc)
	: m_IncludeTables(nilIgnore),m_TableFilter(nilIgnore),m_IncludeStoredProcedures(nilIgnore),m_QuerySet(nilIgnore),m_IncludeTargetClusters(nilIgnore),m_ClusterType(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetDBMetaDataRequest");
}

CGetDBMetaDataRequest::CGetDBMetaDataRequest(const char *serviceName, IRpcMessage* rpcmsg)
	: m_IncludeTables(nilIgnore),m_TableFilter(nilIgnore),m_IncludeStoredProcedures(nilIgnore),m_QuerySet(nilIgnore),m_IncludeTargetClusters(nilIgnore),m_ClusterType(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetDBMetaDataRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CGetDBMetaDataRequest::CGetDBMetaDataRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_IncludeTables(nilIgnore),m_TableFilter(nilIgnore),m_IncludeStoredProcedures(nilIgnore),m_QuerySet(nilIgnore),m_IncludeTargetClusters(nilIgnore),m_ClusterType(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetDBMetaDataRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CGetDBMetaDataRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"IncludeTables\" type=\"xsd:boolean\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"TableFilter\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"IncludeStoredProcedures\" type=\"xsd:boolean\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"QuerySet\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"IncludeTargetClusters\" type=\"xsd:boolean\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"ClusterType\" type=\"xsd:string\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CGetDBMetaDataRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CGetDBMetaDataRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CGetDBMetaDataRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("IncludeTables");
	
	form.appendf("  <tr><td><b>IncludeTables? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("TableFilter");
	form.appendf("  <tr><td><b>TableFilter: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("IncludeStoredProcedures");
	
	form.appendf("  <tr><td><b>IncludeStoredProcedures? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("QuerySet");
	form.appendf("  <tr><td><b>QuerySet: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("IncludeTargetClusters");
	
	form.appendf("  <tr><td><b>IncludeTargetClusters? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("ClusterType");
	form.appendf("  <tr><td><b>ClusterType: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CGetDBMetaDataRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CGetDBMetaDataRequest::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_IncludeTables.marshall(rpc_resp, "IncludeTables", "", "", "");
	m_TableFilter.marshall(rpc_resp, "TableFilter", "", "", "");
	m_IncludeStoredProcedures.marshall(rpc_resp, "IncludeStoredProcedures", "", "", "");
	m_QuerySet.marshall(rpc_resp, "QuerySet", "", "", "");
	m_IncludeTargetClusters.marshall(rpc_resp, "IncludeTargetClusters", "", "", "");
	m_ClusterType.marshall(rpc_resp, "ClusterType", "", "", "");
}


void CGetDBMetaDataRequest::copy(CGetDBMetaDataRequest &from)
{
	m_IncludeTables.copy(from.m_IncludeTables);
	m_TableFilter.copy(from.m_TableFilter);
	m_IncludeStoredProcedures.copy(from.m_IncludeStoredProcedures);
	m_QuerySet.copy(from.m_QuerySet);
	m_IncludeTargetClusters.copy(from.m_IncludeTargetClusters);
	m_ClusterType.copy(from.m_ClusterType);
}


void CGetDBMetaDataRequest::copy(IConstGetDBMetaDataRequest &ifrom)
{
	setIncludeTables(ifrom.getIncludeTables());
	setTableFilter(ifrom.getTableFilter());
	setIncludeStoredProcedures(ifrom.getIncludeStoredProcedures());
	setQuerySet(ifrom.getQuerySet());
	setIncludeTargetClusters(ifrom.getIncludeTargetClusters());
	setClusterType(ifrom.getClusterType());
}


void CGetDBMetaDataRequest::getAttributes(IProperties &attributes)
{
}


void CGetDBMetaDataRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_IncludeTables.toStr(ctx, buffer, "IncludeTables", "", true, "", "");
	m_TableFilter.toStr(ctx, buffer, "TableFilter", "", true, "", "");
	m_IncludeStoredProcedures.toStr(ctx, buffer, "IncludeStoredProcedures", "", true, "", "");
	m_QuerySet.toStr(ctx, buffer, "QuerySet", "", true, "", "");
	m_IncludeTargetClusters.toStr(ctx, buffer, "IncludeTargetClusters", "", true, "", "");
	m_ClusterType.toStr(ctx, buffer, "ClusterType", "", true, "", "");
}


void CGetDBMetaDataRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CGetDBMetaDataRequest::serializer(IEspContext* ctx, IConstGetDBMetaDataRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<GetDBMetaDataRequest>");
	// field IncludeTables
	{
		bool b = src.getIncludeTables();
		if (b)
			buffer.appendf("<IncludeTables>1</IncludeTables>");
	}
	// field TableFilter
	{
		const char* s = src.getTableFilter();
		if (s && *s)
		{
			buffer.append("<TableFilter>");
			encodeUtf8XML(s,buffer);
			buffer.append("</TableFilter>");
		}
	}
	// field IncludeStoredProcedures
	{
		bool b = src.getIncludeStoredProcedures();
		if (b)
			buffer.appendf("<IncludeStoredProcedures>1</IncludeStoredProcedures>");
	}
	// field QuerySet
	{
		const char* s = src.getQuerySet();
		if (s && *s)
		{
			buffer.append("<QuerySet>");
			encodeUtf8XML(s,buffer);
			buffer.append("</QuerySet>");
		}
	}
	// field IncludeTargetClusters
	{
		bool b = src.getIncludeTargetClusters();
		if (b)
			buffer.appendf("<IncludeTargetClusters>1</IncludeTargetClusters>");
	}
	// field ClusterType
	{
		const char* s = src.getClusterType();
		if (s && *s)
		{
			buffer.append("<ClusterType>");
			encodeUtf8XML(s,buffer);
			buffer.append("</ClusterType>");
		}
	}
	if (keepRootTag)
		buffer.append("</GetDBMetaDataRequest>");
}

bool CGetDBMetaDataRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_IncludeTables.unmarshall(rpc_request, "IncludeTables", basepath);
	hasValue |= m_TableFilter.unmarshall(rpc_request, "TableFilter", basepath);
	hasValue |= m_IncludeStoredProcedures.unmarshall(rpc_request, "IncludeStoredProcedures", basepath);
	hasValue |= m_QuerySet.unmarshall(rpc_request, "QuerySet", basepath);
	hasValue |= m_IncludeTargetClusters.unmarshall(rpc_request, "IncludeTargetClusters", basepath);
	hasValue |= m_ClusterType.unmarshall(rpc_request, "ClusterType", basepath);
	return hasValue;
}

bool CGetDBMetaDataRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_IncludeTables.unmarshall(ctx, soapval, "IncludeTables");
	hasValue |= m_TableFilter.unmarshall(ctx, soapval, "TableFilter");
	hasValue |= m_IncludeStoredProcedures.unmarshall(ctx, soapval, "IncludeStoredProcedures");
	hasValue |= m_QuerySet.unmarshall(ctx, soapval, "QuerySet");
	hasValue |= m_IncludeTargetClusters.unmarshall(ctx, soapval, "IncludeTargetClusters");
	hasValue |= m_ClusterType.unmarshall(ctx, soapval, "ClusterType");
	return hasValue;
}

bool CGetDBMetaDataRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_IncludeTables.unmarshall(ctx, params, attachments, "IncludeTables", basepath);
	hasValue |= m_TableFilter.unmarshall(ctx, params, attachments, "TableFilter", basepath);
	hasValue |= m_IncludeStoredProcedures.unmarshall(ctx, params, attachments, "IncludeStoredProcedures", basepath);
	hasValue |= m_QuerySet.unmarshall(ctx, params, attachments, "QuerySet", basepath);
	hasValue |= m_IncludeTargetClusters.unmarshall(ctx, params, attachments, "IncludeTargetClusters", basepath);
	hasValue |= m_ClusterType.unmarshall(ctx, params, attachments, "ClusterType", basepath);
	return hasValue;
}

bool CGetDBMetaDataRequest::getIncludeTables() { return m_IncludeTables;}
const char * CGetDBMetaDataRequest::getTableFilter() { return m_TableFilter.query();}
bool CGetDBMetaDataRequest::getIncludeStoredProcedures() { return m_IncludeStoredProcedures;}
const char * CGetDBMetaDataRequest::getQuerySet() { return m_QuerySet.query();}
bool CGetDBMetaDataRequest::getIncludeTargetClusters() { return m_IncludeTargetClusters;}
const char * CGetDBMetaDataRequest::getClusterType() { return m_ClusterType.query();}
void CGetDBMetaDataRequest::setIncludeTables(bool val){ m_IncludeTables=val; }
void CGetDBMetaDataRequest::setTableFilter(const char * val){ m_TableFilter.set(val); }
void CGetDBMetaDataRequest::setIncludeStoredProcedures(bool val){ m_IncludeStoredProcedures=val; }
void CGetDBMetaDataRequest::setQuerySet(const char * val){ m_QuerySet.set(val); }
void CGetDBMetaDataRequest::setIncludeTargetClusters(bool val){ m_IncludeTargetClusters=val; }
void CGetDBMetaDataRequest::setClusterType(const char * val){ m_ClusterType.set(val); }
extern "C"  IEspGetDBMetaDataRequest *createGetDBMetaDataRequest(const char *serv){return ((IEspGetDBMetaDataRequest *)new CGetDBMetaDataRequest(serv));}
extern "C"  IClientGetDBMetaDataRequest *createClientGetDBMetaDataRequest(const char *serv){return ((IClientGetDBMetaDataRequest *)new CGetDBMetaDataRequest(serv));}

//=======================================================
// class CGetDBMetaDataResponse Implementation
//=======================================================

CGetDBMetaDataResponse::CGetDBMetaDataResponse(const char *serviceName, IRpcMessageBinding *init)
	: m_Tables(nilIgnore),m_TableCount(nilIgnore),m_QuerySets(nilIgnore),m_ClusterNames(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetDBMetaDataResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CGetDBMetaDataResponse::CGetDBMetaDataResponse(const char *serviceName, const char *bc)
	: m_Tables(nilIgnore),m_TableCount(nilIgnore),m_QuerySets(nilIgnore),m_ClusterNames(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetDBMetaDataResponse");
}

CGetDBMetaDataResponse::CGetDBMetaDataResponse(const char *serviceName, IRpcMessage* rpcmsg)
	: m_Tables(nilIgnore),m_TableCount(nilIgnore),m_QuerySets(nilIgnore),m_ClusterNames(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetDBMetaDataResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CGetDBMetaDataResponse::CGetDBMetaDataResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_Tables(nilIgnore),m_TableCount(nilIgnore),m_QuerySets(nilIgnore),m_ClusterNames(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetDBMetaDataResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CGetDBMetaDataResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		schema.append("<xsd:element name=\"Exceptions\" type=\"tns:ArrayOfEspException\" minOccurs=\"0\" maxOccurs=\"1\"/>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Tables\">\n");
		schema.append("<xsd:complexType><xsd:sequence>\n");
		schema.append("<xsd:element minOccurs=\"0\" maxOccurs=\"unbounded\" name=\"Table\" type=\"tns:HPCCTable\"/>");
		schema.append("</xsd:sequence></xsd:complexType>");
		schema.append("</xsd:element>");
		schema.append("<xsd:element minOccurs=\"0\" name=\"TableCount\" type=\"xsd:integer\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"QuerySets\">\n");
		schema.append("<xsd:complexType><xsd:sequence>\n");
		schema.append("<xsd:element minOccurs=\"0\" maxOccurs=\"unbounded\" name=\"QuerySet\" type=\"tns:HPCCQuerySet\"/>");
		schema.append("</xsd:sequence></xsd:complexType>");
		schema.append("</xsd:element>");
		schema.append("<xsd:element minOccurs=\"0\" name=\"ClusterNames\">");
		schema.append("<xsd:complexType><xsd:sequence>");
		schema.append("<xsd:element name=\"ClusterName\" type=\"xsd:string\" minOccurs=\"0\" maxOccurs=\"unbounded\"/>\n");
		schema.append("</xsd:sequence></xsd:complexType>\n");
		schema.append("</xsd:element>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	if (!(flags & 0x10)  || (flags & 0x100))
	{
		CHPCCTable::getXsdDefinition(context, request, schema, added);
		CHPCCQuerySet::getXsdDefinition(context, request, schema, added);
	}
	return schema;
}

void CGetDBMetaDataResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CGetDBMetaDataResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
	if (!added.getValue("HPCCQuerySet"))
	{
		added.setValue("HPCCQuerySet",1);
		CHPCCQuerySet::getMapInfo(info,added);
	}
	if (!added.getValue("HPCCTable"))
	{
		added.setValue("HPCCTable",1);
		CHPCCTable::getMapInfo(info,added);
	}
}

StringBuffer &CGetDBMetaDataResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Tables");
	form.appendf("<tr><td><b>Tables: </b></td><td>");
	form.appendf("<table><tr><td><textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea></td>", extfix.str());
	form.append("</tr></table>");
	form.append("</td></tr>");
	extfix.clear();
	if (prefix && *prefix) extfix.append(prefix).append(".");
		extfix.append("TableCount");
	form.appendf("  <tr><td><b>TableCount: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("QuerySets");
	form.appendf("<tr><td><b>QuerySets: </b></td><td>");
	form.appendf("<table><tr><td><textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea></td>", extfix.str());
	form.append("</tr></table>");
	form.append("</td></tr>");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("ClusterNames");
	form.appendf("<tr><td><b>ClusterNames: </b></td><td>");
	form.appendf("<textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea>", extfix.str());
	form.append("</td></tr>");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CGetDBMetaDataResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CGetDBMetaDataResponse::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
		m_Tables.marshall(rpc_resp, "Tables", "Table");
		m_TableCount.marshall(rpc_resp, "TableCount", "", "", "");
		m_QuerySets.marshall(rpc_resp, "QuerySets", "QuerySet");
		m_ClusterNames.marshall(rpc_resp, "ClusterNames", "ClusterName");
	}
}


void CGetDBMetaDataResponse::copy(CGetDBMetaDataResponse &from)
{
	m_Tables.copy(from.m_Tables);
	m_TableCount.copy(from.m_TableCount);
	m_QuerySets.copy(from.m_QuerySets);
	m_ClusterNames.copy(from.m_ClusterNames);
}


void CGetDBMetaDataResponse::copy(IConstGetDBMetaDataResponse &ifrom)
{
	setTables(ifrom.getTables());
	setTableCount(ifrom.getTableCount());
	setQuerySets(ifrom.getQuerySets());
	setClusterNames(ifrom.getClusterNames());
}


void CGetDBMetaDataResponse::getAttributes(IProperties &attributes)
{
}


void CGetDBMetaDataResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
		m_Tables.toStr(ctx, buffer, "Tables", "Table");
		m_TableCount.toStr(ctx, buffer, "TableCount", "", true, "", "");
		m_QuerySets.toStr(ctx, buffer, "QuerySets", "QuerySet");
		m_ClusterNames.toStr(ctx, buffer, "ClusterNames", "ClusterName");
	}
}


void CGetDBMetaDataResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CGetDBMetaDataResponse::serializer(IEspContext* ctx, IConstGetDBMetaDataResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<GetDBMetaDataResponse>");
	// field Tables
	{
		IArrayOf<IConstHPCCTable>& v = src.getTables();
		int size = v.length();
		if (size>0)
			buffer.append("<Tables>");
		for (int i=0;i<size;i++)
		{
			buffer.append("<Table>");
			CHPCCTable::serializer(ctx,v.item(i),buffer,false);
			buffer.append("</Table>");
		}
		if (size>0)
			buffer.append("</Tables>");
	}
	// field TableCount
	{
		int n = src.getTableCount();
		if (n)
			buffer.appendf("<TableCount>%d</TableCount>", n);
	}
	// field QuerySets
	{
		IArrayOf<IConstHPCCQuerySet>& v = src.getQuerySets();
		int size = v.length();
		if (size>0)
			buffer.append("<QuerySets>");
		for (int i=0;i<size;i++)
		{
			buffer.append("<QuerySet>");
			CHPCCQuerySet::serializer(ctx,v.item(i),buffer,false);
			buffer.append("</QuerySet>");
		}
		if (size>0)
			buffer.append("</QuerySets>");
	}
	// field ClusterNames
	{
		StringArray& v = src.getClusterNames();
		if (v.length()>0)
			buffer.append("<ClusterNames>");
		for (size32_t i=0;i<v.length();i++)
			buffer.appendf("<ClusterName>%s</ClusterName>",v.item(i));
		if (v.length()>0)
			buffer.append("</ClusterNames>");
	}
	if (keepRootTag)
		buffer.append("</GetDBMetaDataResponse>");
}

bool CGetDBMetaDataResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
		hasValue |= m_Tables.unmarshall(rpc_request, "Tables", basepath);
		hasValue |= m_TableCount.unmarshall(rpc_request, "TableCount", basepath);
		hasValue |= m_QuerySets.unmarshall(rpc_request, "QuerySets", basepath);
		hasValue |= m_ClusterNames.unmarshall(rpc_request, "ClusterNames", basepath);
	}
	return hasValue;
}

bool CGetDBMetaDataResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Tables.unmarshall(ctx, soapval, "Tables");
	hasValue |= m_TableCount.unmarshall(ctx, soapval, "TableCount");
	hasValue |= m_QuerySets.unmarshall(ctx, soapval, "QuerySets");
	hasValue |= m_ClusterNames.unmarshall(ctx, soapval, "ClusterNames");
	return hasValue;
}

bool CGetDBMetaDataResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Tables.unmarshall(ctx, params, attachments, "Tables", basepath);
	hasValue |= m_TableCount.unmarshall(ctx, params, attachments, "TableCount", basepath);
	hasValue |= m_QuerySets.unmarshall(ctx, params, attachments, "QuerySets", basepath);
	hasValue |= m_ClusterNames.unmarshall(ctx, params, attachments, "ClusterNames", basepath);
	return hasValue;
}

IArrayOf<IConstHPCCTable> & CGetDBMetaDataResponse::getTables() { return (IArrayOf<IConstHPCCTable> &) m_Tables; }
int CGetDBMetaDataResponse::getTableCount() { return m_TableCount;}
IArrayOf<IConstHPCCQuerySet> & CGetDBMetaDataResponse::getQuerySets() { return (IArrayOf<IConstHPCCQuerySet> &) m_QuerySets; }
StringArray & CGetDBMetaDataResponse::getClusterNames() { return (StringArray &) m_ClusterNames; }
void CGetDBMetaDataResponse::setTables(IArrayOf<IEspHPCCTable> &val)
{
	m_Tables->kill();
	IArrayOf<IConstHPCCTable> &target = m_Tables.getValue();
	ForEachItemIn(idx, val)
	{
		IEspHPCCTable &item = (val).item(idx);
		item.Link();
		target.append(item);
	}
}
void CGetDBMetaDataResponse::setTables(IArrayOf<IConstHPCCTable> &val)
{
	m_Tables->kill();
	IArrayOf<IConstHPCCTable> &target = m_Tables.getValue();
	ForEachItemIn(idx, val)
	{
		IConstHPCCTable &item = val.item(idx);
		item.Link();
		target.append(item);
	}
}
void CGetDBMetaDataResponse::setTableCount(int val){ m_TableCount=val; }
void CGetDBMetaDataResponse::setQuerySets(IArrayOf<IEspHPCCQuerySet> &val)
{
	m_QuerySets->kill();
	IArrayOf<IConstHPCCQuerySet> &target = m_QuerySets.getValue();
	ForEachItemIn(idx, val)
	{
		IEspHPCCQuerySet &item = (val).item(idx);
		item.Link();
		target.append(item);
	}
}
void CGetDBMetaDataResponse::setQuerySets(IArrayOf<IConstHPCCQuerySet> &val)
{
	m_QuerySets->kill();
	IArrayOf<IConstHPCCQuerySet> &target = m_QuerySets.getValue();
	ForEachItemIn(idx, val)
	{
		IConstHPCCQuerySet &item = val.item(idx);
		item.Link();
		target.append(item);
	}
}
void CGetDBMetaDataResponse::setClusterNames(StringArray &val){ m_ClusterNames->kill();  CloneArray(m_ClusterNames.getValue(), val); }
extern "C"  IEspGetDBMetaDataResponse *createGetDBMetaDataResponse(const char *serv){return ((IEspGetDBMetaDataResponse *)new CGetDBMetaDataResponse(serv));}
extern "C"  IClientGetDBMetaDataResponse *createClientGetDBMetaDataResponse(const char *serv){return ((IClientGetDBMetaDataResponse *)new CGetDBMetaDataResponse(serv));}

//=======================================================
// class CGetResultsRequest Implementation
//=======================================================

CGetResultsRequest::CGetResultsRequest(const char *serviceName, IRpcMessageBinding *init)
	: m_WuId(nilIgnore),m_SuppressXmlSchema(nilIgnore),m_ResultWindowStart(0, nilIgnore,false),m_ResultWindowCount(0, nilIgnore,false)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetResultsRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CGetResultsRequest::CGetResultsRequest(const char *serviceName, const char *bc)
	: m_WuId(nilIgnore),m_SuppressXmlSchema(nilIgnore),m_ResultWindowStart(0, nilIgnore,false),m_ResultWindowCount(0, nilIgnore,false)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetResultsRequest");
}

CGetResultsRequest::CGetResultsRequest(const char *serviceName, IRpcMessage* rpcmsg)
	: m_WuId(nilIgnore),m_SuppressXmlSchema(nilIgnore),m_ResultWindowStart(0, nilIgnore,false),m_ResultWindowCount(0, nilIgnore,false)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetResultsRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CGetResultsRequest::CGetResultsRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_WuId(nilIgnore),m_SuppressXmlSchema(nilIgnore),m_ResultWindowStart(0, nilIgnore,false),m_ResultWindowCount(0, nilIgnore,false)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetResultsRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CGetResultsRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"WuId\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" default=\"1\" name=\"SuppressXmlSchema\" type=\"xsd:boolean\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"ResultWindowStart\" type=\"xsd:int\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"ResultWindowCount\" type=\"xsd:int\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CGetResultsRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CGetResultsRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CGetResultsRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("WuId");
	form.appendf("  <tr><td><b>WuId: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("SuppressXmlSchema");
	
	form.appendf("  <tr><td><b>SuppressXmlSchema? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\" checked=\"1\" /></td></tr>\n", extfix.str());
	extfix.clear();
	if (prefix && *prefix) extfix.append(prefix).append(".");
		extfix.append("ResultWindowStart");
	form.appendf("  <tr><td><b>ResultWindowStart: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix) extfix.append(prefix).append(".");
		extfix.append("ResultWindowCount");
	form.appendf("  <tr><td><b>ResultWindowCount: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CGetResultsRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CGetResultsRequest::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_WuId.marshall(rpc_resp, "WuId", "", "", "");
	m_SuppressXmlSchema.marshall(rpc_resp, "SuppressXmlSchema", "", "", "");
	m_ResultWindowStart.marshall(rpc_resp, "ResultWindowStart", "", "", "");
	m_ResultWindowCount.marshall(rpc_resp, "ResultWindowCount", "", "", "");
}


void CGetResultsRequest::copy(CGetResultsRequest &from)
{
	m_WuId.copy(from.m_WuId);
	m_SuppressXmlSchema.copy(from.m_SuppressXmlSchema);
	m_ResultWindowStart.copy(from.m_ResultWindowStart);
	m_ResultWindowCount.copy(from.m_ResultWindowCount);
}


void CGetResultsRequest::copy(IConstGetResultsRequest &ifrom)
{
	setWuId(ifrom.getWuId());
	setSuppressXmlSchema(ifrom.getSuppressXmlSchema());
	setResultWindowStart(ifrom.getResultWindowStart());
	setResultWindowCount(ifrom.getResultWindowCount());
}


void CGetResultsRequest::getAttributes(IProperties &attributes)
{
}


void CGetResultsRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_WuId.toStr(ctx, buffer, "WuId", "", true, "", "");
	m_SuppressXmlSchema.toStr(ctx, buffer, "SuppressXmlSchema", "", true, "", "");
	m_ResultWindowStart.toStr(ctx, buffer, "ResultWindowStart", "", true, "", "");
	m_ResultWindowCount.toStr(ctx, buffer, "ResultWindowCount", "", true, "", "");
}


void CGetResultsRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CGetResultsRequest::serializer(IEspContext* ctx, IConstGetResultsRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<GetResultsRequest>");
	// field WuId
	{
		const char* s = src.getWuId();
		if (s && *s)
		{
			buffer.append("<WuId>");
			encodeUtf8XML(s,buffer);
			buffer.append("</WuId>");
		}
	}
	// field SuppressXmlSchema
	{
		bool b = src.getSuppressXmlSchema();
		if (b)
			buffer.appendf("<SuppressXmlSchema>1</SuppressXmlSchema>");
	}
	// field ResultWindowStart
	{
		int n = src.getResultWindowStart();
		if (n)
			buffer.appendf("<ResultWindowStart>%d</ResultWindowStart>", n);
	}
	// field ResultWindowCount
	{
		int n = src.getResultWindowCount();
		if (n)
			buffer.appendf("<ResultWindowCount>%d</ResultWindowCount>", n);
	}
	if (keepRootTag)
		buffer.append("</GetResultsRequest>");
}

bool CGetResultsRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_WuId.unmarshall(rpc_request, "WuId", basepath);
	hasValue |= m_SuppressXmlSchema.unmarshall(rpc_request, "SuppressXmlSchema", basepath);
	hasValue |= m_ResultWindowStart.unmarshall(rpc_request, "ResultWindowStart", basepath);
	hasValue |= m_ResultWindowCount.unmarshall(rpc_request, "ResultWindowCount", basepath);
	return hasValue;
}

bool CGetResultsRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_WuId.unmarshall(ctx, soapval, "WuId");
	hasValue |= m_SuppressXmlSchema.unmarshall(ctx, soapval, "SuppressXmlSchema");
	hasValue |= m_ResultWindowStart.unmarshall(ctx, soapval, "ResultWindowStart");
	hasValue |= m_ResultWindowCount.unmarshall(ctx, soapval, "ResultWindowCount");
	return hasValue;
}

bool CGetResultsRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_WuId.unmarshall(ctx, params, attachments, "WuId", basepath);
	hasValue |= m_SuppressXmlSchema.unmarshall(ctx, params, attachments, "SuppressXmlSchema", basepath);
	hasValue |= m_ResultWindowStart.unmarshall(ctx, params, attachments, "ResultWindowStart", basepath);
	hasValue |= m_ResultWindowCount.unmarshall(ctx, params, attachments, "ResultWindowCount", basepath);
	return hasValue;
}

const char * CGetResultsRequest::getWuId() { return m_WuId.query();}
bool CGetResultsRequest::getSuppressXmlSchema() { return m_SuppressXmlSchema;}
int CGetResultsRequest::getResultWindowStart() { return m_ResultWindowStart;}
int CGetResultsRequest::getResultWindowCount() { return m_ResultWindowCount;}
void CGetResultsRequest::setWuId(const char * val){ m_WuId.set(val); }
void CGetResultsRequest::setSuppressXmlSchema(bool val){ m_SuppressXmlSchema=val; }
void CGetResultsRequest::setResultWindowStart(int val){ m_ResultWindowStart=val; }
void CGetResultsRequest::setResultWindowCount(int val){ m_ResultWindowCount=val; }
extern "C"  IEspGetResultsRequest *createGetResultsRequest(const char *serv){return ((IEspGetResultsRequest *)new CGetResultsRequest(serv));}
extern "C"  IClientGetResultsRequest *createClientGetResultsRequest(const char *serv){return ((IClientGetResultsRequest *)new CGetResultsRequest(serv));}

//=======================================================
// class CGetResultsResponse Implementation
//=======================================================

CGetResultsResponse::CGetResultsResponse(const char *serviceName, IRpcMessageBinding *init)
	: m_Result(nilIgnore),m_ResultWindowStart(nilIgnore),m_ResultWindowCount(nilIgnore),m_Workunit(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetResultsResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CGetResultsResponse::CGetResultsResponse(const char *serviceName, const char *bc)
	: m_Result(nilIgnore),m_ResultWindowStart(nilIgnore),m_ResultWindowCount(nilIgnore),m_Workunit(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetResultsResponse");
}

CGetResultsResponse::CGetResultsResponse(const char *serviceName, IRpcMessage* rpcmsg)
	: m_Result(nilIgnore),m_ResultWindowStart(nilIgnore),m_ResultWindowCount(nilIgnore),m_Workunit(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetResultsResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CGetResultsResponse::CGetResultsResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_Result(nilIgnore),m_ResultWindowStart(nilIgnore),m_ResultWindowCount(nilIgnore),m_Workunit(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetResultsResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CGetResultsResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		schema.append("<xsd:element name=\"Exceptions\" type=\"tns:ArrayOfEspException\" minOccurs=\"0\" maxOccurs=\"1\"/>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Result\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"ResultWindowStart\" type=\"xsd:unsignedInt\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"ResultWindowCount\" type=\"xsd:unsignedInt\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Workunit\" type=\"tns:ECLWorkunit\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	if (!(flags & 0x10)  || (flags & 0x100))
	{
		CECLWorkunit::getXsdDefinition(context, request, schema, added);
	}
	return schema;
}

void CGetResultsResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CGetResultsResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
	if (!added.getValue("ECLWorkunit"))
	{
		added.setValue("ECLWorkunit",1);
		CECLWorkunit::getMapInfo(info,added);
	}
}

StringBuffer &CGetResultsResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Result");
	form.appendf("  <tr><td><b>Result: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix) extfix.append(prefix).append(".");
		extfix.append("ResultWindowStart");
	form.appendf("  <tr><td><b>ResultWindowStart: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix) extfix.append(prefix).append(".");
		extfix.append("ResultWindowCount");
	form.appendf("  <tr><td><b>ResultWindowCount: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Workunit");
	form.append("<tr>").append("<td><b>Workunit: </b></td><td><hr/>");
	CECLWorkunit::getHtmlForm(context, request, serv, method, form, false, extfix.str());
	form.append("<hr/></td></tr>");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CGetResultsResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CGetResultsResponse::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
		m_Result.marshall(rpc_resp, "Result", "", "", "");
		m_ResultWindowStart.marshall(rpc_resp, "ResultWindowStart", "", "", "");
		m_ResultWindowCount.marshall(rpc_resp, "ResultWindowCount", "", "", "");
		m_Workunit.marshall(rpc_resp, "Workunit", "", "", "");
	}
}


void CGetResultsResponse::copy(CGetResultsResponse &from)
{
	m_Result.copy(from.m_Result);
	m_ResultWindowStart.copy(from.m_ResultWindowStart);
	m_ResultWindowCount.copy(from.m_ResultWindowCount);
	m_Workunit.copy(from.m_Workunit);
}


void CGetResultsResponse::copy(IConstGetResultsResponse &ifrom)
{
	setResult(ifrom.getResult());
	setResultWindowStart(ifrom.getResultWindowStart());
	setResultWindowCount(ifrom.getResultWindowCount());
	setWorkunit(ifrom.getWorkunit());
}


void CGetResultsResponse::getAttributes(IProperties &attributes)
{
}


void CGetResultsResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
		m_Result.toStr(ctx, buffer, "Result", "", true, "", "");
		m_ResultWindowStart.toStr(ctx, buffer, "ResultWindowStart", "", true, "", "");
		m_ResultWindowCount.toStr(ctx, buffer, "ResultWindowCount", "", true, "", "");
		m_Workunit.toStr(ctx, buffer, "Workunit", "", false, "", "");
	}
}


void CGetResultsResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CGetResultsResponse::serializer(IEspContext* ctx, IConstGetResultsResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<GetResultsResponse>");
	// field Result
	{
		const char* s = src.getResult();
		if (s && *s)
		{
			buffer.append("<Result>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Result>");
		}
	}
	// field ResultWindowStart
	{
		//*** default kind: TK_UNSIGNED; type=(null), name=ResultWindowStart
		buffer.append("<ResultWindowStart>");
		buffer.append(src.getResultWindowStart());
		buffer.append("</ResultWindowStart>");
	}
	// field ResultWindowCount
	{
		//*** default kind: TK_UNSIGNED; type=(null), name=ResultWindowCount
		buffer.append("<ResultWindowCount>");
		buffer.append(src.getResultWindowCount());
		buffer.append("</ResultWindowCount>");
	}
	// field Workunit
	{
		StringBuffer tmp;
		CECLWorkunit::serializer(ctx,src.getWorkunit(), tmp, false);
		if (tmp.length()>0)
			buffer.appendf("<Workunit>%s</Workunit>",tmp.str());
	}
	if (keepRootTag)
		buffer.append("</GetResultsResponse>");
}

bool CGetResultsResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
		hasValue |= m_Result.unmarshall(rpc_request, "Result", basepath);
		hasValue |= m_ResultWindowStart.unmarshall(rpc_request, "ResultWindowStart", basepath);
		hasValue |= m_ResultWindowCount.unmarshall(rpc_request, "ResultWindowCount", basepath);
		hasValue |= m_Workunit.unmarshall(rpc_request, "Workunit", basepath);
	}
	return hasValue;
}

bool CGetResultsResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Result.unmarshall(ctx, soapval, "Result");
	hasValue |= m_ResultWindowStart.unmarshall(ctx, soapval, "ResultWindowStart");
	hasValue |= m_ResultWindowCount.unmarshall(ctx, soapval, "ResultWindowCount");
	hasValue |= m_Workunit.unmarshall(ctx, soapval, "Workunit");
	return hasValue;
}

bool CGetResultsResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Result.unmarshall(ctx, params, attachments, "Result", basepath);
	hasValue |= m_ResultWindowStart.unmarshall(ctx, params, attachments, "ResultWindowStart", basepath);
	hasValue |= m_ResultWindowCount.unmarshall(ctx, params, attachments, "ResultWindowCount", basepath);
	hasValue |= m_Workunit.unmarshall(ctx, params, attachments, "Workunit", basepath);
	return hasValue;
}

const char * CGetResultsResponse::getResult() { return m_Result.query();}
unsigned int CGetResultsResponse::getResultWindowStart() { return m_ResultWindowStart;}
unsigned int CGetResultsResponse::getResultWindowCount() { return m_ResultWindowCount;}
IConstECLWorkunit & CGetResultsResponse::getWorkunit() { return (IConstECLWorkunit &) m_Workunit.getValue();}
void CGetResultsResponse::setResult(const char * val){ m_Result.set(val); }
void CGetResultsResponse::setResultWindowStart(unsigned int val){ m_ResultWindowStart=val; }
void CGetResultsResponse::setResultWindowCount(unsigned int val){ m_ResultWindowCount=val; }
IEspECLWorkunit & CGetResultsResponse::updateWorkunit(){ return (IEspECLWorkunit &) m_Workunit.getValue(); }
void CGetResultsResponse::setWorkunit(IConstECLWorkunit &ifrom){ m_Workunit.copy(ifrom); }
extern "C"  IEspGetResultsResponse *createGetResultsResponse(const char *serv){return ((IEspGetResultsResponse *)new CGetResultsResponse(serv));}
extern "C"  IClientGetResultsResponse *createClientGetResultsResponse(const char *serv){return ((IClientGetResultsResponse *)new CGetResultsResponse(serv));}

//=======================================================
// class CEchoRequest Implementation
//=======================================================

CEchoRequest::CEchoRequest(const char *serviceName, IRpcMessageBinding *init)
	: m_Request(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("EchoRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CEchoRequest::CEchoRequest(const char *serviceName, const char *bc)
	: m_Request(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("EchoRequest");
}

CEchoRequest::CEchoRequest(const char *serviceName, IRpcMessage* rpcmsg)
	: m_Request(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("EchoRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CEchoRequest::CEchoRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_Request(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("EchoRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CEchoRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Request\" type=\"xsd:string\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CEchoRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CEchoRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CEchoRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Request");
	form.appendf("  <tr><td><b>Request: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CEchoRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CEchoRequest::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_Request.marshall(rpc_resp, "Request", "", "", "");
}


void CEchoRequest::copy(CEchoRequest &from)
{
	m_Request.copy(from.m_Request);
}


void CEchoRequest::copy(IConstEchoRequest &ifrom)
{
	setRequest(ifrom.getRequest());
}


void CEchoRequest::getAttributes(IProperties &attributes)
{
}


void CEchoRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_Request.toStr(ctx, buffer, "Request", "", true, "", "");
}


void CEchoRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CEchoRequest::serializer(IEspContext* ctx, IConstEchoRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<EchoRequest>");
	// field Request
	{
		const char* s = src.getRequest();
		if (s && *s)
		{
			buffer.append("<Request>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Request>");
		}
	}
	if (keepRootTag)
		buffer.append("</EchoRequest>");
}

bool CEchoRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_Request.unmarshall(rpc_request, "Request", basepath);
	return hasValue;
}

bool CEchoRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Request.unmarshall(ctx, soapval, "Request");
	return hasValue;
}

bool CEchoRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Request.unmarshall(ctx, params, attachments, "Request", basepath);
	return hasValue;
}

const char * CEchoRequest::getRequest() { return m_Request.query();}
void CEchoRequest::setRequest(const char * val){ m_Request.set(val); }
extern "C"  IEspEchoRequest *createEchoRequest(const char *serv){return ((IEspEchoRequest *)new CEchoRequest(serv));}
extern "C"  IClientEchoRequest *createClientEchoRequest(const char *serv){return ((IClientEchoRequest *)new CEchoRequest(serv));}

//=======================================================
// class CEchoResponse Implementation
//=======================================================

CEchoResponse::CEchoResponse(const char *serviceName, IRpcMessageBinding *init)
	: m_Response(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("EchoResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CEchoResponse::CEchoResponse(const char *serviceName, const char *bc)
	: m_Response(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("EchoResponse");
}

CEchoResponse::CEchoResponse(const char *serviceName, IRpcMessage* rpcmsg)
	: m_Response(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("EchoResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CEchoResponse::CEchoResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_Response(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("EchoResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CEchoResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Response\" type=\"xsd:string\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CEchoResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CEchoResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CEchoResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Response");
	form.appendf("  <tr><td><b>Response: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CEchoResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CEchoResponse::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
		m_Response.marshall(rpc_resp, "Response", "", "", "");
	}
}


void CEchoResponse::copy(CEchoResponse &from)
{
	m_Response.copy(from.m_Response);
}


void CEchoResponse::copy(IConstEchoResponse &ifrom)
{
	setResponse(ifrom.getResponse());
}


void CEchoResponse::getAttributes(IProperties &attributes)
{
}


void CEchoResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
		m_Response.toStr(ctx, buffer, "Response", "", true, "", "");
	}
}


void CEchoResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CEchoResponse::serializer(IEspContext* ctx, IConstEchoResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<EchoResponse>");
	// field Response
	{
		const char* s = src.getResponse();
		if (s && *s)
		{
			buffer.append("<Response>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Response>");
		}
	}
	if (keepRootTag)
		buffer.append("</EchoResponse>");
}

bool CEchoResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
		hasValue |= m_Response.unmarshall(rpc_request, "Response", basepath);
	}
	return hasValue;
}

bool CEchoResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Response.unmarshall(ctx, soapval, "Response");
	return hasValue;
}

bool CEchoResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Response.unmarshall(ctx, params, attachments, "Response", basepath);
	return hasValue;
}

const char * CEchoResponse::getResponse() { return m_Response.query();}
void CEchoResponse::setResponse(const char * val){ m_Response.set(val); }
extern "C"  IEspEchoResponse *createEchoResponse(const char *serv){return ((IEspEchoResponse *)new CEchoResponse(serv));}
extern "C"  IClientEchoResponse *createClientEchoResponse(const char *serv){return ((IClientEchoResponse *)new CEchoResponse(serv));}

//=======================================================
// class CRelatedIndexSet Implementation
//=======================================================

CRelatedIndexSet::CRelatedIndexSet(const char *serviceName, IRpcMessageBinding *init)
	: m_FileName(nilIgnore),m_Indexes(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("RelatedIndexSet");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CRelatedIndexSet::CRelatedIndexSet(const char *serviceName, const char *bc)
	: m_FileName(nilIgnore),m_Indexes(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("RelatedIndexSet");
}

StringBuffer &CRelatedIndexSet::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:complexType name=\"%s\">\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"FileName\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Indexes\">");
		schema.append("<xsd:complexType><xsd:sequence>");
		schema.append("<xsd:element name=\"Index\" type=\"xsd:string\" minOccurs=\"0\" maxOccurs=\"unbounded\"/>\n");
		schema.append("</xsd:sequence></xsd:complexType>\n");
		schema.append("</xsd:element>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType>\n");
		}
	}
	return schema;
}

void CRelatedIndexSet::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CRelatedIndexSet::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CRelatedIndexSet::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("FileName");
	form.appendf("  <tr><td><b>FileName: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Indexes");
	form.appendf("<tr><td><b>Indexes: </b></td><td>");
	form.appendf("<textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea>", extfix.str());
	form.append("</td></tr>");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CRelatedIndexSet::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CRelatedIndexSet::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_FileName.marshall(rpc_resp, "FileName", "", "", "");
	m_Indexes.marshall(rpc_resp, "Indexes", "Index");
}


void CRelatedIndexSet::copy(CRelatedIndexSet &from)
{
	m_FileName.copy(from.m_FileName);
	m_Indexes.copy(from.m_Indexes);
}


void CRelatedIndexSet::copy(IConstRelatedIndexSet &ifrom)
{
	setFileName(ifrom.getFileName());
	setIndexes(ifrom.getIndexes());
}


void CRelatedIndexSet::getAttributes(IProperties &attributes)
{
}


void CRelatedIndexSet::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_FileName.toStr(ctx, buffer, "FileName", "", true, "", "");
	m_Indexes.toStr(ctx, buffer, "Indexes", "Index");
}


void CRelatedIndexSet::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CRelatedIndexSet::serializer(IEspContext* ctx, IConstRelatedIndexSet &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<RelatedIndexSet>");
	// field FileName
	{
		const char* s = src.getFileName();
		if (s && *s)
		{
			buffer.append("<FileName>");
			encodeUtf8XML(s,buffer);
			buffer.append("</FileName>");
		}
	}
	// field Indexes
	{
		StringArray& v = src.getIndexes();
		if (v.length()>0)
			buffer.append("<Indexes>");
		for (size32_t i=0;i<v.length();i++)
			buffer.appendf("<Index>%s</Index>",v.item(i));
		if (v.length()>0)
			buffer.append("</Indexes>");
	}
	if (keepRootTag)
		buffer.append("</RelatedIndexSet>");
}

bool CRelatedIndexSet::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_FileName.unmarshall(rpc_request, "FileName", basepath);
	hasValue |= m_Indexes.unmarshall(rpc_request, "Indexes", basepath);
	return hasValue;
}

bool CRelatedIndexSet::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_FileName.unmarshall(ctx, soapval, "FileName");
	hasValue |= m_Indexes.unmarshall(ctx, soapval, "Indexes");
	return hasValue;
}

bool CRelatedIndexSet::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_FileName.unmarshall(ctx, params, attachments, "FileName", basepath);
	hasValue |= m_Indexes.unmarshall(ctx, params, attachments, "Indexes", basepath);
	return hasValue;
}

const char * CRelatedIndexSet::getFileName() { return m_FileName.query();}
StringArray & CRelatedIndexSet::getIndexes() { return (StringArray &) m_Indexes; }
void CRelatedIndexSet::setFileName(const char * val){ m_FileName.set(val); }
void CRelatedIndexSet::setIndexes(StringArray &val){ m_Indexes->kill();  CloneArray(m_Indexes.getValue(), val); }
extern "C"  IEspRelatedIndexSet *createRelatedIndexSet(const char *serv, const char *msgname){return ((IEspRelatedIndexSet *)new CRelatedIndexSet(serv /*, msgname*/));}
extern "C"  IClientRelatedIndexSet *createClientRelatedIndexSet(const char *serv, const char *msgname){return ((IClientRelatedIndexSet *)new CRelatedIndexSet(serv /*, msgname*/));}

//=======================================================
// class CGetRelatedIndexesRequest Implementation
//=======================================================

CGetRelatedIndexesRequest::CGetRelatedIndexesRequest(const char *serviceName, IRpcMessageBinding *init)
	: m_FileNames(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetRelatedIndexesRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CGetRelatedIndexesRequest::CGetRelatedIndexesRequest(const char *serviceName, const char *bc)
	: m_FileNames(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetRelatedIndexesRequest");
}

CGetRelatedIndexesRequest::CGetRelatedIndexesRequest(const char *serviceName, IRpcMessage* rpcmsg)
	: m_FileNames(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetRelatedIndexesRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CGetRelatedIndexesRequest::CGetRelatedIndexesRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_FileNames(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetRelatedIndexesRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CGetRelatedIndexesRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"FileNames\">");
		schema.append("<xsd:complexType><xsd:sequence>");
		schema.append("<xsd:element name=\"FileName\" type=\"xsd:string\" minOccurs=\"0\" maxOccurs=\"unbounded\"/>\n");
		schema.append("</xsd:sequence></xsd:complexType>\n");
		schema.append("</xsd:element>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CGetRelatedIndexesRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CGetRelatedIndexesRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CGetRelatedIndexesRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("FileNames");
	form.appendf("<tr><td><b>FileNames: </b></td><td>");
	form.appendf("<textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea>", extfix.str());
	form.append("</td></tr>");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CGetRelatedIndexesRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CGetRelatedIndexesRequest::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_FileNames.marshall(rpc_resp, "FileNames", "FileName");
}


void CGetRelatedIndexesRequest::copy(CGetRelatedIndexesRequest &from)
{
	m_FileNames.copy(from.m_FileNames);
}


void CGetRelatedIndexesRequest::copy(IConstGetRelatedIndexesRequest &ifrom)
{
	setFileNames(ifrom.getFileNames());
}


void CGetRelatedIndexesRequest::getAttributes(IProperties &attributes)
{
}


void CGetRelatedIndexesRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_FileNames.toStr(ctx, buffer, "FileNames", "FileName");
}


void CGetRelatedIndexesRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CGetRelatedIndexesRequest::serializer(IEspContext* ctx, IConstGetRelatedIndexesRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<GetRelatedIndexesRequest>");
	// field FileNames
	{
		StringArray& v = src.getFileNames();
		if (v.length()>0)
			buffer.append("<FileNames>");
		for (size32_t i=0;i<v.length();i++)
			buffer.appendf("<FileName>%s</FileName>",v.item(i));
		if (v.length()>0)
			buffer.append("</FileNames>");
	}
	if (keepRootTag)
		buffer.append("</GetRelatedIndexesRequest>");
}

bool CGetRelatedIndexesRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_FileNames.unmarshall(rpc_request, "FileNames", basepath);
	return hasValue;
}

bool CGetRelatedIndexesRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_FileNames.unmarshall(ctx, soapval, "FileNames");
	return hasValue;
}

bool CGetRelatedIndexesRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_FileNames.unmarshall(ctx, params, attachments, "FileNames", basepath);
	return hasValue;
}

StringArray & CGetRelatedIndexesRequest::getFileNames() { return (StringArray &) m_FileNames; }
void CGetRelatedIndexesRequest::setFileNames(StringArray &val){ m_FileNames->kill();  CloneArray(m_FileNames.getValue(), val); }
extern "C"  IEspGetRelatedIndexesRequest *createGetRelatedIndexesRequest(const char *serv){return ((IEspGetRelatedIndexesRequest *)new CGetRelatedIndexesRequest(serv));}
extern "C"  IClientGetRelatedIndexesRequest *createClientGetRelatedIndexesRequest(const char *serv){return ((IClientGetRelatedIndexesRequest *)new CGetRelatedIndexesRequest(serv));}

//=======================================================
// class CGetRelatedIndexesResponse Implementation
//=======================================================

CGetRelatedIndexesResponse::CGetRelatedIndexesResponse(const char *serviceName, IRpcMessageBinding *init)
	: m_RelatedIndexSets(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetRelatedIndexesResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CGetRelatedIndexesResponse::CGetRelatedIndexesResponse(const char *serviceName, const char *bc)
	: m_RelatedIndexSets(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetRelatedIndexesResponse");
}

CGetRelatedIndexesResponse::CGetRelatedIndexesResponse(const char *serviceName, IRpcMessage* rpcmsg)
	: m_RelatedIndexSets(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetRelatedIndexesResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CGetRelatedIndexesResponse::CGetRelatedIndexesResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_RelatedIndexSets(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetRelatedIndexesResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CGetRelatedIndexesResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"RelatedIndexSets\">\n");
		schema.append("<xsd:complexType><xsd:sequence>\n");
		schema.append("<xsd:element minOccurs=\"0\" maxOccurs=\"unbounded\" name=\"RelatedIndexSet\" type=\"tns:RelatedIndexSet\"/>");
		schema.append("</xsd:sequence></xsd:complexType>");
		schema.append("</xsd:element>");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	if (!(flags & 0x10)  || (flags & 0x100))
	{
		CRelatedIndexSet::getXsdDefinition(context, request, schema, added);
	}
	return schema;
}

void CGetRelatedIndexesResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CGetRelatedIndexesResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
	if (!added.getValue("RelatedIndexSet"))
	{
		added.setValue("RelatedIndexSet",1);
		CRelatedIndexSet::getMapInfo(info,added);
	}
}

StringBuffer &CGetRelatedIndexesResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("RelatedIndexSets");
	form.appendf("<tr><td><b>RelatedIndexSets: </b></td><td>");
	form.appendf("<table><tr><td><textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea></td>", extfix.str());
	form.append("</tr></table>");
	form.append("</td></tr>");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CGetRelatedIndexesResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CGetRelatedIndexesResponse::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
		m_RelatedIndexSets.marshall(rpc_resp, "RelatedIndexSets", "RelatedIndexSet");
	}
}


void CGetRelatedIndexesResponse::copy(CGetRelatedIndexesResponse &from)
{
	m_RelatedIndexSets.copy(from.m_RelatedIndexSets);
}


void CGetRelatedIndexesResponse::copy(IConstGetRelatedIndexesResponse &ifrom)
{
	setRelatedIndexSets(ifrom.getRelatedIndexSets());
}


void CGetRelatedIndexesResponse::getAttributes(IProperties &attributes)
{
}


void CGetRelatedIndexesResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
		m_RelatedIndexSets.toStr(ctx, buffer, "RelatedIndexSets", "RelatedIndexSet");
	}
}


void CGetRelatedIndexesResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CGetRelatedIndexesResponse::serializer(IEspContext* ctx, IConstGetRelatedIndexesResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<GetRelatedIndexesResponse>");
	// field RelatedIndexSets
	{
		IArrayOf<IConstRelatedIndexSet>& v = src.getRelatedIndexSets();
		int size = v.length();
		if (size>0)
			buffer.append("<RelatedIndexSets>");
		for (int i=0;i<size;i++)
		{
			buffer.append("<RelatedIndexSet>");
			CRelatedIndexSet::serializer(ctx,v.item(i),buffer,false);
			buffer.append("</RelatedIndexSet>");
		}
		if (size>0)
			buffer.append("</RelatedIndexSets>");
	}
	if (keepRootTag)
		buffer.append("</GetRelatedIndexesResponse>");
}

bool CGetRelatedIndexesResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
		hasValue |= m_RelatedIndexSets.unmarshall(rpc_request, "RelatedIndexSets", basepath);
	}
	return hasValue;
}

bool CGetRelatedIndexesResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_RelatedIndexSets.unmarshall(ctx, soapval, "RelatedIndexSets");
	return hasValue;
}

bool CGetRelatedIndexesResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_RelatedIndexSets.unmarshall(ctx, params, attachments, "RelatedIndexSets", basepath);
	return hasValue;
}

IArrayOf<IConstRelatedIndexSet> & CGetRelatedIndexesResponse::getRelatedIndexSets() { return (IArrayOf<IConstRelatedIndexSet> &) m_RelatedIndexSets; }
void CGetRelatedIndexesResponse::setRelatedIndexSets(IArrayOf<IEspRelatedIndexSet> &val)
{
	m_RelatedIndexSets->kill();
	IArrayOf<IConstRelatedIndexSet> &target = m_RelatedIndexSets.getValue();
	ForEachItemIn(idx, val)
	{
		IEspRelatedIndexSet &item = (val).item(idx);
		item.Link();
		target.append(item);
	}
}
void CGetRelatedIndexesResponse::setRelatedIndexSets(IArrayOf<IConstRelatedIndexSet> &val)
{
	m_RelatedIndexSets->kill();
	IArrayOf<IConstRelatedIndexSet> &target = m_RelatedIndexSets.getValue();
	ForEachItemIn(idx, val)
	{
		IConstRelatedIndexSet &item = val.item(idx);
		item.Link();
		target.append(item);
	}
}
extern "C"  IEspGetRelatedIndexesResponse *createGetRelatedIndexesResponse(const char *serv){return ((IEspGetRelatedIndexesResponse *)new CGetRelatedIndexesResponse(serv));}
extern "C"  IClientGetRelatedIndexesResponse *createClientGetRelatedIndexesResponse(const char *serv){return ((IClientGetRelatedIndexesResponse *)new CGetRelatedIndexesResponse(serv));}

//=======================================================
// class CSetRelatedIndexesRequest Implementation
//=======================================================

CSetRelatedIndexesRequest::CSetRelatedIndexesRequest(const char *serviceName, IRpcMessageBinding *init)
	: m_RelatedIndexSets(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("SetRelatedIndexesRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CSetRelatedIndexesRequest::CSetRelatedIndexesRequest(const char *serviceName, const char *bc)
	: m_RelatedIndexSets(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("SetRelatedIndexesRequest");
}

CSetRelatedIndexesRequest::CSetRelatedIndexesRequest(const char *serviceName, IRpcMessage* rpcmsg)
	: m_RelatedIndexSets(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("SetRelatedIndexesRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CSetRelatedIndexesRequest::CSetRelatedIndexesRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_RelatedIndexSets(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("SetRelatedIndexesRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CSetRelatedIndexesRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"RelatedIndexSets\">\n");
		schema.append("<xsd:complexType><xsd:sequence>\n");
		schema.append("<xsd:element minOccurs=\"0\" maxOccurs=\"unbounded\" name=\"RelatedIndexSet\" type=\"tns:RelatedIndexSet\"/>");
		schema.append("</xsd:sequence></xsd:complexType>");
		schema.append("</xsd:element>");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	if (!(flags & 0x10)  || (flags & 0x100))
	{
		CRelatedIndexSet::getXsdDefinition(context, request, schema, added);
	}
	return schema;
}

void CSetRelatedIndexesRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CSetRelatedIndexesRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
	if (!added.getValue("RelatedIndexSet"))
	{
		added.setValue("RelatedIndexSet",1);
		CRelatedIndexSet::getMapInfo(info,added);
	}
}

StringBuffer &CSetRelatedIndexesRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("RelatedIndexSets");
	form.appendf("<tr><td><b>RelatedIndexSets: </b></td><td>");
	form.appendf("<table><tr><td><textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea></td>", extfix.str());
	form.append("</tr></table>");
	form.append("</td></tr>");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CSetRelatedIndexesRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CSetRelatedIndexesRequest::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_RelatedIndexSets.marshall(rpc_resp, "RelatedIndexSets", "RelatedIndexSet");
}


void CSetRelatedIndexesRequest::copy(CSetRelatedIndexesRequest &from)
{
	m_RelatedIndexSets.copy(from.m_RelatedIndexSets);
}


void CSetRelatedIndexesRequest::copy(IConstSetRelatedIndexesRequest &ifrom)
{
	setRelatedIndexSets(ifrom.getRelatedIndexSets());
}


void CSetRelatedIndexesRequest::getAttributes(IProperties &attributes)
{
}


void CSetRelatedIndexesRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_RelatedIndexSets.toStr(ctx, buffer, "RelatedIndexSets", "RelatedIndexSet");
}


void CSetRelatedIndexesRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CSetRelatedIndexesRequest::serializer(IEspContext* ctx, IConstSetRelatedIndexesRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<SetRelatedIndexesRequest>");
	// field RelatedIndexSets
	{
		IArrayOf<IConstRelatedIndexSet>& v = src.getRelatedIndexSets();
		int size = v.length();
		if (size>0)
			buffer.append("<RelatedIndexSets>");
		for (int i=0;i<size;i++)
		{
			buffer.append("<RelatedIndexSet>");
			CRelatedIndexSet::serializer(ctx,v.item(i),buffer,false);
			buffer.append("</RelatedIndexSet>");
		}
		if (size>0)
			buffer.append("</RelatedIndexSets>");
	}
	if (keepRootTag)
		buffer.append("</SetRelatedIndexesRequest>");
}

bool CSetRelatedIndexesRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_RelatedIndexSets.unmarshall(rpc_request, "RelatedIndexSets", basepath);
	return hasValue;
}

bool CSetRelatedIndexesRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_RelatedIndexSets.unmarshall(ctx, soapval, "RelatedIndexSets");
	return hasValue;
}

bool CSetRelatedIndexesRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_RelatedIndexSets.unmarshall(ctx, params, attachments, "RelatedIndexSets", basepath);
	return hasValue;
}

IArrayOf<IConstRelatedIndexSet> & CSetRelatedIndexesRequest::getRelatedIndexSets() { return (IArrayOf<IConstRelatedIndexSet> &) m_RelatedIndexSets; }
void CSetRelatedIndexesRequest::setRelatedIndexSets(IArrayOf<IEspRelatedIndexSet> &val)
{
	m_RelatedIndexSets->kill();
	IArrayOf<IConstRelatedIndexSet> &target = m_RelatedIndexSets.getValue();
	ForEachItemIn(idx, val)
	{
		IEspRelatedIndexSet &item = (val).item(idx);
		item.Link();
		target.append(item);
	}
}
void CSetRelatedIndexesRequest::setRelatedIndexSets(IArrayOf<IConstRelatedIndexSet> &val)
{
	m_RelatedIndexSets->kill();
	IArrayOf<IConstRelatedIndexSet> &target = m_RelatedIndexSets.getValue();
	ForEachItemIn(idx, val)
	{
		IConstRelatedIndexSet &item = val.item(idx);
		item.Link();
		target.append(item);
	}
}
extern "C"  IEspSetRelatedIndexesRequest *createSetRelatedIndexesRequest(const char *serv){return ((IEspSetRelatedIndexesRequest *)new CSetRelatedIndexesRequest(serv));}
extern "C"  IClientSetRelatedIndexesRequest *createClientSetRelatedIndexesRequest(const char *serv){return ((IClientSetRelatedIndexesRequest *)new CSetRelatedIndexesRequest(serv));}

//=======================================================
// class CSetRelatedIndexesResponse Implementation
//=======================================================

CSetRelatedIndexesResponse::CSetRelatedIndexesResponse(const char *serviceName, IRpcMessageBinding *init)
	: m_RelatedIndexSets(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("SetRelatedIndexesResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CSetRelatedIndexesResponse::CSetRelatedIndexesResponse(const char *serviceName, const char *bc)
	: m_RelatedIndexSets(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("SetRelatedIndexesResponse");
}

CSetRelatedIndexesResponse::CSetRelatedIndexesResponse(const char *serviceName, IRpcMessage* rpcmsg)
	: m_RelatedIndexSets(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("SetRelatedIndexesResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CSetRelatedIndexesResponse::CSetRelatedIndexesResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_RelatedIndexSets(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("SetRelatedIndexesResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CSetRelatedIndexesResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"RelatedIndexSets\">\n");
		schema.append("<xsd:complexType><xsd:sequence>\n");
		schema.append("<xsd:element minOccurs=\"0\" maxOccurs=\"unbounded\" name=\"RelatedIndexSet\" type=\"tns:RelatedIndexSet\"/>");
		schema.append("</xsd:sequence></xsd:complexType>");
		schema.append("</xsd:element>");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	if (!(flags & 0x10)  || (flags & 0x100))
	{
		CRelatedIndexSet::getXsdDefinition(context, request, schema, added);
	}
	return schema;
}

void CSetRelatedIndexesResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CSetRelatedIndexesResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
	if (!added.getValue("RelatedIndexSet"))
	{
		added.setValue("RelatedIndexSet",1);
		CRelatedIndexSet::getMapInfo(info,added);
	}
}

StringBuffer &CSetRelatedIndexesResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("RelatedIndexSets");
	form.appendf("<tr><td><b>RelatedIndexSets: </b></td><td>");
	form.appendf("<table><tr><td><textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea></td>", extfix.str());
	form.append("</tr></table>");
	form.append("</td></tr>");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CSetRelatedIndexesResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CSetRelatedIndexesResponse::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
		m_RelatedIndexSets.marshall(rpc_resp, "RelatedIndexSets", "RelatedIndexSet");
	}
}


void CSetRelatedIndexesResponse::copy(CSetRelatedIndexesResponse &from)
{
	m_RelatedIndexSets.copy(from.m_RelatedIndexSets);
}


void CSetRelatedIndexesResponse::copy(IConstSetRelatedIndexesResponse &ifrom)
{
	setRelatedIndexSets(ifrom.getRelatedIndexSets());
}


void CSetRelatedIndexesResponse::getAttributes(IProperties &attributes)
{
}


void CSetRelatedIndexesResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
		m_RelatedIndexSets.toStr(ctx, buffer, "RelatedIndexSets", "RelatedIndexSet");
	}
}


void CSetRelatedIndexesResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CSetRelatedIndexesResponse::serializer(IEspContext* ctx, IConstSetRelatedIndexesResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<SetRelatedIndexesResponse>");
	// field RelatedIndexSets
	{
		IArrayOf<IConstRelatedIndexSet>& v = src.getRelatedIndexSets();
		int size = v.length();
		if (size>0)
			buffer.append("<RelatedIndexSets>");
		for (int i=0;i<size;i++)
		{
			buffer.append("<RelatedIndexSet>");
			CRelatedIndexSet::serializer(ctx,v.item(i),buffer,false);
			buffer.append("</RelatedIndexSet>");
		}
		if (size>0)
			buffer.append("</RelatedIndexSets>");
	}
	if (keepRootTag)
		buffer.append("</SetRelatedIndexesResponse>");
}

bool CSetRelatedIndexesResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
		hasValue |= m_RelatedIndexSets.unmarshall(rpc_request, "RelatedIndexSets", basepath);
	}
	return hasValue;
}

bool CSetRelatedIndexesResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_RelatedIndexSets.unmarshall(ctx, soapval, "RelatedIndexSets");
	return hasValue;
}

bool CSetRelatedIndexesResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_RelatedIndexSets.unmarshall(ctx, params, attachments, "RelatedIndexSets", basepath);
	return hasValue;
}

IArrayOf<IConstRelatedIndexSet> & CSetRelatedIndexesResponse::getRelatedIndexSets() { return (IArrayOf<IConstRelatedIndexSet> &) m_RelatedIndexSets; }
void CSetRelatedIndexesResponse::setRelatedIndexSets(IArrayOf<IEspRelatedIndexSet> &val)
{
	m_RelatedIndexSets->kill();
	IArrayOf<IConstRelatedIndexSet> &target = m_RelatedIndexSets.getValue();
	ForEachItemIn(idx, val)
	{
		IEspRelatedIndexSet &item = (val).item(idx);
		item.Link();
		target.append(item);
	}
}
void CSetRelatedIndexesResponse::setRelatedIndexSets(IArrayOf<IConstRelatedIndexSet> &val)
{
	m_RelatedIndexSets->kill();
	IArrayOf<IConstRelatedIndexSet> &target = m_RelatedIndexSets.getValue();
	ForEachItemIn(idx, val)
	{
		IConstRelatedIndexSet &item = val.item(idx);
		item.Link();
		target.append(item);
	}
}
extern "C"  IEspSetRelatedIndexesResponse *createSetRelatedIndexesResponse(const char *serv){return ((IEspSetRelatedIndexesResponse *)new CSetRelatedIndexesResponse(serv));}
extern "C"  IClientSetRelatedIndexesResponse *createClientSetRelatedIndexesResponse(const char *serv){return ((IClientSetRelatedIndexesResponse *)new CSetRelatedIndexesResponse(serv));}

//=======================================================
// class CEclFieldType Implementation
//=======================================================

CEclFieldType::CEclFieldType(const char *serviceName, IRpcMessageBinding *init)
	: m_Type(nilIgnore),m_Locale(nilIgnore),m_Length(nilIgnore),m_Precision(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("EclFieldType");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CEclFieldType::CEclFieldType(const char *serviceName, const char *bc)
	: m_Type(nilIgnore),m_Locale(nilIgnore),m_Length(nilIgnore),m_Precision(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("EclFieldType");
}

StringBuffer &CEclFieldType::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:complexType name=\"%s\">\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Type\" type=\"tns:HPCCFieldType\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Locale\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Length\" type=\"xsd:integer\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Precision\" type=\"xsd:integer\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType>\n");
		}
	}
	if (!(flags & 0x10)  || (flags & 0x100))
	{
		CXHPCCFieldType::getXsdDefinition(context, request, schema, added);
	}
	return schema;
}

void CEclFieldType::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CEclFieldType::getMapInfo(IMapInfo& info, BoolHash& added)
{
	if (!added.getValue("HPCCFieldType"))
	{
		added.setValue("HPCCFieldType",1);
		CXHPCCFieldType::getMapInfo(info,added);
	}
}

StringBuffer &CEclFieldType::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Type");
	form.appendf("  <tr><td><b>Type: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Locale");
	form.appendf("  <tr><td><b>Locale: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix) extfix.append(prefix).append(".");
		extfix.append("Length");
	form.appendf("  <tr><td><b>Length: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix) extfix.append(prefix).append(".");
		extfix.append("Precision");
	form.appendf("  <tr><td><b>Precision: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CEclFieldType::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CEclFieldType::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_Type.marshall(rpc_resp, "Type", "", "", "");
	m_Locale.marshall(rpc_resp, "Locale", "", "", "");
	m_Length.marshall(rpc_resp, "Length", "", "", "");
	m_Precision.marshall(rpc_resp, "Precision", "", "", "");
}


void CEclFieldType::copy(CEclFieldType &from)
{
	m_Type.copy(from.m_Type);
	m_Locale.copy(from.m_Locale);
	m_Length.copy(from.m_Length);
	m_Precision.copy(from.m_Precision);
}


void CEclFieldType::copy(IConstEclFieldType &ifrom)
{
	setType(ifrom.getType());
	setLocale(ifrom.getLocale());
	setLength(ifrom.getLength());
	setPrecision(ifrom.getPrecision());
}


void CEclFieldType::getAttributes(IProperties &attributes)
{
}


void CEclFieldType::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_Type.toStr(ctx, buffer, "Type", "", true, "", "");
	m_Locale.toStr(ctx, buffer, "Locale", "", true, "", "");
	m_Length.toStr(ctx, buffer, "Length", "", true, "", "");
	m_Precision.toStr(ctx, buffer, "Precision", "", true, "", "");
}


void CEclFieldType::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CEclFieldType::serializer(IEspContext* ctx, IConstEclFieldType &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<EclFieldType>");
	// field Type
	{
		const char* s = src.getTypeAsString();
		buffer.append("<Type>");
		encodeUtf8XML(s,buffer);
		buffer.append("</Type>");
	}
	// field Locale
	{
		const char* s = src.getLocale();
		if (s && *s)
		{
			buffer.append("<Locale>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Locale>");
		}
	}
	// field Length
	{
		int n = src.getLength();
		if (n)
			buffer.appendf("<Length>%d</Length>", n);
	}
	// field Precision
	{
		int n = src.getPrecision();
		if (n)
			buffer.appendf("<Precision>%d</Precision>", n);
	}
	if (keepRootTag)
		buffer.append("</EclFieldType>");
}

bool CEclFieldType::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_Type.unmarshall(rpc_request, "Type", basepath);
	hasValue |= m_Locale.unmarshall(rpc_request, "Locale", basepath);
	hasValue |= m_Length.unmarshall(rpc_request, "Length", basepath);
	hasValue |= m_Precision.unmarshall(rpc_request, "Precision", basepath);
	return hasValue;
}

bool CEclFieldType::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Type.unmarshall(ctx, soapval, "Type");
	hasValue |= m_Locale.unmarshall(ctx, soapval, "Locale");
	hasValue |= m_Length.unmarshall(ctx, soapval, "Length");
	hasValue |= m_Precision.unmarshall(ctx, soapval, "Precision");
	return hasValue;
}

bool CEclFieldType::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Type.unmarshall(ctx, params, attachments, "Type", basepath);
	hasValue |= m_Locale.unmarshall(ctx, params, attachments, "Locale", basepath);
	hasValue |= m_Length.unmarshall(ctx, params, attachments, "Length", basepath);
	hasValue |= m_Precision.unmarshall(ctx, params, attachments, "Precision", basepath);
	return hasValue;
}

CHPCCFieldType CEclFieldType::getType() { return m_Type.getValue(); }
const char* CEclFieldType::getTypeAsString() {  return (const char*)m_Type; }
const char * CEclFieldType::getLocale() { return m_Locale.query();}
int CEclFieldType::getLength() { return m_Length;}
int CEclFieldType::getPrecision() { return m_Precision;}
void CEclFieldType::setType(CHPCCFieldType val) { m_Type.setValue(val); }
void CEclFieldType::setType(const char* val) { m_Type.setValue(val); }
void CEclFieldType::setLocale(const char * val){ m_Locale.set(val); }
void CEclFieldType::setLength(int val){ m_Length=val; }
void CEclFieldType::setPrecision(int val){ m_Precision=val; }
extern "C"  IEspEclFieldType *createEclFieldType(const char *serv, const char *msgname){return ((IEspEclFieldType *)new CEclFieldType(serv /*, msgname*/));}
extern "C"  IClientEclFieldType *createClientEclFieldType(const char *serv, const char *msgname){return ((IClientEclFieldType *)new CEclFieldType(serv /*, msgname*/));}

//=======================================================
// class CEclFieldDeclaration Implementation
//=======================================================

CEclFieldDeclaration::CEclFieldDeclaration(const char *serviceName, IRpcMessageBinding *init)
	: m_FieldName(nilIgnore),m_EclFieldType(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("EclFieldDeclaration");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CEclFieldDeclaration::CEclFieldDeclaration(const char *serviceName, const char *bc)
	: m_FieldName(nilIgnore),m_EclFieldType(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("EclFieldDeclaration");
}

StringBuffer &CEclFieldDeclaration::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:complexType name=\"%s\">\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"FieldName\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"EclFieldType\" type=\"tns:EclFieldType\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType>\n");
		}
	}
	if (!(flags & 0x10)  || (flags & 0x100))
	{
		CEclFieldType::getXsdDefinition(context, request, schema, added);
	}
	return schema;
}

void CEclFieldDeclaration::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CEclFieldDeclaration::getMapInfo(IMapInfo& info, BoolHash& added)
{
	if (!added.getValue("EclFieldType"))
	{
		added.setValue("EclFieldType",1);
		CEclFieldType::getMapInfo(info,added);
	}
}

StringBuffer &CEclFieldDeclaration::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("FieldName");
	form.appendf("  <tr><td><b>FieldName: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("EclFieldType");
	form.append("<tr>").append("<td><b>EclFieldType: </b></td><td><hr/>");
	CEclFieldType::getHtmlForm(context, request, serv, method, form, false, extfix.str());
	form.append("<hr/></td></tr>");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CEclFieldDeclaration::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CEclFieldDeclaration::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_FieldName.marshall(rpc_resp, "FieldName", "", "", "");
	m_EclFieldType.marshall(rpc_resp, "EclFieldType", "", "", "");
}


void CEclFieldDeclaration::copy(CEclFieldDeclaration &from)
{
	m_FieldName.copy(from.m_FieldName);
	m_EclFieldType.copy(from.m_EclFieldType);
}


void CEclFieldDeclaration::copy(IConstEclFieldDeclaration &ifrom)
{
	setFieldName(ifrom.getFieldName());
	setEclFieldType(ifrom.getEclFieldType());
}


void CEclFieldDeclaration::getAttributes(IProperties &attributes)
{
}


void CEclFieldDeclaration::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_FieldName.toStr(ctx, buffer, "FieldName", "", true, "", "");
	m_EclFieldType.toStr(ctx, buffer, "EclFieldType", "", false, "", "");
}


void CEclFieldDeclaration::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CEclFieldDeclaration::serializer(IEspContext* ctx, IConstEclFieldDeclaration &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<EclFieldDeclaration>");
	// field FieldName
	{
		const char* s = src.getFieldName();
		if (s && *s)
		{
			buffer.append("<FieldName>");
			encodeUtf8XML(s,buffer);
			buffer.append("</FieldName>");
		}
	}
	// field EclFieldType
	{
		StringBuffer tmp;
		CEclFieldType::serializer(ctx,src.getEclFieldType(), tmp, false);
		if (tmp.length()>0)
			buffer.appendf("<EclFieldType>%s</EclFieldType>",tmp.str());
	}
	if (keepRootTag)
		buffer.append("</EclFieldDeclaration>");
}

bool CEclFieldDeclaration::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_FieldName.unmarshall(rpc_request, "FieldName", basepath);
	hasValue |= m_EclFieldType.unmarshall(rpc_request, "EclFieldType", basepath);
	return hasValue;
}

bool CEclFieldDeclaration::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_FieldName.unmarshall(ctx, soapval, "FieldName");
	hasValue |= m_EclFieldType.unmarshall(ctx, soapval, "EclFieldType");
	return hasValue;
}

bool CEclFieldDeclaration::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_FieldName.unmarshall(ctx, params, attachments, "FieldName", basepath);
	hasValue |= m_EclFieldType.unmarshall(ctx, params, attachments, "EclFieldType", basepath);
	return hasValue;
}

const char * CEclFieldDeclaration::getFieldName() { return m_FieldName.query();}
IConstEclFieldType & CEclFieldDeclaration::getEclFieldType() { return (IConstEclFieldType &) m_EclFieldType.getValue();}
void CEclFieldDeclaration::setFieldName(const char * val){ m_FieldName.set(val); }
IEspEclFieldType & CEclFieldDeclaration::updateEclFieldType(){ return (IEspEclFieldType &) m_EclFieldType.getValue(); }
void CEclFieldDeclaration::setEclFieldType(IConstEclFieldType &ifrom){ m_EclFieldType.copy(ifrom); }
extern "C"  IEspEclFieldDeclaration *createEclFieldDeclaration(const char *serv, const char *msgname){return ((IEspEclFieldDeclaration *)new CEclFieldDeclaration(serv /*, msgname*/));}
extern "C"  IClientEclFieldDeclaration *createClientEclFieldDeclaration(const char *serv, const char *msgname){return ((IClientEclFieldDeclaration *)new CEclFieldDeclaration(serv /*, msgname*/));}

//=======================================================
// class CDataTypeParam Implementation
//=======================================================

CDataTypeParam::CDataTypeParam(const char *serviceName, IRpcMessageBinding *init)
	: m_Name(nilIgnore),m_Values(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("DataTypeParam");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CDataTypeParam::CDataTypeParam(const char *serviceName, const char *bc)
	: m_Name(nilIgnore),m_Values(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("DataTypeParam");
}

StringBuffer &CDataTypeParam::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:complexType name=\"%s\">\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Name\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Values\">");
		schema.append("<xsd:complexType><xsd:sequence>");
		schema.append("<xsd:element name=\"Value\" type=\"xsd:string\" minOccurs=\"0\" maxOccurs=\"unbounded\"/>\n");
		schema.append("</xsd:sequence></xsd:complexType>\n");
		schema.append("</xsd:element>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType>\n");
		}
	}
	return schema;
}

void CDataTypeParam::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CDataTypeParam::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CDataTypeParam::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Name");
	form.appendf("  <tr><td><b>Name: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Values");
	form.appendf("<tr><td><b>Values: </b></td><td>");
	form.appendf("<textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea>", extfix.str());
	form.append("</td></tr>");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CDataTypeParam::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CDataTypeParam::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_Name.marshall(rpc_resp, "Name", "", "", "");
	m_Values.marshall(rpc_resp, "Values", "Value");
}


void CDataTypeParam::copy(CDataTypeParam &from)
{
	m_Name.copy(from.m_Name);
	m_Values.copy(from.m_Values);
}


void CDataTypeParam::copy(IConstDataTypeParam &ifrom)
{
	setName(ifrom.getName());
	setValues(ifrom.getValues());
}


void CDataTypeParam::getAttributes(IProperties &attributes)
{
}


void CDataTypeParam::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_Name.toStr(ctx, buffer, "Name", "", true, "", "");
	m_Values.toStr(ctx, buffer, "Values", "Value");
}


void CDataTypeParam::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CDataTypeParam::serializer(IEspContext* ctx, IConstDataTypeParam &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<DataTypeParam>");
	// field Name
	{
		const char* s = src.getName();
		if (s && *s)
		{
			buffer.append("<Name>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Name>");
		}
	}
	// field Values
	{
		StringArray& v = src.getValues();
		if (v.length()>0)
			buffer.append("<Values>");
		for (size32_t i=0;i<v.length();i++)
			buffer.appendf("<Value>%s</Value>",v.item(i));
		if (v.length()>0)
			buffer.append("</Values>");
	}
	if (keepRootTag)
		buffer.append("</DataTypeParam>");
}

bool CDataTypeParam::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_Name.unmarshall(rpc_request, "Name", basepath);
	hasValue |= m_Values.unmarshall(rpc_request, "Values", basepath);
	return hasValue;
}

bool CDataTypeParam::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Name.unmarshall(ctx, soapval, "Name");
	hasValue |= m_Values.unmarshall(ctx, soapval, "Values");
	return hasValue;
}

bool CDataTypeParam::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Name.unmarshall(ctx, params, attachments, "Name", basepath);
	hasValue |= m_Values.unmarshall(ctx, params, attachments, "Values", basepath);
	return hasValue;
}

const char * CDataTypeParam::getName() { return m_Name.query();}
StringArray & CDataTypeParam::getValues() { return (StringArray &) m_Values; }
void CDataTypeParam::setName(const char * val){ m_Name.set(val); }
void CDataTypeParam::setValues(StringArray &val){ m_Values->kill();  CloneArray(m_Values.getValue(), val); }
extern "C"  IEspDataTypeParam *createDataTypeParam(const char *serv, const char *msgname){return ((IEspDataTypeParam *)new CDataTypeParam(serv /*, msgname*/));}
extern "C"  IClientDataTypeParam *createClientDataTypeParam(const char *serv, const char *msgname){return ((IClientDataTypeParam *)new CDataTypeParam(serv /*, msgname*/));}

//=======================================================
// class CDataType Implementation
//=======================================================

CDataType::CDataType(const char *serviceName, IRpcMessageBinding *init)
	: m_Type(nilIgnore),m_Params(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("DataType");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CDataType::CDataType(const char *serviceName, const char *bc)
	: m_Type(nilIgnore),m_Params(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("DataType");
}

StringBuffer &CDataType::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:complexType name=\"%s\">\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Type\" type=\"tns:HPCCFileType\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Params\">\n");
		schema.append("<xsd:complexType><xsd:sequence>\n");
		schema.append("<xsd:element minOccurs=\"0\" maxOccurs=\"unbounded\" name=\"Param\" type=\"tns:DataTypeParam\"/>");
		schema.append("</xsd:sequence></xsd:complexType>");
		schema.append("</xsd:element>");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType>\n");
		}
	}
	if (!(flags & 0x10)  || (flags & 0x100))
	{
		CXHPCCFileType::getXsdDefinition(context, request, schema, added);
		CDataTypeParam::getXsdDefinition(context, request, schema, added);
	}
	return schema;
}

void CDataType::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CDataType::getMapInfo(IMapInfo& info, BoolHash& added)
{
	if (!added.getValue("DataTypeParam"))
	{
		added.setValue("DataTypeParam",1);
		CDataTypeParam::getMapInfo(info,added);
	}
	if (!added.getValue("HPCCFileType"))
	{
		added.setValue("HPCCFileType",1);
		CXHPCCFileType::getMapInfo(info,added);
	}
}

StringBuffer &CDataType::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Type");
	form.appendf("  <tr><td><b>Type: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Params");
	form.appendf("<tr><td><b>Params: </b></td><td>");
	form.appendf("<table><tr><td><textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea></td>", extfix.str());
	form.append("</tr></table>");
	form.append("</td></tr>");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CDataType::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CDataType::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_Type.marshall(rpc_resp, "Type", "", "", "");
	m_Params.marshall(rpc_resp, "Params", "Param");
}


void CDataType::copy(CDataType &from)
{
	m_Type.copy(from.m_Type);
	m_Params.copy(from.m_Params);
}


void CDataType::copy(IConstDataType &ifrom)
{
	setType(ifrom.getType());
	setParams(ifrom.getParams());
}


void CDataType::getAttributes(IProperties &attributes)
{
}


void CDataType::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_Type.toStr(ctx, buffer, "Type", "", true, "", "");
	m_Params.toStr(ctx, buffer, "Params", "Param");
}


void CDataType::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CDataType::serializer(IEspContext* ctx, IConstDataType &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<DataType>");
	// field Type
	{
		const char* s = src.getTypeAsString();
		buffer.append("<Type>");
		encodeUtf8XML(s,buffer);
		buffer.append("</Type>");
	}
	// field Params
	{
		IArrayOf<IConstDataTypeParam>& v = src.getParams();
		int size = v.length();
		if (size>0)
			buffer.append("<Params>");
		for (int i=0;i<size;i++)
		{
			buffer.append("<Param>");
			CDataTypeParam::serializer(ctx,v.item(i),buffer,false);
			buffer.append("</Param>");
		}
		if (size>0)
			buffer.append("</Params>");
	}
	if (keepRootTag)
		buffer.append("</DataType>");
}

bool CDataType::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_Type.unmarshall(rpc_request, "Type", basepath);
	hasValue |= m_Params.unmarshall(rpc_request, "Params", basepath);
	return hasValue;
}

bool CDataType::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Type.unmarshall(ctx, soapval, "Type");
	hasValue |= m_Params.unmarshall(ctx, soapval, "Params");
	return hasValue;
}

bool CDataType::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Type.unmarshall(ctx, params, attachments, "Type", basepath);
	hasValue |= m_Params.unmarshall(ctx, params, attachments, "Params", basepath);
	return hasValue;
}

CHPCCFileType CDataType::getType() { return m_Type.getValue(); }
const char* CDataType::getTypeAsString() {  return (const char*)m_Type; }
IArrayOf<IConstDataTypeParam> & CDataType::getParams() { return (IArrayOf<IConstDataTypeParam> &) m_Params; }
void CDataType::setType(CHPCCFileType val) { m_Type.setValue(val); }
void CDataType::setType(const char* val) { m_Type.setValue(val); }
void CDataType::setParams(IArrayOf<IEspDataTypeParam> &val)
{
	m_Params->kill();
	IArrayOf<IConstDataTypeParam> &target = m_Params.getValue();
	ForEachItemIn(idx, val)
	{
		IEspDataTypeParam &item = (val).item(idx);
		item.Link();
		target.append(item);
	}
}
void CDataType::setParams(IArrayOf<IConstDataTypeParam> &val)
{
	m_Params->kill();
	IArrayOf<IConstDataTypeParam> &target = m_Params.getValue();
	ForEachItemIn(idx, val)
	{
		IConstDataTypeParam &item = val.item(idx);
		item.Link();
		target.append(item);
	}
}
extern "C"  IEspDataType *createDataType(const char *serv, const char *msgname){return ((IEspDataType *)new CDataType(serv /*, msgname*/));}
extern "C"  IClientDataType *createClientDataType(const char *serv, const char *msgname){return ((IClientDataType *)new CDataType(serv /*, msgname*/));}

//=======================================================
// class CDataSourceInfo Implementation
//=======================================================

CDataSourceInfo::CDataSourceInfo(const char *serviceName, IRpcMessageBinding *init)
	: m_SprayedFileName(nilIgnore),m_LandingZoneIP(nilIgnore),m_LandingZonePath(nilIgnore),m_LandingZoneFileName(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("DataSourceInfo");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CDataSourceInfo::CDataSourceInfo(const char *serviceName, const char *bc)
	: m_SprayedFileName(nilIgnore),m_LandingZoneIP(nilIgnore),m_LandingZonePath(nilIgnore),m_LandingZoneFileName(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("DataSourceInfo");
}

StringBuffer &CDataSourceInfo::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:complexType name=\"%s\">\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"SprayedFileName\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"LandingZoneIP\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"LandingZonePath\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"LandingZoneFileName\" type=\"xsd:string\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType>\n");
		}
	}
	return schema;
}

void CDataSourceInfo::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CDataSourceInfo::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CDataSourceInfo::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("SprayedFileName");
	form.appendf("  <tr><td><b>SprayedFileName: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("LandingZoneIP");
	form.appendf("  <tr><td><b>LandingZoneIP: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("LandingZonePath");
	form.appendf("  <tr><td><b>LandingZonePath: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("LandingZoneFileName");
	form.appendf("  <tr><td><b>LandingZoneFileName: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CDataSourceInfo::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CDataSourceInfo::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_SprayedFileName.marshall(rpc_resp, "SprayedFileName", "", "", "");
	m_LandingZoneIP.marshall(rpc_resp, "LandingZoneIP", "", "", "");
	m_LandingZonePath.marshall(rpc_resp, "LandingZonePath", "", "", "");
	m_LandingZoneFileName.marshall(rpc_resp, "LandingZoneFileName", "", "", "");
}


void CDataSourceInfo::copy(CDataSourceInfo &from)
{
	m_SprayedFileName.copy(from.m_SprayedFileName);
	m_LandingZoneIP.copy(from.m_LandingZoneIP);
	m_LandingZonePath.copy(from.m_LandingZonePath);
	m_LandingZoneFileName.copy(from.m_LandingZoneFileName);
}


void CDataSourceInfo::copy(IConstDataSourceInfo &ifrom)
{
	setSprayedFileName(ifrom.getSprayedFileName());
	setLandingZoneIP(ifrom.getLandingZoneIP());
	setLandingZonePath(ifrom.getLandingZonePath());
	setLandingZoneFileName(ifrom.getLandingZoneFileName());
}


void CDataSourceInfo::getAttributes(IProperties &attributes)
{
}


void CDataSourceInfo::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_SprayedFileName.toStr(ctx, buffer, "SprayedFileName", "", true, "", "");
	m_LandingZoneIP.toStr(ctx, buffer, "LandingZoneIP", "", true, "", "");
	m_LandingZonePath.toStr(ctx, buffer, "LandingZonePath", "", true, "", "");
	m_LandingZoneFileName.toStr(ctx, buffer, "LandingZoneFileName", "", true, "", "");
}


void CDataSourceInfo::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CDataSourceInfo::serializer(IEspContext* ctx, IConstDataSourceInfo &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<DataSourceInfo>");
	// field SprayedFileName
	{
		const char* s = src.getSprayedFileName();
		if (s && *s)
		{
			buffer.append("<SprayedFileName>");
			encodeUtf8XML(s,buffer);
			buffer.append("</SprayedFileName>");
		}
	}
	// field LandingZoneIP
	{
		const char* s = src.getLandingZoneIP();
		if (s && *s)
		{
			buffer.append("<LandingZoneIP>");
			encodeUtf8XML(s,buffer);
			buffer.append("</LandingZoneIP>");
		}
	}
	// field LandingZonePath
	{
		const char* s = src.getLandingZonePath();
		if (s && *s)
		{
			buffer.append("<LandingZonePath>");
			encodeUtf8XML(s,buffer);
			buffer.append("</LandingZonePath>");
		}
	}
	// field LandingZoneFileName
	{
		const char* s = src.getLandingZoneFileName();
		if (s && *s)
		{
			buffer.append("<LandingZoneFileName>");
			encodeUtf8XML(s,buffer);
			buffer.append("</LandingZoneFileName>");
		}
	}
	if (keepRootTag)
		buffer.append("</DataSourceInfo>");
}

bool CDataSourceInfo::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_SprayedFileName.unmarshall(rpc_request, "SprayedFileName", basepath);
	hasValue |= m_LandingZoneIP.unmarshall(rpc_request, "LandingZoneIP", basepath);
	hasValue |= m_LandingZonePath.unmarshall(rpc_request, "LandingZonePath", basepath);
	hasValue |= m_LandingZoneFileName.unmarshall(rpc_request, "LandingZoneFileName", basepath);
	return hasValue;
}

bool CDataSourceInfo::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_SprayedFileName.unmarshall(ctx, soapval, "SprayedFileName");
	hasValue |= m_LandingZoneIP.unmarshall(ctx, soapval, "LandingZoneIP");
	hasValue |= m_LandingZonePath.unmarshall(ctx, soapval, "LandingZonePath");
	hasValue |= m_LandingZoneFileName.unmarshall(ctx, soapval, "LandingZoneFileName");
	return hasValue;
}

bool CDataSourceInfo::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_SprayedFileName.unmarshall(ctx, params, attachments, "SprayedFileName", basepath);
	hasValue |= m_LandingZoneIP.unmarshall(ctx, params, attachments, "LandingZoneIP", basepath);
	hasValue |= m_LandingZonePath.unmarshall(ctx, params, attachments, "LandingZonePath", basepath);
	hasValue |= m_LandingZoneFileName.unmarshall(ctx, params, attachments, "LandingZoneFileName", basepath);
	return hasValue;
}

const char * CDataSourceInfo::getSprayedFileName() { return m_SprayedFileName.query();}
const char * CDataSourceInfo::getLandingZoneIP() { return m_LandingZoneIP.query();}
const char * CDataSourceInfo::getLandingZonePath() { return m_LandingZonePath.query();}
const char * CDataSourceInfo::getLandingZoneFileName() { return m_LandingZoneFileName.query();}
void CDataSourceInfo::setSprayedFileName(const char * val){ m_SprayedFileName.set(val); }
void CDataSourceInfo::setLandingZoneIP(const char * val){ m_LandingZoneIP.set(val); }
void CDataSourceInfo::setLandingZonePath(const char * val){ m_LandingZonePath.set(val); }
void CDataSourceInfo::setLandingZoneFileName(const char * val){ m_LandingZoneFileName.set(val); }
extern "C"  IEspDataSourceInfo *createDataSourceInfo(const char *serv, const char *msgname){return ((IEspDataSourceInfo *)new CDataSourceInfo(serv /*, msgname*/));}
extern "C"  IClientDataSourceInfo *createClientDataSourceInfo(const char *serv, const char *msgname){return ((IClientDataSourceInfo *)new CDataSourceInfo(serv /*, msgname*/));}

//=======================================================
// class CCreateTableAndLoadRequest Implementation
//=======================================================

CCreateTableAndLoadRequest::CCreateTableAndLoadRequest(const char *serviceName, IRpcMessageBinding *init)
	: m_TableName(nilIgnore),m_TableDescription(nilIgnore),m_Overwrite(nilIgnore),m_EclFields(nilIgnore),m_TargetCluster(nilIgnore),m_Owner(nilIgnore),m_DataSource(serviceName, nilIgnore),m_DataSourceType(serviceName, nilIgnore),m_Wait(-1, nilIgnore,false)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("CreateTableAndLoadRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CCreateTableAndLoadRequest::CCreateTableAndLoadRequest(const char *serviceName, const char *bc)
	: m_TableName(nilIgnore),m_TableDescription(nilIgnore),m_Overwrite(nilIgnore),m_EclFields(nilIgnore),m_TargetCluster(nilIgnore),m_Owner(nilIgnore),m_DataSource(serviceName, nilIgnore),m_DataSourceType(serviceName, nilIgnore),m_Wait(-1, nilIgnore,false)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("CreateTableAndLoadRequest");
}

CCreateTableAndLoadRequest::CCreateTableAndLoadRequest(const char *serviceName, IRpcMessage* rpcmsg)
	: m_TableName(nilIgnore),m_TableDescription(nilIgnore),m_Overwrite(nilIgnore),m_EclFields(nilIgnore),m_TargetCluster(nilIgnore),m_Owner(nilIgnore),m_DataSource(serviceName, nilIgnore),m_DataSourceType(serviceName, nilIgnore),m_Wait(-1, nilIgnore,false)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("CreateTableAndLoadRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CCreateTableAndLoadRequest::CCreateTableAndLoadRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_TableName(nilIgnore),m_TableDescription(nilIgnore),m_Overwrite(nilIgnore),m_EclFields(nilIgnore),m_TargetCluster(nilIgnore),m_Owner(nilIgnore),m_DataSource(serviceName, nilIgnore),m_DataSourceType(serviceName, nilIgnore),m_Wait(-1, nilIgnore,false)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("CreateTableAndLoadRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CCreateTableAndLoadRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"TableName\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"TableDescription\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Overwrite\" type=\"xsd:boolean\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"EclFields\">\n");
		schema.append("<xsd:complexType><xsd:sequence>\n");
		schema.append("<xsd:element minOccurs=\"0\" maxOccurs=\"unbounded\" name=\"EclField\" type=\"tns:EclFieldDeclaration\"/>");
		schema.append("</xsd:sequence></xsd:complexType>");
		schema.append("</xsd:element>");
		schema.append("<xsd:element minOccurs=\"0\" name=\"TargetCluster\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Owner\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"DataSource\" type=\"tns:DataSourceInfo\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"DataSourceType\" type=\"tns:DataType\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" default=\"-1\" name=\"Wait\" type=\"xsd:int\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	if (!(flags & 0x10)  || (flags & 0x100))
	{
		CEclFieldDeclaration::getXsdDefinition(context, request, schema, added);
		CDataSourceInfo::getXsdDefinition(context, request, schema, added);
		CDataType::getXsdDefinition(context, request, schema, added);
	}
	return schema;
}

void CCreateTableAndLoadRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CCreateTableAndLoadRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
	if (!added.getValue("DataSourceInfo"))
	{
		added.setValue("DataSourceInfo",1);
		CDataSourceInfo::getMapInfo(info,added);
	}
	if (!added.getValue("DataType"))
	{
		added.setValue("DataType",1);
		CDataType::getMapInfo(info,added);
	}
	if (!added.getValue("EclFieldDeclaration"))
	{
		added.setValue("EclFieldDeclaration",1);
		CEclFieldDeclaration::getMapInfo(info,added);
	}
}

StringBuffer &CCreateTableAndLoadRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("TableName");
	form.appendf("  <tr><td><b>TableName: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("TableDescription");
	form.appendf("  <tr><td><b>TableDescription: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Overwrite");
	
	form.appendf("  <tr><td><b>Overwrite? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("EclFields");
	form.appendf("<tr><td><b>EclFields: </b></td><td>");
	form.appendf("<table><tr><td><textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea></td>", extfix.str());
	form.append("</tr></table>");
	form.append("</td></tr>");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("TargetCluster");
	form.appendf("  <tr><td><b>TargetCluster: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Owner");
	form.appendf("  <tr><td><b>Owner: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("DataSource");
	form.append("<tr>").append("<td><b>DataSource: </b></td><td><hr/>");
	CDataSourceInfo::getHtmlForm(context, request, serv, method, form, false, extfix.str());
	form.append("<hr/></td></tr>");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("DataSourceType");
	form.append("<tr>").append("<td><b>DataSourceType: </b></td><td><hr/>");
	CDataType::getHtmlForm(context, request, serv, method, form, false, extfix.str());
	form.append("<hr/></td></tr>");
	extfix.clear();
	if (prefix && *prefix) extfix.append(prefix).append(".");
		extfix.append("Wait");
	form.appendf("  <tr><td><b>Wait: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"	 value=\"-1\"/>", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CCreateTableAndLoadRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CCreateTableAndLoadRequest::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_TableName.marshall(rpc_resp, "TableName", "", "", "");
	m_TableDescription.marshall(rpc_resp, "TableDescription", "", "", "");
	m_Overwrite.marshall(rpc_resp, "Overwrite", "", "", "");
	m_EclFields.marshall(rpc_resp, "EclFields", "EclField");
	m_TargetCluster.marshall(rpc_resp, "TargetCluster", "", "", "");
	m_Owner.marshall(rpc_resp, "Owner", "", "", "");
	m_DataSource.marshall(rpc_resp, "DataSource", "", "", "");
	m_DataSourceType.marshall(rpc_resp, "DataSourceType", "", "", "");
	m_Wait.marshall(rpc_resp, "Wait", "", "", "");
}


void CCreateTableAndLoadRequest::copy(CCreateTableAndLoadRequest &from)
{
	m_TableName.copy(from.m_TableName);
	m_TableDescription.copy(from.m_TableDescription);
	m_Overwrite.copy(from.m_Overwrite);
	m_EclFields.copy(from.m_EclFields);
	m_TargetCluster.copy(from.m_TargetCluster);
	m_Owner.copy(from.m_Owner);
	m_DataSource.copy(from.m_DataSource);
	m_DataSourceType.copy(from.m_DataSourceType);
	m_Wait.copy(from.m_Wait);
}


void CCreateTableAndLoadRequest::copy(IConstCreateTableAndLoadRequest &ifrom)
{
	setTableName(ifrom.getTableName());
	setTableDescription(ifrom.getTableDescription());
	setOverwrite(ifrom.getOverwrite());
	setEclFields(ifrom.getEclFields());
	setTargetCluster(ifrom.getTargetCluster());
	setOwner(ifrom.getOwner());
	setDataSource(ifrom.getDataSource());
	setDataSourceType(ifrom.getDataSourceType());
	setWait(ifrom.getWait());
}


void CCreateTableAndLoadRequest::getAttributes(IProperties &attributes)
{
}


void CCreateTableAndLoadRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_TableName.toStr(ctx, buffer, "TableName", "", true, "", "");
	m_TableDescription.toStr(ctx, buffer, "TableDescription", "", true, "", "");
	m_Overwrite.toStr(ctx, buffer, "Overwrite", "", true, "", "");
	m_EclFields.toStr(ctx, buffer, "EclFields", "EclField");
	m_TargetCluster.toStr(ctx, buffer, "TargetCluster", "", true, "", "");
	m_Owner.toStr(ctx, buffer, "Owner", "", true, "", "");
	m_DataSource.toStr(ctx, buffer, "DataSource", "", false, "", "");
	m_DataSourceType.toStr(ctx, buffer, "DataSourceType", "", false, "", "");
	m_Wait.toStr(ctx, buffer, "Wait", "", true, "", "");
}


void CCreateTableAndLoadRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CCreateTableAndLoadRequest::serializer(IEspContext* ctx, IConstCreateTableAndLoadRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<CreateTableAndLoadRequest>");
	// field TableName
	{
		const char* s = src.getTableName();
		if (s && *s)
		{
			buffer.append("<TableName>");
			encodeUtf8XML(s,buffer);
			buffer.append("</TableName>");
		}
	}
	// field TableDescription
	{
		const char* s = src.getTableDescription();
		if (s && *s)
		{
			buffer.append("<TableDescription>");
			encodeUtf8XML(s,buffer);
			buffer.append("</TableDescription>");
		}
	}
	// field Overwrite
	{
		bool b = src.getOverwrite();
		if (b)
			buffer.appendf("<Overwrite>1</Overwrite>");
	}
	// field EclFields
	{
		IArrayOf<IConstEclFieldDeclaration>& v = src.getEclFields();
		int size = v.length();
		if (size>0)
			buffer.append("<EclFields>");
		for (int i=0;i<size;i++)
		{
			buffer.append("<EclField>");
			CEclFieldDeclaration::serializer(ctx,v.item(i),buffer,false);
			buffer.append("</EclField>");
		}
		if (size>0)
			buffer.append("</EclFields>");
	}
	// field TargetCluster
	{
		const char* s = src.getTargetCluster();
		if (s && *s)
		{
			buffer.append("<TargetCluster>");
			encodeUtf8XML(s,buffer);
			buffer.append("</TargetCluster>");
		}
	}
	// field Owner
	{
		const char* s = src.getOwner();
		if (s && *s)
		{
			buffer.append("<Owner>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Owner>");
		}
	}
	// field DataSource
	{
		StringBuffer tmp;
		CDataSourceInfo::serializer(ctx,src.getDataSource(), tmp, false);
		if (tmp.length()>0)
			buffer.appendf("<DataSource>%s</DataSource>",tmp.str());
	}
	// field DataSourceType
	{
		StringBuffer tmp;
		CDataType::serializer(ctx,src.getDataSourceType(), tmp, false);
		if (tmp.length()>0)
			buffer.appendf("<DataSourceType>%s</DataSourceType>",tmp.str());
	}
	// field Wait
	{
		int n = src.getWait();
		if (n)
			buffer.appendf("<Wait>%d</Wait>", n);
	}
	if (keepRootTag)
		buffer.append("</CreateTableAndLoadRequest>");
}

bool CCreateTableAndLoadRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_TableName.unmarshall(rpc_request, "TableName", basepath);
	hasValue |= m_TableDescription.unmarshall(rpc_request, "TableDescription", basepath);
	hasValue |= m_Overwrite.unmarshall(rpc_request, "Overwrite", basepath);
	hasValue |= m_EclFields.unmarshall(rpc_request, "EclFields", basepath);
	hasValue |= m_TargetCluster.unmarshall(rpc_request, "TargetCluster", basepath);
	hasValue |= m_Owner.unmarshall(rpc_request, "Owner", basepath);
	hasValue |= m_DataSource.unmarshall(rpc_request, "DataSource", basepath);
	hasValue |= m_DataSourceType.unmarshall(rpc_request, "DataSourceType", basepath);
	hasValue |= m_Wait.unmarshall(rpc_request, "Wait", basepath);
	return hasValue;
}

bool CCreateTableAndLoadRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_TableName.unmarshall(ctx, soapval, "TableName");
	hasValue |= m_TableDescription.unmarshall(ctx, soapval, "TableDescription");
	hasValue |= m_Overwrite.unmarshall(ctx, soapval, "Overwrite");
	hasValue |= m_EclFields.unmarshall(ctx, soapval, "EclFields");
	hasValue |= m_TargetCluster.unmarshall(ctx, soapval, "TargetCluster");
	hasValue |= m_Owner.unmarshall(ctx, soapval, "Owner");
	hasValue |= m_DataSource.unmarshall(ctx, soapval, "DataSource");
	hasValue |= m_DataSourceType.unmarshall(ctx, soapval, "DataSourceType");
	hasValue |= m_Wait.unmarshall(ctx, soapval, "Wait");
	return hasValue;
}

bool CCreateTableAndLoadRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_TableName.unmarshall(ctx, params, attachments, "TableName", basepath);
	hasValue |= m_TableDescription.unmarshall(ctx, params, attachments, "TableDescription", basepath);
	hasValue |= m_Overwrite.unmarshall(ctx, params, attachments, "Overwrite", basepath);
	hasValue |= m_EclFields.unmarshall(ctx, params, attachments, "EclFields", basepath);
	hasValue |= m_TargetCluster.unmarshall(ctx, params, attachments, "TargetCluster", basepath);
	hasValue |= m_Owner.unmarshall(ctx, params, attachments, "Owner", basepath);
	hasValue |= m_DataSource.unmarshall(ctx, params, attachments, "DataSource", basepath);
	hasValue |= m_DataSourceType.unmarshall(ctx, params, attachments, "DataSourceType", basepath);
	hasValue |= m_Wait.unmarshall(ctx, params, attachments, "Wait", basepath);
	return hasValue;
}

const char * CCreateTableAndLoadRequest::getTableName() { return m_TableName.query();}
const char * CCreateTableAndLoadRequest::getTableDescription() { return m_TableDescription.query();}
bool CCreateTableAndLoadRequest::getOverwrite() { return m_Overwrite;}
IArrayOf<IConstEclFieldDeclaration> & CCreateTableAndLoadRequest::getEclFields() { return (IArrayOf<IConstEclFieldDeclaration> &) m_EclFields; }
const char * CCreateTableAndLoadRequest::getTargetCluster() { return m_TargetCluster.query();}
const char * CCreateTableAndLoadRequest::getOwner() { return m_Owner.query();}
IConstDataSourceInfo & CCreateTableAndLoadRequest::getDataSource() { return (IConstDataSourceInfo &) m_DataSource.getValue();}
IConstDataType & CCreateTableAndLoadRequest::getDataSourceType() { return (IConstDataType &) m_DataSourceType.getValue();}
int CCreateTableAndLoadRequest::getWait() { return m_Wait;}
void CCreateTableAndLoadRequest::setTableName(const char * val){ m_TableName.set(val); }
void CCreateTableAndLoadRequest::setTableDescription(const char * val){ m_TableDescription.set(val); }
void CCreateTableAndLoadRequest::setOverwrite(bool val){ m_Overwrite=val; }
void CCreateTableAndLoadRequest::setEclFields(IArrayOf<IEspEclFieldDeclaration> &val)
{
	m_EclFields->kill();
	IArrayOf<IConstEclFieldDeclaration> &target = m_EclFields.getValue();
	ForEachItemIn(idx, val)
	{
		IEspEclFieldDeclaration &item = (val).item(idx);
		item.Link();
		target.append(item);
	}
}
void CCreateTableAndLoadRequest::setEclFields(IArrayOf<IConstEclFieldDeclaration> &val)
{
	m_EclFields->kill();
	IArrayOf<IConstEclFieldDeclaration> &target = m_EclFields.getValue();
	ForEachItemIn(idx, val)
	{
		IConstEclFieldDeclaration &item = val.item(idx);
		item.Link();
		target.append(item);
	}
}
void CCreateTableAndLoadRequest::setTargetCluster(const char * val){ m_TargetCluster.set(val); }
void CCreateTableAndLoadRequest::setOwner(const char * val){ m_Owner.set(val); }
IEspDataSourceInfo & CCreateTableAndLoadRequest::updateDataSource(){ return (IEspDataSourceInfo &) m_DataSource.getValue(); }
void CCreateTableAndLoadRequest::setDataSource(IConstDataSourceInfo &ifrom){ m_DataSource.copy(ifrom); }
IEspDataType & CCreateTableAndLoadRequest::updateDataSourceType(){ return (IEspDataType &) m_DataSourceType.getValue(); }
void CCreateTableAndLoadRequest::setDataSourceType(IConstDataType &ifrom){ m_DataSourceType.copy(ifrom); }
void CCreateTableAndLoadRequest::setWait(int val){ m_Wait=val; }
extern "C"  IEspCreateTableAndLoadRequest *createCreateTableAndLoadRequest(const char *serv){return ((IEspCreateTableAndLoadRequest *)new CCreateTableAndLoadRequest(serv));}
extern "C"  IClientCreateTableAndLoadRequest *createClientCreateTableAndLoadRequest(const char *serv){return ((IClientCreateTableAndLoadRequest *)new CCreateTableAndLoadRequest(serv));}

//=======================================================
// class CCreateTableAndLoadResponse Implementation
//=======================================================

CCreateTableAndLoadResponse::CCreateTableAndLoadResponse(const char *serviceName, IRpcMessageBinding *init)
	: m_TableName(nilIgnore),m_Success(nilIgnore),m_EclRecordDefinition(nilIgnore),m_Workunit(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("CreateTableAndLoadResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CCreateTableAndLoadResponse::CCreateTableAndLoadResponse(const char *serviceName, const char *bc)
	: m_TableName(nilIgnore),m_Success(nilIgnore),m_EclRecordDefinition(nilIgnore),m_Workunit(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("CreateTableAndLoadResponse");
}

CCreateTableAndLoadResponse::CCreateTableAndLoadResponse(const char *serviceName, IRpcMessage* rpcmsg)
	: m_TableName(nilIgnore),m_Success(nilIgnore),m_EclRecordDefinition(nilIgnore),m_Workunit(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("CreateTableAndLoadResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CCreateTableAndLoadResponse::CCreateTableAndLoadResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_TableName(nilIgnore),m_Success(nilIgnore),m_EclRecordDefinition(nilIgnore),m_Workunit(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("CreateTableAndLoadResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CCreateTableAndLoadResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"TableName\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Success\" type=\"xsd:boolean\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"EclRecordDefinition\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Workunit\" type=\"tns:ECLWorkunit\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	if (!(flags & 0x10)  || (flags & 0x100))
	{
		CECLWorkunit::getXsdDefinition(context, request, schema, added);
	}
	return schema;
}

void CCreateTableAndLoadResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CCreateTableAndLoadResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
	if (!added.getValue("ECLWorkunit"))
	{
		added.setValue("ECLWorkunit",1);
		CECLWorkunit::getMapInfo(info,added);
	}
}

StringBuffer &CCreateTableAndLoadResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("TableName");
	form.appendf("  <tr><td><b>TableName: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Success");
	
	form.appendf("  <tr><td><b>Success? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("EclRecordDefinition");
	form.appendf("  <tr><td><b>EclRecordDefinition: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Workunit");
	form.append("<tr>").append("<td><b>Workunit: </b></td><td><hr/>");
	CECLWorkunit::getHtmlForm(context, request, serv, method, form, false, extfix.str());
	form.append("<hr/></td></tr>");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CCreateTableAndLoadResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CCreateTableAndLoadResponse::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
		m_TableName.marshall(rpc_resp, "TableName", "", "", "");
		m_Success.marshall(rpc_resp, "Success", "", "", "");
		m_EclRecordDefinition.marshall(rpc_resp, "EclRecordDefinition", "", "", "");
		m_Workunit.marshall(rpc_resp, "Workunit", "", "", "");
	}
}


void CCreateTableAndLoadResponse::copy(CCreateTableAndLoadResponse &from)
{
	m_TableName.copy(from.m_TableName);
	m_Success.copy(from.m_Success);
	m_EclRecordDefinition.copy(from.m_EclRecordDefinition);
	m_Workunit.copy(from.m_Workunit);
}


void CCreateTableAndLoadResponse::copy(IConstCreateTableAndLoadResponse &ifrom)
{
	setTableName(ifrom.getTableName());
	setSuccess(ifrom.getSuccess());
	setEclRecordDefinition(ifrom.getEclRecordDefinition());
	setWorkunit(ifrom.getWorkunit());
}


void CCreateTableAndLoadResponse::getAttributes(IProperties &attributes)
{
}


void CCreateTableAndLoadResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
		m_TableName.toStr(ctx, buffer, "TableName", "", true, "", "");
		m_Success.toStr(ctx, buffer, "Success", "", true, "", "");
		m_EclRecordDefinition.toStr(ctx, buffer, "EclRecordDefinition", "", true, "", "");
		m_Workunit.toStr(ctx, buffer, "Workunit", "", false, "", "");
	}
}


void CCreateTableAndLoadResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CCreateTableAndLoadResponse::serializer(IEspContext* ctx, IConstCreateTableAndLoadResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<CreateTableAndLoadResponse>");
	// field TableName
	{
		const char* s = src.getTableName();
		if (s && *s)
		{
			buffer.append("<TableName>");
			encodeUtf8XML(s,buffer);
			buffer.append("</TableName>");
		}
	}
	// field Success
	{
		bool b = src.getSuccess();
		if (b)
			buffer.appendf("<Success>1</Success>");
	}
	// field EclRecordDefinition
	{
		const char* s = src.getEclRecordDefinition();
		if (s && *s)
		{
			buffer.append("<EclRecordDefinition>");
			encodeUtf8XML(s,buffer);
			buffer.append("</EclRecordDefinition>");
		}
	}
	// field Workunit
	{
		StringBuffer tmp;
		CECLWorkunit::serializer(ctx,src.getWorkunit(), tmp, false);
		if (tmp.length()>0)
			buffer.appendf("<Workunit>%s</Workunit>",tmp.str());
	}
	if (keepRootTag)
		buffer.append("</CreateTableAndLoadResponse>");
}

bool CCreateTableAndLoadResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
		hasValue |= m_TableName.unmarshall(rpc_request, "TableName", basepath);
		hasValue |= m_Success.unmarshall(rpc_request, "Success", basepath);
		hasValue |= m_EclRecordDefinition.unmarshall(rpc_request, "EclRecordDefinition", basepath);
		hasValue |= m_Workunit.unmarshall(rpc_request, "Workunit", basepath);
	}
	return hasValue;
}

bool CCreateTableAndLoadResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_TableName.unmarshall(ctx, soapval, "TableName");
	hasValue |= m_Success.unmarshall(ctx, soapval, "Success");
	hasValue |= m_EclRecordDefinition.unmarshall(ctx, soapval, "EclRecordDefinition");
	hasValue |= m_Workunit.unmarshall(ctx, soapval, "Workunit");
	return hasValue;
}

bool CCreateTableAndLoadResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_TableName.unmarshall(ctx, params, attachments, "TableName", basepath);
	hasValue |= m_Success.unmarshall(ctx, params, attachments, "Success", basepath);
	hasValue |= m_EclRecordDefinition.unmarshall(ctx, params, attachments, "EclRecordDefinition", basepath);
	hasValue |= m_Workunit.unmarshall(ctx, params, attachments, "Workunit", basepath);
	return hasValue;
}

const char * CCreateTableAndLoadResponse::getTableName() { return m_TableName.query();}
bool CCreateTableAndLoadResponse::getSuccess() { return m_Success;}
const char * CCreateTableAndLoadResponse::getEclRecordDefinition() { return m_EclRecordDefinition.query();}
IConstECLWorkunit & CCreateTableAndLoadResponse::getWorkunit() { return (IConstECLWorkunit &) m_Workunit.getValue();}
void CCreateTableAndLoadResponse::setTableName(const char * val){ m_TableName.set(val); }
void CCreateTableAndLoadResponse::setSuccess(bool val){ m_Success=val; }
void CCreateTableAndLoadResponse::setEclRecordDefinition(const char * val){ m_EclRecordDefinition.set(val); }
IEspECLWorkunit & CCreateTableAndLoadResponse::updateWorkunit(){ return (IEspECLWorkunit &) m_Workunit.getValue(); }
void CCreateTableAndLoadResponse::setWorkunit(IConstECLWorkunit &ifrom){ m_Workunit.copy(ifrom); }
extern "C"  IEspCreateTableAndLoadResponse *createCreateTableAndLoadResponse(const char *serv){return ((IEspCreateTableAndLoadResponse *)new CCreateTableAndLoadResponse(serv));}
extern "C"  IClientCreateTableAndLoadResponse *createClientCreateTableAndLoadResponse(const char *serv){return ((IClientCreateTableAndLoadResponse *)new CCreateTableAndLoadResponse(serv));}

//=======================================================
// class CwssqlPingRequest Implementation
//=======================================================

CwssqlPingRequest::CwssqlPingRequest(const char *serviceName, IRpcMessageBinding *init)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("wssqlPingRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CwssqlPingRequest::CwssqlPingRequest(const char *serviceName, const char *bc)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("wssqlPingRequest");
}

CwssqlPingRequest::CwssqlPingRequest(const char *serviceName, IRpcMessage* rpcmsg)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("wssqlPingRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CwssqlPingRequest::CwssqlPingRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("wssqlPingRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CwssqlPingRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType><xsd:all/></xsd:complexType></xsd:element>\n", msgTypeName);
		}
	}
	return schema;
}

void CwssqlPingRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CwssqlPingRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CwssqlPingRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CwssqlPingRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CwssqlPingRequest::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

}


void CwssqlPingRequest::copy(CwssqlPingRequest &from)
{
}


void CwssqlPingRequest::copy(IConstwssqlPingRequest &ifrom)
{
}


void CwssqlPingRequest::getAttributes(IProperties &attributes)
{
}


void CwssqlPingRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
}


void CwssqlPingRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CwssqlPingRequest::serializer(IEspContext* ctx, IConstwssqlPingRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<wssqlPingRequest>");
	if (keepRootTag)
		buffer.append("</wssqlPingRequest>");
}

bool CwssqlPingRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	return hasValue;
}

bool CwssqlPingRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	return hasValue;
}

bool CwssqlPingRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	return hasValue;
}

extern "C"  IEspwssqlPingRequest *createwssqlPingRequest(const char *serv){return ((IEspwssqlPingRequest *)new CwssqlPingRequest(serv));}
extern "C"  IClientwssqlPingRequest *createClientwssqlPingRequest(const char *serv){return ((IClientwssqlPingRequest *)new CwssqlPingRequest(serv));}

//=======================================================
// class CwssqlPingResponse Implementation
//=======================================================

CwssqlPingResponse::CwssqlPingResponse(const char *serviceName, IRpcMessageBinding *init)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("wssqlPingResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CwssqlPingResponse::CwssqlPingResponse(const char *serviceName, const char *bc)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("wssqlPingResponse");
}

CwssqlPingResponse::CwssqlPingResponse(const char *serviceName, IRpcMessage* rpcmsg)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("wssqlPingResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CwssqlPingResponse::CwssqlPingResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("wssqlPingResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CwssqlPingResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType><xsd:all/></xsd:complexType></xsd:element>\n", msgTypeName);
		}
	}
	return schema;
}

void CwssqlPingResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CwssqlPingResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CwssqlPingResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CwssqlPingResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CwssqlPingResponse::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
	}
}


void CwssqlPingResponse::copy(CwssqlPingResponse &from)
{
}


void CwssqlPingResponse::copy(IConstwssqlPingResponse &ifrom)
{
}


void CwssqlPingResponse::getAttributes(IProperties &attributes)
{
}


void CwssqlPingResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
	}
}


void CwssqlPingResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CwssqlPingResponse::serializer(IEspContext* ctx, IConstwssqlPingResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<wssqlPingResponse>");
	if (keepRootTag)
		buffer.append("</wssqlPingResponse>");
}

bool CwssqlPingResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
	}
	return hasValue;
}

bool CwssqlPingResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	return hasValue;
}

bool CwssqlPingResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	return hasValue;
}

extern "C"  IEspwssqlPingResponse *createwssqlPingResponse(const char *serv){return ((IEspwssqlPingResponse *)new CwssqlPingResponse(serv));}
extern "C"  IClientwssqlPingResponse *createClientwssqlPingResponse(const char *serv){return ((IClientwssqlPingResponse *)new CwssqlPingResponse(serv));}

//=======================================================
// class CwssqlSoapBinding Implementation
//=======================================================

CwssqlSoapBinding::CwssqlSoapBinding(http_soap_log_level level):CHttpSoapBinding(NULL, NULL, NULL, level)
{
	init_strings();
	setWsdlVersion(3.05);
}

CwssqlSoapBinding::CwssqlSoapBinding(IPropertyTree* cfg, const char *bindname, const char *procname, http_soap_log_level level):CHttpSoapBinding(cfg, bindname, procname, level)
{
	init_strings(); 
	setWsdlVersion(3.05);

}

void CwssqlSoapBinding::init_strings()
{
}

int CwssqlSoapBinding::processRequest(IRpcMessage* rpc_call, IRpcMessage* rpc_response)
{
	if(rpc_call == NULL || rpc_response == NULL)
		return -1;

	IEspContext *ctx=rpc_call->queryContext();
	DBGLOG("Client version: %g", ctx->getClientVersion());
	StringBuffer serviceName;
	double clientVer=(ctx) ? ctx->getClientVersion() : 0.0;
	qualifyServiceName(*ctx, ctx->queryServiceName(NULL), NULL, serviceName, NULL);
	CRpcCall* thecall = static_cast<CRpcCall *>(rpc_call);
	CRpcResponse* response = static_cast<CRpcResponse*>(rpc_response);
	CHttpRequest* httprequest = thecall->getHttpReq();
	CHttpResponse* httpresponse = response->getHttpResp();

	Owned<IEspwssql> iserv = (IEspwssql*)getService();
	if(iserv == NULL)
	{
		response->set_status(SOAP_SERVER_ERROR);
		response->set_err("Service not available");
		DBGLOG("Service not available");
		return -1;
	}
	if (thecall->get_name() == NULL)
	{
		response->set_status(SOAP_CLIENT_ERROR);
		response->set_err("No service method specified");
		ERRLOG("No service method specified");
		return -1;
	}

	IEspContext& context = *rpc_call->queryContext();

	if(!stricmp(thecall->get_name(), "CreateTableAndLoad")||!stricmp(thecall->get_name(), "CreateTableAndLoadRequest"))
	{
		Owned<CCreateTableAndLoadRequest> esp_request = new CCreateTableAndLoadRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CCreateTableAndLoadResponse> esp_response = new CCreateTableAndLoadResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		StringBuffer source;
		source.appendf("wssql::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			if (clientVer!=-1.0 && clientVer<3.03)
				throw MakeStringException(-1, "Client version is too old, please update your client application.");			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "wssql", "CreateTableAndLoad");
			iserv->onCreateTableAndLoad(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "wssql", "CreateTableAndLoad");
		response->set_name("CreateTableAndLoadResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "Echo")||!stricmp(thecall->get_name(), "EchoRequest"))
	{
		Owned<CEchoRequest> esp_request = new CEchoRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CEchoResponse> esp_response = new CEchoResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		StringBuffer source;
		source.appendf("wssql::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "wssql", "Echo");
			iserv->onEcho(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "wssql", "Echo");
		response->set_name("EchoResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "ExecutePreparedSQL")||!stricmp(thecall->get_name(), "ExecutePreparedSQLRequest"))
	{
		Owned<CExecutePreparedSQLRequest> esp_request = new CExecutePreparedSQLRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CExecutePreparedSQLResponse> esp_response = new CExecutePreparedSQLResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		StringBuffer source;
		source.appendf("wssql::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "wssql", "ExecutePreparedSQL");
			iserv->onExecutePreparedSQL(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "wssql", "ExecutePreparedSQL");
		response->set_name("ExecutePreparedSQLResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "ExecuteSQL")||!stricmp(thecall->get_name(), "ExecuteSQLRequest"))
	{
		Owned<CExecuteSQLRequest> esp_request = new CExecuteSQLRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CExecuteSQLResponse> esp_response = new CExecuteSQLResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		StringBuffer source;
		source.appendf("wssql::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "wssql", "ExecuteSQL");
			iserv->onExecuteSQL(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "wssql", "ExecuteSQL");
		response->set_name("ExecuteSQLResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "GetDBMetaData")||!stricmp(thecall->get_name(), "GetDBMetaDataRequest"))
	{
		Owned<CGetDBMetaDataRequest> esp_request = new CGetDBMetaDataRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CGetDBMetaDataResponse> esp_response = new CGetDBMetaDataResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		StringBuffer source;
		source.appendf("wssql::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "wssql", "GetDBMetaData");
			iserv->onGetDBMetaData(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "wssql", "GetDBMetaData");
		response->set_name("GetDBMetaDataResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "GetDBSystemInfo")||!stricmp(thecall->get_name(), "GetDBSystemInfoRequest"))
	{
		Owned<CGetDBSystemInfoRequest> esp_request = new CGetDBSystemInfoRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CGetDBSystemInfoResponse> esp_response = new CGetDBSystemInfoResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		StringBuffer source;
		source.appendf("wssql::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "wssql", "GetDBSystemInfo");
			iserv->onGetDBSystemInfo(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "wssql", "GetDBSystemInfo");
		response->set_name("GetDBSystemInfoResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "GetRelatedIndexes")||!stricmp(thecall->get_name(), "GetRelatedIndexesRequest"))
	{
		Owned<CGetRelatedIndexesRequest> esp_request = new CGetRelatedIndexesRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CGetRelatedIndexesResponse> esp_response = new CGetRelatedIndexesResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		StringBuffer source;
		source.appendf("wssql::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			if (clientVer!=-1.0 && clientVer<3.02)
				throw MakeStringException(-1, "Client version is too old, please update your client application.");			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "wssql", "GetRelatedIndexes");
			iserv->onGetRelatedIndexes(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "wssql", "GetRelatedIndexes");
		response->set_name("GetRelatedIndexesResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "GetResults")||!stricmp(thecall->get_name(), "GetResultsRequest"))
	{
		Owned<CGetResultsRequest> esp_request = new CGetResultsRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CGetResultsResponse> esp_response = new CGetResultsResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		StringBuffer source;
		source.appendf("wssql::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "wssql", "GetResults");
			iserv->onGetResults(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "wssql", "GetResults");
		response->set_name("GetResultsResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "Ping")||!stricmp(thecall->get_name(), "wssqlPingRequest"))
	{
		Owned<CwssqlPingRequest> esp_request = new CwssqlPingRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CwssqlPingResponse> esp_response = new CwssqlPingResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		StringBuffer source;
		source.appendf("wssql::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "wssql", "Ping");
			iserv->onPing(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "wssql", "Ping");
		response->set_name("wssqlPingResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "PrepareSQL")||!stricmp(thecall->get_name(), "PrepareSQLRequest"))
	{
		Owned<CPrepareSQLRequest> esp_request = new CPrepareSQLRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CPrepareSQLResponse> esp_response = new CPrepareSQLResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		StringBuffer source;
		source.appendf("wssql::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "wssql", "PrepareSQL");
			iserv->onPrepareSQL(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "wssql", "PrepareSQL");
		response->set_name("PrepareSQLResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "SetRelatedIndexes")||!stricmp(thecall->get_name(), "SetRelatedIndexesRequest"))
	{
		Owned<CSetRelatedIndexesRequest> esp_request = new CSetRelatedIndexesRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CSetRelatedIndexesResponse> esp_response = new CSetRelatedIndexesResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		StringBuffer source;
		source.appendf("wssql::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			if (clientVer!=-1.0 && clientVer<3.02)
				throw MakeStringException(-1, "Client version is too old, please update your client application.");			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "wssql", "SetRelatedIndexes");
			iserv->onSetRelatedIndexes(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "wssql", "SetRelatedIndexes");
		response->set_name("SetRelatedIndexesResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	response->set_status(SOAP_CLIENT_ERROR);
	StringBuffer msg, svcName;
	msg.appendf("Method %s not available in service %s",thecall->get_name(),getServiceName(svcName).str());
	ERRLOG("%s", msg.str());
	response->set_err(msg);
	return -1;
}

int CwssqlSoapBinding::getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &content, const char *service, const char *method, bool mda)
{
	BoolHash added;
	if (context.getClientVersion()<=0)
		context.setClientVersion(3.05);

	DBGLOG("Client version: %g", context.getClientVersion());
	bool fullservice = (!Utils::strcasecmp(service, "wssql"));
	bool allMethods = (method==NULL || *method==0);
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "CreateTableAndLoad"))) || Utils::strcasecmp(method, "CreateTableAndLoad")==0)
	{
		if (context.getClientVersion()>=3.03) {
			CCreateTableAndLoadRequest::getMapInfo(context.queryMapInfo());
			CCreateTableAndLoadResponse::getMapInfo(context.queryMapInfo());
			CCreateTableAndLoadRequest::getXsdDefinition(context, request, "CreateTableAndLoadRequest", content, added);
			CCreateTableAndLoadResponse::getXsdDefinition(context, request, content, added);
		}
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "Echo"))) || Utils::strcasecmp(method, "Echo")==0)
	{
		CEchoRequest::getMapInfo(context.queryMapInfo());
		CEchoResponse::getMapInfo(context.queryMapInfo());
		CEchoRequest::getXsdDefinition(context, request, "EchoRequest", content, added);
		CEchoResponse::getXsdDefinition(context, request, content, added);
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "ExecutePreparedSQL"))) || Utils::strcasecmp(method, "ExecutePreparedSQL")==0)
	{
		CExecutePreparedSQLRequest::getMapInfo(context.queryMapInfo());
		CExecutePreparedSQLResponse::getMapInfo(context.queryMapInfo());
		CExecutePreparedSQLRequest::getXsdDefinition(context, request, "ExecutePreparedSQLRequest", content, added);
		CExecutePreparedSQLResponse::getXsdDefinition(context, request, content, added);
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "ExecuteSQL"))) || Utils::strcasecmp(method, "ExecuteSQL")==0)
	{
		CExecuteSQLRequest::getMapInfo(context.queryMapInfo());
		CExecuteSQLResponse::getMapInfo(context.queryMapInfo());
		CExecuteSQLRequest::getXsdDefinition(context, request, "ExecuteSQLRequest", content, added);
		CExecuteSQLResponse::getXsdDefinition(context, request, content, added);
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "GetDBMetaData"))) || Utils::strcasecmp(method, "GetDBMetaData")==0)
	{
		CGetDBMetaDataRequest::getMapInfo(context.queryMapInfo());
		CGetDBMetaDataResponse::getMapInfo(context.queryMapInfo());
		CGetDBMetaDataRequest::getXsdDefinition(context, request, "GetDBMetaDataRequest", content, added);
		CGetDBMetaDataResponse::getXsdDefinition(context, request, content, added);
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "GetDBSystemInfo"))) || Utils::strcasecmp(method, "GetDBSystemInfo")==0)
	{
		CGetDBSystemInfoRequest::getMapInfo(context.queryMapInfo());
		CGetDBSystemInfoResponse::getMapInfo(context.queryMapInfo());
		CGetDBSystemInfoRequest::getXsdDefinition(context, request, "GetDBSystemInfoRequest", content, added);
		CGetDBSystemInfoResponse::getXsdDefinition(context, request, content, added);
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "GetRelatedIndexes"))) || Utils::strcasecmp(method, "GetRelatedIndexes")==0)
	{
		if (context.getClientVersion()>=3.02) {
			CGetRelatedIndexesRequest::getMapInfo(context.queryMapInfo());
			CGetRelatedIndexesResponse::getMapInfo(context.queryMapInfo());
			CGetRelatedIndexesRequest::getXsdDefinition(context, request, "GetRelatedIndexesRequest", content, added);
			CGetRelatedIndexesResponse::getXsdDefinition(context, request, content, added);
		}
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "GetResults"))) || Utils::strcasecmp(method, "GetResults")==0)
	{
		CGetResultsRequest::getMapInfo(context.queryMapInfo());
		CGetResultsResponse::getMapInfo(context.queryMapInfo());
		CGetResultsRequest::getXsdDefinition(context, request, "GetResultsRequest", content, added);
		CGetResultsResponse::getXsdDefinition(context, request, content, added);
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "Ping"))) || Utils::strcasecmp(method, "Ping")==0)
	{
		CwssqlPingRequest::getMapInfo(context.queryMapInfo());
		CwssqlPingResponse::getMapInfo(context.queryMapInfo());
		CwssqlPingRequest::getXsdDefinition(context, request, "wssqlPingRequest", content, added);
		CwssqlPingResponse::getXsdDefinition(context, request, content, added);
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "PrepareSQL"))) || Utils::strcasecmp(method, "PrepareSQL")==0)
	{
		CPrepareSQLRequest::getMapInfo(context.queryMapInfo());
		CPrepareSQLResponse::getMapInfo(context.queryMapInfo());
		CPrepareSQLRequest::getXsdDefinition(context, request, "PrepareSQLRequest", content, added);
		CPrepareSQLResponse::getXsdDefinition(context, request, content, added);
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "SetRelatedIndexes"))) || Utils::strcasecmp(method, "SetRelatedIndexes")==0)
	{
		if (context.getClientVersion()>=3.02) {
			CSetRelatedIndexesRequest::getMapInfo(context.queryMapInfo());
			CSetRelatedIndexesResponse::getMapInfo(context.queryMapInfo());
			CSetRelatedIndexesRequest::getXsdDefinition(context, request, "SetRelatedIndexesRequest", content, added);
			CSetRelatedIndexesResponse::getXsdDefinition(context, request, content, added);
		}
	}
	return 0;
}

int CwssqlSoapBinding::getMethodHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &page, bool bIncludeFormTag)
{
	DBGLOG("Client version: %g", context.getClientVersion());
	if (Utils::strcasecmp(method, "CreateTableAndLoad")==0)
	{
		CCreateTableAndLoadRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "Echo")==0)
	{
		CEchoRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "ExecutePreparedSQL")==0)
	{
		CExecutePreparedSQLRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "ExecuteSQL")==0)
	{
		CExecuteSQLRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "GetDBMetaData")==0)
	{
		CGetDBMetaDataRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "GetDBSystemInfo")==0)
	{
		CGetDBSystemInfoRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "GetRelatedIndexes")==0)
	{
		CGetRelatedIndexesRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "GetResults")==0)
	{
		CGetResultsRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "Ping")==0)
	{
		CwssqlPingRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "PrepareSQL")==0)
	{
		CPrepareSQLRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "SetRelatedIndexes")==0)
	{
		CSetRelatedIndexesRequest::getHtmlForm(context, request, serv, method, page);
	}
	return 0;
}

int CwssqlSoapBinding::getQualifiedNames(IEspContext& ctx, MethodInfoArray & methods)
{
	double ver = ctx.getClientVersion();
	if (ver<=0)
		ver = getWsdlVersion();
	const char *servname=ctx.queryServiceName(NULL);
	bool fullservice = (!stricmp(servname, "esp")||!stricmp(servname, "wssql"));
	if ((fullservice || isMethodInSubService(ctx, servname, "CreateTableAndLoad")) && ctx.isMethodAllowed(ver,NULL, NULL, 3.03, -1))
		methods.append(*new CMethodInfo("CreateTableAndLoad", "CreateTableAndLoadRequest", "CreateTableAndLoadResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "Echo")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("Echo", "EchoRequest", "EchoResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "ExecutePreparedSQL")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("ExecutePreparedSQL", "ExecutePreparedSQLRequest", "ExecutePreparedSQLResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "ExecuteSQL")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("ExecuteSQL", "ExecuteSQLRequest", "ExecuteSQLResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "GetDBMetaData")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("GetDBMetaData", "GetDBMetaDataRequest", "GetDBMetaDataResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "GetDBSystemInfo")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("GetDBSystemInfo", "GetDBSystemInfoRequest", "GetDBSystemInfoResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "GetRelatedIndexes")) && ctx.isMethodAllowed(ver,NULL, NULL, 3.02, -1))
		methods.append(*new CMethodInfo("GetRelatedIndexes", "GetRelatedIndexesRequest", "GetRelatedIndexesResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "GetResults")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("GetResults", "GetResultsRequest", "GetResultsResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "Ping")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("Ping", "wssqlPingRequest", "wssqlPingResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "PrepareSQL")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("PrepareSQL", "PrepareSQLRequest", "PrepareSQLResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "SetRelatedIndexes")) && ctx.isMethodAllowed(ver,NULL, NULL, 3.02, -1))
		methods.append(*new CMethodInfo("SetRelatedIndexes", "SetRelatedIndexesRequest", "SetRelatedIndexesResponse"));
	return methods.ordinality();
}

StringBuffer & CwssqlSoapBinding::getServiceName(StringBuffer &resp)
{
	resp.append("wssql");
	return resp;
}

bool CwssqlSoapBinding::isValidServiceName(IEspContext &context, const char *name)
{
	if (!Utils::strcasecmp(name, "wssql"))
		return true;
	else
		return (hasSubService(context, name));
}

bool CwssqlSoapBinding::qualifyMethodName(IEspContext &context, const char *methname, StringBuffer *methQName)
{
	if (!methname || !*methname)
	{
		if (methQName!=NULL)
			methQName->clear();
		return true;
	}
	if (Utils::strcasecmp(methname, "CreateTableAndLoad")==0)
	{
		if (methQName!=NULL)
			methQName->set("CreateTableAndLoad");
		return true;
	}
	if (Utils::strcasecmp(methname, "Echo")==0)
	{
		if (methQName!=NULL)
			methQName->set("Echo");
		return true;
	}
	if (Utils::strcasecmp(methname, "ExecutePreparedSQL")==0)
	{
		if (methQName!=NULL)
			methQName->set("ExecutePreparedSQL");
		return true;
	}
	if (Utils::strcasecmp(methname, "ExecuteSQL")==0)
	{
		if (methQName!=NULL)
			methQName->set("ExecuteSQL");
		return true;
	}
	if (Utils::strcasecmp(methname, "GetDBMetaData")==0)
	{
		if (methQName!=NULL)
			methQName->set("GetDBMetaData");
		return true;
	}
	if (Utils::strcasecmp(methname, "GetDBSystemInfo")==0)
	{
		if (methQName!=NULL)
			methQName->set("GetDBSystemInfo");
		return true;
	}
	if (Utils::strcasecmp(methname, "GetRelatedIndexes")==0)
	{
		if (methQName!=NULL)
			methQName->set("GetRelatedIndexes");
		return true;
	}
	if (Utils::strcasecmp(methname, "GetResults")==0)
	{
		if (methQName!=NULL)
			methQName->set("GetResults");
		return true;
	}
	if (Utils::strcasecmp(methname, "Ping")==0)
	{
		if (methQName!=NULL)
			methQName->set("Ping");
		return true;
	}
	if (Utils::strcasecmp(methname, "PrepareSQL")==0)
	{
		if (methQName!=NULL)
			methQName->set("PrepareSQL");
		return true;
	}
	if (Utils::strcasecmp(methname, "SetRelatedIndexes")==0)
	{
		if (methQName!=NULL)
			methQName->set("SetRelatedIndexes");
		return true;
	}
	return false;
}

bool CwssqlSoapBinding::qualifyServiceName(IEspContext &context, const char *servname, const char *methname, StringBuffer &servQName, StringBuffer *methQName)
{
	servQName.clear();
	if (!Utils::strcasecmp(servname, "wssql"))
	{
		servQName.append("wssql");
		return qualifyMethodName(context, methname, methQName);
	}
	return qualifySubServiceName(context, servname, methname, servQName, methQName);
}

int CwssqlSoapBinding::onGetFile(IEspContext &context, CHttpRequest* request, CHttpResponse* response, const char *pathex)
{
	if(request == NULL || response == NULL)
		return -1;
	StringBuffer mimetype;
	MemoryBuffer content;

	StringBuffer filepath;
	getBaseFilePath(filepath);
	if (strchr("\\/", filepath.charAt(filepath.length()-1))==NULL)
		filepath.append("/");
	filepath.append(pathex);
	response->httpContentFromFile(filepath.str());
	response->send();
	return 0;
}

int CwssqlSoapBinding::onGetForm(IEspContext &context, CHttpRequest* request, CHttpResponse* response, const char *service, const char *method)
{
	if (context.getClientVersion()<=0)
		context.setClientVersion(3.05);

	if (!stricmp("CreateTableAndLoad", method)) {
		CCreateTableAndLoadRequest::getMapInfo(context.queryMapInfo());
		CCreateTableAndLoadResponse::getMapInfo(context.queryMapInfo());
	}
	if (!stricmp("Echo", method)) {
		CEchoRequest::getMapInfo(context.queryMapInfo());
		CEchoResponse::getMapInfo(context.queryMapInfo());
	}
	if (!stricmp("ExecutePreparedSQL", method)) {
		CExecutePreparedSQLRequest::getMapInfo(context.queryMapInfo());
		CExecutePreparedSQLResponse::getMapInfo(context.queryMapInfo());
	}
	if (!stricmp("ExecuteSQL", method)) {
		CExecuteSQLRequest::getMapInfo(context.queryMapInfo());
		CExecuteSQLResponse::getMapInfo(context.queryMapInfo());
	}
	if (!stricmp("GetDBMetaData", method)) {
		CGetDBMetaDataRequest::getMapInfo(context.queryMapInfo());
		CGetDBMetaDataResponse::getMapInfo(context.queryMapInfo());
	}
	if (!stricmp("GetDBSystemInfo", method)) {
		CGetDBSystemInfoRequest::getMapInfo(context.queryMapInfo());
		CGetDBSystemInfoResponse::getMapInfo(context.queryMapInfo());
	}
	if (!stricmp("GetRelatedIndexes", method)) {
		CGetRelatedIndexesRequest::getMapInfo(context.queryMapInfo());
		CGetRelatedIndexesResponse::getMapInfo(context.queryMapInfo());
	}
	if (!stricmp("GetResults", method)) {
		CGetResultsRequest::getMapInfo(context.queryMapInfo());
		CGetResultsResponse::getMapInfo(context.queryMapInfo());
	}
	if (!stricmp("Ping", method)) {
		CwssqlPingRequest::getMapInfo(context.queryMapInfo());
		CwssqlPingResponse::getMapInfo(context.queryMapInfo());
	}
	if (!stricmp("PrepareSQL", method)) {
		CPrepareSQLRequest::getMapInfo(context.queryMapInfo());
		CPrepareSQLResponse::getMapInfo(context.queryMapInfo());
	}
	if (!stricmp("SetRelatedIndexes", method)) {
		CSetRelatedIndexesRequest::getMapInfo(context.queryMapInfo());
		CSetRelatedIndexesResponse::getMapInfo(context.queryMapInfo());
	}

	return EspHttpBinding::onGetForm(context, request, response, service, method);
}
int CwssqlSoapBinding::onGetXForm(IEspContext &context, CHttpRequest* request, CHttpResponse* response, const char *service, const char *method)
{
	return EspHttpBinding::onGetXForm(context, request, response, service, method);
}

int CwssqlSoapBinding::onGetService(IEspContext &context, CHttpRequest* request, CHttpResponse* response, const char *service, const char *method, const char *pathex)
{
	if(request == NULL || response == NULL)
		return -1;
	return onGetQuery(context, request, response, service, method);
}

 IRpcRequestBinding *CwssqlSoapBinding::createReqBinding(IEspContext &context, IHttpMessage *ireq, const char *service, const char *method)
{
	CHttpRequest *request=static_cast<CHttpRequest*>(ireq);
	IProperties *props = (request) ? request->queryParameters() : NULL;

	if (!stricmp(method, "CreateTableAndLoad") || !stricmp(method, "CreateTableAndLoadRequest"))
		return new CCreateTableAndLoadRequest(&context, "wssql", props, NULL);
	if (!stricmp(method, "Echo") || !stricmp(method, "EchoRequest"))
		return new CEchoRequest(&context, "wssql", props, NULL);
	if (!stricmp(method, "ExecutePreparedSQL") || !stricmp(method, "ExecutePreparedSQLRequest"))
		return new CExecutePreparedSQLRequest(&context, "wssql", props, NULL);
	if (!stricmp(method, "ExecuteSQL") || !stricmp(method, "ExecuteSQLRequest"))
		return new CExecuteSQLRequest(&context, "wssql", props, NULL);
	if (!stricmp(method, "GetDBMetaData") || !stricmp(method, "GetDBMetaDataRequest"))
		return new CGetDBMetaDataRequest(&context, "wssql", props, NULL);
	if (!stricmp(method, "GetDBSystemInfo") || !stricmp(method, "GetDBSystemInfoRequest"))
		return new CGetDBSystemInfoRequest(&context, "wssql", props, NULL);
	if (!stricmp(method, "GetRelatedIndexes") || !stricmp(method, "GetRelatedIndexesRequest"))
		return new CGetRelatedIndexesRequest(&context, "wssql", props, NULL);
	if (!stricmp(method, "GetResults") || !stricmp(method, "GetResultsRequest"))
		return new CGetResultsRequest(&context, "wssql", props, NULL);
	if (!stricmp(method, "Ping") || !stricmp(method, "wssqlPingRequest"))
		return new CwssqlPingRequest(&context, "wssql", props, NULL);
	if (!stricmp(method, "PrepareSQL") || !stricmp(method, "PrepareSQLRequest"))
		return new CPrepareSQLRequest(&context, "wssql", props, NULL);
	if (!stricmp(method, "SetRelatedIndexes") || !stricmp(method, "SetRelatedIndexesRequest"))
		return new CSetRelatedIndexesRequest(&context, "wssql", props, NULL);
	return NULL;
}

int CwssqlSoapBinding::onGetInstantQuery(IEspContext &context, CHttpRequest* request, CHttpResponse* response, const char *service, const char *method)
{
	if (context.getClientVersion()<=0)
		context.setClientVersion(3.05);

	if(request == NULL || response == NULL)
		return -1;
	StringBuffer respStr;
	Owned<IEspwssql> iserv = (IEspwssql*)getService();
	if(iserv == NULL)
	{
		respStr.append("Service not available");
		response->setContent(respStr.str());
		response->setContentType("text/html");
		response->send();
	}
	else
	{
		Owned<CSoapResponseBinding> esp_response;
		StringBuffer source;
		IEspContext& context = *request->queryContext();
		if(!stricmp(method, "CreateTableAndLoad")||!stricmp(method, "CreateTableAndLoadRequest"))
		{
			Owned<CCreateTableAndLoadRequest> esp_request = new CCreateTableAndLoadRequest(&context, "wssql", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			CCreateTableAndLoadResponse* resp = new CCreateTableAndLoadResponse("wssql");
			esp_response.setown(resp);
			MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
			source.setf("wssql::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				if(accessmap.ordinality()>0)
					onFeaturesAuthorize(context, accessmap, "wssql", "CreateTableAndLoad");
				iserv->onCreateTableAndLoad(context, *esp_request.get(), *resp);
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "wssql", "CreateTableAndLoad", StringBuffer(getCFD()).append("./smc_xslt/exceptions.xslt").str()))
				return 0;
		}
		if(!stricmp(method, "Echo")||!stricmp(method, "EchoRequest"))
		{
			Owned<CEchoRequest> esp_request = new CEchoRequest(&context, "wssql", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			CEchoResponse* resp = new CEchoResponse("wssql");
			esp_response.setown(resp);
			MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
			source.setf("wssql::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				if(accessmap.ordinality()>0)
					onFeaturesAuthorize(context, accessmap, "wssql", "Echo");
				iserv->onEcho(context, *esp_request.get(), *resp);
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "wssql", "Echo", StringBuffer(getCFD()).append("./smc_xslt/exceptions.xslt").str()))
				return 0;
		}
		if(!stricmp(method, "ExecutePreparedSQL")||!stricmp(method, "ExecutePreparedSQLRequest"))
		{
			Owned<CExecutePreparedSQLRequest> esp_request = new CExecutePreparedSQLRequest(&context, "wssql", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			CExecutePreparedSQLResponse* resp = new CExecutePreparedSQLResponse("wssql");
			esp_response.setown(resp);
			MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
			source.setf("wssql::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				if(accessmap.ordinality()>0)
					onFeaturesAuthorize(context, accessmap, "wssql", "ExecutePreparedSQL");
				iserv->onExecutePreparedSQL(context, *esp_request.get(), *resp);
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "wssql", "ExecutePreparedSQL", StringBuffer(getCFD()).append("./smc_xslt/exceptions.xslt").str()))
				return 0;
		}
		if(!stricmp(method, "ExecuteSQL")||!stricmp(method, "ExecuteSQLRequest"))
		{
			Owned<CExecuteSQLRequest> esp_request = new CExecuteSQLRequest(&context, "wssql", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			CExecuteSQLResponse* resp = new CExecuteSQLResponse("wssql");
			esp_response.setown(resp);
			MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
			source.setf("wssql::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				if(accessmap.ordinality()>0)
					onFeaturesAuthorize(context, accessmap, "wssql", "ExecuteSQL");
				iserv->onExecuteSQL(context, *esp_request.get(), *resp);
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "wssql", "ExecuteSQL", StringBuffer(getCFD()).append("./smc_xslt/exceptions.xslt").str()))
				return 0;
		}
		if(!stricmp(method, "GetDBMetaData")||!stricmp(method, "GetDBMetaDataRequest"))
		{
			Owned<CGetDBMetaDataRequest> esp_request = new CGetDBMetaDataRequest(&context, "wssql", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			CGetDBMetaDataResponse* resp = new CGetDBMetaDataResponse("wssql");
			esp_response.setown(resp);
			MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
			source.setf("wssql::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				if(accessmap.ordinality()>0)
					onFeaturesAuthorize(context, accessmap, "wssql", "GetDBMetaData");
				iserv->onGetDBMetaData(context, *esp_request.get(), *resp);
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "wssql", "GetDBMetaData", StringBuffer(getCFD()).append("./smc_xslt/exceptions.xslt").str()))
				return 0;
		}
		if(!stricmp(method, "GetDBSystemInfo")||!stricmp(method, "GetDBSystemInfoRequest"))
		{
			Owned<CGetDBSystemInfoRequest> esp_request = new CGetDBSystemInfoRequest(&context, "wssql", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			CGetDBSystemInfoResponse* resp = new CGetDBSystemInfoResponse("wssql");
			esp_response.setown(resp);
			MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
			source.setf("wssql::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				if(accessmap.ordinality()>0)
					onFeaturesAuthorize(context, accessmap, "wssql", "GetDBSystemInfo");
				iserv->onGetDBSystemInfo(context, *esp_request.get(), *resp);
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "wssql", "GetDBSystemInfo", StringBuffer(getCFD()).append("./smc_xslt/exceptions.xslt").str()))
				return 0;
		}
		if(!stricmp(method, "GetRelatedIndexes")||!stricmp(method, "GetRelatedIndexesRequest"))
		{
			Owned<CGetRelatedIndexesRequest> esp_request = new CGetRelatedIndexesRequest(&context, "wssql", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			CGetRelatedIndexesResponse* resp = new CGetRelatedIndexesResponse("wssql");
			esp_response.setown(resp);
			MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
			source.setf("wssql::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				if(accessmap.ordinality()>0)
					onFeaturesAuthorize(context, accessmap, "wssql", "GetRelatedIndexes");
				iserv->onGetRelatedIndexes(context, *esp_request.get(), *resp);
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "wssql", "GetRelatedIndexes", StringBuffer(getCFD()).append("./smc_xslt/exceptions.xslt").str()))
				return 0;
		}
		if(!stricmp(method, "GetResults")||!stricmp(method, "GetResultsRequest"))
		{
			Owned<CGetResultsRequest> esp_request = new CGetResultsRequest(&context, "wssql", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			CGetResultsResponse* resp = new CGetResultsResponse("wssql");
			esp_response.setown(resp);
			MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
			source.setf("wssql::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				if(accessmap.ordinality()>0)
					onFeaturesAuthorize(context, accessmap, "wssql", "GetResults");
				iserv->onGetResults(context, *esp_request.get(), *resp);
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "wssql", "GetResults", StringBuffer(getCFD()).append("./smc_xslt/exceptions.xslt").str()))
				return 0;
		}
		if(!stricmp(method, "Ping")||!stricmp(method, "wssqlPingRequest"))
		{
			Owned<CwssqlPingRequest> esp_request = new CwssqlPingRequest(&context, "wssql", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			CwssqlPingResponse* resp = new CwssqlPingResponse("wssql");
			esp_response.setown(resp);
			MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
			source.setf("wssql::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				if(accessmap.ordinality()>0)
					onFeaturesAuthorize(context, accessmap, "wssql", "Ping");
				iserv->onPing(context, *esp_request.get(), *resp);
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "wssql", "Ping", StringBuffer(getCFD()).append("./smc_xslt/exceptions.xslt").str()))
				return 0;
		}
		if(!stricmp(method, "PrepareSQL")||!stricmp(method, "PrepareSQLRequest"))
		{
			Owned<CPrepareSQLRequest> esp_request = new CPrepareSQLRequest(&context, "wssql", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			CPrepareSQLResponse* resp = new CPrepareSQLResponse("wssql");
			esp_response.setown(resp);
			MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
			source.setf("wssql::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				if(accessmap.ordinality()>0)
					onFeaturesAuthorize(context, accessmap, "wssql", "PrepareSQL");
				iserv->onPrepareSQL(context, *esp_request.get(), *resp);
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "wssql", "PrepareSQL", StringBuffer(getCFD()).append("./smc_xslt/exceptions.xslt").str()))
				return 0;
		}
		if(!stricmp(method, "SetRelatedIndexes")||!stricmp(method, "SetRelatedIndexesRequest"))
		{
			Owned<CSetRelatedIndexesRequest> esp_request = new CSetRelatedIndexesRequest(&context, "wssql", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			CSetRelatedIndexesResponse* resp = new CSetRelatedIndexesResponse("wssql");
			esp_response.setown(resp);
			MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
			source.setf("wssql::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				if(accessmap.ordinality()>0)
					onFeaturesAuthorize(context, accessmap, "wssql", "SetRelatedIndexes");
				iserv->onSetRelatedIndexes(context, *esp_request.get(), *resp);
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "wssql", "SetRelatedIndexes", StringBuffer(getCFD()).append("./smc_xslt/exceptions.xslt").str()))
				return 0;
		}

		if (esp_response.get())
		{
			if (canRedirect(*request) && esp_response->getRedirectUrl() && *esp_response->getRedirectUrl())
				response->redirect(*request, esp_response->getRedirectUrl());
			else
			{
				MemoryBuffer content;
				StringBuffer mimetype;
				esp_response->appendContent(&context,content, mimetype);
				onBeforeSendResponse(context,request,content,service,method);
				response->setContent(content.length(), content.toByteArray());
				response->setContentType(mimetype.str());
				response->send();
			}
			return 0;
		}
	}
	return onGetNotFound(context, request,  response, service);
}





//=======================================================
// client util methods
//=======================================================

//------ method CreateTableAndLoad ---------

IClientCreateTableAndLoadRequest * CClientwssql::createCreateTableAndLoadRequest()
{
	CCreateTableAndLoadRequest* request = new CCreateTableAndLoadRequest("wssql");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientCreateTableAndLoadResponse * CClientwssql::CreateTableAndLoad(IClientCreateTableAndLoadRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CCreateTableAndLoadRequest* esprequest = static_cast<CCreateTableAndLoadRequest*>(request);
	CCreateTableAndLoadResponse* espresponse = new CCreateTableAndLoadResponse("wssql");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientwssql::async_CreateTableAndLoad(IClientCreateTableAndLoadRequest *request, IClientwssqlEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CCreateTableAndLoadRequest* esprequest = static_cast<CCreateTableAndLoadRequest*>(request);
	esprequest->setMethod("CreateTableAndLoad");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientwssql::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientCreateTableAndLoadResponse *CClientwssql::CreateTableAndLoadFn(const char * TableName_, const char * TableDescription_, bool Overwrite_, IArrayOf<IConstEclFieldDeclaration> &EclFields_, const char * TargetCluster_, const char * Owner_, IConstDataSourceInfo &DataSource_, IConstDataType &DataSourceType_, int Wait_)
{
	Owned<IClientCreateTableAndLoadRequest> req =  createCreateTableAndLoadRequest();
	req->setTableName(TableName_);
	req->setTableDescription(TableDescription_);
	req->setOverwrite(Overwrite_);
	req->setEclFields(EclFields_);
	req->setTargetCluster(TargetCluster_);
	req->setOwner(Owner_);
	req->setDataSource(DataSource_);
	req->setDataSourceType(DataSourceType_);
	req->setWait(Wait_);
	return CreateTableAndLoad(req.get());
}

//------ method Echo ---------

IClientEchoRequest * CClientwssql::createEchoRequest()
{
	CEchoRequest* request = new CEchoRequest("wssql");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientEchoResponse * CClientwssql::Echo(IClientEchoRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CEchoRequest* esprequest = static_cast<CEchoRequest*>(request);
	CEchoResponse* espresponse = new CEchoResponse("wssql");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientwssql::async_Echo(IClientEchoRequest *request, IClientwssqlEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CEchoRequest* esprequest = static_cast<CEchoRequest*>(request);
	esprequest->setMethod("Echo");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientwssql::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientEchoResponse *CClientwssql::EchoFn(const char * Request_)
{
	Owned<IClientEchoRequest> req =  createEchoRequest();
	req->setRequest(Request_);
	return Echo(req.get());
}

//------ method ExecutePreparedSQL ---------

IClientExecutePreparedSQLRequest * CClientwssql::createExecutePreparedSQLRequest()
{
	CExecutePreparedSQLRequest* request = new CExecutePreparedSQLRequest("wssql");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientExecutePreparedSQLResponse * CClientwssql::ExecutePreparedSQL(IClientExecutePreparedSQLRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CExecutePreparedSQLRequest* esprequest = static_cast<CExecutePreparedSQLRequest*>(request);
	CExecutePreparedSQLResponse* espresponse = new CExecutePreparedSQLResponse("wssql");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientwssql::async_ExecutePreparedSQL(IClientExecutePreparedSQLRequest *request, IClientwssqlEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CExecutePreparedSQLRequest* esprequest = static_cast<CExecutePreparedSQLRequest*>(request);
	esprequest->setMethod("ExecutePreparedSQL");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientwssql::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientExecutePreparedSQLResponse *CClientwssql::ExecutePreparedSQLFn(const char * WuId_, const char * UserName_, const char * TargetCluster_, bool SuppressResults_, bool SuppressXmlSchema_, int Wait_, int ResultWindowStart_, int ResultWindowCount_, IArrayOf<IConstNamedValue> &Variables_)
{
	Owned<IClientExecutePreparedSQLRequest> req =  createExecutePreparedSQLRequest();
	req->setWuId(WuId_);
	req->setUserName(UserName_);
	req->setTargetCluster(TargetCluster_);
	req->setSuppressResults(SuppressResults_);
	req->setSuppressXmlSchema(SuppressXmlSchema_);
	req->setWait(Wait_);
	req->setResultWindowStart(ResultWindowStart_);
	req->setResultWindowCount(ResultWindowCount_);
	req->setVariables(Variables_);
	return ExecutePreparedSQL(req.get());
}

//------ method ExecuteSQL ---------

IClientExecuteSQLRequest * CClientwssql::createExecuteSQLRequest()
{
	CExecuteSQLRequest* request = new CExecuteSQLRequest("wssql");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientExecuteSQLResponse * CClientwssql::ExecuteSQL(IClientExecuteSQLRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CExecuteSQLRequest* esprequest = static_cast<CExecuteSQLRequest*>(request);
	CExecuteSQLResponse* espresponse = new CExecuteSQLResponse("wssql");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientwssql::async_ExecuteSQL(IClientExecuteSQLRequest *request, IClientwssqlEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CExecuteSQLRequest* esprequest = static_cast<CExecuteSQLRequest*>(request);
	esprequest->setMethod("ExecuteSQL");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientwssql::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientExecuteSQLResponse *CClientwssql::ExecuteSQLFn(const char * SqlText_, const char * UserName_, const char * TargetCluster_, StringArray &AlternateClusters_, const char * TargetQuerySet_, bool SuppressResults_, bool SuppressXmlSchema_, int Wait_, int resultLimit_, int ResultWindowStart_, int ResultWindowCount_, bool IgnoreCache_)
{
	Owned<IClientExecuteSQLRequest> req =  createExecuteSQLRequest();
	req->setSqlText(SqlText_);
	req->setUserName(UserName_);
	req->setTargetCluster(TargetCluster_);
	req->setAlternateClusters(AlternateClusters_);
	req->setTargetQuerySet(TargetQuerySet_);
	req->setSuppressResults(SuppressResults_);
	req->setSuppressXmlSchema(SuppressXmlSchema_);
	req->setWait(Wait_);
	req->setResultLimit(resultLimit_);
	req->setResultWindowStart(ResultWindowStart_);
	req->setResultWindowCount(ResultWindowCount_);
	req->setIgnoreCache(IgnoreCache_);
	return ExecuteSQL(req.get());
}

//------ method GetDBMetaData ---------

IClientGetDBMetaDataRequest * CClientwssql::createGetDBMetaDataRequest()
{
	CGetDBMetaDataRequest* request = new CGetDBMetaDataRequest("wssql");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientGetDBMetaDataResponse * CClientwssql::GetDBMetaData(IClientGetDBMetaDataRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CGetDBMetaDataRequest* esprequest = static_cast<CGetDBMetaDataRequest*>(request);
	CGetDBMetaDataResponse* espresponse = new CGetDBMetaDataResponse("wssql");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientwssql::async_GetDBMetaData(IClientGetDBMetaDataRequest *request, IClientwssqlEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CGetDBMetaDataRequest* esprequest = static_cast<CGetDBMetaDataRequest*>(request);
	esprequest->setMethod("GetDBMetaData");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientwssql::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientGetDBMetaDataResponse *CClientwssql::GetDBMetaDataFn(bool IncludeTables_, const char * TableFilter_, bool IncludeStoredProcedures_, const char * QuerySet_, bool IncludeTargetClusters_, const char * ClusterType_)
{
	Owned<IClientGetDBMetaDataRequest> req =  createGetDBMetaDataRequest();
	req->setIncludeTables(IncludeTables_);
	req->setTableFilter(TableFilter_);
	req->setIncludeStoredProcedures(IncludeStoredProcedures_);
	req->setQuerySet(QuerySet_);
	req->setIncludeTargetClusters(IncludeTargetClusters_);
	req->setClusterType(ClusterType_);
	return GetDBMetaData(req.get());
}

//------ method GetDBSystemInfo ---------

IClientGetDBSystemInfoRequest * CClientwssql::createGetDBSystemInfoRequest()
{
	CGetDBSystemInfoRequest* request = new CGetDBSystemInfoRequest("wssql");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientGetDBSystemInfoResponse * CClientwssql::GetDBSystemInfo(IClientGetDBSystemInfoRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CGetDBSystemInfoRequest* esprequest = static_cast<CGetDBSystemInfoRequest*>(request);
	CGetDBSystemInfoResponse* espresponse = new CGetDBSystemInfoResponse("wssql");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientwssql::async_GetDBSystemInfo(IClientGetDBSystemInfoRequest *request, IClientwssqlEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CGetDBSystemInfoRequest* esprequest = static_cast<CGetDBSystemInfoRequest*>(request);
	esprequest->setMethod("GetDBSystemInfo");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientwssql::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientGetDBSystemInfoResponse *CClientwssql::GetDBSystemInfoFn(bool IncludeAll_)
{
	Owned<IClientGetDBSystemInfoRequest> req =  createGetDBSystemInfoRequest();
	req->setIncludeAll(IncludeAll_);
	return GetDBSystemInfo(req.get());
}

//------ method GetRelatedIndexes ---------

IClientGetRelatedIndexesRequest * CClientwssql::createGetRelatedIndexesRequest()
{
	CGetRelatedIndexesRequest* request = new CGetRelatedIndexesRequest("wssql");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientGetRelatedIndexesResponse * CClientwssql::GetRelatedIndexes(IClientGetRelatedIndexesRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CGetRelatedIndexesRequest* esprequest = static_cast<CGetRelatedIndexesRequest*>(request);
	CGetRelatedIndexesResponse* espresponse = new CGetRelatedIndexesResponse("wssql");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientwssql::async_GetRelatedIndexes(IClientGetRelatedIndexesRequest *request, IClientwssqlEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CGetRelatedIndexesRequest* esprequest = static_cast<CGetRelatedIndexesRequest*>(request);
	esprequest->setMethod("GetRelatedIndexes");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientwssql::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientGetRelatedIndexesResponse *CClientwssql::GetRelatedIndexesFn(StringArray &FileNames_)
{
	Owned<IClientGetRelatedIndexesRequest> req =  createGetRelatedIndexesRequest();
	req->setFileNames(FileNames_);
	return GetRelatedIndexes(req.get());
}

//------ method GetResults ---------

IClientGetResultsRequest * CClientwssql::createGetResultsRequest()
{
	CGetResultsRequest* request = new CGetResultsRequest("wssql");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientGetResultsResponse * CClientwssql::GetResults(IClientGetResultsRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CGetResultsRequest* esprequest = static_cast<CGetResultsRequest*>(request);
	CGetResultsResponse* espresponse = new CGetResultsResponse("wssql");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientwssql::async_GetResults(IClientGetResultsRequest *request, IClientwssqlEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CGetResultsRequest* esprequest = static_cast<CGetResultsRequest*>(request);
	esprequest->setMethod("GetResults");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientwssql::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientGetResultsResponse *CClientwssql::GetResultsFn(const char * WuId_, bool SuppressXmlSchema_, int ResultWindowStart_, int ResultWindowCount_)
{
	Owned<IClientGetResultsRequest> req =  createGetResultsRequest();
	req->setWuId(WuId_);
	req->setSuppressXmlSchema(SuppressXmlSchema_);
	req->setResultWindowStart(ResultWindowStart_);
	req->setResultWindowCount(ResultWindowCount_);
	return GetResults(req.get());
}

//------ method Ping ---------

IClientwssqlPingRequest * CClientwssql::createPingRequest()
{
	CwssqlPingRequest* request = new CwssqlPingRequest("wssql");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientwssqlPingResponse * CClientwssql::Ping(IClientwssqlPingRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CwssqlPingRequest* esprequest = static_cast<CwssqlPingRequest*>(request);
	CwssqlPingResponse* espresponse = new CwssqlPingResponse("wssql");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientwssql::async_Ping(IClientwssqlPingRequest *request, IClientwssqlEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CwssqlPingRequest* esprequest = static_cast<CwssqlPingRequest*>(request);
	esprequest->setMethod("Ping");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientwssql::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientwssqlPingResponse *CClientwssql::PingFn()
{
	Owned<IClientwssqlPingRequest> req =  createPingRequest();
	return Ping(req.get());
}

//------ method PrepareSQL ---------

IClientPrepareSQLRequest * CClientwssql::createPrepareSQLRequest()
{
	CPrepareSQLRequest* request = new CPrepareSQLRequest("wssql");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientPrepareSQLResponse * CClientwssql::PrepareSQL(IClientPrepareSQLRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CPrepareSQLRequest* esprequest = static_cast<CPrepareSQLRequest*>(request);
	CPrepareSQLResponse* espresponse = new CPrepareSQLResponse("wssql");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientwssql::async_PrepareSQL(IClientPrepareSQLRequest *request, IClientwssqlEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CPrepareSQLRequest* esprequest = static_cast<CPrepareSQLRequest*>(request);
	esprequest->setMethod("PrepareSQL");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientwssql::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientPrepareSQLResponse *CClientwssql::PrepareSQLFn(const char * SqlText_, const char * TargetCluster_, StringArray &AlternateClusters_, const char * TargetQuerySet_, int Wait_)
{
	Owned<IClientPrepareSQLRequest> req =  createPrepareSQLRequest();
	req->setSqlText(SqlText_);
	req->setTargetCluster(TargetCluster_);
	req->setAlternateClusters(AlternateClusters_);
	req->setTargetQuerySet(TargetQuerySet_);
	req->setWait(Wait_);
	return PrepareSQL(req.get());
}

//------ method SetRelatedIndexes ---------

IClientSetRelatedIndexesRequest * CClientwssql::createSetRelatedIndexesRequest()
{
	CSetRelatedIndexesRequest* request = new CSetRelatedIndexesRequest("wssql");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientSetRelatedIndexesResponse * CClientwssql::SetRelatedIndexes(IClientSetRelatedIndexesRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CSetRelatedIndexesRequest* esprequest = static_cast<CSetRelatedIndexesRequest*>(request);
	CSetRelatedIndexesResponse* espresponse = new CSetRelatedIndexesResponse("wssql");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientwssql::async_SetRelatedIndexes(IClientSetRelatedIndexesRequest *request, IClientwssqlEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CSetRelatedIndexesRequest* esprequest = static_cast<CSetRelatedIndexesRequest*>(request);
	esprequest->setMethod("SetRelatedIndexes");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientwssql::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientSetRelatedIndexesResponse *CClientwssql::SetRelatedIndexesFn(IArrayOf<IConstRelatedIndexSet> &RelatedIndexSets_)
{
	Owned<IClientSetRelatedIndexesRequest> req =  createSetRelatedIndexesRequest();
	req->setRelatedIndexSets(RelatedIndexSets_);
	return SetRelatedIndexes(req.get());
}

int CClientwssql::transferThunkEvent(void *data)
{
	IRpcResponseBinding *response = (IRpcResponseBinding *)data;
	if (response!=NULL)
	{
		IClientwssqlEvents *eventSink = (IClientwssqlEvents *)response->getEventSink();
		response->lock();

		if (stricmp(response->getMethod(), "CreateTableAndLoad")==0)
		{
			IClientCreateTableAndLoadResponse* icresp = dynamic_cast<IClientCreateTableAndLoadResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onCreateTableAndLoadComplete(icresp, response->queryState());
				else
					eventSink->onCreateTableAndLoadError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "Echo")==0)
		{
			IClientEchoResponse* icresp = dynamic_cast<IClientEchoResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onEchoComplete(icresp, response->queryState());
				else
					eventSink->onEchoError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "ExecutePreparedSQL")==0)
		{
			IClientExecutePreparedSQLResponse* icresp = dynamic_cast<IClientExecutePreparedSQLResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onExecutePreparedSQLComplete(icresp, response->queryState());
				else
					eventSink->onExecutePreparedSQLError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "ExecuteSQL")==0)
		{
			IClientExecuteSQLResponse* icresp = dynamic_cast<IClientExecuteSQLResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onExecuteSQLComplete(icresp, response->queryState());
				else
					eventSink->onExecuteSQLError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "GetDBMetaData")==0)
		{
			IClientGetDBMetaDataResponse* icresp = dynamic_cast<IClientGetDBMetaDataResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onGetDBMetaDataComplete(icresp, response->queryState());
				else
					eventSink->onGetDBMetaDataError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "GetDBSystemInfo")==0)
		{
			IClientGetDBSystemInfoResponse* icresp = dynamic_cast<IClientGetDBSystemInfoResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onGetDBSystemInfoComplete(icresp, response->queryState());
				else
					eventSink->onGetDBSystemInfoError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "GetRelatedIndexes")==0)
		{
			IClientGetRelatedIndexesResponse* icresp = dynamic_cast<IClientGetRelatedIndexesResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onGetRelatedIndexesComplete(icresp, response->queryState());
				else
					eventSink->onGetRelatedIndexesError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "GetResults")==0)
		{
			IClientGetResultsResponse* icresp = dynamic_cast<IClientGetResultsResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onGetResultsComplete(icresp, response->queryState());
				else
					eventSink->onGetResultsError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "Ping")==0)
		{
			IClientwssqlPingResponse* icresp = dynamic_cast<IClientwssqlPingResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onPingComplete(icresp, response->queryState());
				else
					eventSink->onPingError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "PrepareSQL")==0)
		{
			IClientPrepareSQLResponse* icresp = dynamic_cast<IClientPrepareSQLResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onPrepareSQLComplete(icresp, response->queryState());
				else
					eventSink->onPrepareSQLError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "SetRelatedIndexes")==0)
		{
			IClientSetRelatedIndexesResponse* icresp = dynamic_cast<IClientSetRelatedIndexesResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onSetRelatedIndexesComplete(icresp, response->queryState());
				else
					eventSink->onSetRelatedIndexesError(icresp,response->queryState());
			}
		}
		response->unlock();
	}
	return 0;
}

static IRpcResponseBinding* createwssqlResponseObject(IRpcRequestBinding *request)
{
	const char* method = request->getMethod();
	if (stricmp(method, "CreateTableAndLoad")==0)
		return new CCreateTableAndLoadResponse("wssql", request);
	if (stricmp(method, "Echo")==0)
		return new CEchoResponse("wssql", request);
	if (stricmp(method, "ExecutePreparedSQL")==0)
		return new CExecutePreparedSQLResponse("wssql", request);
	if (stricmp(method, "ExecuteSQL")==0)
		return new CExecuteSQLResponse("wssql", request);
	if (stricmp(method, "GetDBMetaData")==0)
		return new CGetDBMetaDataResponse("wssql", request);
	if (stricmp(method, "GetDBSystemInfo")==0)
		return new CGetDBSystemInfoResponse("wssql", request);
	if (stricmp(method, "GetRelatedIndexes")==0)
		return new CGetRelatedIndexesResponse("wssql", request);
	if (stricmp(method, "GetResults")==0)
		return new CGetResultsResponse("wssql", request);
	if (stricmp(method, "Ping")==0)
		return new CwssqlPingResponse("wssql", request);
	if (stricmp(method, "PrepareSQL")==0)
		return new CPrepareSQLResponse("wssql", request);
	if (stricmp(method, "SetRelatedIndexes")==0)
		return new CSetRelatedIndexesResponse("wssql", request);
	return NULL;
}

#ifdef _WIN32
void CClientwssql::espWorkerThread(void* data)
#else
void *CClientwssql::espWorkerThread(void *data)
#endif
{
	IRpcRequestBinding *request = (IRpcRequestBinding *) data;

	if (request != NULL)
	{
		request->lock();
		IRpcResponseBinding *response=createwssqlResponseObject(request);
		if (response!=NULL)
		{
			try{
				request->post(*response);
			}
			catch(IException* ex){
				StringBuffer errorStr;
				ex->errorMessage(errorStr);
				ERRLOG("CClientwssql::espWorkerThread(%s)--Exception caught while posting async request: %s", request->getMethod(), errorStr.str());
				ex->Release();
			}
			catch(...){
				ERRLOG("Unknown exception caught while posting async request");
			}
		}
#ifdef USE_CLIENT_THREAD
		ThunkToClientThread(request->getThunkHandle(), transferThunkEvent, (void *)response);
#else
		transferThunkEvent((void *)response);
#endif
		request->unlock();
		if(request->queryState()!=NULL)
			request->queryState()->Release();

		if(response!=NULL)
			response->Release();

		request->Release();
	}
#if defined(_WIN32)
#else
	return (void *) 0 ;
#endif
}



extern "C" IClientwssql * createwssqlClient() {  return new CClientwssql(); }


#endif //ws_sql_ESPGEN_INCLUDED
