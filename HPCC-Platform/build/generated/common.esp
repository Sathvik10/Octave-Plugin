// *** Source file generated by HIDL Version 1.3 from common.ecm ***
// *** Not to be hand edited (changes will be lost on re-generation) ***

#ifndef common_ESPGEN_INCLUDED
#define common_ESPGEN_INCLUDED

#include "common_esp.ipp"

#ifdef _WIN32
#include "edwin.h"
#include <process.h>
#endif



//=======================================================
// class CNamedValue Implementation
//=======================================================

CNamedValue::CNamedValue(const char *serviceName, IRpcMessageBinding *init)
	: m_Name(nilRemove),m_Value(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("NamedValue");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CNamedValue::CNamedValue(const char *serviceName, const char *bc)
	: m_Name(nilRemove),m_Value(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("NamedValue");
}

StringBuffer &CNamedValue::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:complexType name=\"%s\">\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Name\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Value\" type=\"xsd:string\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType>\n");
		}
	}
	return schema;
}

void CNamedValue::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CNamedValue::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CNamedValue::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Name");
	form.appendf("  <tr><td><b>Name: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Value");
	form.appendf("  <tr><td><b>Value: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CNamedValue::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CNamedValue::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_Name.marshall(rpc_resp, "Name", "", "", "");
	m_Value.marshall(rpc_resp, "Value", "", "", "");
}


void CNamedValue::copy(CNamedValue &from)
{
	m_Name.copy(from.m_Name);
	m_Value.copy(from.m_Value);
}


void CNamedValue::copy(IConstNamedValue &ifrom)
{
	setName(ifrom.getName());
	setValue(ifrom.getValue());
}


void CNamedValue::getAttributes(IProperties &attributes)
{
}


void CNamedValue::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_Name.toStr(ctx, buffer, "Name", "", true, "", "");
	m_Value.toStr(ctx, buffer, "Value", "", true, "", "");
}


void CNamedValue::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CNamedValue::serializer(IEspContext* ctx, IConstNamedValue &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<NamedValue>");
	// field Name
	{
		const char* s = src.getName();
		if (s && *s)
		{
			buffer.append("<Name>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Name>");
		}
	}
	// field Value
	{
		const char* s = src.getValue();
		if (s && *s)
		{
			buffer.append("<Value>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Value>");
		}
	}
	if (keepRootTag)
		buffer.append("</NamedValue>");
}

bool CNamedValue::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_Name.unmarshall(rpc_request, "Name", basepath);
	hasValue |= m_Value.unmarshall(rpc_request, "Value", basepath);
	return hasValue;
}

bool CNamedValue::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Name.unmarshall(ctx, soapval, "Name");
	hasValue |= m_Value.unmarshall(ctx, soapval, "Value");
	return hasValue;
}

bool CNamedValue::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Name.unmarshall(ctx, params, attachments, "Name", basepath);
	hasValue |= m_Value.unmarshall(ctx, params, attachments, "Value", basepath);
	return hasValue;
}

const char * CNamedValue::getName() { return m_Name.query();}
const char * CNamedValue::getValue() { return m_Value.query();}
void CNamedValue::setName(const char * val){ m_Name.set(val); }
void CNamedValue::setValue(const char * val){ m_Value.set(val); }
extern "C"  IEspNamedValue *createNamedValue(const char *serv, const char *msgname){return ((IEspNamedValue *)new CNamedValue(serv /*, msgname*/));}
extern "C"  IClientNamedValue *createClientNamedValue(const char *serv, const char *msgname){return ((IClientNamedValue *)new CNamedValue(serv /*, msgname*/));}

//=======================================================
// class CNameAndType Implementation
//=======================================================

CNameAndType::CNameAndType(const char *serviceName, IRpcMessageBinding *init)
	: m_Name(nilRemove),m_Type(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("NameAndType");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CNameAndType::CNameAndType(const char *serviceName, const char *bc)
	: m_Name(nilRemove),m_Type(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("NameAndType");
}

StringBuffer &CNameAndType::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:complexType name=\"%s\">\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Name\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Type\" type=\"xsd:string\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType>\n");
		}
	}
	return schema;
}

void CNameAndType::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CNameAndType::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CNameAndType::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Name");
	form.appendf("  <tr><td><b>Name: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Type");
	form.appendf("  <tr><td><b>Type: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CNameAndType::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CNameAndType::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_Name.marshall(rpc_resp, "Name", "", "", "");
	m_Type.marshall(rpc_resp, "Type", "", "", "");
}


void CNameAndType::copy(CNameAndType &from)
{
	m_Name.copy(from.m_Name);
	m_Type.copy(from.m_Type);
}


void CNameAndType::copy(IConstNameAndType &ifrom)
{
	setName(ifrom.getName());
	setType(ifrom.getType());
}


void CNameAndType::getAttributes(IProperties &attributes)
{
}


void CNameAndType::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_Name.toStr(ctx, buffer, "Name", "", true, "", "");
	m_Type.toStr(ctx, buffer, "Type", "", true, "", "");
}


void CNameAndType::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CNameAndType::serializer(IEspContext* ctx, IConstNameAndType &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<NameAndType>");
	// field Name
	{
		const char* s = src.getName();
		if (s && *s)
		{
			buffer.append("<Name>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Name>");
		}
	}
	// field Type
	{
		const char* s = src.getType();
		if (s && *s)
		{
			buffer.append("<Type>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Type>");
		}
	}
	if (keepRootTag)
		buffer.append("</NameAndType>");
}

bool CNameAndType::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_Name.unmarshall(rpc_request, "Name", basepath);
	hasValue |= m_Type.unmarshall(rpc_request, "Type", basepath);
	return hasValue;
}

bool CNameAndType::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Name.unmarshall(ctx, soapval, "Name");
	hasValue |= m_Type.unmarshall(ctx, soapval, "Type");
	return hasValue;
}

bool CNameAndType::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Name.unmarshall(ctx, params, attachments, "Name", basepath);
	hasValue |= m_Type.unmarshall(ctx, params, attachments, "Type", basepath);
	return hasValue;
}

const char * CNameAndType::getName() { return m_Name.query();}
const char * CNameAndType::getType() { return m_Type.query();}
void CNameAndType::setName(const char * val){ m_Name.set(val); }
void CNameAndType::setType(const char * val){ m_Type.set(val); }
extern "C"  IEspNameAndType *createNameAndType(const char *serv, const char *msgname){return ((IEspNameAndType *)new CNameAndType(serv /*, msgname*/));}
extern "C"  IClientNameAndType *createClientNameAndType(const char *serv, const char *msgname){return ((IClientNameAndType *)new CNameAndType(serv /*, msgname*/));}

//=======================================================
// class CLogicalFileError Implementation
//=======================================================

CLogicalFileError::CLogicalFileError(const char *serviceName, IRpcMessageBinding *init)
	: m_Error(nilRemove),m_LogicalName(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("LogicalFileError");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CLogicalFileError::CLogicalFileError(const char *serviceName, const char *bc)
	: m_Error(nilRemove),m_LogicalName(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("LogicalFileError");
}

StringBuffer &CLogicalFileError::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:complexType name=\"%s\">\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Error\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"LogicalName\" type=\"xsd:string\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType>\n");
		}
	}
	return schema;
}

void CLogicalFileError::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CLogicalFileError::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CLogicalFileError::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Error");
	form.appendf("  <tr><td><b>Error: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("LogicalName");
	form.appendf("  <tr><td><b>LogicalName: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CLogicalFileError::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CLogicalFileError::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_Error.marshall(rpc_resp, "Error", "", "", "");
	m_LogicalName.marshall(rpc_resp, "LogicalName", "", "", "");
}


void CLogicalFileError::copy(CLogicalFileError &from)
{
	m_Error.copy(from.m_Error);
	m_LogicalName.copy(from.m_LogicalName);
}


void CLogicalFileError::copy(IConstLogicalFileError &ifrom)
{
	setError(ifrom.getError());
	setLogicalName(ifrom.getLogicalName());
}


void CLogicalFileError::getAttributes(IProperties &attributes)
{
}


void CLogicalFileError::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_Error.toStr(ctx, buffer, "Error", "", true, "", "");
	m_LogicalName.toStr(ctx, buffer, "LogicalName", "", true, "", "");
}


void CLogicalFileError::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CLogicalFileError::serializer(IEspContext* ctx, IConstLogicalFileError &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<LogicalFileError>");
	// field Error
	{
		const char* s = src.getError();
		if (s && *s)
		{
			buffer.append("<Error>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Error>");
		}
	}
	// field LogicalName
	{
		const char* s = src.getLogicalName();
		if (s && *s)
		{
			buffer.append("<LogicalName>");
			encodeUtf8XML(s,buffer);
			buffer.append("</LogicalName>");
		}
	}
	if (keepRootTag)
		buffer.append("</LogicalFileError>");
}

bool CLogicalFileError::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_Error.unmarshall(rpc_request, "Error", basepath);
	hasValue |= m_LogicalName.unmarshall(rpc_request, "LogicalName", basepath);
	return hasValue;
}

bool CLogicalFileError::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Error.unmarshall(ctx, soapval, "Error");
	hasValue |= m_LogicalName.unmarshall(ctx, soapval, "LogicalName");
	return hasValue;
}

bool CLogicalFileError::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Error.unmarshall(ctx, params, attachments, "Error", basepath);
	hasValue |= m_LogicalName.unmarshall(ctx, params, attachments, "LogicalName", basepath);
	return hasValue;
}

const char * CLogicalFileError::getError() { return m_Error.query();}
const char * CLogicalFileError::getLogicalName() { return m_LogicalName.query();}
void CLogicalFileError::setError(const char * val){ m_Error.set(val); }
void CLogicalFileError::setLogicalName(const char * val){ m_LogicalName.set(val); }
extern "C"  IEspLogicalFileError *createLogicalFileError(const char *serv, const char *msgname){return ((IEspLogicalFileError *)new CLogicalFileError(serv /*, msgname*/));}
extern "C"  IClientLogicalFileError *createClientLogicalFileError(const char *serv, const char *msgname){return ((IClientLogicalFileError *)new CLogicalFileError(serv /*, msgname*/));}
#endif //common_ESPGEN_INCLUDED
