// *** Source file generated by HIDL Version 1.3 from ws_espcontrol.ecm ***
// *** Not to be hand edited (changes will be lost on re-generation) ***

#ifndef ws_espcontrol_ESPGEN_INCLUDED
#define ws_espcontrol_ESPGEN_INCLUDED

#include "ws_espcontrol_esp.ipp"

#ifdef _WIN32
#include "edwin.h"
#include <process.h>
#endif



//=======================================================
// class CSetLoggingRequest Implementation
//=======================================================

CSetLoggingRequest::CSetLoggingRequest(const char *serviceName, IRpcMessageBinding *init)
	: m_LoggingLevel(nilRemove),m_LogRequests(nilRemove),m_LogResponses(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("SetLoggingRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CSetLoggingRequest::CSetLoggingRequest(const char *serviceName, const char *bc)
	: m_LoggingLevel(nilRemove),m_LogRequests(nilRemove),m_LogResponses(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("SetLoggingRequest");
}

CSetLoggingRequest::CSetLoggingRequest(const char *serviceName, IRpcMessage* rpcmsg)
	: m_LoggingLevel(nilRemove),m_LogRequests(nilRemove),m_LogResponses(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("SetLoggingRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CSetLoggingRequest::CSetLoggingRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_LoggingLevel(nilRemove),m_LogRequests(nilRemove),m_LogResponses(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("SetLoggingRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CSetLoggingRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"LoggingLevel\" type=\"xsd:int\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"LogRequests\" type=\"xsd:boolean\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"LogResponses\" type=\"xsd:boolean\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CSetLoggingRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CSetLoggingRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CSetLoggingRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix) extfix.append(prefix).append(".");
		extfix.append("LoggingLevel");
	form.appendf("  <tr><td><b>LoggingLevel: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("LogRequests");
	
	form.appendf("  <tr><td><b>LogRequests? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("LogResponses");
	
	form.appendf("  <tr><td><b>LogResponses? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CSetLoggingRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CSetLoggingRequest::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_LoggingLevel.marshall(rpc_resp, "LoggingLevel", "", "", "");
	m_LogRequests.marshall(rpc_resp, "LogRequests", "", "", "");
	m_LogResponses.marshall(rpc_resp, "LogResponses", "", "", "");
}


void CSetLoggingRequest::copy(CSetLoggingRequest &from)
{
	m_LoggingLevel.copy(from.m_LoggingLevel);
	m_LogRequests.copy(from.m_LogRequests);
	m_LogResponses.copy(from.m_LogResponses);
}


void CSetLoggingRequest::copy(IConstSetLoggingRequest &ifrom)
{
	setLoggingLevel(ifrom.getLoggingLevel());
	setLogRequests(ifrom.getLogRequests());
	setLogResponses(ifrom.getLogResponses());
}


void CSetLoggingRequest::getAttributes(IProperties &attributes)
{
}


void CSetLoggingRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_LoggingLevel.toStr(ctx, buffer, "LoggingLevel", "", true, "", "");
	m_LogRequests.toStr(ctx, buffer, "LogRequests", "", true, "", "");
	m_LogResponses.toStr(ctx, buffer, "LogResponses", "", true, "", "");
}


void CSetLoggingRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CSetLoggingRequest::serializer(IEspContext* ctx, IConstSetLoggingRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<SetLoggingRequest>");
	// field LoggingLevel
	{
		int n = src.getLoggingLevel();
		if (n)
			buffer.appendf("<LoggingLevel>%d</LoggingLevel>", n);
	}
	// field LogRequests
	{
		bool b = src.getLogRequests();
		if (b)
			buffer.appendf("<LogRequests>1</LogRequests>");
	}
	// field LogResponses
	{
		bool b = src.getLogResponses();
		if (b)
			buffer.appendf("<LogResponses>1</LogResponses>");
	}
	if (keepRootTag)
		buffer.append("</SetLoggingRequest>");
}

bool CSetLoggingRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_LoggingLevel.unmarshall(rpc_request, "LoggingLevel", basepath);
	hasValue |= m_LogRequests.unmarshall(rpc_request, "LogRequests", basepath);
	hasValue |= m_LogResponses.unmarshall(rpc_request, "LogResponses", basepath);
	return hasValue;
}

bool CSetLoggingRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_LoggingLevel.unmarshall(ctx, soapval, "LoggingLevel");
	hasValue |= m_LogRequests.unmarshall(ctx, soapval, "LogRequests");
	hasValue |= m_LogResponses.unmarshall(ctx, soapval, "LogResponses");
	return hasValue;
}

bool CSetLoggingRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_LoggingLevel.unmarshall(ctx, params, attachments, "LoggingLevel", basepath);
	hasValue |= m_LogRequests.unmarshall(ctx, params, attachments, "LogRequests", basepath);
	hasValue |= m_LogResponses.unmarshall(ctx, params, attachments, "LogResponses", basepath);
	return hasValue;
}

bool CSetLoggingRequest::getLoggingLevel_isNull(){return m_LoggingLevel.is_nil();}
int CSetLoggingRequest::getLoggingLevel() { return m_LoggingLevel;}
bool CSetLoggingRequest::getLogRequests_isNull(){return m_LogRequests.is_nil();}
bool CSetLoggingRequest::getLogRequests() { return m_LogRequests;}
bool CSetLoggingRequest::getLogResponses_isNull(){return m_LogResponses.is_nil();}
bool CSetLoggingRequest::getLogResponses() { return m_LogResponses;}
void CSetLoggingRequest::setLoggingLevel_null(){ m_LoggingLevel.Nil(); }void CSetLoggingRequest::setLoggingLevel(int val){ m_LoggingLevel=val; }
void CSetLoggingRequest::setLogRequests_null(){ m_LogRequests.Nil(); }void CSetLoggingRequest::setLogRequests(bool val){ m_LogRequests=val; }
void CSetLoggingRequest::setLogResponses_null(){ m_LogResponses.Nil(); }void CSetLoggingRequest::setLogResponses(bool val){ m_LogResponses=val; }
extern "C"  IEspSetLoggingRequest *createSetLoggingRequest(const char *serv){return ((IEspSetLoggingRequest *)new CSetLoggingRequest(serv));}
extern "C"  IClientSetLoggingRequest *createClientSetLoggingRequest(const char *serv){return ((IClientSetLoggingRequest *)new CSetLoggingRequest(serv));}

//=======================================================
// class CSetLoggingResponse Implementation
//=======================================================

CSetLoggingResponse::CSetLoggingResponse(const char *serviceName, IRpcMessageBinding *init)
	: m_Status(nilRemove),m_Message(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("SetLoggingResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CSetLoggingResponse::CSetLoggingResponse(const char *serviceName, const char *bc)
	: m_Status(nilRemove),m_Message(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("SetLoggingResponse");
}

CSetLoggingResponse::CSetLoggingResponse(const char *serviceName, IRpcMessage* rpcmsg)
	: m_Status(nilRemove),m_Message(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("SetLoggingResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CSetLoggingResponse::CSetLoggingResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_Status(nilRemove),m_Message(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("SetLoggingResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CSetLoggingResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		schema.append("<xsd:element name=\"Exceptions\" type=\"tns:ArrayOfEspException\" minOccurs=\"0\" maxOccurs=\"1\"/>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Status\" type=\"xsd:int\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Message\" type=\"xsd:string\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CSetLoggingResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CSetLoggingResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CSetLoggingResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix) extfix.append(prefix).append(".");
		extfix.append("Status");
	form.appendf("  <tr><td><b>Status: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Message");
	form.appendf("  <tr><td><b>Message: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CSetLoggingResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CSetLoggingResponse::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
		m_Status.marshall(rpc_resp, "Status", "", "", "");
		m_Message.marshall(rpc_resp, "Message", "", "", "");
	}
}


void CSetLoggingResponse::copy(CSetLoggingResponse &from)
{
	m_Status.copy(from.m_Status);
	m_Message.copy(from.m_Message);
}


void CSetLoggingResponse::copy(IConstSetLoggingResponse &ifrom)
{
	setStatus(ifrom.getStatus());
	setMessage(ifrom.getMessage());
}


void CSetLoggingResponse::getAttributes(IProperties &attributes)
{
}


void CSetLoggingResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
		m_Status.toStr(ctx, buffer, "Status", "", false, "", "");
		m_Message.toStr(ctx, buffer, "Message", "", false, "", "");
	}
}


void CSetLoggingResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CSetLoggingResponse::serializer(IEspContext* ctx, IConstSetLoggingResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<SetLoggingResponse>");
	// field Status
	{
		int n = src.getStatus();
		if (n)
			buffer.appendf("<Status>%d</Status>", n);
	}
	// field Message
	{
		const char* s = src.getMessage();
		if (s && *s)
		{
			buffer.append("<Message>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Message>");
		}
	}
	if (keepRootTag)
		buffer.append("</SetLoggingResponse>");
}

bool CSetLoggingResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
		hasValue |= m_Status.unmarshall(rpc_request, "Status", basepath);
		hasValue |= m_Message.unmarshall(rpc_request, "Message", basepath);
	}
	return hasValue;
}

bool CSetLoggingResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Status.unmarshall(ctx, soapval, "Status");
	hasValue |= m_Message.unmarshall(ctx, soapval, "Message");
	return hasValue;
}

bool CSetLoggingResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Status.unmarshall(ctx, params, attachments, "Status", basepath);
	hasValue |= m_Message.unmarshall(ctx, params, attachments, "Message", basepath);
	return hasValue;
}

bool CSetLoggingResponse::getStatus_isNull(){return m_Status.is_nil();}
int CSetLoggingResponse::getStatus() { return m_Status;}
const char * CSetLoggingResponse::getMessage() { return m_Message.query();}
void CSetLoggingResponse::setStatus_null(){ m_Status.Nil(); }void CSetLoggingResponse::setStatus(int val){ m_Status=val; }
void CSetLoggingResponse::setMessage(const char * val){ m_Message.set(val); }
extern "C"  IEspSetLoggingResponse *createSetLoggingResponse(const char *serv){return ((IEspSetLoggingResponse *)new CSetLoggingResponse(serv));}
extern "C"  IClientSetLoggingResponse *createClientSetLoggingResponse(const char *serv){return ((IClientSetLoggingResponse *)new CSetLoggingResponse(serv));}

//=======================================================
// class CSession Implementation
//=======================================================

CSession::CSession(const char *serviceName, IRpcMessageBinding *init)
	: m_ID(nilRemove),m_UserID(nilRemove),m_NetworkAddress(nilRemove),m_CreateTime(nilRemove),m_LastAccessed(nilRemove),m_TimeoutAt(nilRemove),m_Port(nilRemove),m_TimeoutByAdmin(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("Session");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CSession::CSession(const char *serviceName, const char *bc)
	: m_ID(nilRemove),m_UserID(nilRemove),m_NetworkAddress(nilRemove),m_CreateTime(nilRemove),m_LastAccessed(nilRemove),m_TimeoutAt(nilRemove),m_Port(nilRemove),m_TimeoutByAdmin(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("Session");
}

StringBuffer &CSession::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:complexType name=\"%s\">\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"ID\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"UserID\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"NetworkAddress\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"CreateTime\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"LastAccessed\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"TimeoutAt\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Port\" type=\"xsd:int\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"TimeoutByAdmin\" type=\"xsd:boolean\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType>\n");
		}
	}
	return schema;
}

void CSession::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CSession::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CSession::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("ID");
	form.appendf("  <tr><td><b>ID: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("UserID");
	form.appendf("  <tr><td><b>UserID: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("NetworkAddress");
	form.appendf("  <tr><td><b>NetworkAddress: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("CreateTime");
	form.appendf("  <tr><td><b>CreateTime: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("LastAccessed");
	form.appendf("  <tr><td><b>LastAccessed: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("TimeoutAt");
	form.appendf("  <tr><td><b>TimeoutAt: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix) extfix.append(prefix).append(".");
		extfix.append("Port");
	form.appendf("  <tr><td><b>Port: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("TimeoutByAdmin");
	
	form.appendf("  <tr><td><b>TimeoutByAdmin? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CSession::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CSession::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_ID.marshall(rpc_resp, "ID", "", "", "");
	m_UserID.marshall(rpc_resp, "UserID", "", "", "");
	m_NetworkAddress.marshall(rpc_resp, "NetworkAddress", "", "", "");
	m_CreateTime.marshall(rpc_resp, "CreateTime", "", "", "");
	m_LastAccessed.marshall(rpc_resp, "LastAccessed", "", "", "");
	m_TimeoutAt.marshall(rpc_resp, "TimeoutAt", "", "", "");
	m_Port.marshall(rpc_resp, "Port", "", "", "");
	m_TimeoutByAdmin.marshall(rpc_resp, "TimeoutByAdmin", "", "", "");
}


void CSession::copy(CSession &from)
{
	m_ID.copy(from.m_ID);
	m_UserID.copy(from.m_UserID);
	m_NetworkAddress.copy(from.m_NetworkAddress);
	m_CreateTime.copy(from.m_CreateTime);
	m_LastAccessed.copy(from.m_LastAccessed);
	m_TimeoutAt.copy(from.m_TimeoutAt);
	m_Port.copy(from.m_Port);
	m_TimeoutByAdmin.copy(from.m_TimeoutByAdmin);
}


void CSession::copy(IConstSession &ifrom)
{
	setID(ifrom.getID());
	setUserID(ifrom.getUserID());
	setNetworkAddress(ifrom.getNetworkAddress());
	setCreateTime(ifrom.getCreateTime());
	setLastAccessed(ifrom.getLastAccessed());
	setTimeoutAt(ifrom.getTimeoutAt());
	setPort(ifrom.getPort());
	setTimeoutByAdmin(ifrom.getTimeoutByAdmin());
}


void CSession::getAttributes(IProperties &attributes)
{
}


void CSession::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_ID.toStr(ctx, buffer, "ID", "", true, "", "");
	m_UserID.toStr(ctx, buffer, "UserID", "", true, "", "");
	m_NetworkAddress.toStr(ctx, buffer, "NetworkAddress", "", true, "", "");
	m_CreateTime.toStr(ctx, buffer, "CreateTime", "", true, "", "");
	m_LastAccessed.toStr(ctx, buffer, "LastAccessed", "", true, "", "");
	m_TimeoutAt.toStr(ctx, buffer, "TimeoutAt", "", true, "", "");
	m_Port.toStr(ctx, buffer, "Port", "", true, "", "");
	m_TimeoutByAdmin.toStr(ctx, buffer, "TimeoutByAdmin", "", true, "", "");
}


void CSession::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CSession::serializer(IEspContext* ctx, IConstSession &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<Session>");
	// field ID
	{
		const char* s = src.getID();
		if (s && *s)
		{
			buffer.append("<ID>");
			encodeUtf8XML(s,buffer);
			buffer.append("</ID>");
		}
	}
	// field UserID
	{
		const char* s = src.getUserID();
		if (s && *s)
		{
			buffer.append("<UserID>");
			encodeUtf8XML(s,buffer);
			buffer.append("</UserID>");
		}
	}
	// field NetworkAddress
	{
		const char* s = src.getNetworkAddress();
		if (s && *s)
		{
			buffer.append("<NetworkAddress>");
			encodeUtf8XML(s,buffer);
			buffer.append("</NetworkAddress>");
		}
	}
	// field CreateTime
	{
		const char* s = src.getCreateTime();
		if (s && *s)
		{
			buffer.append("<CreateTime>");
			encodeUtf8XML(s,buffer);
			buffer.append("</CreateTime>");
		}
	}
	// field LastAccessed
	{
		const char* s = src.getLastAccessed();
		if (s && *s)
		{
			buffer.append("<LastAccessed>");
			encodeUtf8XML(s,buffer);
			buffer.append("</LastAccessed>");
		}
	}
	// field TimeoutAt
	{
		const char* s = src.getTimeoutAt();
		if (s && *s)
		{
			buffer.append("<TimeoutAt>");
			encodeUtf8XML(s,buffer);
			buffer.append("</TimeoutAt>");
		}
	}
	// field Port
	{
		int n = src.getPort();
		if (n)
			buffer.appendf("<Port>%d</Port>", n);
	}
	// field TimeoutByAdmin
	{
		bool b = src.getTimeoutByAdmin();
		if (b)
			buffer.appendf("<TimeoutByAdmin>1</TimeoutByAdmin>");
	}
	if (keepRootTag)
		buffer.append("</Session>");
}

bool CSession::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_ID.unmarshall(rpc_request, "ID", basepath);
	hasValue |= m_UserID.unmarshall(rpc_request, "UserID", basepath);
	hasValue |= m_NetworkAddress.unmarshall(rpc_request, "NetworkAddress", basepath);
	hasValue |= m_CreateTime.unmarshall(rpc_request, "CreateTime", basepath);
	hasValue |= m_LastAccessed.unmarshall(rpc_request, "LastAccessed", basepath);
	hasValue |= m_TimeoutAt.unmarshall(rpc_request, "TimeoutAt", basepath);
	hasValue |= m_Port.unmarshall(rpc_request, "Port", basepath);
	hasValue |= m_TimeoutByAdmin.unmarshall(rpc_request, "TimeoutByAdmin", basepath);
	return hasValue;
}

bool CSession::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_ID.unmarshall(ctx, soapval, "ID");
	hasValue |= m_UserID.unmarshall(ctx, soapval, "UserID");
	hasValue |= m_NetworkAddress.unmarshall(ctx, soapval, "NetworkAddress");
	hasValue |= m_CreateTime.unmarshall(ctx, soapval, "CreateTime");
	hasValue |= m_LastAccessed.unmarshall(ctx, soapval, "LastAccessed");
	hasValue |= m_TimeoutAt.unmarshall(ctx, soapval, "TimeoutAt");
	hasValue |= m_Port.unmarshall(ctx, soapval, "Port");
	hasValue |= m_TimeoutByAdmin.unmarshall(ctx, soapval, "TimeoutByAdmin");
	return hasValue;
}

bool CSession::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_ID.unmarshall(ctx, params, attachments, "ID", basepath);
	hasValue |= m_UserID.unmarshall(ctx, params, attachments, "UserID", basepath);
	hasValue |= m_NetworkAddress.unmarshall(ctx, params, attachments, "NetworkAddress", basepath);
	hasValue |= m_CreateTime.unmarshall(ctx, params, attachments, "CreateTime", basepath);
	hasValue |= m_LastAccessed.unmarshall(ctx, params, attachments, "LastAccessed", basepath);
	hasValue |= m_TimeoutAt.unmarshall(ctx, params, attachments, "TimeoutAt", basepath);
	hasValue |= m_Port.unmarshall(ctx, params, attachments, "Port", basepath);
	hasValue |= m_TimeoutByAdmin.unmarshall(ctx, params, attachments, "TimeoutByAdmin", basepath);
	return hasValue;
}

const char * CSession::getID() { return m_ID.query();}
const char * CSession::getUserID() { return m_UserID.query();}
const char * CSession::getNetworkAddress() { return m_NetworkAddress.query();}
const char * CSession::getCreateTime() { return m_CreateTime.query();}
const char * CSession::getLastAccessed() { return m_LastAccessed.query();}
const char * CSession::getTimeoutAt() { return m_TimeoutAt.query();}
bool CSession::getPort_isNull(){return m_Port.is_nil();}
int CSession::getPort() { return m_Port;}
bool CSession::getTimeoutByAdmin_isNull(){return m_TimeoutByAdmin.is_nil();}
bool CSession::getTimeoutByAdmin() { return m_TimeoutByAdmin;}
void CSession::setID(const char * val){ m_ID.set(val); }
void CSession::setUserID(const char * val){ m_UserID.set(val); }
void CSession::setNetworkAddress(const char * val){ m_NetworkAddress.set(val); }
void CSession::setCreateTime(const char * val){ m_CreateTime.set(val); }
void CSession::setLastAccessed(const char * val){ m_LastAccessed.set(val); }
void CSession::setTimeoutAt(const char * val){ m_TimeoutAt.set(val); }
void CSession::setPort_null(){ m_Port.Nil(); }void CSession::setPort(int val){ m_Port=val; }
void CSession::setTimeoutByAdmin_null(){ m_TimeoutByAdmin.Nil(); }void CSession::setTimeoutByAdmin(bool val){ m_TimeoutByAdmin=val; }
extern "C"  IEspSession *createSession(const char *serv, const char *msgname){return ((IEspSession *)new CSession(serv /*, msgname*/));}
extern "C"  IClientSession *createClientSession(const char *serv, const char *msgname){return ((IClientSession *)new CSession(serv /*, msgname*/));}

//=======================================================
// class CSessionQueryRequest Implementation
//=======================================================

CSessionQueryRequest::CSessionQueryRequest(const char *serviceName, IRpcMessageBinding *init)
	: m_FromIP(nilRemove),m_UserID(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("SessionQueryRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CSessionQueryRequest::CSessionQueryRequest(const char *serviceName, const char *bc)
	: m_FromIP(nilRemove),m_UserID(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("SessionQueryRequest");
}

CSessionQueryRequest::CSessionQueryRequest(const char *serviceName, IRpcMessage* rpcmsg)
	: m_FromIP(nilRemove),m_UserID(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("SessionQueryRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CSessionQueryRequest::CSessionQueryRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_FromIP(nilRemove),m_UserID(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("SessionQueryRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CSessionQueryRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"FromIP\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"UserID\" type=\"xsd:string\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CSessionQueryRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CSessionQueryRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CSessionQueryRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("FromIP");
	form.appendf("  <tr><td><b>FromIP: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("UserID");
	form.appendf("  <tr><td><b>UserID: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CSessionQueryRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CSessionQueryRequest::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_FromIP.marshall(rpc_resp, "FromIP", "", "", "");
	m_UserID.marshall(rpc_resp, "UserID", "", "", "");
}


void CSessionQueryRequest::copy(CSessionQueryRequest &from)
{
	m_FromIP.copy(from.m_FromIP);
	m_UserID.copy(from.m_UserID);
}


void CSessionQueryRequest::copy(IConstSessionQueryRequest &ifrom)
{
	setFromIP(ifrom.getFromIP());
	setUserID(ifrom.getUserID());
}


void CSessionQueryRequest::getAttributes(IProperties &attributes)
{
}


void CSessionQueryRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_FromIP.toStr(ctx, buffer, "FromIP", "", true, "", "");
	m_UserID.toStr(ctx, buffer, "UserID", "", true, "", "");
}


void CSessionQueryRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CSessionQueryRequest::serializer(IEspContext* ctx, IConstSessionQueryRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<SessionQueryRequest>");
	// field FromIP
	{
		const char* s = src.getFromIP();
		if (s && *s)
		{
			buffer.append("<FromIP>");
			encodeUtf8XML(s,buffer);
			buffer.append("</FromIP>");
		}
	}
	// field UserID
	{
		const char* s = src.getUserID();
		if (s && *s)
		{
			buffer.append("<UserID>");
			encodeUtf8XML(s,buffer);
			buffer.append("</UserID>");
		}
	}
	if (keepRootTag)
		buffer.append("</SessionQueryRequest>");
}

bool CSessionQueryRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_FromIP.unmarshall(rpc_request, "FromIP", basepath);
	hasValue |= m_UserID.unmarshall(rpc_request, "UserID", basepath);
	return hasValue;
}

bool CSessionQueryRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_FromIP.unmarshall(ctx, soapval, "FromIP");
	hasValue |= m_UserID.unmarshall(ctx, soapval, "UserID");
	return hasValue;
}

bool CSessionQueryRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_FromIP.unmarshall(ctx, params, attachments, "FromIP", basepath);
	hasValue |= m_UserID.unmarshall(ctx, params, attachments, "UserID", basepath);
	return hasValue;
}

const char * CSessionQueryRequest::getFromIP() { return m_FromIP.query();}
const char * CSessionQueryRequest::getUserID() { return m_UserID.query();}
void CSessionQueryRequest::setFromIP(const char * val){ m_FromIP.set(val); }
void CSessionQueryRequest::setUserID(const char * val){ m_UserID.set(val); }
extern "C"  IEspSessionQueryRequest *createSessionQueryRequest(const char *serv){return ((IEspSessionQueryRequest *)new CSessionQueryRequest(serv));}
extern "C"  IClientSessionQueryRequest *createClientSessionQueryRequest(const char *serv){return ((IClientSessionQueryRequest *)new CSessionQueryRequest(serv));}

//=======================================================
// class CSessionQueryResponse Implementation
//=======================================================

CSessionQueryResponse::CSessionQueryResponse(const char *serviceName, IRpcMessageBinding *init)
	: m_Sessions(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("SessionQueryResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CSessionQueryResponse::CSessionQueryResponse(const char *serviceName, const char *bc)
	: m_Sessions(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("SessionQueryResponse");
}

CSessionQueryResponse::CSessionQueryResponse(const char *serviceName, IRpcMessage* rpcmsg)
	: m_Sessions(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("SessionQueryResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CSessionQueryResponse::CSessionQueryResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_Sessions(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("SessionQueryResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CSessionQueryResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		schema.append("<xsd:element name=\"Exceptions\" type=\"tns:ArrayOfEspException\" minOccurs=\"0\" maxOccurs=\"1\"/>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Sessions\" type=\"tns:ArrayOfSession\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	if (!(flags & 0x10)  || (flags & 0x100))
	{
		CSession::getXsdDefinition(context, request, schema, added);
	}
	if (added.getValue("Session") && added.getValue("ArrayOfSession")==NULL) {
		schema.append("<xsd:complexType name=\"ArrayOfSession\">\n");
		schema.append("<xsd:sequence>\n");
		schema.append("<xsd:element minOccurs=\"0\" maxOccurs=\"unbounded\" name=\"Session\" type=\"tns:Session\"/>\n");
		schema.append("</xsd:sequence>\n");
		schema.append("</xsd:complexType>\n");
		added.setValue("ArrayOfSession",1);
	}
	return schema;
}

void CSessionQueryResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CSessionQueryResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
	if (!added.getValue("Session"))
	{
		added.setValue("Session",1);
		CSession::getMapInfo(info,added);
	}
}

StringBuffer &CSessionQueryResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Sessions");
	form.appendf("<tr><td><b>Sessions: </b></td><td>");
	form.appendf("<table><tr><td><textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea></td>", extfix.str());
	form.append("</tr></table>");
	form.append("</td></tr>");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CSessionQueryResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CSessionQueryResponse::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
		m_Sessions.marshall(rpc_resp, "Sessions", "Session");
	}
}


void CSessionQueryResponse::copy(CSessionQueryResponse &from)
{
	m_Sessions.copy(from.m_Sessions);
}


void CSessionQueryResponse::copy(IConstSessionQueryResponse &ifrom)
{
	setSessions(ifrom.getSessions());
}


void CSessionQueryResponse::getAttributes(IProperties &attributes)
{
}


void CSessionQueryResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
		m_Sessions.toStr(ctx, buffer, "Sessions", "Session");
	}
}


void CSessionQueryResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CSessionQueryResponse::serializer(IEspContext* ctx, IConstSessionQueryResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<SessionQueryResponse>");
	// field Sessions
	{
		IArrayOf<IConstSession>& v = src.getSessions();
		int size = v.length();
		if (size>0)
			buffer.append("<Sessions>");
		for (int i=0;i<size;i++)
		{
			buffer.append("<Item>");
			CSession::serializer(ctx,v.item(i),buffer,false);
			buffer.append("</Item>");
		}
		if (size>0)
			buffer.append("</Sessions>");
	}
	if (keepRootTag)
		buffer.append("</SessionQueryResponse>");
}

bool CSessionQueryResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
		hasValue |= m_Sessions.unmarshall(rpc_request, "Sessions", basepath);
	}
	return hasValue;
}

bool CSessionQueryResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Sessions.unmarshall(ctx, soapval, "Sessions");
	return hasValue;
}

bool CSessionQueryResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Sessions.unmarshall(ctx, params, attachments, "Sessions", basepath);
	return hasValue;
}

IArrayOf<IConstSession> & CSessionQueryResponse::getSessions() { return (IArrayOf<IConstSession> &) m_Sessions; }
void CSessionQueryResponse::setSessions(IArrayOf<IEspSession> &val)
{
	m_Sessions->kill();
	IArrayOf<IConstSession> &target = m_Sessions.getValue();
	ForEachItemIn(idx, val)
	{
		IEspSession &item = (val).item(idx);
		item.Link();
		target.append(item);
	}
}
void CSessionQueryResponse::setSessions(IArrayOf<IConstSession> &val)
{
	m_Sessions->kill();
	IArrayOf<IConstSession> &target = m_Sessions.getValue();
	ForEachItemIn(idx, val)
	{
		IConstSession &item = val.item(idx);
		item.Link();
		target.append(item);
	}
}
extern "C"  IEspSessionQueryResponse *createSessionQueryResponse(const char *serv){return ((IEspSessionQueryResponse *)new CSessionQueryResponse(serv));}
extern "C"  IClientSessionQueryResponse *createClientSessionQueryResponse(const char *serv){return ((IClientSessionQueryResponse *)new CSessionQueryResponse(serv));}

//=======================================================
// class CSessionInfoRequest Implementation
//=======================================================

CSessionInfoRequest::CSessionInfoRequest(const char *serviceName, IRpcMessageBinding *init)
	: m_Port(nilRemove),m_ID(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("SessionInfoRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CSessionInfoRequest::CSessionInfoRequest(const char *serviceName, const char *bc)
	: m_Port(nilRemove),m_ID(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("SessionInfoRequest");
}

CSessionInfoRequest::CSessionInfoRequest(const char *serviceName, IRpcMessage* rpcmsg)
	: m_Port(nilRemove),m_ID(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("SessionInfoRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CSessionInfoRequest::CSessionInfoRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_Port(nilRemove),m_ID(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("SessionInfoRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CSessionInfoRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Port\" type=\"xsd:int\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"ID\" type=\"xsd:string\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CSessionInfoRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CSessionInfoRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CSessionInfoRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix) extfix.append(prefix).append(".");
		extfix.append("Port");
	form.appendf("  <tr><td><b>Port: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("ID");
	form.appendf("  <tr><td><b>ID: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CSessionInfoRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CSessionInfoRequest::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_Port.marshall(rpc_resp, "Port", "", "", "");
	m_ID.marshall(rpc_resp, "ID", "", "", "");
}


void CSessionInfoRequest::copy(CSessionInfoRequest &from)
{
	m_Port.copy(from.m_Port);
	m_ID.copy(from.m_ID);
}


void CSessionInfoRequest::copy(IConstSessionInfoRequest &ifrom)
{
	setPort(ifrom.getPort());
	setID(ifrom.getID());
}


void CSessionInfoRequest::getAttributes(IProperties &attributes)
{
}


void CSessionInfoRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_Port.toStr(ctx, buffer, "Port", "", true, "", "");
	m_ID.toStr(ctx, buffer, "ID", "", true, "", "");
}


void CSessionInfoRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CSessionInfoRequest::serializer(IEspContext* ctx, IConstSessionInfoRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<SessionInfoRequest>");
	// field Port
	{
		int n = src.getPort();
		if (n)
			buffer.appendf("<Port>%d</Port>", n);
	}
	// field ID
	{
		const char* s = src.getID();
		if (s && *s)
		{
			buffer.append("<ID>");
			encodeUtf8XML(s,buffer);
			buffer.append("</ID>");
		}
	}
	if (keepRootTag)
		buffer.append("</SessionInfoRequest>");
}

bool CSessionInfoRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_Port.unmarshall(rpc_request, "Port", basepath);
	hasValue |= m_ID.unmarshall(rpc_request, "ID", basepath);
	return hasValue;
}

bool CSessionInfoRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Port.unmarshall(ctx, soapval, "Port");
	hasValue |= m_ID.unmarshall(ctx, soapval, "ID");
	return hasValue;
}

bool CSessionInfoRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Port.unmarshall(ctx, params, attachments, "Port", basepath);
	hasValue |= m_ID.unmarshall(ctx, params, attachments, "ID", basepath);
	return hasValue;
}

bool CSessionInfoRequest::getPort_isNull(){return m_Port.is_nil();}
int CSessionInfoRequest::getPort() { return m_Port;}
const char * CSessionInfoRequest::getID() { return m_ID.query();}
void CSessionInfoRequest::setPort_null(){ m_Port.Nil(); }void CSessionInfoRequest::setPort(int val){ m_Port=val; }
void CSessionInfoRequest::setID(const char * val){ m_ID.set(val); }
extern "C"  IEspSessionInfoRequest *createSessionInfoRequest(const char *serv){return ((IEspSessionInfoRequest *)new CSessionInfoRequest(serv));}
extern "C"  IClientSessionInfoRequest *createClientSessionInfoRequest(const char *serv){return ((IClientSessionInfoRequest *)new CSessionInfoRequest(serv));}

//=======================================================
// class CSessionInfoResponse Implementation
//=======================================================

CSessionInfoResponse::CSessionInfoResponse(const char *serviceName, IRpcMessageBinding *init)
	: m_Session(serviceName, nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("SessionInfoResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CSessionInfoResponse::CSessionInfoResponse(const char *serviceName, const char *bc)
	: m_Session(serviceName, nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("SessionInfoResponse");
}

CSessionInfoResponse::CSessionInfoResponse(const char *serviceName, IRpcMessage* rpcmsg)
	: m_Session(serviceName, nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("SessionInfoResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CSessionInfoResponse::CSessionInfoResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_Session(serviceName, nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("SessionInfoResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CSessionInfoResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		schema.append("<xsd:element name=\"Exceptions\" type=\"tns:ArrayOfEspException\" minOccurs=\"0\" maxOccurs=\"1\"/>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Session\" type=\"tns:Session\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	if (!(flags & 0x10)  || (flags & 0x100))
	{
		CSession::getXsdDefinition(context, request, schema, added);
	}
	return schema;
}

void CSessionInfoResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CSessionInfoResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
	if (!added.getValue("Session"))
	{
		added.setValue("Session",1);
		CSession::getMapInfo(info,added);
	}
}

StringBuffer &CSessionInfoResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Session");
	form.append("<tr>").append("<td><b>Session: </b></td><td><hr/>");
	CSession::getHtmlForm(context, request, serv, method, form, false, extfix.str());
	form.append("<hr/></td></tr>");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CSessionInfoResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CSessionInfoResponse::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
		m_Session.marshall(rpc_resp, "Session", "", "", "");
	}
}


void CSessionInfoResponse::copy(CSessionInfoResponse &from)
{
	m_Session.copy(from.m_Session);
}


void CSessionInfoResponse::copy(IConstSessionInfoResponse &ifrom)
{
	setSession(ifrom.getSession());
}


void CSessionInfoResponse::getAttributes(IProperties &attributes)
{
}


void CSessionInfoResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
		m_Session.toStr(ctx, buffer, "Session", "", false, "", "");
	}
}


void CSessionInfoResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CSessionInfoResponse::serializer(IEspContext* ctx, IConstSessionInfoResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<SessionInfoResponse>");
	// field Session
	{
		StringBuffer tmp;
		CSession::serializer(ctx,src.getSession(), tmp, false);
		if (tmp.length()>0)
			buffer.appendf("<Session>%s</Session>",tmp.str());
	}
	if (keepRootTag)
		buffer.append("</SessionInfoResponse>");
}

bool CSessionInfoResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
		hasValue |= m_Session.unmarshall(rpc_request, "Session", basepath);
	}
	return hasValue;
}

bool CSessionInfoResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Session.unmarshall(ctx, soapval, "Session");
	return hasValue;
}

bool CSessionInfoResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Session.unmarshall(ctx, params, attachments, "Session", basepath);
	return hasValue;
}

IConstSession & CSessionInfoResponse::getSession() { return (IConstSession &) m_Session.getValue();}
IEspSession & CSessionInfoResponse::updateSession(){ return (IEspSession &) m_Session.getValue(); }
void CSessionInfoResponse::setSession(IConstSession &ifrom){ m_Session.copy(ifrom); }
extern "C"  IEspSessionInfoResponse *createSessionInfoResponse(const char *serv){return ((IEspSessionInfoResponse *)new CSessionInfoResponse(serv));}
extern "C"  IClientSessionInfoResponse *createClientSessionInfoResponse(const char *serv){return ((IClientSessionInfoResponse *)new CSessionInfoResponse(serv));}

//=======================================================
// class CCleanSessionRequest Implementation
//=======================================================

CCleanSessionRequest::CCleanSessionRequest(const char *serviceName, IRpcMessageBinding *init)
	: m_ID(nilRemove),m_UserID(nilRemove),m_FromIP(nilRemove),m_AllSessions(0, nilRemove,false)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("CleanSessionRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CCleanSessionRequest::CCleanSessionRequest(const char *serviceName, const char *bc)
	: m_ID(nilRemove),m_UserID(nilRemove),m_FromIP(nilRemove),m_AllSessions(0, nilRemove,false)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("CleanSessionRequest");
}

CCleanSessionRequest::CCleanSessionRequest(const char *serviceName, IRpcMessage* rpcmsg)
	: m_ID(nilRemove),m_UserID(nilRemove),m_FromIP(nilRemove),m_AllSessions(0, nilRemove,false)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("CleanSessionRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CCleanSessionRequest::CCleanSessionRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_ID(nilRemove),m_UserID(nilRemove),m_FromIP(nilRemove),m_AllSessions(0, nilRemove,false)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("CleanSessionRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CCleanSessionRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"ID\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"UserID\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"FromIP\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" default=\"false\" name=\"AllSessions\" type=\"xsd:boolean\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CCleanSessionRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CCleanSessionRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CCleanSessionRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("ID");
	form.appendf("  <tr><td><b>ID: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("UserID");
	form.appendf("  <tr><td><b>UserID: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("FromIP");
	form.appendf("  <tr><td><b>FromIP: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("AllSessions");
	
	form.appendf("  <tr><td><b>AllSessions? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CCleanSessionRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CCleanSessionRequest::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_ID.marshall(rpc_resp, "ID", "", "", "");
	m_UserID.marshall(rpc_resp, "UserID", "", "", "");
	m_FromIP.marshall(rpc_resp, "FromIP", "", "", "");
	m_AllSessions.marshall(rpc_resp, "AllSessions", "", "", "");
}


void CCleanSessionRequest::copy(CCleanSessionRequest &from)
{
	m_ID.copy(from.m_ID);
	m_UserID.copy(from.m_UserID);
	m_FromIP.copy(from.m_FromIP);
	m_AllSessions.copy(from.m_AllSessions);
}


void CCleanSessionRequest::copy(IConstCleanSessionRequest &ifrom)
{
	setID(ifrom.getID());
	setUserID(ifrom.getUserID());
	setFromIP(ifrom.getFromIP());
	setAllSessions(ifrom.getAllSessions());
}


void CCleanSessionRequest::getAttributes(IProperties &attributes)
{
}


void CCleanSessionRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_ID.toStr(ctx, buffer, "ID", "", true, "", "");
	m_UserID.toStr(ctx, buffer, "UserID", "", true, "", "");
	m_FromIP.toStr(ctx, buffer, "FromIP", "", true, "", "");
	m_AllSessions.toStr(ctx, buffer, "AllSessions", "", true, "", "");
}


void CCleanSessionRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CCleanSessionRequest::serializer(IEspContext* ctx, IConstCleanSessionRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<CleanSessionRequest>");
	// field ID
	{
		const char* s = src.getID();
		if (s && *s)
		{
			buffer.append("<ID>");
			encodeUtf8XML(s,buffer);
			buffer.append("</ID>");
		}
	}
	// field UserID
	{
		const char* s = src.getUserID();
		if (s && *s)
		{
			buffer.append("<UserID>");
			encodeUtf8XML(s,buffer);
			buffer.append("</UserID>");
		}
	}
	// field FromIP
	{
		const char* s = src.getFromIP();
		if (s && *s)
		{
			buffer.append("<FromIP>");
			encodeUtf8XML(s,buffer);
			buffer.append("</FromIP>");
		}
	}
	// field AllSessions
	{
		bool b = src.getAllSessions();
		if (b)
			buffer.appendf("<AllSessions>1</AllSessions>");
	}
	if (keepRootTag)
		buffer.append("</CleanSessionRequest>");
}

bool CCleanSessionRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_ID.unmarshall(rpc_request, "ID", basepath);
	hasValue |= m_UserID.unmarshall(rpc_request, "UserID", basepath);
	hasValue |= m_FromIP.unmarshall(rpc_request, "FromIP", basepath);
	hasValue |= m_AllSessions.unmarshall(rpc_request, "AllSessions", basepath);
	return hasValue;
}

bool CCleanSessionRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_ID.unmarshall(ctx, soapval, "ID");
	hasValue |= m_UserID.unmarshall(ctx, soapval, "UserID");
	hasValue |= m_FromIP.unmarshall(ctx, soapval, "FromIP");
	hasValue |= m_AllSessions.unmarshall(ctx, soapval, "AllSessions");
	return hasValue;
}

bool CCleanSessionRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_ID.unmarshall(ctx, params, attachments, "ID", basepath);
	hasValue |= m_UserID.unmarshall(ctx, params, attachments, "UserID", basepath);
	hasValue |= m_FromIP.unmarshall(ctx, params, attachments, "FromIP", basepath);
	hasValue |= m_AllSessions.unmarshall(ctx, params, attachments, "AllSessions", basepath);
	return hasValue;
}

const char * CCleanSessionRequest::getID() { return m_ID.query();}
const char * CCleanSessionRequest::getUserID() { return m_UserID.query();}
const char * CCleanSessionRequest::getFromIP() { return m_FromIP.query();}
bool CCleanSessionRequest::getAllSessions_isNull(){return m_AllSessions.is_nil();}
bool CCleanSessionRequest::getAllSessions() { return m_AllSessions;}
void CCleanSessionRequest::setID(const char * val){ m_ID.set(val); }
void CCleanSessionRequest::setUserID(const char * val){ m_UserID.set(val); }
void CCleanSessionRequest::setFromIP(const char * val){ m_FromIP.set(val); }
void CCleanSessionRequest::setAllSessions_null(){ m_AllSessions.Nil(); }void CCleanSessionRequest::setAllSessions(bool val){ m_AllSessions=val; }
extern "C"  IEspCleanSessionRequest *createCleanSessionRequest(const char *serv){return ((IEspCleanSessionRequest *)new CCleanSessionRequest(serv));}
extern "C"  IClientCleanSessionRequest *createClientCleanSessionRequest(const char *serv){return ((IClientCleanSessionRequest *)new CCleanSessionRequest(serv));}

//=======================================================
// class CCleanSessionResponse Implementation
//=======================================================

CCleanSessionResponse::CCleanSessionResponse(const char *serviceName, IRpcMessageBinding *init)
	: m_Status(nilRemove),m_Message(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("CleanSessionResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CCleanSessionResponse::CCleanSessionResponse(const char *serviceName, const char *bc)
	: m_Status(nilRemove),m_Message(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("CleanSessionResponse");
}

CCleanSessionResponse::CCleanSessionResponse(const char *serviceName, IRpcMessage* rpcmsg)
	: m_Status(nilRemove),m_Message(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("CleanSessionResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CCleanSessionResponse::CCleanSessionResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_Status(nilRemove),m_Message(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("CleanSessionResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CCleanSessionResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		schema.append("<xsd:element name=\"Exceptions\" type=\"tns:ArrayOfEspException\" minOccurs=\"0\" maxOccurs=\"1\"/>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Status\" type=\"xsd:int\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Message\" type=\"xsd:string\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CCleanSessionResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CCleanSessionResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CCleanSessionResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix) extfix.append(prefix).append(".");
		extfix.append("Status");
	form.appendf("  <tr><td><b>Status: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Message");
	form.appendf("  <tr><td><b>Message: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CCleanSessionResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CCleanSessionResponse::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
		m_Status.marshall(rpc_resp, "Status", "", "", "");
		m_Message.marshall(rpc_resp, "Message", "", "", "");
	}
}


void CCleanSessionResponse::copy(CCleanSessionResponse &from)
{
	m_Status.copy(from.m_Status);
	m_Message.copy(from.m_Message);
}


void CCleanSessionResponse::copy(IConstCleanSessionResponse &ifrom)
{
	setStatus(ifrom.getStatus());
	setMessage(ifrom.getMessage());
}


void CCleanSessionResponse::getAttributes(IProperties &attributes)
{
}


void CCleanSessionResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
		m_Status.toStr(ctx, buffer, "Status", "", false, "", "");
		m_Message.toStr(ctx, buffer, "Message", "", false, "", "");
	}
}


void CCleanSessionResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CCleanSessionResponse::serializer(IEspContext* ctx, IConstCleanSessionResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<CleanSessionResponse>");
	// field Status
	{
		int n = src.getStatus();
		if (n)
			buffer.appendf("<Status>%d</Status>", n);
	}
	// field Message
	{
		const char* s = src.getMessage();
		if (s && *s)
		{
			buffer.append("<Message>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Message>");
		}
	}
	if (keepRootTag)
		buffer.append("</CleanSessionResponse>");
}

bool CCleanSessionResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
		hasValue |= m_Status.unmarshall(rpc_request, "Status", basepath);
		hasValue |= m_Message.unmarshall(rpc_request, "Message", basepath);
	}
	return hasValue;
}

bool CCleanSessionResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Status.unmarshall(ctx, soapval, "Status");
	hasValue |= m_Message.unmarshall(ctx, soapval, "Message");
	return hasValue;
}

bool CCleanSessionResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Status.unmarshall(ctx, params, attachments, "Status", basepath);
	hasValue |= m_Message.unmarshall(ctx, params, attachments, "Message", basepath);
	return hasValue;
}

bool CCleanSessionResponse::getStatus_isNull(){return m_Status.is_nil();}
int CCleanSessionResponse::getStatus() { return m_Status;}
const char * CCleanSessionResponse::getMessage() { return m_Message.query();}
void CCleanSessionResponse::setStatus_null(){ m_Status.Nil(); }void CCleanSessionResponse::setStatus(int val){ m_Status=val; }
void CCleanSessionResponse::setMessage(const char * val){ m_Message.set(val); }
extern "C"  IEspCleanSessionResponse *createCleanSessionResponse(const char *serv){return ((IEspCleanSessionResponse *)new CCleanSessionResponse(serv));}
extern "C"  IClientCleanSessionResponse *createClientCleanSessionResponse(const char *serv){return ((IClientCleanSessionResponse *)new CCleanSessionResponse(serv));}

//=======================================================
// class CSetSessionTimeoutRequest Implementation
//=======================================================

CSetSessionTimeoutRequest::CSetSessionTimeoutRequest(const char *serviceName, IRpcMessageBinding *init)
	: m_ID(nilRemove),m_UserID(nilRemove),m_FromIP(nilRemove),m_TimeoutMinutes(nilRemove),m_AllSessions(0, nilRemove,false)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("SetSessionTimeoutRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CSetSessionTimeoutRequest::CSetSessionTimeoutRequest(const char *serviceName, const char *bc)
	: m_ID(nilRemove),m_UserID(nilRemove),m_FromIP(nilRemove),m_TimeoutMinutes(nilRemove),m_AllSessions(0, nilRemove,false)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("SetSessionTimeoutRequest");
}

CSetSessionTimeoutRequest::CSetSessionTimeoutRequest(const char *serviceName, IRpcMessage* rpcmsg)
	: m_ID(nilRemove),m_UserID(nilRemove),m_FromIP(nilRemove),m_TimeoutMinutes(nilRemove),m_AllSessions(0, nilRemove,false)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("SetSessionTimeoutRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CSetSessionTimeoutRequest::CSetSessionTimeoutRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_ID(nilRemove),m_UserID(nilRemove),m_FromIP(nilRemove),m_TimeoutMinutes(nilRemove),m_AllSessions(0, nilRemove,false)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("SetSessionTimeoutRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CSetSessionTimeoutRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"ID\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"UserID\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"FromIP\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"TimeoutMinutes\" type=\"xsd:int\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" default=\"false\" name=\"AllSessions\" type=\"xsd:boolean\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CSetSessionTimeoutRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CSetSessionTimeoutRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CSetSessionTimeoutRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("ID");
	form.appendf("  <tr><td><b>ID: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("UserID");
	form.appendf("  <tr><td><b>UserID: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("FromIP");
	form.appendf("  <tr><td><b>FromIP: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix) extfix.append(prefix).append(".");
		extfix.append("TimeoutMinutes");
	form.appendf("  <tr><td><b>TimeoutMinutes: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("AllSessions");
	
	form.appendf("  <tr><td><b>AllSessions? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CSetSessionTimeoutRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CSetSessionTimeoutRequest::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_ID.marshall(rpc_resp, "ID", "", "", "");
	m_UserID.marshall(rpc_resp, "UserID", "", "", "");
	m_FromIP.marshall(rpc_resp, "FromIP", "", "", "");
	m_TimeoutMinutes.marshall(rpc_resp, "TimeoutMinutes", "", "", "");
	m_AllSessions.marshall(rpc_resp, "AllSessions", "", "", "");
}


void CSetSessionTimeoutRequest::copy(CSetSessionTimeoutRequest &from)
{
	m_ID.copy(from.m_ID);
	m_UserID.copy(from.m_UserID);
	m_FromIP.copy(from.m_FromIP);
	m_TimeoutMinutes.copy(from.m_TimeoutMinutes);
	m_AllSessions.copy(from.m_AllSessions);
}


void CSetSessionTimeoutRequest::copy(IConstSetSessionTimeoutRequest &ifrom)
{
	setID(ifrom.getID());
	setUserID(ifrom.getUserID());
	setFromIP(ifrom.getFromIP());
	setTimeoutMinutes(ifrom.getTimeoutMinutes());
	setAllSessions(ifrom.getAllSessions());
}


void CSetSessionTimeoutRequest::getAttributes(IProperties &attributes)
{
}


void CSetSessionTimeoutRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_ID.toStr(ctx, buffer, "ID", "", true, "", "");
	m_UserID.toStr(ctx, buffer, "UserID", "", true, "", "");
	m_FromIP.toStr(ctx, buffer, "FromIP", "", true, "", "");
	m_TimeoutMinutes.toStr(ctx, buffer, "TimeoutMinutes", "", true, "", "");
	m_AllSessions.toStr(ctx, buffer, "AllSessions", "", true, "", "");
}


void CSetSessionTimeoutRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CSetSessionTimeoutRequest::serializer(IEspContext* ctx, IConstSetSessionTimeoutRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<SetSessionTimeoutRequest>");
	// field ID
	{
		const char* s = src.getID();
		if (s && *s)
		{
			buffer.append("<ID>");
			encodeUtf8XML(s,buffer);
			buffer.append("</ID>");
		}
	}
	// field UserID
	{
		const char* s = src.getUserID();
		if (s && *s)
		{
			buffer.append("<UserID>");
			encodeUtf8XML(s,buffer);
			buffer.append("</UserID>");
		}
	}
	// field FromIP
	{
		const char* s = src.getFromIP();
		if (s && *s)
		{
			buffer.append("<FromIP>");
			encodeUtf8XML(s,buffer);
			buffer.append("</FromIP>");
		}
	}
	// field TimeoutMinutes
	{
		int n = src.getTimeoutMinutes();
		if (n)
			buffer.appendf("<TimeoutMinutes>%d</TimeoutMinutes>", n);
	}
	// field AllSessions
	{
		bool b = src.getAllSessions();
		if (b)
			buffer.appendf("<AllSessions>1</AllSessions>");
	}
	if (keepRootTag)
		buffer.append("</SetSessionTimeoutRequest>");
}

bool CSetSessionTimeoutRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_ID.unmarshall(rpc_request, "ID", basepath);
	hasValue |= m_UserID.unmarshall(rpc_request, "UserID", basepath);
	hasValue |= m_FromIP.unmarshall(rpc_request, "FromIP", basepath);
	hasValue |= m_TimeoutMinutes.unmarshall(rpc_request, "TimeoutMinutes", basepath);
	hasValue |= m_AllSessions.unmarshall(rpc_request, "AllSessions", basepath);
	return hasValue;
}

bool CSetSessionTimeoutRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_ID.unmarshall(ctx, soapval, "ID");
	hasValue |= m_UserID.unmarshall(ctx, soapval, "UserID");
	hasValue |= m_FromIP.unmarshall(ctx, soapval, "FromIP");
	hasValue |= m_TimeoutMinutes.unmarshall(ctx, soapval, "TimeoutMinutes");
	hasValue |= m_AllSessions.unmarshall(ctx, soapval, "AllSessions");
	return hasValue;
}

bool CSetSessionTimeoutRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_ID.unmarshall(ctx, params, attachments, "ID", basepath);
	hasValue |= m_UserID.unmarshall(ctx, params, attachments, "UserID", basepath);
	hasValue |= m_FromIP.unmarshall(ctx, params, attachments, "FromIP", basepath);
	hasValue |= m_TimeoutMinutes.unmarshall(ctx, params, attachments, "TimeoutMinutes", basepath);
	hasValue |= m_AllSessions.unmarshall(ctx, params, attachments, "AllSessions", basepath);
	return hasValue;
}

const char * CSetSessionTimeoutRequest::getID() { return m_ID.query();}
const char * CSetSessionTimeoutRequest::getUserID() { return m_UserID.query();}
const char * CSetSessionTimeoutRequest::getFromIP() { return m_FromIP.query();}
bool CSetSessionTimeoutRequest::getTimeoutMinutes_isNull(){return m_TimeoutMinutes.is_nil();}
int CSetSessionTimeoutRequest::getTimeoutMinutes() { return m_TimeoutMinutes;}
bool CSetSessionTimeoutRequest::getAllSessions_isNull(){return m_AllSessions.is_nil();}
bool CSetSessionTimeoutRequest::getAllSessions() { return m_AllSessions;}
void CSetSessionTimeoutRequest::setID(const char * val){ m_ID.set(val); }
void CSetSessionTimeoutRequest::setUserID(const char * val){ m_UserID.set(val); }
void CSetSessionTimeoutRequest::setFromIP(const char * val){ m_FromIP.set(val); }
void CSetSessionTimeoutRequest::setTimeoutMinutes_null(){ m_TimeoutMinutes.Nil(); }void CSetSessionTimeoutRequest::setTimeoutMinutes(int val){ m_TimeoutMinutes=val; }
void CSetSessionTimeoutRequest::setAllSessions_null(){ m_AllSessions.Nil(); }void CSetSessionTimeoutRequest::setAllSessions(bool val){ m_AllSessions=val; }
extern "C"  IEspSetSessionTimeoutRequest *createSetSessionTimeoutRequest(const char *serv){return ((IEspSetSessionTimeoutRequest *)new CSetSessionTimeoutRequest(serv));}
extern "C"  IClientSetSessionTimeoutRequest *createClientSetSessionTimeoutRequest(const char *serv){return ((IClientSetSessionTimeoutRequest *)new CSetSessionTimeoutRequest(serv));}

//=======================================================
// class CSetSessionTimeoutResponse Implementation
//=======================================================

CSetSessionTimeoutResponse::CSetSessionTimeoutResponse(const char *serviceName, IRpcMessageBinding *init)
	: m_Status(nilRemove),m_Message(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("SetSessionTimeoutResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CSetSessionTimeoutResponse::CSetSessionTimeoutResponse(const char *serviceName, const char *bc)
	: m_Status(nilRemove),m_Message(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("SetSessionTimeoutResponse");
}

CSetSessionTimeoutResponse::CSetSessionTimeoutResponse(const char *serviceName, IRpcMessage* rpcmsg)
	: m_Status(nilRemove),m_Message(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("SetSessionTimeoutResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CSetSessionTimeoutResponse::CSetSessionTimeoutResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_Status(nilRemove),m_Message(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("SetSessionTimeoutResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CSetSessionTimeoutResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		schema.append("<xsd:element name=\"Exceptions\" type=\"tns:ArrayOfEspException\" minOccurs=\"0\" maxOccurs=\"1\"/>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Status\" type=\"xsd:int\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Message\" type=\"xsd:string\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CSetSessionTimeoutResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CSetSessionTimeoutResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CSetSessionTimeoutResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix) extfix.append(prefix).append(".");
		extfix.append("Status");
	form.appendf("  <tr><td><b>Status: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Message");
	form.appendf("  <tr><td><b>Message: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CSetSessionTimeoutResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CSetSessionTimeoutResponse::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
		m_Status.marshall(rpc_resp, "Status", "", "", "");
		m_Message.marshall(rpc_resp, "Message", "", "", "");
	}
}


void CSetSessionTimeoutResponse::copy(CSetSessionTimeoutResponse &from)
{
	m_Status.copy(from.m_Status);
	m_Message.copy(from.m_Message);
}


void CSetSessionTimeoutResponse::copy(IConstSetSessionTimeoutResponse &ifrom)
{
	setStatus(ifrom.getStatus());
	setMessage(ifrom.getMessage());
}


void CSetSessionTimeoutResponse::getAttributes(IProperties &attributes)
{
}


void CSetSessionTimeoutResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
		m_Status.toStr(ctx, buffer, "Status", "", false, "", "");
		m_Message.toStr(ctx, buffer, "Message", "", false, "", "");
	}
}


void CSetSessionTimeoutResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CSetSessionTimeoutResponse::serializer(IEspContext* ctx, IConstSetSessionTimeoutResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<SetSessionTimeoutResponse>");
	// field Status
	{
		int n = src.getStatus();
		if (n)
			buffer.appendf("<Status>%d</Status>", n);
	}
	// field Message
	{
		const char* s = src.getMessage();
		if (s && *s)
		{
			buffer.append("<Message>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Message>");
		}
	}
	if (keepRootTag)
		buffer.append("</SetSessionTimeoutResponse>");
}

bool CSetSessionTimeoutResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
		hasValue |= m_Status.unmarshall(rpc_request, "Status", basepath);
		hasValue |= m_Message.unmarshall(rpc_request, "Message", basepath);
	}
	return hasValue;
}

bool CSetSessionTimeoutResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Status.unmarshall(ctx, soapval, "Status");
	hasValue |= m_Message.unmarshall(ctx, soapval, "Message");
	return hasValue;
}

bool CSetSessionTimeoutResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Status.unmarshall(ctx, params, attachments, "Status", basepath);
	hasValue |= m_Message.unmarshall(ctx, params, attachments, "Message", basepath);
	return hasValue;
}

bool CSetSessionTimeoutResponse::getStatus_isNull(){return m_Status.is_nil();}
int CSetSessionTimeoutResponse::getStatus() { return m_Status;}
const char * CSetSessionTimeoutResponse::getMessage() { return m_Message.query();}
void CSetSessionTimeoutResponse::setStatus_null(){ m_Status.Nil(); }void CSetSessionTimeoutResponse::setStatus(int val){ m_Status=val; }
void CSetSessionTimeoutResponse::setMessage(const char * val){ m_Message.set(val); }
extern "C"  IEspSetSessionTimeoutResponse *createSetSessionTimeoutResponse(const char *serv){return ((IEspSetSessionTimeoutResponse *)new CSetSessionTimeoutResponse(serv));}
extern "C"  IClientSetSessionTimeoutResponse *createClientSetSessionTimeoutResponse(const char *serv){return ((IClientSetSessionTimeoutResponse *)new CSetSessionTimeoutResponse(serv));}

//=======================================================
// class CDisableDaliSubscriptionsRequest Implementation
//=======================================================

CDisableDaliSubscriptionsRequest::CDisableDaliSubscriptionsRequest(const char *serviceName, IRpcMessageBinding *init)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("DisableDaliSubscriptionsRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CDisableDaliSubscriptionsRequest::CDisableDaliSubscriptionsRequest(const char *serviceName, const char *bc)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("DisableDaliSubscriptionsRequest");
}

CDisableDaliSubscriptionsRequest::CDisableDaliSubscriptionsRequest(const char *serviceName, IRpcMessage* rpcmsg)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("DisableDaliSubscriptionsRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CDisableDaliSubscriptionsRequest::CDisableDaliSubscriptionsRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("DisableDaliSubscriptionsRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CDisableDaliSubscriptionsRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType><xsd:all/></xsd:complexType></xsd:element>\n", msgTypeName);
		}
	}
	return schema;
}

void CDisableDaliSubscriptionsRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CDisableDaliSubscriptionsRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CDisableDaliSubscriptionsRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CDisableDaliSubscriptionsRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CDisableDaliSubscriptionsRequest::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

}


void CDisableDaliSubscriptionsRequest::copy(CDisableDaliSubscriptionsRequest &from)
{
}


void CDisableDaliSubscriptionsRequest::copy(IConstDisableDaliSubscriptionsRequest &ifrom)
{
}


void CDisableDaliSubscriptionsRequest::getAttributes(IProperties &attributes)
{
}


void CDisableDaliSubscriptionsRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
}


void CDisableDaliSubscriptionsRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CDisableDaliSubscriptionsRequest::serializer(IEspContext* ctx, IConstDisableDaliSubscriptionsRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<DisableDaliSubscriptionsRequest>");
	if (keepRootTag)
		buffer.append("</DisableDaliSubscriptionsRequest>");
}

bool CDisableDaliSubscriptionsRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	return hasValue;
}

bool CDisableDaliSubscriptionsRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	return hasValue;
}

bool CDisableDaliSubscriptionsRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	return hasValue;
}

extern "C"  IEspDisableDaliSubscriptionsRequest *createDisableDaliSubscriptionsRequest(const char *serv){return ((IEspDisableDaliSubscriptionsRequest *)new CDisableDaliSubscriptionsRequest(serv));}
extern "C"  IClientDisableDaliSubscriptionsRequest *createClientDisableDaliSubscriptionsRequest(const char *serv){return ((IClientDisableDaliSubscriptionsRequest *)new CDisableDaliSubscriptionsRequest(serv));}

//=======================================================
// class CDisableDaliSubscriptionsResponse Implementation
//=======================================================

CDisableDaliSubscriptionsResponse::CDisableDaliSubscriptionsResponse(const char *serviceName, IRpcMessageBinding *init)
	: m_Status(nilRemove),m_Message(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("DisableDaliSubscriptionsResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CDisableDaliSubscriptionsResponse::CDisableDaliSubscriptionsResponse(const char *serviceName, const char *bc)
	: m_Status(nilRemove),m_Message(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("DisableDaliSubscriptionsResponse");
}

CDisableDaliSubscriptionsResponse::CDisableDaliSubscriptionsResponse(const char *serviceName, IRpcMessage* rpcmsg)
	: m_Status(nilRemove),m_Message(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("DisableDaliSubscriptionsResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CDisableDaliSubscriptionsResponse::CDisableDaliSubscriptionsResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_Status(nilRemove),m_Message(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("DisableDaliSubscriptionsResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CDisableDaliSubscriptionsResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		schema.append("<xsd:element name=\"Exceptions\" type=\"tns:ArrayOfEspException\" minOccurs=\"0\" maxOccurs=\"1\"/>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Status\" type=\"xsd:int\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Message\" type=\"xsd:string\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CDisableDaliSubscriptionsResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CDisableDaliSubscriptionsResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CDisableDaliSubscriptionsResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix) extfix.append(prefix).append(".");
		extfix.append("Status");
	form.appendf("  <tr><td><b>Status: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Message");
	form.appendf("  <tr><td><b>Message: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CDisableDaliSubscriptionsResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CDisableDaliSubscriptionsResponse::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
		m_Status.marshall(rpc_resp, "Status", "", "", "");
		m_Message.marshall(rpc_resp, "Message", "", "", "");
	}
}


void CDisableDaliSubscriptionsResponse::copy(CDisableDaliSubscriptionsResponse &from)
{
	m_Status.copy(from.m_Status);
	m_Message.copy(from.m_Message);
}


void CDisableDaliSubscriptionsResponse::copy(IConstDisableDaliSubscriptionsResponse &ifrom)
{
	setStatus(ifrom.getStatus());
	setMessage(ifrom.getMessage());
}


void CDisableDaliSubscriptionsResponse::getAttributes(IProperties &attributes)
{
}


void CDisableDaliSubscriptionsResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
		m_Status.toStr(ctx, buffer, "Status", "", false, "", "");
		m_Message.toStr(ctx, buffer, "Message", "", false, "", "");
	}
}


void CDisableDaliSubscriptionsResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CDisableDaliSubscriptionsResponse::serializer(IEspContext* ctx, IConstDisableDaliSubscriptionsResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<DisableDaliSubscriptionsResponse>");
	// field Status
	{
		int n = src.getStatus();
		if (n)
			buffer.appendf("<Status>%d</Status>", n);
	}
	// field Message
	{
		const char* s = src.getMessage();
		if (s && *s)
		{
			buffer.append("<Message>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Message>");
		}
	}
	if (keepRootTag)
		buffer.append("</DisableDaliSubscriptionsResponse>");
}

bool CDisableDaliSubscriptionsResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
		hasValue |= m_Status.unmarshall(rpc_request, "Status", basepath);
		hasValue |= m_Message.unmarshall(rpc_request, "Message", basepath);
	}
	return hasValue;
}

bool CDisableDaliSubscriptionsResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Status.unmarshall(ctx, soapval, "Status");
	hasValue |= m_Message.unmarshall(ctx, soapval, "Message");
	return hasValue;
}

bool CDisableDaliSubscriptionsResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Status.unmarshall(ctx, params, attachments, "Status", basepath);
	hasValue |= m_Message.unmarshall(ctx, params, attachments, "Message", basepath);
	return hasValue;
}

bool CDisableDaliSubscriptionsResponse::getStatus_isNull(){return m_Status.is_nil();}
int CDisableDaliSubscriptionsResponse::getStatus() { return m_Status;}
const char * CDisableDaliSubscriptionsResponse::getMessage() { return m_Message.query();}
void CDisableDaliSubscriptionsResponse::setStatus_null(){ m_Status.Nil(); }void CDisableDaliSubscriptionsResponse::setStatus(int val){ m_Status=val; }
void CDisableDaliSubscriptionsResponse::setMessage(const char * val){ m_Message.set(val); }
extern "C"  IEspDisableDaliSubscriptionsResponse *createDisableDaliSubscriptionsResponse(const char *serv){return ((IEspDisableDaliSubscriptionsResponse *)new CDisableDaliSubscriptionsResponse(serv));}
extern "C"  IClientDisableDaliSubscriptionsResponse *createClientDisableDaliSubscriptionsResponse(const char *serv){return ((IClientDisableDaliSubscriptionsResponse *)new CDisableDaliSubscriptionsResponse(serv));}

//=======================================================
// class CEnableDaliSubscriptionsRequest Implementation
//=======================================================

CEnableDaliSubscriptionsRequest::CEnableDaliSubscriptionsRequest(const char *serviceName, IRpcMessageBinding *init)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("EnableDaliSubscriptionsRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CEnableDaliSubscriptionsRequest::CEnableDaliSubscriptionsRequest(const char *serviceName, const char *bc)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("EnableDaliSubscriptionsRequest");
}

CEnableDaliSubscriptionsRequest::CEnableDaliSubscriptionsRequest(const char *serviceName, IRpcMessage* rpcmsg)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("EnableDaliSubscriptionsRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CEnableDaliSubscriptionsRequest::CEnableDaliSubscriptionsRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("EnableDaliSubscriptionsRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CEnableDaliSubscriptionsRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType><xsd:all/></xsd:complexType></xsd:element>\n", msgTypeName);
		}
	}
	return schema;
}

void CEnableDaliSubscriptionsRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CEnableDaliSubscriptionsRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CEnableDaliSubscriptionsRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CEnableDaliSubscriptionsRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CEnableDaliSubscriptionsRequest::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

}


void CEnableDaliSubscriptionsRequest::copy(CEnableDaliSubscriptionsRequest &from)
{
}


void CEnableDaliSubscriptionsRequest::copy(IConstEnableDaliSubscriptionsRequest &ifrom)
{
}


void CEnableDaliSubscriptionsRequest::getAttributes(IProperties &attributes)
{
}


void CEnableDaliSubscriptionsRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
}


void CEnableDaliSubscriptionsRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CEnableDaliSubscriptionsRequest::serializer(IEspContext* ctx, IConstEnableDaliSubscriptionsRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<EnableDaliSubscriptionsRequest>");
	if (keepRootTag)
		buffer.append("</EnableDaliSubscriptionsRequest>");
}

bool CEnableDaliSubscriptionsRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	return hasValue;
}

bool CEnableDaliSubscriptionsRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	return hasValue;
}

bool CEnableDaliSubscriptionsRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	return hasValue;
}

extern "C"  IEspEnableDaliSubscriptionsRequest *createEnableDaliSubscriptionsRequest(const char *serv){return ((IEspEnableDaliSubscriptionsRequest *)new CEnableDaliSubscriptionsRequest(serv));}
extern "C"  IClientEnableDaliSubscriptionsRequest *createClientEnableDaliSubscriptionsRequest(const char *serv){return ((IClientEnableDaliSubscriptionsRequest *)new CEnableDaliSubscriptionsRequest(serv));}

//=======================================================
// class CEnableDaliSubscriptionsResponse Implementation
//=======================================================

CEnableDaliSubscriptionsResponse::CEnableDaliSubscriptionsResponse(const char *serviceName, IRpcMessageBinding *init)
	: m_Status(nilRemove),m_Message(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("EnableDaliSubscriptionsResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CEnableDaliSubscriptionsResponse::CEnableDaliSubscriptionsResponse(const char *serviceName, const char *bc)
	: m_Status(nilRemove),m_Message(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("EnableDaliSubscriptionsResponse");
}

CEnableDaliSubscriptionsResponse::CEnableDaliSubscriptionsResponse(const char *serviceName, IRpcMessage* rpcmsg)
	: m_Status(nilRemove),m_Message(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("EnableDaliSubscriptionsResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CEnableDaliSubscriptionsResponse::CEnableDaliSubscriptionsResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_Status(nilRemove),m_Message(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("EnableDaliSubscriptionsResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CEnableDaliSubscriptionsResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		schema.append("<xsd:element name=\"Exceptions\" type=\"tns:ArrayOfEspException\" minOccurs=\"0\" maxOccurs=\"1\"/>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Status\" type=\"xsd:int\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Message\" type=\"xsd:string\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CEnableDaliSubscriptionsResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CEnableDaliSubscriptionsResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CEnableDaliSubscriptionsResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix) extfix.append(prefix).append(".");
		extfix.append("Status");
	form.appendf("  <tr><td><b>Status: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Message");
	form.appendf("  <tr><td><b>Message: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CEnableDaliSubscriptionsResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CEnableDaliSubscriptionsResponse::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
		m_Status.marshall(rpc_resp, "Status", "", "", "");
		m_Message.marshall(rpc_resp, "Message", "", "", "");
	}
}


void CEnableDaliSubscriptionsResponse::copy(CEnableDaliSubscriptionsResponse &from)
{
	m_Status.copy(from.m_Status);
	m_Message.copy(from.m_Message);
}


void CEnableDaliSubscriptionsResponse::copy(IConstEnableDaliSubscriptionsResponse &ifrom)
{
	setStatus(ifrom.getStatus());
	setMessage(ifrom.getMessage());
}


void CEnableDaliSubscriptionsResponse::getAttributes(IProperties &attributes)
{
}


void CEnableDaliSubscriptionsResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
		m_Status.toStr(ctx, buffer, "Status", "", false, "", "");
		m_Message.toStr(ctx, buffer, "Message", "", false, "", "");
	}
}


void CEnableDaliSubscriptionsResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CEnableDaliSubscriptionsResponse::serializer(IEspContext* ctx, IConstEnableDaliSubscriptionsResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<EnableDaliSubscriptionsResponse>");
	// field Status
	{
		int n = src.getStatus();
		if (n)
			buffer.appendf("<Status>%d</Status>", n);
	}
	// field Message
	{
		const char* s = src.getMessage();
		if (s && *s)
		{
			buffer.append("<Message>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Message>");
		}
	}
	if (keepRootTag)
		buffer.append("</EnableDaliSubscriptionsResponse>");
}

bool CEnableDaliSubscriptionsResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
		hasValue |= m_Status.unmarshall(rpc_request, "Status", basepath);
		hasValue |= m_Message.unmarshall(rpc_request, "Message", basepath);
	}
	return hasValue;
}

bool CEnableDaliSubscriptionsResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Status.unmarshall(ctx, soapval, "Status");
	hasValue |= m_Message.unmarshall(ctx, soapval, "Message");
	return hasValue;
}

bool CEnableDaliSubscriptionsResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Status.unmarshall(ctx, params, attachments, "Status", basepath);
	hasValue |= m_Message.unmarshall(ctx, params, attachments, "Message", basepath);
	return hasValue;
}

bool CEnableDaliSubscriptionsResponse::getStatus_isNull(){return m_Status.is_nil();}
int CEnableDaliSubscriptionsResponse::getStatus() { return m_Status;}
const char * CEnableDaliSubscriptionsResponse::getMessage() { return m_Message.query();}
void CEnableDaliSubscriptionsResponse::setStatus_null(){ m_Status.Nil(); }void CEnableDaliSubscriptionsResponse::setStatus(int val){ m_Status=val; }
void CEnableDaliSubscriptionsResponse::setMessage(const char * val){ m_Message.set(val); }
extern "C"  IEspEnableDaliSubscriptionsResponse *createEnableDaliSubscriptionsResponse(const char *serv){return ((IEspEnableDaliSubscriptionsResponse *)new CEnableDaliSubscriptionsResponse(serv));}
extern "C"  IClientEnableDaliSubscriptionsResponse *createClientEnableDaliSubscriptionsResponse(const char *serv){return ((IClientEnableDaliSubscriptionsResponse *)new CEnableDaliSubscriptionsResponse(serv));}

//=======================================================
// class CDetachFromDaliRequest Implementation
//=======================================================

CDetachFromDaliRequest::CDetachFromDaliRequest(const char *serviceName, IRpcMessageBinding *init)
	: m_Force(0, nilRemove,false)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("DetachFromDaliRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CDetachFromDaliRequest::CDetachFromDaliRequest(const char *serviceName, const char *bc)
	: m_Force(0, nilRemove,false)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("DetachFromDaliRequest");
}

CDetachFromDaliRequest::CDetachFromDaliRequest(const char *serviceName, IRpcMessage* rpcmsg)
	: m_Force(0, nilRemove,false)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("DetachFromDaliRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CDetachFromDaliRequest::CDetachFromDaliRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_Force(0, nilRemove,false)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("DetachFromDaliRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CDetachFromDaliRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" default=\"false\" name=\"Force\" type=\"xsd:boolean\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CDetachFromDaliRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CDetachFromDaliRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CDetachFromDaliRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Force");
	
	form.appendf("  <tr><td><b>Force? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CDetachFromDaliRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CDetachFromDaliRequest::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_Force.marshall(rpc_resp, "Force", "", "", "");
}


void CDetachFromDaliRequest::copy(CDetachFromDaliRequest &from)
{
	m_Force.copy(from.m_Force);
}


void CDetachFromDaliRequest::copy(IConstDetachFromDaliRequest &ifrom)
{
	setForce(ifrom.getForce());
}


void CDetachFromDaliRequest::getAttributes(IProperties &attributes)
{
}


void CDetachFromDaliRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_Force.toStr(ctx, buffer, "Force", "", true, "", "");
}


void CDetachFromDaliRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CDetachFromDaliRequest::serializer(IEspContext* ctx, IConstDetachFromDaliRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<DetachFromDaliRequest>");
	// field Force
	{
		bool b = src.getForce();
		if (b)
			buffer.appendf("<Force>1</Force>");
	}
	if (keepRootTag)
		buffer.append("</DetachFromDaliRequest>");
}

bool CDetachFromDaliRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_Force.unmarshall(rpc_request, "Force", basepath);
	return hasValue;
}

bool CDetachFromDaliRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Force.unmarshall(ctx, soapval, "Force");
	return hasValue;
}

bool CDetachFromDaliRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Force.unmarshall(ctx, params, attachments, "Force", basepath);
	return hasValue;
}

bool CDetachFromDaliRequest::getForce_isNull(){return m_Force.is_nil();}
bool CDetachFromDaliRequest::getForce() { return m_Force;}
void CDetachFromDaliRequest::setForce_null(){ m_Force.Nil(); }void CDetachFromDaliRequest::setForce(bool val){ m_Force=val; }
extern "C"  IEspDetachFromDaliRequest *createDetachFromDaliRequest(const char *serv){return ((IEspDetachFromDaliRequest *)new CDetachFromDaliRequest(serv));}
extern "C"  IClientDetachFromDaliRequest *createClientDetachFromDaliRequest(const char *serv){return ((IClientDetachFromDaliRequest *)new CDetachFromDaliRequest(serv));}

//=======================================================
// class CDetachFromDaliResponse Implementation
//=======================================================

CDetachFromDaliResponse::CDetachFromDaliResponse(const char *serviceName, IRpcMessageBinding *init)
	: m_Status(nilRemove),m_Message(nilRemove),m_Forced(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("DetachFromDaliResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CDetachFromDaliResponse::CDetachFromDaliResponse(const char *serviceName, const char *bc)
	: m_Status(nilRemove),m_Message(nilRemove),m_Forced(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("DetachFromDaliResponse");
}

CDetachFromDaliResponse::CDetachFromDaliResponse(const char *serviceName, IRpcMessage* rpcmsg)
	: m_Status(nilRemove),m_Message(nilRemove),m_Forced(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("DetachFromDaliResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CDetachFromDaliResponse::CDetachFromDaliResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_Status(nilRemove),m_Message(nilRemove),m_Forced(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("DetachFromDaliResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CDetachFromDaliResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		schema.append("<xsd:element name=\"Exceptions\" type=\"tns:ArrayOfEspException\" minOccurs=\"0\" maxOccurs=\"1\"/>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Status\" type=\"xsd:int\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Message\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Forced\" type=\"xsd:boolean\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CDetachFromDaliResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CDetachFromDaliResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CDetachFromDaliResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix) extfix.append(prefix).append(".");
		extfix.append("Status");
	form.appendf("  <tr><td><b>Status: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Message");
	form.appendf("  <tr><td><b>Message: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Forced");
	
	form.appendf("  <tr><td><b>Forced? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CDetachFromDaliResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CDetachFromDaliResponse::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
		m_Status.marshall(rpc_resp, "Status", "", "", "");
		m_Message.marshall(rpc_resp, "Message", "", "", "");
		m_Forced.marshall(rpc_resp, "Forced", "", "", "");
	}
}


void CDetachFromDaliResponse::copy(CDetachFromDaliResponse &from)
{
	m_Status.copy(from.m_Status);
	m_Message.copy(from.m_Message);
	m_Forced.copy(from.m_Forced);
}


void CDetachFromDaliResponse::copy(IConstDetachFromDaliResponse &ifrom)
{
	setStatus(ifrom.getStatus());
	setMessage(ifrom.getMessage());
	setForced(ifrom.getForced());
}


void CDetachFromDaliResponse::getAttributes(IProperties &attributes)
{
}


void CDetachFromDaliResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
		m_Status.toStr(ctx, buffer, "Status", "", false, "", "");
		m_Message.toStr(ctx, buffer, "Message", "", false, "", "");
		m_Forced.toStr(ctx, buffer, "Forced", "", false, "", "");
	}
}


void CDetachFromDaliResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CDetachFromDaliResponse::serializer(IEspContext* ctx, IConstDetachFromDaliResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<DetachFromDaliResponse>");
	// field Status
	{
		int n = src.getStatus();
		if (n)
			buffer.appendf("<Status>%d</Status>", n);
	}
	// field Message
	{
		const char* s = src.getMessage();
		if (s && *s)
		{
			buffer.append("<Message>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Message>");
		}
	}
	// field Forced
	{
		bool b = src.getForced();
		if (b)
			buffer.appendf("<Forced>1</Forced>");
	}
	if (keepRootTag)
		buffer.append("</DetachFromDaliResponse>");
}

bool CDetachFromDaliResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
		hasValue |= m_Status.unmarshall(rpc_request, "Status", basepath);
		hasValue |= m_Message.unmarshall(rpc_request, "Message", basepath);
		hasValue |= m_Forced.unmarshall(rpc_request, "Forced", basepath);
	}
	return hasValue;
}

bool CDetachFromDaliResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Status.unmarshall(ctx, soapval, "Status");
	hasValue |= m_Message.unmarshall(ctx, soapval, "Message");
	hasValue |= m_Forced.unmarshall(ctx, soapval, "Forced");
	return hasValue;
}

bool CDetachFromDaliResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Status.unmarshall(ctx, params, attachments, "Status", basepath);
	hasValue |= m_Message.unmarshall(ctx, params, attachments, "Message", basepath);
	hasValue |= m_Forced.unmarshall(ctx, params, attachments, "Forced", basepath);
	return hasValue;
}

bool CDetachFromDaliResponse::getStatus_isNull(){return m_Status.is_nil();}
int CDetachFromDaliResponse::getStatus() { return m_Status;}
const char * CDetachFromDaliResponse::getMessage() { return m_Message.query();}
bool CDetachFromDaliResponse::getForced_isNull(){return m_Forced.is_nil();}
bool CDetachFromDaliResponse::getForced() { return m_Forced;}
void CDetachFromDaliResponse::setStatus_null(){ m_Status.Nil(); }void CDetachFromDaliResponse::setStatus(int val){ m_Status=val; }
void CDetachFromDaliResponse::setMessage(const char * val){ m_Message.set(val); }
void CDetachFromDaliResponse::setForced_null(){ m_Forced.Nil(); }void CDetachFromDaliResponse::setForced(bool val){ m_Forced=val; }
extern "C"  IEspDetachFromDaliResponse *createDetachFromDaliResponse(const char *serv){return ((IEspDetachFromDaliResponse *)new CDetachFromDaliResponse(serv));}
extern "C"  IClientDetachFromDaliResponse *createClientDetachFromDaliResponse(const char *serv){return ((IClientDetachFromDaliResponse *)new CDetachFromDaliResponse(serv));}

//=======================================================
// class CAttachToDaliRequest Implementation
//=======================================================

CAttachToDaliRequest::CAttachToDaliRequest(const char *serviceName, IRpcMessageBinding *init)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("AttachToDaliRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CAttachToDaliRequest::CAttachToDaliRequest(const char *serviceName, const char *bc)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("AttachToDaliRequest");
}

CAttachToDaliRequest::CAttachToDaliRequest(const char *serviceName, IRpcMessage* rpcmsg)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("AttachToDaliRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CAttachToDaliRequest::CAttachToDaliRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("AttachToDaliRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CAttachToDaliRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType><xsd:all/></xsd:complexType></xsd:element>\n", msgTypeName);
		}
	}
	return schema;
}

void CAttachToDaliRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CAttachToDaliRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CAttachToDaliRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CAttachToDaliRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CAttachToDaliRequest::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

}


void CAttachToDaliRequest::copy(CAttachToDaliRequest &from)
{
}


void CAttachToDaliRequest::copy(IConstAttachToDaliRequest &ifrom)
{
}


void CAttachToDaliRequest::getAttributes(IProperties &attributes)
{
}


void CAttachToDaliRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
}


void CAttachToDaliRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CAttachToDaliRequest::serializer(IEspContext* ctx, IConstAttachToDaliRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<AttachToDaliRequest>");
	if (keepRootTag)
		buffer.append("</AttachToDaliRequest>");
}

bool CAttachToDaliRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	return hasValue;
}

bool CAttachToDaliRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	return hasValue;
}

bool CAttachToDaliRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	return hasValue;
}

extern "C"  IEspAttachToDaliRequest *createAttachToDaliRequest(const char *serv){return ((IEspAttachToDaliRequest *)new CAttachToDaliRequest(serv));}
extern "C"  IClientAttachToDaliRequest *createClientAttachToDaliRequest(const char *serv){return ((IClientAttachToDaliRequest *)new CAttachToDaliRequest(serv));}

//=======================================================
// class CAttachToDaliResponse Implementation
//=======================================================

CAttachToDaliResponse::CAttachToDaliResponse(const char *serviceName, IRpcMessageBinding *init)
	: m_Status(nilRemove),m_Message(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("AttachToDaliResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CAttachToDaliResponse::CAttachToDaliResponse(const char *serviceName, const char *bc)
	: m_Status(nilRemove),m_Message(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("AttachToDaliResponse");
}

CAttachToDaliResponse::CAttachToDaliResponse(const char *serviceName, IRpcMessage* rpcmsg)
	: m_Status(nilRemove),m_Message(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("AttachToDaliResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CAttachToDaliResponse::CAttachToDaliResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_Status(nilRemove),m_Message(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("AttachToDaliResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CAttachToDaliResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		schema.append("<xsd:element name=\"Exceptions\" type=\"tns:ArrayOfEspException\" minOccurs=\"0\" maxOccurs=\"1\"/>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Status\" type=\"xsd:int\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Message\" type=\"xsd:string\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CAttachToDaliResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CAttachToDaliResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CAttachToDaliResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix) extfix.append(prefix).append(".");
		extfix.append("Status");
	form.appendf("  <tr><td><b>Status: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Message");
	form.appendf("  <tr><td><b>Message: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CAttachToDaliResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CAttachToDaliResponse::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
		m_Status.marshall(rpc_resp, "Status", "", "", "");
		m_Message.marshall(rpc_resp, "Message", "", "", "");
	}
}


void CAttachToDaliResponse::copy(CAttachToDaliResponse &from)
{
	m_Status.copy(from.m_Status);
	m_Message.copy(from.m_Message);
}


void CAttachToDaliResponse::copy(IConstAttachToDaliResponse &ifrom)
{
	setStatus(ifrom.getStatus());
	setMessage(ifrom.getMessage());
}


void CAttachToDaliResponse::getAttributes(IProperties &attributes)
{
}


void CAttachToDaliResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
		m_Status.toStr(ctx, buffer, "Status", "", false, "", "");
		m_Message.toStr(ctx, buffer, "Message", "", false, "", "");
	}
}


void CAttachToDaliResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CAttachToDaliResponse::serializer(IEspContext* ctx, IConstAttachToDaliResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<AttachToDaliResponse>");
	// field Status
	{
		int n = src.getStatus();
		if (n)
			buffer.appendf("<Status>%d</Status>", n);
	}
	// field Message
	{
		const char* s = src.getMessage();
		if (s && *s)
		{
			buffer.append("<Message>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Message>");
		}
	}
	if (keepRootTag)
		buffer.append("</AttachToDaliResponse>");
}

bool CAttachToDaliResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
		hasValue |= m_Status.unmarshall(rpc_request, "Status", basepath);
		hasValue |= m_Message.unmarshall(rpc_request, "Message", basepath);
	}
	return hasValue;
}

bool CAttachToDaliResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Status.unmarshall(ctx, soapval, "Status");
	hasValue |= m_Message.unmarshall(ctx, soapval, "Message");
	return hasValue;
}

bool CAttachToDaliResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Status.unmarshall(ctx, params, attachments, "Status", basepath);
	hasValue |= m_Message.unmarshall(ctx, params, attachments, "Message", basepath);
	return hasValue;
}

bool CAttachToDaliResponse::getStatus_isNull(){return m_Status.is_nil();}
int CAttachToDaliResponse::getStatus() { return m_Status;}
const char * CAttachToDaliResponse::getMessage() { return m_Message.query();}
void CAttachToDaliResponse::setStatus_null(){ m_Status.Nil(); }void CAttachToDaliResponse::setStatus(int val){ m_Status=val; }
void CAttachToDaliResponse::setMessage(const char * val){ m_Message.set(val); }
extern "C"  IEspAttachToDaliResponse *createAttachToDaliResponse(const char *serv){return ((IEspAttachToDaliResponse *)new CAttachToDaliResponse(serv));}
extern "C"  IClientAttachToDaliResponse *createClientAttachToDaliResponse(const char *serv){return ((IClientAttachToDaliResponse *)new CAttachToDaliResponse(serv));}

//=======================================================
// class CWSESPControlPingRequest Implementation
//=======================================================

CWSESPControlPingRequest::CWSESPControlPingRequest(const char *serviceName, IRpcMessageBinding *init)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("WSESPControlPingRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CWSESPControlPingRequest::CWSESPControlPingRequest(const char *serviceName, const char *bc)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("WSESPControlPingRequest");
}

CWSESPControlPingRequest::CWSESPControlPingRequest(const char *serviceName, IRpcMessage* rpcmsg)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("WSESPControlPingRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CWSESPControlPingRequest::CWSESPControlPingRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("WSESPControlPingRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CWSESPControlPingRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType><xsd:all/></xsd:complexType></xsd:element>\n", msgTypeName);
		}
	}
	return schema;
}

void CWSESPControlPingRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CWSESPControlPingRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CWSESPControlPingRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CWSESPControlPingRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CWSESPControlPingRequest::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

}


void CWSESPControlPingRequest::copy(CWSESPControlPingRequest &from)
{
}


void CWSESPControlPingRequest::copy(IConstWSESPControlPingRequest &ifrom)
{
}


void CWSESPControlPingRequest::getAttributes(IProperties &attributes)
{
}


void CWSESPControlPingRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
}


void CWSESPControlPingRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CWSESPControlPingRequest::serializer(IEspContext* ctx, IConstWSESPControlPingRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<WSESPControlPingRequest>");
	if (keepRootTag)
		buffer.append("</WSESPControlPingRequest>");
}

bool CWSESPControlPingRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	return hasValue;
}

bool CWSESPControlPingRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	return hasValue;
}

bool CWSESPControlPingRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	return hasValue;
}

extern "C"  IEspWSESPControlPingRequest *createWSESPControlPingRequest(const char *serv){return ((IEspWSESPControlPingRequest *)new CWSESPControlPingRequest(serv));}
extern "C"  IClientWSESPControlPingRequest *createClientWSESPControlPingRequest(const char *serv){return ((IClientWSESPControlPingRequest *)new CWSESPControlPingRequest(serv));}

//=======================================================
// class CWSESPControlPingResponse Implementation
//=======================================================

CWSESPControlPingResponse::CWSESPControlPingResponse(const char *serviceName, IRpcMessageBinding *init)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("WSESPControlPingResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CWSESPControlPingResponse::CWSESPControlPingResponse(const char *serviceName, const char *bc)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("WSESPControlPingResponse");
}

CWSESPControlPingResponse::CWSESPControlPingResponse(const char *serviceName, IRpcMessage* rpcmsg)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("WSESPControlPingResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CWSESPControlPingResponse::CWSESPControlPingResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("WSESPControlPingResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CWSESPControlPingResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType><xsd:all/></xsd:complexType></xsd:element>\n", msgTypeName);
		}
	}
	return schema;
}

void CWSESPControlPingResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CWSESPControlPingResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CWSESPControlPingResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CWSESPControlPingResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CWSESPControlPingResponse::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
	}
}


void CWSESPControlPingResponse::copy(CWSESPControlPingResponse &from)
{
}


void CWSESPControlPingResponse::copy(IConstWSESPControlPingResponse &ifrom)
{
}


void CWSESPControlPingResponse::getAttributes(IProperties &attributes)
{
}


void CWSESPControlPingResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
	}
}


void CWSESPControlPingResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CWSESPControlPingResponse::serializer(IEspContext* ctx, IConstWSESPControlPingResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<WSESPControlPingResponse>");
	if (keepRootTag)
		buffer.append("</WSESPControlPingResponse>");
}

bool CWSESPControlPingResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
	}
	return hasValue;
}

bool CWSESPControlPingResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	return hasValue;
}

bool CWSESPControlPingResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	return hasValue;
}

extern "C"  IEspWSESPControlPingResponse *createWSESPControlPingResponse(const char *serv){return ((IEspWSESPControlPingResponse *)new CWSESPControlPingResponse(serv));}
extern "C"  IClientWSESPControlPingResponse *createClientWSESPControlPingResponse(const char *serv){return ((IClientWSESPControlPingResponse *)new CWSESPControlPingResponse(serv));}

//=======================================================
// class CWSESPControlSoapBinding Implementation
//=======================================================

CWSESPControlSoapBinding::CWSESPControlSoapBinding(http_soap_log_level level):CHttpSoapBinding(NULL, NULL, NULL, level)
{
	init_strings();
	setWsdlVersion(1.02);
}

CWSESPControlSoapBinding::CWSESPControlSoapBinding(IPropertyTree* cfg, const char *bindname, const char *procname, http_soap_log_level level):CHttpSoapBinding(cfg, bindname, procname, level)
{
	init_strings(); 
	setWsdlVersion(1.02);

}

void CWSESPControlSoapBinding::init_strings()
{
}

int CWSESPControlSoapBinding::processRequest(IRpcMessage* rpc_call, IRpcMessage* rpc_response)
{
	if(rpc_call == NULL || rpc_response == NULL)
		return -1;

	IEspContext *ctx=rpc_call->queryContext();
	DBGLOG("Client version: %g", ctx->getClientVersion());
	StringBuffer serviceName;
	double clientVer=(ctx) ? ctx->getClientVersion() : 0.0;
	qualifyServiceName(*ctx, ctx->queryServiceName(NULL), NULL, serviceName, NULL);
	CRpcCall* thecall = static_cast<CRpcCall *>(rpc_call);
	CRpcResponse* response = static_cast<CRpcResponse*>(rpc_response);
	CHttpRequest* httprequest = thecall->getHttpReq();
	CHttpResponse* httpresponse = response->getHttpResp();

	Owned<IEspWSESPControl> iserv = (IEspWSESPControl*)getService();
	if(iserv == NULL)
	{
		response->set_status(SOAP_SERVER_ERROR);
		response->set_err("Service not available");
		DBGLOG("Service not available");
		return -1;
	}
	if (thecall->get_name() == NULL)
	{
		response->set_status(SOAP_CLIENT_ERROR);
		response->set_err("No service method specified");
		ERRLOG("No service method specified");
		return -1;
	}

	IEspContext& context = *rpc_call->queryContext();

	if(!stricmp(thecall->get_name(), "AttachToDali")||!stricmp(thecall->get_name(), "AttachToDaliRequest"))
	{
		Owned<CAttachToDaliRequest> esp_request = new CAttachToDaliRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CAttachToDaliResponse> esp_response = new CAttachToDaliResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		StringBuffer source;
		source.appendf("WSESPControl::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			if (clientVer!=-1.0 && clientVer<1.02)
				throw MakeStringException(-1, "Client version is too old, please update your client application.");			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "WSESPControl", "AttachToDali");
			iserv->onAttachToDali(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "WSESPControl", "AttachToDali");
		response->set_name("AttachToDaliResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "CleanSession")||!stricmp(thecall->get_name(), "CleanSessionRequest"))
	{
		Owned<CCleanSessionRequest> esp_request = new CCleanSessionRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CCleanSessionResponse> esp_response = new CCleanSessionResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		StringBuffer source;
		source.appendf("WSESPControl::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			if (clientVer!=-1.0 && clientVer<1.01)
				throw MakeStringException(-1, "Client version is too old, please update your client application.");			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "WSESPControl", "CleanSession");
			iserv->onCleanSession(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "WSESPControl", "CleanSession");
		response->set_name("CleanSessionResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "DetachFromDali")||!stricmp(thecall->get_name(), "DetachFromDaliRequest"))
	{
		Owned<CDetachFromDaliRequest> esp_request = new CDetachFromDaliRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CDetachFromDaliResponse> esp_response = new CDetachFromDaliResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		StringBuffer source;
		source.appendf("WSESPControl::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			if (clientVer!=-1.0 && clientVer<1.02)
				throw MakeStringException(-1, "Client version is too old, please update your client application.");			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "WSESPControl", "DetachFromDali");
			iserv->onDetachFromDali(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "WSESPControl", "DetachFromDali");
		response->set_name("DetachFromDaliResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "DisableDaliSubscriptions")||!stricmp(thecall->get_name(), "DisableDaliSubscriptionsRequest"))
	{
		Owned<CDisableDaliSubscriptionsRequest> esp_request = new CDisableDaliSubscriptionsRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CDisableDaliSubscriptionsResponse> esp_response = new CDisableDaliSubscriptionsResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		StringBuffer source;
		source.appendf("WSESPControl::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			if (clientVer!=-1.0 && clientVer<1.02)
				throw MakeStringException(-1, "Client version is too old, please update your client application.");			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "WSESPControl", "DisableDaliSubscriptions");
			iserv->onDisableDaliSubscriptions(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "WSESPControl", "DisableDaliSubscriptions");
		response->set_name("DisableDaliSubscriptionsResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "EnableDaliSubscriptions")||!stricmp(thecall->get_name(), "EnableDaliSubscriptionsRequest"))
	{
		Owned<CEnableDaliSubscriptionsRequest> esp_request = new CEnableDaliSubscriptionsRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CEnableDaliSubscriptionsResponse> esp_response = new CEnableDaliSubscriptionsResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		StringBuffer source;
		source.appendf("WSESPControl::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			if (clientVer!=-1.0 && clientVer<1.02)
				throw MakeStringException(-1, "Client version is too old, please update your client application.");			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "WSESPControl", "EnableDaliSubscriptions");
			iserv->onEnableDaliSubscriptions(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "WSESPControl", "EnableDaliSubscriptions");
		response->set_name("EnableDaliSubscriptionsResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "Ping")||!stricmp(thecall->get_name(), "WSESPControlPingRequest"))
	{
		Owned<CWSESPControlPingRequest> esp_request = new CWSESPControlPingRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CWSESPControlPingResponse> esp_response = new CWSESPControlPingResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		StringBuffer source;
		source.appendf("WSESPControl::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "WSESPControl", "Ping");
			iserv->onPing(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "WSESPControl", "Ping");
		response->set_name("WSESPControlPingResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "SessionInfo")||!stricmp(thecall->get_name(), "SessionInfoRequest"))
	{
		Owned<CSessionInfoRequest> esp_request = new CSessionInfoRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CSessionInfoResponse> esp_response = new CSessionInfoResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		StringBuffer source;
		source.appendf("WSESPControl::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			if (clientVer!=-1.0 && clientVer<1.01)
				throw MakeStringException(-1, "Client version is too old, please update your client application.");			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "WSESPControl", "SessionInfo");
			iserv->onSessionInfo(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "WSESPControl", "SessionInfo");
		response->set_name("SessionInfoResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "SessionQuery")||!stricmp(thecall->get_name(), "SessionQueryRequest"))
	{
		Owned<CSessionQueryRequest> esp_request = new CSessionQueryRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CSessionQueryResponse> esp_response = new CSessionQueryResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		StringBuffer source;
		source.appendf("WSESPControl::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			if (clientVer!=-1.0 && clientVer<1.01)
				throw MakeStringException(-1, "Client version is too old, please update your client application.");			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "WSESPControl", "SessionQuery");
			iserv->onSessionQuery(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "WSESPControl", "SessionQuery");
		response->set_name("SessionQueryResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "SetLogging")||!stricmp(thecall->get_name(), "SetLoggingRequest"))
	{
		Owned<CSetLoggingRequest> esp_request = new CSetLoggingRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CSetLoggingResponse> esp_response = new CSetLoggingResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		StringBuffer source;
		source.appendf("WSESPControl::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "WSESPControl", "SetLogging");
			iserv->onSetLogging(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "WSESPControl", "SetLogging");
		response->set_name("SetLoggingResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "SetSessionTimeout")||!stricmp(thecall->get_name(), "SetSessionTimeoutRequest"))
	{
		Owned<CSetSessionTimeoutRequest> esp_request = new CSetSessionTimeoutRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CSetSessionTimeoutResponse> esp_response = new CSetSessionTimeoutResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		StringBuffer source;
		source.appendf("WSESPControl::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			if (clientVer!=-1.0 && clientVer<1.01)
				throw MakeStringException(-1, "Client version is too old, please update your client application.");			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "WSESPControl", "SetSessionTimeout");
			iserv->onSetSessionTimeout(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "WSESPControl", "SetSessionTimeout");
		response->set_name("SetSessionTimeoutResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	response->set_status(SOAP_CLIENT_ERROR);
	StringBuffer msg, svcName;
	msg.appendf("Method %s not available in service %s",thecall->get_name(),getServiceName(svcName).str());
	ERRLOG("%s", msg.str());
	response->set_err(msg);
	return -1;
}

int CWSESPControlSoapBinding::getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &content, const char *service, const char *method, bool mda)
{
	BoolHash added;
	if (context.getClientVersion()<=0)
		context.setClientVersion(1.02);

	DBGLOG("Client version: %g", context.getClientVersion());
	bool fullservice = (!Utils::strcasecmp(service, "WSESPControl"));
	bool allMethods = (method==NULL || *method==0);
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "AttachToDali"))) || Utils::strcasecmp(method, "AttachToDali")==0)
	{
		if (context.getClientVersion()>=1.02) {
			CAttachToDaliRequest::getMapInfo(context.queryMapInfo());
			CAttachToDaliResponse::getMapInfo(context.queryMapInfo());
			CAttachToDaliRequest::getXsdDefinition(context, request, "AttachToDaliRequest", content, added);
			CAttachToDaliResponse::getXsdDefinition(context, request, content, added);
		}
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "CleanSession"))) || Utils::strcasecmp(method, "CleanSession")==0)
	{
		if (context.getClientVersion()>=1.01) {
			CCleanSessionRequest::getMapInfo(context.queryMapInfo());
			CCleanSessionResponse::getMapInfo(context.queryMapInfo());
			CCleanSessionRequest::getXsdDefinition(context, request, "CleanSessionRequest", content, added);
			CCleanSessionResponse::getXsdDefinition(context, request, content, added);
		}
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "DetachFromDali"))) || Utils::strcasecmp(method, "DetachFromDali")==0)
	{
		if (context.getClientVersion()>=1.02) {
			CDetachFromDaliRequest::getMapInfo(context.queryMapInfo());
			CDetachFromDaliResponse::getMapInfo(context.queryMapInfo());
			CDetachFromDaliRequest::getXsdDefinition(context, request, "DetachFromDaliRequest", content, added);
			CDetachFromDaliResponse::getXsdDefinition(context, request, content, added);
		}
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "DisableDaliSubscriptions"))) || Utils::strcasecmp(method, "DisableDaliSubscriptions")==0)
	{
		if (context.getClientVersion()>=1.02) {
			CDisableDaliSubscriptionsRequest::getMapInfo(context.queryMapInfo());
			CDisableDaliSubscriptionsResponse::getMapInfo(context.queryMapInfo());
			CDisableDaliSubscriptionsRequest::getXsdDefinition(context, request, "DisableDaliSubscriptionsRequest", content, added);
			CDisableDaliSubscriptionsResponse::getXsdDefinition(context, request, content, added);
		}
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "EnableDaliSubscriptions"))) || Utils::strcasecmp(method, "EnableDaliSubscriptions")==0)
	{
		if (context.getClientVersion()>=1.02) {
			CEnableDaliSubscriptionsRequest::getMapInfo(context.queryMapInfo());
			CEnableDaliSubscriptionsResponse::getMapInfo(context.queryMapInfo());
			CEnableDaliSubscriptionsRequest::getXsdDefinition(context, request, "EnableDaliSubscriptionsRequest", content, added);
			CEnableDaliSubscriptionsResponse::getXsdDefinition(context, request, content, added);
		}
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "Ping"))) || Utils::strcasecmp(method, "Ping")==0)
	{
		CWSESPControlPingRequest::getMapInfo(context.queryMapInfo());
		CWSESPControlPingResponse::getMapInfo(context.queryMapInfo());
		CWSESPControlPingRequest::getXsdDefinition(context, request, "WSESPControlPingRequest", content, added);
		CWSESPControlPingResponse::getXsdDefinition(context, request, content, added);
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "SessionInfo"))) || Utils::strcasecmp(method, "SessionInfo")==0)
	{
		if (context.getClientVersion()>=1.01) {
			CSessionInfoRequest::getMapInfo(context.queryMapInfo());
			CSessionInfoResponse::getMapInfo(context.queryMapInfo());
			CSessionInfoRequest::getXsdDefinition(context, request, "SessionInfoRequest", content, added);
			CSessionInfoResponse::getXsdDefinition(context, request, content, added);
		}
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "SessionQuery"))) || Utils::strcasecmp(method, "SessionQuery")==0)
	{
		if (context.getClientVersion()>=1.01) {
			CSessionQueryRequest::getMapInfo(context.queryMapInfo());
			CSessionQueryResponse::getMapInfo(context.queryMapInfo());
			CSessionQueryRequest::getXsdDefinition(context, request, "SessionQueryRequest", content, added);
			CSessionQueryResponse::getXsdDefinition(context, request, content, added);
		}
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "SetLogging"))) || Utils::strcasecmp(method, "SetLogging")==0)
	{
		CSetLoggingRequest::getMapInfo(context.queryMapInfo());
		CSetLoggingResponse::getMapInfo(context.queryMapInfo());
		CSetLoggingRequest::getXsdDefinition(context, request, "SetLoggingRequest", content, added);
		CSetLoggingResponse::getXsdDefinition(context, request, content, added);
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "SetSessionTimeout"))) || Utils::strcasecmp(method, "SetSessionTimeout")==0)
	{
		if (context.getClientVersion()>=1.01) {
			CSetSessionTimeoutRequest::getMapInfo(context.queryMapInfo());
			CSetSessionTimeoutResponse::getMapInfo(context.queryMapInfo());
			CSetSessionTimeoutRequest::getXsdDefinition(context, request, "SetSessionTimeoutRequest", content, added);
			CSetSessionTimeoutResponse::getXsdDefinition(context, request, content, added);
		}
	}
	return 0;
}

int CWSESPControlSoapBinding::getMethodHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &page, bool bIncludeFormTag)
{
	DBGLOG("Client version: %g", context.getClientVersion());
	if (Utils::strcasecmp(method, "AttachToDali")==0)
	{
		CAttachToDaliRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "CleanSession")==0)
	{
		CCleanSessionRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "DetachFromDali")==0)
	{
		CDetachFromDaliRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "DisableDaliSubscriptions")==0)
	{
		CDisableDaliSubscriptionsRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "EnableDaliSubscriptions")==0)
	{
		CEnableDaliSubscriptionsRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "Ping")==0)
	{
		CWSESPControlPingRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "SessionInfo")==0)
	{
		CSessionInfoRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "SessionQuery")==0)
	{
		CSessionQueryRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "SetLogging")==0)
	{
		CSetLoggingRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "SetSessionTimeout")==0)
	{
		CSetSessionTimeoutRequest::getHtmlForm(context, request, serv, method, page);
	}
	return 0;
}

int CWSESPControlSoapBinding::getQualifiedNames(IEspContext& ctx, MethodInfoArray & methods)
{
	double ver = ctx.getClientVersion();
	if (ver<=0)
		ver = getWsdlVersion();
	const char *servname=ctx.queryServiceName(NULL);
	bool fullservice = (!stricmp(servname, "esp")||!stricmp(servname, "WSESPControl"));
	if ((fullservice || isMethodInSubService(ctx, servname, "AttachToDali")) && ctx.isMethodAllowed(ver,NULL, NULL, 1.02, -1))
		methods.append(*new CMethodInfo("AttachToDali", "AttachToDaliRequest", "AttachToDaliResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "CleanSession")) && ctx.isMethodAllowed(ver,NULL, NULL, 1.01, -1))
		methods.append(*new CMethodInfo("CleanSession", "CleanSessionRequest", "CleanSessionResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "DetachFromDali")) && ctx.isMethodAllowed(ver,NULL, NULL, 1.02, -1))
		methods.append(*new CMethodInfo("DetachFromDali", "DetachFromDaliRequest", "DetachFromDaliResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "DisableDaliSubscriptions")) && ctx.isMethodAllowed(ver,NULL, NULL, 1.02, -1))
		methods.append(*new CMethodInfo("DisableDaliSubscriptions", "DisableDaliSubscriptionsRequest", "DisableDaliSubscriptionsResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "EnableDaliSubscriptions")) && ctx.isMethodAllowed(ver,NULL, NULL, 1.02, -1))
		methods.append(*new CMethodInfo("EnableDaliSubscriptions", "EnableDaliSubscriptionsRequest", "EnableDaliSubscriptionsResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "Ping")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("Ping", "WSESPControlPingRequest", "WSESPControlPingResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "SessionInfo")) && ctx.isMethodAllowed(ver,NULL, NULL, 1.01, -1))
		methods.append(*new CMethodInfo("SessionInfo", "SessionInfoRequest", "SessionInfoResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "SessionQuery")) && ctx.isMethodAllowed(ver,NULL, NULL, 1.01, -1))
		methods.append(*new CMethodInfo("SessionQuery", "SessionQueryRequest", "SessionQueryResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "SetLogging")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("SetLogging", "SetLoggingRequest", "SetLoggingResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "SetSessionTimeout")) && ctx.isMethodAllowed(ver,NULL, NULL, 1.01, -1))
		methods.append(*new CMethodInfo("SetSessionTimeout", "SetSessionTimeoutRequest", "SetSessionTimeoutResponse"));
	return methods.ordinality();
}

StringBuffer & CWSESPControlSoapBinding::getServiceName(StringBuffer &resp)
{
	resp.append("WSESPControl");
	return resp;
}

bool CWSESPControlSoapBinding::isValidServiceName(IEspContext &context, const char *name)
{
	if (!Utils::strcasecmp(name, "WSESPControl"))
		return true;
	else
		return (hasSubService(context, name));
}

bool CWSESPControlSoapBinding::qualifyMethodName(IEspContext &context, const char *methname, StringBuffer *methQName)
{
	if (!methname || !*methname)
	{
		if (methQName!=NULL)
			methQName->clear();
		return true;
	}
	if (Utils::strcasecmp(methname, "AttachToDali")==0)
	{
		if (methQName!=NULL)
			methQName->set("AttachToDali");
		return true;
	}
	if (Utils::strcasecmp(methname, "CleanSession")==0)
	{
		if (methQName!=NULL)
			methQName->set("CleanSession");
		return true;
	}
	if (Utils::strcasecmp(methname, "DetachFromDali")==0)
	{
		if (methQName!=NULL)
			methQName->set("DetachFromDali");
		return true;
	}
	if (Utils::strcasecmp(methname, "DisableDaliSubscriptions")==0)
	{
		if (methQName!=NULL)
			methQName->set("DisableDaliSubscriptions");
		return true;
	}
	if (Utils::strcasecmp(methname, "EnableDaliSubscriptions")==0)
	{
		if (methQName!=NULL)
			methQName->set("EnableDaliSubscriptions");
		return true;
	}
	if (Utils::strcasecmp(methname, "Ping")==0)
	{
		if (methQName!=NULL)
			methQName->set("Ping");
		return true;
	}
	if (Utils::strcasecmp(methname, "SessionInfo")==0)
	{
		if (methQName!=NULL)
			methQName->set("SessionInfo");
		return true;
	}
	if (Utils::strcasecmp(methname, "SessionQuery")==0)
	{
		if (methQName!=NULL)
			methQName->set("SessionQuery");
		return true;
	}
	if (Utils::strcasecmp(methname, "SetLogging")==0)
	{
		if (methQName!=NULL)
			methQName->set("SetLogging");
		return true;
	}
	if (Utils::strcasecmp(methname, "SetSessionTimeout")==0)
	{
		if (methQName!=NULL)
			methQName->set("SetSessionTimeout");
		return true;
	}
	return false;
}

bool CWSESPControlSoapBinding::qualifyServiceName(IEspContext &context, const char *servname, const char *methname, StringBuffer &servQName, StringBuffer *methQName)
{
	servQName.clear();
	if (!Utils::strcasecmp(servname, "WSESPControl"))
	{
		servQName.append("WSESPControl");
		return qualifyMethodName(context, methname, methQName);
	}
	return qualifySubServiceName(context, servname, methname, servQName, methQName);
}

int CWSESPControlSoapBinding::onGetFile(IEspContext &context, CHttpRequest* request, CHttpResponse* response, const char *pathex)
{
	if(request == NULL || response == NULL)
		return -1;
	StringBuffer mimetype;
	MemoryBuffer content;

	StringBuffer filepath;
	getBaseFilePath(filepath);
	if (strchr("\\/", filepath.charAt(filepath.length()-1))==NULL)
		filepath.append("/");
	filepath.append(pathex);
	response->httpContentFromFile(filepath.str());
	response->send();
	return 0;
}

int CWSESPControlSoapBinding::onGetForm(IEspContext &context, CHttpRequest* request, CHttpResponse* response, const char *service, const char *method)
{
	if (context.getClientVersion()<=0)
		context.setClientVersion(1.02);

	if (!stricmp("AttachToDali", method)) {
		CAttachToDaliRequest::getMapInfo(context.queryMapInfo());
		CAttachToDaliResponse::getMapInfo(context.queryMapInfo());
	}
	if (!stricmp("CleanSession", method)) {
		CCleanSessionRequest::getMapInfo(context.queryMapInfo());
		CCleanSessionResponse::getMapInfo(context.queryMapInfo());
	}
	if (!stricmp("DetachFromDali", method)) {
		CDetachFromDaliRequest::getMapInfo(context.queryMapInfo());
		CDetachFromDaliResponse::getMapInfo(context.queryMapInfo());
	}
	if (!stricmp("DisableDaliSubscriptions", method)) {
		CDisableDaliSubscriptionsRequest::getMapInfo(context.queryMapInfo());
		CDisableDaliSubscriptionsResponse::getMapInfo(context.queryMapInfo());
	}
	if (!stricmp("EnableDaliSubscriptions", method)) {
		CEnableDaliSubscriptionsRequest::getMapInfo(context.queryMapInfo());
		CEnableDaliSubscriptionsResponse::getMapInfo(context.queryMapInfo());
	}
	if (!stricmp("Ping", method)) {
		CWSESPControlPingRequest::getMapInfo(context.queryMapInfo());
		CWSESPControlPingResponse::getMapInfo(context.queryMapInfo());
	}
	if (!stricmp("SessionInfo", method)) {
		CSessionInfoRequest::getMapInfo(context.queryMapInfo());
		CSessionInfoResponse::getMapInfo(context.queryMapInfo());
	}
	if (!stricmp("SessionQuery", method)) {
		CSessionQueryRequest::getMapInfo(context.queryMapInfo());
		CSessionQueryResponse::getMapInfo(context.queryMapInfo());
	}
	if (!stricmp("SetLogging", method)) {
		CSetLoggingRequest::getMapInfo(context.queryMapInfo());
		CSetLoggingResponse::getMapInfo(context.queryMapInfo());
	}
	if (!stricmp("SetSessionTimeout", method)) {
		CSetSessionTimeoutRequest::getMapInfo(context.queryMapInfo());
		CSetSessionTimeoutResponse::getMapInfo(context.queryMapInfo());
	}

	return EspHttpBinding::onGetForm(context, request, response, service, method);
}
int CWSESPControlSoapBinding::onGetXForm(IEspContext &context, CHttpRequest* request, CHttpResponse* response, const char *service, const char *method)
{
	return EspHttpBinding::onGetXForm(context, request, response, service, method);
}

int CWSESPControlSoapBinding::onGetService(IEspContext &context, CHttpRequest* request, CHttpResponse* response, const char *service, const char *method, const char *pathex)
{
	if(request == NULL || response == NULL)
		return -1;
	return onGetQuery(context, request, response, service, method);
}

 IRpcRequestBinding *CWSESPControlSoapBinding::createReqBinding(IEspContext &context, IHttpMessage *ireq, const char *service, const char *method)
{
	CHttpRequest *request=static_cast<CHttpRequest*>(ireq);
	IProperties *props = (request) ? request->queryParameters() : NULL;

	if (!stricmp(method, "AttachToDali") || !stricmp(method, "AttachToDaliRequest"))
		return new CAttachToDaliRequest(&context, "WSESPControl", props, NULL);
	if (!stricmp(method, "CleanSession") || !stricmp(method, "CleanSessionRequest"))
		return new CCleanSessionRequest(&context, "WSESPControl", props, NULL);
	if (!stricmp(method, "DetachFromDali") || !stricmp(method, "DetachFromDaliRequest"))
		return new CDetachFromDaliRequest(&context, "WSESPControl", props, NULL);
	if (!stricmp(method, "DisableDaliSubscriptions") || !stricmp(method, "DisableDaliSubscriptionsRequest"))
		return new CDisableDaliSubscriptionsRequest(&context, "WSESPControl", props, NULL);
	if (!stricmp(method, "EnableDaliSubscriptions") || !stricmp(method, "EnableDaliSubscriptionsRequest"))
		return new CEnableDaliSubscriptionsRequest(&context, "WSESPControl", props, NULL);
	if (!stricmp(method, "Ping") || !stricmp(method, "WSESPControlPingRequest"))
		return new CWSESPControlPingRequest(&context, "WSESPControl", props, NULL);
	if (!stricmp(method, "SessionInfo") || !stricmp(method, "SessionInfoRequest"))
		return new CSessionInfoRequest(&context, "WSESPControl", props, NULL);
	if (!stricmp(method, "SessionQuery") || !stricmp(method, "SessionQueryRequest"))
		return new CSessionQueryRequest(&context, "WSESPControl", props, NULL);
	if (!stricmp(method, "SetLogging") || !stricmp(method, "SetLoggingRequest"))
		return new CSetLoggingRequest(&context, "WSESPControl", props, NULL);
	if (!stricmp(method, "SetSessionTimeout") || !stricmp(method, "SetSessionTimeoutRequest"))
		return new CSetSessionTimeoutRequest(&context, "WSESPControl", props, NULL);
	return NULL;
}

int CWSESPControlSoapBinding::onGetInstantQuery(IEspContext &context, CHttpRequest* request, CHttpResponse* response, const char *service, const char *method)
{
	if (context.getClientVersion()<=0)
		context.setClientVersion(1.01);

	if(request == NULL || response == NULL)
		return -1;
	StringBuffer respStr;
	Owned<IEspWSESPControl> iserv = (IEspWSESPControl*)getService();
	if(iserv == NULL)
	{
		respStr.append("Service not available");
		response->setContent(respStr.str());
		response->setContentType("text/html");
		response->send();
	}
	else
	{
		Owned<CSoapResponseBinding> esp_response;
		StringBuffer source;
		IEspContext& context = *request->queryContext();
		if(!stricmp(method, "AttachToDali")||!stricmp(method, "AttachToDaliRequest"))
		{
			Owned<CAttachToDaliRequest> esp_request = new CAttachToDaliRequest(&context, "WSESPControl", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			CAttachToDaliResponse* resp = new CAttachToDaliResponse("WSESPControl");
			esp_response.setown(resp);
			MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
			source.setf("WSESPControl::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				if(accessmap.ordinality()>0)
					onFeaturesAuthorize(context, accessmap, "WSESPControl", "AttachToDali");
				iserv->onAttachToDali(context, *esp_request.get(), *resp);
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "WSESPControl", "AttachToDali", StringBuffer(getCFD()).append("./smc_xslt/exceptions.xslt").str()))
				return 0;
		}
		if(!stricmp(method, "CleanSession")||!stricmp(method, "CleanSessionRequest"))
		{
			Owned<CCleanSessionRequest> esp_request = new CCleanSessionRequest(&context, "WSESPControl", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			CCleanSessionResponse* resp = new CCleanSessionResponse("WSESPControl");
			esp_response.setown(resp);
			MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
			source.setf("WSESPControl::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				if(accessmap.ordinality()>0)
					onFeaturesAuthorize(context, accessmap, "WSESPControl", "CleanSession");
				iserv->onCleanSession(context, *esp_request.get(), *resp);
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "WSESPControl", "CleanSession", StringBuffer(getCFD()).append("./smc_xslt/exceptions.xslt").str()))
				return 0;
		}
		if(!stricmp(method, "DetachFromDali")||!stricmp(method, "DetachFromDaliRequest"))
		{
			Owned<CDetachFromDaliRequest> esp_request = new CDetachFromDaliRequest(&context, "WSESPControl", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			CDetachFromDaliResponse* resp = new CDetachFromDaliResponse("WSESPControl");
			esp_response.setown(resp);
			MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
			source.setf("WSESPControl::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				if(accessmap.ordinality()>0)
					onFeaturesAuthorize(context, accessmap, "WSESPControl", "DetachFromDali");
				iserv->onDetachFromDali(context, *esp_request.get(), *resp);
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "WSESPControl", "DetachFromDali", StringBuffer(getCFD()).append("./smc_xslt/exceptions.xslt").str()))
				return 0;
		}
		if(!stricmp(method, "DisableDaliSubscriptions")||!stricmp(method, "DisableDaliSubscriptionsRequest"))
		{
			Owned<CDisableDaliSubscriptionsRequest> esp_request = new CDisableDaliSubscriptionsRequest(&context, "WSESPControl", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			CDisableDaliSubscriptionsResponse* resp = new CDisableDaliSubscriptionsResponse("WSESPControl");
			esp_response.setown(resp);
			MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
			source.setf("WSESPControl::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				if(accessmap.ordinality()>0)
					onFeaturesAuthorize(context, accessmap, "WSESPControl", "DisableDaliSubscriptions");
				iserv->onDisableDaliSubscriptions(context, *esp_request.get(), *resp);
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "WSESPControl", "DisableDaliSubscriptions", StringBuffer(getCFD()).append("./smc_xslt/exceptions.xslt").str()))
				return 0;
		}
		if(!stricmp(method, "EnableDaliSubscriptions")||!stricmp(method, "EnableDaliSubscriptionsRequest"))
		{
			Owned<CEnableDaliSubscriptionsRequest> esp_request = new CEnableDaliSubscriptionsRequest(&context, "WSESPControl", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			CEnableDaliSubscriptionsResponse* resp = new CEnableDaliSubscriptionsResponse("WSESPControl");
			esp_response.setown(resp);
			MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
			source.setf("WSESPControl::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				if(accessmap.ordinality()>0)
					onFeaturesAuthorize(context, accessmap, "WSESPControl", "EnableDaliSubscriptions");
				iserv->onEnableDaliSubscriptions(context, *esp_request.get(), *resp);
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "WSESPControl", "EnableDaliSubscriptions", StringBuffer(getCFD()).append("./smc_xslt/exceptions.xslt").str()))
				return 0;
		}
		if(!stricmp(method, "Ping")||!stricmp(method, "WSESPControlPingRequest"))
		{
			Owned<CWSESPControlPingRequest> esp_request = new CWSESPControlPingRequest(&context, "WSESPControl", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			CWSESPControlPingResponse* resp = new CWSESPControlPingResponse("WSESPControl");
			esp_response.setown(resp);
			MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
			source.setf("WSESPControl::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				if(accessmap.ordinality()>0)
					onFeaturesAuthorize(context, accessmap, "WSESPControl", "Ping");
				iserv->onPing(context, *esp_request.get(), *resp);
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "WSESPControl", "Ping", StringBuffer(getCFD()).append("./smc_xslt/exceptions.xslt").str()))
				return 0;
		}
		if(!stricmp(method, "SessionInfo")||!stricmp(method, "SessionInfoRequest"))
		{
			Owned<CSessionInfoRequest> esp_request = new CSessionInfoRequest(&context, "WSESPControl", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			CSessionInfoResponse* resp = new CSessionInfoResponse("WSESPControl");
			esp_response.setown(resp);
			MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
			source.setf("WSESPControl::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				if(accessmap.ordinality()>0)
					onFeaturesAuthorize(context, accessmap, "WSESPControl", "SessionInfo");
				iserv->onSessionInfo(context, *esp_request.get(), *resp);
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "WSESPControl", "SessionInfo", StringBuffer(getCFD()).append("./smc_xslt/exceptions.xslt").str()))
				return 0;
		}
		if(!stricmp(method, "SessionQuery")||!stricmp(method, "SessionQueryRequest"))
		{
			Owned<CSessionQueryRequest> esp_request = new CSessionQueryRequest(&context, "WSESPControl", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			CSessionQueryResponse* resp = new CSessionQueryResponse("WSESPControl");
			esp_response.setown(resp);
			MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
			source.setf("WSESPControl::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				if(accessmap.ordinality()>0)
					onFeaturesAuthorize(context, accessmap, "WSESPControl", "SessionQuery");
				iserv->onSessionQuery(context, *esp_request.get(), *resp);
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "WSESPControl", "SessionQuery", StringBuffer(getCFD()).append("./smc_xslt/exceptions.xslt").str()))
				return 0;
		}
		if(!stricmp(method, "SetLogging")||!stricmp(method, "SetLoggingRequest"))
		{
			Owned<CSetLoggingRequest> esp_request = new CSetLoggingRequest(&context, "WSESPControl", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			CSetLoggingResponse* resp = new CSetLoggingResponse("WSESPControl");
			esp_response.setown(resp);
			MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
			source.setf("WSESPControl::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				if(accessmap.ordinality()>0)
					onFeaturesAuthorize(context, accessmap, "WSESPControl", "SetLogging");
				iserv->onSetLogging(context, *esp_request.get(), *resp);
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "WSESPControl", "SetLogging", StringBuffer(getCFD()).append("./smc_xslt/exceptions.xslt").str()))
				return 0;
		}
		if(!stricmp(method, "SetSessionTimeout")||!stricmp(method, "SetSessionTimeoutRequest"))
		{
			Owned<CSetSessionTimeoutRequest> esp_request = new CSetSessionTimeoutRequest(&context, "WSESPControl", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			CSetSessionTimeoutResponse* resp = new CSetSessionTimeoutResponse("WSESPControl");
			esp_response.setown(resp);
			MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
			source.setf("WSESPControl::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				if(accessmap.ordinality()>0)
					onFeaturesAuthorize(context, accessmap, "WSESPControl", "SetSessionTimeout");
				iserv->onSetSessionTimeout(context, *esp_request.get(), *resp);
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "WSESPControl", "SetSessionTimeout", StringBuffer(getCFD()).append("./smc_xslt/exceptions.xslt").str()))
				return 0;
		}

		if (esp_response.get())
		{
			if (canRedirect(*request) && esp_response->getRedirectUrl() && *esp_response->getRedirectUrl())
				response->redirect(*request, esp_response->getRedirectUrl());
			else
			{
				MemoryBuffer content;
				StringBuffer mimetype;
				esp_response->appendContent(&context,content, mimetype);
				onBeforeSendResponse(context,request,content,service,method);
				response->setContent(content.length(), content.toByteArray());
				response->setContentType(mimetype.str());
				response->send();
			}
			return 0;
		}
	}
	return onGetNotFound(context, request,  response, service);
}





//=======================================================
// client util methods
//=======================================================

//------ method AttachToDali ---------

IClientAttachToDaliRequest * CClientWSESPControl::createAttachToDaliRequest()
{
	CAttachToDaliRequest* request = new CAttachToDaliRequest("WSESPControl");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientAttachToDaliResponse * CClientWSESPControl::AttachToDali(IClientAttachToDaliRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CAttachToDaliRequest* esprequest = static_cast<CAttachToDaliRequest*>(request);
	CAttachToDaliResponse* espresponse = new CAttachToDaliResponse("WSESPControl");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientWSESPControl::async_AttachToDali(IClientAttachToDaliRequest *request, IClientWSESPControlEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CAttachToDaliRequest* esprequest = static_cast<CAttachToDaliRequest*>(request);
	esprequest->setMethod("AttachToDali");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientWSESPControl::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientAttachToDaliResponse *CClientWSESPControl::AttachToDaliFn()
{
	Owned<IClientAttachToDaliRequest> req =  createAttachToDaliRequest();
	return AttachToDali(req.get());
}

//------ method CleanSession ---------

IClientCleanSessionRequest * CClientWSESPControl::createCleanSessionRequest()
{
	CCleanSessionRequest* request = new CCleanSessionRequest("WSESPControl");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientCleanSessionResponse * CClientWSESPControl::CleanSession(IClientCleanSessionRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CCleanSessionRequest* esprequest = static_cast<CCleanSessionRequest*>(request);
	CCleanSessionResponse* espresponse = new CCleanSessionResponse("WSESPControl");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientWSESPControl::async_CleanSession(IClientCleanSessionRequest *request, IClientWSESPControlEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CCleanSessionRequest* esprequest = static_cast<CCleanSessionRequest*>(request);
	esprequest->setMethod("CleanSession");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientWSESPControl::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientCleanSessionResponse *CClientWSESPControl::CleanSessionFn(const char * ID_, const char * UserID_, const char * FromIP_, bool AllSessions_)
{
	Owned<IClientCleanSessionRequest> req =  createCleanSessionRequest();
	req->setID(ID_);
	req->setUserID(UserID_);
	req->setFromIP(FromIP_);
	req->setAllSessions(AllSessions_);
	return CleanSession(req.get());
}

//------ method DetachFromDali ---------

IClientDetachFromDaliRequest * CClientWSESPControl::createDetachFromDaliRequest()
{
	CDetachFromDaliRequest* request = new CDetachFromDaliRequest("WSESPControl");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientDetachFromDaliResponse * CClientWSESPControl::DetachFromDali(IClientDetachFromDaliRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CDetachFromDaliRequest* esprequest = static_cast<CDetachFromDaliRequest*>(request);
	CDetachFromDaliResponse* espresponse = new CDetachFromDaliResponse("WSESPControl");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientWSESPControl::async_DetachFromDali(IClientDetachFromDaliRequest *request, IClientWSESPControlEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CDetachFromDaliRequest* esprequest = static_cast<CDetachFromDaliRequest*>(request);
	esprequest->setMethod("DetachFromDali");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientWSESPControl::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientDetachFromDaliResponse *CClientWSESPControl::DetachFromDaliFn(bool Force_)
{
	Owned<IClientDetachFromDaliRequest> req =  createDetachFromDaliRequest();
	req->setForce(Force_);
	return DetachFromDali(req.get());
}

//------ method DisableDaliSubscriptions ---------

IClientDisableDaliSubscriptionsRequest * CClientWSESPControl::createDisableDaliSubscriptionsRequest()
{
	CDisableDaliSubscriptionsRequest* request = new CDisableDaliSubscriptionsRequest("WSESPControl");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientDisableDaliSubscriptionsResponse * CClientWSESPControl::DisableDaliSubscriptions(IClientDisableDaliSubscriptionsRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CDisableDaliSubscriptionsRequest* esprequest = static_cast<CDisableDaliSubscriptionsRequest*>(request);
	CDisableDaliSubscriptionsResponse* espresponse = new CDisableDaliSubscriptionsResponse("WSESPControl");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientWSESPControl::async_DisableDaliSubscriptions(IClientDisableDaliSubscriptionsRequest *request, IClientWSESPControlEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CDisableDaliSubscriptionsRequest* esprequest = static_cast<CDisableDaliSubscriptionsRequest*>(request);
	esprequest->setMethod("DisableDaliSubscriptions");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientWSESPControl::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientDisableDaliSubscriptionsResponse *CClientWSESPControl::DisableDaliSubscriptionsFn()
{
	Owned<IClientDisableDaliSubscriptionsRequest> req =  createDisableDaliSubscriptionsRequest();
	return DisableDaliSubscriptions(req.get());
}

//------ method EnableDaliSubscriptions ---------

IClientEnableDaliSubscriptionsRequest * CClientWSESPControl::createEnableDaliSubscriptionsRequest()
{
	CEnableDaliSubscriptionsRequest* request = new CEnableDaliSubscriptionsRequest("WSESPControl");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientEnableDaliSubscriptionsResponse * CClientWSESPControl::EnableDaliSubscriptions(IClientEnableDaliSubscriptionsRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CEnableDaliSubscriptionsRequest* esprequest = static_cast<CEnableDaliSubscriptionsRequest*>(request);
	CEnableDaliSubscriptionsResponse* espresponse = new CEnableDaliSubscriptionsResponse("WSESPControl");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientWSESPControl::async_EnableDaliSubscriptions(IClientEnableDaliSubscriptionsRequest *request, IClientWSESPControlEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CEnableDaliSubscriptionsRequest* esprequest = static_cast<CEnableDaliSubscriptionsRequest*>(request);
	esprequest->setMethod("EnableDaliSubscriptions");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientWSESPControl::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientEnableDaliSubscriptionsResponse *CClientWSESPControl::EnableDaliSubscriptionsFn()
{
	Owned<IClientEnableDaliSubscriptionsRequest> req =  createEnableDaliSubscriptionsRequest();
	return EnableDaliSubscriptions(req.get());
}

//------ method Ping ---------

IClientWSESPControlPingRequest * CClientWSESPControl::createPingRequest()
{
	CWSESPControlPingRequest* request = new CWSESPControlPingRequest("WSESPControl");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientWSESPControlPingResponse * CClientWSESPControl::Ping(IClientWSESPControlPingRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CWSESPControlPingRequest* esprequest = static_cast<CWSESPControlPingRequest*>(request);
	CWSESPControlPingResponse* espresponse = new CWSESPControlPingResponse("WSESPControl");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientWSESPControl::async_Ping(IClientWSESPControlPingRequest *request, IClientWSESPControlEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CWSESPControlPingRequest* esprequest = static_cast<CWSESPControlPingRequest*>(request);
	esprequest->setMethod("Ping");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientWSESPControl::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientWSESPControlPingResponse *CClientWSESPControl::PingFn()
{
	Owned<IClientWSESPControlPingRequest> req =  createPingRequest();
	return Ping(req.get());
}

//------ method SessionInfo ---------

IClientSessionInfoRequest * CClientWSESPControl::createSessionInfoRequest()
{
	CSessionInfoRequest* request = new CSessionInfoRequest("WSESPControl");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientSessionInfoResponse * CClientWSESPControl::SessionInfo(IClientSessionInfoRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CSessionInfoRequest* esprequest = static_cast<CSessionInfoRequest*>(request);
	CSessionInfoResponse* espresponse = new CSessionInfoResponse("WSESPControl");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientWSESPControl::async_SessionInfo(IClientSessionInfoRequest *request, IClientWSESPControlEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CSessionInfoRequest* esprequest = static_cast<CSessionInfoRequest*>(request);
	esprequest->setMethod("SessionInfo");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientWSESPControl::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientSessionInfoResponse *CClientWSESPControl::SessionInfoFn(int Port_, const char * ID_)
{
	Owned<IClientSessionInfoRequest> req =  createSessionInfoRequest();
	req->setPort(Port_);
	req->setID(ID_);
	return SessionInfo(req.get());
}

//------ method SessionQuery ---------

IClientSessionQueryRequest * CClientWSESPControl::createSessionQueryRequest()
{
	CSessionQueryRequest* request = new CSessionQueryRequest("WSESPControl");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientSessionQueryResponse * CClientWSESPControl::SessionQuery(IClientSessionQueryRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CSessionQueryRequest* esprequest = static_cast<CSessionQueryRequest*>(request);
	CSessionQueryResponse* espresponse = new CSessionQueryResponse("WSESPControl");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientWSESPControl::async_SessionQuery(IClientSessionQueryRequest *request, IClientWSESPControlEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CSessionQueryRequest* esprequest = static_cast<CSessionQueryRequest*>(request);
	esprequest->setMethod("SessionQuery");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientWSESPControl::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientSessionQueryResponse *CClientWSESPControl::SessionQueryFn(const char * FromIP_, const char * UserID_)
{
	Owned<IClientSessionQueryRequest> req =  createSessionQueryRequest();
	req->setFromIP(FromIP_);
	req->setUserID(UserID_);
	return SessionQuery(req.get());
}

//------ method SetLogging ---------

IClientSetLoggingRequest * CClientWSESPControl::createSetLoggingRequest()
{
	CSetLoggingRequest* request = new CSetLoggingRequest("WSESPControl");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientSetLoggingResponse * CClientWSESPControl::SetLogging(IClientSetLoggingRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CSetLoggingRequest* esprequest = static_cast<CSetLoggingRequest*>(request);
	CSetLoggingResponse* espresponse = new CSetLoggingResponse("WSESPControl");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientWSESPControl::async_SetLogging(IClientSetLoggingRequest *request, IClientWSESPControlEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CSetLoggingRequest* esprequest = static_cast<CSetLoggingRequest*>(request);
	esprequest->setMethod("SetLogging");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientWSESPControl::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientSetLoggingResponse *CClientWSESPControl::SetLoggingFn(int LoggingLevel_, bool LogRequests_, bool LogResponses_)
{
	Owned<IClientSetLoggingRequest> req =  createSetLoggingRequest();
	req->setLoggingLevel(LoggingLevel_);
	req->setLogRequests(LogRequests_);
	req->setLogResponses(LogResponses_);
	return SetLogging(req.get());
}

//------ method SetSessionTimeout ---------

IClientSetSessionTimeoutRequest * CClientWSESPControl::createSetSessionTimeoutRequest()
{
	CSetSessionTimeoutRequest* request = new CSetSessionTimeoutRequest("WSESPControl");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientSetSessionTimeoutResponse * CClientWSESPControl::SetSessionTimeout(IClientSetSessionTimeoutRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CSetSessionTimeoutRequest* esprequest = static_cast<CSetSessionTimeoutRequest*>(request);
	CSetSessionTimeoutResponse* espresponse = new CSetSessionTimeoutResponse("WSESPControl");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientWSESPControl::async_SetSessionTimeout(IClientSetSessionTimeoutRequest *request, IClientWSESPControlEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CSetSessionTimeoutRequest* esprequest = static_cast<CSetSessionTimeoutRequest*>(request);
	esprequest->setMethod("SetSessionTimeout");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientWSESPControl::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientSetSessionTimeoutResponse *CClientWSESPControl::SetSessionTimeoutFn(const char * ID_, const char * UserID_, const char * FromIP_, int TimeoutMinutes_, bool AllSessions_)
{
	Owned<IClientSetSessionTimeoutRequest> req =  createSetSessionTimeoutRequest();
	req->setID(ID_);
	req->setUserID(UserID_);
	req->setFromIP(FromIP_);
	req->setTimeoutMinutes(TimeoutMinutes_);
	req->setAllSessions(AllSessions_);
	return SetSessionTimeout(req.get());
}

int CClientWSESPControl::transferThunkEvent(void *data)
{
	IRpcResponseBinding *response = (IRpcResponseBinding *)data;
	if (response!=NULL)
	{
		IClientWSESPControlEvents *eventSink = (IClientWSESPControlEvents *)response->getEventSink();
		response->lock();

		if (stricmp(response->getMethod(), "AttachToDali")==0)
		{
			IClientAttachToDaliResponse* icresp = dynamic_cast<IClientAttachToDaliResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onAttachToDaliComplete(icresp, response->queryState());
				else
					eventSink->onAttachToDaliError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "CleanSession")==0)
		{
			IClientCleanSessionResponse* icresp = dynamic_cast<IClientCleanSessionResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onCleanSessionComplete(icresp, response->queryState());
				else
					eventSink->onCleanSessionError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "DetachFromDali")==0)
		{
			IClientDetachFromDaliResponse* icresp = dynamic_cast<IClientDetachFromDaliResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onDetachFromDaliComplete(icresp, response->queryState());
				else
					eventSink->onDetachFromDaliError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "DisableDaliSubscriptions")==0)
		{
			IClientDisableDaliSubscriptionsResponse* icresp = dynamic_cast<IClientDisableDaliSubscriptionsResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onDisableDaliSubscriptionsComplete(icresp, response->queryState());
				else
					eventSink->onDisableDaliSubscriptionsError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "EnableDaliSubscriptions")==0)
		{
			IClientEnableDaliSubscriptionsResponse* icresp = dynamic_cast<IClientEnableDaliSubscriptionsResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onEnableDaliSubscriptionsComplete(icresp, response->queryState());
				else
					eventSink->onEnableDaliSubscriptionsError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "Ping")==0)
		{
			IClientWSESPControlPingResponse* icresp = dynamic_cast<IClientWSESPControlPingResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onPingComplete(icresp, response->queryState());
				else
					eventSink->onPingError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "SessionInfo")==0)
		{
			IClientSessionInfoResponse* icresp = dynamic_cast<IClientSessionInfoResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onSessionInfoComplete(icresp, response->queryState());
				else
					eventSink->onSessionInfoError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "SessionQuery")==0)
		{
			IClientSessionQueryResponse* icresp = dynamic_cast<IClientSessionQueryResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onSessionQueryComplete(icresp, response->queryState());
				else
					eventSink->onSessionQueryError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "SetLogging")==0)
		{
			IClientSetLoggingResponse* icresp = dynamic_cast<IClientSetLoggingResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onSetLoggingComplete(icresp, response->queryState());
				else
					eventSink->onSetLoggingError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "SetSessionTimeout")==0)
		{
			IClientSetSessionTimeoutResponse* icresp = dynamic_cast<IClientSetSessionTimeoutResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onSetSessionTimeoutComplete(icresp, response->queryState());
				else
					eventSink->onSetSessionTimeoutError(icresp,response->queryState());
			}
		}
		response->unlock();
	}
	return 0;
}

static IRpcResponseBinding* createWSESPControlResponseObject(IRpcRequestBinding *request)
{
	const char* method = request->getMethod();
	if (stricmp(method, "AttachToDali")==0)
		return new CAttachToDaliResponse("WSESPControl", request);
	if (stricmp(method, "CleanSession")==0)
		return new CCleanSessionResponse("WSESPControl", request);
	if (stricmp(method, "DetachFromDali")==0)
		return new CDetachFromDaliResponse("WSESPControl", request);
	if (stricmp(method, "DisableDaliSubscriptions")==0)
		return new CDisableDaliSubscriptionsResponse("WSESPControl", request);
	if (stricmp(method, "EnableDaliSubscriptions")==0)
		return new CEnableDaliSubscriptionsResponse("WSESPControl", request);
	if (stricmp(method, "Ping")==0)
		return new CWSESPControlPingResponse("WSESPControl", request);
	if (stricmp(method, "SessionInfo")==0)
		return new CSessionInfoResponse("WSESPControl", request);
	if (stricmp(method, "SessionQuery")==0)
		return new CSessionQueryResponse("WSESPControl", request);
	if (stricmp(method, "SetLogging")==0)
		return new CSetLoggingResponse("WSESPControl", request);
	if (stricmp(method, "SetSessionTimeout")==0)
		return new CSetSessionTimeoutResponse("WSESPControl", request);
	return NULL;
}

#ifdef _WIN32
void CClientWSESPControl::espWorkerThread(void* data)
#else
void *CClientWSESPControl::espWorkerThread(void *data)
#endif
{
	IRpcRequestBinding *request = (IRpcRequestBinding *) data;

	if (request != NULL)
	{
		request->lock();
		IRpcResponseBinding *response=createWSESPControlResponseObject(request);
		if (response!=NULL)
		{
			try{
				request->post(*response);
			}
			catch(IException* ex){
				StringBuffer errorStr;
				ex->errorMessage(errorStr);
				ERRLOG("CClientWSESPControl::espWorkerThread(%s)--Exception caught while posting async request: %s", request->getMethod(), errorStr.str());
				ex->Release();
			}
			catch(...){
				ERRLOG("Unknown exception caught while posting async request");
			}
		}
#ifdef USE_CLIENT_THREAD
		ThunkToClientThread(request->getThunkHandle(), transferThunkEvent, (void *)response);
#else
		transferThunkEvent((void *)response);
#endif
		request->unlock();
		if(request->queryState()!=NULL)
			request->queryState()->Release();

		if(response!=NULL)
			response->Release();

		request->Release();
	}
#if defined(_WIN32)
#else
	return (void *) 0 ;
#endif
}



extern "C" IClientWSESPControl * createWSESPControlClient() {  return new CClientWSESPControl(); }


#endif //ws_espcontrol_ESPGEN_INCLUDED
