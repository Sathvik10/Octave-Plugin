// *** Source file generated by HIDL Version 1.3 from ws_topology.ecm ***
// *** Not to be hand edited (changes will be lost on re-generation) ***

#ifndef ws_topology_ESPGEN_INCLUDED
#define ws_topology_ESPGEN_INCLUDED

#include "ws_topology_esp.ipp"

#ifdef _WIN32
#include "edwin.h"
#include <process.h>
#endif



//=======================================================
// class CTpMachine Implementation
//=======================================================

CTpMachine::CTpMachine(const char *serviceName, IRpcMessageBinding *init)
	: m_Name(nilIgnore),m_Netaddress(nilIgnore),m_ConfigNetaddress(nilIgnore),m_Domain(nilIgnore),m_Directory(nilIgnore),m_Type(nilIgnore),m_Available(nilIgnore),m_OS(nilIgnore),m_Path(nilIgnore),m_Port(nilIgnore),m_ProcessNumber(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("TpMachine");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CTpMachine::CTpMachine(const char *serviceName, const char *bc)
	: m_Name(nilIgnore),m_Netaddress(nilIgnore),m_ConfigNetaddress(nilIgnore),m_Domain(nilIgnore),m_Directory(nilIgnore),m_Type(nilIgnore),m_Available(nilIgnore),m_OS(nilIgnore),m_Path(nilIgnore),m_Port(nilIgnore),m_ProcessNumber(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("TpMachine");
}

StringBuffer &CTpMachine::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:complexType name=\"%s\">\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Name\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Netaddress\" type=\"xsd:string\"/>\n");
		if (!context.suppressed("TpMachine","ConfigNetaddress")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"ConfigNetaddress\" type=\"xsd:string\"/>\n");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Domain\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Directory\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Type\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Available\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"OS\" type=\"xsd:int\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Path\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Port\" type=\"xsd:int\"/>\n");
		if (!context.suppressed("TpMachine","ProcessNumber")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"ProcessNumber\" type=\"xsd:int\"/>\n");
		}
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType>\n");
		}
	}
	return schema;
}

void CTpMachine::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CTpMachine::getMapInfo(IMapInfo& info, BoolHash& added)
{
	info.addMinVersion("TpMachine","ConfigNetaddress",1.09);
	info.addMinVersion("TpMachine","ProcessNumber",1.18);
}

StringBuffer &CTpMachine::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Name");
	form.appendf("  <tr><td><b>Name: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Netaddress");
	form.appendf("  <tr><td><b>Netaddress: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (!context.suppressed("TpMachine","ConfigNetaddress")) {
		extfix.clear();
		if (prefix && *prefix)
			extfix.append(prefix).append(".");
		extfix.append("ConfigNetaddress");
		form.appendf("  <tr><td><b>ConfigNetaddress: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
		form.append("</td></tr>\n");
	}
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Domain");
	form.appendf("  <tr><td><b>Domain: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Directory");
	form.appendf("  <tr><td><b>Directory: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Type");
	form.appendf("  <tr><td><b>Type: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Available");
	form.appendf("  <tr><td><b>Available: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix) extfix.append(prefix).append(".");
		extfix.append("OS");
	form.appendf("  <tr><td><b>OS: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Path");
	form.appendf("  <tr><td><b>Path: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix) extfix.append(prefix).append(".");
		extfix.append("Port");
	form.appendf("  <tr><td><b>Port: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
	form.append("</td></tr>\n");
	if (!context.suppressed("TpMachine","ProcessNumber")) {
		extfix.clear();
		if (prefix && *prefix) extfix.append(prefix).append(".");
			extfix.append("ProcessNumber");
		form.appendf("  <tr><td><b>ProcessNumber: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
		form.append("</td></tr>\n");
	}
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CTpMachine::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CTpMachine::serialize(IRpcMessage& rpc_resp)
{
	IEspContext* ctx = rpc_resp.queryContext();
	double clientVer= ctx ? ctx->getClientVersion() : -1; /* no context gets everything */
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_Name.marshall(rpc_resp, "Name", "", "", "");
	m_Netaddress.marshall(rpc_resp, "Netaddress", "", "", "");
	if ((clientVer==-1.0 || clientVer>=1.09))
		m_ConfigNetaddress.marshall(rpc_resp, "ConfigNetaddress", "", "", "");
	m_Domain.marshall(rpc_resp, "Domain", "", "", "");
	m_Directory.marshall(rpc_resp, "Directory", "", "", "");
	m_Type.marshall(rpc_resp, "Type", "", "", "");
	m_Available.marshall(rpc_resp, "Available", "", "", "");
	m_OS.marshall(rpc_resp, "OS", "", "", "");
	m_Path.marshall(rpc_resp, "Path", "", "", "");
	m_Port.marshall(rpc_resp, "Port", "", "", "");
	if ((clientVer==-1.0 || clientVer>=1.18))
		m_ProcessNumber.marshall(rpc_resp, "ProcessNumber", "", "", "");
}


void CTpMachine::copy(CTpMachine &from)
{
	m_Name.copy(from.m_Name);
	m_Netaddress.copy(from.m_Netaddress);
	m_ConfigNetaddress.copy(from.m_ConfigNetaddress);
	m_Domain.copy(from.m_Domain);
	m_Directory.copy(from.m_Directory);
	m_Type.copy(from.m_Type);
	m_Available.copy(from.m_Available);
	m_OS.copy(from.m_OS);
	m_Path.copy(from.m_Path);
	m_Port.copy(from.m_Port);
	m_ProcessNumber.copy(from.m_ProcessNumber);
}


void CTpMachine::copy(IConstTpMachine &ifrom)
{
	setName(ifrom.getName());
	setNetaddress(ifrom.getNetaddress());
	setConfigNetaddress(ifrom.getConfigNetaddress());
	setDomain(ifrom.getDomain());
	setDirectory(ifrom.getDirectory());
	setType(ifrom.getType());
	setAvailable(ifrom.getAvailable());
	setOS(ifrom.getOS());
	setPath(ifrom.getPath());
	setPort(ifrom.getPort());
	setProcessNumber(ifrom.getProcessNumber());
}


void CTpMachine::getAttributes(IProperties &attributes)
{
}


void CTpMachine::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	double clientVer = ctx ? ctx->getClientVersion() : -1;
	m_Name.toStr(ctx, buffer, "Name", "", true, "", "");
	m_Netaddress.toStr(ctx, buffer, "Netaddress", "", true, "", "");
	if ((clientVer==-1.0 || clientVer>=1.09))
		m_ConfigNetaddress.toStr(ctx, buffer, "ConfigNetaddress", "", true, "", "");
	m_Domain.toStr(ctx, buffer, "Domain", "", true, "", "");
	m_Directory.toStr(ctx, buffer, "Directory", "", true, "", "");
	m_Type.toStr(ctx, buffer, "Type", "", true, "", "");
	m_Available.toStr(ctx, buffer, "Available", "", true, "", "");
	m_OS.toStr(ctx, buffer, "OS", "", true, "", "");
	m_Path.toStr(ctx, buffer, "Path", "", true, "", "");
	m_Port.toStr(ctx, buffer, "Port", "", true, "", "");
	if ((clientVer==-1.0 || clientVer>=1.18))
		m_ProcessNumber.toStr(ctx, buffer, "ProcessNumber", "", true, "", "");
}


void CTpMachine::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CTpMachine::serializer(IEspContext* ctx, IConstTpMachine &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<TpMachine>");
	double clientVer = ctx ? ctx->getClientVersion() : -1;
	// field Name
	{
		const char* s = src.getName();
		if (s && *s)
		{
			buffer.append("<Name>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Name>");
		}
	}
	// field Netaddress
	{
		const char* s = src.getNetaddress();
		if (s && *s)
		{
			buffer.append("<Netaddress>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Netaddress>");
		}
	}
	// field ConfigNetaddress
	if ((clientVer==-1.0 || clientVer>=1.09))
	{
		const char* s = src.getConfigNetaddress();
		if (s && *s)
		{
			buffer.append("<ConfigNetaddress>");
			encodeUtf8XML(s,buffer);
			buffer.append("</ConfigNetaddress>");
		}
	}
	// field Domain
	{
		const char* s = src.getDomain();
		if (s && *s)
		{
			buffer.append("<Domain>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Domain>");
		}
	}
	// field Directory
	{
		const char* s = src.getDirectory();
		if (s && *s)
		{
			buffer.append("<Directory>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Directory>");
		}
	}
	// field Type
	{
		const char* s = src.getType();
		if (s && *s)
		{
			buffer.append("<Type>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Type>");
		}
	}
	// field Available
	{
		const char* s = src.getAvailable();
		if (s && *s)
		{
			buffer.append("<Available>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Available>");
		}
	}
	// field OS
	{
		int n = src.getOS();
		if (n)
			buffer.appendf("<OS>%d</OS>", n);
	}
	// field Path
	{
		const char* s = src.getPath();
		if (s && *s)
		{
			buffer.append("<Path>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Path>");
		}
	}
	// field Port
	{
		int n = src.getPort();
		if (n)
			buffer.appendf("<Port>%d</Port>", n);
	}
	// field ProcessNumber
	if ((clientVer==-1.0 || clientVer>=1.18))
	{
		int n = src.getProcessNumber();
		if (n)
			buffer.appendf("<ProcessNumber>%d</ProcessNumber>", n);
	}
	if (keepRootTag)
		buffer.append("</TpMachine>");
}

bool CTpMachine::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_Name.unmarshall(rpc_request, "Name", basepath);
	hasValue |= m_Netaddress.unmarshall(rpc_request, "Netaddress", basepath);
	hasValue |= m_ConfigNetaddress.unmarshall(rpc_request, "ConfigNetaddress", basepath);
	hasValue |= m_Domain.unmarshall(rpc_request, "Domain", basepath);
	hasValue |= m_Directory.unmarshall(rpc_request, "Directory", basepath);
	hasValue |= m_Type.unmarshall(rpc_request, "Type", basepath);
	hasValue |= m_Available.unmarshall(rpc_request, "Available", basepath);
	hasValue |= m_OS.unmarshall(rpc_request, "OS", basepath);
	hasValue |= m_Path.unmarshall(rpc_request, "Path", basepath);
	hasValue |= m_Port.unmarshall(rpc_request, "Port", basepath);
	hasValue |= m_ProcessNumber.unmarshall(rpc_request, "ProcessNumber", basepath);
	return hasValue;
}

bool CTpMachine::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Name.unmarshall(ctx, soapval, "Name");
	hasValue |= m_Netaddress.unmarshall(ctx, soapval, "Netaddress");
	hasValue |= m_ConfigNetaddress.unmarshall(ctx, soapval, "ConfigNetaddress");
	hasValue |= m_Domain.unmarshall(ctx, soapval, "Domain");
	hasValue |= m_Directory.unmarshall(ctx, soapval, "Directory");
	hasValue |= m_Type.unmarshall(ctx, soapval, "Type");
	hasValue |= m_Available.unmarshall(ctx, soapval, "Available");
	hasValue |= m_OS.unmarshall(ctx, soapval, "OS");
	hasValue |= m_Path.unmarshall(ctx, soapval, "Path");
	hasValue |= m_Port.unmarshall(ctx, soapval, "Port");
	hasValue |= m_ProcessNumber.unmarshall(ctx, soapval, "ProcessNumber");
	return hasValue;
}

bool CTpMachine::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Name.unmarshall(ctx, params, attachments, "Name", basepath);
	hasValue |= m_Netaddress.unmarshall(ctx, params, attachments, "Netaddress", basepath);
	hasValue |= m_ConfigNetaddress.unmarshall(ctx, params, attachments, "ConfigNetaddress", basepath);
	hasValue |= m_Domain.unmarshall(ctx, params, attachments, "Domain", basepath);
	hasValue |= m_Directory.unmarshall(ctx, params, attachments, "Directory", basepath);
	hasValue |= m_Type.unmarshall(ctx, params, attachments, "Type", basepath);
	hasValue |= m_Available.unmarshall(ctx, params, attachments, "Available", basepath);
	hasValue |= m_OS.unmarshall(ctx, params, attachments, "OS", basepath);
	hasValue |= m_Path.unmarshall(ctx, params, attachments, "Path", basepath);
	hasValue |= m_Port.unmarshall(ctx, params, attachments, "Port", basepath);
	hasValue |= m_ProcessNumber.unmarshall(ctx, params, attachments, "ProcessNumber", basepath);
	return hasValue;
}

const char * CTpMachine::getName() { return m_Name.query();}
const char * CTpMachine::getNetaddress() { return m_Netaddress.query();}
const char * CTpMachine::getConfigNetaddress() { return m_ConfigNetaddress.query();}
const char * CTpMachine::getDomain() { return m_Domain.query();}
const char * CTpMachine::getDirectory() { return m_Directory.query();}
const char * CTpMachine::getType() { return m_Type.query();}
const char * CTpMachine::getAvailable() { return m_Available.query();}
int CTpMachine::getOS() { return m_OS;}
const char * CTpMachine::getPath() { return m_Path.query();}
int CTpMachine::getPort() { return m_Port;}
int CTpMachine::getProcessNumber() { return m_ProcessNumber;}
void CTpMachine::setName(const char * val){ m_Name.set(val); }
void CTpMachine::setNetaddress(const char * val){ m_Netaddress.set(val); }
void CTpMachine::setConfigNetaddress(const char * val){ m_ConfigNetaddress.set(val); }
void CTpMachine::setDomain(const char * val){ m_Domain.set(val); }
void CTpMachine::setDirectory(const char * val){ m_Directory.set(val); }
void CTpMachine::setType(const char * val){ m_Type.set(val); }
void CTpMachine::setAvailable(const char * val){ m_Available.set(val); }
void CTpMachine::setOS(int val){ m_OS=val; }
void CTpMachine::setPath(const char * val){ m_Path.set(val); }
void CTpMachine::setPort(int val){ m_Port=val; }
void CTpMachine::setProcessNumber(int val){ m_ProcessNumber=val; }
extern "C"  IEspTpMachine *createTpMachine(const char *serv, const char *msgname){return ((IEspTpMachine *)new CTpMachine(serv /*, msgname*/));}
extern "C"  IClientTpMachine *createClientTpMachine(const char *serv, const char *msgname){return ((IClientTpMachine *)new CTpMachine(serv /*, msgname*/));}

//=======================================================
// class CTpCluster Implementation
//=======================================================

CTpCluster::CTpCluster(const char *serviceName, IRpcMessageBinding *init)
	: m_Type(nilIgnore),m_Name(nilIgnore),m_QueueName(nilIgnore),m_Build(nilIgnore),m_Directory(nilIgnore),m_LogDirectory(nilIgnore),m_Desc(nilIgnore),m_Prefix(nilIgnore),m_Path(nilIgnore),m_DataModel(nilIgnore),m_OS(nilIgnore),m_HasThorSpareProcess(nilIgnore),m_TpMachines(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("TpCluster");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CTpCluster::CTpCluster(const char *serviceName, const char *bc)
	: m_Type(nilIgnore),m_Name(nilIgnore),m_QueueName(nilIgnore),m_Build(nilIgnore),m_Directory(nilIgnore),m_LogDirectory(nilIgnore),m_Desc(nilIgnore),m_Prefix(nilIgnore),m_Path(nilIgnore),m_DataModel(nilIgnore),m_OS(nilIgnore),m_HasThorSpareProcess(nilIgnore),m_TpMachines(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("TpCluster");
}

StringBuffer &CTpCluster::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:complexType name=\"%s\">\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Type\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Name\" type=\"xsd:string\"/>\n");
		if (!context.suppressed("TpCluster","QueueName")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"QueueName\" type=\"xsd:string\"/>\n");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Build\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Directory\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"LogDirectory\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Desc\" type=\"xsd:string\"/>\n");
		if (!context.suppressed("TpCluster","Prefix")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"Prefix\" type=\"xsd:string\"/>\n");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Path\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"DataModel\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"OS\" type=\"xsd:int\"/>\n");
		if (!context.suppressed("TpCluster","HasThorSpareProcess")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"HasThorSpareProcess\" type=\"xsd:boolean\"/>\n");
		}
		if (!context.suppressed("TpCluster","TpMachines")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"TpMachines\" type=\"tns:ArrayOfTpMachine\"/>\n");
		}
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType>\n");
		}
	}
	if (!(flags & 0x10)  || (flags & 0x100))
	{
		if (!context.suppressed("TpCluster","TpMachines"))
			CTpMachine::getXsdDefinition(context, request, schema, added);
	}
	if (added.getValue("TpMachine") && added.getValue("ArrayOfTpMachine")==NULL) {
		schema.append("<xsd:complexType name=\"ArrayOfTpMachine\">\n");
		schema.append("<xsd:sequence>\n");
		schema.append("<xsd:element minOccurs=\"0\" maxOccurs=\"unbounded\" name=\"TpMachine\" type=\"tns:TpMachine\"/>\n");
		schema.append("</xsd:sequence>\n");
		schema.append("</xsd:complexType>\n");
		added.setValue("ArrayOfTpMachine",1);
	}
	return schema;
}

void CTpCluster::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CTpCluster::getMapInfo(IMapInfo& info, BoolHash& added)
{
	info.addMinVersion("TpCluster","QueueName",1.03);
	info.addMaxVersion("TpCluster","Prefix",1.16);
	info.addMinVersion("TpCluster","HasThorSpareProcess",1.15);
	info.addMinVersion("TpCluster","TpMachines",1.12);
	if (!added.getValue("TpMachine"))
	{
		added.setValue("TpMachine",1);
		CTpMachine::getMapInfo(info,added);
	}
}

StringBuffer &CTpCluster::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Type");
	form.appendf("  <tr><td><b>Type: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Name");
	form.appendf("  <tr><td><b>Name: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (!context.suppressed("TpCluster","QueueName")) {
		extfix.clear();
		if (prefix && *prefix)
			extfix.append(prefix).append(".");
		extfix.append("QueueName");
		form.appendf("  <tr><td><b>QueueName: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
		form.append("</td></tr>\n");
	}
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Build");
	form.appendf("  <tr><td><b>Build: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Directory");
	form.appendf("  <tr><td><b>Directory: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("LogDirectory");
	form.appendf("  <tr><td><b>LogDirectory: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Desc");
	form.appendf("  <tr><td><b>Desc: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (!context.suppressed("TpCluster","Prefix")) {
		extfix.clear();
		if (prefix && *prefix)
			extfix.append(prefix).append(".");
		extfix.append("Prefix");
		form.appendf("  <tr><td><b>Prefix: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
		form.append("</td></tr>\n");
	}
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Path");
	form.appendf("  <tr><td><b>Path: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("DataModel");
	form.appendf("  <tr><td><b>DataModel: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix) extfix.append(prefix).append(".");
		extfix.append("OS");
	form.appendf("  <tr><td><b>OS: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
	form.append("</td></tr>\n");
	if (!context.suppressed("TpCluster","HasThorSpareProcess")) {
		extfix.clear();
		if (prefix && *prefix)
			extfix.append(prefix).append(".");
		extfix.append("HasThorSpareProcess");
		
	form.appendf("  <tr><td><b>HasThorSpareProcess? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	}
	if (!context.suppressed("TpCluster","TpMachines")) {
		extfix.clear();
		if (prefix && *prefix)
			extfix.append(prefix).append(".");
		extfix.append("TpMachines");
		form.appendf("<tr><td><b>TpMachines: </b></td><td>");
		form.appendf("<table><tr><td><textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea></td>", extfix.str());
		form.append("</tr></table>");
		form.append("</td></tr>");
	}
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CTpCluster::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CTpCluster::serialize(IRpcMessage& rpc_resp)
{
	IEspContext* ctx = rpc_resp.queryContext();
	double clientVer= ctx ? ctx->getClientVersion() : -1; /* no context gets everything */
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_Type.marshall(rpc_resp, "Type", "", "", "");
	m_Name.marshall(rpc_resp, "Name", "", "", "");
	if ((clientVer==-1.0 || clientVer>=1.03))
		m_QueueName.marshall(rpc_resp, "QueueName", "", "", "");
	m_Build.marshall(rpc_resp, "Build", "", "", "");
	m_Directory.marshall(rpc_resp, "Directory", "", "", "");
	m_LogDirectory.marshall(rpc_resp, "LogDirectory", "", "", "");
	m_Desc.marshall(rpc_resp, "Desc", "", "", "");
	if ((clientVer==-1.0 || clientVer<=1.16))
		m_Prefix.marshall(rpc_resp, "Prefix", "", "", "");
	m_Path.marshall(rpc_resp, "Path", "", "", "");
	m_DataModel.marshall(rpc_resp, "DataModel", "", "", "");
	m_OS.marshall(rpc_resp, "OS", "", "", "");
	if ((clientVer==-1.0 || clientVer>=1.15))
		m_HasThorSpareProcess.marshall(rpc_resp, "HasThorSpareProcess", "", "", "");
	if ((clientVer==-1.0 || clientVer>=1.12))
		m_TpMachines.marshall(rpc_resp, "TpMachines", "TpMachine");
}


void CTpCluster::copy(CTpCluster &from)
{
	m_Type.copy(from.m_Type);
	m_Name.copy(from.m_Name);
	m_QueueName.copy(from.m_QueueName);
	m_Build.copy(from.m_Build);
	m_Directory.copy(from.m_Directory);
	m_LogDirectory.copy(from.m_LogDirectory);
	m_Desc.copy(from.m_Desc);
	m_Prefix.copy(from.m_Prefix);
	m_Path.copy(from.m_Path);
	m_DataModel.copy(from.m_DataModel);
	m_OS.copy(from.m_OS);
	m_HasThorSpareProcess.copy(from.m_HasThorSpareProcess);
	m_TpMachines.copy(from.m_TpMachines);
}


void CTpCluster::copy(IConstTpCluster &ifrom)
{
	setType(ifrom.getType());
	setName(ifrom.getName());
	setQueueName(ifrom.getQueueName());
	setBuild(ifrom.getBuild());
	setDirectory(ifrom.getDirectory());
	setLogDirectory(ifrom.getLogDirectory());
	setDesc(ifrom.getDesc());
	setPrefix(ifrom.getPrefix());
	setPath(ifrom.getPath());
	setDataModel(ifrom.getDataModel());
	setOS(ifrom.getOS());
	setHasThorSpareProcess(ifrom.getHasThorSpareProcess());
	setTpMachines(ifrom.getTpMachines());
}


void CTpCluster::getAttributes(IProperties &attributes)
{
}


void CTpCluster::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	double clientVer = ctx ? ctx->getClientVersion() : -1;
	m_Type.toStr(ctx, buffer, "Type", "", true, "", "");
	m_Name.toStr(ctx, buffer, "Name", "", true, "", "");
	if ((clientVer==-1.0 || clientVer>=1.03))
		m_QueueName.toStr(ctx, buffer, "QueueName", "", true, "", "");
	m_Build.toStr(ctx, buffer, "Build", "", true, "", "");
	m_Directory.toStr(ctx, buffer, "Directory", "", true, "", "");
	m_LogDirectory.toStr(ctx, buffer, "LogDirectory", "", true, "", "");
	m_Desc.toStr(ctx, buffer, "Desc", "", true, "", "");
	if ((clientVer==-1.0 || clientVer<=1.16))
		m_Prefix.toStr(ctx, buffer, "Prefix", "", true, "", "");
	m_Path.toStr(ctx, buffer, "Path", "", true, "", "");
	m_DataModel.toStr(ctx, buffer, "DataModel", "", true, "", "");
	m_OS.toStr(ctx, buffer, "OS", "", true, "", "");
	if ((clientVer==-1.0 || clientVer>=1.15))
		m_HasThorSpareProcess.toStr(ctx, buffer, "HasThorSpareProcess", "", true, "", "");
	if ((clientVer==-1.0 || clientVer>=1.12))
		m_TpMachines.toStr(ctx, buffer, "TpMachines", "TpMachine");
}


void CTpCluster::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CTpCluster::serializer(IEspContext* ctx, IConstTpCluster &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<TpCluster>");
	double clientVer = ctx ? ctx->getClientVersion() : -1;
	// field Type
	{
		const char* s = src.getType();
		if (s && *s)
		{
			buffer.append("<Type>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Type>");
		}
	}
	// field Name
	{
		const char* s = src.getName();
		if (s && *s)
		{
			buffer.append("<Name>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Name>");
		}
	}
	// field QueueName
	if ((clientVer==-1.0 || clientVer>=1.03))
	{
		const char* s = src.getQueueName();
		if (s && *s)
		{
			buffer.append("<QueueName>");
			encodeUtf8XML(s,buffer);
			buffer.append("</QueueName>");
		}
	}
	// field Build
	{
		const char* s = src.getBuild();
		if (s && *s)
		{
			buffer.append("<Build>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Build>");
		}
	}
	// field Directory
	{
		const char* s = src.getDirectory();
		if (s && *s)
		{
			buffer.append("<Directory>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Directory>");
		}
	}
	// field LogDirectory
	{
		const char* s = src.getLogDirectory();
		if (s && *s)
		{
			buffer.append("<LogDirectory>");
			encodeUtf8XML(s,buffer);
			buffer.append("</LogDirectory>");
		}
	}
	// field Desc
	{
		const char* s = src.getDesc();
		if (s && *s)
		{
			buffer.append("<Desc>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Desc>");
		}
	}
	// field Prefix
	if ((clientVer==-1.0 || clientVer<=1.16))
	{
		const char* s = src.getPrefix();
		if (s && *s)
		{
			buffer.append("<Prefix>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Prefix>");
		}
	}
	// field Path
	{
		const char* s = src.getPath();
		if (s && *s)
		{
			buffer.append("<Path>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Path>");
		}
	}
	// field DataModel
	{
		const char* s = src.getDataModel();
		if (s && *s)
		{
			buffer.append("<DataModel>");
			encodeUtf8XML(s,buffer);
			buffer.append("</DataModel>");
		}
	}
	// field OS
	{
		int n = src.getOS();
		if (n)
			buffer.appendf("<OS>%d</OS>", n);
	}
	// field HasThorSpareProcess
	if ((clientVer==-1.0 || clientVer>=1.15))
	{
		bool b = src.getHasThorSpareProcess();
		if (b)
			buffer.appendf("<HasThorSpareProcess>1</HasThorSpareProcess>");
	}
	// field TpMachines
	if ((clientVer==-1.0 || clientVer>=1.12))
	{
		IArrayOf<IConstTpMachine>& v = src.getTpMachines();
		int size = v.length();
		if (size>0)
			buffer.append("<TpMachines>");
		for (int i=0;i<size;i++)
		{
			buffer.append("<Item>");
			CTpMachine::serializer(ctx,v.item(i),buffer,false);
			buffer.append("</Item>");
		}
		if (size>0)
			buffer.append("</TpMachines>");
	}
	if (keepRootTag)
		buffer.append("</TpCluster>");
}

bool CTpCluster::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_Type.unmarshall(rpc_request, "Type", basepath);
	hasValue |= m_Name.unmarshall(rpc_request, "Name", basepath);
	hasValue |= m_QueueName.unmarshall(rpc_request, "QueueName", basepath);
	hasValue |= m_Build.unmarshall(rpc_request, "Build", basepath);
	hasValue |= m_Directory.unmarshall(rpc_request, "Directory", basepath);
	hasValue |= m_LogDirectory.unmarshall(rpc_request, "LogDirectory", basepath);
	hasValue |= m_Desc.unmarshall(rpc_request, "Desc", basepath);
	hasValue |= m_Prefix.unmarshall(rpc_request, "Prefix", basepath);
	hasValue |= m_Path.unmarshall(rpc_request, "Path", basepath);
	hasValue |= m_DataModel.unmarshall(rpc_request, "DataModel", basepath);
	hasValue |= m_OS.unmarshall(rpc_request, "OS", basepath);
	hasValue |= m_HasThorSpareProcess.unmarshall(rpc_request, "HasThorSpareProcess", basepath);
	hasValue |= m_TpMachines.unmarshall(rpc_request, "TpMachines", basepath);
	return hasValue;
}

bool CTpCluster::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Type.unmarshall(ctx, soapval, "Type");
	hasValue |= m_Name.unmarshall(ctx, soapval, "Name");
	hasValue |= m_QueueName.unmarshall(ctx, soapval, "QueueName");
	hasValue |= m_Build.unmarshall(ctx, soapval, "Build");
	hasValue |= m_Directory.unmarshall(ctx, soapval, "Directory");
	hasValue |= m_LogDirectory.unmarshall(ctx, soapval, "LogDirectory");
	hasValue |= m_Desc.unmarshall(ctx, soapval, "Desc");
	hasValue |= m_Prefix.unmarshall(ctx, soapval, "Prefix");
	hasValue |= m_Path.unmarshall(ctx, soapval, "Path");
	hasValue |= m_DataModel.unmarshall(ctx, soapval, "DataModel");
	hasValue |= m_OS.unmarshall(ctx, soapval, "OS");
	hasValue |= m_HasThorSpareProcess.unmarshall(ctx, soapval, "HasThorSpareProcess");
	hasValue |= m_TpMachines.unmarshall(ctx, soapval, "TpMachines");
	return hasValue;
}

bool CTpCluster::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Type.unmarshall(ctx, params, attachments, "Type", basepath);
	hasValue |= m_Name.unmarshall(ctx, params, attachments, "Name", basepath);
	hasValue |= m_QueueName.unmarshall(ctx, params, attachments, "QueueName", basepath);
	hasValue |= m_Build.unmarshall(ctx, params, attachments, "Build", basepath);
	hasValue |= m_Directory.unmarshall(ctx, params, attachments, "Directory", basepath);
	hasValue |= m_LogDirectory.unmarshall(ctx, params, attachments, "LogDirectory", basepath);
	hasValue |= m_Desc.unmarshall(ctx, params, attachments, "Desc", basepath);
	hasValue |= m_Prefix.unmarshall(ctx, params, attachments, "Prefix", basepath);
	hasValue |= m_Path.unmarshall(ctx, params, attachments, "Path", basepath);
	hasValue |= m_DataModel.unmarshall(ctx, params, attachments, "DataModel", basepath);
	hasValue |= m_OS.unmarshall(ctx, params, attachments, "OS", basepath);
	hasValue |= m_HasThorSpareProcess.unmarshall(ctx, params, attachments, "HasThorSpareProcess", basepath);
	hasValue |= m_TpMachines.unmarshall(ctx, params, attachments, "TpMachines", basepath);
	return hasValue;
}

const char * CTpCluster::getType() { return m_Type.query();}
const char * CTpCluster::getName() { return m_Name.query();}
const char * CTpCluster::getQueueName() { return m_QueueName.query();}
const char * CTpCluster::getBuild() { return m_Build.query();}
const char * CTpCluster::getDirectory() { return m_Directory.query();}
const char * CTpCluster::getLogDirectory() { return m_LogDirectory.query();}
const char * CTpCluster::getDesc() { return m_Desc.query();}
const char * CTpCluster::getPrefix() { return m_Prefix.query();}
const char * CTpCluster::getPath() { return m_Path.query();}
const char * CTpCluster::getDataModel() { return m_DataModel.query();}
int CTpCluster::getOS() { return m_OS;}
bool CTpCluster::getHasThorSpareProcess() { return m_HasThorSpareProcess;}
IArrayOf<IConstTpMachine> & CTpCluster::getTpMachines() { return (IArrayOf<IConstTpMachine> &) m_TpMachines; }
void CTpCluster::setType(const char * val){ m_Type.set(val); }
void CTpCluster::setName(const char * val){ m_Name.set(val); }
void CTpCluster::setQueueName(const char * val){ m_QueueName.set(val); }
void CTpCluster::setBuild(const char * val){ m_Build.set(val); }
void CTpCluster::setDirectory(const char * val){ m_Directory.set(val); }
void CTpCluster::setLogDirectory(const char * val){ m_LogDirectory.set(val); }
void CTpCluster::setDesc(const char * val){ m_Desc.set(val); }
void CTpCluster::setPrefix(const char * val){ m_Prefix.set(val); }
void CTpCluster::setPath(const char * val){ m_Path.set(val); }
void CTpCluster::setDataModel(const char * val){ m_DataModel.set(val); }
void CTpCluster::setOS(int val){ m_OS=val; }
void CTpCluster::setHasThorSpareProcess(bool val){ m_HasThorSpareProcess=val; }
void CTpCluster::setTpMachines(IArrayOf<IEspTpMachine> &val)
{
	m_TpMachines->kill();
	IArrayOf<IConstTpMachine> &target = m_TpMachines.getValue();
	ForEachItemIn(idx, val)
	{
		IEspTpMachine &item = (val).item(idx);
		item.Link();
		target.append(item);
	}
}
void CTpCluster::setTpMachines(IArrayOf<IConstTpMachine> &val)
{
	m_TpMachines->kill();
	IArrayOf<IConstTpMachine> &target = m_TpMachines.getValue();
	ForEachItemIn(idx, val)
	{
		IConstTpMachine &item = val.item(idx);
		item.Link();
		target.append(item);
	}
}
extern "C"  IEspTpCluster *createTpCluster(const char *serv, const char *msgname){return ((IEspTpCluster *)new CTpCluster(serv /*, msgname*/));}
extern "C"  IClientTpCluster *createClientTpCluster(const char *serv, const char *msgname){return ((IClientTpCluster *)new CTpCluster(serv /*, msgname*/));}

//=======================================================
// class CTpLogicalCluster Implementation
//=======================================================

CTpLogicalCluster::CTpLogicalCluster(const char *serviceName, IRpcMessageBinding *init)
	: m_Name(nilIgnore),m_Queue(nilIgnore),m_LanguageVersion(nilIgnore),m_Process(nilIgnore),m_Type(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("TpLogicalCluster");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CTpLogicalCluster::CTpLogicalCluster(const char *serviceName, const char *bc)
	: m_Name(nilIgnore),m_Queue(nilIgnore),m_LanguageVersion(nilIgnore),m_Process(nilIgnore),m_Type(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("TpLogicalCluster");
}

StringBuffer &CTpLogicalCluster::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:complexType name=\"%s\">\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Name\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Queue\" type=\"xsd:string\"/>\n");
		if (!context.suppressed("TpLogicalCluster","LanguageVersion")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"LanguageVersion\" type=\"xsd:string\"/>\n");
		}
		if (!context.suppressed("TpLogicalCluster","Process")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"Process\" type=\"xsd:string\"/>\n");
		}
		if (!context.suppressed("TpLogicalCluster","Type")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"Type\" type=\"xsd:string\"/>\n");
		}
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType>\n");
		}
	}
	return schema;
}

void CTpLogicalCluster::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CTpLogicalCluster::getMapInfo(IMapInfo& info, BoolHash& added)
{
	info.addMinVersion("TpLogicalCluster","LanguageVersion",1.14);
	info.addMinVersion("TpLogicalCluster","Process",1.11);
	info.addMinVersion("TpLogicalCluster","Type",1.22);
}

StringBuffer &CTpLogicalCluster::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Name");
	form.appendf("  <tr><td><b>Name: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Queue");
	form.appendf("  <tr><td><b>Queue: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (!context.suppressed("TpLogicalCluster","LanguageVersion")) {
		extfix.clear();
		if (prefix && *prefix)
			extfix.append(prefix).append(".");
		extfix.append("LanguageVersion");
		form.appendf("  <tr><td><b>LanguageVersion: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
		form.append("</td></tr>\n");
	}
	if (!context.suppressed("TpLogicalCluster","Process")) {
		extfix.clear();
		if (prefix && *prefix)
			extfix.append(prefix).append(".");
		extfix.append("Process");
		form.appendf("  <tr><td><b>Process: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
		form.append("</td></tr>\n");
	}
	if (!context.suppressed("TpLogicalCluster","Type")) {
		extfix.clear();
		if (prefix && *prefix)
			extfix.append(prefix).append(".");
		extfix.append("Type");
		form.appendf("  <tr><td><b>Type: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
		form.append("</td></tr>\n");
	}
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CTpLogicalCluster::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CTpLogicalCluster::serialize(IRpcMessage& rpc_resp)
{
	IEspContext* ctx = rpc_resp.queryContext();
	double clientVer= ctx ? ctx->getClientVersion() : -1; /* no context gets everything */
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_Name.marshall(rpc_resp, "Name", "", "", "");
	m_Queue.marshall(rpc_resp, "Queue", "", "", "");
	if ((clientVer==-1.0 || clientVer>=1.14))
		m_LanguageVersion.marshall(rpc_resp, "LanguageVersion", "", "", "");
	if ((clientVer==-1.0 || clientVer>=1.11))
		m_Process.marshall(rpc_resp, "Process", "", "", "");
	if ((clientVer==-1.0 || clientVer>=1.22))
		m_Type.marshall(rpc_resp, "Type", "", "", "");
}


void CTpLogicalCluster::copy(CTpLogicalCluster &from)
{
	m_Name.copy(from.m_Name);
	m_Queue.copy(from.m_Queue);
	m_LanguageVersion.copy(from.m_LanguageVersion);
	m_Process.copy(from.m_Process);
	m_Type.copy(from.m_Type);
}


void CTpLogicalCluster::copy(IConstTpLogicalCluster &ifrom)
{
	setName(ifrom.getName());
	setQueue(ifrom.getQueue());
	setLanguageVersion(ifrom.getLanguageVersion());
	setProcess(ifrom.getProcess());
	setType(ifrom.getType());
}


void CTpLogicalCluster::getAttributes(IProperties &attributes)
{
}


void CTpLogicalCluster::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	double clientVer = ctx ? ctx->getClientVersion() : -1;
	m_Name.toStr(ctx, buffer, "Name", "", true, "", "");
	m_Queue.toStr(ctx, buffer, "Queue", "", true, "", "");
	if ((clientVer==-1.0 || clientVer>=1.14))
		m_LanguageVersion.toStr(ctx, buffer, "LanguageVersion", "", true, "", "");
	if ((clientVer==-1.0 || clientVer>=1.11))
		m_Process.toStr(ctx, buffer, "Process", "", true, "", "");
	if ((clientVer==-1.0 || clientVer>=1.22))
		m_Type.toStr(ctx, buffer, "Type", "", true, "", "");
}


void CTpLogicalCluster::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CTpLogicalCluster::serializer(IEspContext* ctx, IConstTpLogicalCluster &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<TpLogicalCluster>");
	double clientVer = ctx ? ctx->getClientVersion() : -1;
	// field Name
	{
		const char* s = src.getName();
		if (s && *s)
		{
			buffer.append("<Name>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Name>");
		}
	}
	// field Queue
	{
		const char* s = src.getQueue();
		if (s && *s)
		{
			buffer.append("<Queue>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Queue>");
		}
	}
	// field LanguageVersion
	if ((clientVer==-1.0 || clientVer>=1.14))
	{
		const char* s = src.getLanguageVersion();
		if (s && *s)
		{
			buffer.append("<LanguageVersion>");
			encodeUtf8XML(s,buffer);
			buffer.append("</LanguageVersion>");
		}
	}
	// field Process
	if ((clientVer==-1.0 || clientVer>=1.11))
	{
		const char* s = src.getProcess();
		if (s && *s)
		{
			buffer.append("<Process>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Process>");
		}
	}
	// field Type
	if ((clientVer==-1.0 || clientVer>=1.22))
	{
		const char* s = src.getType();
		if (s && *s)
		{
			buffer.append("<Type>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Type>");
		}
	}
	if (keepRootTag)
		buffer.append("</TpLogicalCluster>");
}

bool CTpLogicalCluster::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_Name.unmarshall(rpc_request, "Name", basepath);
	hasValue |= m_Queue.unmarshall(rpc_request, "Queue", basepath);
	hasValue |= m_LanguageVersion.unmarshall(rpc_request, "LanguageVersion", basepath);
	hasValue |= m_Process.unmarshall(rpc_request, "Process", basepath);
	hasValue |= m_Type.unmarshall(rpc_request, "Type", basepath);
	return hasValue;
}

bool CTpLogicalCluster::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Name.unmarshall(ctx, soapval, "Name");
	hasValue |= m_Queue.unmarshall(ctx, soapval, "Queue");
	hasValue |= m_LanguageVersion.unmarshall(ctx, soapval, "LanguageVersion");
	hasValue |= m_Process.unmarshall(ctx, soapval, "Process");
	hasValue |= m_Type.unmarshall(ctx, soapval, "Type");
	return hasValue;
}

bool CTpLogicalCluster::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Name.unmarshall(ctx, params, attachments, "Name", basepath);
	hasValue |= m_Queue.unmarshall(ctx, params, attachments, "Queue", basepath);
	hasValue |= m_LanguageVersion.unmarshall(ctx, params, attachments, "LanguageVersion", basepath);
	hasValue |= m_Process.unmarshall(ctx, params, attachments, "Process", basepath);
	hasValue |= m_Type.unmarshall(ctx, params, attachments, "Type", basepath);
	return hasValue;
}

const char * CTpLogicalCluster::getName() { return m_Name.query();}
const char * CTpLogicalCluster::getQueue() { return m_Queue.query();}
const char * CTpLogicalCluster::getLanguageVersion() { return m_LanguageVersion.query();}
const char * CTpLogicalCluster::getProcess() { return m_Process.query();}
const char * CTpLogicalCluster::getType() { return m_Type.query();}
void CTpLogicalCluster::setName(const char * val){ m_Name.set(val); }
void CTpLogicalCluster::setQueue(const char * val){ m_Queue.set(val); }
void CTpLogicalCluster::setLanguageVersion(const char * val){ m_LanguageVersion.set(val); }
void CTpLogicalCluster::setProcess(const char * val){ m_Process.set(val); }
void CTpLogicalCluster::setType(const char * val){ m_Type.set(val); }
extern "C"  IEspTpLogicalCluster *createTpLogicalCluster(const char *serv, const char *msgname){return ((IEspTpLogicalCluster *)new CTpLogicalCluster(serv /*, msgname*/));}
extern "C"  IClientTpLogicalCluster *createClientTpLogicalCluster(const char *serv, const char *msgname){return ((IClientTpLogicalCluster *)new CTpLogicalCluster(serv /*, msgname*/));}

//=======================================================
// class CTpGroup Implementation
//=======================================================

CTpGroup::CTpGroup(const char *serviceName, IRpcMessageBinding *init)
	: m_Name(nilRemove),m_Kind(nilRemove),m_ReplicateOutputs(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("TpGroup");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CTpGroup::CTpGroup(const char *serviceName, const char *bc)
	: m_Name(nilRemove),m_Kind(nilRemove),m_ReplicateOutputs(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("TpGroup");
}

StringBuffer &CTpGroup::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:complexType name=\"%s\">\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Name\" type=\"xsd:string\"/>\n");
		if (!context.suppressed("TpGroup","Kind")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"Kind\" type=\"xsd:string\"/>\n");
		}
		if (!context.suppressed("TpGroup","ReplicateOutputs")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"ReplicateOutputs\" type=\"xsd:boolean\"/>\n");
		}
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType>\n");
		}
	}
	return schema;
}

void CTpGroup::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CTpGroup::getMapInfo(IMapInfo& info, BoolHash& added)
{
	info.addMinVersion("TpGroup","Kind",1.21);
	info.addMinVersion("TpGroup","ReplicateOutputs",1.21);
}

StringBuffer &CTpGroup::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Name");
	form.appendf("  <tr><td><b>Name: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (!context.suppressed("TpGroup","Kind")) {
		extfix.clear();
		if (prefix && *prefix)
			extfix.append(prefix).append(".");
		extfix.append("Kind");
		form.appendf("  <tr><td><b>Kind: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
		form.append("</td></tr>\n");
	}
	if (!context.suppressed("TpGroup","ReplicateOutputs")) {
		extfix.clear();
		if (prefix && *prefix)
			extfix.append(prefix).append(".");
		extfix.append("ReplicateOutputs");
		
	form.appendf("  <tr><td><b>ReplicateOutputs? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	}
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CTpGroup::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CTpGroup::serialize(IRpcMessage& rpc_resp)
{
	IEspContext* ctx = rpc_resp.queryContext();
	double clientVer= ctx ? ctx->getClientVersion() : -1; /* no context gets everything */
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_Name.marshall(rpc_resp, "Name", "", "", "");
	if ((clientVer==-1.0 || clientVer>=1.21))
		m_Kind.marshall(rpc_resp, "Kind", "", "", "");
	if ((clientVer==-1.0 || clientVer>=1.21))
		m_ReplicateOutputs.marshall(rpc_resp, "ReplicateOutputs", "", "", "");
}


void CTpGroup::copy(CTpGroup &from)
{
	m_Name.copy(from.m_Name);
	m_Kind.copy(from.m_Kind);
	m_ReplicateOutputs.copy(from.m_ReplicateOutputs);
}


void CTpGroup::copy(IConstTpGroup &ifrom)
{
	setName(ifrom.getName());
	setKind(ifrom.getKind());
	setReplicateOutputs(ifrom.getReplicateOutputs());
}


void CTpGroup::getAttributes(IProperties &attributes)
{
}


void CTpGroup::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	double clientVer = ctx ? ctx->getClientVersion() : -1;
	m_Name.toStr(ctx, buffer, "Name", "", true, "", "");
	if ((clientVer==-1.0 || clientVer>=1.21))
		m_Kind.toStr(ctx, buffer, "Kind", "", true, "", "");
	if ((clientVer==-1.0 || clientVer>=1.21))
		m_ReplicateOutputs.toStr(ctx, buffer, "ReplicateOutputs", "", true, "", "");
}


void CTpGroup::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CTpGroup::serializer(IEspContext* ctx, IConstTpGroup &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<TpGroup>");
	double clientVer = ctx ? ctx->getClientVersion() : -1;
	// field Name
	{
		const char* s = src.getName();
		if (s && *s)
		{
			buffer.append("<Name>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Name>");
		}
	}
	// field Kind
	if ((clientVer==-1.0 || clientVer>=1.21))
	{
		const char* s = src.getKind();
		if (s && *s)
		{
			buffer.append("<Kind>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Kind>");
		}
	}
	// field ReplicateOutputs
	if ((clientVer==-1.0 || clientVer>=1.21))
	{
		bool b = src.getReplicateOutputs();
		if (b)
			buffer.appendf("<ReplicateOutputs>1</ReplicateOutputs>");
	}
	if (keepRootTag)
		buffer.append("</TpGroup>");
}

bool CTpGroup::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_Name.unmarshall(rpc_request, "Name", basepath);
	hasValue |= m_Kind.unmarshall(rpc_request, "Kind", basepath);
	hasValue |= m_ReplicateOutputs.unmarshall(rpc_request, "ReplicateOutputs", basepath);
	return hasValue;
}

bool CTpGroup::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Name.unmarshall(ctx, soapval, "Name");
	hasValue |= m_Kind.unmarshall(ctx, soapval, "Kind");
	hasValue |= m_ReplicateOutputs.unmarshall(ctx, soapval, "ReplicateOutputs");
	return hasValue;
}

bool CTpGroup::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Name.unmarshall(ctx, params, attachments, "Name", basepath);
	hasValue |= m_Kind.unmarshall(ctx, params, attachments, "Kind", basepath);
	hasValue |= m_ReplicateOutputs.unmarshall(ctx, params, attachments, "ReplicateOutputs", basepath);
	return hasValue;
}

const char * CTpGroup::getName() { return m_Name.query();}
const char * CTpGroup::getKind() { return m_Kind.query();}
bool CTpGroup::getReplicateOutputs_isNull(){return m_ReplicateOutputs.is_nil();}
bool CTpGroup::getReplicateOutputs() { return m_ReplicateOutputs;}
void CTpGroup::setName(const char * val){ m_Name.set(val); }
void CTpGroup::setKind(const char * val){ m_Kind.set(val); }
void CTpGroup::setReplicateOutputs_null(){ m_ReplicateOutputs.Nil(); }void CTpGroup::setReplicateOutputs(bool val){ m_ReplicateOutputs=val; }
extern "C"  IEspTpGroup *createTpGroup(const char *serv, const char *msgname){return ((IEspTpGroup *)new CTpGroup(serv /*, msgname*/));}
extern "C"  IClientTpGroup *createClientTpGroup(const char *serv, const char *msgname){return ((IClientTpGroup *)new CTpGroup(serv /*, msgname*/));}

//=======================================================
// class CTpDali Implementation
//=======================================================

CTpDali::CTpDali(const char *serviceName, IRpcMessageBinding *init)
	: m_Name(nilIgnore),m_Description(nilIgnore),m_Build(nilIgnore),m_BackupComputer(nilIgnore),m_BackupDirectory(nilIgnore),m_Type(nilIgnore),m_Path(nilIgnore),m_LogDirectory(nilIgnore),m_AuditLogDirectory(nilIgnore),m_TpMachines(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("TpDali");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CTpDali::CTpDali(const char *serviceName, const char *bc)
	: m_Name(nilIgnore),m_Description(nilIgnore),m_Build(nilIgnore),m_BackupComputer(nilIgnore),m_BackupDirectory(nilIgnore),m_Type(nilIgnore),m_Path(nilIgnore),m_LogDirectory(nilIgnore),m_AuditLogDirectory(nilIgnore),m_TpMachines(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("TpDali");
}

StringBuffer &CTpDali::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:complexType name=\"%s\">\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Name\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Description\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Build\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"BackupComputer\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"BackupDirectory\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Type\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Path\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"LogDirectory\" type=\"xsd:string\"/>\n");
		if (!context.suppressed("TpDali","AuditLogDirectory")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"AuditLogDirectory\" type=\"xsd:string\"/>\n");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"TpMachines\" type=\"tns:ArrayOfTpMachine\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType>\n");
		}
	}
	if (!(flags & 0x10)  || (flags & 0x100))
	{
		CTpMachine::getXsdDefinition(context, request, schema, added);
	}
	if (added.getValue("TpMachine") && added.getValue("ArrayOfTpMachine")==NULL) {
		schema.append("<xsd:complexType name=\"ArrayOfTpMachine\">\n");
		schema.append("<xsd:sequence>\n");
		schema.append("<xsd:element minOccurs=\"0\" maxOccurs=\"unbounded\" name=\"TpMachine\" type=\"tns:TpMachine\"/>\n");
		schema.append("</xsd:sequence>\n");
		schema.append("</xsd:complexType>\n");
		added.setValue("ArrayOfTpMachine",1);
	}
	return schema;
}

void CTpDali::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CTpDali::getMapInfo(IMapInfo& info, BoolHash& added)
{
	info.addMinVersion("TpDali","AuditLogDirectory",1.27);
	if (!added.getValue("TpMachine"))
	{
		added.setValue("TpMachine",1);
		CTpMachine::getMapInfo(info,added);
	}
}

StringBuffer &CTpDali::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Name");
	form.appendf("  <tr><td><b>Name: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Description");
	form.appendf("  <tr><td><b>Description: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Build");
	form.appendf("  <tr><td><b>Build: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("BackupComputer");
	form.appendf("  <tr><td><b>BackupComputer: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("BackupDirectory");
	form.appendf("  <tr><td><b>BackupDirectory: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Type");
	form.appendf("  <tr><td><b>Type: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Path");
	form.appendf("  <tr><td><b>Path: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("LogDirectory");
	form.appendf("  <tr><td><b>LogDirectory: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (!context.suppressed("TpDali","AuditLogDirectory")) {
		extfix.clear();
		if (prefix && *prefix)
			extfix.append(prefix).append(".");
		extfix.append("AuditLogDirectory");
		form.appendf("  <tr><td><b>AuditLogDirectory: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
		form.append("</td></tr>\n");
	}
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("TpMachines");
	form.appendf("<tr><td><b>TpMachines: </b></td><td>");
	form.appendf("<table><tr><td><textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea></td>", extfix.str());
	form.append("</tr></table>");
	form.append("</td></tr>");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CTpDali::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CTpDali::serialize(IRpcMessage& rpc_resp)
{
	IEspContext* ctx = rpc_resp.queryContext();
	double clientVer= ctx ? ctx->getClientVersion() : -1; /* no context gets everything */
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_Name.marshall(rpc_resp, "Name", "", "", "");
	m_Description.marshall(rpc_resp, "Description", "", "", "");
	m_Build.marshall(rpc_resp, "Build", "", "", "");
	m_BackupComputer.marshall(rpc_resp, "BackupComputer", "", "", "");
	m_BackupDirectory.marshall(rpc_resp, "BackupDirectory", "", "", "");
	m_Type.marshall(rpc_resp, "Type", "", "", "");
	m_Path.marshall(rpc_resp, "Path", "", "", "");
	m_LogDirectory.marshall(rpc_resp, "LogDirectory", "", "", "");
	if ((clientVer==-1.0 || clientVer>=1.27))
		m_AuditLogDirectory.marshall(rpc_resp, "AuditLogDirectory", "", "", "");
	m_TpMachines.marshall(rpc_resp, "TpMachines", "TpMachine");
}


void CTpDali::copy(CTpDali &from)
{
	m_Name.copy(from.m_Name);
	m_Description.copy(from.m_Description);
	m_Build.copy(from.m_Build);
	m_BackupComputer.copy(from.m_BackupComputer);
	m_BackupDirectory.copy(from.m_BackupDirectory);
	m_Type.copy(from.m_Type);
	m_Path.copy(from.m_Path);
	m_LogDirectory.copy(from.m_LogDirectory);
	m_AuditLogDirectory.copy(from.m_AuditLogDirectory);
	m_TpMachines.copy(from.m_TpMachines);
}


void CTpDali::copy(IConstTpDali &ifrom)
{
	setName(ifrom.getName());
	setDescription(ifrom.getDescription());
	setBuild(ifrom.getBuild());
	setBackupComputer(ifrom.getBackupComputer());
	setBackupDirectory(ifrom.getBackupDirectory());
	setType(ifrom.getType());
	setPath(ifrom.getPath());
	setLogDirectory(ifrom.getLogDirectory());
	setAuditLogDirectory(ifrom.getAuditLogDirectory());
	setTpMachines(ifrom.getTpMachines());
}


void CTpDali::getAttributes(IProperties &attributes)
{
}


void CTpDali::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	double clientVer = ctx ? ctx->getClientVersion() : -1;
	m_Name.toStr(ctx, buffer, "Name", "", true, "", "");
	m_Description.toStr(ctx, buffer, "Description", "", true, "", "");
	m_Build.toStr(ctx, buffer, "Build", "", true, "", "");
	m_BackupComputer.toStr(ctx, buffer, "BackupComputer", "", true, "", "");
	m_BackupDirectory.toStr(ctx, buffer, "BackupDirectory", "", true, "", "");
	m_Type.toStr(ctx, buffer, "Type", "", true, "", "");
	m_Path.toStr(ctx, buffer, "Path", "", true, "", "");
	m_LogDirectory.toStr(ctx, buffer, "LogDirectory", "", true, "", "");
	if ((clientVer==-1.0 || clientVer>=1.27))
		m_AuditLogDirectory.toStr(ctx, buffer, "AuditLogDirectory", "", true, "", "");
	m_TpMachines.toStr(ctx, buffer, "TpMachines", "TpMachine");
}


void CTpDali::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CTpDali::serializer(IEspContext* ctx, IConstTpDali &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<TpDali>");
	double clientVer = ctx ? ctx->getClientVersion() : -1;
	// field Name
	{
		const char* s = src.getName();
		if (s && *s)
		{
			buffer.append("<Name>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Name>");
		}
	}
	// field Description
	{
		const char* s = src.getDescription();
		if (s && *s)
		{
			buffer.append("<Description>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Description>");
		}
	}
	// field Build
	{
		const char* s = src.getBuild();
		if (s && *s)
		{
			buffer.append("<Build>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Build>");
		}
	}
	// field BackupComputer
	{
		const char* s = src.getBackupComputer();
		if (s && *s)
		{
			buffer.append("<BackupComputer>");
			encodeUtf8XML(s,buffer);
			buffer.append("</BackupComputer>");
		}
	}
	// field BackupDirectory
	{
		const char* s = src.getBackupDirectory();
		if (s && *s)
		{
			buffer.append("<BackupDirectory>");
			encodeUtf8XML(s,buffer);
			buffer.append("</BackupDirectory>");
		}
	}
	// field Type
	{
		const char* s = src.getType();
		if (s && *s)
		{
			buffer.append("<Type>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Type>");
		}
	}
	// field Path
	{
		const char* s = src.getPath();
		if (s && *s)
		{
			buffer.append("<Path>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Path>");
		}
	}
	// field LogDirectory
	{
		const char* s = src.getLogDirectory();
		if (s && *s)
		{
			buffer.append("<LogDirectory>");
			encodeUtf8XML(s,buffer);
			buffer.append("</LogDirectory>");
		}
	}
	// field AuditLogDirectory
	if ((clientVer==-1.0 || clientVer>=1.27))
	{
		const char* s = src.getAuditLogDirectory();
		if (s && *s)
		{
			buffer.append("<AuditLogDirectory>");
			encodeUtf8XML(s,buffer);
			buffer.append("</AuditLogDirectory>");
		}
	}
	// field TpMachines
	{
		IArrayOf<IConstTpMachine>& v = src.getTpMachines();
		int size = v.length();
		if (size>0)
			buffer.append("<TpMachines>");
		for (int i=0;i<size;i++)
		{
			buffer.append("<Item>");
			CTpMachine::serializer(ctx,v.item(i),buffer,false);
			buffer.append("</Item>");
		}
		if (size>0)
			buffer.append("</TpMachines>");
	}
	if (keepRootTag)
		buffer.append("</TpDali>");
}

bool CTpDali::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_Name.unmarshall(rpc_request, "Name", basepath);
	hasValue |= m_Description.unmarshall(rpc_request, "Description", basepath);
	hasValue |= m_Build.unmarshall(rpc_request, "Build", basepath);
	hasValue |= m_BackupComputer.unmarshall(rpc_request, "BackupComputer", basepath);
	hasValue |= m_BackupDirectory.unmarshall(rpc_request, "BackupDirectory", basepath);
	hasValue |= m_Type.unmarshall(rpc_request, "Type", basepath);
	hasValue |= m_Path.unmarshall(rpc_request, "Path", basepath);
	hasValue |= m_LogDirectory.unmarshall(rpc_request, "LogDirectory", basepath);
	hasValue |= m_AuditLogDirectory.unmarshall(rpc_request, "AuditLogDirectory", basepath);
	hasValue |= m_TpMachines.unmarshall(rpc_request, "TpMachines", basepath);
	return hasValue;
}

bool CTpDali::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Name.unmarshall(ctx, soapval, "Name");
	hasValue |= m_Description.unmarshall(ctx, soapval, "Description");
	hasValue |= m_Build.unmarshall(ctx, soapval, "Build");
	hasValue |= m_BackupComputer.unmarshall(ctx, soapval, "BackupComputer");
	hasValue |= m_BackupDirectory.unmarshall(ctx, soapval, "BackupDirectory");
	hasValue |= m_Type.unmarshall(ctx, soapval, "Type");
	hasValue |= m_Path.unmarshall(ctx, soapval, "Path");
	hasValue |= m_LogDirectory.unmarshall(ctx, soapval, "LogDirectory");
	hasValue |= m_AuditLogDirectory.unmarshall(ctx, soapval, "AuditLogDirectory");
	hasValue |= m_TpMachines.unmarshall(ctx, soapval, "TpMachines");
	return hasValue;
}

bool CTpDali::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Name.unmarshall(ctx, params, attachments, "Name", basepath);
	hasValue |= m_Description.unmarshall(ctx, params, attachments, "Description", basepath);
	hasValue |= m_Build.unmarshall(ctx, params, attachments, "Build", basepath);
	hasValue |= m_BackupComputer.unmarshall(ctx, params, attachments, "BackupComputer", basepath);
	hasValue |= m_BackupDirectory.unmarshall(ctx, params, attachments, "BackupDirectory", basepath);
	hasValue |= m_Type.unmarshall(ctx, params, attachments, "Type", basepath);
	hasValue |= m_Path.unmarshall(ctx, params, attachments, "Path", basepath);
	hasValue |= m_LogDirectory.unmarshall(ctx, params, attachments, "LogDirectory", basepath);
	hasValue |= m_AuditLogDirectory.unmarshall(ctx, params, attachments, "AuditLogDirectory", basepath);
	hasValue |= m_TpMachines.unmarshall(ctx, params, attachments, "TpMachines", basepath);
	return hasValue;
}

const char * CTpDali::getName() { return m_Name.query();}
const char * CTpDali::getDescription() { return m_Description.query();}
const char * CTpDali::getBuild() { return m_Build.query();}
const char * CTpDali::getBackupComputer() { return m_BackupComputer.query();}
const char * CTpDali::getBackupDirectory() { return m_BackupDirectory.query();}
const char * CTpDali::getType() { return m_Type.query();}
const char * CTpDali::getPath() { return m_Path.query();}
const char * CTpDali::getLogDirectory() { return m_LogDirectory.query();}
const char * CTpDali::getAuditLogDirectory() { return m_AuditLogDirectory.query();}
IArrayOf<IConstTpMachine> & CTpDali::getTpMachines() { return (IArrayOf<IConstTpMachine> &) m_TpMachines; }
void CTpDali::setName(const char * val){ m_Name.set(val); }
void CTpDali::setDescription(const char * val){ m_Description.set(val); }
void CTpDali::setBuild(const char * val){ m_Build.set(val); }
void CTpDali::setBackupComputer(const char * val){ m_BackupComputer.set(val); }
void CTpDali::setBackupDirectory(const char * val){ m_BackupDirectory.set(val); }
void CTpDali::setType(const char * val){ m_Type.set(val); }
void CTpDali::setPath(const char * val){ m_Path.set(val); }
void CTpDali::setLogDirectory(const char * val){ m_LogDirectory.set(val); }
void CTpDali::setAuditLogDirectory(const char * val){ m_AuditLogDirectory.set(val); }
void CTpDali::setTpMachines(IArrayOf<IEspTpMachine> &val)
{
	m_TpMachines->kill();
	IArrayOf<IConstTpMachine> &target = m_TpMachines.getValue();
	ForEachItemIn(idx, val)
	{
		IEspTpMachine &item = (val).item(idx);
		item.Link();
		target.append(item);
	}
}
void CTpDali::setTpMachines(IArrayOf<IConstTpMachine> &val)
{
	m_TpMachines->kill();
	IArrayOf<IConstTpMachine> &target = m_TpMachines.getValue();
	ForEachItemIn(idx, val)
	{
		IConstTpMachine &item = val.item(idx);
		item.Link();
		target.append(item);
	}
}
extern "C"  IEspTpDali *createTpDali(const char *serv, const char *msgname){return ((IEspTpDali *)new CTpDali(serv /*, msgname*/));}
extern "C"  IClientTpDali *createClientTpDali(const char *serv, const char *msgname){return ((IClientTpDali *)new CTpDali(serv /*, msgname*/));}

//=======================================================
// class CTpEclServer Implementation
//=======================================================

CTpEclServer::CTpEclServer(const char *serviceName, IRpcMessageBinding *init)
	: m_Name(nilIgnore),m_Description(nilIgnore),m_Build(nilIgnore),m_LogDirectory(nilIgnore),m_Type(nilIgnore),m_Path(nilIgnore),m_TpMachines(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("TpEclServer");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CTpEclServer::CTpEclServer(const char *serviceName, const char *bc)
	: m_Name(nilIgnore),m_Description(nilIgnore),m_Build(nilIgnore),m_LogDirectory(nilIgnore),m_Type(nilIgnore),m_Path(nilIgnore),m_TpMachines(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("TpEclServer");
}

StringBuffer &CTpEclServer::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:complexType name=\"%s\">\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Name\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Description\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Build\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"LogDirectory\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Type\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Path\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"TpMachines\" type=\"tns:ArrayOfTpMachine\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType>\n");
		}
	}
	if (!(flags & 0x10)  || (flags & 0x100))
	{
		CTpMachine::getXsdDefinition(context, request, schema, added);
	}
	if (added.getValue("TpMachine") && added.getValue("ArrayOfTpMachine")==NULL) {
		schema.append("<xsd:complexType name=\"ArrayOfTpMachine\">\n");
		schema.append("<xsd:sequence>\n");
		schema.append("<xsd:element minOccurs=\"0\" maxOccurs=\"unbounded\" name=\"TpMachine\" type=\"tns:TpMachine\"/>\n");
		schema.append("</xsd:sequence>\n");
		schema.append("</xsd:complexType>\n");
		added.setValue("ArrayOfTpMachine",1);
	}
	return schema;
}

void CTpEclServer::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CTpEclServer::getMapInfo(IMapInfo& info, BoolHash& added)
{
	if (!added.getValue("TpMachine"))
	{
		added.setValue("TpMachine",1);
		CTpMachine::getMapInfo(info,added);
	}
}

StringBuffer &CTpEclServer::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Name");
	form.appendf("  <tr><td><b>Name: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Description");
	form.appendf("  <tr><td><b>Description: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Build");
	form.appendf("  <tr><td><b>Build: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("LogDirectory");
	form.appendf("  <tr><td><b>LogDirectory: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Type");
	form.appendf("  <tr><td><b>Type: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Path");
	form.appendf("  <tr><td><b>Path: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("TpMachines");
	form.appendf("<tr><td><b>TpMachines: </b></td><td>");
	form.appendf("<table><tr><td><textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea></td>", extfix.str());
	form.append("</tr></table>");
	form.append("</td></tr>");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CTpEclServer::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CTpEclServer::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_Name.marshall(rpc_resp, "Name", "", "", "");
	m_Description.marshall(rpc_resp, "Description", "", "", "");
	m_Build.marshall(rpc_resp, "Build", "", "", "");
	m_LogDirectory.marshall(rpc_resp, "LogDirectory", "", "", "");
	m_Type.marshall(rpc_resp, "Type", "", "", "");
	m_Path.marshall(rpc_resp, "Path", "", "", "");
	m_TpMachines.marshall(rpc_resp, "TpMachines", "TpMachine");
}


void CTpEclServer::copy(CTpEclServer &from)
{
	m_Name.copy(from.m_Name);
	m_Description.copy(from.m_Description);
	m_Build.copy(from.m_Build);
	m_LogDirectory.copy(from.m_LogDirectory);
	m_Type.copy(from.m_Type);
	m_Path.copy(from.m_Path);
	m_TpMachines.copy(from.m_TpMachines);
}


void CTpEclServer::copy(IConstTpEclServer &ifrom)
{
	setName(ifrom.getName());
	setDescription(ifrom.getDescription());
	setBuild(ifrom.getBuild());
	setLogDirectory(ifrom.getLogDirectory());
	setType(ifrom.getType());
	setPath(ifrom.getPath());
	setTpMachines(ifrom.getTpMachines());
}


void CTpEclServer::getAttributes(IProperties &attributes)
{
}


void CTpEclServer::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_Name.toStr(ctx, buffer, "Name", "", true, "", "");
	m_Description.toStr(ctx, buffer, "Description", "", true, "", "");
	m_Build.toStr(ctx, buffer, "Build", "", true, "", "");
	m_LogDirectory.toStr(ctx, buffer, "LogDirectory", "", true, "", "");
	m_Type.toStr(ctx, buffer, "Type", "", true, "", "");
	m_Path.toStr(ctx, buffer, "Path", "", true, "", "");
	m_TpMachines.toStr(ctx, buffer, "TpMachines", "TpMachine");
}


void CTpEclServer::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CTpEclServer::serializer(IEspContext* ctx, IConstTpEclServer &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<TpEclServer>");
	// field Name
	{
		const char* s = src.getName();
		if (s && *s)
		{
			buffer.append("<Name>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Name>");
		}
	}
	// field Description
	{
		const char* s = src.getDescription();
		if (s && *s)
		{
			buffer.append("<Description>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Description>");
		}
	}
	// field Build
	{
		const char* s = src.getBuild();
		if (s && *s)
		{
			buffer.append("<Build>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Build>");
		}
	}
	// field LogDirectory
	{
		const char* s = src.getLogDirectory();
		if (s && *s)
		{
			buffer.append("<LogDirectory>");
			encodeUtf8XML(s,buffer);
			buffer.append("</LogDirectory>");
		}
	}
	// field Type
	{
		const char* s = src.getType();
		if (s && *s)
		{
			buffer.append("<Type>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Type>");
		}
	}
	// field Path
	{
		const char* s = src.getPath();
		if (s && *s)
		{
			buffer.append("<Path>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Path>");
		}
	}
	// field TpMachines
	{
		IArrayOf<IConstTpMachine>& v = src.getTpMachines();
		int size = v.length();
		if (size>0)
			buffer.append("<TpMachines>");
		for (int i=0;i<size;i++)
		{
			buffer.append("<Item>");
			CTpMachine::serializer(ctx,v.item(i),buffer,false);
			buffer.append("</Item>");
		}
		if (size>0)
			buffer.append("</TpMachines>");
	}
	if (keepRootTag)
		buffer.append("</TpEclServer>");
}

bool CTpEclServer::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_Name.unmarshall(rpc_request, "Name", basepath);
	hasValue |= m_Description.unmarshall(rpc_request, "Description", basepath);
	hasValue |= m_Build.unmarshall(rpc_request, "Build", basepath);
	hasValue |= m_LogDirectory.unmarshall(rpc_request, "LogDirectory", basepath);
	hasValue |= m_Type.unmarshall(rpc_request, "Type", basepath);
	hasValue |= m_Path.unmarshall(rpc_request, "Path", basepath);
	hasValue |= m_TpMachines.unmarshall(rpc_request, "TpMachines", basepath);
	return hasValue;
}

bool CTpEclServer::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Name.unmarshall(ctx, soapval, "Name");
	hasValue |= m_Description.unmarshall(ctx, soapval, "Description");
	hasValue |= m_Build.unmarshall(ctx, soapval, "Build");
	hasValue |= m_LogDirectory.unmarshall(ctx, soapval, "LogDirectory");
	hasValue |= m_Type.unmarshall(ctx, soapval, "Type");
	hasValue |= m_Path.unmarshall(ctx, soapval, "Path");
	hasValue |= m_TpMachines.unmarshall(ctx, soapval, "TpMachines");
	return hasValue;
}

bool CTpEclServer::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Name.unmarshall(ctx, params, attachments, "Name", basepath);
	hasValue |= m_Description.unmarshall(ctx, params, attachments, "Description", basepath);
	hasValue |= m_Build.unmarshall(ctx, params, attachments, "Build", basepath);
	hasValue |= m_LogDirectory.unmarshall(ctx, params, attachments, "LogDirectory", basepath);
	hasValue |= m_Type.unmarshall(ctx, params, attachments, "Type", basepath);
	hasValue |= m_Path.unmarshall(ctx, params, attachments, "Path", basepath);
	hasValue |= m_TpMachines.unmarshall(ctx, params, attachments, "TpMachines", basepath);
	return hasValue;
}

const char * CTpEclServer::getName() { return m_Name.query();}
const char * CTpEclServer::getDescription() { return m_Description.query();}
const char * CTpEclServer::getBuild() { return m_Build.query();}
const char * CTpEclServer::getLogDirectory() { return m_LogDirectory.query();}
const char * CTpEclServer::getType() { return m_Type.query();}
const char * CTpEclServer::getPath() { return m_Path.query();}
IArrayOf<IConstTpMachine> & CTpEclServer::getTpMachines() { return (IArrayOf<IConstTpMachine> &) m_TpMachines; }
void CTpEclServer::setName(const char * val){ m_Name.set(val); }
void CTpEclServer::setDescription(const char * val){ m_Description.set(val); }
void CTpEclServer::setBuild(const char * val){ m_Build.set(val); }
void CTpEclServer::setLogDirectory(const char * val){ m_LogDirectory.set(val); }
void CTpEclServer::setType(const char * val){ m_Type.set(val); }
void CTpEclServer::setPath(const char * val){ m_Path.set(val); }
void CTpEclServer::setTpMachines(IArrayOf<IEspTpMachine> &val)
{
	m_TpMachines->kill();
	IArrayOf<IConstTpMachine> &target = m_TpMachines.getValue();
	ForEachItemIn(idx, val)
	{
		IEspTpMachine &item = (val).item(idx);
		item.Link();
		target.append(item);
	}
}
void CTpEclServer::setTpMachines(IArrayOf<IConstTpMachine> &val)
{
	m_TpMachines->kill();
	IArrayOf<IConstTpMachine> &target = m_TpMachines.getValue();
	ForEachItemIn(idx, val)
	{
		IConstTpMachine &item = val.item(idx);
		item.Link();
		target.append(item);
	}
}
extern "C"  IEspTpEclServer *createTpEclServer(const char *serv, const char *msgname){return ((IEspTpEclServer *)new CTpEclServer(serv /*, msgname*/));}
extern "C"  IClientTpEclServer *createClientTpEclServer(const char *serv, const char *msgname){return ((IClientTpEclServer *)new CTpEclServer(serv /*, msgname*/));}

//=======================================================
// class CTpEclAgent Implementation
//=======================================================

CTpEclAgent::CTpEclAgent(const char *serviceName, IRpcMessageBinding *init)
	: m_Name(nilIgnore),m_Description(nilIgnore),m_Build(nilIgnore),m_Type(nilIgnore),m_Path(nilIgnore),m_DaliServer(nilIgnore),m_LogDir(nilIgnore),m_TpMachines(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("TpEclAgent");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CTpEclAgent::CTpEclAgent(const char *serviceName, const char *bc)
	: m_Name(nilIgnore),m_Description(nilIgnore),m_Build(nilIgnore),m_Type(nilIgnore),m_Path(nilIgnore),m_DaliServer(nilIgnore),m_LogDir(nilIgnore),m_TpMachines(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("TpEclAgent");
}

StringBuffer &CTpEclAgent::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:complexType name=\"%s\">\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Name\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Description\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Build\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Type\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Path\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"DaliServer\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"LogDir\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"TpMachines\" type=\"tns:ArrayOfTpMachine\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType>\n");
		}
	}
	if (!(flags & 0x10)  || (flags & 0x100))
	{
		CTpMachine::getXsdDefinition(context, request, schema, added);
	}
	if (added.getValue("TpMachine") && added.getValue("ArrayOfTpMachine")==NULL) {
		schema.append("<xsd:complexType name=\"ArrayOfTpMachine\">\n");
		schema.append("<xsd:sequence>\n");
		schema.append("<xsd:element minOccurs=\"0\" maxOccurs=\"unbounded\" name=\"TpMachine\" type=\"tns:TpMachine\"/>\n");
		schema.append("</xsd:sequence>\n");
		schema.append("</xsd:complexType>\n");
		added.setValue("ArrayOfTpMachine",1);
	}
	return schema;
}

void CTpEclAgent::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CTpEclAgent::getMapInfo(IMapInfo& info, BoolHash& added)
{
	if (!added.getValue("TpMachine"))
	{
		added.setValue("TpMachine",1);
		CTpMachine::getMapInfo(info,added);
	}
}

StringBuffer &CTpEclAgent::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Name");
	form.appendf("  <tr><td><b>Name: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Description");
	form.appendf("  <tr><td><b>Description: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Build");
	form.appendf("  <tr><td><b>Build: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Type");
	form.appendf("  <tr><td><b>Type: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Path");
	form.appendf("  <tr><td><b>Path: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("DaliServer");
	form.appendf("  <tr><td><b>DaliServer: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("LogDir");
	form.appendf("  <tr><td><b>LogDir: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("TpMachines");
	form.appendf("<tr><td><b>TpMachines: </b></td><td>");
	form.appendf("<table><tr><td><textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea></td>", extfix.str());
	form.append("</tr></table>");
	form.append("</td></tr>");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CTpEclAgent::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CTpEclAgent::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_Name.marshall(rpc_resp, "Name", "", "", "");
	m_Description.marshall(rpc_resp, "Description", "", "", "");
	m_Build.marshall(rpc_resp, "Build", "", "", "");
	m_Type.marshall(rpc_resp, "Type", "", "", "");
	m_Path.marshall(rpc_resp, "Path", "", "", "");
	m_DaliServer.marshall(rpc_resp, "DaliServer", "", "", "");
	m_LogDir.marshall(rpc_resp, "LogDir", "", "", "");
	m_TpMachines.marshall(rpc_resp, "TpMachines", "TpMachine");
}


void CTpEclAgent::copy(CTpEclAgent &from)
{
	m_Name.copy(from.m_Name);
	m_Description.copy(from.m_Description);
	m_Build.copy(from.m_Build);
	m_Type.copy(from.m_Type);
	m_Path.copy(from.m_Path);
	m_DaliServer.copy(from.m_DaliServer);
	m_LogDir.copy(from.m_LogDir);
	m_TpMachines.copy(from.m_TpMachines);
}


void CTpEclAgent::copy(IConstTpEclAgent &ifrom)
{
	setName(ifrom.getName());
	setDescription(ifrom.getDescription());
	setBuild(ifrom.getBuild());
	setType(ifrom.getType());
	setPath(ifrom.getPath());
	setDaliServer(ifrom.getDaliServer());
	setLogDir(ifrom.getLogDir());
	setTpMachines(ifrom.getTpMachines());
}


void CTpEclAgent::getAttributes(IProperties &attributes)
{
}


void CTpEclAgent::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_Name.toStr(ctx, buffer, "Name", "", true, "", "");
	m_Description.toStr(ctx, buffer, "Description", "", true, "", "");
	m_Build.toStr(ctx, buffer, "Build", "", true, "", "");
	m_Type.toStr(ctx, buffer, "Type", "", true, "", "");
	m_Path.toStr(ctx, buffer, "Path", "", true, "", "");
	m_DaliServer.toStr(ctx, buffer, "DaliServer", "", true, "", "");
	m_LogDir.toStr(ctx, buffer, "LogDir", "", true, "", "");
	m_TpMachines.toStr(ctx, buffer, "TpMachines", "TpMachine");
}


void CTpEclAgent::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CTpEclAgent::serializer(IEspContext* ctx, IConstTpEclAgent &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<TpEclAgent>");
	// field Name
	{
		const char* s = src.getName();
		if (s && *s)
		{
			buffer.append("<Name>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Name>");
		}
	}
	// field Description
	{
		const char* s = src.getDescription();
		if (s && *s)
		{
			buffer.append("<Description>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Description>");
		}
	}
	// field Build
	{
		const char* s = src.getBuild();
		if (s && *s)
		{
			buffer.append("<Build>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Build>");
		}
	}
	// field Type
	{
		const char* s = src.getType();
		if (s && *s)
		{
			buffer.append("<Type>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Type>");
		}
	}
	// field Path
	{
		const char* s = src.getPath();
		if (s && *s)
		{
			buffer.append("<Path>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Path>");
		}
	}
	// field DaliServer
	{
		const char* s = src.getDaliServer();
		if (s && *s)
		{
			buffer.append("<DaliServer>");
			encodeUtf8XML(s,buffer);
			buffer.append("</DaliServer>");
		}
	}
	// field LogDir
	{
		const char* s = src.getLogDir();
		if (s && *s)
		{
			buffer.append("<LogDir>");
			encodeUtf8XML(s,buffer);
			buffer.append("</LogDir>");
		}
	}
	// field TpMachines
	{
		IArrayOf<IConstTpMachine>& v = src.getTpMachines();
		int size = v.length();
		if (size>0)
			buffer.append("<TpMachines>");
		for (int i=0;i<size;i++)
		{
			buffer.append("<Item>");
			CTpMachine::serializer(ctx,v.item(i),buffer,false);
			buffer.append("</Item>");
		}
		if (size>0)
			buffer.append("</TpMachines>");
	}
	if (keepRootTag)
		buffer.append("</TpEclAgent>");
}

bool CTpEclAgent::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_Name.unmarshall(rpc_request, "Name", basepath);
	hasValue |= m_Description.unmarshall(rpc_request, "Description", basepath);
	hasValue |= m_Build.unmarshall(rpc_request, "Build", basepath);
	hasValue |= m_Type.unmarshall(rpc_request, "Type", basepath);
	hasValue |= m_Path.unmarshall(rpc_request, "Path", basepath);
	hasValue |= m_DaliServer.unmarshall(rpc_request, "DaliServer", basepath);
	hasValue |= m_LogDir.unmarshall(rpc_request, "LogDir", basepath);
	hasValue |= m_TpMachines.unmarshall(rpc_request, "TpMachines", basepath);
	return hasValue;
}

bool CTpEclAgent::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Name.unmarshall(ctx, soapval, "Name");
	hasValue |= m_Description.unmarshall(ctx, soapval, "Description");
	hasValue |= m_Build.unmarshall(ctx, soapval, "Build");
	hasValue |= m_Type.unmarshall(ctx, soapval, "Type");
	hasValue |= m_Path.unmarshall(ctx, soapval, "Path");
	hasValue |= m_DaliServer.unmarshall(ctx, soapval, "DaliServer");
	hasValue |= m_LogDir.unmarshall(ctx, soapval, "LogDir");
	hasValue |= m_TpMachines.unmarshall(ctx, soapval, "TpMachines");
	return hasValue;
}

bool CTpEclAgent::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Name.unmarshall(ctx, params, attachments, "Name", basepath);
	hasValue |= m_Description.unmarshall(ctx, params, attachments, "Description", basepath);
	hasValue |= m_Build.unmarshall(ctx, params, attachments, "Build", basepath);
	hasValue |= m_Type.unmarshall(ctx, params, attachments, "Type", basepath);
	hasValue |= m_Path.unmarshall(ctx, params, attachments, "Path", basepath);
	hasValue |= m_DaliServer.unmarshall(ctx, params, attachments, "DaliServer", basepath);
	hasValue |= m_LogDir.unmarshall(ctx, params, attachments, "LogDir", basepath);
	hasValue |= m_TpMachines.unmarshall(ctx, params, attachments, "TpMachines", basepath);
	return hasValue;
}

const char * CTpEclAgent::getName() { return m_Name.query();}
const char * CTpEclAgent::getDescription() { return m_Description.query();}
const char * CTpEclAgent::getBuild() { return m_Build.query();}
const char * CTpEclAgent::getType() { return m_Type.query();}
const char * CTpEclAgent::getPath() { return m_Path.query();}
const char * CTpEclAgent::getDaliServer() { return m_DaliServer.query();}
const char * CTpEclAgent::getLogDir() { return m_LogDir.query();}
IArrayOf<IConstTpMachine> & CTpEclAgent::getTpMachines() { return (IArrayOf<IConstTpMachine> &) m_TpMachines; }
void CTpEclAgent::setName(const char * val){ m_Name.set(val); }
void CTpEclAgent::setDescription(const char * val){ m_Description.set(val); }
void CTpEclAgent::setBuild(const char * val){ m_Build.set(val); }
void CTpEclAgent::setType(const char * val){ m_Type.set(val); }
void CTpEclAgent::setPath(const char * val){ m_Path.set(val); }
void CTpEclAgent::setDaliServer(const char * val){ m_DaliServer.set(val); }
void CTpEclAgent::setLogDir(const char * val){ m_LogDir.set(val); }
void CTpEclAgent::setTpMachines(IArrayOf<IEspTpMachine> &val)
{
	m_TpMachines->kill();
	IArrayOf<IConstTpMachine> &target = m_TpMachines.getValue();
	ForEachItemIn(idx, val)
	{
		IEspTpMachine &item = (val).item(idx);
		item.Link();
		target.append(item);
	}
}
void CTpEclAgent::setTpMachines(IArrayOf<IConstTpMachine> &val)
{
	m_TpMachines->kill();
	IArrayOf<IConstTpMachine> &target = m_TpMachines.getValue();
	ForEachItemIn(idx, val)
	{
		IConstTpMachine &item = val.item(idx);
		item.Link();
		target.append(item);
	}
}
extern "C"  IEspTpEclAgent *createTpEclAgent(const char *serv, const char *msgname){return ((IEspTpEclAgent *)new CTpEclAgent(serv /*, msgname*/));}
extern "C"  IClientTpEclAgent *createClientTpEclAgent(const char *serv, const char *msgname){return ((IClientTpEclAgent *)new CTpEclAgent(serv /*, msgname*/));}

//=======================================================
// class CTpAgentExec Implementation
//=======================================================

CTpAgentExec::CTpAgentExec(const char *serviceName, IRpcMessageBinding *init)
	: m_DaliServer(nilIgnore),m_LogDir(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("TpAgentExec");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CTpAgentExec::CTpAgentExec(const char *serviceName, const char *bc)
	: m_DaliServer(nilIgnore),m_LogDir(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("TpAgentExec");
}

StringBuffer &CTpAgentExec::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:complexType name=\"%s\">\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"DaliServer\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"LogDir\" type=\"xsd:string\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType>\n");
		}
	}
	return schema;
}

void CTpAgentExec::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CTpAgentExec::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CTpAgentExec::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("DaliServer");
	form.appendf("  <tr><td><b>DaliServer: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("LogDir");
	form.appendf("  <tr><td><b>LogDir: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CTpAgentExec::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CTpAgentExec::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_DaliServer.marshall(rpc_resp, "DaliServer", "", "", "");
	m_LogDir.marshall(rpc_resp, "LogDir", "", "", "");
}


void CTpAgentExec::copy(CTpAgentExec &from)
{
	m_DaliServer.copy(from.m_DaliServer);
	m_LogDir.copy(from.m_LogDir);
}


void CTpAgentExec::copy(IConstTpAgentExec &ifrom)
{
	setDaliServer(ifrom.getDaliServer());
	setLogDir(ifrom.getLogDir());
}


void CTpAgentExec::getAttributes(IProperties &attributes)
{
}


void CTpAgentExec::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_DaliServer.toStr(ctx, buffer, "DaliServer", "", true, "", "");
	m_LogDir.toStr(ctx, buffer, "LogDir", "", true, "", "");
}


void CTpAgentExec::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CTpAgentExec::serializer(IEspContext* ctx, IConstTpAgentExec &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<TpAgentExec>");
	// field DaliServer
	{
		const char* s = src.getDaliServer();
		if (s && *s)
		{
			buffer.append("<DaliServer>");
			encodeUtf8XML(s,buffer);
			buffer.append("</DaliServer>");
		}
	}
	// field LogDir
	{
		const char* s = src.getLogDir();
		if (s && *s)
		{
			buffer.append("<LogDir>");
			encodeUtf8XML(s,buffer);
			buffer.append("</LogDir>");
		}
	}
	if (keepRootTag)
		buffer.append("</TpAgentExec>");
}

bool CTpAgentExec::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_DaliServer.unmarshall(rpc_request, "DaliServer", basepath);
	hasValue |= m_LogDir.unmarshall(rpc_request, "LogDir", basepath);
	return hasValue;
}

bool CTpAgentExec::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_DaliServer.unmarshall(ctx, soapval, "DaliServer");
	hasValue |= m_LogDir.unmarshall(ctx, soapval, "LogDir");
	return hasValue;
}

bool CTpAgentExec::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_DaliServer.unmarshall(ctx, params, attachments, "DaliServer", basepath);
	hasValue |= m_LogDir.unmarshall(ctx, params, attachments, "LogDir", basepath);
	return hasValue;
}

const char * CTpAgentExec::getDaliServer() { return m_DaliServer.query();}
const char * CTpAgentExec::getLogDir() { return m_LogDir.query();}
void CTpAgentExec::setDaliServer(const char * val){ m_DaliServer.set(val); }
void CTpAgentExec::setLogDir(const char * val){ m_LogDir.set(val); }
extern "C"  IEspTpAgentExec *createTpAgentExec(const char *serv, const char *msgname){return ((IEspTpAgentExec *)new CTpAgentExec(serv /*, msgname*/));}
extern "C"  IClientTpAgentExec *createClientTpAgentExec(const char *serv, const char *msgname){return ((IClientTpAgentExec *)new CTpAgentExec(serv /*, msgname*/));}

//=======================================================
// class CTpEclScheduler Implementation
//=======================================================

CTpEclScheduler::CTpEclScheduler(const char *serviceName, IRpcMessageBinding *init)
	: m_Name(nilIgnore),m_Description(nilIgnore),m_Build(nilIgnore),m_LogDirectory(nilIgnore),m_Type(nilIgnore),m_Path(nilIgnore),m_TpMachines(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("TpEclScheduler");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CTpEclScheduler::CTpEclScheduler(const char *serviceName, const char *bc)
	: m_Name(nilIgnore),m_Description(nilIgnore),m_Build(nilIgnore),m_LogDirectory(nilIgnore),m_Type(nilIgnore),m_Path(nilIgnore),m_TpMachines(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("TpEclScheduler");
}

StringBuffer &CTpEclScheduler::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:complexType name=\"%s\">\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Name\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Description\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Build\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"LogDirectory\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Type\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Path\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"TpMachines\" type=\"tns:ArrayOfTpMachine\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType>\n");
		}
	}
	if (!(flags & 0x10)  || (flags & 0x100))
	{
		CTpMachine::getXsdDefinition(context, request, schema, added);
	}
	if (added.getValue("TpMachine") && added.getValue("ArrayOfTpMachine")==NULL) {
		schema.append("<xsd:complexType name=\"ArrayOfTpMachine\">\n");
		schema.append("<xsd:sequence>\n");
		schema.append("<xsd:element minOccurs=\"0\" maxOccurs=\"unbounded\" name=\"TpMachine\" type=\"tns:TpMachine\"/>\n");
		schema.append("</xsd:sequence>\n");
		schema.append("</xsd:complexType>\n");
		added.setValue("ArrayOfTpMachine",1);
	}
	return schema;
}

void CTpEclScheduler::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CTpEclScheduler::getMapInfo(IMapInfo& info, BoolHash& added)
{
	if (!added.getValue("TpMachine"))
	{
		added.setValue("TpMachine",1);
		CTpMachine::getMapInfo(info,added);
	}
}

StringBuffer &CTpEclScheduler::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Name");
	form.appendf("  <tr><td><b>Name: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Description");
	form.appendf("  <tr><td><b>Description: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Build");
	form.appendf("  <tr><td><b>Build: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("LogDirectory");
	form.appendf("  <tr><td><b>LogDirectory: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Type");
	form.appendf("  <tr><td><b>Type: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Path");
	form.appendf("  <tr><td><b>Path: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("TpMachines");
	form.appendf("<tr><td><b>TpMachines: </b></td><td>");
	form.appendf("<table><tr><td><textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea></td>", extfix.str());
	form.append("</tr></table>");
	form.append("</td></tr>");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CTpEclScheduler::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CTpEclScheduler::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_Name.marshall(rpc_resp, "Name", "", "", "");
	m_Description.marshall(rpc_resp, "Description", "", "", "");
	m_Build.marshall(rpc_resp, "Build", "", "", "");
	m_LogDirectory.marshall(rpc_resp, "LogDirectory", "", "", "");
	m_Type.marshall(rpc_resp, "Type", "", "", "");
	m_Path.marshall(rpc_resp, "Path", "", "", "");
	m_TpMachines.marshall(rpc_resp, "TpMachines", "TpMachine");
}


void CTpEclScheduler::copy(CTpEclScheduler &from)
{
	m_Name.copy(from.m_Name);
	m_Description.copy(from.m_Description);
	m_Build.copy(from.m_Build);
	m_LogDirectory.copy(from.m_LogDirectory);
	m_Type.copy(from.m_Type);
	m_Path.copy(from.m_Path);
	m_TpMachines.copy(from.m_TpMachines);
}


void CTpEclScheduler::copy(IConstTpEclScheduler &ifrom)
{
	setName(ifrom.getName());
	setDescription(ifrom.getDescription());
	setBuild(ifrom.getBuild());
	setLogDirectory(ifrom.getLogDirectory());
	setType(ifrom.getType());
	setPath(ifrom.getPath());
	setTpMachines(ifrom.getTpMachines());
}


void CTpEclScheduler::getAttributes(IProperties &attributes)
{
}


void CTpEclScheduler::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_Name.toStr(ctx, buffer, "Name", "", true, "", "");
	m_Description.toStr(ctx, buffer, "Description", "", true, "", "");
	m_Build.toStr(ctx, buffer, "Build", "", true, "", "");
	m_LogDirectory.toStr(ctx, buffer, "LogDirectory", "", true, "", "");
	m_Type.toStr(ctx, buffer, "Type", "", true, "", "");
	m_Path.toStr(ctx, buffer, "Path", "", true, "", "");
	m_TpMachines.toStr(ctx, buffer, "TpMachines", "TpMachine");
}


void CTpEclScheduler::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CTpEclScheduler::serializer(IEspContext* ctx, IConstTpEclScheduler &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<TpEclScheduler>");
	// field Name
	{
		const char* s = src.getName();
		if (s && *s)
		{
			buffer.append("<Name>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Name>");
		}
	}
	// field Description
	{
		const char* s = src.getDescription();
		if (s && *s)
		{
			buffer.append("<Description>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Description>");
		}
	}
	// field Build
	{
		const char* s = src.getBuild();
		if (s && *s)
		{
			buffer.append("<Build>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Build>");
		}
	}
	// field LogDirectory
	{
		const char* s = src.getLogDirectory();
		if (s && *s)
		{
			buffer.append("<LogDirectory>");
			encodeUtf8XML(s,buffer);
			buffer.append("</LogDirectory>");
		}
	}
	// field Type
	{
		const char* s = src.getType();
		if (s && *s)
		{
			buffer.append("<Type>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Type>");
		}
	}
	// field Path
	{
		const char* s = src.getPath();
		if (s && *s)
		{
			buffer.append("<Path>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Path>");
		}
	}
	// field TpMachines
	{
		IArrayOf<IConstTpMachine>& v = src.getTpMachines();
		int size = v.length();
		if (size>0)
			buffer.append("<TpMachines>");
		for (int i=0;i<size;i++)
		{
			buffer.append("<Item>");
			CTpMachine::serializer(ctx,v.item(i),buffer,false);
			buffer.append("</Item>");
		}
		if (size>0)
			buffer.append("</TpMachines>");
	}
	if (keepRootTag)
		buffer.append("</TpEclScheduler>");
}

bool CTpEclScheduler::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_Name.unmarshall(rpc_request, "Name", basepath);
	hasValue |= m_Description.unmarshall(rpc_request, "Description", basepath);
	hasValue |= m_Build.unmarshall(rpc_request, "Build", basepath);
	hasValue |= m_LogDirectory.unmarshall(rpc_request, "LogDirectory", basepath);
	hasValue |= m_Type.unmarshall(rpc_request, "Type", basepath);
	hasValue |= m_Path.unmarshall(rpc_request, "Path", basepath);
	hasValue |= m_TpMachines.unmarshall(rpc_request, "TpMachines", basepath);
	return hasValue;
}

bool CTpEclScheduler::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Name.unmarshall(ctx, soapval, "Name");
	hasValue |= m_Description.unmarshall(ctx, soapval, "Description");
	hasValue |= m_Build.unmarshall(ctx, soapval, "Build");
	hasValue |= m_LogDirectory.unmarshall(ctx, soapval, "LogDirectory");
	hasValue |= m_Type.unmarshall(ctx, soapval, "Type");
	hasValue |= m_Path.unmarshall(ctx, soapval, "Path");
	hasValue |= m_TpMachines.unmarshall(ctx, soapval, "TpMachines");
	return hasValue;
}

bool CTpEclScheduler::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Name.unmarshall(ctx, params, attachments, "Name", basepath);
	hasValue |= m_Description.unmarshall(ctx, params, attachments, "Description", basepath);
	hasValue |= m_Build.unmarshall(ctx, params, attachments, "Build", basepath);
	hasValue |= m_LogDirectory.unmarshall(ctx, params, attachments, "LogDirectory", basepath);
	hasValue |= m_Type.unmarshall(ctx, params, attachments, "Type", basepath);
	hasValue |= m_Path.unmarshall(ctx, params, attachments, "Path", basepath);
	hasValue |= m_TpMachines.unmarshall(ctx, params, attachments, "TpMachines", basepath);
	return hasValue;
}

const char * CTpEclScheduler::getName() { return m_Name.query();}
const char * CTpEclScheduler::getDescription() { return m_Description.query();}
const char * CTpEclScheduler::getBuild() { return m_Build.query();}
const char * CTpEclScheduler::getLogDirectory() { return m_LogDirectory.query();}
const char * CTpEclScheduler::getType() { return m_Type.query();}
const char * CTpEclScheduler::getPath() { return m_Path.query();}
IArrayOf<IConstTpMachine> & CTpEclScheduler::getTpMachines() { return (IArrayOf<IConstTpMachine> &) m_TpMachines; }
void CTpEclScheduler::setName(const char * val){ m_Name.set(val); }
void CTpEclScheduler::setDescription(const char * val){ m_Description.set(val); }
void CTpEclScheduler::setBuild(const char * val){ m_Build.set(val); }
void CTpEclScheduler::setLogDirectory(const char * val){ m_LogDirectory.set(val); }
void CTpEclScheduler::setType(const char * val){ m_Type.set(val); }
void CTpEclScheduler::setPath(const char * val){ m_Path.set(val); }
void CTpEclScheduler::setTpMachines(IArrayOf<IEspTpMachine> &val)
{
	m_TpMachines->kill();
	IArrayOf<IConstTpMachine> &target = m_TpMachines.getValue();
	ForEachItemIn(idx, val)
	{
		IEspTpMachine &item = (val).item(idx);
		item.Link();
		target.append(item);
	}
}
void CTpEclScheduler::setTpMachines(IArrayOf<IConstTpMachine> &val)
{
	m_TpMachines->kill();
	IArrayOf<IConstTpMachine> &target = m_TpMachines.getValue();
	ForEachItemIn(idx, val)
	{
		IConstTpMachine &item = val.item(idx);
		item.Link();
		target.append(item);
	}
}
extern "C"  IEspTpEclScheduler *createTpEclScheduler(const char *serv, const char *msgname){return ((IEspTpEclScheduler *)new CTpEclScheduler(serv /*, msgname*/));}
extern "C"  IClientTpEclScheduler *createClientTpEclScheduler(const char *serv, const char *msgname){return ((IClientTpEclScheduler *)new CTpEclScheduler(serv /*, msgname*/));}

//=======================================================
// class CTpBinding Implementation
//=======================================================

CTpBinding::CTpBinding(const char *serviceName, IRpcMessageBinding *init)
	: m_Name(nilRemove),m_Service(nilRemove),m_ServiceType(nilRemove),m_BindingType(nilRemove),m_ServiceBuildSet(nilRemove),m_Port(nilRemove),m_Protocol(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("TpBinding");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CTpBinding::CTpBinding(const char *serviceName, const char *bc)
	: m_Name(nilRemove),m_Service(nilRemove),m_ServiceType(nilRemove),m_BindingType(nilRemove),m_ServiceBuildSet(nilRemove),m_Port(nilRemove),m_Protocol(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("TpBinding");
}

StringBuffer &CTpBinding::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:complexType name=\"%s\">\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Name\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Service\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"ServiceType\" type=\"xsd:string\"/>\n");
		if (!context.suppressed("TpBinding","BindingType")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"BindingType\" type=\"xsd:string\"/>\n");
		}
		if (!context.suppressed("TpBinding","ServiceBuildSet")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"ServiceBuildSet\" type=\"xsd:string\"/>\n");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Port\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Protocol\" type=\"xsd:string\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType>\n");
		}
	}
	return schema;
}

void CTpBinding::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CTpBinding::getMapInfo(IMapInfo& info, BoolHash& added)
{
	info.addMinVersion("TpBinding","BindingType",1.23);
	info.addMinVersion("TpBinding","ServiceBuildSet",1.24);
}

StringBuffer &CTpBinding::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Name");
	form.appendf("  <tr><td><b>Name: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Service");
	form.appendf("  <tr><td><b>Service: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("ServiceType");
	form.appendf("  <tr><td><b>ServiceType: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (!context.suppressed("TpBinding","BindingType")) {
		extfix.clear();
		if (prefix && *prefix)
			extfix.append(prefix).append(".");
		extfix.append("BindingType");
		form.appendf("  <tr><td><b>BindingType: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
		form.append("</td></tr>\n");
	}
	if (!context.suppressed("TpBinding","ServiceBuildSet")) {
		extfix.clear();
		if (prefix && *prefix)
			extfix.append(prefix).append(".");
		extfix.append("ServiceBuildSet");
		form.appendf("  <tr><td><b>ServiceBuildSet: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
		form.append("</td></tr>\n");
	}
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Port");
	form.appendf("  <tr><td><b>Port: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Protocol");
	form.appendf("  <tr><td><b>Protocol: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CTpBinding::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CTpBinding::serialize(IRpcMessage& rpc_resp)
{
	IEspContext* ctx = rpc_resp.queryContext();
	double clientVer= ctx ? ctx->getClientVersion() : -1; /* no context gets everything */
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_Name.marshall(rpc_resp, "Name", "", "", "");
	m_Service.marshall(rpc_resp, "Service", "", "", "");
	m_ServiceType.marshall(rpc_resp, "ServiceType", "", "", "");
	if ((clientVer==-1.0 || clientVer>=1.23))
		m_BindingType.marshall(rpc_resp, "BindingType", "", "", "");
	if ((clientVer==-1.0 || clientVer>=1.24))
		m_ServiceBuildSet.marshall(rpc_resp, "ServiceBuildSet", "", "", "");
	m_Port.marshall(rpc_resp, "Port", "", "", "");
	m_Protocol.marshall(rpc_resp, "Protocol", "", "", "");
}


void CTpBinding::copy(CTpBinding &from)
{
	m_Name.copy(from.m_Name);
	m_Service.copy(from.m_Service);
	m_ServiceType.copy(from.m_ServiceType);
	m_BindingType.copy(from.m_BindingType);
	m_ServiceBuildSet.copy(from.m_ServiceBuildSet);
	m_Port.copy(from.m_Port);
	m_Protocol.copy(from.m_Protocol);
}


void CTpBinding::copy(IConstTpBinding &ifrom)
{
	setName(ifrom.getName());
	setService(ifrom.getService());
	setServiceType(ifrom.getServiceType());
	setBindingType(ifrom.getBindingType());
	setServiceBuildSet(ifrom.getServiceBuildSet());
	setPort(ifrom.getPort());
	setProtocol(ifrom.getProtocol());
}


void CTpBinding::getAttributes(IProperties &attributes)
{
}


void CTpBinding::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	double clientVer = ctx ? ctx->getClientVersion() : -1;
	m_Name.toStr(ctx, buffer, "Name", "", true, "", "");
	m_Service.toStr(ctx, buffer, "Service", "", true, "", "");
	m_ServiceType.toStr(ctx, buffer, "ServiceType", "", true, "", "");
	if ((clientVer==-1.0 || clientVer>=1.23))
		m_BindingType.toStr(ctx, buffer, "BindingType", "", true, "", "");
	if ((clientVer==-1.0 || clientVer>=1.24))
		m_ServiceBuildSet.toStr(ctx, buffer, "ServiceBuildSet", "", true, "", "");
	m_Port.toStr(ctx, buffer, "Port", "", true, "", "");
	m_Protocol.toStr(ctx, buffer, "Protocol", "", true, "", "");
}


void CTpBinding::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CTpBinding::serializer(IEspContext* ctx, IConstTpBinding &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<TpBinding>");
	double clientVer = ctx ? ctx->getClientVersion() : -1;
	// field Name
	{
		const char* s = src.getName();
		if (s && *s)
		{
			buffer.append("<Name>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Name>");
		}
	}
	// field Service
	{
		const char* s = src.getService();
		if (s && *s)
		{
			buffer.append("<Service>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Service>");
		}
	}
	// field ServiceType
	{
		const char* s = src.getServiceType();
		if (s && *s)
		{
			buffer.append("<ServiceType>");
			encodeUtf8XML(s,buffer);
			buffer.append("</ServiceType>");
		}
	}
	// field BindingType
	if ((clientVer==-1.0 || clientVer>=1.23))
	{
		const char* s = src.getBindingType();
		if (s && *s)
		{
			buffer.append("<BindingType>");
			encodeUtf8XML(s,buffer);
			buffer.append("</BindingType>");
		}
	}
	// field ServiceBuildSet
	if ((clientVer==-1.0 || clientVer>=1.24))
	{
		const char* s = src.getServiceBuildSet();
		if (s && *s)
		{
			buffer.append("<ServiceBuildSet>");
			encodeUtf8XML(s,buffer);
			buffer.append("</ServiceBuildSet>");
		}
	}
	// field Port
	{
		const char* s = src.getPort();
		if (s && *s)
		{
			buffer.append("<Port>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Port>");
		}
	}
	// field Protocol
	{
		const char* s = src.getProtocol();
		if (s && *s)
		{
			buffer.append("<Protocol>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Protocol>");
		}
	}
	if (keepRootTag)
		buffer.append("</TpBinding>");
}

bool CTpBinding::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_Name.unmarshall(rpc_request, "Name", basepath);
	hasValue |= m_Service.unmarshall(rpc_request, "Service", basepath);
	hasValue |= m_ServiceType.unmarshall(rpc_request, "ServiceType", basepath);
	hasValue |= m_BindingType.unmarshall(rpc_request, "BindingType", basepath);
	hasValue |= m_ServiceBuildSet.unmarshall(rpc_request, "ServiceBuildSet", basepath);
	hasValue |= m_Port.unmarshall(rpc_request, "Port", basepath);
	hasValue |= m_Protocol.unmarshall(rpc_request, "Protocol", basepath);
	return hasValue;
}

bool CTpBinding::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Name.unmarshall(ctx, soapval, "Name");
	hasValue |= m_Service.unmarshall(ctx, soapval, "Service");
	hasValue |= m_ServiceType.unmarshall(ctx, soapval, "ServiceType");
	hasValue |= m_BindingType.unmarshall(ctx, soapval, "BindingType");
	hasValue |= m_ServiceBuildSet.unmarshall(ctx, soapval, "ServiceBuildSet");
	hasValue |= m_Port.unmarshall(ctx, soapval, "Port");
	hasValue |= m_Protocol.unmarshall(ctx, soapval, "Protocol");
	return hasValue;
}

bool CTpBinding::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Name.unmarshall(ctx, params, attachments, "Name", basepath);
	hasValue |= m_Service.unmarshall(ctx, params, attachments, "Service", basepath);
	hasValue |= m_ServiceType.unmarshall(ctx, params, attachments, "ServiceType", basepath);
	hasValue |= m_BindingType.unmarshall(ctx, params, attachments, "BindingType", basepath);
	hasValue |= m_ServiceBuildSet.unmarshall(ctx, params, attachments, "ServiceBuildSet", basepath);
	hasValue |= m_Port.unmarshall(ctx, params, attachments, "Port", basepath);
	hasValue |= m_Protocol.unmarshall(ctx, params, attachments, "Protocol", basepath);
	return hasValue;
}

const char * CTpBinding::getName() { return m_Name.query();}
const char * CTpBinding::getService() { return m_Service.query();}
const char * CTpBinding::getServiceType() { return m_ServiceType.query();}
const char * CTpBinding::getBindingType() { return m_BindingType.query();}
const char * CTpBinding::getServiceBuildSet() { return m_ServiceBuildSet.query();}
const char * CTpBinding::getPort() { return m_Port.query();}
const char * CTpBinding::getProtocol() { return m_Protocol.query();}
void CTpBinding::setName(const char * val){ m_Name.set(val); }
void CTpBinding::setService(const char * val){ m_Service.set(val); }
void CTpBinding::setServiceType(const char * val){ m_ServiceType.set(val); }
void CTpBinding::setBindingType(const char * val){ m_BindingType.set(val); }
void CTpBinding::setServiceBuildSet(const char * val){ m_ServiceBuildSet.set(val); }
void CTpBinding::setPort(const char * val){ m_Port.set(val); }
void CTpBinding::setProtocol(const char * val){ m_Protocol.set(val); }
extern "C"  IEspTpBinding *createTpBinding(const char *serv, const char *msgname){return ((IEspTpBinding *)new CTpBinding(serv /*, msgname*/));}
extern "C"  IClientTpBinding *createClientTpBinding(const char *serv, const char *msgname){return ((IClientTpBinding *)new CTpBinding(serv /*, msgname*/));}

//=======================================================
// class CTpEspServicePlugin Implementation
//=======================================================

CTpEspServicePlugin::CTpEspServicePlugin(const char *serviceName, IRpcMessageBinding *init)
	: m_ShortName(nilIgnore),m_LongName(nilIgnore),m_FolderName(nilIgnore),m_WidgetName(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("TpEspServicePlugin");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CTpEspServicePlugin::CTpEspServicePlugin(const char *serviceName, const char *bc)
	: m_ShortName(nilIgnore),m_LongName(nilIgnore),m_FolderName(nilIgnore),m_WidgetName(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("TpEspServicePlugin");
}

StringBuffer &CTpEspServicePlugin::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:complexType name=\"%s\">\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"ShortName\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"LongName\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"FolderName\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"WidgetName\" type=\"xsd:string\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType>\n");
		}
	}
	return schema;
}

void CTpEspServicePlugin::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CTpEspServicePlugin::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CTpEspServicePlugin::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("ShortName");
	form.appendf("  <tr><td><b>ShortName: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("LongName");
	form.appendf("  <tr><td><b>LongName: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("FolderName");
	form.appendf("  <tr><td><b>FolderName: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("WidgetName");
	form.appendf("  <tr><td><b>WidgetName: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CTpEspServicePlugin::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CTpEspServicePlugin::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_ShortName.marshall(rpc_resp, "ShortName", "", "", "");
	m_LongName.marshall(rpc_resp, "LongName", "", "", "");
	m_FolderName.marshall(rpc_resp, "FolderName", "", "", "");
	m_WidgetName.marshall(rpc_resp, "WidgetName", "", "", "");
}


void CTpEspServicePlugin::copy(CTpEspServicePlugin &from)
{
	m_ShortName.copy(from.m_ShortName);
	m_LongName.copy(from.m_LongName);
	m_FolderName.copy(from.m_FolderName);
	m_WidgetName.copy(from.m_WidgetName);
}


void CTpEspServicePlugin::copy(IConstTpEspServicePlugin &ifrom)
{
	setShortName(ifrom.getShortName());
	setLongName(ifrom.getLongName());
	setFolderName(ifrom.getFolderName());
	setWidgetName(ifrom.getWidgetName());
}


void CTpEspServicePlugin::getAttributes(IProperties &attributes)
{
}


void CTpEspServicePlugin::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_ShortName.toStr(ctx, buffer, "ShortName", "", true, "", "");
	m_LongName.toStr(ctx, buffer, "LongName", "", true, "", "");
	m_FolderName.toStr(ctx, buffer, "FolderName", "", true, "", "");
	m_WidgetName.toStr(ctx, buffer, "WidgetName", "", true, "", "");
}


void CTpEspServicePlugin::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CTpEspServicePlugin::serializer(IEspContext* ctx, IConstTpEspServicePlugin &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<TpEspServicePlugin>");
	// field ShortName
	{
		const char* s = src.getShortName();
		if (s && *s)
		{
			buffer.append("<ShortName>");
			encodeUtf8XML(s,buffer);
			buffer.append("</ShortName>");
		}
	}
	// field LongName
	{
		const char* s = src.getLongName();
		if (s && *s)
		{
			buffer.append("<LongName>");
			encodeUtf8XML(s,buffer);
			buffer.append("</LongName>");
		}
	}
	// field FolderName
	{
		const char* s = src.getFolderName();
		if (s && *s)
		{
			buffer.append("<FolderName>");
			encodeUtf8XML(s,buffer);
			buffer.append("</FolderName>");
		}
	}
	// field WidgetName
	{
		const char* s = src.getWidgetName();
		if (s && *s)
		{
			buffer.append("<WidgetName>");
			encodeUtf8XML(s,buffer);
			buffer.append("</WidgetName>");
		}
	}
	if (keepRootTag)
		buffer.append("</TpEspServicePlugin>");
}

bool CTpEspServicePlugin::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_ShortName.unmarshall(rpc_request, "ShortName", basepath);
	hasValue |= m_LongName.unmarshall(rpc_request, "LongName", basepath);
	hasValue |= m_FolderName.unmarshall(rpc_request, "FolderName", basepath);
	hasValue |= m_WidgetName.unmarshall(rpc_request, "WidgetName", basepath);
	return hasValue;
}

bool CTpEspServicePlugin::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_ShortName.unmarshall(ctx, soapval, "ShortName");
	hasValue |= m_LongName.unmarshall(ctx, soapval, "LongName");
	hasValue |= m_FolderName.unmarshall(ctx, soapval, "FolderName");
	hasValue |= m_WidgetName.unmarshall(ctx, soapval, "WidgetName");
	return hasValue;
}

bool CTpEspServicePlugin::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_ShortName.unmarshall(ctx, params, attachments, "ShortName", basepath);
	hasValue |= m_LongName.unmarshall(ctx, params, attachments, "LongName", basepath);
	hasValue |= m_FolderName.unmarshall(ctx, params, attachments, "FolderName", basepath);
	hasValue |= m_WidgetName.unmarshall(ctx, params, attachments, "WidgetName", basepath);
	return hasValue;
}

const char * CTpEspServicePlugin::getShortName() { return m_ShortName.query();}
const char * CTpEspServicePlugin::getLongName() { return m_LongName.query();}
const char * CTpEspServicePlugin::getFolderName() { return m_FolderName.query();}
const char * CTpEspServicePlugin::getWidgetName() { return m_WidgetName.query();}
void CTpEspServicePlugin::setShortName(const char * val){ m_ShortName.set(val); }
void CTpEspServicePlugin::setLongName(const char * val){ m_LongName.set(val); }
void CTpEspServicePlugin::setFolderName(const char * val){ m_FolderName.set(val); }
void CTpEspServicePlugin::setWidgetName(const char * val){ m_WidgetName.set(val); }
extern "C"  IEspTpEspServicePlugin *createTpEspServicePlugin(const char *serv, const char *msgname){return ((IEspTpEspServicePlugin *)new CTpEspServicePlugin(serv /*, msgname*/));}
extern "C"  IClientTpEspServicePlugin *createClientTpEspServicePlugin(const char *serv, const char *msgname){return ((IClientTpEspServicePlugin *)new CTpEspServicePlugin(serv /*, msgname*/));}

//=======================================================
// class CTpEspServer Implementation
//=======================================================

CTpEspServer::CTpEspServer(const char *serviceName, IRpcMessageBinding *init)
	: m_Name(nilIgnore),m_Description(nilIgnore),m_Build(nilIgnore),m_Type(nilIgnore),m_Path(nilIgnore),m_LogDirectory(nilIgnore),m_TpMachines(nilIgnore),m_TpBindings(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("TpEspServer");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CTpEspServer::CTpEspServer(const char *serviceName, const char *bc)
	: m_Name(nilIgnore),m_Description(nilIgnore),m_Build(nilIgnore),m_Type(nilIgnore),m_Path(nilIgnore),m_LogDirectory(nilIgnore),m_TpMachines(nilIgnore),m_TpBindings(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("TpEspServer");
}

StringBuffer &CTpEspServer::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:complexType name=\"%s\">\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Name\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Description\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Build\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Type\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Path\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"LogDirectory\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"TpMachines\" type=\"tns:ArrayOfTpMachine\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"TpBindings\" type=\"tns:ArrayOfTpBinding\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType>\n");
		}
	}
	if (!(flags & 0x10)  || (flags & 0x100))
	{
		CTpMachine::getXsdDefinition(context, request, schema, added);
		CTpBinding::getXsdDefinition(context, request, schema, added);
	}
	if (added.getValue("TpBinding") && added.getValue("ArrayOfTpBinding")==NULL) {
		schema.append("<xsd:complexType name=\"ArrayOfTpBinding\">\n");
		schema.append("<xsd:sequence>\n");
		schema.append("<xsd:element minOccurs=\"0\" maxOccurs=\"unbounded\" name=\"TpBinding\" type=\"tns:TpBinding\"/>\n");
		schema.append("</xsd:sequence>\n");
		schema.append("</xsd:complexType>\n");
		added.setValue("ArrayOfTpBinding",1);
	}
	if (added.getValue("TpMachine") && added.getValue("ArrayOfTpMachine")==NULL) {
		schema.append("<xsd:complexType name=\"ArrayOfTpMachine\">\n");
		schema.append("<xsd:sequence>\n");
		schema.append("<xsd:element minOccurs=\"0\" maxOccurs=\"unbounded\" name=\"TpMachine\" type=\"tns:TpMachine\"/>\n");
		schema.append("</xsd:sequence>\n");
		schema.append("</xsd:complexType>\n");
		added.setValue("ArrayOfTpMachine",1);
	}
	return schema;
}

void CTpEspServer::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CTpEspServer::getMapInfo(IMapInfo& info, BoolHash& added)
{
	if (!added.getValue("TpBinding"))
	{
		added.setValue("TpBinding",1);
		CTpBinding::getMapInfo(info,added);
	}
	if (!added.getValue("TpMachine"))
	{
		added.setValue("TpMachine",1);
		CTpMachine::getMapInfo(info,added);
	}
}

StringBuffer &CTpEspServer::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Name");
	form.appendf("  <tr><td><b>Name: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Description");
	form.appendf("  <tr><td><b>Description: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Build");
	form.appendf("  <tr><td><b>Build: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Type");
	form.appendf("  <tr><td><b>Type: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Path");
	form.appendf("  <tr><td><b>Path: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("LogDirectory");
	form.appendf("  <tr><td><b>LogDirectory: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("TpMachines");
	form.appendf("<tr><td><b>TpMachines: </b></td><td>");
	form.appendf("<table><tr><td><textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea></td>", extfix.str());
	form.append("</tr></table>");
	form.append("</td></tr>");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("TpBindings");
	form.appendf("<tr><td><b>TpBindings: </b></td><td>");
	form.appendf("<table><tr><td><textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea></td>", extfix.str());
	form.append("</tr></table>");
	form.append("</td></tr>");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CTpEspServer::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CTpEspServer::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_Name.marshall(rpc_resp, "Name", "", "", "");
	m_Description.marshall(rpc_resp, "Description", "", "", "");
	m_Build.marshall(rpc_resp, "Build", "", "", "");
	m_Type.marshall(rpc_resp, "Type", "", "", "");
	m_Path.marshall(rpc_resp, "Path", "", "", "");
	m_LogDirectory.marshall(rpc_resp, "LogDirectory", "", "", "");
	m_TpMachines.marshall(rpc_resp, "TpMachines", "TpMachine");
	m_TpBindings.marshall(rpc_resp, "TpBindings", "TpBinding");
}


void CTpEspServer::copy(CTpEspServer &from)
{
	m_Name.copy(from.m_Name);
	m_Description.copy(from.m_Description);
	m_Build.copy(from.m_Build);
	m_Type.copy(from.m_Type);
	m_Path.copy(from.m_Path);
	m_LogDirectory.copy(from.m_LogDirectory);
	m_TpMachines.copy(from.m_TpMachines);
	m_TpBindings.copy(from.m_TpBindings);
}


void CTpEspServer::copy(IConstTpEspServer &ifrom)
{
	setName(ifrom.getName());
	setDescription(ifrom.getDescription());
	setBuild(ifrom.getBuild());
	setType(ifrom.getType());
	setPath(ifrom.getPath());
	setLogDirectory(ifrom.getLogDirectory());
	setTpMachines(ifrom.getTpMachines());
	setTpBindings(ifrom.getTpBindings());
}


void CTpEspServer::getAttributes(IProperties &attributes)
{
}


void CTpEspServer::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_Name.toStr(ctx, buffer, "Name", "", true, "", "");
	m_Description.toStr(ctx, buffer, "Description", "", true, "", "");
	m_Build.toStr(ctx, buffer, "Build", "", true, "", "");
	m_Type.toStr(ctx, buffer, "Type", "", true, "", "");
	m_Path.toStr(ctx, buffer, "Path", "", true, "", "");
	m_LogDirectory.toStr(ctx, buffer, "LogDirectory", "", true, "", "");
	m_TpMachines.toStr(ctx, buffer, "TpMachines", "TpMachine");
	m_TpBindings.toStr(ctx, buffer, "TpBindings", "TpBinding");
}


void CTpEspServer::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CTpEspServer::serializer(IEspContext* ctx, IConstTpEspServer &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<TpEspServer>");
	// field Name
	{
		const char* s = src.getName();
		if (s && *s)
		{
			buffer.append("<Name>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Name>");
		}
	}
	// field Description
	{
		const char* s = src.getDescription();
		if (s && *s)
		{
			buffer.append("<Description>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Description>");
		}
	}
	// field Build
	{
		const char* s = src.getBuild();
		if (s && *s)
		{
			buffer.append("<Build>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Build>");
		}
	}
	// field Type
	{
		const char* s = src.getType();
		if (s && *s)
		{
			buffer.append("<Type>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Type>");
		}
	}
	// field Path
	{
		const char* s = src.getPath();
		if (s && *s)
		{
			buffer.append("<Path>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Path>");
		}
	}
	// field LogDirectory
	{
		const char* s = src.getLogDirectory();
		if (s && *s)
		{
			buffer.append("<LogDirectory>");
			encodeUtf8XML(s,buffer);
			buffer.append("</LogDirectory>");
		}
	}
	// field TpMachines
	{
		IArrayOf<IConstTpMachine>& v = src.getTpMachines();
		int size = v.length();
		if (size>0)
			buffer.append("<TpMachines>");
		for (int i=0;i<size;i++)
		{
			buffer.append("<Item>");
			CTpMachine::serializer(ctx,v.item(i),buffer,false);
			buffer.append("</Item>");
		}
		if (size>0)
			buffer.append("</TpMachines>");
	}
	// field TpBindings
	{
		IArrayOf<IConstTpBinding>& v = src.getTpBindings();
		int size = v.length();
		if (size>0)
			buffer.append("<TpBindings>");
		for (int i=0;i<size;i++)
		{
			buffer.append("<Item>");
			CTpBinding::serializer(ctx,v.item(i),buffer,false);
			buffer.append("</Item>");
		}
		if (size>0)
			buffer.append("</TpBindings>");
	}
	if (keepRootTag)
		buffer.append("</TpEspServer>");
}

bool CTpEspServer::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_Name.unmarshall(rpc_request, "Name", basepath);
	hasValue |= m_Description.unmarshall(rpc_request, "Description", basepath);
	hasValue |= m_Build.unmarshall(rpc_request, "Build", basepath);
	hasValue |= m_Type.unmarshall(rpc_request, "Type", basepath);
	hasValue |= m_Path.unmarshall(rpc_request, "Path", basepath);
	hasValue |= m_LogDirectory.unmarshall(rpc_request, "LogDirectory", basepath);
	hasValue |= m_TpMachines.unmarshall(rpc_request, "TpMachines", basepath);
	hasValue |= m_TpBindings.unmarshall(rpc_request, "TpBindings", basepath);
	return hasValue;
}

bool CTpEspServer::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Name.unmarshall(ctx, soapval, "Name");
	hasValue |= m_Description.unmarshall(ctx, soapval, "Description");
	hasValue |= m_Build.unmarshall(ctx, soapval, "Build");
	hasValue |= m_Type.unmarshall(ctx, soapval, "Type");
	hasValue |= m_Path.unmarshall(ctx, soapval, "Path");
	hasValue |= m_LogDirectory.unmarshall(ctx, soapval, "LogDirectory");
	hasValue |= m_TpMachines.unmarshall(ctx, soapval, "TpMachines");
	hasValue |= m_TpBindings.unmarshall(ctx, soapval, "TpBindings");
	return hasValue;
}

bool CTpEspServer::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Name.unmarshall(ctx, params, attachments, "Name", basepath);
	hasValue |= m_Description.unmarshall(ctx, params, attachments, "Description", basepath);
	hasValue |= m_Build.unmarshall(ctx, params, attachments, "Build", basepath);
	hasValue |= m_Type.unmarshall(ctx, params, attachments, "Type", basepath);
	hasValue |= m_Path.unmarshall(ctx, params, attachments, "Path", basepath);
	hasValue |= m_LogDirectory.unmarshall(ctx, params, attachments, "LogDirectory", basepath);
	hasValue |= m_TpMachines.unmarshall(ctx, params, attachments, "TpMachines", basepath);
	hasValue |= m_TpBindings.unmarshall(ctx, params, attachments, "TpBindings", basepath);
	return hasValue;
}

const char * CTpEspServer::getName() { return m_Name.query();}
const char * CTpEspServer::getDescription() { return m_Description.query();}
const char * CTpEspServer::getBuild() { return m_Build.query();}
const char * CTpEspServer::getType() { return m_Type.query();}
const char * CTpEspServer::getPath() { return m_Path.query();}
const char * CTpEspServer::getLogDirectory() { return m_LogDirectory.query();}
IArrayOf<IConstTpMachine> & CTpEspServer::getTpMachines() { return (IArrayOf<IConstTpMachine> &) m_TpMachines; }
IArrayOf<IConstTpBinding> & CTpEspServer::getTpBindings() { return (IArrayOf<IConstTpBinding> &) m_TpBindings; }
void CTpEspServer::setName(const char * val){ m_Name.set(val); }
void CTpEspServer::setDescription(const char * val){ m_Description.set(val); }
void CTpEspServer::setBuild(const char * val){ m_Build.set(val); }
void CTpEspServer::setType(const char * val){ m_Type.set(val); }
void CTpEspServer::setPath(const char * val){ m_Path.set(val); }
void CTpEspServer::setLogDirectory(const char * val){ m_LogDirectory.set(val); }
void CTpEspServer::setTpMachines(IArrayOf<IEspTpMachine> &val)
{
	m_TpMachines->kill();
	IArrayOf<IConstTpMachine> &target = m_TpMachines.getValue();
	ForEachItemIn(idx, val)
	{
		IEspTpMachine &item = (val).item(idx);
		item.Link();
		target.append(item);
	}
}
void CTpEspServer::setTpMachines(IArrayOf<IConstTpMachine> &val)
{
	m_TpMachines->kill();
	IArrayOf<IConstTpMachine> &target = m_TpMachines.getValue();
	ForEachItemIn(idx, val)
	{
		IConstTpMachine &item = val.item(idx);
		item.Link();
		target.append(item);
	}
}
void CTpEspServer::setTpBindings(IArrayOf<IEspTpBinding> &val)
{
	m_TpBindings->kill();
	IArrayOf<IConstTpBinding> &target = m_TpBindings.getValue();
	ForEachItemIn(idx, val)
	{
		IEspTpBinding &item = (val).item(idx);
		item.Link();
		target.append(item);
	}
}
void CTpEspServer::setTpBindings(IArrayOf<IConstTpBinding> &val)
{
	m_TpBindings->kill();
	IArrayOf<IConstTpBinding> &target = m_TpBindings.getValue();
	ForEachItemIn(idx, val)
	{
		IConstTpBinding &item = val.item(idx);
		item.Link();
		target.append(item);
	}
}
extern "C"  IEspTpEspServer *createTpEspServer(const char *serv, const char *msgname){return ((IEspTpEspServer *)new CTpEspServer(serv /*, msgname*/));}
extern "C"  IClientTpEspServer *createClientTpEspServer(const char *serv, const char *msgname){return ((IClientTpEspServer *)new CTpEspServer(serv /*, msgname*/));}

//=======================================================
// class CTpDfuServer Implementation
//=======================================================

CTpDfuServer::CTpDfuServer(const char *serviceName, IRpcMessageBinding *init)
	: m_Name(nilIgnore),m_Description(nilIgnore),m_Build(nilIgnore),m_Queue(nilIgnore),m_Type(nilIgnore),m_Path(nilIgnore),m_LogDirectory(nilIgnore),m_TpMachines(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("TpDfuServer");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CTpDfuServer::CTpDfuServer(const char *serviceName, const char *bc)
	: m_Name(nilIgnore),m_Description(nilIgnore),m_Build(nilIgnore),m_Queue(nilIgnore),m_Type(nilIgnore),m_Path(nilIgnore),m_LogDirectory(nilIgnore),m_TpMachines(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("TpDfuServer");
}

StringBuffer &CTpDfuServer::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:complexType name=\"%s\">\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Name\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Description\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Build\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Queue\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Type\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Path\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"LogDirectory\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"TpMachines\" type=\"tns:ArrayOfTpMachine\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType>\n");
		}
	}
	if (!(flags & 0x10)  || (flags & 0x100))
	{
		CTpMachine::getXsdDefinition(context, request, schema, added);
	}
	if (added.getValue("TpMachine") && added.getValue("ArrayOfTpMachine")==NULL) {
		schema.append("<xsd:complexType name=\"ArrayOfTpMachine\">\n");
		schema.append("<xsd:sequence>\n");
		schema.append("<xsd:element minOccurs=\"0\" maxOccurs=\"unbounded\" name=\"TpMachine\" type=\"tns:TpMachine\"/>\n");
		schema.append("</xsd:sequence>\n");
		schema.append("</xsd:complexType>\n");
		added.setValue("ArrayOfTpMachine",1);
	}
	return schema;
}

void CTpDfuServer::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CTpDfuServer::getMapInfo(IMapInfo& info, BoolHash& added)
{
	if (!added.getValue("TpMachine"))
	{
		added.setValue("TpMachine",1);
		CTpMachine::getMapInfo(info,added);
	}
}

StringBuffer &CTpDfuServer::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Name");
	form.appendf("  <tr><td><b>Name: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Description");
	form.appendf("  <tr><td><b>Description: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Build");
	form.appendf("  <tr><td><b>Build: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Queue");
	form.appendf("  <tr><td><b>Queue: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Type");
	form.appendf("  <tr><td><b>Type: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Path");
	form.appendf("  <tr><td><b>Path: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("LogDirectory");
	form.appendf("  <tr><td><b>LogDirectory: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("TpMachines");
	form.appendf("<tr><td><b>TpMachines: </b></td><td>");
	form.appendf("<table><tr><td><textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea></td>", extfix.str());
	form.append("</tr></table>");
	form.append("</td></tr>");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CTpDfuServer::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CTpDfuServer::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_Name.marshall(rpc_resp, "Name", "", "", "");
	m_Description.marshall(rpc_resp, "Description", "", "", "");
	m_Build.marshall(rpc_resp, "Build", "", "", "");
	m_Queue.marshall(rpc_resp, "Queue", "", "", "");
	m_Type.marshall(rpc_resp, "Type", "", "", "");
	m_Path.marshall(rpc_resp, "Path", "", "", "");
	m_LogDirectory.marshall(rpc_resp, "LogDirectory", "", "", "");
	m_TpMachines.marshall(rpc_resp, "TpMachines", "TpMachine");
}


void CTpDfuServer::copy(CTpDfuServer &from)
{
	m_Name.copy(from.m_Name);
	m_Description.copy(from.m_Description);
	m_Build.copy(from.m_Build);
	m_Queue.copy(from.m_Queue);
	m_Type.copy(from.m_Type);
	m_Path.copy(from.m_Path);
	m_LogDirectory.copy(from.m_LogDirectory);
	m_TpMachines.copy(from.m_TpMachines);
}


void CTpDfuServer::copy(IConstTpDfuServer &ifrom)
{
	setName(ifrom.getName());
	setDescription(ifrom.getDescription());
	setBuild(ifrom.getBuild());
	setQueue(ifrom.getQueue());
	setType(ifrom.getType());
	setPath(ifrom.getPath());
	setLogDirectory(ifrom.getLogDirectory());
	setTpMachines(ifrom.getTpMachines());
}


void CTpDfuServer::getAttributes(IProperties &attributes)
{
}


void CTpDfuServer::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_Name.toStr(ctx, buffer, "Name", "", true, "", "");
	m_Description.toStr(ctx, buffer, "Description", "", true, "", "");
	m_Build.toStr(ctx, buffer, "Build", "", true, "", "");
	m_Queue.toStr(ctx, buffer, "Queue", "", true, "", "");
	m_Type.toStr(ctx, buffer, "Type", "", true, "", "");
	m_Path.toStr(ctx, buffer, "Path", "", true, "", "");
	m_LogDirectory.toStr(ctx, buffer, "LogDirectory", "", true, "", "");
	m_TpMachines.toStr(ctx, buffer, "TpMachines", "TpMachine");
}


void CTpDfuServer::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CTpDfuServer::serializer(IEspContext* ctx, IConstTpDfuServer &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<TpDfuServer>");
	// field Name
	{
		const char* s = src.getName();
		if (s && *s)
		{
			buffer.append("<Name>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Name>");
		}
	}
	// field Description
	{
		const char* s = src.getDescription();
		if (s && *s)
		{
			buffer.append("<Description>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Description>");
		}
	}
	// field Build
	{
		const char* s = src.getBuild();
		if (s && *s)
		{
			buffer.append("<Build>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Build>");
		}
	}
	// field Queue
	{
		const char* s = src.getQueue();
		if (s && *s)
		{
			buffer.append("<Queue>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Queue>");
		}
	}
	// field Type
	{
		const char* s = src.getType();
		if (s && *s)
		{
			buffer.append("<Type>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Type>");
		}
	}
	// field Path
	{
		const char* s = src.getPath();
		if (s && *s)
		{
			buffer.append("<Path>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Path>");
		}
	}
	// field LogDirectory
	{
		const char* s = src.getLogDirectory();
		if (s && *s)
		{
			buffer.append("<LogDirectory>");
			encodeUtf8XML(s,buffer);
			buffer.append("</LogDirectory>");
		}
	}
	// field TpMachines
	{
		IArrayOf<IConstTpMachine>& v = src.getTpMachines();
		int size = v.length();
		if (size>0)
			buffer.append("<TpMachines>");
		for (int i=0;i<size;i++)
		{
			buffer.append("<Item>");
			CTpMachine::serializer(ctx,v.item(i),buffer,false);
			buffer.append("</Item>");
		}
		if (size>0)
			buffer.append("</TpMachines>");
	}
	if (keepRootTag)
		buffer.append("</TpDfuServer>");
}

bool CTpDfuServer::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_Name.unmarshall(rpc_request, "Name", basepath);
	hasValue |= m_Description.unmarshall(rpc_request, "Description", basepath);
	hasValue |= m_Build.unmarshall(rpc_request, "Build", basepath);
	hasValue |= m_Queue.unmarshall(rpc_request, "Queue", basepath);
	hasValue |= m_Type.unmarshall(rpc_request, "Type", basepath);
	hasValue |= m_Path.unmarshall(rpc_request, "Path", basepath);
	hasValue |= m_LogDirectory.unmarshall(rpc_request, "LogDirectory", basepath);
	hasValue |= m_TpMachines.unmarshall(rpc_request, "TpMachines", basepath);
	return hasValue;
}

bool CTpDfuServer::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Name.unmarshall(ctx, soapval, "Name");
	hasValue |= m_Description.unmarshall(ctx, soapval, "Description");
	hasValue |= m_Build.unmarshall(ctx, soapval, "Build");
	hasValue |= m_Queue.unmarshall(ctx, soapval, "Queue");
	hasValue |= m_Type.unmarshall(ctx, soapval, "Type");
	hasValue |= m_Path.unmarshall(ctx, soapval, "Path");
	hasValue |= m_LogDirectory.unmarshall(ctx, soapval, "LogDirectory");
	hasValue |= m_TpMachines.unmarshall(ctx, soapval, "TpMachines");
	return hasValue;
}

bool CTpDfuServer::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Name.unmarshall(ctx, params, attachments, "Name", basepath);
	hasValue |= m_Description.unmarshall(ctx, params, attachments, "Description", basepath);
	hasValue |= m_Build.unmarshall(ctx, params, attachments, "Build", basepath);
	hasValue |= m_Queue.unmarshall(ctx, params, attachments, "Queue", basepath);
	hasValue |= m_Type.unmarshall(ctx, params, attachments, "Type", basepath);
	hasValue |= m_Path.unmarshall(ctx, params, attachments, "Path", basepath);
	hasValue |= m_LogDirectory.unmarshall(ctx, params, attachments, "LogDirectory", basepath);
	hasValue |= m_TpMachines.unmarshall(ctx, params, attachments, "TpMachines", basepath);
	return hasValue;
}

const char * CTpDfuServer::getName() { return m_Name.query();}
const char * CTpDfuServer::getDescription() { return m_Description.query();}
const char * CTpDfuServer::getBuild() { return m_Build.query();}
const char * CTpDfuServer::getQueue() { return m_Queue.query();}
const char * CTpDfuServer::getType() { return m_Type.query();}
const char * CTpDfuServer::getPath() { return m_Path.query();}
const char * CTpDfuServer::getLogDirectory() { return m_LogDirectory.query();}
IArrayOf<IConstTpMachine> & CTpDfuServer::getTpMachines() { return (IArrayOf<IConstTpMachine> &) m_TpMachines; }
void CTpDfuServer::setName(const char * val){ m_Name.set(val); }
void CTpDfuServer::setDescription(const char * val){ m_Description.set(val); }
void CTpDfuServer::setBuild(const char * val){ m_Build.set(val); }
void CTpDfuServer::setQueue(const char * val){ m_Queue.set(val); }
void CTpDfuServer::setType(const char * val){ m_Type.set(val); }
void CTpDfuServer::setPath(const char * val){ m_Path.set(val); }
void CTpDfuServer::setLogDirectory(const char * val){ m_LogDirectory.set(val); }
void CTpDfuServer::setTpMachines(IArrayOf<IEspTpMachine> &val)
{
	m_TpMachines->kill();
	IArrayOf<IConstTpMachine> &target = m_TpMachines.getValue();
	ForEachItemIn(idx, val)
	{
		IEspTpMachine &item = (val).item(idx);
		item.Link();
		target.append(item);
	}
}
void CTpDfuServer::setTpMachines(IArrayOf<IConstTpMachine> &val)
{
	m_TpMachines->kill();
	IArrayOf<IConstTpMachine> &target = m_TpMachines.getValue();
	ForEachItemIn(idx, val)
	{
		IConstTpMachine &item = val.item(idx);
		item.Link();
		target.append(item);
	}
}
extern "C"  IEspTpDfuServer *createTpDfuServer(const char *serv, const char *msgname){return ((IEspTpDfuServer *)new CTpDfuServer(serv /*, msgname*/));}
extern "C"  IClientTpDfuServer *createClientTpDfuServer(const char *serv, const char *msgname){return ((IClientTpDfuServer *)new CTpDfuServer(serv /*, msgname*/));}

//=======================================================
// class CTpSashaServer Implementation
//=======================================================

CTpSashaServer::CTpSashaServer(const char *serviceName, IRpcMessageBinding *init)
	: m_Name(nilIgnore),m_Description(nilIgnore),m_Build(nilIgnore),m_Path(nilIgnore),m_LogDirectory(nilIgnore),m_TpMachines(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("TpSashaServer");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CTpSashaServer::CTpSashaServer(const char *serviceName, const char *bc)
	: m_Name(nilIgnore),m_Description(nilIgnore),m_Build(nilIgnore),m_Path(nilIgnore),m_LogDirectory(nilIgnore),m_TpMachines(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("TpSashaServer");
}

StringBuffer &CTpSashaServer::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:complexType name=\"%s\">\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Name\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Description\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Build\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Path\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"LogDirectory\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"TpMachines\" type=\"tns:ArrayOfTpMachine\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType>\n");
		}
	}
	if (!(flags & 0x10)  || (flags & 0x100))
	{
		CTpMachine::getXsdDefinition(context, request, schema, added);
	}
	if (added.getValue("TpMachine") && added.getValue("ArrayOfTpMachine")==NULL) {
		schema.append("<xsd:complexType name=\"ArrayOfTpMachine\">\n");
		schema.append("<xsd:sequence>\n");
		schema.append("<xsd:element minOccurs=\"0\" maxOccurs=\"unbounded\" name=\"TpMachine\" type=\"tns:TpMachine\"/>\n");
		schema.append("</xsd:sequence>\n");
		schema.append("</xsd:complexType>\n");
		added.setValue("ArrayOfTpMachine",1);
	}
	return schema;
}

void CTpSashaServer::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CTpSashaServer::getMapInfo(IMapInfo& info, BoolHash& added)
{
	if (!added.getValue("TpMachine"))
	{
		added.setValue("TpMachine",1);
		CTpMachine::getMapInfo(info,added);
	}
}

StringBuffer &CTpSashaServer::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Name");
	form.appendf("  <tr><td><b>Name: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Description");
	form.appendf("  <tr><td><b>Description: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Build");
	form.appendf("  <tr><td><b>Build: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Path");
	form.appendf("  <tr><td><b>Path: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("LogDirectory");
	form.appendf("  <tr><td><b>LogDirectory: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("TpMachines");
	form.appendf("<tr><td><b>TpMachines: </b></td><td>");
	form.appendf("<table><tr><td><textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea></td>", extfix.str());
	form.append("</tr></table>");
	form.append("</td></tr>");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CTpSashaServer::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CTpSashaServer::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_Name.marshall(rpc_resp, "Name", "", "", "");
	m_Description.marshall(rpc_resp, "Description", "", "", "");
	m_Build.marshall(rpc_resp, "Build", "", "", "");
	m_Path.marshall(rpc_resp, "Path", "", "", "");
	m_LogDirectory.marshall(rpc_resp, "LogDirectory", "", "", "");
	m_TpMachines.marshall(rpc_resp, "TpMachines", "TpMachine");
}


void CTpSashaServer::copy(CTpSashaServer &from)
{
	m_Name.copy(from.m_Name);
	m_Description.copy(from.m_Description);
	m_Build.copy(from.m_Build);
	m_Path.copy(from.m_Path);
	m_LogDirectory.copy(from.m_LogDirectory);
	m_TpMachines.copy(from.m_TpMachines);
}


void CTpSashaServer::copy(IConstTpSashaServer &ifrom)
{
	setName(ifrom.getName());
	setDescription(ifrom.getDescription());
	setBuild(ifrom.getBuild());
	setPath(ifrom.getPath());
	setLogDirectory(ifrom.getLogDirectory());
	setTpMachines(ifrom.getTpMachines());
}


void CTpSashaServer::getAttributes(IProperties &attributes)
{
}


void CTpSashaServer::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_Name.toStr(ctx, buffer, "Name", "", true, "", "");
	m_Description.toStr(ctx, buffer, "Description", "", true, "", "");
	m_Build.toStr(ctx, buffer, "Build", "", true, "", "");
	m_Path.toStr(ctx, buffer, "Path", "", true, "", "");
	m_LogDirectory.toStr(ctx, buffer, "LogDirectory", "", true, "", "");
	m_TpMachines.toStr(ctx, buffer, "TpMachines", "TpMachine");
}


void CTpSashaServer::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CTpSashaServer::serializer(IEspContext* ctx, IConstTpSashaServer &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<TpSashaServer>");
	// field Name
	{
		const char* s = src.getName();
		if (s && *s)
		{
			buffer.append("<Name>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Name>");
		}
	}
	// field Description
	{
		const char* s = src.getDescription();
		if (s && *s)
		{
			buffer.append("<Description>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Description>");
		}
	}
	// field Build
	{
		const char* s = src.getBuild();
		if (s && *s)
		{
			buffer.append("<Build>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Build>");
		}
	}
	// field Path
	{
		const char* s = src.getPath();
		if (s && *s)
		{
			buffer.append("<Path>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Path>");
		}
	}
	// field LogDirectory
	{
		const char* s = src.getLogDirectory();
		if (s && *s)
		{
			buffer.append("<LogDirectory>");
			encodeUtf8XML(s,buffer);
			buffer.append("</LogDirectory>");
		}
	}
	// field TpMachines
	{
		IArrayOf<IConstTpMachine>& v = src.getTpMachines();
		int size = v.length();
		if (size>0)
			buffer.append("<TpMachines>");
		for (int i=0;i<size;i++)
		{
			buffer.append("<Item>");
			CTpMachine::serializer(ctx,v.item(i),buffer,false);
			buffer.append("</Item>");
		}
		if (size>0)
			buffer.append("</TpMachines>");
	}
	if (keepRootTag)
		buffer.append("</TpSashaServer>");
}

bool CTpSashaServer::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_Name.unmarshall(rpc_request, "Name", basepath);
	hasValue |= m_Description.unmarshall(rpc_request, "Description", basepath);
	hasValue |= m_Build.unmarshall(rpc_request, "Build", basepath);
	hasValue |= m_Path.unmarshall(rpc_request, "Path", basepath);
	hasValue |= m_LogDirectory.unmarshall(rpc_request, "LogDirectory", basepath);
	hasValue |= m_TpMachines.unmarshall(rpc_request, "TpMachines", basepath);
	return hasValue;
}

bool CTpSashaServer::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Name.unmarshall(ctx, soapval, "Name");
	hasValue |= m_Description.unmarshall(ctx, soapval, "Description");
	hasValue |= m_Build.unmarshall(ctx, soapval, "Build");
	hasValue |= m_Path.unmarshall(ctx, soapval, "Path");
	hasValue |= m_LogDirectory.unmarshall(ctx, soapval, "LogDirectory");
	hasValue |= m_TpMachines.unmarshall(ctx, soapval, "TpMachines");
	return hasValue;
}

bool CTpSashaServer::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Name.unmarshall(ctx, params, attachments, "Name", basepath);
	hasValue |= m_Description.unmarshall(ctx, params, attachments, "Description", basepath);
	hasValue |= m_Build.unmarshall(ctx, params, attachments, "Build", basepath);
	hasValue |= m_Path.unmarshall(ctx, params, attachments, "Path", basepath);
	hasValue |= m_LogDirectory.unmarshall(ctx, params, attachments, "LogDirectory", basepath);
	hasValue |= m_TpMachines.unmarshall(ctx, params, attachments, "TpMachines", basepath);
	return hasValue;
}

const char * CTpSashaServer::getName() { return m_Name.query();}
const char * CTpSashaServer::getDescription() { return m_Description.query();}
const char * CTpSashaServer::getBuild() { return m_Build.query();}
const char * CTpSashaServer::getPath() { return m_Path.query();}
const char * CTpSashaServer::getLogDirectory() { return m_LogDirectory.query();}
IArrayOf<IConstTpMachine> & CTpSashaServer::getTpMachines() { return (IArrayOf<IConstTpMachine> &) m_TpMachines; }
void CTpSashaServer::setName(const char * val){ m_Name.set(val); }
void CTpSashaServer::setDescription(const char * val){ m_Description.set(val); }
void CTpSashaServer::setBuild(const char * val){ m_Build.set(val); }
void CTpSashaServer::setPath(const char * val){ m_Path.set(val); }
void CTpSashaServer::setLogDirectory(const char * val){ m_LogDirectory.set(val); }
void CTpSashaServer::setTpMachines(IArrayOf<IEspTpMachine> &val)
{
	m_TpMachines->kill();
	IArrayOf<IConstTpMachine> &target = m_TpMachines.getValue();
	ForEachItemIn(idx, val)
	{
		IEspTpMachine &item = (val).item(idx);
		item.Link();
		target.append(item);
	}
}
void CTpSashaServer::setTpMachines(IArrayOf<IConstTpMachine> &val)
{
	m_TpMachines->kill();
	IArrayOf<IConstTpMachine> &target = m_TpMachines.getValue();
	ForEachItemIn(idx, val)
	{
		IConstTpMachine &item = val.item(idx);
		item.Link();
		target.append(item);
	}
}
extern "C"  IEspTpSashaServer *createTpSashaServer(const char *serv, const char *msgname){return ((IEspTpSashaServer *)new CTpSashaServer(serv /*, msgname*/));}
extern "C"  IClientTpSashaServer *createClientTpSashaServer(const char *serv, const char *msgname){return ((IClientTpSashaServer *)new CTpSashaServer(serv /*, msgname*/));}

//=======================================================
// class CTpLdapServer Implementation
//=======================================================

CTpLdapServer::CTpLdapServer(const char *serviceName, IRpcMessageBinding *init)
	: m_Name(nilIgnore),m_Description(nilIgnore),m_Build(nilIgnore),m_Path(nilIgnore),m_TpMachines(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("TpLdapServer");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CTpLdapServer::CTpLdapServer(const char *serviceName, const char *bc)
	: m_Name(nilIgnore),m_Description(nilIgnore),m_Build(nilIgnore),m_Path(nilIgnore),m_TpMachines(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("TpLdapServer");
}

StringBuffer &CTpLdapServer::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:complexType name=\"%s\">\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Name\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Description\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Build\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Path\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"TpMachines\" type=\"tns:ArrayOfTpMachine\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType>\n");
		}
	}
	if (!(flags & 0x10)  || (flags & 0x100))
	{
		CTpMachine::getXsdDefinition(context, request, schema, added);
	}
	if (added.getValue("TpMachine") && added.getValue("ArrayOfTpMachine")==NULL) {
		schema.append("<xsd:complexType name=\"ArrayOfTpMachine\">\n");
		schema.append("<xsd:sequence>\n");
		schema.append("<xsd:element minOccurs=\"0\" maxOccurs=\"unbounded\" name=\"TpMachine\" type=\"tns:TpMachine\"/>\n");
		schema.append("</xsd:sequence>\n");
		schema.append("</xsd:complexType>\n");
		added.setValue("ArrayOfTpMachine",1);
	}
	return schema;
}

void CTpLdapServer::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CTpLdapServer::getMapInfo(IMapInfo& info, BoolHash& added)
{
	if (!added.getValue("TpMachine"))
	{
		added.setValue("TpMachine",1);
		CTpMachine::getMapInfo(info,added);
	}
}

StringBuffer &CTpLdapServer::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Name");
	form.appendf("  <tr><td><b>Name: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Description");
	form.appendf("  <tr><td><b>Description: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Build");
	form.appendf("  <tr><td><b>Build: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Path");
	form.appendf("  <tr><td><b>Path: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("TpMachines");
	form.appendf("<tr><td><b>TpMachines: </b></td><td>");
	form.appendf("<table><tr><td><textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea></td>", extfix.str());
	form.append("</tr></table>");
	form.append("</td></tr>");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CTpLdapServer::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CTpLdapServer::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_Name.marshall(rpc_resp, "Name", "", "", "");
	m_Description.marshall(rpc_resp, "Description", "", "", "");
	m_Build.marshall(rpc_resp, "Build", "", "", "");
	m_Path.marshall(rpc_resp, "Path", "", "", "");
	m_TpMachines.marshall(rpc_resp, "TpMachines", "TpMachine");
}


void CTpLdapServer::copy(CTpLdapServer &from)
{
	m_Name.copy(from.m_Name);
	m_Description.copy(from.m_Description);
	m_Build.copy(from.m_Build);
	m_Path.copy(from.m_Path);
	m_TpMachines.copy(from.m_TpMachines);
}


void CTpLdapServer::copy(IConstTpLdapServer &ifrom)
{
	setName(ifrom.getName());
	setDescription(ifrom.getDescription());
	setBuild(ifrom.getBuild());
	setPath(ifrom.getPath());
	setTpMachines(ifrom.getTpMachines());
}


void CTpLdapServer::getAttributes(IProperties &attributes)
{
}


void CTpLdapServer::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_Name.toStr(ctx, buffer, "Name", "", true, "", "");
	m_Description.toStr(ctx, buffer, "Description", "", true, "", "");
	m_Build.toStr(ctx, buffer, "Build", "", true, "", "");
	m_Path.toStr(ctx, buffer, "Path", "", true, "", "");
	m_TpMachines.toStr(ctx, buffer, "TpMachines", "TpMachine");
}


void CTpLdapServer::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CTpLdapServer::serializer(IEspContext* ctx, IConstTpLdapServer &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<TpLdapServer>");
	// field Name
	{
		const char* s = src.getName();
		if (s && *s)
		{
			buffer.append("<Name>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Name>");
		}
	}
	// field Description
	{
		const char* s = src.getDescription();
		if (s && *s)
		{
			buffer.append("<Description>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Description>");
		}
	}
	// field Build
	{
		const char* s = src.getBuild();
		if (s && *s)
		{
			buffer.append("<Build>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Build>");
		}
	}
	// field Path
	{
		const char* s = src.getPath();
		if (s && *s)
		{
			buffer.append("<Path>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Path>");
		}
	}
	// field TpMachines
	{
		IArrayOf<IConstTpMachine>& v = src.getTpMachines();
		int size = v.length();
		if (size>0)
			buffer.append("<TpMachines>");
		for (int i=0;i<size;i++)
		{
			buffer.append("<Item>");
			CTpMachine::serializer(ctx,v.item(i),buffer,false);
			buffer.append("</Item>");
		}
		if (size>0)
			buffer.append("</TpMachines>");
	}
	if (keepRootTag)
		buffer.append("</TpLdapServer>");
}

bool CTpLdapServer::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_Name.unmarshall(rpc_request, "Name", basepath);
	hasValue |= m_Description.unmarshall(rpc_request, "Description", basepath);
	hasValue |= m_Build.unmarshall(rpc_request, "Build", basepath);
	hasValue |= m_Path.unmarshall(rpc_request, "Path", basepath);
	hasValue |= m_TpMachines.unmarshall(rpc_request, "TpMachines", basepath);
	return hasValue;
}

bool CTpLdapServer::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Name.unmarshall(ctx, soapval, "Name");
	hasValue |= m_Description.unmarshall(ctx, soapval, "Description");
	hasValue |= m_Build.unmarshall(ctx, soapval, "Build");
	hasValue |= m_Path.unmarshall(ctx, soapval, "Path");
	hasValue |= m_TpMachines.unmarshall(ctx, soapval, "TpMachines");
	return hasValue;
}

bool CTpLdapServer::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Name.unmarshall(ctx, params, attachments, "Name", basepath);
	hasValue |= m_Description.unmarshall(ctx, params, attachments, "Description", basepath);
	hasValue |= m_Build.unmarshall(ctx, params, attachments, "Build", basepath);
	hasValue |= m_Path.unmarshall(ctx, params, attachments, "Path", basepath);
	hasValue |= m_TpMachines.unmarshall(ctx, params, attachments, "TpMachines", basepath);
	return hasValue;
}

const char * CTpLdapServer::getName() { return m_Name.query();}
const char * CTpLdapServer::getDescription() { return m_Description.query();}
const char * CTpLdapServer::getBuild() { return m_Build.query();}
const char * CTpLdapServer::getPath() { return m_Path.query();}
IArrayOf<IConstTpMachine> & CTpLdapServer::getTpMachines() { return (IArrayOf<IConstTpMachine> &) m_TpMachines; }
void CTpLdapServer::setName(const char * val){ m_Name.set(val); }
void CTpLdapServer::setDescription(const char * val){ m_Description.set(val); }
void CTpLdapServer::setBuild(const char * val){ m_Build.set(val); }
void CTpLdapServer::setPath(const char * val){ m_Path.set(val); }
void CTpLdapServer::setTpMachines(IArrayOf<IEspTpMachine> &val)
{
	m_TpMachines->kill();
	IArrayOf<IConstTpMachine> &target = m_TpMachines.getValue();
	ForEachItemIn(idx, val)
	{
		IEspTpMachine &item = (val).item(idx);
		item.Link();
		target.append(item);
	}
}
void CTpLdapServer::setTpMachines(IArrayOf<IConstTpMachine> &val)
{
	m_TpMachines->kill();
	IArrayOf<IConstTpMachine> &target = m_TpMachines.getValue();
	ForEachItemIn(idx, val)
	{
		IConstTpMachine &item = val.item(idx);
		item.Link();
		target.append(item);
	}
}
extern "C"  IEspTpLdapServer *createTpLdapServer(const char *serv, const char *msgname){return ((IEspTpLdapServer *)new CTpLdapServer(serv /*, msgname*/));}
extern "C"  IClientTpLdapServer *createClientTpLdapServer(const char *serv, const char *msgname){return ((IClientTpLdapServer *)new CTpLdapServer(serv /*, msgname*/));}

//=======================================================
// class CTpDropZone Implementation
//=======================================================

CTpDropZone::CTpDropZone(const char *serviceName, IRpcMessageBinding *init)
	: m_Name(nilIgnore),m_Description(nilIgnore),m_Build(nilIgnore),m_Path(nilIgnore),m_ECLWatchVisible(nilIgnore),m_UMask(nilIgnore),m_TpMachines(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("TpDropZone");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CTpDropZone::CTpDropZone(const char *serviceName, const char *bc)
	: m_Name(nilIgnore),m_Description(nilIgnore),m_Build(nilIgnore),m_Path(nilIgnore),m_ECLWatchVisible(nilIgnore),m_UMask(nilIgnore),m_TpMachines(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("TpDropZone");
}

StringBuffer &CTpDropZone::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:complexType name=\"%s\">\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Name\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Description\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Build\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Path\" type=\"xsd:string\"/>\n");
		if (!context.suppressed("TpDropZone","ECLWatchVisible")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"ECLWatchVisible\" type=\"xsd:boolean\"/>\n");
		}
		if (!context.suppressed("TpDropZone","UMask")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"UMask\" type=\"xsd:string\"/>\n");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"TpMachines\" type=\"tns:ArrayOfTpMachine\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType>\n");
		}
	}
	if (!(flags & 0x10)  || (flags & 0x100))
	{
		CTpMachine::getXsdDefinition(context, request, schema, added);
	}
	if (added.getValue("TpMachine") && added.getValue("ArrayOfTpMachine")==NULL) {
		schema.append("<xsd:complexType name=\"ArrayOfTpMachine\">\n");
		schema.append("<xsd:sequence>\n");
		schema.append("<xsd:element minOccurs=\"0\" maxOccurs=\"unbounded\" name=\"TpMachine\" type=\"tns:TpMachine\"/>\n");
		schema.append("</xsd:sequence>\n");
		schema.append("</xsd:complexType>\n");
		added.setValue("ArrayOfTpMachine",1);
	}
	return schema;
}

void CTpDropZone::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CTpDropZone::getMapInfo(IMapInfo& info, BoolHash& added)
{
	info.addMinVersion("TpDropZone","ECLWatchVisible",1.26);
	info.addMinVersion("TpDropZone","UMask",1.26);
	if (!added.getValue("TpMachine"))
	{
		added.setValue("TpMachine",1);
		CTpMachine::getMapInfo(info,added);
	}
}

StringBuffer &CTpDropZone::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Name");
	form.appendf("  <tr><td><b>Name: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Description");
	form.appendf("  <tr><td><b>Description: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Build");
	form.appendf("  <tr><td><b>Build: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Path");
	form.appendf("  <tr><td><b>Path: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (!context.suppressed("TpDropZone","ECLWatchVisible")) {
		extfix.clear();
		if (prefix && *prefix)
			extfix.append(prefix).append(".");
		extfix.append("ECLWatchVisible");
		
	form.appendf("  <tr><td><b>ECLWatchVisible? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	}
	if (!context.suppressed("TpDropZone","UMask")) {
		extfix.clear();
		if (prefix && *prefix)
			extfix.append(prefix).append(".");
		extfix.append("UMask");
		form.appendf("  <tr><td><b>UMask: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
		form.append("</td></tr>\n");
	}
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("TpMachines");
	form.appendf("<tr><td><b>TpMachines: </b></td><td>");
	form.appendf("<table><tr><td><textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea></td>", extfix.str());
	form.append("</tr></table>");
	form.append("</td></tr>");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CTpDropZone::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CTpDropZone::serialize(IRpcMessage& rpc_resp)
{
	IEspContext* ctx = rpc_resp.queryContext();
	double clientVer= ctx ? ctx->getClientVersion() : -1; /* no context gets everything */
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_Name.marshall(rpc_resp, "Name", "", "", "");
	m_Description.marshall(rpc_resp, "Description", "", "", "");
	m_Build.marshall(rpc_resp, "Build", "", "", "");
	m_Path.marshall(rpc_resp, "Path", "", "", "");
	if ((clientVer==-1.0 || clientVer>=1.26))
		m_ECLWatchVisible.marshall(rpc_resp, "ECLWatchVisible", "", "", "");
	if ((clientVer==-1.0 || clientVer>=1.26))
		m_UMask.marshall(rpc_resp, "UMask", "", "", "");
	m_TpMachines.marshall(rpc_resp, "TpMachines", "TpMachine");
}


void CTpDropZone::copy(CTpDropZone &from)
{
	m_Name.copy(from.m_Name);
	m_Description.copy(from.m_Description);
	m_Build.copy(from.m_Build);
	m_Path.copy(from.m_Path);
	m_ECLWatchVisible.copy(from.m_ECLWatchVisible);
	m_UMask.copy(from.m_UMask);
	m_TpMachines.copy(from.m_TpMachines);
}


void CTpDropZone::copy(IConstTpDropZone &ifrom)
{
	setName(ifrom.getName());
	setDescription(ifrom.getDescription());
	setBuild(ifrom.getBuild());
	setPath(ifrom.getPath());
	setECLWatchVisible(ifrom.getECLWatchVisible());
	setUMask(ifrom.getUMask());
	setTpMachines(ifrom.getTpMachines());
}


void CTpDropZone::getAttributes(IProperties &attributes)
{
}


void CTpDropZone::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	double clientVer = ctx ? ctx->getClientVersion() : -1;
	m_Name.toStr(ctx, buffer, "Name", "", true, "", "");
	m_Description.toStr(ctx, buffer, "Description", "", true, "", "");
	m_Build.toStr(ctx, buffer, "Build", "", true, "", "");
	m_Path.toStr(ctx, buffer, "Path", "", true, "", "");
	if ((clientVer==-1.0 || clientVer>=1.26))
		m_ECLWatchVisible.toStr(ctx, buffer, "ECLWatchVisible", "", true, "", "");
	if ((clientVer==-1.0 || clientVer>=1.26))
		m_UMask.toStr(ctx, buffer, "UMask", "", true, "", "");
	m_TpMachines.toStr(ctx, buffer, "TpMachines", "TpMachine");
}


void CTpDropZone::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CTpDropZone::serializer(IEspContext* ctx, IConstTpDropZone &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<TpDropZone>");
	double clientVer = ctx ? ctx->getClientVersion() : -1;
	// field Name
	{
		const char* s = src.getName();
		if (s && *s)
		{
			buffer.append("<Name>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Name>");
		}
	}
	// field Description
	{
		const char* s = src.getDescription();
		if (s && *s)
		{
			buffer.append("<Description>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Description>");
		}
	}
	// field Build
	{
		const char* s = src.getBuild();
		if (s && *s)
		{
			buffer.append("<Build>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Build>");
		}
	}
	// field Path
	{
		const char* s = src.getPath();
		if (s && *s)
		{
			buffer.append("<Path>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Path>");
		}
	}
	// field ECLWatchVisible
	if ((clientVer==-1.0 || clientVer>=1.26))
	{
		bool b = src.getECLWatchVisible();
		if (b)
			buffer.appendf("<ECLWatchVisible>1</ECLWatchVisible>");
	}
	// field UMask
	if ((clientVer==-1.0 || clientVer>=1.26))
	{
		const char* s = src.getUMask();
		if (s && *s)
		{
			buffer.append("<UMask>");
			encodeUtf8XML(s,buffer);
			buffer.append("</UMask>");
		}
	}
	// field TpMachines
	{
		IArrayOf<IConstTpMachine>& v = src.getTpMachines();
		int size = v.length();
		if (size>0)
			buffer.append("<TpMachines>");
		for (int i=0;i<size;i++)
		{
			buffer.append("<Item>");
			CTpMachine::serializer(ctx,v.item(i),buffer,false);
			buffer.append("</Item>");
		}
		if (size>0)
			buffer.append("</TpMachines>");
	}
	if (keepRootTag)
		buffer.append("</TpDropZone>");
}

bool CTpDropZone::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_Name.unmarshall(rpc_request, "Name", basepath);
	hasValue |= m_Description.unmarshall(rpc_request, "Description", basepath);
	hasValue |= m_Build.unmarshall(rpc_request, "Build", basepath);
	hasValue |= m_Path.unmarshall(rpc_request, "Path", basepath);
	hasValue |= m_ECLWatchVisible.unmarshall(rpc_request, "ECLWatchVisible", basepath);
	hasValue |= m_UMask.unmarshall(rpc_request, "UMask", basepath);
	hasValue |= m_TpMachines.unmarshall(rpc_request, "TpMachines", basepath);
	return hasValue;
}

bool CTpDropZone::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Name.unmarshall(ctx, soapval, "Name");
	hasValue |= m_Description.unmarshall(ctx, soapval, "Description");
	hasValue |= m_Build.unmarshall(ctx, soapval, "Build");
	hasValue |= m_Path.unmarshall(ctx, soapval, "Path");
	hasValue |= m_ECLWatchVisible.unmarshall(ctx, soapval, "ECLWatchVisible");
	hasValue |= m_UMask.unmarshall(ctx, soapval, "UMask");
	hasValue |= m_TpMachines.unmarshall(ctx, soapval, "TpMachines");
	return hasValue;
}

bool CTpDropZone::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Name.unmarshall(ctx, params, attachments, "Name", basepath);
	hasValue |= m_Description.unmarshall(ctx, params, attachments, "Description", basepath);
	hasValue |= m_Build.unmarshall(ctx, params, attachments, "Build", basepath);
	hasValue |= m_Path.unmarshall(ctx, params, attachments, "Path", basepath);
	hasValue |= m_ECLWatchVisible.unmarshall(ctx, params, attachments, "ECLWatchVisible", basepath);
	hasValue |= m_UMask.unmarshall(ctx, params, attachments, "UMask", basepath);
	hasValue |= m_TpMachines.unmarshall(ctx, params, attachments, "TpMachines", basepath);
	return hasValue;
}

const char * CTpDropZone::getName() { return m_Name.query();}
const char * CTpDropZone::getDescription() { return m_Description.query();}
const char * CTpDropZone::getBuild() { return m_Build.query();}
const char * CTpDropZone::getPath() { return m_Path.query();}
bool CTpDropZone::getECLWatchVisible() { return m_ECLWatchVisible;}
const char * CTpDropZone::getUMask() { return m_UMask.query();}
IArrayOf<IConstTpMachine> & CTpDropZone::getTpMachines() { return (IArrayOf<IConstTpMachine> &) m_TpMachines; }
void CTpDropZone::setName(const char * val){ m_Name.set(val); }
void CTpDropZone::setDescription(const char * val){ m_Description.set(val); }
void CTpDropZone::setBuild(const char * val){ m_Build.set(val); }
void CTpDropZone::setPath(const char * val){ m_Path.set(val); }
void CTpDropZone::setECLWatchVisible(bool val){ m_ECLWatchVisible=val; }
void CTpDropZone::setUMask(const char * val){ m_UMask.set(val); }
void CTpDropZone::setTpMachines(IArrayOf<IEspTpMachine> &val)
{
	m_TpMachines->kill();
	IArrayOf<IConstTpMachine> &target = m_TpMachines.getValue();
	ForEachItemIn(idx, val)
	{
		IEspTpMachine &item = (val).item(idx);
		item.Link();
		target.append(item);
	}
}
void CTpDropZone::setTpMachines(IArrayOf<IConstTpMachine> &val)
{
	m_TpMachines->kill();
	IArrayOf<IConstTpMachine> &target = m_TpMachines.getValue();
	ForEachItemIn(idx, val)
	{
		IConstTpMachine &item = val.item(idx);
		item.Link();
		target.append(item);
	}
}
extern "C"  IEspTpDropZone *createTpDropZone(const char *serv, const char *msgname){return ((IEspTpDropZone *)new CTpDropZone(serv /*, msgname*/));}
extern "C"  IClientTpDropZone *createClientTpDropZone(const char *serv, const char *msgname){return ((IClientTpDropZone *)new CTpDropZone(serv /*, msgname*/));}

//=======================================================
// class CTpMySqlServer Implementation
//=======================================================

CTpMySqlServer::CTpMySqlServer(const char *serviceName, IRpcMessageBinding *init)
	: m_Name(nilIgnore),m_Description(nilIgnore),m_Build(nilIgnore),m_Path(nilIgnore),m_TpMachines(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("TpMySqlServer");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CTpMySqlServer::CTpMySqlServer(const char *serviceName, const char *bc)
	: m_Name(nilIgnore),m_Description(nilIgnore),m_Build(nilIgnore),m_Path(nilIgnore),m_TpMachines(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("TpMySqlServer");
}

StringBuffer &CTpMySqlServer::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:complexType name=\"%s\">\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Name\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Description\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Build\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Path\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"TpMachines\" type=\"tns:ArrayOfTpMachine\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType>\n");
		}
	}
	if (!(flags & 0x10)  || (flags & 0x100))
	{
		CTpMachine::getXsdDefinition(context, request, schema, added);
	}
	if (added.getValue("TpMachine") && added.getValue("ArrayOfTpMachine")==NULL) {
		schema.append("<xsd:complexType name=\"ArrayOfTpMachine\">\n");
		schema.append("<xsd:sequence>\n");
		schema.append("<xsd:element minOccurs=\"0\" maxOccurs=\"unbounded\" name=\"TpMachine\" type=\"tns:TpMachine\"/>\n");
		schema.append("</xsd:sequence>\n");
		schema.append("</xsd:complexType>\n");
		added.setValue("ArrayOfTpMachine",1);
	}
	return schema;
}

void CTpMySqlServer::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CTpMySqlServer::getMapInfo(IMapInfo& info, BoolHash& added)
{
	if (!added.getValue("TpMachine"))
	{
		added.setValue("TpMachine",1);
		CTpMachine::getMapInfo(info,added);
	}
}

StringBuffer &CTpMySqlServer::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Name");
	form.appendf("  <tr><td><b>Name: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Description");
	form.appendf("  <tr><td><b>Description: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Build");
	form.appendf("  <tr><td><b>Build: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Path");
	form.appendf("  <tr><td><b>Path: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("TpMachines");
	form.appendf("<tr><td><b>TpMachines: </b></td><td>");
	form.appendf("<table><tr><td><textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea></td>", extfix.str());
	form.append("</tr></table>");
	form.append("</td></tr>");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CTpMySqlServer::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CTpMySqlServer::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_Name.marshall(rpc_resp, "Name", "", "", "");
	m_Description.marshall(rpc_resp, "Description", "", "", "");
	m_Build.marshall(rpc_resp, "Build", "", "", "");
	m_Path.marshall(rpc_resp, "Path", "", "", "");
	m_TpMachines.marshall(rpc_resp, "TpMachines", "TpMachine");
}


void CTpMySqlServer::copy(CTpMySqlServer &from)
{
	m_Name.copy(from.m_Name);
	m_Description.copy(from.m_Description);
	m_Build.copy(from.m_Build);
	m_Path.copy(from.m_Path);
	m_TpMachines.copy(from.m_TpMachines);
}


void CTpMySqlServer::copy(IConstTpMySqlServer &ifrom)
{
	setName(ifrom.getName());
	setDescription(ifrom.getDescription());
	setBuild(ifrom.getBuild());
	setPath(ifrom.getPath());
	setTpMachines(ifrom.getTpMachines());
}


void CTpMySqlServer::getAttributes(IProperties &attributes)
{
}


void CTpMySqlServer::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_Name.toStr(ctx, buffer, "Name", "", true, "", "");
	m_Description.toStr(ctx, buffer, "Description", "", true, "", "");
	m_Build.toStr(ctx, buffer, "Build", "", true, "", "");
	m_Path.toStr(ctx, buffer, "Path", "", true, "", "");
	m_TpMachines.toStr(ctx, buffer, "TpMachines", "TpMachine");
}


void CTpMySqlServer::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CTpMySqlServer::serializer(IEspContext* ctx, IConstTpMySqlServer &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<TpMySqlServer>");
	// field Name
	{
		const char* s = src.getName();
		if (s && *s)
		{
			buffer.append("<Name>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Name>");
		}
	}
	// field Description
	{
		const char* s = src.getDescription();
		if (s && *s)
		{
			buffer.append("<Description>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Description>");
		}
	}
	// field Build
	{
		const char* s = src.getBuild();
		if (s && *s)
		{
			buffer.append("<Build>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Build>");
		}
	}
	// field Path
	{
		const char* s = src.getPath();
		if (s && *s)
		{
			buffer.append("<Path>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Path>");
		}
	}
	// field TpMachines
	{
		IArrayOf<IConstTpMachine>& v = src.getTpMachines();
		int size = v.length();
		if (size>0)
			buffer.append("<TpMachines>");
		for (int i=0;i<size;i++)
		{
			buffer.append("<Item>");
			CTpMachine::serializer(ctx,v.item(i),buffer,false);
			buffer.append("</Item>");
		}
		if (size>0)
			buffer.append("</TpMachines>");
	}
	if (keepRootTag)
		buffer.append("</TpMySqlServer>");
}

bool CTpMySqlServer::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_Name.unmarshall(rpc_request, "Name", basepath);
	hasValue |= m_Description.unmarshall(rpc_request, "Description", basepath);
	hasValue |= m_Build.unmarshall(rpc_request, "Build", basepath);
	hasValue |= m_Path.unmarshall(rpc_request, "Path", basepath);
	hasValue |= m_TpMachines.unmarshall(rpc_request, "TpMachines", basepath);
	return hasValue;
}

bool CTpMySqlServer::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Name.unmarshall(ctx, soapval, "Name");
	hasValue |= m_Description.unmarshall(ctx, soapval, "Description");
	hasValue |= m_Build.unmarshall(ctx, soapval, "Build");
	hasValue |= m_Path.unmarshall(ctx, soapval, "Path");
	hasValue |= m_TpMachines.unmarshall(ctx, soapval, "TpMachines");
	return hasValue;
}

bool CTpMySqlServer::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Name.unmarshall(ctx, params, attachments, "Name", basepath);
	hasValue |= m_Description.unmarshall(ctx, params, attachments, "Description", basepath);
	hasValue |= m_Build.unmarshall(ctx, params, attachments, "Build", basepath);
	hasValue |= m_Path.unmarshall(ctx, params, attachments, "Path", basepath);
	hasValue |= m_TpMachines.unmarshall(ctx, params, attachments, "TpMachines", basepath);
	return hasValue;
}

const char * CTpMySqlServer::getName() { return m_Name.query();}
const char * CTpMySqlServer::getDescription() { return m_Description.query();}
const char * CTpMySqlServer::getBuild() { return m_Build.query();}
const char * CTpMySqlServer::getPath() { return m_Path.query();}
IArrayOf<IConstTpMachine> & CTpMySqlServer::getTpMachines() { return (IArrayOf<IConstTpMachine> &) m_TpMachines; }
void CTpMySqlServer::setName(const char * val){ m_Name.set(val); }
void CTpMySqlServer::setDescription(const char * val){ m_Description.set(val); }
void CTpMySqlServer::setBuild(const char * val){ m_Build.set(val); }
void CTpMySqlServer::setPath(const char * val){ m_Path.set(val); }
void CTpMySqlServer::setTpMachines(IArrayOf<IEspTpMachine> &val)
{
	m_TpMachines->kill();
	IArrayOf<IConstTpMachine> &target = m_TpMachines.getValue();
	ForEachItemIn(idx, val)
	{
		IEspTpMachine &item = (val).item(idx);
		item.Link();
		target.append(item);
	}
}
void CTpMySqlServer::setTpMachines(IArrayOf<IConstTpMachine> &val)
{
	m_TpMachines->kill();
	IArrayOf<IConstTpMachine> &target = m_TpMachines.getValue();
	ForEachItemIn(idx, val)
	{
		IConstTpMachine &item = val.item(idx);
		item.Link();
		target.append(item);
	}
}
extern "C"  IEspTpMySqlServer *createTpMySqlServer(const char *serv, const char *msgname){return ((IEspTpMySqlServer *)new CTpMySqlServer(serv /*, msgname*/));}
extern "C"  IClientTpMySqlServer *createClientTpMySqlServer(const char *serv, const char *msgname){return ((IClientTpMySqlServer *)new CTpMySqlServer(serv /*, msgname*/));}

//=======================================================
// class CTpFTSlave Implementation
//=======================================================

CTpFTSlave::CTpFTSlave(const char *serviceName, IRpcMessageBinding *init)
	: m_Name(nilIgnore),m_Description(nilIgnore),m_Build(nilIgnore),m_Path(nilIgnore),m_TpMachines(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("TpFTSlave");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CTpFTSlave::CTpFTSlave(const char *serviceName, const char *bc)
	: m_Name(nilIgnore),m_Description(nilIgnore),m_Build(nilIgnore),m_Path(nilIgnore),m_TpMachines(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("TpFTSlave");
}

StringBuffer &CTpFTSlave::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:complexType name=\"%s\">\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Name\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Description\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Build\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Path\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"TpMachines\" type=\"tns:ArrayOfTpMachine\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType>\n");
		}
	}
	if (!(flags & 0x10)  || (flags & 0x100))
	{
		CTpMachine::getXsdDefinition(context, request, schema, added);
	}
	if (added.getValue("TpMachine") && added.getValue("ArrayOfTpMachine")==NULL) {
		schema.append("<xsd:complexType name=\"ArrayOfTpMachine\">\n");
		schema.append("<xsd:sequence>\n");
		schema.append("<xsd:element minOccurs=\"0\" maxOccurs=\"unbounded\" name=\"TpMachine\" type=\"tns:TpMachine\"/>\n");
		schema.append("</xsd:sequence>\n");
		schema.append("</xsd:complexType>\n");
		added.setValue("ArrayOfTpMachine",1);
	}
	return schema;
}

void CTpFTSlave::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CTpFTSlave::getMapInfo(IMapInfo& info, BoolHash& added)
{
	if (!added.getValue("TpMachine"))
	{
		added.setValue("TpMachine",1);
		CTpMachine::getMapInfo(info,added);
	}
}

StringBuffer &CTpFTSlave::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Name");
	form.appendf("  <tr><td><b>Name: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Description");
	form.appendf("  <tr><td><b>Description: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Build");
	form.appendf("  <tr><td><b>Build: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Path");
	form.appendf("  <tr><td><b>Path: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("TpMachines");
	form.appendf("<tr><td><b>TpMachines: </b></td><td>");
	form.appendf("<table><tr><td><textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea></td>", extfix.str());
	form.append("</tr></table>");
	form.append("</td></tr>");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CTpFTSlave::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CTpFTSlave::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_Name.marshall(rpc_resp, "Name", "", "", "");
	m_Description.marshall(rpc_resp, "Description", "", "", "");
	m_Build.marshall(rpc_resp, "Build", "", "", "");
	m_Path.marshall(rpc_resp, "Path", "", "", "");
	m_TpMachines.marshall(rpc_resp, "TpMachines", "TpMachine");
}


void CTpFTSlave::copy(CTpFTSlave &from)
{
	m_Name.copy(from.m_Name);
	m_Description.copy(from.m_Description);
	m_Build.copy(from.m_Build);
	m_Path.copy(from.m_Path);
	m_TpMachines.copy(from.m_TpMachines);
}


void CTpFTSlave::copy(IConstTpFTSlave &ifrom)
{
	setName(ifrom.getName());
	setDescription(ifrom.getDescription());
	setBuild(ifrom.getBuild());
	setPath(ifrom.getPath());
	setTpMachines(ifrom.getTpMachines());
}


void CTpFTSlave::getAttributes(IProperties &attributes)
{
}


void CTpFTSlave::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_Name.toStr(ctx, buffer, "Name", "", true, "", "");
	m_Description.toStr(ctx, buffer, "Description", "", true, "", "");
	m_Build.toStr(ctx, buffer, "Build", "", true, "", "");
	m_Path.toStr(ctx, buffer, "Path", "", true, "", "");
	m_TpMachines.toStr(ctx, buffer, "TpMachines", "TpMachine");
}


void CTpFTSlave::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CTpFTSlave::serializer(IEspContext* ctx, IConstTpFTSlave &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<TpFTSlave>");
	// field Name
	{
		const char* s = src.getName();
		if (s && *s)
		{
			buffer.append("<Name>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Name>");
		}
	}
	// field Description
	{
		const char* s = src.getDescription();
		if (s && *s)
		{
			buffer.append("<Description>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Description>");
		}
	}
	// field Build
	{
		const char* s = src.getBuild();
		if (s && *s)
		{
			buffer.append("<Build>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Build>");
		}
	}
	// field Path
	{
		const char* s = src.getPath();
		if (s && *s)
		{
			buffer.append("<Path>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Path>");
		}
	}
	// field TpMachines
	{
		IArrayOf<IConstTpMachine>& v = src.getTpMachines();
		int size = v.length();
		if (size>0)
			buffer.append("<TpMachines>");
		for (int i=0;i<size;i++)
		{
			buffer.append("<Item>");
			CTpMachine::serializer(ctx,v.item(i),buffer,false);
			buffer.append("</Item>");
		}
		if (size>0)
			buffer.append("</TpMachines>");
	}
	if (keepRootTag)
		buffer.append("</TpFTSlave>");
}

bool CTpFTSlave::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_Name.unmarshall(rpc_request, "Name", basepath);
	hasValue |= m_Description.unmarshall(rpc_request, "Description", basepath);
	hasValue |= m_Build.unmarshall(rpc_request, "Build", basepath);
	hasValue |= m_Path.unmarshall(rpc_request, "Path", basepath);
	hasValue |= m_TpMachines.unmarshall(rpc_request, "TpMachines", basepath);
	return hasValue;
}

bool CTpFTSlave::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Name.unmarshall(ctx, soapval, "Name");
	hasValue |= m_Description.unmarshall(ctx, soapval, "Description");
	hasValue |= m_Build.unmarshall(ctx, soapval, "Build");
	hasValue |= m_Path.unmarshall(ctx, soapval, "Path");
	hasValue |= m_TpMachines.unmarshall(ctx, soapval, "TpMachines");
	return hasValue;
}

bool CTpFTSlave::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Name.unmarshall(ctx, params, attachments, "Name", basepath);
	hasValue |= m_Description.unmarshall(ctx, params, attachments, "Description", basepath);
	hasValue |= m_Build.unmarshall(ctx, params, attachments, "Build", basepath);
	hasValue |= m_Path.unmarshall(ctx, params, attachments, "Path", basepath);
	hasValue |= m_TpMachines.unmarshall(ctx, params, attachments, "TpMachines", basepath);
	return hasValue;
}

const char * CTpFTSlave::getName() { return m_Name.query();}
const char * CTpFTSlave::getDescription() { return m_Description.query();}
const char * CTpFTSlave::getBuild() { return m_Build.query();}
const char * CTpFTSlave::getPath() { return m_Path.query();}
IArrayOf<IConstTpMachine> & CTpFTSlave::getTpMachines() { return (IArrayOf<IConstTpMachine> &) m_TpMachines; }
void CTpFTSlave::setName(const char * val){ m_Name.set(val); }
void CTpFTSlave::setDescription(const char * val){ m_Description.set(val); }
void CTpFTSlave::setBuild(const char * val){ m_Build.set(val); }
void CTpFTSlave::setPath(const char * val){ m_Path.set(val); }
void CTpFTSlave::setTpMachines(IArrayOf<IEspTpMachine> &val)
{
	m_TpMachines->kill();
	IArrayOf<IConstTpMachine> &target = m_TpMachines.getValue();
	ForEachItemIn(idx, val)
	{
		IEspTpMachine &item = (val).item(idx);
		item.Link();
		target.append(item);
	}
}
void CTpFTSlave::setTpMachines(IArrayOf<IConstTpMachine> &val)
{
	m_TpMachines->kill();
	IArrayOf<IConstTpMachine> &target = m_TpMachines.getValue();
	ForEachItemIn(idx, val)
	{
		IConstTpMachine &item = val.item(idx);
		item.Link();
		target.append(item);
	}
}
extern "C"  IEspTpFTSlave *createTpFTSlave(const char *serv, const char *msgname){return ((IEspTpFTSlave *)new CTpFTSlave(serv /*, msgname*/));}
extern "C"  IClientTpFTSlave *createClientTpFTSlave(const char *serv, const char *msgname){return ((IClientTpFTSlave *)new CTpFTSlave(serv /*, msgname*/));}

//=======================================================
// class CTpDkcSlave Implementation
//=======================================================

CTpDkcSlave::CTpDkcSlave(const char *serviceName, IRpcMessageBinding *init)
	: m_Name(nilIgnore),m_Description(nilIgnore),m_Build(nilIgnore),m_Path(nilIgnore),m_TpMachines(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("TpDkcSlave");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CTpDkcSlave::CTpDkcSlave(const char *serviceName, const char *bc)
	: m_Name(nilIgnore),m_Description(nilIgnore),m_Build(nilIgnore),m_Path(nilIgnore),m_TpMachines(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("TpDkcSlave");
}

StringBuffer &CTpDkcSlave::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:complexType name=\"%s\">\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Name\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Description\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Build\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Path\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"TpMachines\" type=\"tns:ArrayOfTpMachine\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType>\n");
		}
	}
	if (!(flags & 0x10)  || (flags & 0x100))
	{
		CTpMachine::getXsdDefinition(context, request, schema, added);
	}
	if (added.getValue("TpMachine") && added.getValue("ArrayOfTpMachine")==NULL) {
		schema.append("<xsd:complexType name=\"ArrayOfTpMachine\">\n");
		schema.append("<xsd:sequence>\n");
		schema.append("<xsd:element minOccurs=\"0\" maxOccurs=\"unbounded\" name=\"TpMachine\" type=\"tns:TpMachine\"/>\n");
		schema.append("</xsd:sequence>\n");
		schema.append("</xsd:complexType>\n");
		added.setValue("ArrayOfTpMachine",1);
	}
	return schema;
}

void CTpDkcSlave::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CTpDkcSlave::getMapInfo(IMapInfo& info, BoolHash& added)
{
	if (!added.getValue("TpMachine"))
	{
		added.setValue("TpMachine",1);
		CTpMachine::getMapInfo(info,added);
	}
}

StringBuffer &CTpDkcSlave::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Name");
	form.appendf("  <tr><td><b>Name: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Description");
	form.appendf("  <tr><td><b>Description: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Build");
	form.appendf("  <tr><td><b>Build: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Path");
	form.appendf("  <tr><td><b>Path: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("TpMachines");
	form.appendf("<tr><td><b>TpMachines: </b></td><td>");
	form.appendf("<table><tr><td><textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea></td>", extfix.str());
	form.append("</tr></table>");
	form.append("</td></tr>");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CTpDkcSlave::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CTpDkcSlave::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_Name.marshall(rpc_resp, "Name", "", "", "");
	m_Description.marshall(rpc_resp, "Description", "", "", "");
	m_Build.marshall(rpc_resp, "Build", "", "", "");
	m_Path.marshall(rpc_resp, "Path", "", "", "");
	m_TpMachines.marshall(rpc_resp, "TpMachines", "TpMachine");
}


void CTpDkcSlave::copy(CTpDkcSlave &from)
{
	m_Name.copy(from.m_Name);
	m_Description.copy(from.m_Description);
	m_Build.copy(from.m_Build);
	m_Path.copy(from.m_Path);
	m_TpMachines.copy(from.m_TpMachines);
}


void CTpDkcSlave::copy(IConstTpDkcSlave &ifrom)
{
	setName(ifrom.getName());
	setDescription(ifrom.getDescription());
	setBuild(ifrom.getBuild());
	setPath(ifrom.getPath());
	setTpMachines(ifrom.getTpMachines());
}


void CTpDkcSlave::getAttributes(IProperties &attributes)
{
}


void CTpDkcSlave::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_Name.toStr(ctx, buffer, "Name", "", true, "", "");
	m_Description.toStr(ctx, buffer, "Description", "", true, "", "");
	m_Build.toStr(ctx, buffer, "Build", "", true, "", "");
	m_Path.toStr(ctx, buffer, "Path", "", true, "", "");
	m_TpMachines.toStr(ctx, buffer, "TpMachines", "TpMachine");
}


void CTpDkcSlave::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CTpDkcSlave::serializer(IEspContext* ctx, IConstTpDkcSlave &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<TpDkcSlave>");
	// field Name
	{
		const char* s = src.getName();
		if (s && *s)
		{
			buffer.append("<Name>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Name>");
		}
	}
	// field Description
	{
		const char* s = src.getDescription();
		if (s && *s)
		{
			buffer.append("<Description>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Description>");
		}
	}
	// field Build
	{
		const char* s = src.getBuild();
		if (s && *s)
		{
			buffer.append("<Build>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Build>");
		}
	}
	// field Path
	{
		const char* s = src.getPath();
		if (s && *s)
		{
			buffer.append("<Path>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Path>");
		}
	}
	// field TpMachines
	{
		IArrayOf<IConstTpMachine>& v = src.getTpMachines();
		int size = v.length();
		if (size>0)
			buffer.append("<TpMachines>");
		for (int i=0;i<size;i++)
		{
			buffer.append("<Item>");
			CTpMachine::serializer(ctx,v.item(i),buffer,false);
			buffer.append("</Item>");
		}
		if (size>0)
			buffer.append("</TpMachines>");
	}
	if (keepRootTag)
		buffer.append("</TpDkcSlave>");
}

bool CTpDkcSlave::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_Name.unmarshall(rpc_request, "Name", basepath);
	hasValue |= m_Description.unmarshall(rpc_request, "Description", basepath);
	hasValue |= m_Build.unmarshall(rpc_request, "Build", basepath);
	hasValue |= m_Path.unmarshall(rpc_request, "Path", basepath);
	hasValue |= m_TpMachines.unmarshall(rpc_request, "TpMachines", basepath);
	return hasValue;
}

bool CTpDkcSlave::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Name.unmarshall(ctx, soapval, "Name");
	hasValue |= m_Description.unmarshall(ctx, soapval, "Description");
	hasValue |= m_Build.unmarshall(ctx, soapval, "Build");
	hasValue |= m_Path.unmarshall(ctx, soapval, "Path");
	hasValue |= m_TpMachines.unmarshall(ctx, soapval, "TpMachines");
	return hasValue;
}

bool CTpDkcSlave::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Name.unmarshall(ctx, params, attachments, "Name", basepath);
	hasValue |= m_Description.unmarshall(ctx, params, attachments, "Description", basepath);
	hasValue |= m_Build.unmarshall(ctx, params, attachments, "Build", basepath);
	hasValue |= m_Path.unmarshall(ctx, params, attachments, "Path", basepath);
	hasValue |= m_TpMachines.unmarshall(ctx, params, attachments, "TpMachines", basepath);
	return hasValue;
}

const char * CTpDkcSlave::getName() { return m_Name.query();}
const char * CTpDkcSlave::getDescription() { return m_Description.query();}
const char * CTpDkcSlave::getBuild() { return m_Build.query();}
const char * CTpDkcSlave::getPath() { return m_Path.query();}
IArrayOf<IConstTpMachine> & CTpDkcSlave::getTpMachines() { return (IArrayOf<IConstTpMachine> &) m_TpMachines; }
void CTpDkcSlave::setName(const char * val){ m_Name.set(val); }
void CTpDkcSlave::setDescription(const char * val){ m_Description.set(val); }
void CTpDkcSlave::setBuild(const char * val){ m_Build.set(val); }
void CTpDkcSlave::setPath(const char * val){ m_Path.set(val); }
void CTpDkcSlave::setTpMachines(IArrayOf<IEspTpMachine> &val)
{
	m_TpMachines->kill();
	IArrayOf<IConstTpMachine> &target = m_TpMachines.getValue();
	ForEachItemIn(idx, val)
	{
		IEspTpMachine &item = (val).item(idx);
		item.Link();
		target.append(item);
	}
}
void CTpDkcSlave::setTpMachines(IArrayOf<IConstTpMachine> &val)
{
	m_TpMachines->kill();
	IArrayOf<IConstTpMachine> &target = m_TpMachines.getValue();
	ForEachItemIn(idx, val)
	{
		IConstTpMachine &item = val.item(idx);
		item.Link();
		target.append(item);
	}
}
extern "C"  IEspTpDkcSlave *createTpDkcSlave(const char *serv, const char *msgname){return ((IEspTpDkcSlave *)new CTpDkcSlave(serv /*, msgname*/));}
extern "C"  IClientTpDkcSlave *createClientTpDkcSlave(const char *serv, const char *msgname){return ((IClientTpDkcSlave *)new CTpDkcSlave(serv /*, msgname*/));}

//=======================================================
// class CTpGenesisServer Implementation
//=======================================================

CTpGenesisServer::CTpGenesisServer(const char *serviceName, IRpcMessageBinding *init)
	: m_Name(nilIgnore),m_Description(nilIgnore),m_Build(nilIgnore),m_Path(nilIgnore),m_TpMachines(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("TpGenesisServer");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CTpGenesisServer::CTpGenesisServer(const char *serviceName, const char *bc)
	: m_Name(nilIgnore),m_Description(nilIgnore),m_Build(nilIgnore),m_Path(nilIgnore),m_TpMachines(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("TpGenesisServer");
}

StringBuffer &CTpGenesisServer::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:complexType name=\"%s\">\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Name\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Description\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Build\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Path\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"TpMachines\" type=\"tns:ArrayOfTpMachine\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType>\n");
		}
	}
	if (!(flags & 0x10)  || (flags & 0x100))
	{
		CTpMachine::getXsdDefinition(context, request, schema, added);
	}
	if (added.getValue("TpMachine") && added.getValue("ArrayOfTpMachine")==NULL) {
		schema.append("<xsd:complexType name=\"ArrayOfTpMachine\">\n");
		schema.append("<xsd:sequence>\n");
		schema.append("<xsd:element minOccurs=\"0\" maxOccurs=\"unbounded\" name=\"TpMachine\" type=\"tns:TpMachine\"/>\n");
		schema.append("</xsd:sequence>\n");
		schema.append("</xsd:complexType>\n");
		added.setValue("ArrayOfTpMachine",1);
	}
	return schema;
}

void CTpGenesisServer::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CTpGenesisServer::getMapInfo(IMapInfo& info, BoolHash& added)
{
	if (!added.getValue("TpMachine"))
	{
		added.setValue("TpMachine",1);
		CTpMachine::getMapInfo(info,added);
	}
}

StringBuffer &CTpGenesisServer::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Name");
	form.appendf("  <tr><td><b>Name: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Description");
	form.appendf("  <tr><td><b>Description: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Build");
	form.appendf("  <tr><td><b>Build: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Path");
	form.appendf("  <tr><td><b>Path: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("TpMachines");
	form.appendf("<tr><td><b>TpMachines: </b></td><td>");
	form.appendf("<table><tr><td><textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea></td>", extfix.str());
	form.append("</tr></table>");
	form.append("</td></tr>");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CTpGenesisServer::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CTpGenesisServer::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_Name.marshall(rpc_resp, "Name", "", "", "");
	m_Description.marshall(rpc_resp, "Description", "", "", "");
	m_Build.marshall(rpc_resp, "Build", "", "", "");
	m_Path.marshall(rpc_resp, "Path", "", "", "");
	m_TpMachines.marshall(rpc_resp, "TpMachines", "TpMachine");
}


void CTpGenesisServer::copy(CTpGenesisServer &from)
{
	m_Name.copy(from.m_Name);
	m_Description.copy(from.m_Description);
	m_Build.copy(from.m_Build);
	m_Path.copy(from.m_Path);
	m_TpMachines.copy(from.m_TpMachines);
}


void CTpGenesisServer::copy(IConstTpGenesisServer &ifrom)
{
	setName(ifrom.getName());
	setDescription(ifrom.getDescription());
	setBuild(ifrom.getBuild());
	setPath(ifrom.getPath());
	setTpMachines(ifrom.getTpMachines());
}


void CTpGenesisServer::getAttributes(IProperties &attributes)
{
}


void CTpGenesisServer::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_Name.toStr(ctx, buffer, "Name", "", true, "", "");
	m_Description.toStr(ctx, buffer, "Description", "", true, "", "");
	m_Build.toStr(ctx, buffer, "Build", "", true, "", "");
	m_Path.toStr(ctx, buffer, "Path", "", true, "", "");
	m_TpMachines.toStr(ctx, buffer, "TpMachines", "TpMachine");
}


void CTpGenesisServer::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CTpGenesisServer::serializer(IEspContext* ctx, IConstTpGenesisServer &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<TpGenesisServer>");
	// field Name
	{
		const char* s = src.getName();
		if (s && *s)
		{
			buffer.append("<Name>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Name>");
		}
	}
	// field Description
	{
		const char* s = src.getDescription();
		if (s && *s)
		{
			buffer.append("<Description>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Description>");
		}
	}
	// field Build
	{
		const char* s = src.getBuild();
		if (s && *s)
		{
			buffer.append("<Build>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Build>");
		}
	}
	// field Path
	{
		const char* s = src.getPath();
		if (s && *s)
		{
			buffer.append("<Path>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Path>");
		}
	}
	// field TpMachines
	{
		IArrayOf<IConstTpMachine>& v = src.getTpMachines();
		int size = v.length();
		if (size>0)
			buffer.append("<TpMachines>");
		for (int i=0;i<size;i++)
		{
			buffer.append("<Item>");
			CTpMachine::serializer(ctx,v.item(i),buffer,false);
			buffer.append("</Item>");
		}
		if (size>0)
			buffer.append("</TpMachines>");
	}
	if (keepRootTag)
		buffer.append("</TpGenesisServer>");
}

bool CTpGenesisServer::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_Name.unmarshall(rpc_request, "Name", basepath);
	hasValue |= m_Description.unmarshall(rpc_request, "Description", basepath);
	hasValue |= m_Build.unmarshall(rpc_request, "Build", basepath);
	hasValue |= m_Path.unmarshall(rpc_request, "Path", basepath);
	hasValue |= m_TpMachines.unmarshall(rpc_request, "TpMachines", basepath);
	return hasValue;
}

bool CTpGenesisServer::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Name.unmarshall(ctx, soapval, "Name");
	hasValue |= m_Description.unmarshall(ctx, soapval, "Description");
	hasValue |= m_Build.unmarshall(ctx, soapval, "Build");
	hasValue |= m_Path.unmarshall(ctx, soapval, "Path");
	hasValue |= m_TpMachines.unmarshall(ctx, soapval, "TpMachines");
	return hasValue;
}

bool CTpGenesisServer::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Name.unmarshall(ctx, params, attachments, "Name", basepath);
	hasValue |= m_Description.unmarshall(ctx, params, attachments, "Description", basepath);
	hasValue |= m_Build.unmarshall(ctx, params, attachments, "Build", basepath);
	hasValue |= m_Path.unmarshall(ctx, params, attachments, "Path", basepath);
	hasValue |= m_TpMachines.unmarshall(ctx, params, attachments, "TpMachines", basepath);
	return hasValue;
}

const char * CTpGenesisServer::getName() { return m_Name.query();}
const char * CTpGenesisServer::getDescription() { return m_Description.query();}
const char * CTpGenesisServer::getBuild() { return m_Build.query();}
const char * CTpGenesisServer::getPath() { return m_Path.query();}
IArrayOf<IConstTpMachine> & CTpGenesisServer::getTpMachines() { return (IArrayOf<IConstTpMachine> &) m_TpMachines; }
void CTpGenesisServer::setName(const char * val){ m_Name.set(val); }
void CTpGenesisServer::setDescription(const char * val){ m_Description.set(val); }
void CTpGenesisServer::setBuild(const char * val){ m_Build.set(val); }
void CTpGenesisServer::setPath(const char * val){ m_Path.set(val); }
void CTpGenesisServer::setTpMachines(IArrayOf<IEspTpMachine> &val)
{
	m_TpMachines->kill();
	IArrayOf<IConstTpMachine> &target = m_TpMachines.getValue();
	ForEachItemIn(idx, val)
	{
		IEspTpMachine &item = (val).item(idx);
		item.Link();
		target.append(item);
	}
}
void CTpGenesisServer::setTpMachines(IArrayOf<IConstTpMachine> &val)
{
	m_TpMachines->kill();
	IArrayOf<IConstTpMachine> &target = m_TpMachines.getValue();
	ForEachItemIn(idx, val)
	{
		IConstTpMachine &item = val.item(idx);
		item.Link();
		target.append(item);
	}
}
extern "C"  IEspTpGenesisServer *createTpGenesisServer(const char *serv, const char *msgname){return ((IEspTpGenesisServer *)new CTpGenesisServer(serv /*, msgname*/));}
extern "C"  IClientTpGenesisServer *createClientTpGenesisServer(const char *serv, const char *msgname){return ((IClientTpGenesisServer *)new CTpGenesisServer(serv /*, msgname*/));}

//=======================================================
// class CTpSparkThor Implementation
//=======================================================

CTpSparkThor::CTpSparkThor(const char *serviceName, IRpcMessageBinding *init)
	: m_Name(nilIgnore),m_Build(nilIgnore),m_ThorClusterName(nilIgnore),m_ThorPath(nilIgnore),m_SparkExecutorCores(nilIgnore),m_SparkExecutorMemory(nilIgnore),m_SparkMasterPort(nilIgnore),m_SparkMasterWebUIPort(nilIgnore),m_SparkWorkerCores(nilIgnore),m_SparkWorkerMemory(nilIgnore),m_SparkWorkerPort(nilIgnore),m_LogDirectory(nilIgnore),m_Path(nilIgnore),m_TpMachines(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("TpSparkThor");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CTpSparkThor::CTpSparkThor(const char *serviceName, const char *bc)
	: m_Name(nilIgnore),m_Build(nilIgnore),m_ThorClusterName(nilIgnore),m_ThorPath(nilIgnore),m_SparkExecutorCores(nilIgnore),m_SparkExecutorMemory(nilIgnore),m_SparkMasterPort(nilIgnore),m_SparkMasterWebUIPort(nilIgnore),m_SparkWorkerCores(nilIgnore),m_SparkWorkerMemory(nilIgnore),m_SparkWorkerPort(nilIgnore),m_LogDirectory(nilIgnore),m_Path(nilIgnore),m_TpMachines(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("TpSparkThor");
}

StringBuffer &CTpSparkThor::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:complexType name=\"%s\">\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Name\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Build\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"ThorClusterName\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"ThorPath\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"SparkExecutorCores\" type=\"xsd:unsignedInt\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"SparkExecutorMemory\" type=\"xsd:long\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"SparkMasterPort\" type=\"xsd:unsignedInt\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"SparkMasterWebUIPort\" type=\"xsd:unsignedInt\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"SparkWorkerCores\" type=\"xsd:unsignedInt\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"SparkWorkerMemory\" type=\"xsd:long\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"SparkWorkerPort\" type=\"xsd:unsignedInt\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"LogDirectory\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Path\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"TpMachines\" type=\"tns:ArrayOfTpMachine\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType>\n");
		}
	}
	if (!(flags & 0x10)  || (flags & 0x100))
	{
		CTpMachine::getXsdDefinition(context, request, schema, added);
	}
	if (added.getValue("TpMachine") && added.getValue("ArrayOfTpMachine")==NULL) {
		schema.append("<xsd:complexType name=\"ArrayOfTpMachine\">\n");
		schema.append("<xsd:sequence>\n");
		schema.append("<xsd:element minOccurs=\"0\" maxOccurs=\"unbounded\" name=\"TpMachine\" type=\"tns:TpMachine\"/>\n");
		schema.append("</xsd:sequence>\n");
		schema.append("</xsd:complexType>\n");
		added.setValue("ArrayOfTpMachine",1);
	}
	return schema;
}

void CTpSparkThor::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CTpSparkThor::getMapInfo(IMapInfo& info, BoolHash& added)
{
	if (!added.getValue("TpMachine"))
	{
		added.setValue("TpMachine",1);
		CTpMachine::getMapInfo(info,added);
	}
}

StringBuffer &CTpSparkThor::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Name");
	form.appendf("  <tr><td><b>Name: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Build");
	form.appendf("  <tr><td><b>Build: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("ThorClusterName");
	form.appendf("  <tr><td><b>ThorClusterName: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("ThorPath");
	form.appendf("  <tr><td><b>ThorPath: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix) extfix.append(prefix).append(".");
		extfix.append("SparkExecutorCores");
	form.appendf("  <tr><td><b>SparkExecutorCores: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("SparkExecutorMemory");
	form.appendf("  <tr><td><b>SparkExecutorMemory: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix) extfix.append(prefix).append(".");
		extfix.append("SparkMasterPort");
	form.appendf("  <tr><td><b>SparkMasterPort: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix) extfix.append(prefix).append(".");
		extfix.append("SparkMasterWebUIPort");
	form.appendf("  <tr><td><b>SparkMasterWebUIPort: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix) extfix.append(prefix).append(".");
		extfix.append("SparkWorkerCores");
	form.appendf("  <tr><td><b>SparkWorkerCores: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("SparkWorkerMemory");
	form.appendf("  <tr><td><b>SparkWorkerMemory: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix) extfix.append(prefix).append(".");
		extfix.append("SparkWorkerPort");
	form.appendf("  <tr><td><b>SparkWorkerPort: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("LogDirectory");
	form.appendf("  <tr><td><b>LogDirectory: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Path");
	form.appendf("  <tr><td><b>Path: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("TpMachines");
	form.appendf("<tr><td><b>TpMachines: </b></td><td>");
	form.appendf("<table><tr><td><textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea></td>", extfix.str());
	form.append("</tr></table>");
	form.append("</td></tr>");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CTpSparkThor::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CTpSparkThor::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_Name.marshall(rpc_resp, "Name", "", "", "");
	m_Build.marshall(rpc_resp, "Build", "", "", "");
	m_ThorClusterName.marshall(rpc_resp, "ThorClusterName", "", "", "");
	m_ThorPath.marshall(rpc_resp, "ThorPath", "", "", "");
	m_SparkExecutorCores.marshall(rpc_resp, "SparkExecutorCores", "", "", "");
	m_SparkExecutorMemory.marshall(rpc_resp, "SparkExecutorMemory", "", "", "");
	m_SparkMasterPort.marshall(rpc_resp, "SparkMasterPort", "", "", "");
	m_SparkMasterWebUIPort.marshall(rpc_resp, "SparkMasterWebUIPort", "", "", "");
	m_SparkWorkerCores.marshall(rpc_resp, "SparkWorkerCores", "", "", "");
	m_SparkWorkerMemory.marshall(rpc_resp, "SparkWorkerMemory", "", "", "");
	m_SparkWorkerPort.marshall(rpc_resp, "SparkWorkerPort", "", "", "");
	m_LogDirectory.marshall(rpc_resp, "LogDirectory", "", "", "");
	m_Path.marshall(rpc_resp, "Path", "", "", "");
	m_TpMachines.marshall(rpc_resp, "TpMachines", "TpMachine");
}


void CTpSparkThor::copy(CTpSparkThor &from)
{
	m_Name.copy(from.m_Name);
	m_Build.copy(from.m_Build);
	m_ThorClusterName.copy(from.m_ThorClusterName);
	m_ThorPath.copy(from.m_ThorPath);
	m_SparkExecutorCores.copy(from.m_SparkExecutorCores);
	m_SparkExecutorMemory.copy(from.m_SparkExecutorMemory);
	m_SparkMasterPort.copy(from.m_SparkMasterPort);
	m_SparkMasterWebUIPort.copy(from.m_SparkMasterWebUIPort);
	m_SparkWorkerCores.copy(from.m_SparkWorkerCores);
	m_SparkWorkerMemory.copy(from.m_SparkWorkerMemory);
	m_SparkWorkerPort.copy(from.m_SparkWorkerPort);
	m_LogDirectory.copy(from.m_LogDirectory);
	m_Path.copy(from.m_Path);
	m_TpMachines.copy(from.m_TpMachines);
}


void CTpSparkThor::copy(IConstTpSparkThor &ifrom)
{
	setName(ifrom.getName());
	setBuild(ifrom.getBuild());
	setThorClusterName(ifrom.getThorClusterName());
	setThorPath(ifrom.getThorPath());
	setSparkExecutorCores(ifrom.getSparkExecutorCores());
	setSparkExecutorMemory(ifrom.getSparkExecutorMemory());
	setSparkMasterPort(ifrom.getSparkMasterPort());
	setSparkMasterWebUIPort(ifrom.getSparkMasterWebUIPort());
	setSparkWorkerCores(ifrom.getSparkWorkerCores());
	setSparkWorkerMemory(ifrom.getSparkWorkerMemory());
	setSparkWorkerPort(ifrom.getSparkWorkerPort());
	setLogDirectory(ifrom.getLogDirectory());
	setPath(ifrom.getPath());
	setTpMachines(ifrom.getTpMachines());
}


void CTpSparkThor::getAttributes(IProperties &attributes)
{
}


void CTpSparkThor::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_Name.toStr(ctx, buffer, "Name", "", true, "", "");
	m_Build.toStr(ctx, buffer, "Build", "", true, "", "");
	m_ThorClusterName.toStr(ctx, buffer, "ThorClusterName", "", true, "", "");
	m_ThorPath.toStr(ctx, buffer, "ThorPath", "", true, "", "");
	m_SparkExecutorCores.toStr(ctx, buffer, "SparkExecutorCores", "", true, "", "");
	m_SparkExecutorMemory.toStr(ctx, buffer, "SparkExecutorMemory", "", true, "", "");
	m_SparkMasterPort.toStr(ctx, buffer, "SparkMasterPort", "", true, "", "");
	m_SparkMasterWebUIPort.toStr(ctx, buffer, "SparkMasterWebUIPort", "", true, "", "");
	m_SparkWorkerCores.toStr(ctx, buffer, "SparkWorkerCores", "", true, "", "");
	m_SparkWorkerMemory.toStr(ctx, buffer, "SparkWorkerMemory", "", true, "", "");
	m_SparkWorkerPort.toStr(ctx, buffer, "SparkWorkerPort", "", true, "", "");
	m_LogDirectory.toStr(ctx, buffer, "LogDirectory", "", true, "", "");
	m_Path.toStr(ctx, buffer, "Path", "", true, "", "");
	m_TpMachines.toStr(ctx, buffer, "TpMachines", "TpMachine");
}


void CTpSparkThor::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CTpSparkThor::serializer(IEspContext* ctx, IConstTpSparkThor &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<TpSparkThor>");
	// field Name
	{
		const char* s = src.getName();
		if (s && *s)
		{
			buffer.append("<Name>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Name>");
		}
	}
	// field Build
	{
		const char* s = src.getBuild();
		if (s && *s)
		{
			buffer.append("<Build>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Build>");
		}
	}
	// field ThorClusterName
	{
		const char* s = src.getThorClusterName();
		if (s && *s)
		{
			buffer.append("<ThorClusterName>");
			encodeUtf8XML(s,buffer);
			buffer.append("</ThorClusterName>");
		}
	}
	// field ThorPath
	{
		const char* s = src.getThorPath();
		if (s && *s)
		{
			buffer.append("<ThorPath>");
			encodeUtf8XML(s,buffer);
			buffer.append("</ThorPath>");
		}
	}
	// field SparkExecutorCores
	{
		//*** default kind: TK_UNSIGNED; type=(null), name=SparkExecutorCores
		buffer.append("<SparkExecutorCores>");
		buffer.append(src.getSparkExecutorCores());
		buffer.append("</SparkExecutorCores>");
	}
	// field SparkExecutorMemory
	{
		//*** default kind: TK_INT; type=int64, name=SparkExecutorMemory
		buffer.append("<SparkExecutorMemory>");
		buffer.append(src.getSparkExecutorMemory());
		buffer.append("</SparkExecutorMemory>");
	}
	// field SparkMasterPort
	{
		//*** default kind: TK_UNSIGNED; type=(null), name=SparkMasterPort
		buffer.append("<SparkMasterPort>");
		buffer.append(src.getSparkMasterPort());
		buffer.append("</SparkMasterPort>");
	}
	// field SparkMasterWebUIPort
	{
		//*** default kind: TK_UNSIGNED; type=(null), name=SparkMasterWebUIPort
		buffer.append("<SparkMasterWebUIPort>");
		buffer.append(src.getSparkMasterWebUIPort());
		buffer.append("</SparkMasterWebUIPort>");
	}
	// field SparkWorkerCores
	{
		//*** default kind: TK_UNSIGNED; type=(null), name=SparkWorkerCores
		buffer.append("<SparkWorkerCores>");
		buffer.append(src.getSparkWorkerCores());
		buffer.append("</SparkWorkerCores>");
	}
	// field SparkWorkerMemory
	{
		//*** default kind: TK_INT; type=int64, name=SparkWorkerMemory
		buffer.append("<SparkWorkerMemory>");
		buffer.append(src.getSparkWorkerMemory());
		buffer.append("</SparkWorkerMemory>");
	}
	// field SparkWorkerPort
	{
		//*** default kind: TK_UNSIGNED; type=(null), name=SparkWorkerPort
		buffer.append("<SparkWorkerPort>");
		buffer.append(src.getSparkWorkerPort());
		buffer.append("</SparkWorkerPort>");
	}
	// field LogDirectory
	{
		const char* s = src.getLogDirectory();
		if (s && *s)
		{
			buffer.append("<LogDirectory>");
			encodeUtf8XML(s,buffer);
			buffer.append("</LogDirectory>");
		}
	}
	// field Path
	{
		const char* s = src.getPath();
		if (s && *s)
		{
			buffer.append("<Path>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Path>");
		}
	}
	// field TpMachines
	{
		IArrayOf<IConstTpMachine>& v = src.getTpMachines();
		int size = v.length();
		if (size>0)
			buffer.append("<TpMachines>");
		for (int i=0;i<size;i++)
		{
			buffer.append("<Item>");
			CTpMachine::serializer(ctx,v.item(i),buffer,false);
			buffer.append("</Item>");
		}
		if (size>0)
			buffer.append("</TpMachines>");
	}
	if (keepRootTag)
		buffer.append("</TpSparkThor>");
}

bool CTpSparkThor::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_Name.unmarshall(rpc_request, "Name", basepath);
	hasValue |= m_Build.unmarshall(rpc_request, "Build", basepath);
	hasValue |= m_ThorClusterName.unmarshall(rpc_request, "ThorClusterName", basepath);
	hasValue |= m_ThorPath.unmarshall(rpc_request, "ThorPath", basepath);
	hasValue |= m_SparkExecutorCores.unmarshall(rpc_request, "SparkExecutorCores", basepath);
	hasValue |= m_SparkExecutorMemory.unmarshall(rpc_request, "SparkExecutorMemory", basepath);
	hasValue |= m_SparkMasterPort.unmarshall(rpc_request, "SparkMasterPort", basepath);
	hasValue |= m_SparkMasterWebUIPort.unmarshall(rpc_request, "SparkMasterWebUIPort", basepath);
	hasValue |= m_SparkWorkerCores.unmarshall(rpc_request, "SparkWorkerCores", basepath);
	hasValue |= m_SparkWorkerMemory.unmarshall(rpc_request, "SparkWorkerMemory", basepath);
	hasValue |= m_SparkWorkerPort.unmarshall(rpc_request, "SparkWorkerPort", basepath);
	hasValue |= m_LogDirectory.unmarshall(rpc_request, "LogDirectory", basepath);
	hasValue |= m_Path.unmarshall(rpc_request, "Path", basepath);
	hasValue |= m_TpMachines.unmarshall(rpc_request, "TpMachines", basepath);
	return hasValue;
}

bool CTpSparkThor::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Name.unmarshall(ctx, soapval, "Name");
	hasValue |= m_Build.unmarshall(ctx, soapval, "Build");
	hasValue |= m_ThorClusterName.unmarshall(ctx, soapval, "ThorClusterName");
	hasValue |= m_ThorPath.unmarshall(ctx, soapval, "ThorPath");
	hasValue |= m_SparkExecutorCores.unmarshall(ctx, soapval, "SparkExecutorCores");
	hasValue |= m_SparkExecutorMemory.unmarshall(ctx, soapval, "SparkExecutorMemory");
	hasValue |= m_SparkMasterPort.unmarshall(ctx, soapval, "SparkMasterPort");
	hasValue |= m_SparkMasterWebUIPort.unmarshall(ctx, soapval, "SparkMasterWebUIPort");
	hasValue |= m_SparkWorkerCores.unmarshall(ctx, soapval, "SparkWorkerCores");
	hasValue |= m_SparkWorkerMemory.unmarshall(ctx, soapval, "SparkWorkerMemory");
	hasValue |= m_SparkWorkerPort.unmarshall(ctx, soapval, "SparkWorkerPort");
	hasValue |= m_LogDirectory.unmarshall(ctx, soapval, "LogDirectory");
	hasValue |= m_Path.unmarshall(ctx, soapval, "Path");
	hasValue |= m_TpMachines.unmarshall(ctx, soapval, "TpMachines");
	return hasValue;
}

bool CTpSparkThor::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Name.unmarshall(ctx, params, attachments, "Name", basepath);
	hasValue |= m_Build.unmarshall(ctx, params, attachments, "Build", basepath);
	hasValue |= m_ThorClusterName.unmarshall(ctx, params, attachments, "ThorClusterName", basepath);
	hasValue |= m_ThorPath.unmarshall(ctx, params, attachments, "ThorPath", basepath);
	hasValue |= m_SparkExecutorCores.unmarshall(ctx, params, attachments, "SparkExecutorCores", basepath);
	hasValue |= m_SparkExecutorMemory.unmarshall(ctx, params, attachments, "SparkExecutorMemory", basepath);
	hasValue |= m_SparkMasterPort.unmarshall(ctx, params, attachments, "SparkMasterPort", basepath);
	hasValue |= m_SparkMasterWebUIPort.unmarshall(ctx, params, attachments, "SparkMasterWebUIPort", basepath);
	hasValue |= m_SparkWorkerCores.unmarshall(ctx, params, attachments, "SparkWorkerCores", basepath);
	hasValue |= m_SparkWorkerMemory.unmarshall(ctx, params, attachments, "SparkWorkerMemory", basepath);
	hasValue |= m_SparkWorkerPort.unmarshall(ctx, params, attachments, "SparkWorkerPort", basepath);
	hasValue |= m_LogDirectory.unmarshall(ctx, params, attachments, "LogDirectory", basepath);
	hasValue |= m_Path.unmarshall(ctx, params, attachments, "Path", basepath);
	hasValue |= m_TpMachines.unmarshall(ctx, params, attachments, "TpMachines", basepath);
	return hasValue;
}

const char * CTpSparkThor::getName() { return m_Name.query();}
const char * CTpSparkThor::getBuild() { return m_Build.query();}
const char * CTpSparkThor::getThorClusterName() { return m_ThorClusterName.query();}
const char * CTpSparkThor::getThorPath() { return m_ThorPath.query();}
unsigned int CTpSparkThor::getSparkExecutorCores() { return m_SparkExecutorCores;}
__int64 CTpSparkThor::getSparkExecutorMemory() { return m_SparkExecutorMemory;}
unsigned int CTpSparkThor::getSparkMasterPort() { return m_SparkMasterPort;}
unsigned int CTpSparkThor::getSparkMasterWebUIPort() { return m_SparkMasterWebUIPort;}
unsigned int CTpSparkThor::getSparkWorkerCores() { return m_SparkWorkerCores;}
__int64 CTpSparkThor::getSparkWorkerMemory() { return m_SparkWorkerMemory;}
unsigned int CTpSparkThor::getSparkWorkerPort() { return m_SparkWorkerPort;}
const char * CTpSparkThor::getLogDirectory() { return m_LogDirectory.query();}
const char * CTpSparkThor::getPath() { return m_Path.query();}
IArrayOf<IConstTpMachine> & CTpSparkThor::getTpMachines() { return (IArrayOf<IConstTpMachine> &) m_TpMachines; }
void CTpSparkThor::setName(const char * val){ m_Name.set(val); }
void CTpSparkThor::setBuild(const char * val){ m_Build.set(val); }
void CTpSparkThor::setThorClusterName(const char * val){ m_ThorClusterName.set(val); }
void CTpSparkThor::setThorPath(const char * val){ m_ThorPath.set(val); }
void CTpSparkThor::setSparkExecutorCores(unsigned int val){ m_SparkExecutorCores=val; }
void CTpSparkThor::setSparkExecutorMemory(__int64 val){ m_SparkExecutorMemory=val; }
void CTpSparkThor::setSparkMasterPort(unsigned int val){ m_SparkMasterPort=val; }
void CTpSparkThor::setSparkMasterWebUIPort(unsigned int val){ m_SparkMasterWebUIPort=val; }
void CTpSparkThor::setSparkWorkerCores(unsigned int val){ m_SparkWorkerCores=val; }
void CTpSparkThor::setSparkWorkerMemory(__int64 val){ m_SparkWorkerMemory=val; }
void CTpSparkThor::setSparkWorkerPort(unsigned int val){ m_SparkWorkerPort=val; }
void CTpSparkThor::setLogDirectory(const char * val){ m_LogDirectory.set(val); }
void CTpSparkThor::setPath(const char * val){ m_Path.set(val); }
void CTpSparkThor::setTpMachines(IArrayOf<IEspTpMachine> &val)
{
	m_TpMachines->kill();
	IArrayOf<IConstTpMachine> &target = m_TpMachines.getValue();
	ForEachItemIn(idx, val)
	{
		IEspTpMachine &item = (val).item(idx);
		item.Link();
		target.append(item);
	}
}
void CTpSparkThor::setTpMachines(IArrayOf<IConstTpMachine> &val)
{
	m_TpMachines->kill();
	IArrayOf<IConstTpMachine> &target = m_TpMachines.getValue();
	ForEachItemIn(idx, val)
	{
		IConstTpMachine &item = val.item(idx);
		item.Link();
		target.append(item);
	}
}
extern "C"  IEspTpSparkThor *createTpSparkThor(const char *serv, const char *msgname){return ((IEspTpSparkThor *)new CTpSparkThor(serv /*, msgname*/));}
extern "C"  IClientTpSparkThor *createClientTpSparkThor(const char *serv, const char *msgname){return ((IClientTpSparkThor *)new CTpSparkThor(serv /*, msgname*/));}

//=======================================================
// class CTpQueue Implementation
//=======================================================

CTpQueue::CTpQueue(const char *serviceName, IRpcMessageBinding *init)
	: m_Name(nilIgnore),m_WorkUnit(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("TpQueue");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CTpQueue::CTpQueue(const char *serviceName, const char *bc)
	: m_Name(nilIgnore),m_WorkUnit(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("TpQueue");
}

StringBuffer &CTpQueue::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:complexType name=\"%s\">\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Name\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"WorkUnit\" type=\"xsd:string\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType>\n");
		}
	}
	return schema;
}

void CTpQueue::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CTpQueue::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CTpQueue::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Name");
	form.appendf("  <tr><td><b>Name: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("WorkUnit");
	form.appendf("  <tr><td><b>WorkUnit: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CTpQueue::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CTpQueue::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_Name.marshall(rpc_resp, "Name", "", "", "");
	m_WorkUnit.marshall(rpc_resp, "WorkUnit", "", "", "");
}


void CTpQueue::copy(CTpQueue &from)
{
	m_Name.copy(from.m_Name);
	m_WorkUnit.copy(from.m_WorkUnit);
}


void CTpQueue::copy(IConstTpQueue &ifrom)
{
	setName(ifrom.getName());
	setWorkUnit(ifrom.getWorkUnit());
}


void CTpQueue::getAttributes(IProperties &attributes)
{
}


void CTpQueue::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_Name.toStr(ctx, buffer, "Name", "", true, "", "");
	m_WorkUnit.toStr(ctx, buffer, "WorkUnit", "", true, "", "");
}


void CTpQueue::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CTpQueue::serializer(IEspContext* ctx, IConstTpQueue &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<TpQueue>");
	// field Name
	{
		const char* s = src.getName();
		if (s && *s)
		{
			buffer.append("<Name>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Name>");
		}
	}
	// field WorkUnit
	{
		const char* s = src.getWorkUnit();
		if (s && *s)
		{
			buffer.append("<WorkUnit>");
			encodeUtf8XML(s,buffer);
			buffer.append("</WorkUnit>");
		}
	}
	if (keepRootTag)
		buffer.append("</TpQueue>");
}

bool CTpQueue::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_Name.unmarshall(rpc_request, "Name", basepath);
	hasValue |= m_WorkUnit.unmarshall(rpc_request, "WorkUnit", basepath);
	return hasValue;
}

bool CTpQueue::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Name.unmarshall(ctx, soapval, "Name");
	hasValue |= m_WorkUnit.unmarshall(ctx, soapval, "WorkUnit");
	return hasValue;
}

bool CTpQueue::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Name.unmarshall(ctx, params, attachments, "Name", basepath);
	hasValue |= m_WorkUnit.unmarshall(ctx, params, attachments, "WorkUnit", basepath);
	return hasValue;
}

const char * CTpQueue::getName() { return m_Name.query();}
const char * CTpQueue::getWorkUnit() { return m_WorkUnit.query();}
void CTpQueue::setName(const char * val){ m_Name.set(val); }
void CTpQueue::setWorkUnit(const char * val){ m_WorkUnit.set(val); }
extern "C"  IEspTpQueue *createTpQueue(const char *serv, const char *msgname){return ((IEspTpQueue *)new CTpQueue(serv /*, msgname*/));}
extern "C"  IClientTpQueue *createClientTpQueue(const char *serv, const char *msgname){return ((IClientTpQueue *)new CTpQueue(serv /*, msgname*/));}

//=======================================================
// class CTpServices Implementation
//=======================================================

CTpServices::CTpServices(const char *serviceName, IRpcMessageBinding *init)
	: m_TpDalis(nilIgnore),m_TpDfuServers(nilIgnore),m_TpDkcSlaves(nilIgnore),m_TpDropZones(nilIgnore),m_TpEclAgents(nilIgnore),m_TpEclServers(nilIgnore),m_TpEclCCServers(nilIgnore),m_TpEclSchedulers(nilIgnore),m_TpEspServers(nilIgnore),m_TpFTSlaves(nilIgnore),m_TpGenesisServers(nilIgnore),m_TpLdapServers(nilIgnore),m_TpMySqlServers(nilIgnore),m_TpSashaServers(nilIgnore),m_TpSparkThors(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("TpServices");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CTpServices::CTpServices(const char *serviceName, const char *bc)
	: m_TpDalis(nilIgnore),m_TpDfuServers(nilIgnore),m_TpDkcSlaves(nilIgnore),m_TpDropZones(nilIgnore),m_TpEclAgents(nilIgnore),m_TpEclServers(nilIgnore),m_TpEclCCServers(nilIgnore),m_TpEclSchedulers(nilIgnore),m_TpEspServers(nilIgnore),m_TpFTSlaves(nilIgnore),m_TpGenesisServers(nilIgnore),m_TpLdapServers(nilIgnore),m_TpMySqlServers(nilIgnore),m_TpSashaServers(nilIgnore),m_TpSparkThors(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("TpServices");
}

StringBuffer &CTpServices::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:complexType name=\"%s\">\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"TpDalis\" type=\"tns:ArrayOfTpDali\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"TpDfuServers\" type=\"tns:ArrayOfTpDfuServer\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"TpDkcSlaves\" type=\"tns:ArrayOfTpDkcSlave\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"TpDropZones\" type=\"tns:ArrayOfTpDropZone\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"TpEclAgents\" type=\"tns:ArrayOfTpEclAgent\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"TpEclServers\" type=\"tns:ArrayOfTpEclServer\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"TpEclCCServers\" type=\"tns:ArrayOfTpEclServer\"/>\n");
		if (!context.suppressed("TpServices","TpEclSchedulers")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"TpEclSchedulers\" type=\"tns:ArrayOfTpEclScheduler\"/>\n");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"TpEspServers\" type=\"tns:ArrayOfTpEspServer\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"TpFTSlaves\" type=\"tns:ArrayOfTpFTSlave\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"TpGenesisServers\" type=\"tns:ArrayOfTpGenesisServer\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"TpLdapServers\" type=\"tns:ArrayOfTpLdapServer\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"TpMySqlServers\" type=\"tns:ArrayOfTpMySqlServer\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"TpSashaServers\" type=\"tns:ArrayOfTpSashaServer\"/>\n");
		if (!context.suppressed("TpServices","TpSparkThors")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"TpSparkThors\" type=\"tns:ArrayOfTpSparkThor\"/>\n");
		}
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType>\n");
		}
	}
	if (!(flags & 0x10)  || (flags & 0x100))
	{
		CTpDali::getXsdDefinition(context, request, schema, added);
		CTpDfuServer::getXsdDefinition(context, request, schema, added);
		CTpDkcSlave::getXsdDefinition(context, request, schema, added);
		CTpDropZone::getXsdDefinition(context, request, schema, added);
		CTpEclAgent::getXsdDefinition(context, request, schema, added);
		CTpEclServer::getXsdDefinition(context, request, schema, added);
		if (!context.suppressed("TpServices","TpEclSchedulers"))
			CTpEclScheduler::getXsdDefinition(context, request, schema, added);
		CTpEspServer::getXsdDefinition(context, request, schema, added);
		CTpFTSlave::getXsdDefinition(context, request, schema, added);
		CTpGenesisServer::getXsdDefinition(context, request, schema, added);
		CTpLdapServer::getXsdDefinition(context, request, schema, added);
		CTpMySqlServer::getXsdDefinition(context, request, schema, added);
		CTpSashaServer::getXsdDefinition(context, request, schema, added);
		if (!context.suppressed("TpServices","TpSparkThors"))
			CTpSparkThor::getXsdDefinition(context, request, schema, added);
	}
	if (added.getValue("TpDali") && added.getValue("ArrayOfTpDali")==NULL) {
		schema.append("<xsd:complexType name=\"ArrayOfTpDali\">\n");
		schema.append("<xsd:sequence>\n");
		schema.append("<xsd:element minOccurs=\"0\" maxOccurs=\"unbounded\" name=\"TpDali\" type=\"tns:TpDali\"/>\n");
		schema.append("</xsd:sequence>\n");
		schema.append("</xsd:complexType>\n");
		added.setValue("ArrayOfTpDali",1);
	}
	if (added.getValue("TpDfuServer") && added.getValue("ArrayOfTpDfuServer")==NULL) {
		schema.append("<xsd:complexType name=\"ArrayOfTpDfuServer\">\n");
		schema.append("<xsd:sequence>\n");
		schema.append("<xsd:element minOccurs=\"0\" maxOccurs=\"unbounded\" name=\"TpDfuServer\" type=\"tns:TpDfuServer\"/>\n");
		schema.append("</xsd:sequence>\n");
		schema.append("</xsd:complexType>\n");
		added.setValue("ArrayOfTpDfuServer",1);
	}
	if (added.getValue("TpDkcSlave") && added.getValue("ArrayOfTpDkcSlave")==NULL) {
		schema.append("<xsd:complexType name=\"ArrayOfTpDkcSlave\">\n");
		schema.append("<xsd:sequence>\n");
		schema.append("<xsd:element minOccurs=\"0\" maxOccurs=\"unbounded\" name=\"TpDkcSlave\" type=\"tns:TpDkcSlave\"/>\n");
		schema.append("</xsd:sequence>\n");
		schema.append("</xsd:complexType>\n");
		added.setValue("ArrayOfTpDkcSlave",1);
	}
	if (added.getValue("TpDropZone") && added.getValue("ArrayOfTpDropZone")==NULL) {
		schema.append("<xsd:complexType name=\"ArrayOfTpDropZone\">\n");
		schema.append("<xsd:sequence>\n");
		schema.append("<xsd:element minOccurs=\"0\" maxOccurs=\"unbounded\" name=\"TpDropZone\" type=\"tns:TpDropZone\"/>\n");
		schema.append("</xsd:sequence>\n");
		schema.append("</xsd:complexType>\n");
		added.setValue("ArrayOfTpDropZone",1);
	}
	if (added.getValue("TpEclAgent") && added.getValue("ArrayOfTpEclAgent")==NULL) {
		schema.append("<xsd:complexType name=\"ArrayOfTpEclAgent\">\n");
		schema.append("<xsd:sequence>\n");
		schema.append("<xsd:element minOccurs=\"0\" maxOccurs=\"unbounded\" name=\"TpEclAgent\" type=\"tns:TpEclAgent\"/>\n");
		schema.append("</xsd:sequence>\n");
		schema.append("</xsd:complexType>\n");
		added.setValue("ArrayOfTpEclAgent",1);
	}
	if (added.getValue("TpEclScheduler") && added.getValue("ArrayOfTpEclScheduler")==NULL) {
		schema.append("<xsd:complexType name=\"ArrayOfTpEclScheduler\">\n");
		schema.append("<xsd:sequence>\n");
		schema.append("<xsd:element minOccurs=\"0\" maxOccurs=\"unbounded\" name=\"TpEclScheduler\" type=\"tns:TpEclScheduler\"/>\n");
		schema.append("</xsd:sequence>\n");
		schema.append("</xsd:complexType>\n");
		added.setValue("ArrayOfTpEclScheduler",1);
	}
	if (added.getValue("TpEclServer") && added.getValue("ArrayOfTpEclServer")==NULL) {
		schema.append("<xsd:complexType name=\"ArrayOfTpEclServer\">\n");
		schema.append("<xsd:sequence>\n");
		schema.append("<xsd:element minOccurs=\"0\" maxOccurs=\"unbounded\" name=\"TpEclServer\" type=\"tns:TpEclServer\"/>\n");
		schema.append("</xsd:sequence>\n");
		schema.append("</xsd:complexType>\n");
		added.setValue("ArrayOfTpEclServer",1);
	}
	if (added.getValue("TpEspServer") && added.getValue("ArrayOfTpEspServer")==NULL) {
		schema.append("<xsd:complexType name=\"ArrayOfTpEspServer\">\n");
		schema.append("<xsd:sequence>\n");
		schema.append("<xsd:element minOccurs=\"0\" maxOccurs=\"unbounded\" name=\"TpEspServer\" type=\"tns:TpEspServer\"/>\n");
		schema.append("</xsd:sequence>\n");
		schema.append("</xsd:complexType>\n");
		added.setValue("ArrayOfTpEspServer",1);
	}
	if (added.getValue("TpFTSlave") && added.getValue("ArrayOfTpFTSlave")==NULL) {
		schema.append("<xsd:complexType name=\"ArrayOfTpFTSlave\">\n");
		schema.append("<xsd:sequence>\n");
		schema.append("<xsd:element minOccurs=\"0\" maxOccurs=\"unbounded\" name=\"TpFTSlave\" type=\"tns:TpFTSlave\"/>\n");
		schema.append("</xsd:sequence>\n");
		schema.append("</xsd:complexType>\n");
		added.setValue("ArrayOfTpFTSlave",1);
	}
	if (added.getValue("TpGenesisServer") && added.getValue("ArrayOfTpGenesisServer")==NULL) {
		schema.append("<xsd:complexType name=\"ArrayOfTpGenesisServer\">\n");
		schema.append("<xsd:sequence>\n");
		schema.append("<xsd:element minOccurs=\"0\" maxOccurs=\"unbounded\" name=\"TpGenesisServer\" type=\"tns:TpGenesisServer\"/>\n");
		schema.append("</xsd:sequence>\n");
		schema.append("</xsd:complexType>\n");
		added.setValue("ArrayOfTpGenesisServer",1);
	}
	if (added.getValue("TpLdapServer") && added.getValue("ArrayOfTpLdapServer")==NULL) {
		schema.append("<xsd:complexType name=\"ArrayOfTpLdapServer\">\n");
		schema.append("<xsd:sequence>\n");
		schema.append("<xsd:element minOccurs=\"0\" maxOccurs=\"unbounded\" name=\"TpLdapServer\" type=\"tns:TpLdapServer\"/>\n");
		schema.append("</xsd:sequence>\n");
		schema.append("</xsd:complexType>\n");
		added.setValue("ArrayOfTpLdapServer",1);
	}
	if (added.getValue("TpMySqlServer") && added.getValue("ArrayOfTpMySqlServer")==NULL) {
		schema.append("<xsd:complexType name=\"ArrayOfTpMySqlServer\">\n");
		schema.append("<xsd:sequence>\n");
		schema.append("<xsd:element minOccurs=\"0\" maxOccurs=\"unbounded\" name=\"TpMySqlServer\" type=\"tns:TpMySqlServer\"/>\n");
		schema.append("</xsd:sequence>\n");
		schema.append("</xsd:complexType>\n");
		added.setValue("ArrayOfTpMySqlServer",1);
	}
	if (added.getValue("TpSashaServer") && added.getValue("ArrayOfTpSashaServer")==NULL) {
		schema.append("<xsd:complexType name=\"ArrayOfTpSashaServer\">\n");
		schema.append("<xsd:sequence>\n");
		schema.append("<xsd:element minOccurs=\"0\" maxOccurs=\"unbounded\" name=\"TpSashaServer\" type=\"tns:TpSashaServer\"/>\n");
		schema.append("</xsd:sequence>\n");
		schema.append("</xsd:complexType>\n");
		added.setValue("ArrayOfTpSashaServer",1);
	}
	if (added.getValue("TpSparkThor") && added.getValue("ArrayOfTpSparkThor")==NULL) {
		schema.append("<xsd:complexType name=\"ArrayOfTpSparkThor\">\n");
		schema.append("<xsd:sequence>\n");
		schema.append("<xsd:element minOccurs=\"0\" maxOccurs=\"unbounded\" name=\"TpSparkThor\" type=\"tns:TpSparkThor\"/>\n");
		schema.append("</xsd:sequence>\n");
		schema.append("</xsd:complexType>\n");
		added.setValue("ArrayOfTpSparkThor",1);
	}
	return schema;
}

void CTpServices::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CTpServices::getMapInfo(IMapInfo& info, BoolHash& added)
{
	info.addMinVersion("TpServices","TpEclSchedulers",1.16);
	info.addMinVersion("TpServices","TpSparkThors",1.28);
	if (!added.getValue("TpDali"))
	{
		added.setValue("TpDali",1);
		CTpDali::getMapInfo(info,added);
	}
	if (!added.getValue("TpDfuServer"))
	{
		added.setValue("TpDfuServer",1);
		CTpDfuServer::getMapInfo(info,added);
	}
	if (!added.getValue("TpDkcSlave"))
	{
		added.setValue("TpDkcSlave",1);
		CTpDkcSlave::getMapInfo(info,added);
	}
	if (!added.getValue("TpDropZone"))
	{
		added.setValue("TpDropZone",1);
		CTpDropZone::getMapInfo(info,added);
	}
	if (!added.getValue("TpEclAgent"))
	{
		added.setValue("TpEclAgent",1);
		CTpEclAgent::getMapInfo(info,added);
	}
	if (!added.getValue("TpEclScheduler"))
	{
		added.setValue("TpEclScheduler",1);
		CTpEclScheduler::getMapInfo(info,added);
	}
	if (!added.getValue("TpEclServer"))
	{
		added.setValue("TpEclServer",1);
		CTpEclServer::getMapInfo(info,added);
	}
	if (!added.getValue("TpEspServer"))
	{
		added.setValue("TpEspServer",1);
		CTpEspServer::getMapInfo(info,added);
	}
	if (!added.getValue("TpFTSlave"))
	{
		added.setValue("TpFTSlave",1);
		CTpFTSlave::getMapInfo(info,added);
	}
	if (!added.getValue("TpGenesisServer"))
	{
		added.setValue("TpGenesisServer",1);
		CTpGenesisServer::getMapInfo(info,added);
	}
	if (!added.getValue("TpLdapServer"))
	{
		added.setValue("TpLdapServer",1);
		CTpLdapServer::getMapInfo(info,added);
	}
	if (!added.getValue("TpMySqlServer"))
	{
		added.setValue("TpMySqlServer",1);
		CTpMySqlServer::getMapInfo(info,added);
	}
	if (!added.getValue("TpSashaServer"))
	{
		added.setValue("TpSashaServer",1);
		CTpSashaServer::getMapInfo(info,added);
	}
	if (!added.getValue("TpSparkThor"))
	{
		added.setValue("TpSparkThor",1);
		CTpSparkThor::getMapInfo(info,added);
	}
}

StringBuffer &CTpServices::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("TpDalis");
	form.appendf("<tr><td><b>TpDalis: </b></td><td>");
	form.appendf("<table><tr><td><textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea></td>", extfix.str());
	form.append("</tr></table>");
	form.append("</td></tr>");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("TpDfuServers");
	form.appendf("<tr><td><b>TpDfuServers: </b></td><td>");
	form.appendf("<table><tr><td><textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea></td>", extfix.str());
	form.append("</tr></table>");
	form.append("</td></tr>");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("TpDkcSlaves");
	form.appendf("<tr><td><b>TpDkcSlaves: </b></td><td>");
	form.appendf("<table><tr><td><textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea></td>", extfix.str());
	form.append("</tr></table>");
	form.append("</td></tr>");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("TpDropZones");
	form.appendf("<tr><td><b>TpDropZones: </b></td><td>");
	form.appendf("<table><tr><td><textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea></td>", extfix.str());
	form.append("</tr></table>");
	form.append("</td></tr>");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("TpEclAgents");
	form.appendf("<tr><td><b>TpEclAgents: </b></td><td>");
	form.appendf("<table><tr><td><textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea></td>", extfix.str());
	form.append("</tr></table>");
	form.append("</td></tr>");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("TpEclServers");
	form.appendf("<tr><td><b>TpEclServers: </b></td><td>");
	form.appendf("<table><tr><td><textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea></td>", extfix.str());
	form.append("</tr></table>");
	form.append("</td></tr>");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("TpEclCCServers");
	form.appendf("<tr><td><b>TpEclCCServers: </b></td><td>");
	form.appendf("<table><tr><td><textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea></td>", extfix.str());
	form.append("</tr></table>");
	form.append("</td></tr>");
	if (!context.suppressed("TpServices","TpEclSchedulers")) {
		extfix.clear();
		if (prefix && *prefix)
			extfix.append(prefix).append(".");
		extfix.append("TpEclSchedulers");
		form.appendf("<tr><td><b>TpEclSchedulers: </b></td><td>");
		form.appendf("<table><tr><td><textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea></td>", extfix.str());
		form.append("</tr></table>");
		form.append("</td></tr>");
	}
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("TpEspServers");
	form.appendf("<tr><td><b>TpEspServers: </b></td><td>");
	form.appendf("<table><tr><td><textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea></td>", extfix.str());
	form.append("</tr></table>");
	form.append("</td></tr>");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("TpFTSlaves");
	form.appendf("<tr><td><b>TpFTSlaves: </b></td><td>");
	form.appendf("<table><tr><td><textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea></td>", extfix.str());
	form.append("</tr></table>");
	form.append("</td></tr>");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("TpGenesisServers");
	form.appendf("<tr><td><b>TpGenesisServers: </b></td><td>");
	form.appendf("<table><tr><td><textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea></td>", extfix.str());
	form.append("</tr></table>");
	form.append("</td></tr>");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("TpLdapServers");
	form.appendf("<tr><td><b>TpLdapServers: </b></td><td>");
	form.appendf("<table><tr><td><textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea></td>", extfix.str());
	form.append("</tr></table>");
	form.append("</td></tr>");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("TpMySqlServers");
	form.appendf("<tr><td><b>TpMySqlServers: </b></td><td>");
	form.appendf("<table><tr><td><textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea></td>", extfix.str());
	form.append("</tr></table>");
	form.append("</td></tr>");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("TpSashaServers");
	form.appendf("<tr><td><b>TpSashaServers: </b></td><td>");
	form.appendf("<table><tr><td><textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea></td>", extfix.str());
	form.append("</tr></table>");
	form.append("</td></tr>");
	if (!context.suppressed("TpServices","TpSparkThors")) {
		extfix.clear();
		if (prefix && *prefix)
			extfix.append(prefix).append(".");
		extfix.append("TpSparkThors");
		form.appendf("<tr><td><b>TpSparkThors: </b></td><td>");
		form.appendf("<table><tr><td><textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea></td>", extfix.str());
		form.append("</tr></table>");
		form.append("</td></tr>");
	}
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CTpServices::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CTpServices::serialize(IRpcMessage& rpc_resp)
{
	IEspContext* ctx = rpc_resp.queryContext();
	double clientVer= ctx ? ctx->getClientVersion() : -1; /* no context gets everything */
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_TpDalis.marshall(rpc_resp, "TpDalis", "TpDali");
	m_TpDfuServers.marshall(rpc_resp, "TpDfuServers", "TpDfuServer");
	m_TpDkcSlaves.marshall(rpc_resp, "TpDkcSlaves", "TpDkcSlave");
	m_TpDropZones.marshall(rpc_resp, "TpDropZones", "TpDropZone");
	m_TpEclAgents.marshall(rpc_resp, "TpEclAgents", "TpEclAgent");
	m_TpEclServers.marshall(rpc_resp, "TpEclServers", "TpEclServer");
	m_TpEclCCServers.marshall(rpc_resp, "TpEclCCServers", "TpEclServer");
	if ((clientVer==-1.0 || clientVer>=1.16))
		m_TpEclSchedulers.marshall(rpc_resp, "TpEclSchedulers", "TpEclScheduler");
	m_TpEspServers.marshall(rpc_resp, "TpEspServers", "TpEspServer");
	m_TpFTSlaves.marshall(rpc_resp, "TpFTSlaves", "TpFTSlave");
	m_TpGenesisServers.marshall(rpc_resp, "TpGenesisServers", "TpGenesisServer");
	m_TpLdapServers.marshall(rpc_resp, "TpLdapServers", "TpLdapServer");
	m_TpMySqlServers.marshall(rpc_resp, "TpMySqlServers", "TpMySqlServer");
	m_TpSashaServers.marshall(rpc_resp, "TpSashaServers", "TpSashaServer");
	if ((clientVer==-1.0 || clientVer>=1.28))
		m_TpSparkThors.marshall(rpc_resp, "TpSparkThors", "TpSparkThor");
}


void CTpServices::copy(CTpServices &from)
{
	m_TpDalis.copy(from.m_TpDalis);
	m_TpDfuServers.copy(from.m_TpDfuServers);
	m_TpDkcSlaves.copy(from.m_TpDkcSlaves);
	m_TpDropZones.copy(from.m_TpDropZones);
	m_TpEclAgents.copy(from.m_TpEclAgents);
	m_TpEclServers.copy(from.m_TpEclServers);
	m_TpEclCCServers.copy(from.m_TpEclCCServers);
	m_TpEclSchedulers.copy(from.m_TpEclSchedulers);
	m_TpEspServers.copy(from.m_TpEspServers);
	m_TpFTSlaves.copy(from.m_TpFTSlaves);
	m_TpGenesisServers.copy(from.m_TpGenesisServers);
	m_TpLdapServers.copy(from.m_TpLdapServers);
	m_TpMySqlServers.copy(from.m_TpMySqlServers);
	m_TpSashaServers.copy(from.m_TpSashaServers);
	m_TpSparkThors.copy(from.m_TpSparkThors);
}


void CTpServices::copy(IConstTpServices &ifrom)
{
	setTpDalis(ifrom.getTpDalis());
	setTpDfuServers(ifrom.getTpDfuServers());
	setTpDkcSlaves(ifrom.getTpDkcSlaves());
	setTpDropZones(ifrom.getTpDropZones());
	setTpEclAgents(ifrom.getTpEclAgents());
	setTpEclServers(ifrom.getTpEclServers());
	setTpEclCCServers(ifrom.getTpEclCCServers());
	setTpEclSchedulers(ifrom.getTpEclSchedulers());
	setTpEspServers(ifrom.getTpEspServers());
	setTpFTSlaves(ifrom.getTpFTSlaves());
	setTpGenesisServers(ifrom.getTpGenesisServers());
	setTpLdapServers(ifrom.getTpLdapServers());
	setTpMySqlServers(ifrom.getTpMySqlServers());
	setTpSashaServers(ifrom.getTpSashaServers());
	setTpSparkThors(ifrom.getTpSparkThors());
}


void CTpServices::getAttributes(IProperties &attributes)
{
}


void CTpServices::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	double clientVer = ctx ? ctx->getClientVersion() : -1;
	m_TpDalis.toStr(ctx, buffer, "TpDalis", "TpDali");
	m_TpDfuServers.toStr(ctx, buffer, "TpDfuServers", "TpDfuServer");
	m_TpDkcSlaves.toStr(ctx, buffer, "TpDkcSlaves", "TpDkcSlave");
	m_TpDropZones.toStr(ctx, buffer, "TpDropZones", "TpDropZone");
	m_TpEclAgents.toStr(ctx, buffer, "TpEclAgents", "TpEclAgent");
	m_TpEclServers.toStr(ctx, buffer, "TpEclServers", "TpEclServer");
	m_TpEclCCServers.toStr(ctx, buffer, "TpEclCCServers", "TpEclServer");
	if ((clientVer==-1.0 || clientVer>=1.16))
		m_TpEclSchedulers.toStr(ctx, buffer, "TpEclSchedulers", "TpEclScheduler");
	m_TpEspServers.toStr(ctx, buffer, "TpEspServers", "TpEspServer");
	m_TpFTSlaves.toStr(ctx, buffer, "TpFTSlaves", "TpFTSlave");
	m_TpGenesisServers.toStr(ctx, buffer, "TpGenesisServers", "TpGenesisServer");
	m_TpLdapServers.toStr(ctx, buffer, "TpLdapServers", "TpLdapServer");
	m_TpMySqlServers.toStr(ctx, buffer, "TpMySqlServers", "TpMySqlServer");
	m_TpSashaServers.toStr(ctx, buffer, "TpSashaServers", "TpSashaServer");
	if ((clientVer==-1.0 || clientVer>=1.28))
		m_TpSparkThors.toStr(ctx, buffer, "TpSparkThors", "TpSparkThor");
}


void CTpServices::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CTpServices::serializer(IEspContext* ctx, IConstTpServices &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<TpServices>");
	double clientVer = ctx ? ctx->getClientVersion() : -1;
	// field TpDalis
	{
		IArrayOf<IConstTpDali>& v = src.getTpDalis();
		int size = v.length();
		if (size>0)
			buffer.append("<TpDalis>");
		for (int i=0;i<size;i++)
		{
			buffer.append("<Item>");
			CTpDali::serializer(ctx,v.item(i),buffer,false);
			buffer.append("</Item>");
		}
		if (size>0)
			buffer.append("</TpDalis>");
	}
	// field TpDfuServers
	{
		IArrayOf<IConstTpDfuServer>& v = src.getTpDfuServers();
		int size = v.length();
		if (size>0)
			buffer.append("<TpDfuServers>");
		for (int i=0;i<size;i++)
		{
			buffer.append("<Item>");
			CTpDfuServer::serializer(ctx,v.item(i),buffer,false);
			buffer.append("</Item>");
		}
		if (size>0)
			buffer.append("</TpDfuServers>");
	}
	// field TpDkcSlaves
	{
		IArrayOf<IConstTpDkcSlave>& v = src.getTpDkcSlaves();
		int size = v.length();
		if (size>0)
			buffer.append("<TpDkcSlaves>");
		for (int i=0;i<size;i++)
		{
			buffer.append("<Item>");
			CTpDkcSlave::serializer(ctx,v.item(i),buffer,false);
			buffer.append("</Item>");
		}
		if (size>0)
			buffer.append("</TpDkcSlaves>");
	}
	// field TpDropZones
	{
		IArrayOf<IConstTpDropZone>& v = src.getTpDropZones();
		int size = v.length();
		if (size>0)
			buffer.append("<TpDropZones>");
		for (int i=0;i<size;i++)
		{
			buffer.append("<Item>");
			CTpDropZone::serializer(ctx,v.item(i),buffer,false);
			buffer.append("</Item>");
		}
		if (size>0)
			buffer.append("</TpDropZones>");
	}
	// field TpEclAgents
	{
		IArrayOf<IConstTpEclAgent>& v = src.getTpEclAgents();
		int size = v.length();
		if (size>0)
			buffer.append("<TpEclAgents>");
		for (int i=0;i<size;i++)
		{
			buffer.append("<Item>");
			CTpEclAgent::serializer(ctx,v.item(i),buffer,false);
			buffer.append("</Item>");
		}
		if (size>0)
			buffer.append("</TpEclAgents>");
	}
	// field TpEclServers
	{
		IArrayOf<IConstTpEclServer>& v = src.getTpEclServers();
		int size = v.length();
		if (size>0)
			buffer.append("<TpEclServers>");
		for (int i=0;i<size;i++)
		{
			buffer.append("<Item>");
			CTpEclServer::serializer(ctx,v.item(i),buffer,false);
			buffer.append("</Item>");
		}
		if (size>0)
			buffer.append("</TpEclServers>");
	}
	// field TpEclCCServers
	{
		IArrayOf<IConstTpEclServer>& v = src.getTpEclCCServers();
		int size = v.length();
		if (size>0)
			buffer.append("<TpEclCCServers>");
		for (int i=0;i<size;i++)
		{
			buffer.append("<Item>");
			CTpEclServer::serializer(ctx,v.item(i),buffer,false);
			buffer.append("</Item>");
		}
		if (size>0)
			buffer.append("</TpEclCCServers>");
	}
	// field TpEclSchedulers
	if ((clientVer==-1.0 || clientVer>=1.16))
	{
		IArrayOf<IConstTpEclScheduler>& v = src.getTpEclSchedulers();
		int size = v.length();
		if (size>0)
			buffer.append("<TpEclSchedulers>");
		for (int i=0;i<size;i++)
		{
			buffer.append("<Item>");
			CTpEclScheduler::serializer(ctx,v.item(i),buffer,false);
			buffer.append("</Item>");
		}
		if (size>0)
			buffer.append("</TpEclSchedulers>");
	}
	// field TpEspServers
	{
		IArrayOf<IConstTpEspServer>& v = src.getTpEspServers();
		int size = v.length();
		if (size>0)
			buffer.append("<TpEspServers>");
		for (int i=0;i<size;i++)
		{
			buffer.append("<Item>");
			CTpEspServer::serializer(ctx,v.item(i),buffer,false);
			buffer.append("</Item>");
		}
		if (size>0)
			buffer.append("</TpEspServers>");
	}
	// field TpFTSlaves
	{
		IArrayOf<IConstTpFTSlave>& v = src.getTpFTSlaves();
		int size = v.length();
		if (size>0)
			buffer.append("<TpFTSlaves>");
		for (int i=0;i<size;i++)
		{
			buffer.append("<Item>");
			CTpFTSlave::serializer(ctx,v.item(i),buffer,false);
			buffer.append("</Item>");
		}
		if (size>0)
			buffer.append("</TpFTSlaves>");
	}
	// field TpGenesisServers
	{
		IArrayOf<IConstTpGenesisServer>& v = src.getTpGenesisServers();
		int size = v.length();
		if (size>0)
			buffer.append("<TpGenesisServers>");
		for (int i=0;i<size;i++)
		{
			buffer.append("<Item>");
			CTpGenesisServer::serializer(ctx,v.item(i),buffer,false);
			buffer.append("</Item>");
		}
		if (size>0)
			buffer.append("</TpGenesisServers>");
	}
	// field TpLdapServers
	{
		IArrayOf<IConstTpLdapServer>& v = src.getTpLdapServers();
		int size = v.length();
		if (size>0)
			buffer.append("<TpLdapServers>");
		for (int i=0;i<size;i++)
		{
			buffer.append("<Item>");
			CTpLdapServer::serializer(ctx,v.item(i),buffer,false);
			buffer.append("</Item>");
		}
		if (size>0)
			buffer.append("</TpLdapServers>");
	}
	// field TpMySqlServers
	{
		IArrayOf<IConstTpMySqlServer>& v = src.getTpMySqlServers();
		int size = v.length();
		if (size>0)
			buffer.append("<TpMySqlServers>");
		for (int i=0;i<size;i++)
		{
			buffer.append("<Item>");
			CTpMySqlServer::serializer(ctx,v.item(i),buffer,false);
			buffer.append("</Item>");
		}
		if (size>0)
			buffer.append("</TpMySqlServers>");
	}
	// field TpSashaServers
	{
		IArrayOf<IConstTpSashaServer>& v = src.getTpSashaServers();
		int size = v.length();
		if (size>0)
			buffer.append("<TpSashaServers>");
		for (int i=0;i<size;i++)
		{
			buffer.append("<Item>");
			CTpSashaServer::serializer(ctx,v.item(i),buffer,false);
			buffer.append("</Item>");
		}
		if (size>0)
			buffer.append("</TpSashaServers>");
	}
	// field TpSparkThors
	if ((clientVer==-1.0 || clientVer>=1.28))
	{
		IArrayOf<IConstTpSparkThor>& v = src.getTpSparkThors();
		int size = v.length();
		if (size>0)
			buffer.append("<TpSparkThors>");
		for (int i=0;i<size;i++)
		{
			buffer.append("<Item>");
			CTpSparkThor::serializer(ctx,v.item(i),buffer,false);
			buffer.append("</Item>");
		}
		if (size>0)
			buffer.append("</TpSparkThors>");
	}
	if (keepRootTag)
		buffer.append("</TpServices>");
}

bool CTpServices::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_TpDalis.unmarshall(rpc_request, "TpDalis", basepath);
	hasValue |= m_TpDfuServers.unmarshall(rpc_request, "TpDfuServers", basepath);
	hasValue |= m_TpDkcSlaves.unmarshall(rpc_request, "TpDkcSlaves", basepath);
	hasValue |= m_TpDropZones.unmarshall(rpc_request, "TpDropZones", basepath);
	hasValue |= m_TpEclAgents.unmarshall(rpc_request, "TpEclAgents", basepath);
	hasValue |= m_TpEclServers.unmarshall(rpc_request, "TpEclServers", basepath);
	hasValue |= m_TpEclCCServers.unmarshall(rpc_request, "TpEclCCServers", basepath);
	hasValue |= m_TpEclSchedulers.unmarshall(rpc_request, "TpEclSchedulers", basepath);
	hasValue |= m_TpEspServers.unmarshall(rpc_request, "TpEspServers", basepath);
	hasValue |= m_TpFTSlaves.unmarshall(rpc_request, "TpFTSlaves", basepath);
	hasValue |= m_TpGenesisServers.unmarshall(rpc_request, "TpGenesisServers", basepath);
	hasValue |= m_TpLdapServers.unmarshall(rpc_request, "TpLdapServers", basepath);
	hasValue |= m_TpMySqlServers.unmarshall(rpc_request, "TpMySqlServers", basepath);
	hasValue |= m_TpSashaServers.unmarshall(rpc_request, "TpSashaServers", basepath);
	hasValue |= m_TpSparkThors.unmarshall(rpc_request, "TpSparkThors", basepath);
	return hasValue;
}

bool CTpServices::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_TpDalis.unmarshall(ctx, soapval, "TpDalis");
	hasValue |= m_TpDfuServers.unmarshall(ctx, soapval, "TpDfuServers");
	hasValue |= m_TpDkcSlaves.unmarshall(ctx, soapval, "TpDkcSlaves");
	hasValue |= m_TpDropZones.unmarshall(ctx, soapval, "TpDropZones");
	hasValue |= m_TpEclAgents.unmarshall(ctx, soapval, "TpEclAgents");
	hasValue |= m_TpEclServers.unmarshall(ctx, soapval, "TpEclServers");
	hasValue |= m_TpEclCCServers.unmarshall(ctx, soapval, "TpEclCCServers");
	hasValue |= m_TpEclSchedulers.unmarshall(ctx, soapval, "TpEclSchedulers");
	hasValue |= m_TpEspServers.unmarshall(ctx, soapval, "TpEspServers");
	hasValue |= m_TpFTSlaves.unmarshall(ctx, soapval, "TpFTSlaves");
	hasValue |= m_TpGenesisServers.unmarshall(ctx, soapval, "TpGenesisServers");
	hasValue |= m_TpLdapServers.unmarshall(ctx, soapval, "TpLdapServers");
	hasValue |= m_TpMySqlServers.unmarshall(ctx, soapval, "TpMySqlServers");
	hasValue |= m_TpSashaServers.unmarshall(ctx, soapval, "TpSashaServers");
	hasValue |= m_TpSparkThors.unmarshall(ctx, soapval, "TpSparkThors");
	return hasValue;
}

bool CTpServices::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_TpDalis.unmarshall(ctx, params, attachments, "TpDalis", basepath);
	hasValue |= m_TpDfuServers.unmarshall(ctx, params, attachments, "TpDfuServers", basepath);
	hasValue |= m_TpDkcSlaves.unmarshall(ctx, params, attachments, "TpDkcSlaves", basepath);
	hasValue |= m_TpDropZones.unmarshall(ctx, params, attachments, "TpDropZones", basepath);
	hasValue |= m_TpEclAgents.unmarshall(ctx, params, attachments, "TpEclAgents", basepath);
	hasValue |= m_TpEclServers.unmarshall(ctx, params, attachments, "TpEclServers", basepath);
	hasValue |= m_TpEclCCServers.unmarshall(ctx, params, attachments, "TpEclCCServers", basepath);
	hasValue |= m_TpEclSchedulers.unmarshall(ctx, params, attachments, "TpEclSchedulers", basepath);
	hasValue |= m_TpEspServers.unmarshall(ctx, params, attachments, "TpEspServers", basepath);
	hasValue |= m_TpFTSlaves.unmarshall(ctx, params, attachments, "TpFTSlaves", basepath);
	hasValue |= m_TpGenesisServers.unmarshall(ctx, params, attachments, "TpGenesisServers", basepath);
	hasValue |= m_TpLdapServers.unmarshall(ctx, params, attachments, "TpLdapServers", basepath);
	hasValue |= m_TpMySqlServers.unmarshall(ctx, params, attachments, "TpMySqlServers", basepath);
	hasValue |= m_TpSashaServers.unmarshall(ctx, params, attachments, "TpSashaServers", basepath);
	hasValue |= m_TpSparkThors.unmarshall(ctx, params, attachments, "TpSparkThors", basepath);
	return hasValue;
}

IArrayOf<IConstTpDali> & CTpServices::getTpDalis() { return (IArrayOf<IConstTpDali> &) m_TpDalis; }
IArrayOf<IConstTpDfuServer> & CTpServices::getTpDfuServers() { return (IArrayOf<IConstTpDfuServer> &) m_TpDfuServers; }
IArrayOf<IConstTpDkcSlave> & CTpServices::getTpDkcSlaves() { return (IArrayOf<IConstTpDkcSlave> &) m_TpDkcSlaves; }
IArrayOf<IConstTpDropZone> & CTpServices::getTpDropZones() { return (IArrayOf<IConstTpDropZone> &) m_TpDropZones; }
IArrayOf<IConstTpEclAgent> & CTpServices::getTpEclAgents() { return (IArrayOf<IConstTpEclAgent> &) m_TpEclAgents; }
IArrayOf<IConstTpEclServer> & CTpServices::getTpEclServers() { return (IArrayOf<IConstTpEclServer> &) m_TpEclServers; }
IArrayOf<IConstTpEclServer> & CTpServices::getTpEclCCServers() { return (IArrayOf<IConstTpEclServer> &) m_TpEclCCServers; }
IArrayOf<IConstTpEclScheduler> & CTpServices::getTpEclSchedulers() { return (IArrayOf<IConstTpEclScheduler> &) m_TpEclSchedulers; }
IArrayOf<IConstTpEspServer> & CTpServices::getTpEspServers() { return (IArrayOf<IConstTpEspServer> &) m_TpEspServers; }
IArrayOf<IConstTpFTSlave> & CTpServices::getTpFTSlaves() { return (IArrayOf<IConstTpFTSlave> &) m_TpFTSlaves; }
IArrayOf<IConstTpGenesisServer> & CTpServices::getTpGenesisServers() { return (IArrayOf<IConstTpGenesisServer> &) m_TpGenesisServers; }
IArrayOf<IConstTpLdapServer> & CTpServices::getTpLdapServers() { return (IArrayOf<IConstTpLdapServer> &) m_TpLdapServers; }
IArrayOf<IConstTpMySqlServer> & CTpServices::getTpMySqlServers() { return (IArrayOf<IConstTpMySqlServer> &) m_TpMySqlServers; }
IArrayOf<IConstTpSashaServer> & CTpServices::getTpSashaServers() { return (IArrayOf<IConstTpSashaServer> &) m_TpSashaServers; }
IArrayOf<IConstTpSparkThor> & CTpServices::getTpSparkThors() { return (IArrayOf<IConstTpSparkThor> &) m_TpSparkThors; }
void CTpServices::setTpDalis(IArrayOf<IEspTpDali> &val)
{
	m_TpDalis->kill();
	IArrayOf<IConstTpDali> &target = m_TpDalis.getValue();
	ForEachItemIn(idx, val)
	{
		IEspTpDali &item = (val).item(idx);
		item.Link();
		target.append(item);
	}
}
void CTpServices::setTpDalis(IArrayOf<IConstTpDali> &val)
{
	m_TpDalis->kill();
	IArrayOf<IConstTpDali> &target = m_TpDalis.getValue();
	ForEachItemIn(idx, val)
	{
		IConstTpDali &item = val.item(idx);
		item.Link();
		target.append(item);
	}
}
void CTpServices::setTpDfuServers(IArrayOf<IEspTpDfuServer> &val)
{
	m_TpDfuServers->kill();
	IArrayOf<IConstTpDfuServer> &target = m_TpDfuServers.getValue();
	ForEachItemIn(idx, val)
	{
		IEspTpDfuServer &item = (val).item(idx);
		item.Link();
		target.append(item);
	}
}
void CTpServices::setTpDfuServers(IArrayOf<IConstTpDfuServer> &val)
{
	m_TpDfuServers->kill();
	IArrayOf<IConstTpDfuServer> &target = m_TpDfuServers.getValue();
	ForEachItemIn(idx, val)
	{
		IConstTpDfuServer &item = val.item(idx);
		item.Link();
		target.append(item);
	}
}
void CTpServices::setTpDkcSlaves(IArrayOf<IEspTpDkcSlave> &val)
{
	m_TpDkcSlaves->kill();
	IArrayOf<IConstTpDkcSlave> &target = m_TpDkcSlaves.getValue();
	ForEachItemIn(idx, val)
	{
		IEspTpDkcSlave &item = (val).item(idx);
		item.Link();
		target.append(item);
	}
}
void CTpServices::setTpDkcSlaves(IArrayOf<IConstTpDkcSlave> &val)
{
	m_TpDkcSlaves->kill();
	IArrayOf<IConstTpDkcSlave> &target = m_TpDkcSlaves.getValue();
	ForEachItemIn(idx, val)
	{
		IConstTpDkcSlave &item = val.item(idx);
		item.Link();
		target.append(item);
	}
}
void CTpServices::setTpDropZones(IArrayOf<IEspTpDropZone> &val)
{
	m_TpDropZones->kill();
	IArrayOf<IConstTpDropZone> &target = m_TpDropZones.getValue();
	ForEachItemIn(idx, val)
	{
		IEspTpDropZone &item = (val).item(idx);
		item.Link();
		target.append(item);
	}
}
void CTpServices::setTpDropZones(IArrayOf<IConstTpDropZone> &val)
{
	m_TpDropZones->kill();
	IArrayOf<IConstTpDropZone> &target = m_TpDropZones.getValue();
	ForEachItemIn(idx, val)
	{
		IConstTpDropZone &item = val.item(idx);
		item.Link();
		target.append(item);
	}
}
void CTpServices::setTpEclAgents(IArrayOf<IEspTpEclAgent> &val)
{
	m_TpEclAgents->kill();
	IArrayOf<IConstTpEclAgent> &target = m_TpEclAgents.getValue();
	ForEachItemIn(idx, val)
	{
		IEspTpEclAgent &item = (val).item(idx);
		item.Link();
		target.append(item);
	}
}
void CTpServices::setTpEclAgents(IArrayOf<IConstTpEclAgent> &val)
{
	m_TpEclAgents->kill();
	IArrayOf<IConstTpEclAgent> &target = m_TpEclAgents.getValue();
	ForEachItemIn(idx, val)
	{
		IConstTpEclAgent &item = val.item(idx);
		item.Link();
		target.append(item);
	}
}
void CTpServices::setTpEclServers(IArrayOf<IEspTpEclServer> &val)
{
	m_TpEclServers->kill();
	IArrayOf<IConstTpEclServer> &target = m_TpEclServers.getValue();
	ForEachItemIn(idx, val)
	{
		IEspTpEclServer &item = (val).item(idx);
		item.Link();
		target.append(item);
	}
}
void CTpServices::setTpEclServers(IArrayOf<IConstTpEclServer> &val)
{
	m_TpEclServers->kill();
	IArrayOf<IConstTpEclServer> &target = m_TpEclServers.getValue();
	ForEachItemIn(idx, val)
	{
		IConstTpEclServer &item = val.item(idx);
		item.Link();
		target.append(item);
	}
}
void CTpServices::setTpEclCCServers(IArrayOf<IEspTpEclServer> &val)
{
	m_TpEclCCServers->kill();
	IArrayOf<IConstTpEclServer> &target = m_TpEclCCServers.getValue();
	ForEachItemIn(idx, val)
	{
		IEspTpEclServer &item = (val).item(idx);
		item.Link();
		target.append(item);
	}
}
void CTpServices::setTpEclCCServers(IArrayOf<IConstTpEclServer> &val)
{
	m_TpEclCCServers->kill();
	IArrayOf<IConstTpEclServer> &target = m_TpEclCCServers.getValue();
	ForEachItemIn(idx, val)
	{
		IConstTpEclServer &item = val.item(idx);
		item.Link();
		target.append(item);
	}
}
void CTpServices::setTpEclSchedulers(IArrayOf<IEspTpEclScheduler> &val)
{
	m_TpEclSchedulers->kill();
	IArrayOf<IConstTpEclScheduler> &target = m_TpEclSchedulers.getValue();
	ForEachItemIn(idx, val)
	{
		IEspTpEclScheduler &item = (val).item(idx);
		item.Link();
		target.append(item);
	}
}
void CTpServices::setTpEclSchedulers(IArrayOf<IConstTpEclScheduler> &val)
{
	m_TpEclSchedulers->kill();
	IArrayOf<IConstTpEclScheduler> &target = m_TpEclSchedulers.getValue();
	ForEachItemIn(idx, val)
	{
		IConstTpEclScheduler &item = val.item(idx);
		item.Link();
		target.append(item);
	}
}
void CTpServices::setTpEspServers(IArrayOf<IEspTpEspServer> &val)
{
	m_TpEspServers->kill();
	IArrayOf<IConstTpEspServer> &target = m_TpEspServers.getValue();
	ForEachItemIn(idx, val)
	{
		IEspTpEspServer &item = (val).item(idx);
		item.Link();
		target.append(item);
	}
}
void CTpServices::setTpEspServers(IArrayOf<IConstTpEspServer> &val)
{
	m_TpEspServers->kill();
	IArrayOf<IConstTpEspServer> &target = m_TpEspServers.getValue();
	ForEachItemIn(idx, val)
	{
		IConstTpEspServer &item = val.item(idx);
		item.Link();
		target.append(item);
	}
}
void CTpServices::setTpFTSlaves(IArrayOf<IEspTpFTSlave> &val)
{
	m_TpFTSlaves->kill();
	IArrayOf<IConstTpFTSlave> &target = m_TpFTSlaves.getValue();
	ForEachItemIn(idx, val)
	{
		IEspTpFTSlave &item = (val).item(idx);
		item.Link();
		target.append(item);
	}
}
void CTpServices::setTpFTSlaves(IArrayOf<IConstTpFTSlave> &val)
{
	m_TpFTSlaves->kill();
	IArrayOf<IConstTpFTSlave> &target = m_TpFTSlaves.getValue();
	ForEachItemIn(idx, val)
	{
		IConstTpFTSlave &item = val.item(idx);
		item.Link();
		target.append(item);
	}
}
void CTpServices::setTpGenesisServers(IArrayOf<IEspTpGenesisServer> &val)
{
	m_TpGenesisServers->kill();
	IArrayOf<IConstTpGenesisServer> &target = m_TpGenesisServers.getValue();
	ForEachItemIn(idx, val)
	{
		IEspTpGenesisServer &item = (val).item(idx);
		item.Link();
		target.append(item);
	}
}
void CTpServices::setTpGenesisServers(IArrayOf<IConstTpGenesisServer> &val)
{
	m_TpGenesisServers->kill();
	IArrayOf<IConstTpGenesisServer> &target = m_TpGenesisServers.getValue();
	ForEachItemIn(idx, val)
	{
		IConstTpGenesisServer &item = val.item(idx);
		item.Link();
		target.append(item);
	}
}
void CTpServices::setTpLdapServers(IArrayOf<IEspTpLdapServer> &val)
{
	m_TpLdapServers->kill();
	IArrayOf<IConstTpLdapServer> &target = m_TpLdapServers.getValue();
	ForEachItemIn(idx, val)
	{
		IEspTpLdapServer &item = (val).item(idx);
		item.Link();
		target.append(item);
	}
}
void CTpServices::setTpLdapServers(IArrayOf<IConstTpLdapServer> &val)
{
	m_TpLdapServers->kill();
	IArrayOf<IConstTpLdapServer> &target = m_TpLdapServers.getValue();
	ForEachItemIn(idx, val)
	{
		IConstTpLdapServer &item = val.item(idx);
		item.Link();
		target.append(item);
	}
}
void CTpServices::setTpMySqlServers(IArrayOf<IEspTpMySqlServer> &val)
{
	m_TpMySqlServers->kill();
	IArrayOf<IConstTpMySqlServer> &target = m_TpMySqlServers.getValue();
	ForEachItemIn(idx, val)
	{
		IEspTpMySqlServer &item = (val).item(idx);
		item.Link();
		target.append(item);
	}
}
void CTpServices::setTpMySqlServers(IArrayOf<IConstTpMySqlServer> &val)
{
	m_TpMySqlServers->kill();
	IArrayOf<IConstTpMySqlServer> &target = m_TpMySqlServers.getValue();
	ForEachItemIn(idx, val)
	{
		IConstTpMySqlServer &item = val.item(idx);
		item.Link();
		target.append(item);
	}
}
void CTpServices::setTpSashaServers(IArrayOf<IEspTpSashaServer> &val)
{
	m_TpSashaServers->kill();
	IArrayOf<IConstTpSashaServer> &target = m_TpSashaServers.getValue();
	ForEachItemIn(idx, val)
	{
		IEspTpSashaServer &item = (val).item(idx);
		item.Link();
		target.append(item);
	}
}
void CTpServices::setTpSashaServers(IArrayOf<IConstTpSashaServer> &val)
{
	m_TpSashaServers->kill();
	IArrayOf<IConstTpSashaServer> &target = m_TpSashaServers.getValue();
	ForEachItemIn(idx, val)
	{
		IConstTpSashaServer &item = val.item(idx);
		item.Link();
		target.append(item);
	}
}
void CTpServices::setTpSparkThors(IArrayOf<IEspTpSparkThor> &val)
{
	m_TpSparkThors->kill();
	IArrayOf<IConstTpSparkThor> &target = m_TpSparkThors.getValue();
	ForEachItemIn(idx, val)
	{
		IEspTpSparkThor &item = (val).item(idx);
		item.Link();
		target.append(item);
	}
}
void CTpServices::setTpSparkThors(IArrayOf<IConstTpSparkThor> &val)
{
	m_TpSparkThors->kill();
	IArrayOf<IConstTpSparkThor> &target = m_TpSparkThors.getValue();
	ForEachItemIn(idx, val)
	{
		IConstTpSparkThor &item = val.item(idx);
		item.Link();
		target.append(item);
	}
}
extern "C"  IEspTpServices *createTpServices(const char *serv, const char *msgname){return ((IEspTpServices *)new CTpServices(serv /*, msgname*/));}
extern "C"  IClientTpServices *createClientTpServices(const char *serv, const char *msgname){return ((IClientTpServices *)new CTpServices(serv /*, msgname*/));}

//=======================================================
// class CTpClusterNameType Implementation
//=======================================================

CTpClusterNameType::CTpClusterNameType(const char *serviceName, IRpcMessageBinding *init)
	: m_Name(nilIgnore),m_Type(nilIgnore),m_IsDefault(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("TpClusterNameType");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CTpClusterNameType::CTpClusterNameType(const char *serviceName, const char *bc)
	: m_Name(nilIgnore),m_Type(nilIgnore),m_IsDefault(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("TpClusterNameType");
}

StringBuffer &CTpClusterNameType::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:complexType name=\"%s\">\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Name\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Type\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"IsDefault\" type=\"xsd:boolean\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType>\n");
		}
	}
	return schema;
}

void CTpClusterNameType::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CTpClusterNameType::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CTpClusterNameType::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Name");
	form.appendf("  <tr><td><b>Name: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Type");
	form.appendf("  <tr><td><b>Type: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("IsDefault");
	
	form.appendf("  <tr><td><b>IsDefault? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CTpClusterNameType::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CTpClusterNameType::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_Name.marshall(rpc_resp, "Name", "", "", "");
	m_Type.marshall(rpc_resp, "Type", "", "", "");
	m_IsDefault.marshall(rpc_resp, "IsDefault", "", "", "");
}


void CTpClusterNameType::copy(CTpClusterNameType &from)
{
	m_Name.copy(from.m_Name);
	m_Type.copy(from.m_Type);
	m_IsDefault.copy(from.m_IsDefault);
}


void CTpClusterNameType::copy(IConstTpClusterNameType &ifrom)
{
	setName(ifrom.getName());
	setType(ifrom.getType());
	setIsDefault(ifrom.getIsDefault());
}


void CTpClusterNameType::getAttributes(IProperties &attributes)
{
}


void CTpClusterNameType::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_Name.toStr(ctx, buffer, "Name", "", true, "", "");
	m_Type.toStr(ctx, buffer, "Type", "", true, "", "");
	m_IsDefault.toStr(ctx, buffer, "IsDefault", "", true, "", "");
}


void CTpClusterNameType::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CTpClusterNameType::serializer(IEspContext* ctx, IConstTpClusterNameType &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<TpClusterNameType>");
	// field Name
	{
		const char* s = src.getName();
		if (s && *s)
		{
			buffer.append("<Name>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Name>");
		}
	}
	// field Type
	{
		const char* s = src.getType();
		if (s && *s)
		{
			buffer.append("<Type>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Type>");
		}
	}
	// field IsDefault
	{
		bool b = src.getIsDefault();
		if (b)
			buffer.appendf("<IsDefault>1</IsDefault>");
	}
	if (keepRootTag)
		buffer.append("</TpClusterNameType>");
}

bool CTpClusterNameType::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_Name.unmarshall(rpc_request, "Name", basepath);
	hasValue |= m_Type.unmarshall(rpc_request, "Type", basepath);
	hasValue |= m_IsDefault.unmarshall(rpc_request, "IsDefault", basepath);
	return hasValue;
}

bool CTpClusterNameType::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Name.unmarshall(ctx, soapval, "Name");
	hasValue |= m_Type.unmarshall(ctx, soapval, "Type");
	hasValue |= m_IsDefault.unmarshall(ctx, soapval, "IsDefault");
	return hasValue;
}

bool CTpClusterNameType::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Name.unmarshall(ctx, params, attachments, "Name", basepath);
	hasValue |= m_Type.unmarshall(ctx, params, attachments, "Type", basepath);
	hasValue |= m_IsDefault.unmarshall(ctx, params, attachments, "IsDefault", basepath);
	return hasValue;
}

const char * CTpClusterNameType::getName() { return m_Name.query();}
const char * CTpClusterNameType::getType() { return m_Type.query();}
bool CTpClusterNameType::getIsDefault() { return m_IsDefault;}
void CTpClusterNameType::setName(const char * val){ m_Name.set(val); }
void CTpClusterNameType::setType(const char * val){ m_Type.set(val); }
void CTpClusterNameType::setIsDefault(bool val){ m_IsDefault=val; }
extern "C"  IEspTpClusterNameType *createTpClusterNameType(const char *serv, const char *msgname){return ((IEspTpClusterNameType *)new CTpClusterNameType(serv /*, msgname*/));}
extern "C"  IClientTpClusterNameType *createClientTpClusterNameType(const char *serv, const char *msgname){return ((IClientTpClusterNameType *)new CTpClusterNameType(serv /*, msgname*/));}

//=======================================================
// class CTpListTargetClustersRequest Implementation
//=======================================================

CTpListTargetClustersRequest::CTpListTargetClustersRequest(const char *serviceName, IRpcMessageBinding *init)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("TpListTargetClustersRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CTpListTargetClustersRequest::CTpListTargetClustersRequest(const char *serviceName, const char *bc)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("TpListTargetClustersRequest");
}

CTpListTargetClustersRequest::CTpListTargetClustersRequest(const char *serviceName, IRpcMessage* rpcmsg)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("TpListTargetClustersRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CTpListTargetClustersRequest::CTpListTargetClustersRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("TpListTargetClustersRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CTpListTargetClustersRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType><xsd:all/></xsd:complexType></xsd:element>\n", msgTypeName);
		}
	}
	return schema;
}

void CTpListTargetClustersRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CTpListTargetClustersRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CTpListTargetClustersRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CTpListTargetClustersRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CTpListTargetClustersRequest::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

}


void CTpListTargetClustersRequest::copy(CTpListTargetClustersRequest &from)
{
}


void CTpListTargetClustersRequest::copy(IConstTpListTargetClustersRequest &ifrom)
{
}


void CTpListTargetClustersRequest::getAttributes(IProperties &attributes)
{
}


void CTpListTargetClustersRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
}


void CTpListTargetClustersRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CTpListTargetClustersRequest::serializer(IEspContext* ctx, IConstTpListTargetClustersRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<TpListTargetClustersRequest>");
	if (keepRootTag)
		buffer.append("</TpListTargetClustersRequest>");
}

bool CTpListTargetClustersRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	return hasValue;
}

bool CTpListTargetClustersRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	return hasValue;
}

bool CTpListTargetClustersRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	return hasValue;
}

extern "C"  IEspTpListTargetClustersRequest *createTpListTargetClustersRequest(const char *serv){return ((IEspTpListTargetClustersRequest *)new CTpListTargetClustersRequest(serv));}
extern "C"  IClientTpListTargetClustersRequest *createClientTpListTargetClustersRequest(const char *serv){return ((IClientTpListTargetClustersRequest *)new CTpListTargetClustersRequest(serv));}

//=======================================================
// class CTpListTargetClustersResponse Implementation
//=======================================================

CTpListTargetClustersResponse::CTpListTargetClustersResponse(const char *serviceName, IRpcMessageBinding *init)
	: m_TargetClusters(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("TpListTargetClustersResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CTpListTargetClustersResponse::CTpListTargetClustersResponse(const char *serviceName, const char *bc)
	: m_TargetClusters(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("TpListTargetClustersResponse");
}

CTpListTargetClustersResponse::CTpListTargetClustersResponse(const char *serviceName, IRpcMessage* rpcmsg)
	: m_TargetClusters(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("TpListTargetClustersResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CTpListTargetClustersResponse::CTpListTargetClustersResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_TargetClusters(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("TpListTargetClustersResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CTpListTargetClustersResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		schema.append("<xsd:element name=\"Exceptions\" type=\"tns:ArrayOfEspException\" minOccurs=\"0\" maxOccurs=\"1\"/>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"TargetClusters\" type=\"tns:ArrayOfTpClusterNameType\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	if (!(flags & 0x10)  || (flags & 0x100))
	{
		CTpClusterNameType::getXsdDefinition(context, request, schema, added);
	}
	if (added.getValue("TpClusterNameType") && added.getValue("ArrayOfTpClusterNameType")==NULL) {
		schema.append("<xsd:complexType name=\"ArrayOfTpClusterNameType\">\n");
		schema.append("<xsd:sequence>\n");
		schema.append("<xsd:element minOccurs=\"0\" maxOccurs=\"unbounded\" name=\"TpClusterNameType\" type=\"tns:TpClusterNameType\"/>\n");
		schema.append("</xsd:sequence>\n");
		schema.append("</xsd:complexType>\n");
		added.setValue("ArrayOfTpClusterNameType",1);
	}
	return schema;
}

void CTpListTargetClustersResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CTpListTargetClustersResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
	if (!added.getValue("TpClusterNameType"))
	{
		added.setValue("TpClusterNameType",1);
		CTpClusterNameType::getMapInfo(info,added);
	}
}

StringBuffer &CTpListTargetClustersResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("TargetClusters");
	form.appendf("<tr><td><b>TargetClusters: </b></td><td>");
	form.appendf("<table><tr><td><textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea></td>", extfix.str());
	form.append("</tr></table>");
	form.append("</td></tr>");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CTpListTargetClustersResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CTpListTargetClustersResponse::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
		m_TargetClusters.marshall(rpc_resp, "TargetClusters", "TpClusterNameType");
	}
}


void CTpListTargetClustersResponse::copy(CTpListTargetClustersResponse &from)
{
	m_TargetClusters.copy(from.m_TargetClusters);
}


void CTpListTargetClustersResponse::copy(IConstTpListTargetClustersResponse &ifrom)
{
	setTargetClusters(ifrom.getTargetClusters());
}


void CTpListTargetClustersResponse::getAttributes(IProperties &attributes)
{
}


void CTpListTargetClustersResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
		m_TargetClusters.toStr(ctx, buffer, "TargetClusters", "TpClusterNameType");
	}
}


void CTpListTargetClustersResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CTpListTargetClustersResponse::serializer(IEspContext* ctx, IConstTpListTargetClustersResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<TpListTargetClustersResponse>");
	// field TargetClusters
	{
		IArrayOf<IConstTpClusterNameType>& v = src.getTargetClusters();
		int size = v.length();
		if (size>0)
			buffer.append("<TargetClusters>");
		for (int i=0;i<size;i++)
		{
			buffer.append("<Item>");
			CTpClusterNameType::serializer(ctx,v.item(i),buffer,false);
			buffer.append("</Item>");
		}
		if (size>0)
			buffer.append("</TargetClusters>");
	}
	if (keepRootTag)
		buffer.append("</TpListTargetClustersResponse>");
}

bool CTpListTargetClustersResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
		hasValue |= m_TargetClusters.unmarshall(rpc_request, "TargetClusters", basepath);
	}
	return hasValue;
}

bool CTpListTargetClustersResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_TargetClusters.unmarshall(ctx, soapval, "TargetClusters");
	return hasValue;
}

bool CTpListTargetClustersResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_TargetClusters.unmarshall(ctx, params, attachments, "TargetClusters", basepath);
	return hasValue;
}

IArrayOf<IConstTpClusterNameType> & CTpListTargetClustersResponse::getTargetClusters() { return (IArrayOf<IConstTpClusterNameType> &) m_TargetClusters; }
void CTpListTargetClustersResponse::setTargetClusters(IArrayOf<IEspTpClusterNameType> &val)
{
	m_TargetClusters->kill();
	IArrayOf<IConstTpClusterNameType> &target = m_TargetClusters.getValue();
	ForEachItemIn(idx, val)
	{
		IEspTpClusterNameType &item = (val).item(idx);
		item.Link();
		target.append(item);
	}
}
void CTpListTargetClustersResponse::setTargetClusters(IArrayOf<IConstTpClusterNameType> &val)
{
	m_TargetClusters->kill();
	IArrayOf<IConstTpClusterNameType> &target = m_TargetClusters.getValue();
	ForEachItemIn(idx, val)
	{
		IConstTpClusterNameType &item = val.item(idx);
		item.Link();
		target.append(item);
	}
}
extern "C"  IEspTpListTargetClustersResponse *createTpListTargetClustersResponse(const char *serv){return ((IEspTpListTargetClustersResponse *)new CTpListTargetClustersResponse(serv));}
extern "C"  IClientTpListTargetClustersResponse *createClientTpListTargetClustersResponse(const char *serv){return ((IClientTpListTargetClustersResponse *)new CTpListTargetClustersResponse(serv));}

//=======================================================
// class CTpTargetCluster Implementation
//=======================================================

CTpTargetCluster::CTpTargetCluster(const char *serviceName, IRpcMessageBinding *init)
	: m_Name(nilIgnore),m_Prefix(nilIgnore),m_Type(nilIgnore),m_TpClusters(nilIgnore),m_TpEclCCServers(nilIgnore),m_TpEclServers(nilIgnore),m_TpEclAgents(nilIgnore),m_TpEclSchedulers(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("TpTargetCluster");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CTpTargetCluster::CTpTargetCluster(const char *serviceName, const char *bc)
	: m_Name(nilIgnore),m_Prefix(nilIgnore),m_Type(nilIgnore),m_TpClusters(nilIgnore),m_TpEclCCServers(nilIgnore),m_TpEclServers(nilIgnore),m_TpEclAgents(nilIgnore),m_TpEclSchedulers(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("TpTargetCluster");
}

StringBuffer &CTpTargetCluster::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:complexType name=\"%s\">\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Name\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Prefix\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Type\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"TpClusters\" type=\"tns:ArrayOfTpCluster\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"TpEclCCServers\" type=\"tns:ArrayOfTpEclServer\"/>\n");
		if (!context.suppressed("TpTargetCluster","TpEclServers")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"TpEclServers\" type=\"tns:ArrayOfTpEclServer\"/>\n");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"TpEclAgents\" type=\"tns:ArrayOfTpEclAgent\"/>\n");
		if (!context.suppressed("TpTargetCluster","TpEclSchedulers")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"TpEclSchedulers\" type=\"tns:ArrayOfTpEclScheduler\"/>\n");
		}
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType>\n");
		}
	}
	if (!(flags & 0x10)  || (flags & 0x100))
	{
		CTpCluster::getXsdDefinition(context, request, schema, added);
		CTpEclServer::getXsdDefinition(context, request, schema, added);
		CTpEclAgent::getXsdDefinition(context, request, schema, added);
		if (!context.suppressed("TpTargetCluster","TpEclSchedulers"))
			CTpEclScheduler::getXsdDefinition(context, request, schema, added);
	}
	if (added.getValue("TpCluster") && added.getValue("ArrayOfTpCluster")==NULL) {
		schema.append("<xsd:complexType name=\"ArrayOfTpCluster\">\n");
		schema.append("<xsd:sequence>\n");
		schema.append("<xsd:element minOccurs=\"0\" maxOccurs=\"unbounded\" name=\"TpCluster\" type=\"tns:TpCluster\"/>\n");
		schema.append("</xsd:sequence>\n");
		schema.append("</xsd:complexType>\n");
		added.setValue("ArrayOfTpCluster",1);
	}
	if (added.getValue("TpEclAgent") && added.getValue("ArrayOfTpEclAgent")==NULL) {
		schema.append("<xsd:complexType name=\"ArrayOfTpEclAgent\">\n");
		schema.append("<xsd:sequence>\n");
		schema.append("<xsd:element minOccurs=\"0\" maxOccurs=\"unbounded\" name=\"TpEclAgent\" type=\"tns:TpEclAgent\"/>\n");
		schema.append("</xsd:sequence>\n");
		schema.append("</xsd:complexType>\n");
		added.setValue("ArrayOfTpEclAgent",1);
	}
	if (added.getValue("TpEclScheduler") && added.getValue("ArrayOfTpEclScheduler")==NULL) {
		schema.append("<xsd:complexType name=\"ArrayOfTpEclScheduler\">\n");
		schema.append("<xsd:sequence>\n");
		schema.append("<xsd:element minOccurs=\"0\" maxOccurs=\"unbounded\" name=\"TpEclScheduler\" type=\"tns:TpEclScheduler\"/>\n");
		schema.append("</xsd:sequence>\n");
		schema.append("</xsd:complexType>\n");
		added.setValue("ArrayOfTpEclScheduler",1);
	}
	if (added.getValue("TpEclServer") && added.getValue("ArrayOfTpEclServer")==NULL) {
		schema.append("<xsd:complexType name=\"ArrayOfTpEclServer\">\n");
		schema.append("<xsd:sequence>\n");
		schema.append("<xsd:element minOccurs=\"0\" maxOccurs=\"unbounded\" name=\"TpEclServer\" type=\"tns:TpEclServer\"/>\n");
		schema.append("</xsd:sequence>\n");
		schema.append("</xsd:complexType>\n");
		added.setValue("ArrayOfTpEclServer",1);
	}
	return schema;
}

void CTpTargetCluster::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CTpTargetCluster::getMapInfo(IMapInfo& info, BoolHash& added)
{
	info.addMinVersion("TpTargetCluster","TpEclServers",1.19);
	info.addMinVersion("TpTargetCluster","TpEclSchedulers",1.16);
	if (!added.getValue("TpCluster"))
	{
		added.setValue("TpCluster",1);
		CTpCluster::getMapInfo(info,added);
	}
	if (!added.getValue("TpEclAgent"))
	{
		added.setValue("TpEclAgent",1);
		CTpEclAgent::getMapInfo(info,added);
	}
	if (!added.getValue("TpEclScheduler"))
	{
		added.setValue("TpEclScheduler",1);
		CTpEclScheduler::getMapInfo(info,added);
	}
	if (!added.getValue("TpEclServer"))
	{
		added.setValue("TpEclServer",1);
		CTpEclServer::getMapInfo(info,added);
	}
}

StringBuffer &CTpTargetCluster::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Name");
	form.appendf("  <tr><td><b>Name: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Prefix");
	form.appendf("  <tr><td><b>Prefix: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Type");
	form.appendf("  <tr><td><b>Type: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("TpClusters");
	form.appendf("<tr><td><b>TpClusters: </b></td><td>");
	form.appendf("<table><tr><td><textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea></td>", extfix.str());
	form.append("</tr></table>");
	form.append("</td></tr>");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("TpEclCCServers");
	form.appendf("<tr><td><b>TpEclCCServers: </b></td><td>");
	form.appendf("<table><tr><td><textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea></td>", extfix.str());
	form.append("</tr></table>");
	form.append("</td></tr>");
	if (!context.suppressed("TpTargetCluster","TpEclServers")) {
		extfix.clear();
		if (prefix && *prefix)
			extfix.append(prefix).append(".");
		extfix.append("TpEclServers");
		form.appendf("<tr><td><b>TpEclServers: </b></td><td>");
		form.appendf("<table><tr><td><textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea></td>", extfix.str());
		form.append("</tr></table>");
		form.append("</td></tr>");
	}
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("TpEclAgents");
	form.appendf("<tr><td><b>TpEclAgents: </b></td><td>");
	form.appendf("<table><tr><td><textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea></td>", extfix.str());
	form.append("</tr></table>");
	form.append("</td></tr>");
	if (!context.suppressed("TpTargetCluster","TpEclSchedulers")) {
		extfix.clear();
		if (prefix && *prefix)
			extfix.append(prefix).append(".");
		extfix.append("TpEclSchedulers");
		form.appendf("<tr><td><b>TpEclSchedulers: </b></td><td>");
		form.appendf("<table><tr><td><textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea></td>", extfix.str());
		form.append("</tr></table>");
		form.append("</td></tr>");
	}
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CTpTargetCluster::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CTpTargetCluster::serialize(IRpcMessage& rpc_resp)
{
	IEspContext* ctx = rpc_resp.queryContext();
	double clientVer= ctx ? ctx->getClientVersion() : -1; /* no context gets everything */
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_Name.marshall(rpc_resp, "Name", "", "", "");
	m_Prefix.marshall(rpc_resp, "Prefix", "", "", "");
	m_Type.marshall(rpc_resp, "Type", "", "", "");
	m_TpClusters.marshall(rpc_resp, "TpClusters", "TpCluster");
	m_TpEclCCServers.marshall(rpc_resp, "TpEclCCServers", "TpEclServer");
	if ((clientVer==-1.0 || clientVer>=1.19))
		m_TpEclServers.marshall(rpc_resp, "TpEclServers", "TpEclServer");
	m_TpEclAgents.marshall(rpc_resp, "TpEclAgents", "TpEclAgent");
	if ((clientVer==-1.0 || clientVer>=1.16))
		m_TpEclSchedulers.marshall(rpc_resp, "TpEclSchedulers", "TpEclScheduler");
}


void CTpTargetCluster::copy(CTpTargetCluster &from)
{
	m_Name.copy(from.m_Name);
	m_Prefix.copy(from.m_Prefix);
	m_Type.copy(from.m_Type);
	m_TpClusters.copy(from.m_TpClusters);
	m_TpEclCCServers.copy(from.m_TpEclCCServers);
	m_TpEclServers.copy(from.m_TpEclServers);
	m_TpEclAgents.copy(from.m_TpEclAgents);
	m_TpEclSchedulers.copy(from.m_TpEclSchedulers);
}


void CTpTargetCluster::copy(IConstTpTargetCluster &ifrom)
{
	setName(ifrom.getName());
	setPrefix(ifrom.getPrefix());
	setType(ifrom.getType());
	setTpClusters(ifrom.getTpClusters());
	setTpEclCCServers(ifrom.getTpEclCCServers());
	setTpEclServers(ifrom.getTpEclServers());
	setTpEclAgents(ifrom.getTpEclAgents());
	setTpEclSchedulers(ifrom.getTpEclSchedulers());
}


void CTpTargetCluster::getAttributes(IProperties &attributes)
{
}


void CTpTargetCluster::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	double clientVer = ctx ? ctx->getClientVersion() : -1;
	m_Name.toStr(ctx, buffer, "Name", "", true, "", "");
	m_Prefix.toStr(ctx, buffer, "Prefix", "", true, "", "");
	m_Type.toStr(ctx, buffer, "Type", "", true, "", "");
	m_TpClusters.toStr(ctx, buffer, "TpClusters", "TpCluster");
	m_TpEclCCServers.toStr(ctx, buffer, "TpEclCCServers", "TpEclServer");
	if ((clientVer==-1.0 || clientVer>=1.19))
		m_TpEclServers.toStr(ctx, buffer, "TpEclServers", "TpEclServer");
	m_TpEclAgents.toStr(ctx, buffer, "TpEclAgents", "TpEclAgent");
	if ((clientVer==-1.0 || clientVer>=1.16))
		m_TpEclSchedulers.toStr(ctx, buffer, "TpEclSchedulers", "TpEclScheduler");
}


void CTpTargetCluster::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CTpTargetCluster::serializer(IEspContext* ctx, IConstTpTargetCluster &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<TpTargetCluster>");
	double clientVer = ctx ? ctx->getClientVersion() : -1;
	// field Name
	{
		const char* s = src.getName();
		if (s && *s)
		{
			buffer.append("<Name>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Name>");
		}
	}
	// field Prefix
	{
		const char* s = src.getPrefix();
		if (s && *s)
		{
			buffer.append("<Prefix>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Prefix>");
		}
	}
	// field Type
	{
		const char* s = src.getType();
		if (s && *s)
		{
			buffer.append("<Type>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Type>");
		}
	}
	// field TpClusters
	{
		IArrayOf<IConstTpCluster>& v = src.getTpClusters();
		int size = v.length();
		if (size>0)
			buffer.append("<TpClusters>");
		for (int i=0;i<size;i++)
		{
			buffer.append("<Item>");
			CTpCluster::serializer(ctx,v.item(i),buffer,false);
			buffer.append("</Item>");
		}
		if (size>0)
			buffer.append("</TpClusters>");
	}
	// field TpEclCCServers
	{
		IArrayOf<IConstTpEclServer>& v = src.getTpEclCCServers();
		int size = v.length();
		if (size>0)
			buffer.append("<TpEclCCServers>");
		for (int i=0;i<size;i++)
		{
			buffer.append("<Item>");
			CTpEclServer::serializer(ctx,v.item(i),buffer,false);
			buffer.append("</Item>");
		}
		if (size>0)
			buffer.append("</TpEclCCServers>");
	}
	// field TpEclServers
	if ((clientVer==-1.0 || clientVer>=1.19))
	{
		IArrayOf<IConstTpEclServer>& v = src.getTpEclServers();
		int size = v.length();
		if (size>0)
			buffer.append("<TpEclServers>");
		for (int i=0;i<size;i++)
		{
			buffer.append("<Item>");
			CTpEclServer::serializer(ctx,v.item(i),buffer,false);
			buffer.append("</Item>");
		}
		if (size>0)
			buffer.append("</TpEclServers>");
	}
	// field TpEclAgents
	{
		IArrayOf<IConstTpEclAgent>& v = src.getTpEclAgents();
		int size = v.length();
		if (size>0)
			buffer.append("<TpEclAgents>");
		for (int i=0;i<size;i++)
		{
			buffer.append("<Item>");
			CTpEclAgent::serializer(ctx,v.item(i),buffer,false);
			buffer.append("</Item>");
		}
		if (size>0)
			buffer.append("</TpEclAgents>");
	}
	// field TpEclSchedulers
	if ((clientVer==-1.0 || clientVer>=1.16))
	{
		IArrayOf<IConstTpEclScheduler>& v = src.getTpEclSchedulers();
		int size = v.length();
		if (size>0)
			buffer.append("<TpEclSchedulers>");
		for (int i=0;i<size;i++)
		{
			buffer.append("<Item>");
			CTpEclScheduler::serializer(ctx,v.item(i),buffer,false);
			buffer.append("</Item>");
		}
		if (size>0)
			buffer.append("</TpEclSchedulers>");
	}
	if (keepRootTag)
		buffer.append("</TpTargetCluster>");
}

bool CTpTargetCluster::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_Name.unmarshall(rpc_request, "Name", basepath);
	hasValue |= m_Prefix.unmarshall(rpc_request, "Prefix", basepath);
	hasValue |= m_Type.unmarshall(rpc_request, "Type", basepath);
	hasValue |= m_TpClusters.unmarshall(rpc_request, "TpClusters", basepath);
	hasValue |= m_TpEclCCServers.unmarshall(rpc_request, "TpEclCCServers", basepath);
	hasValue |= m_TpEclServers.unmarshall(rpc_request, "TpEclServers", basepath);
	hasValue |= m_TpEclAgents.unmarshall(rpc_request, "TpEclAgents", basepath);
	hasValue |= m_TpEclSchedulers.unmarshall(rpc_request, "TpEclSchedulers", basepath);
	return hasValue;
}

bool CTpTargetCluster::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Name.unmarshall(ctx, soapval, "Name");
	hasValue |= m_Prefix.unmarshall(ctx, soapval, "Prefix");
	hasValue |= m_Type.unmarshall(ctx, soapval, "Type");
	hasValue |= m_TpClusters.unmarshall(ctx, soapval, "TpClusters");
	hasValue |= m_TpEclCCServers.unmarshall(ctx, soapval, "TpEclCCServers");
	hasValue |= m_TpEclServers.unmarshall(ctx, soapval, "TpEclServers");
	hasValue |= m_TpEclAgents.unmarshall(ctx, soapval, "TpEclAgents");
	hasValue |= m_TpEclSchedulers.unmarshall(ctx, soapval, "TpEclSchedulers");
	return hasValue;
}

bool CTpTargetCluster::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Name.unmarshall(ctx, params, attachments, "Name", basepath);
	hasValue |= m_Prefix.unmarshall(ctx, params, attachments, "Prefix", basepath);
	hasValue |= m_Type.unmarshall(ctx, params, attachments, "Type", basepath);
	hasValue |= m_TpClusters.unmarshall(ctx, params, attachments, "TpClusters", basepath);
	hasValue |= m_TpEclCCServers.unmarshall(ctx, params, attachments, "TpEclCCServers", basepath);
	hasValue |= m_TpEclServers.unmarshall(ctx, params, attachments, "TpEclServers", basepath);
	hasValue |= m_TpEclAgents.unmarshall(ctx, params, attachments, "TpEclAgents", basepath);
	hasValue |= m_TpEclSchedulers.unmarshall(ctx, params, attachments, "TpEclSchedulers", basepath);
	return hasValue;
}

const char * CTpTargetCluster::getName() { return m_Name.query();}
const char * CTpTargetCluster::getPrefix() { return m_Prefix.query();}
const char * CTpTargetCluster::getType() { return m_Type.query();}
IArrayOf<IConstTpCluster> & CTpTargetCluster::getTpClusters() { return (IArrayOf<IConstTpCluster> &) m_TpClusters; }
IArrayOf<IConstTpEclServer> & CTpTargetCluster::getTpEclCCServers() { return (IArrayOf<IConstTpEclServer> &) m_TpEclCCServers; }
IArrayOf<IConstTpEclServer> & CTpTargetCluster::getTpEclServers() { return (IArrayOf<IConstTpEclServer> &) m_TpEclServers; }
IArrayOf<IConstTpEclAgent> & CTpTargetCluster::getTpEclAgents() { return (IArrayOf<IConstTpEclAgent> &) m_TpEclAgents; }
IArrayOf<IConstTpEclScheduler> & CTpTargetCluster::getTpEclSchedulers() { return (IArrayOf<IConstTpEclScheduler> &) m_TpEclSchedulers; }
void CTpTargetCluster::setName(const char * val){ m_Name.set(val); }
void CTpTargetCluster::setPrefix(const char * val){ m_Prefix.set(val); }
void CTpTargetCluster::setType(const char * val){ m_Type.set(val); }
void CTpTargetCluster::setTpClusters(IArrayOf<IEspTpCluster> &val)
{
	m_TpClusters->kill();
	IArrayOf<IConstTpCluster> &target = m_TpClusters.getValue();
	ForEachItemIn(idx, val)
	{
		IEspTpCluster &item = (val).item(idx);
		item.Link();
		target.append(item);
	}
}
void CTpTargetCluster::setTpClusters(IArrayOf<IConstTpCluster> &val)
{
	m_TpClusters->kill();
	IArrayOf<IConstTpCluster> &target = m_TpClusters.getValue();
	ForEachItemIn(idx, val)
	{
		IConstTpCluster &item = val.item(idx);
		item.Link();
		target.append(item);
	}
}
void CTpTargetCluster::setTpEclCCServers(IArrayOf<IEspTpEclServer> &val)
{
	m_TpEclCCServers->kill();
	IArrayOf<IConstTpEclServer> &target = m_TpEclCCServers.getValue();
	ForEachItemIn(idx, val)
	{
		IEspTpEclServer &item = (val).item(idx);
		item.Link();
		target.append(item);
	}
}
void CTpTargetCluster::setTpEclCCServers(IArrayOf<IConstTpEclServer> &val)
{
	m_TpEclCCServers->kill();
	IArrayOf<IConstTpEclServer> &target = m_TpEclCCServers.getValue();
	ForEachItemIn(idx, val)
	{
		IConstTpEclServer &item = val.item(idx);
		item.Link();
		target.append(item);
	}
}
void CTpTargetCluster::setTpEclServers(IArrayOf<IEspTpEclServer> &val)
{
	m_TpEclServers->kill();
	IArrayOf<IConstTpEclServer> &target = m_TpEclServers.getValue();
	ForEachItemIn(idx, val)
	{
		IEspTpEclServer &item = (val).item(idx);
		item.Link();
		target.append(item);
	}
}
void CTpTargetCluster::setTpEclServers(IArrayOf<IConstTpEclServer> &val)
{
	m_TpEclServers->kill();
	IArrayOf<IConstTpEclServer> &target = m_TpEclServers.getValue();
	ForEachItemIn(idx, val)
	{
		IConstTpEclServer &item = val.item(idx);
		item.Link();
		target.append(item);
	}
}
void CTpTargetCluster::setTpEclAgents(IArrayOf<IEspTpEclAgent> &val)
{
	m_TpEclAgents->kill();
	IArrayOf<IConstTpEclAgent> &target = m_TpEclAgents.getValue();
	ForEachItemIn(idx, val)
	{
		IEspTpEclAgent &item = (val).item(idx);
		item.Link();
		target.append(item);
	}
}
void CTpTargetCluster::setTpEclAgents(IArrayOf<IConstTpEclAgent> &val)
{
	m_TpEclAgents->kill();
	IArrayOf<IConstTpEclAgent> &target = m_TpEclAgents.getValue();
	ForEachItemIn(idx, val)
	{
		IConstTpEclAgent &item = val.item(idx);
		item.Link();
		target.append(item);
	}
}
void CTpTargetCluster::setTpEclSchedulers(IArrayOf<IEspTpEclScheduler> &val)
{
	m_TpEclSchedulers->kill();
	IArrayOf<IConstTpEclScheduler> &target = m_TpEclSchedulers.getValue();
	ForEachItemIn(idx, val)
	{
		IEspTpEclScheduler &item = (val).item(idx);
		item.Link();
		target.append(item);
	}
}
void CTpTargetCluster::setTpEclSchedulers(IArrayOf<IConstTpEclScheduler> &val)
{
	m_TpEclSchedulers->kill();
	IArrayOf<IConstTpEclScheduler> &target = m_TpEclSchedulers.getValue();
	ForEachItemIn(idx, val)
	{
		IConstTpEclScheduler &item = val.item(idx);
		item.Link();
		target.append(item);
	}
}
extern "C"  IEspTpTargetCluster *createTpTargetCluster(const char *serv, const char *msgname){return ((IEspTpTargetCluster *)new CTpTargetCluster(serv /*, msgname*/));}
extern "C"  IClientTpTargetCluster *createClientTpTargetCluster(const char *serv, const char *msgname){return ((IClientTpTargetCluster *)new CTpTargetCluster(serv /*, msgname*/));}

//=======================================================
// class CTpQueryType Implementation
//=======================================================

CTpQueryType::CTpQueryType(const char *serviceName, IRpcMessageBinding *init)
	: m_TPCLUSTER(nilIgnore),m_TPNODE(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("TpQueryType");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CTpQueryType::CTpQueryType(const char *serviceName, const char *bc)
	: m_TPCLUSTER(nilIgnore),m_TPNODE(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("TpQueryType");
}

StringBuffer &CTpQueryType::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:complexType name=\"%s\">\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"TPCLUSTER\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"TPNODE\" type=\"xsd:string\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType>\n");
		}
	}
	return schema;
}

void CTpQueryType::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CTpQueryType::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CTpQueryType::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("TPCLUSTER");
	form.appendf("  <tr><td><b>TPCLUSTER: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("TPNODE");
	form.appendf("  <tr><td><b>TPNODE: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CTpQueryType::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CTpQueryType::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_TPCLUSTER.marshall(rpc_resp, "TPCLUSTER", "", "", "");
	m_TPNODE.marshall(rpc_resp, "TPNODE", "", "", "");
}


void CTpQueryType::copy(CTpQueryType &from)
{
	m_TPCLUSTER.copy(from.m_TPCLUSTER);
	m_TPNODE.copy(from.m_TPNODE);
}


void CTpQueryType::copy(IConstTpQueryType &ifrom)
{
	setTPCLUSTER(ifrom.getTPCLUSTER());
	setTPNODE(ifrom.getTPNODE());
}


void CTpQueryType::getAttributes(IProperties &attributes)
{
}


void CTpQueryType::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_TPCLUSTER.toStr(ctx, buffer, "TPCLUSTER", "", true, "", "");
	m_TPNODE.toStr(ctx, buffer, "TPNODE", "", true, "", "");
}


void CTpQueryType::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CTpQueryType::serializer(IEspContext* ctx, IConstTpQueryType &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<TpQueryType>");
	// field TPCLUSTER
	{
		const char* s = src.getTPCLUSTER();
		if (s && *s)
		{
			buffer.append("<TPCLUSTER>");
			encodeUtf8XML(s,buffer);
			buffer.append("</TPCLUSTER>");
		}
	}
	// field TPNODE
	{
		const char* s = src.getTPNODE();
		if (s && *s)
		{
			buffer.append("<TPNODE>");
			encodeUtf8XML(s,buffer);
			buffer.append("</TPNODE>");
		}
	}
	if (keepRootTag)
		buffer.append("</TpQueryType>");
}

bool CTpQueryType::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_TPCLUSTER.unmarshall(rpc_request, "TPCLUSTER", basepath);
	hasValue |= m_TPNODE.unmarshall(rpc_request, "TPNODE", basepath);
	return hasValue;
}

bool CTpQueryType::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_TPCLUSTER.unmarshall(ctx, soapval, "TPCLUSTER");
	hasValue |= m_TPNODE.unmarshall(ctx, soapval, "TPNODE");
	return hasValue;
}

bool CTpQueryType::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_TPCLUSTER.unmarshall(ctx, params, attachments, "TPCLUSTER", basepath);
	hasValue |= m_TPNODE.unmarshall(ctx, params, attachments, "TPNODE", basepath);
	return hasValue;
}

const char * CTpQueryType::getTPCLUSTER() { return m_TPCLUSTER.query();}
const char * CTpQueryType::getTPNODE() { return m_TPNODE.query();}
void CTpQueryType::setTPCLUSTER(const char * val){ m_TPCLUSTER.set(val); }
void CTpQueryType::setTPNODE(const char * val){ m_TPNODE.set(val); }
extern "C"  IEspTpQueryType *createTpQueryType(const char *serv, const char *msgname){return ((IEspTpQueryType *)new CTpQueryType(serv /*, msgname*/));}
extern "C"  IClientTpQueryType *createClientTpQueryType(const char *serv, const char *msgname){return ((IClientTpQueryType *)new CTpQueryType(serv /*, msgname*/));}

//=======================================================
// class CTpTargetClusterQueryRequest Implementation
//=======================================================

CTpTargetClusterQueryRequest::CTpTargetClusterQueryRequest(const char *serviceName, IRpcMessageBinding *init)
	: m_Type(nilIgnore),m_Name(nilIgnore),m_ShowDetails(0, nilIgnore,false)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("TpTargetClusterQueryRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CTpTargetClusterQueryRequest::CTpTargetClusterQueryRequest(const char *serviceName, const char *bc)
	: m_Type(nilIgnore),m_Name(nilIgnore),m_ShowDetails(0, nilIgnore,false)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("TpTargetClusterQueryRequest");
}

CTpTargetClusterQueryRequest::CTpTargetClusterQueryRequest(const char *serviceName, IRpcMessage* rpcmsg)
	: m_Type(nilIgnore),m_Name(nilIgnore),m_ShowDetails(0, nilIgnore,false)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("TpTargetClusterQueryRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CTpTargetClusterQueryRequest::CTpTargetClusterQueryRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_Type(nilIgnore),m_Name(nilIgnore),m_ShowDetails(0, nilIgnore,false)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("TpTargetClusterQueryRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CTpTargetClusterQueryRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Type\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Name\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" default=\"false\" name=\"ShowDetails\" type=\"xsd:boolean\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CTpTargetClusterQueryRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CTpTargetClusterQueryRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CTpTargetClusterQueryRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Type");
	form.appendf("  <tr><td><b>Type: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Name");
	form.appendf("  <tr><td><b>Name: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("ShowDetails");
	
	form.appendf("  <tr><td><b>ShowDetails? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CTpTargetClusterQueryRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CTpTargetClusterQueryRequest::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_Type.marshall(rpc_resp, "Type", "", "", "");
	m_Name.marshall(rpc_resp, "Name", "", "", "");
	m_ShowDetails.marshall(rpc_resp, "ShowDetails", "", "", "");
}


void CTpTargetClusterQueryRequest::copy(CTpTargetClusterQueryRequest &from)
{
	m_Type.copy(from.m_Type);
	m_Name.copy(from.m_Name);
	m_ShowDetails.copy(from.m_ShowDetails);
}


void CTpTargetClusterQueryRequest::copy(IConstTpTargetClusterQueryRequest &ifrom)
{
	setType(ifrom.getType());
	setName(ifrom.getName());
	setShowDetails(ifrom.getShowDetails());
}


void CTpTargetClusterQueryRequest::getAttributes(IProperties &attributes)
{
}


void CTpTargetClusterQueryRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_Type.toStr(ctx, buffer, "Type", "", true, "", "");
	m_Name.toStr(ctx, buffer, "Name", "", true, "", "");
	m_ShowDetails.toStr(ctx, buffer, "ShowDetails", "", true, "", "");
}


void CTpTargetClusterQueryRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CTpTargetClusterQueryRequest::serializer(IEspContext* ctx, IConstTpTargetClusterQueryRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<TpTargetClusterQueryRequest>");
	// field Type
	{
		const char* s = src.getType();
		if (s && *s)
		{
			buffer.append("<Type>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Type>");
		}
	}
	// field Name
	{
		const char* s = src.getName();
		if (s && *s)
		{
			buffer.append("<Name>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Name>");
		}
	}
	// field ShowDetails
	{
		bool b = src.getShowDetails();
		if (b)
			buffer.appendf("<ShowDetails>1</ShowDetails>");
	}
	if (keepRootTag)
		buffer.append("</TpTargetClusterQueryRequest>");
}

bool CTpTargetClusterQueryRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_Type.unmarshall(rpc_request, "Type", basepath);
	hasValue |= m_Name.unmarshall(rpc_request, "Name", basepath);
	hasValue |= m_ShowDetails.unmarshall(rpc_request, "ShowDetails", basepath);
	return hasValue;
}

bool CTpTargetClusterQueryRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Type.unmarshall(ctx, soapval, "Type");
	hasValue |= m_Name.unmarshall(ctx, soapval, "Name");
	hasValue |= m_ShowDetails.unmarshall(ctx, soapval, "ShowDetails");
	return hasValue;
}

bool CTpTargetClusterQueryRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Type.unmarshall(ctx, params, attachments, "Type", basepath);
	hasValue |= m_Name.unmarshall(ctx, params, attachments, "Name", basepath);
	hasValue |= m_ShowDetails.unmarshall(ctx, params, attachments, "ShowDetails", basepath);
	return hasValue;
}

const char * CTpTargetClusterQueryRequest::getType() { return m_Type.query();}
const char * CTpTargetClusterQueryRequest::getName() { return m_Name.query();}
bool CTpTargetClusterQueryRequest::getShowDetails() { return m_ShowDetails;}
void CTpTargetClusterQueryRequest::setType(const char * val){ m_Type.set(val); }
void CTpTargetClusterQueryRequest::setName(const char * val){ m_Name.set(val); }
void CTpTargetClusterQueryRequest::setShowDetails(bool val){ m_ShowDetails=val; }
extern "C"  IEspTpTargetClusterQueryRequest *createTpTargetClusterQueryRequest(const char *serv){return ((IEspTpTargetClusterQueryRequest *)new CTpTargetClusterQueryRequest(serv));}
extern "C"  IClientTpTargetClusterQueryRequest *createClientTpTargetClusterQueryRequest(const char *serv){return ((IClientTpTargetClusterQueryRequest *)new CTpTargetClusterQueryRequest(serv));}

//=======================================================
// class CTpTargetClusterQueryResponse Implementation
//=======================================================

CTpTargetClusterQueryResponse::CTpTargetClusterQueryResponse(const char *serviceName, IRpcMessageBinding *init)
	: m_ShowDetails(0, nilIgnore,false),m_MemThreshold(nilIgnore),m_DiskThreshold(nilIgnore),m_CpuThreshold(nilIgnore),m_MemThresholdType(nilIgnore),m_DiskThresholdType(nilIgnore),m_PreflightProcessFilter(nilIgnore),m_AcceptLanguage(nilIgnore),m_TpTargetClusters(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("TpTargetClusterQueryResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CTpTargetClusterQueryResponse::CTpTargetClusterQueryResponse(const char *serviceName, const char *bc)
	: m_ShowDetails(0, nilIgnore,false),m_MemThreshold(nilIgnore),m_DiskThreshold(nilIgnore),m_CpuThreshold(nilIgnore),m_MemThresholdType(nilIgnore),m_DiskThresholdType(nilIgnore),m_PreflightProcessFilter(nilIgnore),m_AcceptLanguage(nilIgnore),m_TpTargetClusters(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("TpTargetClusterQueryResponse");
}

CTpTargetClusterQueryResponse::CTpTargetClusterQueryResponse(const char *serviceName, IRpcMessage* rpcmsg)
	: m_ShowDetails(0, nilIgnore,false),m_MemThreshold(nilIgnore),m_DiskThreshold(nilIgnore),m_CpuThreshold(nilIgnore),m_MemThresholdType(nilIgnore),m_DiskThresholdType(nilIgnore),m_PreflightProcessFilter(nilIgnore),m_AcceptLanguage(nilIgnore),m_TpTargetClusters(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("TpTargetClusterQueryResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CTpTargetClusterQueryResponse::CTpTargetClusterQueryResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_ShowDetails(0, nilIgnore,false),m_MemThreshold(nilIgnore),m_DiskThreshold(nilIgnore),m_CpuThreshold(nilIgnore),m_MemThresholdType(nilIgnore),m_DiskThresholdType(nilIgnore),m_PreflightProcessFilter(nilIgnore),m_AcceptLanguage(nilIgnore),m_TpTargetClusters(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("TpTargetClusterQueryResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CTpTargetClusterQueryResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		schema.append("<xsd:element name=\"Exceptions\" type=\"tns:ArrayOfEspException\" minOccurs=\"0\" maxOccurs=\"1\"/>");
		}
		schema.append("<xsd:element minOccurs=\"0\" default=\"false\" name=\"ShowDetails\" type=\"xsd:boolean\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"MemThreshold\" type=\"xsd:int\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"DiskThreshold\" type=\"xsd:int\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"CpuThreshold\" type=\"xsd:int\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"MemThresholdType\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"DiskThresholdType\" type=\"xsd:string\"/>\n");
		if (!context.suppressed("TpTargetClusterQueryResponse","PreflightProcessFilter")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"PreflightProcessFilter\" type=\"xsd:string\"/>\n");
		}
		if (!context.suppressed("TpTargetClusterQueryResponse","AcceptLanguage")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"AcceptLanguage\" type=\"xsd:string\"/>\n");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"TpTargetClusters\" type=\"tns:ArrayOfTpTargetCluster\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	if (!(flags & 0x10)  || (flags & 0x100))
	{
		CTpTargetCluster::getXsdDefinition(context, request, schema, added);
	}
	if (added.getValue("TpTargetCluster") && added.getValue("ArrayOfTpTargetCluster")==NULL) {
		schema.append("<xsd:complexType name=\"ArrayOfTpTargetCluster\">\n");
		schema.append("<xsd:sequence>\n");
		schema.append("<xsd:element minOccurs=\"0\" maxOccurs=\"unbounded\" name=\"TpTargetCluster\" type=\"tns:TpTargetCluster\"/>\n");
		schema.append("</xsd:sequence>\n");
		schema.append("</xsd:complexType>\n");
		added.setValue("ArrayOfTpTargetCluster",1);
	}
	return schema;
}

void CTpTargetClusterQueryResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CTpTargetClusterQueryResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
	info.addMinVersion("TpTargetClusterQueryResponse","PreflightProcessFilter",1.13);
	info.addMinVersion("TpTargetClusterQueryResponse","AcceptLanguage",1.2);
	if (!added.getValue("TpTargetCluster"))
	{
		added.setValue("TpTargetCluster",1);
		CTpTargetCluster::getMapInfo(info,added);
	}
}

StringBuffer &CTpTargetClusterQueryResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("ShowDetails");
	
	form.appendf("  <tr><td><b>ShowDetails? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	extfix.clear();
	if (prefix && *prefix) extfix.append(prefix).append(".");
		extfix.append("MemThreshold");
	form.appendf("  <tr><td><b>MemThreshold: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix) extfix.append(prefix).append(".");
		extfix.append("DiskThreshold");
	form.appendf("  <tr><td><b>DiskThreshold: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix) extfix.append(prefix).append(".");
		extfix.append("CpuThreshold");
	form.appendf("  <tr><td><b>CpuThreshold: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("MemThresholdType");
	form.appendf("  <tr><td><b>MemThresholdType: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("DiskThresholdType");
	form.appendf("  <tr><td><b>DiskThresholdType: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (!context.suppressed("TpTargetClusterQueryResponse","PreflightProcessFilter")) {
		extfix.clear();
		if (prefix && *prefix)
			extfix.append(prefix).append(".");
		extfix.append("PreflightProcessFilter");
		form.appendf("  <tr><td><b>PreflightProcessFilter: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
		form.append("</td></tr>\n");
	}
	if (!context.suppressed("TpTargetClusterQueryResponse","AcceptLanguage")) {
		extfix.clear();
		if (prefix && *prefix)
			extfix.append(prefix).append(".");
		extfix.append("AcceptLanguage");
		form.appendf("  <tr><td><b>AcceptLanguage: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
		form.append("</td></tr>\n");
	}
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("TpTargetClusters");
	form.appendf("<tr><td><b>TpTargetClusters: </b></td><td>");
	form.appendf("<table><tr><td><textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea></td>", extfix.str());
	form.append("</tr></table>");
	form.append("</td></tr>");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CTpTargetClusterQueryResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CTpTargetClusterQueryResponse::serialize(IRpcMessage& rpc_resp)
{
	IEspContext* ctx = rpc_resp.queryContext();
	double clientVer= ctx ? ctx->getClientVersion() : -1; /* no context gets everything */
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
		m_ShowDetails.marshall(rpc_resp, "ShowDetails", "", "", "");
		m_MemThreshold.marshall(rpc_resp, "MemThreshold", "", "", "");
		m_DiskThreshold.marshall(rpc_resp, "DiskThreshold", "", "", "");
		m_CpuThreshold.marshall(rpc_resp, "CpuThreshold", "", "", "");
		m_MemThresholdType.marshall(rpc_resp, "MemThresholdType", "", "", "");
		m_DiskThresholdType.marshall(rpc_resp, "DiskThresholdType", "", "", "");
		if ((clientVer==-1.0 || clientVer>=1.13))
			m_PreflightProcessFilter.marshall(rpc_resp, "PreflightProcessFilter", "", "", "");
		if ((clientVer==-1.0 || clientVer>=1.2))
			m_AcceptLanguage.marshall(rpc_resp, "AcceptLanguage", "", "", "");
		m_TpTargetClusters.marshall(rpc_resp, "TpTargetClusters", "TpTargetCluster");
	}
}


void CTpTargetClusterQueryResponse::copy(CTpTargetClusterQueryResponse &from)
{
	m_ShowDetails.copy(from.m_ShowDetails);
	m_MemThreshold.copy(from.m_MemThreshold);
	m_DiskThreshold.copy(from.m_DiskThreshold);
	m_CpuThreshold.copy(from.m_CpuThreshold);
	m_MemThresholdType.copy(from.m_MemThresholdType);
	m_DiskThresholdType.copy(from.m_DiskThresholdType);
	m_PreflightProcessFilter.copy(from.m_PreflightProcessFilter);
	m_AcceptLanguage.copy(from.m_AcceptLanguage);
	m_TpTargetClusters.copy(from.m_TpTargetClusters);
}


void CTpTargetClusterQueryResponse::copy(IConstTpTargetClusterQueryResponse &ifrom)
{
	setShowDetails(ifrom.getShowDetails());
	setMemThreshold(ifrom.getMemThreshold());
	setDiskThreshold(ifrom.getDiskThreshold());
	setCpuThreshold(ifrom.getCpuThreshold());
	setMemThresholdType(ifrom.getMemThresholdType());
	setDiskThresholdType(ifrom.getDiskThresholdType());
	setPreflightProcessFilter(ifrom.getPreflightProcessFilter());
	setAcceptLanguage(ifrom.getAcceptLanguage());
	setTpTargetClusters(ifrom.getTpTargetClusters());
}


void CTpTargetClusterQueryResponse::getAttributes(IProperties &attributes)
{
}


void CTpTargetClusterQueryResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
		double clientVer = ctx ? ctx->getClientVersion() : -1;
		m_ShowDetails.toStr(ctx, buffer, "ShowDetails", "", true, "", "");
		m_MemThreshold.toStr(ctx, buffer, "MemThreshold", "", true, "", "");
		m_DiskThreshold.toStr(ctx, buffer, "DiskThreshold", "", true, "", "");
		m_CpuThreshold.toStr(ctx, buffer, "CpuThreshold", "", true, "", "");
		m_MemThresholdType.toStr(ctx, buffer, "MemThresholdType", "", true, "", "");
		m_DiskThresholdType.toStr(ctx, buffer, "DiskThresholdType", "", true, "", "");
		if ((clientVer==-1.0 || clientVer>=1.13))
			m_PreflightProcessFilter.toStr(ctx, buffer, "PreflightProcessFilter", "", true, "", "");
		if ((clientVer==-1.0 || clientVer>=1.2))
			m_AcceptLanguage.toStr(ctx, buffer, "AcceptLanguage", "", true, "", "");
		m_TpTargetClusters.toStr(ctx, buffer, "TpTargetClusters", "TpTargetCluster");
	}
}


void CTpTargetClusterQueryResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CTpTargetClusterQueryResponse::serializer(IEspContext* ctx, IConstTpTargetClusterQueryResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<TpTargetClusterQueryResponse>");
	double clientVer = ctx ? ctx->getClientVersion() : -1;
	// field ShowDetails
	{
		bool b = src.getShowDetails();
		if (b)
			buffer.appendf("<ShowDetails>1</ShowDetails>");
	}
	// field MemThreshold
	{
		int n = src.getMemThreshold();
		if (n)
			buffer.appendf("<MemThreshold>%d</MemThreshold>", n);
	}
	// field DiskThreshold
	{
		int n = src.getDiskThreshold();
		if (n)
			buffer.appendf("<DiskThreshold>%d</DiskThreshold>", n);
	}
	// field CpuThreshold
	{
		int n = src.getCpuThreshold();
		if (n)
			buffer.appendf("<CpuThreshold>%d</CpuThreshold>", n);
	}
	// field MemThresholdType
	{
		const char* s = src.getMemThresholdType();
		if (s && *s)
		{
			buffer.append("<MemThresholdType>");
			encodeUtf8XML(s,buffer);
			buffer.append("</MemThresholdType>");
		}
	}
	// field DiskThresholdType
	{
		const char* s = src.getDiskThresholdType();
		if (s && *s)
		{
			buffer.append("<DiskThresholdType>");
			encodeUtf8XML(s,buffer);
			buffer.append("</DiskThresholdType>");
		}
	}
	// field PreflightProcessFilter
	if ((clientVer==-1.0 || clientVer>=1.13))
	{
		const char* s = src.getPreflightProcessFilter();
		if (s && *s)
		{
			buffer.append("<PreflightProcessFilter>");
			encodeUtf8XML(s,buffer);
			buffer.append("</PreflightProcessFilter>");
		}
	}
	// field AcceptLanguage
	if ((clientVer==-1.0 || clientVer>=1.2))
	{
		const char* s = src.getAcceptLanguage();
		if (s && *s)
		{
			buffer.append("<AcceptLanguage>");
			encodeUtf8XML(s,buffer);
			buffer.append("</AcceptLanguage>");
		}
	}
	// field TpTargetClusters
	{
		IArrayOf<IConstTpTargetCluster>& v = src.getTpTargetClusters();
		int size = v.length();
		if (size>0)
			buffer.append("<TpTargetClusters>");
		for (int i=0;i<size;i++)
		{
			buffer.append("<Item>");
			CTpTargetCluster::serializer(ctx,v.item(i),buffer,false);
			buffer.append("</Item>");
		}
		if (size>0)
			buffer.append("</TpTargetClusters>");
	}
	if (keepRootTag)
		buffer.append("</TpTargetClusterQueryResponse>");
}

bool CTpTargetClusterQueryResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
		hasValue |= m_ShowDetails.unmarshall(rpc_request, "ShowDetails", basepath);
		hasValue |= m_MemThreshold.unmarshall(rpc_request, "MemThreshold", basepath);
		hasValue |= m_DiskThreshold.unmarshall(rpc_request, "DiskThreshold", basepath);
		hasValue |= m_CpuThreshold.unmarshall(rpc_request, "CpuThreshold", basepath);
		hasValue |= m_MemThresholdType.unmarshall(rpc_request, "MemThresholdType", basepath);
		hasValue |= m_DiskThresholdType.unmarshall(rpc_request, "DiskThresholdType", basepath);
		hasValue |= m_PreflightProcessFilter.unmarshall(rpc_request, "PreflightProcessFilter", basepath);
		hasValue |= m_AcceptLanguage.unmarshall(rpc_request, "AcceptLanguage", basepath);
		hasValue |= m_TpTargetClusters.unmarshall(rpc_request, "TpTargetClusters", basepath);
	}
	return hasValue;
}

bool CTpTargetClusterQueryResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_ShowDetails.unmarshall(ctx, soapval, "ShowDetails");
	hasValue |= m_MemThreshold.unmarshall(ctx, soapval, "MemThreshold");
	hasValue |= m_DiskThreshold.unmarshall(ctx, soapval, "DiskThreshold");
	hasValue |= m_CpuThreshold.unmarshall(ctx, soapval, "CpuThreshold");
	hasValue |= m_MemThresholdType.unmarshall(ctx, soapval, "MemThresholdType");
	hasValue |= m_DiskThresholdType.unmarshall(ctx, soapval, "DiskThresholdType");
	hasValue |= m_PreflightProcessFilter.unmarshall(ctx, soapval, "PreflightProcessFilter");
	hasValue |= m_AcceptLanguage.unmarshall(ctx, soapval, "AcceptLanguage");
	hasValue |= m_TpTargetClusters.unmarshall(ctx, soapval, "TpTargetClusters");
	return hasValue;
}

bool CTpTargetClusterQueryResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_ShowDetails.unmarshall(ctx, params, attachments, "ShowDetails", basepath);
	hasValue |= m_MemThreshold.unmarshall(ctx, params, attachments, "MemThreshold", basepath);
	hasValue |= m_DiskThreshold.unmarshall(ctx, params, attachments, "DiskThreshold", basepath);
	hasValue |= m_CpuThreshold.unmarshall(ctx, params, attachments, "CpuThreshold", basepath);
	hasValue |= m_MemThresholdType.unmarshall(ctx, params, attachments, "MemThresholdType", basepath);
	hasValue |= m_DiskThresholdType.unmarshall(ctx, params, attachments, "DiskThresholdType", basepath);
	hasValue |= m_PreflightProcessFilter.unmarshall(ctx, params, attachments, "PreflightProcessFilter", basepath);
	hasValue |= m_AcceptLanguage.unmarshall(ctx, params, attachments, "AcceptLanguage", basepath);
	hasValue |= m_TpTargetClusters.unmarshall(ctx, params, attachments, "TpTargetClusters", basepath);
	return hasValue;
}

bool CTpTargetClusterQueryResponse::getShowDetails() { return m_ShowDetails;}
int CTpTargetClusterQueryResponse::getMemThreshold() { return m_MemThreshold;}
int CTpTargetClusterQueryResponse::getDiskThreshold() { return m_DiskThreshold;}
int CTpTargetClusterQueryResponse::getCpuThreshold() { return m_CpuThreshold;}
const char * CTpTargetClusterQueryResponse::getMemThresholdType() { return m_MemThresholdType.query();}
const char * CTpTargetClusterQueryResponse::getDiskThresholdType() { return m_DiskThresholdType.query();}
const char * CTpTargetClusterQueryResponse::getPreflightProcessFilter() { return m_PreflightProcessFilter.query();}
const char * CTpTargetClusterQueryResponse::getAcceptLanguage() { return m_AcceptLanguage.query();}
IArrayOf<IConstTpTargetCluster> & CTpTargetClusterQueryResponse::getTpTargetClusters() { return (IArrayOf<IConstTpTargetCluster> &) m_TpTargetClusters; }
void CTpTargetClusterQueryResponse::setShowDetails(bool val){ m_ShowDetails=val; }
void CTpTargetClusterQueryResponse::setMemThreshold(int val){ m_MemThreshold=val; }
void CTpTargetClusterQueryResponse::setDiskThreshold(int val){ m_DiskThreshold=val; }
void CTpTargetClusterQueryResponse::setCpuThreshold(int val){ m_CpuThreshold=val; }
void CTpTargetClusterQueryResponse::setMemThresholdType(const char * val){ m_MemThresholdType.set(val); }
void CTpTargetClusterQueryResponse::setDiskThresholdType(const char * val){ m_DiskThresholdType.set(val); }
void CTpTargetClusterQueryResponse::setPreflightProcessFilter(const char * val){ m_PreflightProcessFilter.set(val); }
void CTpTargetClusterQueryResponse::setAcceptLanguage(const char * val){ m_AcceptLanguage.set(val); }
void CTpTargetClusterQueryResponse::setTpTargetClusters(IArrayOf<IEspTpTargetCluster> &val)
{
	m_TpTargetClusters->kill();
	IArrayOf<IConstTpTargetCluster> &target = m_TpTargetClusters.getValue();
	ForEachItemIn(idx, val)
	{
		IEspTpTargetCluster &item = (val).item(idx);
		item.Link();
		target.append(item);
	}
}
void CTpTargetClusterQueryResponse::setTpTargetClusters(IArrayOf<IConstTpTargetCluster> &val)
{
	m_TpTargetClusters->kill();
	IArrayOf<IConstTpTargetCluster> &target = m_TpTargetClusters.getValue();
	ForEachItemIn(idx, val)
	{
		IConstTpTargetCluster &item = val.item(idx);
		item.Link();
		target.append(item);
	}
}
extern "C"  IEspTpTargetClusterQueryResponse *createTpTargetClusterQueryResponse(const char *serv){return ((IEspTpTargetClusterQueryResponse *)new CTpTargetClusterQueryResponse(serv));}
extern "C"  IClientTpTargetClusterQueryResponse *createClientTpTargetClusterQueryResponse(const char *serv){return ((IClientTpTargetClusterQueryResponse *)new CTpTargetClusterQueryResponse(serv));}

//=======================================================
// class CTpClusterQueryRequest Implementation
//=======================================================

CTpClusterQueryRequest::CTpClusterQueryRequest(const char *serviceName, IRpcMessageBinding *init)
	: m_Type(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("TpClusterQueryRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CTpClusterQueryRequest::CTpClusterQueryRequest(const char *serviceName, const char *bc)
	: m_Type(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("TpClusterQueryRequest");
}

CTpClusterQueryRequest::CTpClusterQueryRequest(const char *serviceName, IRpcMessage* rpcmsg)
	: m_Type(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("TpClusterQueryRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CTpClusterQueryRequest::CTpClusterQueryRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_Type(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("TpClusterQueryRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CTpClusterQueryRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Type\" type=\"xsd:string\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CTpClusterQueryRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CTpClusterQueryRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CTpClusterQueryRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Type");
	form.appendf("  <tr><td><b>Type: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CTpClusterQueryRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CTpClusterQueryRequest::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_Type.marshall(rpc_resp, "Type", "", "", "");
}


void CTpClusterQueryRequest::copy(CTpClusterQueryRequest &from)
{
	m_Type.copy(from.m_Type);
}


void CTpClusterQueryRequest::copy(IConstTpClusterQueryRequest &ifrom)
{
	setType(ifrom.getType());
}


void CTpClusterQueryRequest::getAttributes(IProperties &attributes)
{
}


void CTpClusterQueryRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_Type.toStr(ctx, buffer, "Type", "", true, "", "");
}


void CTpClusterQueryRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CTpClusterQueryRequest::serializer(IEspContext* ctx, IConstTpClusterQueryRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<TpClusterQueryRequest>");
	// field Type
	{
		const char* s = src.getType();
		if (s && *s)
		{
			buffer.append("<Type>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Type>");
		}
	}
	if (keepRootTag)
		buffer.append("</TpClusterQueryRequest>");
}

bool CTpClusterQueryRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_Type.unmarshall(rpc_request, "Type", basepath);
	return hasValue;
}

bool CTpClusterQueryRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Type.unmarshall(ctx, soapval, "Type");
	return hasValue;
}

bool CTpClusterQueryRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Type.unmarshall(ctx, params, attachments, "Type", basepath);
	return hasValue;
}

const char * CTpClusterQueryRequest::getType() { return m_Type.query();}
void CTpClusterQueryRequest::setType(const char * val){ m_Type.set(val); }
extern "C"  IEspTpClusterQueryRequest *createTpClusterQueryRequest(const char *serv){return ((IEspTpClusterQueryRequest *)new CTpClusterQueryRequest(serv));}
extern "C"  IClientTpClusterQueryRequest *createClientTpClusterQueryRequest(const char *serv){return ((IClientTpClusterQueryRequest *)new CTpClusterQueryRequest(serv));}

//=======================================================
// class CTpClusterQueryResponse Implementation
//=======================================================

CTpClusterQueryResponse::CTpClusterQueryResponse(const char *serviceName, IRpcMessageBinding *init)
	: m_EnableSNMP(nilIgnore),m_AcceptLanguage(nilIgnore),m_TpClusters(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("TpClusterQueryResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CTpClusterQueryResponse::CTpClusterQueryResponse(const char *serviceName, const char *bc)
	: m_EnableSNMP(nilIgnore),m_AcceptLanguage(nilIgnore),m_TpClusters(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("TpClusterQueryResponse");
}

CTpClusterQueryResponse::CTpClusterQueryResponse(const char *serviceName, IRpcMessage* rpcmsg)
	: m_EnableSNMP(nilIgnore),m_AcceptLanguage(nilIgnore),m_TpClusters(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("TpClusterQueryResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CTpClusterQueryResponse::CTpClusterQueryResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_EnableSNMP(nilIgnore),m_AcceptLanguage(nilIgnore),m_TpClusters(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("TpClusterQueryResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CTpClusterQueryResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		schema.append("<xsd:element name=\"Exceptions\" type=\"tns:ArrayOfEspException\" minOccurs=\"0\" maxOccurs=\"1\"/>");
		}
		if (!context.suppressed("TpClusterQueryResponse","EnableSNMP")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"EnableSNMP\" type=\"xsd:boolean\"/>\n");
		}
		if (!context.suppressed("TpClusterQueryResponse","AcceptLanguage")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"AcceptLanguage\" type=\"xsd:string\"/>\n");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"TpClusters\" type=\"tns:ArrayOfTpCluster\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	if (!(flags & 0x10)  || (flags & 0x100))
	{
		CTpCluster::getXsdDefinition(context, request, schema, added);
	}
	if (added.getValue("TpCluster") && added.getValue("ArrayOfTpCluster")==NULL) {
		schema.append("<xsd:complexType name=\"ArrayOfTpCluster\">\n");
		schema.append("<xsd:sequence>\n");
		schema.append("<xsd:element minOccurs=\"0\" maxOccurs=\"unbounded\" name=\"TpCluster\" type=\"tns:TpCluster\"/>\n");
		schema.append("</xsd:sequence>\n");
		schema.append("</xsd:complexType>\n");
		added.setValue("ArrayOfTpCluster",1);
	}
	return schema;
}

void CTpClusterQueryResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CTpClusterQueryResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
	info.addMinVersion("TpClusterQueryResponse","EnableSNMP",1.08);
	info.addMinVersion("TpClusterQueryResponse","AcceptLanguage",1.2);
	if (!added.getValue("TpCluster"))
	{
		added.setValue("TpCluster",1);
		CTpCluster::getMapInfo(info,added);
	}
}

StringBuffer &CTpClusterQueryResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	if (!context.suppressed("TpClusterQueryResponse","EnableSNMP")) {
		extfix.clear();
		if (prefix && *prefix)
			extfix.append(prefix).append(".");
		extfix.append("EnableSNMP");
		
	form.appendf("  <tr><td><b>EnableSNMP? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	}
	if (!context.suppressed("TpClusterQueryResponse","AcceptLanguage")) {
		extfix.clear();
		if (prefix && *prefix)
			extfix.append(prefix).append(".");
		extfix.append("AcceptLanguage");
		form.appendf("  <tr><td><b>AcceptLanguage: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
		form.append("</td></tr>\n");
	}
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("TpClusters");
	form.appendf("<tr><td><b>TpClusters: </b></td><td>");
	form.appendf("<table><tr><td><textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea></td>", extfix.str());
	form.append("</tr></table>");
	form.append("</td></tr>");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CTpClusterQueryResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CTpClusterQueryResponse::serialize(IRpcMessage& rpc_resp)
{
	IEspContext* ctx = rpc_resp.queryContext();
	double clientVer= ctx ? ctx->getClientVersion() : -1; /* no context gets everything */
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
		if ((clientVer==-1.0 || clientVer>=1.08))
			m_EnableSNMP.marshall(rpc_resp, "EnableSNMP", "", "", "");
		if ((clientVer==-1.0 || clientVer>=1.2))
			m_AcceptLanguage.marshall(rpc_resp, "AcceptLanguage", "", "", "");
		m_TpClusters.marshall(rpc_resp, "TpClusters", "TpCluster");
	}
}


void CTpClusterQueryResponse::copy(CTpClusterQueryResponse &from)
{
	m_EnableSNMP.copy(from.m_EnableSNMP);
	m_AcceptLanguage.copy(from.m_AcceptLanguage);
	m_TpClusters.copy(from.m_TpClusters);
}


void CTpClusterQueryResponse::copy(IConstTpClusterQueryResponse &ifrom)
{
	setEnableSNMP(ifrom.getEnableSNMP());
	setAcceptLanguage(ifrom.getAcceptLanguage());
	setTpClusters(ifrom.getTpClusters());
}


void CTpClusterQueryResponse::getAttributes(IProperties &attributes)
{
}


void CTpClusterQueryResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
		double clientVer = ctx ? ctx->getClientVersion() : -1;
		if ((clientVer==-1.0 || clientVer>=1.08))
			m_EnableSNMP.toStr(ctx, buffer, "EnableSNMP", "", true, "", "");
		if ((clientVer==-1.0 || clientVer>=1.2))
			m_AcceptLanguage.toStr(ctx, buffer, "AcceptLanguage", "", true, "", "");
		m_TpClusters.toStr(ctx, buffer, "TpClusters", "TpCluster");
	}
}


void CTpClusterQueryResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CTpClusterQueryResponse::serializer(IEspContext* ctx, IConstTpClusterQueryResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<TpClusterQueryResponse>");
	double clientVer = ctx ? ctx->getClientVersion() : -1;
	// field EnableSNMP
	if ((clientVer==-1.0 || clientVer>=1.08))
	{
		bool b = src.getEnableSNMP();
		if (b)
			buffer.appendf("<EnableSNMP>1</EnableSNMP>");
	}
	// field AcceptLanguage
	if ((clientVer==-1.0 || clientVer>=1.2))
	{
		const char* s = src.getAcceptLanguage();
		if (s && *s)
		{
			buffer.append("<AcceptLanguage>");
			encodeUtf8XML(s,buffer);
			buffer.append("</AcceptLanguage>");
		}
	}
	// field TpClusters
	{
		IArrayOf<IConstTpCluster>& v = src.getTpClusters();
		int size = v.length();
		if (size>0)
			buffer.append("<TpClusters>");
		for (int i=0;i<size;i++)
		{
			buffer.append("<Item>");
			CTpCluster::serializer(ctx,v.item(i),buffer,false);
			buffer.append("</Item>");
		}
		if (size>0)
			buffer.append("</TpClusters>");
	}
	if (keepRootTag)
		buffer.append("</TpClusterQueryResponse>");
}

bool CTpClusterQueryResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
		hasValue |= m_EnableSNMP.unmarshall(rpc_request, "EnableSNMP", basepath);
		hasValue |= m_AcceptLanguage.unmarshall(rpc_request, "AcceptLanguage", basepath);
		hasValue |= m_TpClusters.unmarshall(rpc_request, "TpClusters", basepath);
	}
	return hasValue;
}

bool CTpClusterQueryResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_EnableSNMP.unmarshall(ctx, soapval, "EnableSNMP");
	hasValue |= m_AcceptLanguage.unmarshall(ctx, soapval, "AcceptLanguage");
	hasValue |= m_TpClusters.unmarshall(ctx, soapval, "TpClusters");
	return hasValue;
}

bool CTpClusterQueryResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_EnableSNMP.unmarshall(ctx, params, attachments, "EnableSNMP", basepath);
	hasValue |= m_AcceptLanguage.unmarshall(ctx, params, attachments, "AcceptLanguage", basepath);
	hasValue |= m_TpClusters.unmarshall(ctx, params, attachments, "TpClusters", basepath);
	return hasValue;
}

bool CTpClusterQueryResponse::getEnableSNMP() { return m_EnableSNMP;}
const char * CTpClusterQueryResponse::getAcceptLanguage() { return m_AcceptLanguage.query();}
IArrayOf<IConstTpCluster> & CTpClusterQueryResponse::getTpClusters() { return (IArrayOf<IConstTpCluster> &) m_TpClusters; }
void CTpClusterQueryResponse::setEnableSNMP(bool val){ m_EnableSNMP=val; }
void CTpClusterQueryResponse::setAcceptLanguage(const char * val){ m_AcceptLanguage.set(val); }
void CTpClusterQueryResponse::setTpClusters(IArrayOf<IEspTpCluster> &val)
{
	m_TpClusters->kill();
	IArrayOf<IConstTpCluster> &target = m_TpClusters.getValue();
	ForEachItemIn(idx, val)
	{
		IEspTpCluster &item = (val).item(idx);
		item.Link();
		target.append(item);
	}
}
void CTpClusterQueryResponse::setTpClusters(IArrayOf<IConstTpCluster> &val)
{
	m_TpClusters->kill();
	IArrayOf<IConstTpCluster> &target = m_TpClusters.getValue();
	ForEachItemIn(idx, val)
	{
		IConstTpCluster &item = val.item(idx);
		item.Link();
		target.append(item);
	}
}
extern "C"  IEspTpClusterQueryResponse *createTpClusterQueryResponse(const char *serv){return ((IEspTpClusterQueryResponse *)new CTpClusterQueryResponse(serv));}
extern "C"  IClientTpClusterQueryResponse *createClientTpClusterQueryResponse(const char *serv){return ((IClientTpClusterQueryResponse *)new CTpClusterQueryResponse(serv));}

//=======================================================
// class CTpLogicalClusterQueryRequest Implementation
//=======================================================

CTpLogicalClusterQueryRequest::CTpLogicalClusterQueryRequest(const char *serviceName, IRpcMessageBinding *init)
	: m_EclServerQueue(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("TpLogicalClusterQueryRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CTpLogicalClusterQueryRequest::CTpLogicalClusterQueryRequest(const char *serviceName, const char *bc)
	: m_EclServerQueue(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("TpLogicalClusterQueryRequest");
}

CTpLogicalClusterQueryRequest::CTpLogicalClusterQueryRequest(const char *serviceName, IRpcMessage* rpcmsg)
	: m_EclServerQueue(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("TpLogicalClusterQueryRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CTpLogicalClusterQueryRequest::CTpLogicalClusterQueryRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_EclServerQueue(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("TpLogicalClusterQueryRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CTpLogicalClusterQueryRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"EclServerQueue\" type=\"xsd:string\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CTpLogicalClusterQueryRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CTpLogicalClusterQueryRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CTpLogicalClusterQueryRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("EclServerQueue");
	form.appendf("  <tr><td><b>EclServerQueue: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CTpLogicalClusterQueryRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CTpLogicalClusterQueryRequest::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_EclServerQueue.marshall(rpc_resp, "EclServerQueue", "", "", "");
}


void CTpLogicalClusterQueryRequest::copy(CTpLogicalClusterQueryRequest &from)
{
	m_EclServerQueue.copy(from.m_EclServerQueue);
}


void CTpLogicalClusterQueryRequest::copy(IConstTpLogicalClusterQueryRequest &ifrom)
{
	setEclServerQueue(ifrom.getEclServerQueue());
}


void CTpLogicalClusterQueryRequest::getAttributes(IProperties &attributes)
{
}


void CTpLogicalClusterQueryRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_EclServerQueue.toStr(ctx, buffer, "EclServerQueue", "", true, "", "");
}


void CTpLogicalClusterQueryRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CTpLogicalClusterQueryRequest::serializer(IEspContext* ctx, IConstTpLogicalClusterQueryRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<TpLogicalClusterQueryRequest>");
	// field EclServerQueue
	{
		const char* s = src.getEclServerQueue();
		if (s && *s)
		{
			buffer.append("<EclServerQueue>");
			encodeUtf8XML(s,buffer);
			buffer.append("</EclServerQueue>");
		}
	}
	if (keepRootTag)
		buffer.append("</TpLogicalClusterQueryRequest>");
}

bool CTpLogicalClusterQueryRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_EclServerQueue.unmarshall(rpc_request, "EclServerQueue", basepath);
	return hasValue;
}

bool CTpLogicalClusterQueryRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_EclServerQueue.unmarshall(ctx, soapval, "EclServerQueue");
	return hasValue;
}

bool CTpLogicalClusterQueryRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_EclServerQueue.unmarshall(ctx, params, attachments, "EclServerQueue", basepath);
	return hasValue;
}

const char * CTpLogicalClusterQueryRequest::getEclServerQueue() { return m_EclServerQueue.query();}
void CTpLogicalClusterQueryRequest::setEclServerQueue(const char * val){ m_EclServerQueue.set(val); }
extern "C"  IEspTpLogicalClusterQueryRequest *createTpLogicalClusterQueryRequest(const char *serv){return ((IEspTpLogicalClusterQueryRequest *)new CTpLogicalClusterQueryRequest(serv));}
extern "C"  IClientTpLogicalClusterQueryRequest *createClientTpLogicalClusterQueryRequest(const char *serv){return ((IClientTpLogicalClusterQueryRequest *)new CTpLogicalClusterQueryRequest(serv));}

//=======================================================
// class CTpLogicalClusterQueryResponse Implementation
//=======================================================

CTpLogicalClusterQueryResponse::CTpLogicalClusterQueryResponse(const char *serviceName, IRpcMessageBinding *init)
	: m_TpLogicalClusters(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("TpLogicalClusterQueryResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CTpLogicalClusterQueryResponse::CTpLogicalClusterQueryResponse(const char *serviceName, const char *bc)
	: m_TpLogicalClusters(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("TpLogicalClusterQueryResponse");
}

CTpLogicalClusterQueryResponse::CTpLogicalClusterQueryResponse(const char *serviceName, IRpcMessage* rpcmsg)
	: m_TpLogicalClusters(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("TpLogicalClusterQueryResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CTpLogicalClusterQueryResponse::CTpLogicalClusterQueryResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_TpLogicalClusters(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("TpLogicalClusterQueryResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CTpLogicalClusterQueryResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		schema.append("<xsd:element name=\"Exceptions\" type=\"tns:ArrayOfEspException\" minOccurs=\"0\" maxOccurs=\"1\"/>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"TpLogicalClusters\" type=\"tns:ArrayOfTpLogicalCluster\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	if (!(flags & 0x10)  || (flags & 0x100))
	{
		CTpLogicalCluster::getXsdDefinition(context, request, schema, added);
	}
	if (added.getValue("TpLogicalCluster") && added.getValue("ArrayOfTpLogicalCluster")==NULL) {
		schema.append("<xsd:complexType name=\"ArrayOfTpLogicalCluster\">\n");
		schema.append("<xsd:sequence>\n");
		schema.append("<xsd:element minOccurs=\"0\" maxOccurs=\"unbounded\" name=\"TpLogicalCluster\" type=\"tns:TpLogicalCluster\"/>\n");
		schema.append("</xsd:sequence>\n");
		schema.append("</xsd:complexType>\n");
		added.setValue("ArrayOfTpLogicalCluster",1);
	}
	return schema;
}

void CTpLogicalClusterQueryResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CTpLogicalClusterQueryResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
	if (!added.getValue("TpLogicalCluster"))
	{
		added.setValue("TpLogicalCluster",1);
		CTpLogicalCluster::getMapInfo(info,added);
	}
}

StringBuffer &CTpLogicalClusterQueryResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("TpLogicalClusters");
	form.appendf("<tr><td><b>TpLogicalClusters: </b></td><td>");
	form.appendf("<table><tr><td><textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea></td>", extfix.str());
	form.append("</tr></table>");
	form.append("</td></tr>");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CTpLogicalClusterQueryResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CTpLogicalClusterQueryResponse::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
		m_TpLogicalClusters.marshall(rpc_resp, "TpLogicalClusters", "TpLogicalCluster");
	}
}


void CTpLogicalClusterQueryResponse::copy(CTpLogicalClusterQueryResponse &from)
{
	m_TpLogicalClusters.copy(from.m_TpLogicalClusters);
}


void CTpLogicalClusterQueryResponse::copy(IConstTpLogicalClusterQueryResponse &ifrom)
{
	setTpLogicalClusters(ifrom.getTpLogicalClusters());
}


void CTpLogicalClusterQueryResponse::getAttributes(IProperties &attributes)
{
}


void CTpLogicalClusterQueryResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
		m_TpLogicalClusters.toStr(ctx, buffer, "TpLogicalClusters", "TpLogicalCluster");
	}
}


void CTpLogicalClusterQueryResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CTpLogicalClusterQueryResponse::serializer(IEspContext* ctx, IConstTpLogicalClusterQueryResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<TpLogicalClusterQueryResponse>");
	// field TpLogicalClusters
	{
		IArrayOf<IConstTpLogicalCluster>& v = src.getTpLogicalClusters();
		int size = v.length();
		if (size>0)
			buffer.append("<TpLogicalClusters>");
		for (int i=0;i<size;i++)
		{
			buffer.append("<Item>");
			CTpLogicalCluster::serializer(ctx,v.item(i),buffer,false);
			buffer.append("</Item>");
		}
		if (size>0)
			buffer.append("</TpLogicalClusters>");
	}
	if (keepRootTag)
		buffer.append("</TpLogicalClusterQueryResponse>");
}

bool CTpLogicalClusterQueryResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
		hasValue |= m_TpLogicalClusters.unmarshall(rpc_request, "TpLogicalClusters", basepath);
	}
	return hasValue;
}

bool CTpLogicalClusterQueryResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_TpLogicalClusters.unmarshall(ctx, soapval, "TpLogicalClusters");
	return hasValue;
}

bool CTpLogicalClusterQueryResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_TpLogicalClusters.unmarshall(ctx, params, attachments, "TpLogicalClusters", basepath);
	return hasValue;
}

IArrayOf<IConstTpLogicalCluster> & CTpLogicalClusterQueryResponse::getTpLogicalClusters() { return (IArrayOf<IConstTpLogicalCluster> &) m_TpLogicalClusters; }
void CTpLogicalClusterQueryResponse::setTpLogicalClusters(IArrayOf<IEspTpLogicalCluster> &val)
{
	m_TpLogicalClusters->kill();
	IArrayOf<IConstTpLogicalCluster> &target = m_TpLogicalClusters.getValue();
	ForEachItemIn(idx, val)
	{
		IEspTpLogicalCluster &item = (val).item(idx);
		item.Link();
		target.append(item);
	}
}
void CTpLogicalClusterQueryResponse::setTpLogicalClusters(IArrayOf<IConstTpLogicalCluster> &val)
{
	m_TpLogicalClusters->kill();
	IArrayOf<IConstTpLogicalCluster> &target = m_TpLogicalClusters.getValue();
	ForEachItemIn(idx, val)
	{
		IConstTpLogicalCluster &item = val.item(idx);
		item.Link();
		target.append(item);
	}
}
extern "C"  IEspTpLogicalClusterQueryResponse *createTpLogicalClusterQueryResponse(const char *serv){return ((IEspTpLogicalClusterQueryResponse *)new CTpLogicalClusterQueryResponse(serv));}
extern "C"  IClientTpLogicalClusterQueryResponse *createClientTpLogicalClusterQueryResponse(const char *serv){return ((IClientTpLogicalClusterQueryResponse *)new CTpLogicalClusterQueryResponse(serv));}

//=======================================================
// class CTpGroupQueryRequest Implementation
//=======================================================

CTpGroupQueryRequest::CTpGroupQueryRequest(const char *serviceName, IRpcMessageBinding *init)
	: m_Kind(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("TpGroupQueryRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CTpGroupQueryRequest::CTpGroupQueryRequest(const char *serviceName, const char *bc)
	: m_Kind(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("TpGroupQueryRequest");
}

CTpGroupQueryRequest::CTpGroupQueryRequest(const char *serviceName, IRpcMessage* rpcmsg)
	: m_Kind(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("TpGroupQueryRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CTpGroupQueryRequest::CTpGroupQueryRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_Kind(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("TpGroupQueryRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CTpGroupQueryRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		if (!context.suppressed("TpGroupQueryRequest","Kind")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"Kind\" type=\"xsd:string\"/>\n");
		}
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CTpGroupQueryRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CTpGroupQueryRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
	info.addMinVersion("TpGroupQueryRequest","Kind",1.21);
}

StringBuffer &CTpGroupQueryRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	if (!context.suppressed("TpGroupQueryRequest","Kind")) {
		extfix.clear();
		if (prefix && *prefix)
			extfix.append(prefix).append(".");
		extfix.append("Kind");
		form.appendf("  <tr><td><b>Kind: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
		form.append("</td></tr>\n");
	}
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CTpGroupQueryRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CTpGroupQueryRequest::serialize(IRpcMessage& rpc_resp)
{
	IEspContext* ctx = rpc_resp.queryContext();
	double clientVer= ctx ? ctx->getClientVersion() : -1; /* no context gets everything */
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	if ((clientVer==-1.0 || clientVer>=1.21))
		m_Kind.marshall(rpc_resp, "Kind", "", "", "");
}


void CTpGroupQueryRequest::copy(CTpGroupQueryRequest &from)
{
	m_Kind.copy(from.m_Kind);
}


void CTpGroupQueryRequest::copy(IConstTpGroupQueryRequest &ifrom)
{
	setKind(ifrom.getKind());
}


void CTpGroupQueryRequest::getAttributes(IProperties &attributes)
{
}


void CTpGroupQueryRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	double clientVer = ctx ? ctx->getClientVersion() : -1;
	if ((clientVer==-1.0 || clientVer>=1.21))
		m_Kind.toStr(ctx, buffer, "Kind", "", true, "", "");
}


void CTpGroupQueryRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CTpGroupQueryRequest::serializer(IEspContext* ctx, IConstTpGroupQueryRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<TpGroupQueryRequest>");
	double clientVer = ctx ? ctx->getClientVersion() : -1;
	// field Kind
	if ((clientVer==-1.0 || clientVer>=1.21))
	{
		const char* s = src.getKind();
		if (s && *s)
		{
			buffer.append("<Kind>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Kind>");
		}
	}
	if (keepRootTag)
		buffer.append("</TpGroupQueryRequest>");
}

bool CTpGroupQueryRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_Kind.unmarshall(rpc_request, "Kind", basepath);
	return hasValue;
}

bool CTpGroupQueryRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Kind.unmarshall(ctx, soapval, "Kind");
	return hasValue;
}

bool CTpGroupQueryRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Kind.unmarshall(ctx, params, attachments, "Kind", basepath);
	return hasValue;
}

const char * CTpGroupQueryRequest::getKind() { return m_Kind.query();}
void CTpGroupQueryRequest::setKind(const char * val){ m_Kind.set(val); }
extern "C"  IEspTpGroupQueryRequest *createTpGroupQueryRequest(const char *serv){return ((IEspTpGroupQueryRequest *)new CTpGroupQueryRequest(serv));}
extern "C"  IClientTpGroupQueryRequest *createClientTpGroupQueryRequest(const char *serv){return ((IClientTpGroupQueryRequest *)new CTpGroupQueryRequest(serv));}

//=======================================================
// class CTpGroupQueryResponse Implementation
//=======================================================

CTpGroupQueryResponse::CTpGroupQueryResponse(const char *serviceName, IRpcMessageBinding *init)
	: m_TpGroups(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("TpGroupQueryResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CTpGroupQueryResponse::CTpGroupQueryResponse(const char *serviceName, const char *bc)
	: m_TpGroups(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("TpGroupQueryResponse");
}

CTpGroupQueryResponse::CTpGroupQueryResponse(const char *serviceName, IRpcMessage* rpcmsg)
	: m_TpGroups(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("TpGroupQueryResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CTpGroupQueryResponse::CTpGroupQueryResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_TpGroups(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("TpGroupQueryResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CTpGroupQueryResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		schema.append("<xsd:element name=\"Exceptions\" type=\"tns:ArrayOfEspException\" minOccurs=\"0\" maxOccurs=\"1\"/>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"TpGroups\" type=\"tns:ArrayOfTpGroup\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	if (!(flags & 0x10)  || (flags & 0x100))
	{
		CTpGroup::getXsdDefinition(context, request, schema, added);
	}
	if (added.getValue("TpGroup") && added.getValue("ArrayOfTpGroup")==NULL) {
		schema.append("<xsd:complexType name=\"ArrayOfTpGroup\">\n");
		schema.append("<xsd:sequence>\n");
		schema.append("<xsd:element minOccurs=\"0\" maxOccurs=\"unbounded\" name=\"TpGroup\" type=\"tns:TpGroup\"/>\n");
		schema.append("</xsd:sequence>\n");
		schema.append("</xsd:complexType>\n");
		added.setValue("ArrayOfTpGroup",1);
	}
	return schema;
}

void CTpGroupQueryResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CTpGroupQueryResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
	if (!added.getValue("TpGroup"))
	{
		added.setValue("TpGroup",1);
		CTpGroup::getMapInfo(info,added);
	}
}

StringBuffer &CTpGroupQueryResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("TpGroups");
	form.appendf("<tr><td><b>TpGroups: </b></td><td>");
	form.appendf("<table><tr><td><textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea></td>", extfix.str());
	form.append("</tr></table>");
	form.append("</td></tr>");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CTpGroupQueryResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CTpGroupQueryResponse::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
		m_TpGroups.marshall(rpc_resp, "TpGroups", "TpGroup");
	}
}


void CTpGroupQueryResponse::copy(CTpGroupQueryResponse &from)
{
	m_TpGroups.copy(from.m_TpGroups);
}


void CTpGroupQueryResponse::copy(IConstTpGroupQueryResponse &ifrom)
{
	setTpGroups(ifrom.getTpGroups());
}


void CTpGroupQueryResponse::getAttributes(IProperties &attributes)
{
}


void CTpGroupQueryResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
		m_TpGroups.toStr(ctx, buffer, "TpGroups", "TpGroup");
	}
}


void CTpGroupQueryResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CTpGroupQueryResponse::serializer(IEspContext* ctx, IConstTpGroupQueryResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<TpGroupQueryResponse>");
	// field TpGroups
	{
		IArrayOf<IConstTpGroup>& v = src.getTpGroups();
		int size = v.length();
		if (size>0)
			buffer.append("<TpGroups>");
		for (int i=0;i<size;i++)
		{
			buffer.append("<Item>");
			CTpGroup::serializer(ctx,v.item(i),buffer,false);
			buffer.append("</Item>");
		}
		if (size>0)
			buffer.append("</TpGroups>");
	}
	if (keepRootTag)
		buffer.append("</TpGroupQueryResponse>");
}

bool CTpGroupQueryResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
		hasValue |= m_TpGroups.unmarshall(rpc_request, "TpGroups", basepath);
	}
	return hasValue;
}

bool CTpGroupQueryResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_TpGroups.unmarshall(ctx, soapval, "TpGroups");
	return hasValue;
}

bool CTpGroupQueryResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_TpGroups.unmarshall(ctx, params, attachments, "TpGroups", basepath);
	return hasValue;
}

IArrayOf<IConstTpGroup> & CTpGroupQueryResponse::getTpGroups() { return (IArrayOf<IConstTpGroup> &) m_TpGroups; }
void CTpGroupQueryResponse::setTpGroups(IArrayOf<IEspTpGroup> &val)
{
	m_TpGroups->kill();
	IArrayOf<IConstTpGroup> &target = m_TpGroups.getValue();
	ForEachItemIn(idx, val)
	{
		IEspTpGroup &item = (val).item(idx);
		item.Link();
		target.append(item);
	}
}
void CTpGroupQueryResponse::setTpGroups(IArrayOf<IConstTpGroup> &val)
{
	m_TpGroups->kill();
	IArrayOf<IConstTpGroup> &target = m_TpGroups.getValue();
	ForEachItemIn(idx, val)
	{
		IConstTpGroup &item = val.item(idx);
		item.Link();
		target.append(item);
	}
}
extern "C"  IEspTpGroupQueryResponse *createTpGroupQueryResponse(const char *serv){return ((IEspTpGroupQueryResponse *)new CTpGroupQueryResponse(serv));}
extern "C"  IClientTpGroupQueryResponse *createClientTpGroupQueryResponse(const char *serv){return ((IClientTpGroupQueryResponse *)new CTpGroupQueryResponse(serv));}

//=======================================================
// class CTpClusterInfoRequest Implementation
//=======================================================

CTpClusterInfoRequest::CTpClusterInfoRequest(const char *serviceName, IRpcMessageBinding *init)
	: m_Name(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("TpClusterInfoRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CTpClusterInfoRequest::CTpClusterInfoRequest(const char *serviceName, const char *bc)
	: m_Name(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("TpClusterInfoRequest");
}

CTpClusterInfoRequest::CTpClusterInfoRequest(const char *serviceName, IRpcMessage* rpcmsg)
	: m_Name(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("TpClusterInfoRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CTpClusterInfoRequest::CTpClusterInfoRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_Name(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("TpClusterInfoRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CTpClusterInfoRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Name\" type=\"xsd:string\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CTpClusterInfoRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CTpClusterInfoRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CTpClusterInfoRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Name");
	form.appendf("  <tr><td><b>Name: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CTpClusterInfoRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CTpClusterInfoRequest::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_Name.marshall(rpc_resp, "Name", "", "", "");
}


void CTpClusterInfoRequest::copy(CTpClusterInfoRequest &from)
{
	m_Name.copy(from.m_Name);
}


void CTpClusterInfoRequest::copy(IConstTpClusterInfoRequest &ifrom)
{
	setName(ifrom.getName());
}


void CTpClusterInfoRequest::getAttributes(IProperties &attributes)
{
}


void CTpClusterInfoRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_Name.toStr(ctx, buffer, "Name", "", true, "", "");
}


void CTpClusterInfoRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CTpClusterInfoRequest::serializer(IEspContext* ctx, IConstTpClusterInfoRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<TpClusterInfoRequest>");
	// field Name
	{
		const char* s = src.getName();
		if (s && *s)
		{
			buffer.append("<Name>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Name>");
		}
	}
	if (keepRootTag)
		buffer.append("</TpClusterInfoRequest>");
}

bool CTpClusterInfoRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_Name.unmarshall(rpc_request, "Name", basepath);
	return hasValue;
}

bool CTpClusterInfoRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Name.unmarshall(ctx, soapval, "Name");
	return hasValue;
}

bool CTpClusterInfoRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Name.unmarshall(ctx, params, attachments, "Name", basepath);
	return hasValue;
}

const char * CTpClusterInfoRequest::getName() { return m_Name.query();}
void CTpClusterInfoRequest::setName(const char * val){ m_Name.set(val); }
extern "C"  IEspTpClusterInfoRequest *createTpClusterInfoRequest(const char *serv){return ((IEspTpClusterInfoRequest *)new CTpClusterInfoRequest(serv));}
extern "C"  IClientTpClusterInfoRequest *createClientTpClusterInfoRequest(const char *serv){return ((IClientTpClusterInfoRequest *)new CTpClusterInfoRequest(serv));}

//=======================================================
// class CTpClusterInfoResponse Implementation
//=======================================================

CTpClusterInfoResponse::CTpClusterInfoResponse(const char *serviceName, IRpcMessageBinding *init)
	: m_Name(nilIgnore),m_WorkUnit(nilIgnore),m_TpQueues(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("TpClusterInfoResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CTpClusterInfoResponse::CTpClusterInfoResponse(const char *serviceName, const char *bc)
	: m_Name(nilIgnore),m_WorkUnit(nilIgnore),m_TpQueues(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("TpClusterInfoResponse");
}

CTpClusterInfoResponse::CTpClusterInfoResponse(const char *serviceName, IRpcMessage* rpcmsg)
	: m_Name(nilIgnore),m_WorkUnit(nilIgnore),m_TpQueues(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("TpClusterInfoResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CTpClusterInfoResponse::CTpClusterInfoResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_Name(nilIgnore),m_WorkUnit(nilIgnore),m_TpQueues(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("TpClusterInfoResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CTpClusterInfoResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		schema.append("<xsd:element name=\"Exceptions\" type=\"tns:ArrayOfEspException\" minOccurs=\"0\" maxOccurs=\"1\"/>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Name\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"WorkUnit\" type=\"xsd:string\"/>\n");
		if (!context.suppressed("TpClusterInfoResponse","TpQueues")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"TpQueues\" type=\"tns:ArrayOfTpQueue\"/>\n");
		}
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	if (!(flags & 0x10)  || (flags & 0x100))
	{
		if (!context.suppressed("TpClusterInfoResponse","TpQueues"))
			CTpQueue::getXsdDefinition(context, request, schema, added);
	}
	if (added.getValue("TpQueue") && added.getValue("ArrayOfTpQueue")==NULL) {
		schema.append("<xsd:complexType name=\"ArrayOfTpQueue\">\n");
		schema.append("<xsd:sequence>\n");
		schema.append("<xsd:element minOccurs=\"0\" maxOccurs=\"unbounded\" name=\"TpQueue\" type=\"tns:TpQueue\"/>\n");
		schema.append("</xsd:sequence>\n");
		schema.append("</xsd:complexType>\n");
		added.setValue("ArrayOfTpQueue",1);
	}
	return schema;
}

void CTpClusterInfoResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CTpClusterInfoResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
	info.addMinVersion("TpClusterInfoResponse","TpQueues",1.1);
	if (!added.getValue("TpQueue"))
	{
		added.setValue("TpQueue",1);
		CTpQueue::getMapInfo(info,added);
	}
}

StringBuffer &CTpClusterInfoResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Name");
	form.appendf("  <tr><td><b>Name: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("WorkUnit");
	form.appendf("  <tr><td><b>WorkUnit: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (!context.suppressed("TpClusterInfoResponse","TpQueues")) {
		extfix.clear();
		if (prefix && *prefix)
			extfix.append(prefix).append(".");
		extfix.append("TpQueues");
		form.appendf("<tr><td><b>TpQueues: </b></td><td>");
		form.appendf("<table><tr><td><textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea></td>", extfix.str());
		form.append("</tr></table>");
		form.append("</td></tr>");
	}
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CTpClusterInfoResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CTpClusterInfoResponse::serialize(IRpcMessage& rpc_resp)
{
	IEspContext* ctx = rpc_resp.queryContext();
	double clientVer= ctx ? ctx->getClientVersion() : -1; /* no context gets everything */
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	rpc_resp.setEncodeXml(false);
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
		m_Name.marshall(rpc_resp, "Name", "", "", "");
		m_WorkUnit.marshall(rpc_resp, "WorkUnit", "", "", "");
		if ((clientVer==-1.0 || clientVer>=1.1))
			m_TpQueues.marshall(rpc_resp, "TpQueues", "TpQueue");
	}
}


void CTpClusterInfoResponse::copy(CTpClusterInfoResponse &from)
{
	m_Name.copy(from.m_Name);
	m_WorkUnit.copy(from.m_WorkUnit);
	m_TpQueues.copy(from.m_TpQueues);
}


void CTpClusterInfoResponse::copy(IConstTpClusterInfoResponse &ifrom)
{
	setName(ifrom.getName());
	setWorkUnit(ifrom.getWorkUnit());
	setTpQueues(ifrom.getTpQueues());
}


void CTpClusterInfoResponse::getAttributes(IProperties &attributes)
{
}


void CTpClusterInfoResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
		double clientVer = ctx ? ctx->getClientVersion() : -1;
		m_Name.toStr(ctx, buffer, "Name", "", false, "", "");
		m_WorkUnit.toStr(ctx, buffer, "WorkUnit", "", false, "", "");
		if ((clientVer==-1.0 || clientVer>=1.1))
			m_TpQueues.toStr(ctx, buffer, "TpQueues", "TpQueue");
	}
}


void CTpClusterInfoResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CTpClusterInfoResponse::serializer(IEspContext* ctx, IConstTpClusterInfoResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<TpClusterInfoResponse>");
	double clientVer = ctx ? ctx->getClientVersion() : -1;
	// field Name
	{
		const char* s = src.getName();
		if (s && *s)
		buffer.appendf("<Name>%s</Name>",s);
	}
	// field WorkUnit
	{
		const char* s = src.getWorkUnit();
		if (s && *s)
		buffer.appendf("<WorkUnit>%s</WorkUnit>",s);
	}
	// field TpQueues
	if ((clientVer==-1.0 || clientVer>=1.1))
	{
		IArrayOf<IConstTpQueue>& v = src.getTpQueues();
		int size = v.length();
		if (size>0)
			buffer.append("<TpQueues>");
		for (int i=0;i<size;i++)
		{
			buffer.append("<Item>");
			CTpQueue::serializer(ctx,v.item(i),buffer,false);
			buffer.append("</Item>");
		}
		if (size>0)
			buffer.append("</TpQueues>");
	}
	if (keepRootTag)
		buffer.append("</TpClusterInfoResponse>");
}

bool CTpClusterInfoResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
		hasValue |= m_Name.unmarshall(rpc_request, "Name", basepath);
		hasValue |= m_WorkUnit.unmarshall(rpc_request, "WorkUnit", basepath);
		hasValue |= m_TpQueues.unmarshall(rpc_request, "TpQueues", basepath);
	}
	return hasValue;
}

bool CTpClusterInfoResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Name.unmarshall(ctx, soapval, "Name");
	hasValue |= m_WorkUnit.unmarshall(ctx, soapval, "WorkUnit");
	hasValue |= m_TpQueues.unmarshall(ctx, soapval, "TpQueues");
	return hasValue;
}

bool CTpClusterInfoResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Name.unmarshall(ctx, params, attachments, "Name", basepath);
	hasValue |= m_WorkUnit.unmarshall(ctx, params, attachments, "WorkUnit", basepath);
	hasValue |= m_TpQueues.unmarshall(ctx, params, attachments, "TpQueues", basepath);
	return hasValue;
}

const char * CTpClusterInfoResponse::getName() { return m_Name.query();}
const char * CTpClusterInfoResponse::getWorkUnit() { return m_WorkUnit.query();}
IArrayOf<IConstTpQueue> & CTpClusterInfoResponse::getTpQueues() { return (IArrayOf<IConstTpQueue> &) m_TpQueues; }
void CTpClusterInfoResponse::setName(const char * val){ m_Name.set(val); }
void CTpClusterInfoResponse::setWorkUnit(const char * val){ m_WorkUnit.set(val); }
void CTpClusterInfoResponse::setTpQueues(IArrayOf<IEspTpQueue> &val)
{
	m_TpQueues->kill();
	IArrayOf<IConstTpQueue> &target = m_TpQueues.getValue();
	ForEachItemIn(idx, val)
	{
		IEspTpQueue &item = (val).item(idx);
		item.Link();
		target.append(item);
	}
}
void CTpClusterInfoResponse::setTpQueues(IArrayOf<IConstTpQueue> &val)
{
	m_TpQueues->kill();
	IArrayOf<IConstTpQueue> &target = m_TpQueues.getValue();
	ForEachItemIn(idx, val)
	{
		IConstTpQueue &item = val.item(idx);
		item.Link();
		target.append(item);
	}
}
extern "C"  IEspTpClusterInfoResponse *createTpClusterInfoResponse(const char *serv){return ((IEspTpClusterInfoResponse *)new CTpClusterInfoResponse(serv));}
extern "C"  IClientTpClusterInfoResponse *createClientTpClusterInfoResponse(const char *serv){return ((IClientTpClusterInfoResponse *)new CTpClusterInfoResponse(serv));}

//=======================================================
// class CTpMachineQueryRequest Implementation
//=======================================================

CTpMachineQueryRequest::CTpMachineQueryRequest(const char *serviceName, IRpcMessageBinding *init)
	: m_Type(nilIgnore),m_Cluster(nilIgnore),m_OldIP(nilIgnore),m_Path(nilIgnore),m_Directory(nilIgnore),m_LogDirectory(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("TpMachineQueryRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CTpMachineQueryRequest::CTpMachineQueryRequest(const char *serviceName, const char *bc)
	: m_Type(nilIgnore),m_Cluster(nilIgnore),m_OldIP(nilIgnore),m_Path(nilIgnore),m_Directory(nilIgnore),m_LogDirectory(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("TpMachineQueryRequest");
}

CTpMachineQueryRequest::CTpMachineQueryRequest(const char *serviceName, IRpcMessage* rpcmsg)
	: m_Type(nilIgnore),m_Cluster(nilIgnore),m_OldIP(nilIgnore),m_Path(nilIgnore),m_Directory(nilIgnore),m_LogDirectory(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("TpMachineQueryRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CTpMachineQueryRequest::CTpMachineQueryRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_Type(nilIgnore),m_Cluster(nilIgnore),m_OldIP(nilIgnore),m_Path(nilIgnore),m_Directory(nilIgnore),m_LogDirectory(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("TpMachineQueryRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CTpMachineQueryRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Type\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Cluster\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"OldIP\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Path\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Directory\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"LogDirectory\" type=\"xsd:string\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CTpMachineQueryRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CTpMachineQueryRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CTpMachineQueryRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Type");
	form.appendf("  <tr><td><b>Type: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Cluster");
	form.appendf("  <tr><td><b>Cluster: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("OldIP");
	form.appendf("  <tr><td><b>OldIP: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Path");
	form.appendf("  <tr><td><b>Path: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Directory");
	form.appendf("  <tr><td><b>Directory: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("LogDirectory");
	form.appendf("  <tr><td><b>LogDirectory: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CTpMachineQueryRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CTpMachineQueryRequest::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_Type.marshall(rpc_resp, "Type", "", "", "");
	m_Cluster.marshall(rpc_resp, "Cluster", "", "", "");
	m_OldIP.marshall(rpc_resp, "OldIP", "", "", "");
	m_Path.marshall(rpc_resp, "Path", "", "", "");
	m_Directory.marshall(rpc_resp, "Directory", "", "", "");
	m_LogDirectory.marshall(rpc_resp, "LogDirectory", "", "", "");
}


void CTpMachineQueryRequest::copy(CTpMachineQueryRequest &from)
{
	m_Type.copy(from.m_Type);
	m_Cluster.copy(from.m_Cluster);
	m_OldIP.copy(from.m_OldIP);
	m_Path.copy(from.m_Path);
	m_Directory.copy(from.m_Directory);
	m_LogDirectory.copy(from.m_LogDirectory);
}


void CTpMachineQueryRequest::copy(IConstTpMachineQueryRequest &ifrom)
{
	setType(ifrom.getType());
	setCluster(ifrom.getCluster());
	setOldIP(ifrom.getOldIP());
	setPath(ifrom.getPath());
	setDirectory(ifrom.getDirectory());
	setLogDirectory(ifrom.getLogDirectory());
}


void CTpMachineQueryRequest::getAttributes(IProperties &attributes)
{
}


void CTpMachineQueryRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_Type.toStr(ctx, buffer, "Type", "", true, "", "");
	m_Cluster.toStr(ctx, buffer, "Cluster", "", true, "", "");
	m_OldIP.toStr(ctx, buffer, "OldIP", "", true, "", "");
	m_Path.toStr(ctx, buffer, "Path", "", true, "", "");
	m_Directory.toStr(ctx, buffer, "Directory", "", true, "", "");
	m_LogDirectory.toStr(ctx, buffer, "LogDirectory", "", true, "", "");
}


void CTpMachineQueryRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CTpMachineQueryRequest::serializer(IEspContext* ctx, IConstTpMachineQueryRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<TpMachineQueryRequest>");
	// field Type
	{
		const char* s = src.getType();
		if (s && *s)
		{
			buffer.append("<Type>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Type>");
		}
	}
	// field Cluster
	{
		const char* s = src.getCluster();
		if (s && *s)
		{
			buffer.append("<Cluster>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Cluster>");
		}
	}
	// field OldIP
	{
		const char* s = src.getOldIP();
		if (s && *s)
		{
			buffer.append("<OldIP>");
			encodeUtf8XML(s,buffer);
			buffer.append("</OldIP>");
		}
	}
	// field Path
	{
		const char* s = src.getPath();
		if (s && *s)
		{
			buffer.append("<Path>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Path>");
		}
	}
	// field Directory
	{
		const char* s = src.getDirectory();
		if (s && *s)
		{
			buffer.append("<Directory>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Directory>");
		}
	}
	// field LogDirectory
	{
		const char* s = src.getLogDirectory();
		if (s && *s)
		{
			buffer.append("<LogDirectory>");
			encodeUtf8XML(s,buffer);
			buffer.append("</LogDirectory>");
		}
	}
	if (keepRootTag)
		buffer.append("</TpMachineQueryRequest>");
}

bool CTpMachineQueryRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_Type.unmarshall(rpc_request, "Type", basepath);
	hasValue |= m_Cluster.unmarshall(rpc_request, "Cluster", basepath);
	hasValue |= m_OldIP.unmarshall(rpc_request, "OldIP", basepath);
	hasValue |= m_Path.unmarshall(rpc_request, "Path", basepath);
	hasValue |= m_Directory.unmarshall(rpc_request, "Directory", basepath);
	hasValue |= m_LogDirectory.unmarshall(rpc_request, "LogDirectory", basepath);
	return hasValue;
}

bool CTpMachineQueryRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Type.unmarshall(ctx, soapval, "Type");
	hasValue |= m_Cluster.unmarshall(ctx, soapval, "Cluster");
	hasValue |= m_OldIP.unmarshall(ctx, soapval, "OldIP");
	hasValue |= m_Path.unmarshall(ctx, soapval, "Path");
	hasValue |= m_Directory.unmarshall(ctx, soapval, "Directory");
	hasValue |= m_LogDirectory.unmarshall(ctx, soapval, "LogDirectory");
	return hasValue;
}

bool CTpMachineQueryRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Type.unmarshall(ctx, params, attachments, "Type", basepath);
	hasValue |= m_Cluster.unmarshall(ctx, params, attachments, "Cluster", basepath);
	hasValue |= m_OldIP.unmarshall(ctx, params, attachments, "OldIP", basepath);
	hasValue |= m_Path.unmarshall(ctx, params, attachments, "Path", basepath);
	hasValue |= m_Directory.unmarshall(ctx, params, attachments, "Directory", basepath);
	hasValue |= m_LogDirectory.unmarshall(ctx, params, attachments, "LogDirectory", basepath);
	return hasValue;
}

const char * CTpMachineQueryRequest::getType() { return m_Type.query();}
const char * CTpMachineQueryRequest::getCluster() { return m_Cluster.query();}
const char * CTpMachineQueryRequest::getOldIP() { return m_OldIP.query();}
const char * CTpMachineQueryRequest::getPath() { return m_Path.query();}
const char * CTpMachineQueryRequest::getDirectory() { return m_Directory.query();}
const char * CTpMachineQueryRequest::getLogDirectory() { return m_LogDirectory.query();}
void CTpMachineQueryRequest::setType(const char * val){ m_Type.set(val); }
void CTpMachineQueryRequest::setCluster(const char * val){ m_Cluster.set(val); }
void CTpMachineQueryRequest::setOldIP(const char * val){ m_OldIP.set(val); }
void CTpMachineQueryRequest::setPath(const char * val){ m_Path.set(val); }
void CTpMachineQueryRequest::setDirectory(const char * val){ m_Directory.set(val); }
void CTpMachineQueryRequest::setLogDirectory(const char * val){ m_LogDirectory.set(val); }
extern "C"  IEspTpMachineQueryRequest *createTpMachineQueryRequest(const char *serv){return ((IEspTpMachineQueryRequest *)new CTpMachineQueryRequest(serv));}
extern "C"  IClientTpMachineQueryRequest *createClientTpMachineQueryRequest(const char *serv){return ((IClientTpMachineQueryRequest *)new CTpMachineQueryRequest(serv));}

//=======================================================
// class CTpMachineQueryResponse Implementation
//=======================================================

CTpMachineQueryResponse::CTpMachineQueryResponse(const char *serviceName, IRpcMessageBinding *init)
	: m_EnablePreflightInfo(nilIgnore),m_HasThorSpareProcess(nilIgnore),m_Type(nilIgnore),m_Cluster(nilIgnore),m_OldIP(nilIgnore),m_LogDirectory(nilIgnore),m_Path(nilIgnore),m_MemThreshold(nilIgnore),m_DiskThreshold(nilIgnore),m_CpuThreshold(nilIgnore),m_MemThresholdType(nilIgnore),m_DiskThresholdType(nilIgnore),m_PreflightProcessFilter(nilIgnore),m_EnableSNMP(nilIgnore),m_AcceptLanguage(nilIgnore),m_TpMachines(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("TpMachineQueryResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CTpMachineQueryResponse::CTpMachineQueryResponse(const char *serviceName, const char *bc)
	: m_EnablePreflightInfo(nilIgnore),m_HasThorSpareProcess(nilIgnore),m_Type(nilIgnore),m_Cluster(nilIgnore),m_OldIP(nilIgnore),m_LogDirectory(nilIgnore),m_Path(nilIgnore),m_MemThreshold(nilIgnore),m_DiskThreshold(nilIgnore),m_CpuThreshold(nilIgnore),m_MemThresholdType(nilIgnore),m_DiskThresholdType(nilIgnore),m_PreflightProcessFilter(nilIgnore),m_EnableSNMP(nilIgnore),m_AcceptLanguage(nilIgnore),m_TpMachines(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("TpMachineQueryResponse");
}

CTpMachineQueryResponse::CTpMachineQueryResponse(const char *serviceName, IRpcMessage* rpcmsg)
	: m_EnablePreflightInfo(nilIgnore),m_HasThorSpareProcess(nilIgnore),m_Type(nilIgnore),m_Cluster(nilIgnore),m_OldIP(nilIgnore),m_LogDirectory(nilIgnore),m_Path(nilIgnore),m_MemThreshold(nilIgnore),m_DiskThreshold(nilIgnore),m_CpuThreshold(nilIgnore),m_MemThresholdType(nilIgnore),m_DiskThresholdType(nilIgnore),m_PreflightProcessFilter(nilIgnore),m_EnableSNMP(nilIgnore),m_AcceptLanguage(nilIgnore),m_TpMachines(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("TpMachineQueryResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CTpMachineQueryResponse::CTpMachineQueryResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_EnablePreflightInfo(nilIgnore),m_HasThorSpareProcess(nilIgnore),m_Type(nilIgnore),m_Cluster(nilIgnore),m_OldIP(nilIgnore),m_LogDirectory(nilIgnore),m_Path(nilIgnore),m_MemThreshold(nilIgnore),m_DiskThreshold(nilIgnore),m_CpuThreshold(nilIgnore),m_MemThresholdType(nilIgnore),m_DiskThresholdType(nilIgnore),m_PreflightProcessFilter(nilIgnore),m_EnableSNMP(nilIgnore),m_AcceptLanguage(nilIgnore),m_TpMachines(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("TpMachineQueryResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CTpMachineQueryResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		schema.append("<xsd:element name=\"Exceptions\" type=\"tns:ArrayOfEspException\" minOccurs=\"0\" maxOccurs=\"1\"/>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"EnablePreflightInfo\" type=\"xsd:boolean\"/>\n");
		if (!context.suppressed("TpMachineQueryResponse","HasThorSpareProcess")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"HasThorSpareProcess\" type=\"xsd:boolean\"/>\n");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Type\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Cluster\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"OldIP\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"LogDirectory\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Path\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"MemThreshold\" type=\"xsd:int\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"DiskThreshold\" type=\"xsd:int\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"CpuThreshold\" type=\"xsd:int\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"MemThresholdType\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"DiskThresholdType\" type=\"xsd:string\"/>\n");
		if (!context.suppressed("TpMachineQueryResponse","PreflightProcessFilter")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"PreflightProcessFilter\" type=\"xsd:string\"/>\n");
		}
		if (!context.suppressed("TpMachineQueryResponse","EnableSNMP")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"EnableSNMP\" type=\"xsd:boolean\"/>\n");
		}
		if (!context.suppressed("TpMachineQueryResponse","AcceptLanguage")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"AcceptLanguage\" type=\"xsd:string\"/>\n");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"TpMachines\" type=\"tns:ArrayOfTpMachine\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	if (!(flags & 0x10)  || (flags & 0x100))
	{
		CTpMachine::getXsdDefinition(context, request, schema, added);
	}
	if (added.getValue("TpMachine") && added.getValue("ArrayOfTpMachine")==NULL) {
		schema.append("<xsd:complexType name=\"ArrayOfTpMachine\">\n");
		schema.append("<xsd:sequence>\n");
		schema.append("<xsd:element minOccurs=\"0\" maxOccurs=\"unbounded\" name=\"TpMachine\" type=\"tns:TpMachine\"/>\n");
		schema.append("</xsd:sequence>\n");
		schema.append("</xsd:complexType>\n");
		added.setValue("ArrayOfTpMachine",1);
	}
	return schema;
}

void CTpMachineQueryResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CTpMachineQueryResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
	info.addMinVersion("TpMachineQueryResponse","HasThorSpareProcess",1.15);
	info.addMinVersion("TpMachineQueryResponse","PreflightProcessFilter",1.13);
	info.addMinVersion("TpMachineQueryResponse","EnableSNMP",1.08);
	info.addMinVersion("TpMachineQueryResponse","AcceptLanguage",1.2);
	if (!added.getValue("TpMachine"))
	{
		added.setValue("TpMachine",1);
		CTpMachine::getMapInfo(info,added);
	}
}

StringBuffer &CTpMachineQueryResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("EnablePreflightInfo");
	
	form.appendf("  <tr><td><b>EnablePreflightInfo? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	if (!context.suppressed("TpMachineQueryResponse","HasThorSpareProcess")) {
		extfix.clear();
		if (prefix && *prefix)
			extfix.append(prefix).append(".");
		extfix.append("HasThorSpareProcess");
		
	form.appendf("  <tr><td><b>HasThorSpareProcess? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	}
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Type");
	form.appendf("  <tr><td><b>Type: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Cluster");
	form.appendf("  <tr><td><b>Cluster: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("OldIP");
	form.appendf("  <tr><td><b>OldIP: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("LogDirectory");
	form.appendf("  <tr><td><b>LogDirectory: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Path");
	form.appendf("  <tr><td><b>Path: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix) extfix.append(prefix).append(".");
		extfix.append("MemThreshold");
	form.appendf("  <tr><td><b>MemThreshold: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix) extfix.append(prefix).append(".");
		extfix.append("DiskThreshold");
	form.appendf("  <tr><td><b>DiskThreshold: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix) extfix.append(prefix).append(".");
		extfix.append("CpuThreshold");
	form.appendf("  <tr><td><b>CpuThreshold: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("MemThresholdType");
	form.appendf("  <tr><td><b>MemThresholdType: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("DiskThresholdType");
	form.appendf("  <tr><td><b>DiskThresholdType: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (!context.suppressed("TpMachineQueryResponse","PreflightProcessFilter")) {
		extfix.clear();
		if (prefix && *prefix)
			extfix.append(prefix).append(".");
		extfix.append("PreflightProcessFilter");
		form.appendf("  <tr><td><b>PreflightProcessFilter: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
		form.append("</td></tr>\n");
	}
	if (!context.suppressed("TpMachineQueryResponse","EnableSNMP")) {
		extfix.clear();
		if (prefix && *prefix)
			extfix.append(prefix).append(".");
		extfix.append("EnableSNMP");
		
	form.appendf("  <tr><td><b>EnableSNMP? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	}
	if (!context.suppressed("TpMachineQueryResponse","AcceptLanguage")) {
		extfix.clear();
		if (prefix && *prefix)
			extfix.append(prefix).append(".");
		extfix.append("AcceptLanguage");
		form.appendf("  <tr><td><b>AcceptLanguage: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
		form.append("</td></tr>\n");
	}
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("TpMachines");
	form.appendf("<tr><td><b>TpMachines: </b></td><td>");
	form.appendf("<table><tr><td><textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea></td>", extfix.str());
	form.append("</tr></table>");
	form.append("</td></tr>");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CTpMachineQueryResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CTpMachineQueryResponse::serialize(IRpcMessage& rpc_resp)
{
	IEspContext* ctx = rpc_resp.queryContext();
	double clientVer= ctx ? ctx->getClientVersion() : -1; /* no context gets everything */
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
		m_EnablePreflightInfo.marshall(rpc_resp, "EnablePreflightInfo", "", "", "");
		if ((clientVer==-1.0 || clientVer>=1.15))
			m_HasThorSpareProcess.marshall(rpc_resp, "HasThorSpareProcess", "", "", "");
		m_Type.marshall(rpc_resp, "Type", "", "", "");
		m_Cluster.marshall(rpc_resp, "Cluster", "", "", "");
		m_OldIP.marshall(rpc_resp, "OldIP", "", "", "");
		m_LogDirectory.marshall(rpc_resp, "LogDirectory", "", "", "");
		m_Path.marshall(rpc_resp, "Path", "", "", "");
		m_MemThreshold.marshall(rpc_resp, "MemThreshold", "", "", "");
		m_DiskThreshold.marshall(rpc_resp, "DiskThreshold", "", "", "");
		m_CpuThreshold.marshall(rpc_resp, "CpuThreshold", "", "", "");
		m_MemThresholdType.marshall(rpc_resp, "MemThresholdType", "", "", "");
		m_DiskThresholdType.marshall(rpc_resp, "DiskThresholdType", "", "", "");
		if ((clientVer==-1.0 || clientVer>=1.13))
			m_PreflightProcessFilter.marshall(rpc_resp, "PreflightProcessFilter", "", "", "");
		if ((clientVer==-1.0 || clientVer>=1.08))
			m_EnableSNMP.marshall(rpc_resp, "EnableSNMP", "", "", "");
		if ((clientVer==-1.0 || clientVer>=1.2))
			m_AcceptLanguage.marshall(rpc_resp, "AcceptLanguage", "", "", "");
		m_TpMachines.marshall(rpc_resp, "TpMachines", "TpMachine");
	}
}


void CTpMachineQueryResponse::copy(CTpMachineQueryResponse &from)
{
	m_EnablePreflightInfo.copy(from.m_EnablePreflightInfo);
	m_HasThorSpareProcess.copy(from.m_HasThorSpareProcess);
	m_Type.copy(from.m_Type);
	m_Cluster.copy(from.m_Cluster);
	m_OldIP.copy(from.m_OldIP);
	m_LogDirectory.copy(from.m_LogDirectory);
	m_Path.copy(from.m_Path);
	m_MemThreshold.copy(from.m_MemThreshold);
	m_DiskThreshold.copy(from.m_DiskThreshold);
	m_CpuThreshold.copy(from.m_CpuThreshold);
	m_MemThresholdType.copy(from.m_MemThresholdType);
	m_DiskThresholdType.copy(from.m_DiskThresholdType);
	m_PreflightProcessFilter.copy(from.m_PreflightProcessFilter);
	m_EnableSNMP.copy(from.m_EnableSNMP);
	m_AcceptLanguage.copy(from.m_AcceptLanguage);
	m_TpMachines.copy(from.m_TpMachines);
}


void CTpMachineQueryResponse::copy(IConstTpMachineQueryResponse &ifrom)
{
	setEnablePreflightInfo(ifrom.getEnablePreflightInfo());
	setHasThorSpareProcess(ifrom.getHasThorSpareProcess());
	setType(ifrom.getType());
	setCluster(ifrom.getCluster());
	setOldIP(ifrom.getOldIP());
	setLogDirectory(ifrom.getLogDirectory());
	setPath(ifrom.getPath());
	setMemThreshold(ifrom.getMemThreshold());
	setDiskThreshold(ifrom.getDiskThreshold());
	setCpuThreshold(ifrom.getCpuThreshold());
	setMemThresholdType(ifrom.getMemThresholdType());
	setDiskThresholdType(ifrom.getDiskThresholdType());
	setPreflightProcessFilter(ifrom.getPreflightProcessFilter());
	setEnableSNMP(ifrom.getEnableSNMP());
	setAcceptLanguage(ifrom.getAcceptLanguage());
	setTpMachines(ifrom.getTpMachines());
}


void CTpMachineQueryResponse::getAttributes(IProperties &attributes)
{
}


void CTpMachineQueryResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
		double clientVer = ctx ? ctx->getClientVersion() : -1;
		m_EnablePreflightInfo.toStr(ctx, buffer, "EnablePreflightInfo", "", true, "", "");
		if ((clientVer==-1.0 || clientVer>=1.15))
			m_HasThorSpareProcess.toStr(ctx, buffer, "HasThorSpareProcess", "", true, "", "");
		m_Type.toStr(ctx, buffer, "Type", "", true, "", "");
		m_Cluster.toStr(ctx, buffer, "Cluster", "", true, "", "");
		m_OldIP.toStr(ctx, buffer, "OldIP", "", true, "", "");
		m_LogDirectory.toStr(ctx, buffer, "LogDirectory", "", true, "", "");
		m_Path.toStr(ctx, buffer, "Path", "", true, "", "");
		m_MemThreshold.toStr(ctx, buffer, "MemThreshold", "", true, "", "");
		m_DiskThreshold.toStr(ctx, buffer, "DiskThreshold", "", true, "", "");
		m_CpuThreshold.toStr(ctx, buffer, "CpuThreshold", "", true, "", "");
		m_MemThresholdType.toStr(ctx, buffer, "MemThresholdType", "", true, "", "");
		m_DiskThresholdType.toStr(ctx, buffer, "DiskThresholdType", "", true, "", "");
		if ((clientVer==-1.0 || clientVer>=1.13))
			m_PreflightProcessFilter.toStr(ctx, buffer, "PreflightProcessFilter", "", true, "", "");
		if ((clientVer==-1.0 || clientVer>=1.08))
			m_EnableSNMP.toStr(ctx, buffer, "EnableSNMP", "", true, "", "");
		if ((clientVer==-1.0 || clientVer>=1.2))
			m_AcceptLanguage.toStr(ctx, buffer, "AcceptLanguage", "", true, "", "");
		m_TpMachines.toStr(ctx, buffer, "TpMachines", "TpMachine");
	}
}


void CTpMachineQueryResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CTpMachineQueryResponse::serializer(IEspContext* ctx, IConstTpMachineQueryResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<TpMachineQueryResponse>");
	double clientVer = ctx ? ctx->getClientVersion() : -1;
	// field EnablePreflightInfo
	{
		bool b = src.getEnablePreflightInfo();
		if (b)
			buffer.appendf("<EnablePreflightInfo>1</EnablePreflightInfo>");
	}
	// field HasThorSpareProcess
	if ((clientVer==-1.0 || clientVer>=1.15))
	{
		bool b = src.getHasThorSpareProcess();
		if (b)
			buffer.appendf("<HasThorSpareProcess>1</HasThorSpareProcess>");
	}
	// field Type
	{
		const char* s = src.getType();
		if (s && *s)
		{
			buffer.append("<Type>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Type>");
		}
	}
	// field Cluster
	{
		const char* s = src.getCluster();
		if (s && *s)
		{
			buffer.append("<Cluster>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Cluster>");
		}
	}
	// field OldIP
	{
		const char* s = src.getOldIP();
		if (s && *s)
		{
			buffer.append("<OldIP>");
			encodeUtf8XML(s,buffer);
			buffer.append("</OldIP>");
		}
	}
	// field LogDirectory
	{
		const char* s = src.getLogDirectory();
		if (s && *s)
		{
			buffer.append("<LogDirectory>");
			encodeUtf8XML(s,buffer);
			buffer.append("</LogDirectory>");
		}
	}
	// field Path
	{
		const char* s = src.getPath();
		if (s && *s)
		{
			buffer.append("<Path>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Path>");
		}
	}
	// field MemThreshold
	{
		int n = src.getMemThreshold();
		if (n)
			buffer.appendf("<MemThreshold>%d</MemThreshold>", n);
	}
	// field DiskThreshold
	{
		int n = src.getDiskThreshold();
		if (n)
			buffer.appendf("<DiskThreshold>%d</DiskThreshold>", n);
	}
	// field CpuThreshold
	{
		int n = src.getCpuThreshold();
		if (n)
			buffer.appendf("<CpuThreshold>%d</CpuThreshold>", n);
	}
	// field MemThresholdType
	{
		const char* s = src.getMemThresholdType();
		if (s && *s)
		{
			buffer.append("<MemThresholdType>");
			encodeUtf8XML(s,buffer);
			buffer.append("</MemThresholdType>");
		}
	}
	// field DiskThresholdType
	{
		const char* s = src.getDiskThresholdType();
		if (s && *s)
		{
			buffer.append("<DiskThresholdType>");
			encodeUtf8XML(s,buffer);
			buffer.append("</DiskThresholdType>");
		}
	}
	// field PreflightProcessFilter
	if ((clientVer==-1.0 || clientVer>=1.13))
	{
		const char* s = src.getPreflightProcessFilter();
		if (s && *s)
		{
			buffer.append("<PreflightProcessFilter>");
			encodeUtf8XML(s,buffer);
			buffer.append("</PreflightProcessFilter>");
		}
	}
	// field EnableSNMP
	if ((clientVer==-1.0 || clientVer>=1.08))
	{
		bool b = src.getEnableSNMP();
		if (b)
			buffer.appendf("<EnableSNMP>1</EnableSNMP>");
	}
	// field AcceptLanguage
	if ((clientVer==-1.0 || clientVer>=1.2))
	{
		const char* s = src.getAcceptLanguage();
		if (s && *s)
		{
			buffer.append("<AcceptLanguage>");
			encodeUtf8XML(s,buffer);
			buffer.append("</AcceptLanguage>");
		}
	}
	// field TpMachines
	{
		IArrayOf<IConstTpMachine>& v = src.getTpMachines();
		int size = v.length();
		if (size>0)
			buffer.append("<TpMachines>");
		for (int i=0;i<size;i++)
		{
			buffer.append("<Item>");
			CTpMachine::serializer(ctx,v.item(i),buffer,false);
			buffer.append("</Item>");
		}
		if (size>0)
			buffer.append("</TpMachines>");
	}
	if (keepRootTag)
		buffer.append("</TpMachineQueryResponse>");
}

bool CTpMachineQueryResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
		hasValue |= m_EnablePreflightInfo.unmarshall(rpc_request, "EnablePreflightInfo", basepath);
		hasValue |= m_HasThorSpareProcess.unmarshall(rpc_request, "HasThorSpareProcess", basepath);
		hasValue |= m_Type.unmarshall(rpc_request, "Type", basepath);
		hasValue |= m_Cluster.unmarshall(rpc_request, "Cluster", basepath);
		hasValue |= m_OldIP.unmarshall(rpc_request, "OldIP", basepath);
		hasValue |= m_LogDirectory.unmarshall(rpc_request, "LogDirectory", basepath);
		hasValue |= m_Path.unmarshall(rpc_request, "Path", basepath);
		hasValue |= m_MemThreshold.unmarshall(rpc_request, "MemThreshold", basepath);
		hasValue |= m_DiskThreshold.unmarshall(rpc_request, "DiskThreshold", basepath);
		hasValue |= m_CpuThreshold.unmarshall(rpc_request, "CpuThreshold", basepath);
		hasValue |= m_MemThresholdType.unmarshall(rpc_request, "MemThresholdType", basepath);
		hasValue |= m_DiskThresholdType.unmarshall(rpc_request, "DiskThresholdType", basepath);
		hasValue |= m_PreflightProcessFilter.unmarshall(rpc_request, "PreflightProcessFilter", basepath);
		hasValue |= m_EnableSNMP.unmarshall(rpc_request, "EnableSNMP", basepath);
		hasValue |= m_AcceptLanguage.unmarshall(rpc_request, "AcceptLanguage", basepath);
		hasValue |= m_TpMachines.unmarshall(rpc_request, "TpMachines", basepath);
	}
	return hasValue;
}

bool CTpMachineQueryResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_EnablePreflightInfo.unmarshall(ctx, soapval, "EnablePreflightInfo");
	hasValue |= m_HasThorSpareProcess.unmarshall(ctx, soapval, "HasThorSpareProcess");
	hasValue |= m_Type.unmarshall(ctx, soapval, "Type");
	hasValue |= m_Cluster.unmarshall(ctx, soapval, "Cluster");
	hasValue |= m_OldIP.unmarshall(ctx, soapval, "OldIP");
	hasValue |= m_LogDirectory.unmarshall(ctx, soapval, "LogDirectory");
	hasValue |= m_Path.unmarshall(ctx, soapval, "Path");
	hasValue |= m_MemThreshold.unmarshall(ctx, soapval, "MemThreshold");
	hasValue |= m_DiskThreshold.unmarshall(ctx, soapval, "DiskThreshold");
	hasValue |= m_CpuThreshold.unmarshall(ctx, soapval, "CpuThreshold");
	hasValue |= m_MemThresholdType.unmarshall(ctx, soapval, "MemThresholdType");
	hasValue |= m_DiskThresholdType.unmarshall(ctx, soapval, "DiskThresholdType");
	hasValue |= m_PreflightProcessFilter.unmarshall(ctx, soapval, "PreflightProcessFilter");
	hasValue |= m_EnableSNMP.unmarshall(ctx, soapval, "EnableSNMP");
	hasValue |= m_AcceptLanguage.unmarshall(ctx, soapval, "AcceptLanguage");
	hasValue |= m_TpMachines.unmarshall(ctx, soapval, "TpMachines");
	return hasValue;
}

bool CTpMachineQueryResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_EnablePreflightInfo.unmarshall(ctx, params, attachments, "EnablePreflightInfo", basepath);
	hasValue |= m_HasThorSpareProcess.unmarshall(ctx, params, attachments, "HasThorSpareProcess", basepath);
	hasValue |= m_Type.unmarshall(ctx, params, attachments, "Type", basepath);
	hasValue |= m_Cluster.unmarshall(ctx, params, attachments, "Cluster", basepath);
	hasValue |= m_OldIP.unmarshall(ctx, params, attachments, "OldIP", basepath);
	hasValue |= m_LogDirectory.unmarshall(ctx, params, attachments, "LogDirectory", basepath);
	hasValue |= m_Path.unmarshall(ctx, params, attachments, "Path", basepath);
	hasValue |= m_MemThreshold.unmarshall(ctx, params, attachments, "MemThreshold", basepath);
	hasValue |= m_DiskThreshold.unmarshall(ctx, params, attachments, "DiskThreshold", basepath);
	hasValue |= m_CpuThreshold.unmarshall(ctx, params, attachments, "CpuThreshold", basepath);
	hasValue |= m_MemThresholdType.unmarshall(ctx, params, attachments, "MemThresholdType", basepath);
	hasValue |= m_DiskThresholdType.unmarshall(ctx, params, attachments, "DiskThresholdType", basepath);
	hasValue |= m_PreflightProcessFilter.unmarshall(ctx, params, attachments, "PreflightProcessFilter", basepath);
	hasValue |= m_EnableSNMP.unmarshall(ctx, params, attachments, "EnableSNMP", basepath);
	hasValue |= m_AcceptLanguage.unmarshall(ctx, params, attachments, "AcceptLanguage", basepath);
	hasValue |= m_TpMachines.unmarshall(ctx, params, attachments, "TpMachines", basepath);
	return hasValue;
}

bool CTpMachineQueryResponse::getEnablePreflightInfo() { return m_EnablePreflightInfo;}
bool CTpMachineQueryResponse::getHasThorSpareProcess() { return m_HasThorSpareProcess;}
const char * CTpMachineQueryResponse::getType() { return m_Type.query();}
const char * CTpMachineQueryResponse::getCluster() { return m_Cluster.query();}
const char * CTpMachineQueryResponse::getOldIP() { return m_OldIP.query();}
const char * CTpMachineQueryResponse::getLogDirectory() { return m_LogDirectory.query();}
const char * CTpMachineQueryResponse::getPath() { return m_Path.query();}
int CTpMachineQueryResponse::getMemThreshold() { return m_MemThreshold;}
int CTpMachineQueryResponse::getDiskThreshold() { return m_DiskThreshold;}
int CTpMachineQueryResponse::getCpuThreshold() { return m_CpuThreshold;}
const char * CTpMachineQueryResponse::getMemThresholdType() { return m_MemThresholdType.query();}
const char * CTpMachineQueryResponse::getDiskThresholdType() { return m_DiskThresholdType.query();}
const char * CTpMachineQueryResponse::getPreflightProcessFilter() { return m_PreflightProcessFilter.query();}
bool CTpMachineQueryResponse::getEnableSNMP() { return m_EnableSNMP;}
const char * CTpMachineQueryResponse::getAcceptLanguage() { return m_AcceptLanguage.query();}
IArrayOf<IConstTpMachine> & CTpMachineQueryResponse::getTpMachines() { return (IArrayOf<IConstTpMachine> &) m_TpMachines; }
void CTpMachineQueryResponse::setEnablePreflightInfo(bool val){ m_EnablePreflightInfo=val; }
void CTpMachineQueryResponse::setHasThorSpareProcess(bool val){ m_HasThorSpareProcess=val; }
void CTpMachineQueryResponse::setType(const char * val){ m_Type.set(val); }
void CTpMachineQueryResponse::setCluster(const char * val){ m_Cluster.set(val); }
void CTpMachineQueryResponse::setOldIP(const char * val){ m_OldIP.set(val); }
void CTpMachineQueryResponse::setLogDirectory(const char * val){ m_LogDirectory.set(val); }
void CTpMachineQueryResponse::setPath(const char * val){ m_Path.set(val); }
void CTpMachineQueryResponse::setMemThreshold(int val){ m_MemThreshold=val; }
void CTpMachineQueryResponse::setDiskThreshold(int val){ m_DiskThreshold=val; }
void CTpMachineQueryResponse::setCpuThreshold(int val){ m_CpuThreshold=val; }
void CTpMachineQueryResponse::setMemThresholdType(const char * val){ m_MemThresholdType.set(val); }
void CTpMachineQueryResponse::setDiskThresholdType(const char * val){ m_DiskThresholdType.set(val); }
void CTpMachineQueryResponse::setPreflightProcessFilter(const char * val){ m_PreflightProcessFilter.set(val); }
void CTpMachineQueryResponse::setEnableSNMP(bool val){ m_EnableSNMP=val; }
void CTpMachineQueryResponse::setAcceptLanguage(const char * val){ m_AcceptLanguage.set(val); }
void CTpMachineQueryResponse::setTpMachines(IArrayOf<IEspTpMachine> &val)
{
	m_TpMachines->kill();
	IArrayOf<IConstTpMachine> &target = m_TpMachines.getValue();
	ForEachItemIn(idx, val)
	{
		IEspTpMachine &item = (val).item(idx);
		item.Link();
		target.append(item);
	}
}
void CTpMachineQueryResponse::setTpMachines(IArrayOf<IConstTpMachine> &val)
{
	m_TpMachines->kill();
	IArrayOf<IConstTpMachine> &target = m_TpMachines.getValue();
	ForEachItemIn(idx, val)
	{
		IConstTpMachine &item = val.item(idx);
		item.Link();
		target.append(item);
	}
}
extern "C"  IEspTpMachineQueryResponse *createTpMachineQueryResponse(const char *serv){return ((IEspTpMachineQueryResponse *)new CTpMachineQueryResponse(serv));}
extern "C"  IClientTpMachineQueryResponse *createClientTpMachineQueryResponse(const char *serv){return ((IClientTpMachineQueryResponse *)new CTpMachineQueryResponse(serv));}

//=======================================================
// class CTpMachineInfoRequest Implementation
//=======================================================

CTpMachineInfoRequest::CTpMachineInfoRequest(const char *serviceName, IRpcMessageBinding *init)
	: m_Name(nilIgnore),m_NetAddress(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("TpMachineInfoRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CTpMachineInfoRequest::CTpMachineInfoRequest(const char *serviceName, const char *bc)
	: m_Name(nilIgnore),m_NetAddress(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("TpMachineInfoRequest");
}

CTpMachineInfoRequest::CTpMachineInfoRequest(const char *serviceName, IRpcMessage* rpcmsg)
	: m_Name(nilIgnore),m_NetAddress(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("TpMachineInfoRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CTpMachineInfoRequest::CTpMachineInfoRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_Name(nilIgnore),m_NetAddress(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("TpMachineInfoRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CTpMachineInfoRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Name\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"NetAddress\" type=\"xsd:string\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CTpMachineInfoRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CTpMachineInfoRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CTpMachineInfoRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Name");
	form.appendf("  <tr><td><b>Name: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("NetAddress");
	form.appendf("  <tr><td><b>NetAddress: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CTpMachineInfoRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CTpMachineInfoRequest::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_Name.marshall(rpc_resp, "Name", "", "", "");
	m_NetAddress.marshall(rpc_resp, "NetAddress", "", "", "");
}


void CTpMachineInfoRequest::copy(CTpMachineInfoRequest &from)
{
	m_Name.copy(from.m_Name);
	m_NetAddress.copy(from.m_NetAddress);
}


void CTpMachineInfoRequest::copy(IConstTpMachineInfoRequest &ifrom)
{
	setName(ifrom.getName());
	setNetAddress(ifrom.getNetAddress());
}


void CTpMachineInfoRequest::getAttributes(IProperties &attributes)
{
}


void CTpMachineInfoRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_Name.toStr(ctx, buffer, "Name", "", true, "", "");
	m_NetAddress.toStr(ctx, buffer, "NetAddress", "", true, "", "");
}


void CTpMachineInfoRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CTpMachineInfoRequest::serializer(IEspContext* ctx, IConstTpMachineInfoRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<TpMachineInfoRequest>");
	// field Name
	{
		const char* s = src.getName();
		if (s && *s)
		{
			buffer.append("<Name>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Name>");
		}
	}
	// field NetAddress
	{
		const char* s = src.getNetAddress();
		if (s && *s)
		{
			buffer.append("<NetAddress>");
			encodeUtf8XML(s,buffer);
			buffer.append("</NetAddress>");
		}
	}
	if (keepRootTag)
		buffer.append("</TpMachineInfoRequest>");
}

bool CTpMachineInfoRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_Name.unmarshall(rpc_request, "Name", basepath);
	hasValue |= m_NetAddress.unmarshall(rpc_request, "NetAddress", basepath);
	return hasValue;
}

bool CTpMachineInfoRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Name.unmarshall(ctx, soapval, "Name");
	hasValue |= m_NetAddress.unmarshall(ctx, soapval, "NetAddress");
	return hasValue;
}

bool CTpMachineInfoRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Name.unmarshall(ctx, params, attachments, "Name", basepath);
	hasValue |= m_NetAddress.unmarshall(ctx, params, attachments, "NetAddress", basepath);
	return hasValue;
}

const char * CTpMachineInfoRequest::getName() { return m_Name.query();}
const char * CTpMachineInfoRequest::getNetAddress() { return m_NetAddress.query();}
void CTpMachineInfoRequest::setName(const char * val){ m_Name.set(val); }
void CTpMachineInfoRequest::setNetAddress(const char * val){ m_NetAddress.set(val); }
extern "C"  IEspTpMachineInfoRequest *createTpMachineInfoRequest(const char *serv){return ((IEspTpMachineInfoRequest *)new CTpMachineInfoRequest(serv));}
extern "C"  IClientTpMachineInfoRequest *createClientTpMachineInfoRequest(const char *serv){return ((IClientTpMachineInfoRequest *)new CTpMachineInfoRequest(serv));}

//=======================================================
// class CTpMachineInfoResponse Implementation
//=======================================================

CTpMachineInfoResponse::CTpMachineInfoResponse(const char *serviceName, IRpcMessageBinding *init)
	: m_MachineInfo(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("TpMachineInfoResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CTpMachineInfoResponse::CTpMachineInfoResponse(const char *serviceName, const char *bc)
	: m_MachineInfo(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("TpMachineInfoResponse");
}

CTpMachineInfoResponse::CTpMachineInfoResponse(const char *serviceName, IRpcMessage* rpcmsg)
	: m_MachineInfo(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("TpMachineInfoResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CTpMachineInfoResponse::CTpMachineInfoResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_MachineInfo(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("TpMachineInfoResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CTpMachineInfoResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		schema.append("<xsd:element name=\"Exceptions\" type=\"tns:ArrayOfEspException\" minOccurs=\"0\" maxOccurs=\"1\"/>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"MachineInfo\" type=\"tns:TpMachine\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	if (!(flags & 0x10)  || (flags & 0x100))
	{
		CTpMachine::getXsdDefinition(context, request, schema, added);
	}
	return schema;
}

void CTpMachineInfoResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CTpMachineInfoResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
	if (!added.getValue("TpMachine"))
	{
		added.setValue("TpMachine",1);
		CTpMachine::getMapInfo(info,added);
	}
}

StringBuffer &CTpMachineInfoResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("MachineInfo");
	form.append("<tr>").append("<td><b>MachineInfo: </b></td><td><hr/>");
	CTpMachine::getHtmlForm(context, request, serv, method, form, false, extfix.str());
	form.append("<hr/></td></tr>");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CTpMachineInfoResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CTpMachineInfoResponse::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
		m_MachineInfo.marshall(rpc_resp, "MachineInfo", "", "", "");
	}
}


void CTpMachineInfoResponse::copy(CTpMachineInfoResponse &from)
{
	m_MachineInfo.copy(from.m_MachineInfo);
}


void CTpMachineInfoResponse::copy(IConstTpMachineInfoResponse &ifrom)
{
	setMachineInfo(ifrom.getMachineInfo());
}


void CTpMachineInfoResponse::getAttributes(IProperties &attributes)
{
}


void CTpMachineInfoResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
		m_MachineInfo.toStr(ctx, buffer, "MachineInfo", "", false, "", "");
	}
}


void CTpMachineInfoResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CTpMachineInfoResponse::serializer(IEspContext* ctx, IConstTpMachineInfoResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<TpMachineInfoResponse>");
	// field MachineInfo
	{
		StringBuffer tmp;
		CTpMachine::serializer(ctx,src.getMachineInfo(), tmp, false);
		if (tmp.length()>0)
			buffer.appendf("<MachineInfo>%s</MachineInfo>",tmp.str());
	}
	if (keepRootTag)
		buffer.append("</TpMachineInfoResponse>");
}

bool CTpMachineInfoResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
		hasValue |= m_MachineInfo.unmarshall(rpc_request, "MachineInfo", basepath);
	}
	return hasValue;
}

bool CTpMachineInfoResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_MachineInfo.unmarshall(ctx, soapval, "MachineInfo");
	return hasValue;
}

bool CTpMachineInfoResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_MachineInfo.unmarshall(ctx, params, attachments, "MachineInfo", basepath);
	return hasValue;
}

IConstTpMachine & CTpMachineInfoResponse::getMachineInfo() { return (IConstTpMachine &) m_MachineInfo.getValue();}
IEspTpMachine & CTpMachineInfoResponse::updateMachineInfo(){ return (IEspTpMachine &) m_MachineInfo.getValue(); }
void CTpMachineInfoResponse::setMachineInfo(IConstTpMachine &ifrom){ m_MachineInfo.copy(ifrom); }
extern "C"  IEspTpMachineInfoResponse *createTpMachineInfoResponse(const char *serv){return ((IEspTpMachineInfoResponse *)new CTpMachineInfoResponse(serv));}
extern "C"  IClientTpMachineInfoResponse *createClientTpMachineInfoResponse(const char *serv){return ((IClientTpMachineInfoResponse *)new CTpMachineInfoResponse(serv));}

//=======================================================
// class CTpServiceQueryRequest Implementation
//=======================================================

CTpServiceQueryRequest::CTpServiceQueryRequest(const char *serviceName, IRpcMessageBinding *init)
	: m_Type(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("TpServiceQueryRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CTpServiceQueryRequest::CTpServiceQueryRequest(const char *serviceName, const char *bc)
	: m_Type(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("TpServiceQueryRequest");
}

CTpServiceQueryRequest::CTpServiceQueryRequest(const char *serviceName, IRpcMessage* rpcmsg)
	: m_Type(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("TpServiceQueryRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CTpServiceQueryRequest::CTpServiceQueryRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_Type(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("TpServiceQueryRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CTpServiceQueryRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Type\" type=\"xsd:string\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CTpServiceQueryRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CTpServiceQueryRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CTpServiceQueryRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Type");
	form.appendf("  <tr><td><b>Type: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CTpServiceQueryRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CTpServiceQueryRequest::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_Type.marshall(rpc_resp, "Type", "", "", "");
}


void CTpServiceQueryRequest::copy(CTpServiceQueryRequest &from)
{
	m_Type.copy(from.m_Type);
}


void CTpServiceQueryRequest::copy(IConstTpServiceQueryRequest &ifrom)
{
	setType(ifrom.getType());
}


void CTpServiceQueryRequest::getAttributes(IProperties &attributes)
{
}


void CTpServiceQueryRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_Type.toStr(ctx, buffer, "Type", "", true, "", "");
}


void CTpServiceQueryRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CTpServiceQueryRequest::serializer(IEspContext* ctx, IConstTpServiceQueryRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<TpServiceQueryRequest>");
	// field Type
	{
		const char* s = src.getType();
		if (s && *s)
		{
			buffer.append("<Type>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Type>");
		}
	}
	if (keepRootTag)
		buffer.append("</TpServiceQueryRequest>");
}

bool CTpServiceQueryRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_Type.unmarshall(rpc_request, "Type", basepath);
	return hasValue;
}

bool CTpServiceQueryRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Type.unmarshall(ctx, soapval, "Type");
	return hasValue;
}

bool CTpServiceQueryRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Type.unmarshall(ctx, params, attachments, "Type", basepath);
	return hasValue;
}

const char * CTpServiceQueryRequest::getType() { return m_Type.query();}
void CTpServiceQueryRequest::setType(const char * val){ m_Type.set(val); }
extern "C"  IEspTpServiceQueryRequest *createTpServiceQueryRequest(const char *serv){return ((IEspTpServiceQueryRequest *)new CTpServiceQueryRequest(serv));}
extern "C"  IClientTpServiceQueryRequest *createClientTpServiceQueryRequest(const char *serv){return ((IClientTpServiceQueryRequest *)new CTpServiceQueryRequest(serv));}

//=======================================================
// class CTpServiceQueryResponse Implementation
//=======================================================

CTpServiceQueryResponse::CTpServiceQueryResponse(const char *serviceName, IRpcMessageBinding *init)
	: m_MemThreshold(nilRemove),m_DiskThreshold(nilRemove),m_CpuThreshold(nilRemove),m_EncapsulatedSystem(nilRemove),m_EnableSNMP(nilRemove),m_PreflightProcessFilter(nilRemove),m_AcceptLanguage(nilRemove),m_MemThresholdType(nilRemove),m_DiskThresholdType(nilRemove),m_ServiceList(serviceName, nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("TpServiceQueryResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CTpServiceQueryResponse::CTpServiceQueryResponse(const char *serviceName, const char *bc)
	: m_MemThreshold(nilRemove),m_DiskThreshold(nilRemove),m_CpuThreshold(nilRemove),m_EncapsulatedSystem(nilRemove),m_EnableSNMP(nilRemove),m_PreflightProcessFilter(nilRemove),m_AcceptLanguage(nilRemove),m_MemThresholdType(nilRemove),m_DiskThresholdType(nilRemove),m_ServiceList(serviceName, nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("TpServiceQueryResponse");
}

CTpServiceQueryResponse::CTpServiceQueryResponse(const char *serviceName, IRpcMessage* rpcmsg)
	: m_MemThreshold(nilRemove),m_DiskThreshold(nilRemove),m_CpuThreshold(nilRemove),m_EncapsulatedSystem(nilRemove),m_EnableSNMP(nilRemove),m_PreflightProcessFilter(nilRemove),m_AcceptLanguage(nilRemove),m_MemThresholdType(nilRemove),m_DiskThresholdType(nilRemove),m_ServiceList(serviceName, nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("TpServiceQueryResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CTpServiceQueryResponse::CTpServiceQueryResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_MemThreshold(nilRemove),m_DiskThreshold(nilRemove),m_CpuThreshold(nilRemove),m_EncapsulatedSystem(nilRemove),m_EnableSNMP(nilRemove),m_PreflightProcessFilter(nilRemove),m_AcceptLanguage(nilRemove),m_MemThresholdType(nilRemove),m_DiskThresholdType(nilRemove),m_ServiceList(serviceName, nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("TpServiceQueryResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CTpServiceQueryResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		schema.append("<xsd:element name=\"Exceptions\" type=\"tns:ArrayOfEspException\" minOccurs=\"0\" maxOccurs=\"1\"/>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"MemThreshold\" type=\"xsd:int\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"DiskThreshold\" type=\"xsd:int\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"CpuThreshold\" type=\"xsd:int\"/>\n");
		if (!context.suppressed("TpServiceQueryResponse","EncapsulatedSystem")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"EncapsulatedSystem\" type=\"xsd:boolean\"/>\n");
		}
		if (!context.suppressed("TpServiceQueryResponse","EnableSNMP")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"EnableSNMP\" type=\"xsd:boolean\"/>\n");
		}
		if (!context.suppressed("TpServiceQueryResponse","PreflightProcessFilter")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"PreflightProcessFilter\" type=\"xsd:string\"/>\n");
		}
		if (!context.suppressed("TpServiceQueryResponse","AcceptLanguage")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"AcceptLanguage\" type=\"xsd:string\"/>\n");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"MemThresholdType\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"DiskThresholdType\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"ServiceList\" type=\"tns:TpServices\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	if (!(flags & 0x10)  || (flags & 0x100))
	{
		CTpServices::getXsdDefinition(context, request, schema, added);
	}
	return schema;
}

void CTpServiceQueryResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CTpServiceQueryResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
	info.addMinVersion("TpServiceQueryResponse","EncapsulatedSystem",1.07);
	info.addMinVersion("TpServiceQueryResponse","EnableSNMP",1.08);
	info.addMinVersion("TpServiceQueryResponse","PreflightProcessFilter",1.13);
	info.addMinVersion("TpServiceQueryResponse","AcceptLanguage",1.2);
	if (!added.getValue("TpServices"))
	{
		added.setValue("TpServices",1);
		CTpServices::getMapInfo(info,added);
	}
}

StringBuffer &CTpServiceQueryResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix) extfix.append(prefix).append(".");
		extfix.append("MemThreshold");
	form.appendf("  <tr><td><b>MemThreshold: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix) extfix.append(prefix).append(".");
		extfix.append("DiskThreshold");
	form.appendf("  <tr><td><b>DiskThreshold: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix) extfix.append(prefix).append(".");
		extfix.append("CpuThreshold");
	form.appendf("  <tr><td><b>CpuThreshold: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
	form.append("</td></tr>\n");
	if (!context.suppressed("TpServiceQueryResponse","EncapsulatedSystem")) {
		extfix.clear();
		if (prefix && *prefix)
			extfix.append(prefix).append(".");
		extfix.append("EncapsulatedSystem");
		
	form.appendf("  <tr><td><b>EncapsulatedSystem? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	}
	if (!context.suppressed("TpServiceQueryResponse","EnableSNMP")) {
		extfix.clear();
		if (prefix && *prefix)
			extfix.append(prefix).append(".");
		extfix.append("EnableSNMP");
		
	form.appendf("  <tr><td><b>EnableSNMP? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	}
	if (!context.suppressed("TpServiceQueryResponse","PreflightProcessFilter")) {
		extfix.clear();
		if (prefix && *prefix)
			extfix.append(prefix).append(".");
		extfix.append("PreflightProcessFilter");
		form.appendf("  <tr><td><b>PreflightProcessFilter: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
		form.append("</td></tr>\n");
	}
	if (!context.suppressed("TpServiceQueryResponse","AcceptLanguage")) {
		extfix.clear();
		if (prefix && *prefix)
			extfix.append(prefix).append(".");
		extfix.append("AcceptLanguage");
		form.appendf("  <tr><td><b>AcceptLanguage: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
		form.append("</td></tr>\n");
	}
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("MemThresholdType");
	form.appendf("  <tr><td><b>MemThresholdType: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("DiskThresholdType");
	form.appendf("  <tr><td><b>DiskThresholdType: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("ServiceList");
	form.append("<tr>").append("<td><b>ServiceList: </b></td><td><hr/>");
	CTpServices::getHtmlForm(context, request, serv, method, form, false, extfix.str());
	form.append("<hr/></td></tr>");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CTpServiceQueryResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CTpServiceQueryResponse::serialize(IRpcMessage& rpc_resp)
{
	IEspContext* ctx = rpc_resp.queryContext();
	double clientVer= ctx ? ctx->getClientVersion() : -1; /* no context gets everything */
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
		m_MemThreshold.marshall(rpc_resp, "MemThreshold", "", "", "");
		m_DiskThreshold.marshall(rpc_resp, "DiskThreshold", "", "", "");
		m_CpuThreshold.marshall(rpc_resp, "CpuThreshold", "", "", "");
		if ((clientVer==-1.0 || clientVer>=1.07))
			m_EncapsulatedSystem.marshall(rpc_resp, "EncapsulatedSystem", "", "", "");
		if ((clientVer==-1.0 || clientVer>=1.08))
			m_EnableSNMP.marshall(rpc_resp, "EnableSNMP", "", "", "");
		if ((clientVer==-1.0 || clientVer>=1.13))
			m_PreflightProcessFilter.marshall(rpc_resp, "PreflightProcessFilter", "", "", "");
		if ((clientVer==-1.0 || clientVer>=1.2))
			m_AcceptLanguage.marshall(rpc_resp, "AcceptLanguage", "", "", "");
		m_MemThresholdType.marshall(rpc_resp, "MemThresholdType", "", "", "");
		m_DiskThresholdType.marshall(rpc_resp, "DiskThresholdType", "", "", "");
		m_ServiceList.marshall(rpc_resp, "ServiceList", "", "", "");
	}
}


void CTpServiceQueryResponse::copy(CTpServiceQueryResponse &from)
{
	m_MemThreshold.copy(from.m_MemThreshold);
	m_DiskThreshold.copy(from.m_DiskThreshold);
	m_CpuThreshold.copy(from.m_CpuThreshold);
	m_EncapsulatedSystem.copy(from.m_EncapsulatedSystem);
	m_EnableSNMP.copy(from.m_EnableSNMP);
	m_PreflightProcessFilter.copy(from.m_PreflightProcessFilter);
	m_AcceptLanguage.copy(from.m_AcceptLanguage);
	m_MemThresholdType.copy(from.m_MemThresholdType);
	m_DiskThresholdType.copy(from.m_DiskThresholdType);
	m_ServiceList.copy(from.m_ServiceList);
}


void CTpServiceQueryResponse::copy(IConstTpServiceQueryResponse &ifrom)
{
	setMemThreshold(ifrom.getMemThreshold());
	setDiskThreshold(ifrom.getDiskThreshold());
	setCpuThreshold(ifrom.getCpuThreshold());
	setEncapsulatedSystem(ifrom.getEncapsulatedSystem());
	setEnableSNMP(ifrom.getEnableSNMP());
	setPreflightProcessFilter(ifrom.getPreflightProcessFilter());
	setAcceptLanguage(ifrom.getAcceptLanguage());
	setMemThresholdType(ifrom.getMemThresholdType());
	setDiskThresholdType(ifrom.getDiskThresholdType());
	setServiceList(ifrom.getServiceList());
}


void CTpServiceQueryResponse::getAttributes(IProperties &attributes)
{
}


void CTpServiceQueryResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
		double clientVer = ctx ? ctx->getClientVersion() : -1;
		m_MemThreshold.toStr(ctx, buffer, "MemThreshold", "", true, "", "");
		m_DiskThreshold.toStr(ctx, buffer, "DiskThreshold", "", true, "", "");
		m_CpuThreshold.toStr(ctx, buffer, "CpuThreshold", "", true, "", "");
		if ((clientVer==-1.0 || clientVer>=1.07))
			m_EncapsulatedSystem.toStr(ctx, buffer, "EncapsulatedSystem", "", true, "", "");
		if ((clientVer==-1.0 || clientVer>=1.08))
			m_EnableSNMP.toStr(ctx, buffer, "EnableSNMP", "", true, "", "");
		if ((clientVer==-1.0 || clientVer>=1.13))
			m_PreflightProcessFilter.toStr(ctx, buffer, "PreflightProcessFilter", "", true, "", "");
		if ((clientVer==-1.0 || clientVer>=1.2))
			m_AcceptLanguage.toStr(ctx, buffer, "AcceptLanguage", "", true, "", "");
		m_MemThresholdType.toStr(ctx, buffer, "MemThresholdType", "", true, "", "");
		m_DiskThresholdType.toStr(ctx, buffer, "DiskThresholdType", "", true, "", "");
		m_ServiceList.toStr(ctx, buffer, "ServiceList", "", false, "", "");
	}
}


void CTpServiceQueryResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CTpServiceQueryResponse::serializer(IEspContext* ctx, IConstTpServiceQueryResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<TpServiceQueryResponse>");
	double clientVer = ctx ? ctx->getClientVersion() : -1;
	// field MemThreshold
	{
		int n = src.getMemThreshold();
		if (n)
			buffer.appendf("<MemThreshold>%d</MemThreshold>", n);
	}
	// field DiskThreshold
	{
		int n = src.getDiskThreshold();
		if (n)
			buffer.appendf("<DiskThreshold>%d</DiskThreshold>", n);
	}
	// field CpuThreshold
	{
		int n = src.getCpuThreshold();
		if (n)
			buffer.appendf("<CpuThreshold>%d</CpuThreshold>", n);
	}
	// field EncapsulatedSystem
	if ((clientVer==-1.0 || clientVer>=1.07))
	{
		bool b = src.getEncapsulatedSystem();
		if (b)
			buffer.appendf("<EncapsulatedSystem>1</EncapsulatedSystem>");
	}
	// field EnableSNMP
	if ((clientVer==-1.0 || clientVer>=1.08))
	{
		bool b = src.getEnableSNMP();
		if (b)
			buffer.appendf("<EnableSNMP>1</EnableSNMP>");
	}
	// field PreflightProcessFilter
	if ((clientVer==-1.0 || clientVer>=1.13))
	{
		const char* s = src.getPreflightProcessFilter();
		if (s && *s)
		{
			buffer.append("<PreflightProcessFilter>");
			encodeUtf8XML(s,buffer);
			buffer.append("</PreflightProcessFilter>");
		}
	}
	// field AcceptLanguage
	if ((clientVer==-1.0 || clientVer>=1.2))
	{
		const char* s = src.getAcceptLanguage();
		if (s && *s)
		{
			buffer.append("<AcceptLanguage>");
			encodeUtf8XML(s,buffer);
			buffer.append("</AcceptLanguage>");
		}
	}
	// field MemThresholdType
	{
		const char* s = src.getMemThresholdType();
		if (s && *s)
		{
			buffer.append("<MemThresholdType>");
			encodeUtf8XML(s,buffer);
			buffer.append("</MemThresholdType>");
		}
	}
	// field DiskThresholdType
	{
		const char* s = src.getDiskThresholdType();
		if (s && *s)
		{
			buffer.append("<DiskThresholdType>");
			encodeUtf8XML(s,buffer);
			buffer.append("</DiskThresholdType>");
		}
	}
	// field ServiceList
	{
		StringBuffer tmp;
		CTpServices::serializer(ctx,src.getServiceList(), tmp, false);
		if (tmp.length()>0)
			buffer.appendf("<ServiceList>%s</ServiceList>",tmp.str());
	}
	if (keepRootTag)
		buffer.append("</TpServiceQueryResponse>");
}

bool CTpServiceQueryResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
		hasValue |= m_MemThreshold.unmarshall(rpc_request, "MemThreshold", basepath);
		hasValue |= m_DiskThreshold.unmarshall(rpc_request, "DiskThreshold", basepath);
		hasValue |= m_CpuThreshold.unmarshall(rpc_request, "CpuThreshold", basepath);
		hasValue |= m_EncapsulatedSystem.unmarshall(rpc_request, "EncapsulatedSystem", basepath);
		hasValue |= m_EnableSNMP.unmarshall(rpc_request, "EnableSNMP", basepath);
		hasValue |= m_PreflightProcessFilter.unmarshall(rpc_request, "PreflightProcessFilter", basepath);
		hasValue |= m_AcceptLanguage.unmarshall(rpc_request, "AcceptLanguage", basepath);
		hasValue |= m_MemThresholdType.unmarshall(rpc_request, "MemThresholdType", basepath);
		hasValue |= m_DiskThresholdType.unmarshall(rpc_request, "DiskThresholdType", basepath);
		hasValue |= m_ServiceList.unmarshall(rpc_request, "ServiceList", basepath);
	}
	return hasValue;
}

bool CTpServiceQueryResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_MemThreshold.unmarshall(ctx, soapval, "MemThreshold");
	hasValue |= m_DiskThreshold.unmarshall(ctx, soapval, "DiskThreshold");
	hasValue |= m_CpuThreshold.unmarshall(ctx, soapval, "CpuThreshold");
	hasValue |= m_EncapsulatedSystem.unmarshall(ctx, soapval, "EncapsulatedSystem");
	hasValue |= m_EnableSNMP.unmarshall(ctx, soapval, "EnableSNMP");
	hasValue |= m_PreflightProcessFilter.unmarshall(ctx, soapval, "PreflightProcessFilter");
	hasValue |= m_AcceptLanguage.unmarshall(ctx, soapval, "AcceptLanguage");
	hasValue |= m_MemThresholdType.unmarshall(ctx, soapval, "MemThresholdType");
	hasValue |= m_DiskThresholdType.unmarshall(ctx, soapval, "DiskThresholdType");
	hasValue |= m_ServiceList.unmarshall(ctx, soapval, "ServiceList");
	return hasValue;
}

bool CTpServiceQueryResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_MemThreshold.unmarshall(ctx, params, attachments, "MemThreshold", basepath);
	hasValue |= m_DiskThreshold.unmarshall(ctx, params, attachments, "DiskThreshold", basepath);
	hasValue |= m_CpuThreshold.unmarshall(ctx, params, attachments, "CpuThreshold", basepath);
	hasValue |= m_EncapsulatedSystem.unmarshall(ctx, params, attachments, "EncapsulatedSystem", basepath);
	hasValue |= m_EnableSNMP.unmarshall(ctx, params, attachments, "EnableSNMP", basepath);
	hasValue |= m_PreflightProcessFilter.unmarshall(ctx, params, attachments, "PreflightProcessFilter", basepath);
	hasValue |= m_AcceptLanguage.unmarshall(ctx, params, attachments, "AcceptLanguage", basepath);
	hasValue |= m_MemThresholdType.unmarshall(ctx, params, attachments, "MemThresholdType", basepath);
	hasValue |= m_DiskThresholdType.unmarshall(ctx, params, attachments, "DiskThresholdType", basepath);
	hasValue |= m_ServiceList.unmarshall(ctx, params, attachments, "ServiceList", basepath);
	return hasValue;
}

bool CTpServiceQueryResponse::getMemThreshold_isNull(){return m_MemThreshold.is_nil();}
int CTpServiceQueryResponse::getMemThreshold() { return m_MemThreshold;}
bool CTpServiceQueryResponse::getDiskThreshold_isNull(){return m_DiskThreshold.is_nil();}
int CTpServiceQueryResponse::getDiskThreshold() { return m_DiskThreshold;}
bool CTpServiceQueryResponse::getCpuThreshold_isNull(){return m_CpuThreshold.is_nil();}
int CTpServiceQueryResponse::getCpuThreshold() { return m_CpuThreshold;}
bool CTpServiceQueryResponse::getEncapsulatedSystem_isNull(){return m_EncapsulatedSystem.is_nil();}
bool CTpServiceQueryResponse::getEncapsulatedSystem() { return m_EncapsulatedSystem;}
bool CTpServiceQueryResponse::getEnableSNMP_isNull(){return m_EnableSNMP.is_nil();}
bool CTpServiceQueryResponse::getEnableSNMP() { return m_EnableSNMP;}
const char * CTpServiceQueryResponse::getPreflightProcessFilter() { return m_PreflightProcessFilter.query();}
const char * CTpServiceQueryResponse::getAcceptLanguage() { return m_AcceptLanguage.query();}
const char * CTpServiceQueryResponse::getMemThresholdType() { return m_MemThresholdType.query();}
const char * CTpServiceQueryResponse::getDiskThresholdType() { return m_DiskThresholdType.query();}
IConstTpServices & CTpServiceQueryResponse::getServiceList() { return (IConstTpServices &) m_ServiceList.getValue();}
void CTpServiceQueryResponse::setMemThreshold_null(){ m_MemThreshold.Nil(); }void CTpServiceQueryResponse::setMemThreshold(int val){ m_MemThreshold=val; }
void CTpServiceQueryResponse::setDiskThreshold_null(){ m_DiskThreshold.Nil(); }void CTpServiceQueryResponse::setDiskThreshold(int val){ m_DiskThreshold=val; }
void CTpServiceQueryResponse::setCpuThreshold_null(){ m_CpuThreshold.Nil(); }void CTpServiceQueryResponse::setCpuThreshold(int val){ m_CpuThreshold=val; }
void CTpServiceQueryResponse::setEncapsulatedSystem_null(){ m_EncapsulatedSystem.Nil(); }void CTpServiceQueryResponse::setEncapsulatedSystem(bool val){ m_EncapsulatedSystem=val; }
void CTpServiceQueryResponse::setEnableSNMP_null(){ m_EnableSNMP.Nil(); }void CTpServiceQueryResponse::setEnableSNMP(bool val){ m_EnableSNMP=val; }
void CTpServiceQueryResponse::setPreflightProcessFilter(const char * val){ m_PreflightProcessFilter.set(val); }
void CTpServiceQueryResponse::setAcceptLanguage(const char * val){ m_AcceptLanguage.set(val); }
void CTpServiceQueryResponse::setMemThresholdType(const char * val){ m_MemThresholdType.set(val); }
void CTpServiceQueryResponse::setDiskThresholdType(const char * val){ m_DiskThresholdType.set(val); }
IEspTpServices & CTpServiceQueryResponse::updateServiceList(){ return (IEspTpServices &) m_ServiceList.getValue(); }
void CTpServiceQueryResponse::setServiceList(IConstTpServices &ifrom){ m_ServiceList.copy(ifrom); }
extern "C"  IEspTpServiceQueryResponse *createTpServiceQueryResponse(const char *serv){return ((IEspTpServiceQueryResponse *)new CTpServiceQueryResponse(serv));}
extern "C"  IClientTpServiceQueryResponse *createClientTpServiceQueryResponse(const char *serv){return ((IClientTpServiceQueryResponse *)new CTpServiceQueryResponse(serv));}

//=======================================================
// class CTpSetMachineStatusRequest Implementation
//=======================================================

CTpSetMachineStatusRequest::CTpSetMachineStatusRequest(const char *serviceName, IRpcMessageBinding *init)
	: m_MachinePath(nilIgnore),m_StatusValue(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("TpSetMachineStatusRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CTpSetMachineStatusRequest::CTpSetMachineStatusRequest(const char *serviceName, const char *bc)
	: m_MachinePath(nilIgnore),m_StatusValue(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("TpSetMachineStatusRequest");
}

CTpSetMachineStatusRequest::CTpSetMachineStatusRequest(const char *serviceName, IRpcMessage* rpcmsg)
	: m_MachinePath(nilIgnore),m_StatusValue(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("TpSetMachineStatusRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CTpSetMachineStatusRequest::CTpSetMachineStatusRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_MachinePath(nilIgnore),m_StatusValue(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("TpSetMachineStatusRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CTpSetMachineStatusRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"MachinePath\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"StatusValue\" type=\"xsd:string\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CTpSetMachineStatusRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CTpSetMachineStatusRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CTpSetMachineStatusRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("MachinePath");
	form.appendf("  <tr><td><b>MachinePath: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("StatusValue");
	form.appendf("  <tr><td><b>StatusValue: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CTpSetMachineStatusRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CTpSetMachineStatusRequest::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_MachinePath.marshall(rpc_resp, "MachinePath", "", "", "");
	m_StatusValue.marshall(rpc_resp, "StatusValue", "", "", "");
}


void CTpSetMachineStatusRequest::copy(CTpSetMachineStatusRequest &from)
{
	m_MachinePath.copy(from.m_MachinePath);
	m_StatusValue.copy(from.m_StatusValue);
}


void CTpSetMachineStatusRequest::copy(IConstTpSetMachineStatusRequest &ifrom)
{
	setMachinePath(ifrom.getMachinePath());
	setStatusValue(ifrom.getStatusValue());
}


void CTpSetMachineStatusRequest::getAttributes(IProperties &attributes)
{
}


void CTpSetMachineStatusRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_MachinePath.toStr(ctx, buffer, "MachinePath", "", true, "", "");
	m_StatusValue.toStr(ctx, buffer, "StatusValue", "", true, "", "");
}


void CTpSetMachineStatusRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CTpSetMachineStatusRequest::serializer(IEspContext* ctx, IConstTpSetMachineStatusRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<TpSetMachineStatusRequest>");
	// field MachinePath
	{
		const char* s = src.getMachinePath();
		if (s && *s)
		{
			buffer.append("<MachinePath>");
			encodeUtf8XML(s,buffer);
			buffer.append("</MachinePath>");
		}
	}
	// field StatusValue
	{
		const char* s = src.getStatusValue();
		if (s && *s)
		{
			buffer.append("<StatusValue>");
			encodeUtf8XML(s,buffer);
			buffer.append("</StatusValue>");
		}
	}
	if (keepRootTag)
		buffer.append("</TpSetMachineStatusRequest>");
}

bool CTpSetMachineStatusRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_MachinePath.unmarshall(rpc_request, "MachinePath", basepath);
	hasValue |= m_StatusValue.unmarshall(rpc_request, "StatusValue", basepath);
	return hasValue;
}

bool CTpSetMachineStatusRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_MachinePath.unmarshall(ctx, soapval, "MachinePath");
	hasValue |= m_StatusValue.unmarshall(ctx, soapval, "StatusValue");
	return hasValue;
}

bool CTpSetMachineStatusRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_MachinePath.unmarshall(ctx, params, attachments, "MachinePath", basepath);
	hasValue |= m_StatusValue.unmarshall(ctx, params, attachments, "StatusValue", basepath);
	return hasValue;
}

const char * CTpSetMachineStatusRequest::getMachinePath() { return m_MachinePath.query();}
const char * CTpSetMachineStatusRequest::getStatusValue() { return m_StatusValue.query();}
void CTpSetMachineStatusRequest::setMachinePath(const char * val){ m_MachinePath.set(val); }
void CTpSetMachineStatusRequest::setStatusValue(const char * val){ m_StatusValue.set(val); }
extern "C"  IEspTpSetMachineStatusRequest *createTpSetMachineStatusRequest(const char *serv){return ((IEspTpSetMachineStatusRequest *)new CTpSetMachineStatusRequest(serv));}
extern "C"  IClientTpSetMachineStatusRequest *createClientTpSetMachineStatusRequest(const char *serv){return ((IClientTpSetMachineStatusRequest *)new CTpSetMachineStatusRequest(serv));}

//=======================================================
// class CTpSetMachineStatusResponse Implementation
//=======================================================

CTpSetMachineStatusResponse::CTpSetMachineStatusResponse(const char *serviceName, IRpcMessageBinding *init)
	: m_TpSetMachineStatusResult(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("TpSetMachineStatusResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CTpSetMachineStatusResponse::CTpSetMachineStatusResponse(const char *serviceName, const char *bc)
	: m_TpSetMachineStatusResult(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("TpSetMachineStatusResponse");
}

CTpSetMachineStatusResponse::CTpSetMachineStatusResponse(const char *serviceName, IRpcMessage* rpcmsg)
	: m_TpSetMachineStatusResult(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("TpSetMachineStatusResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CTpSetMachineStatusResponse::CTpSetMachineStatusResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_TpSetMachineStatusResult(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("TpSetMachineStatusResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CTpSetMachineStatusResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		schema.append("<xsd:element name=\"Exceptions\" type=\"tns:ArrayOfEspException\" minOccurs=\"0\" maxOccurs=\"1\"/>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"TpSetMachineStatusResult\" type=\"xsd:boolean\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CTpSetMachineStatusResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CTpSetMachineStatusResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CTpSetMachineStatusResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("TpSetMachineStatusResult");
	
	form.appendf("  <tr><td><b>TpSetMachineStatusResult? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CTpSetMachineStatusResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CTpSetMachineStatusResponse::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
		m_TpSetMachineStatusResult.marshall(rpc_resp, "TpSetMachineStatusResult", "", "", "");
	}
}


void CTpSetMachineStatusResponse::copy(CTpSetMachineStatusResponse &from)
{
	m_TpSetMachineStatusResult.copy(from.m_TpSetMachineStatusResult);
}


void CTpSetMachineStatusResponse::copy(IConstTpSetMachineStatusResponse &ifrom)
{
	setTpSetMachineStatusResult(ifrom.getTpSetMachineStatusResult());
}


void CTpSetMachineStatusResponse::getAttributes(IProperties &attributes)
{
}


void CTpSetMachineStatusResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
		m_TpSetMachineStatusResult.toStr(ctx, buffer, "TpSetMachineStatusResult", "", true, "", "");
	}
}


void CTpSetMachineStatusResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CTpSetMachineStatusResponse::serializer(IEspContext* ctx, IConstTpSetMachineStatusResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<TpSetMachineStatusResponse>");
	// field TpSetMachineStatusResult
	{
		bool b = src.getTpSetMachineStatusResult();
		if (b)
			buffer.appendf("<TpSetMachineStatusResult>1</TpSetMachineStatusResult>");
	}
	if (keepRootTag)
		buffer.append("</TpSetMachineStatusResponse>");
}

bool CTpSetMachineStatusResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
		hasValue |= m_TpSetMachineStatusResult.unmarshall(rpc_request, "TpSetMachineStatusResult", basepath);
	}
	return hasValue;
}

bool CTpSetMachineStatusResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_TpSetMachineStatusResult.unmarshall(ctx, soapval, "TpSetMachineStatusResult");
	return hasValue;
}

bool CTpSetMachineStatusResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_TpSetMachineStatusResult.unmarshall(ctx, params, attachments, "TpSetMachineStatusResult", basepath);
	return hasValue;
}

bool CTpSetMachineStatusResponse::getTpSetMachineStatusResult() { return m_TpSetMachineStatusResult;}
void CTpSetMachineStatusResponse::setTpSetMachineStatusResult(bool val){ m_TpSetMachineStatusResult=val; }
extern "C"  IEspTpSetMachineStatusResponse *createTpSetMachineStatusResponse(const char *serv){return ((IEspTpSetMachineStatusResponse *)new CTpSetMachineStatusResponse(serv));}
extern "C"  IClientTpSetMachineStatusResponse *createClientTpSetMachineStatusResponse(const char *serv){return ((IClientTpSetMachineStatusResponse *)new CTpSetMachineStatusResponse(serv));}

//=======================================================
// class CTpSwapNodeRequest Implementation
//=======================================================

CTpSwapNodeRequest::CTpSwapNodeRequest(const char *serviceName, IRpcMessageBinding *init)
	: m_Cluster(nilIgnore),m_OldIP(nilIgnore),m_NewIP(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("TpSwapNodeRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CTpSwapNodeRequest::CTpSwapNodeRequest(const char *serviceName, const char *bc)
	: m_Cluster(nilIgnore),m_OldIP(nilIgnore),m_NewIP(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("TpSwapNodeRequest");
}

CTpSwapNodeRequest::CTpSwapNodeRequest(const char *serviceName, IRpcMessage* rpcmsg)
	: m_Cluster(nilIgnore),m_OldIP(nilIgnore),m_NewIP(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("TpSwapNodeRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CTpSwapNodeRequest::CTpSwapNodeRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_Cluster(nilIgnore),m_OldIP(nilIgnore),m_NewIP(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("TpSwapNodeRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CTpSwapNodeRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Cluster\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"OldIP\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"NewIP\" type=\"xsd:string\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CTpSwapNodeRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CTpSwapNodeRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CTpSwapNodeRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Cluster");
	form.appendf("  <tr><td><b>Cluster: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("OldIP");
	form.appendf("  <tr><td><b>OldIP: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("NewIP");
	form.appendf("  <tr><td><b>NewIP: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CTpSwapNodeRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CTpSwapNodeRequest::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_Cluster.marshall(rpc_resp, "Cluster", "", "", "");
	m_OldIP.marshall(rpc_resp, "OldIP", "", "", "");
	m_NewIP.marshall(rpc_resp, "NewIP", "", "", "");
}


void CTpSwapNodeRequest::copy(CTpSwapNodeRequest &from)
{
	m_Cluster.copy(from.m_Cluster);
	m_OldIP.copy(from.m_OldIP);
	m_NewIP.copy(from.m_NewIP);
}


void CTpSwapNodeRequest::copy(IConstTpSwapNodeRequest &ifrom)
{
	setCluster(ifrom.getCluster());
	setOldIP(ifrom.getOldIP());
	setNewIP(ifrom.getNewIP());
}


void CTpSwapNodeRequest::getAttributes(IProperties &attributes)
{
}


void CTpSwapNodeRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_Cluster.toStr(ctx, buffer, "Cluster", "", true, "", "");
	m_OldIP.toStr(ctx, buffer, "OldIP", "", true, "", "");
	m_NewIP.toStr(ctx, buffer, "NewIP", "", true, "", "");
}


void CTpSwapNodeRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CTpSwapNodeRequest::serializer(IEspContext* ctx, IConstTpSwapNodeRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<TpSwapNodeRequest>");
	// field Cluster
	{
		const char* s = src.getCluster();
		if (s && *s)
		{
			buffer.append("<Cluster>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Cluster>");
		}
	}
	// field OldIP
	{
		const char* s = src.getOldIP();
		if (s && *s)
		{
			buffer.append("<OldIP>");
			encodeUtf8XML(s,buffer);
			buffer.append("</OldIP>");
		}
	}
	// field NewIP
	{
		const char* s = src.getNewIP();
		if (s && *s)
		{
			buffer.append("<NewIP>");
			encodeUtf8XML(s,buffer);
			buffer.append("</NewIP>");
		}
	}
	if (keepRootTag)
		buffer.append("</TpSwapNodeRequest>");
}

bool CTpSwapNodeRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_Cluster.unmarshall(rpc_request, "Cluster", basepath);
	hasValue |= m_OldIP.unmarshall(rpc_request, "OldIP", basepath);
	hasValue |= m_NewIP.unmarshall(rpc_request, "NewIP", basepath);
	return hasValue;
}

bool CTpSwapNodeRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Cluster.unmarshall(ctx, soapval, "Cluster");
	hasValue |= m_OldIP.unmarshall(ctx, soapval, "OldIP");
	hasValue |= m_NewIP.unmarshall(ctx, soapval, "NewIP");
	return hasValue;
}

bool CTpSwapNodeRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Cluster.unmarshall(ctx, params, attachments, "Cluster", basepath);
	hasValue |= m_OldIP.unmarshall(ctx, params, attachments, "OldIP", basepath);
	hasValue |= m_NewIP.unmarshall(ctx, params, attachments, "NewIP", basepath);
	return hasValue;
}

const char * CTpSwapNodeRequest::getCluster() { return m_Cluster.query();}
const char * CTpSwapNodeRequest::getOldIP() { return m_OldIP.query();}
const char * CTpSwapNodeRequest::getNewIP() { return m_NewIP.query();}
void CTpSwapNodeRequest::setCluster(const char * val){ m_Cluster.set(val); }
void CTpSwapNodeRequest::setOldIP(const char * val){ m_OldIP.set(val); }
void CTpSwapNodeRequest::setNewIP(const char * val){ m_NewIP.set(val); }
extern "C"  IEspTpSwapNodeRequest *createTpSwapNodeRequest(const char *serv){return ((IEspTpSwapNodeRequest *)new CTpSwapNodeRequest(serv));}
extern "C"  IClientTpSwapNodeRequest *createClientTpSwapNodeRequest(const char *serv){return ((IClientTpSwapNodeRequest *)new CTpSwapNodeRequest(serv));}

//=======================================================
// class CTpSwapNodeResponse Implementation
//=======================================================

CTpSwapNodeResponse::CTpSwapNodeResponse(const char *serviceName, IRpcMessageBinding *init)
	: m_TpSwapNodeResult(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("TpSwapNodeResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CTpSwapNodeResponse::CTpSwapNodeResponse(const char *serviceName, const char *bc)
	: m_TpSwapNodeResult(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("TpSwapNodeResponse");
}

CTpSwapNodeResponse::CTpSwapNodeResponse(const char *serviceName, IRpcMessage* rpcmsg)
	: m_TpSwapNodeResult(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("TpSwapNodeResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CTpSwapNodeResponse::CTpSwapNodeResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_TpSwapNodeResult(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("TpSwapNodeResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CTpSwapNodeResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		schema.append("<xsd:element name=\"Exceptions\" type=\"tns:ArrayOfEspException\" minOccurs=\"0\" maxOccurs=\"1\"/>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"TpSwapNodeResult\" type=\"xsd:boolean\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CTpSwapNodeResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CTpSwapNodeResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CTpSwapNodeResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("TpSwapNodeResult");
	
	form.appendf("  <tr><td><b>TpSwapNodeResult? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CTpSwapNodeResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CTpSwapNodeResponse::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
		m_TpSwapNodeResult.marshall(rpc_resp, "TpSwapNodeResult", "", "", "");
	}
}


void CTpSwapNodeResponse::copy(CTpSwapNodeResponse &from)
{
	m_TpSwapNodeResult.copy(from.m_TpSwapNodeResult);
}


void CTpSwapNodeResponse::copy(IConstTpSwapNodeResponse &ifrom)
{
	setTpSwapNodeResult(ifrom.getTpSwapNodeResult());
}


void CTpSwapNodeResponse::getAttributes(IProperties &attributes)
{
}


void CTpSwapNodeResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
		m_TpSwapNodeResult.toStr(ctx, buffer, "TpSwapNodeResult", "", true, "", "");
	}
}


void CTpSwapNodeResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CTpSwapNodeResponse::serializer(IEspContext* ctx, IConstTpSwapNodeResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<TpSwapNodeResponse>");
	// field TpSwapNodeResult
	{
		bool b = src.getTpSwapNodeResult();
		if (b)
			buffer.appendf("<TpSwapNodeResult>1</TpSwapNodeResult>");
	}
	if (keepRootTag)
		buffer.append("</TpSwapNodeResponse>");
}

bool CTpSwapNodeResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
		hasValue |= m_TpSwapNodeResult.unmarshall(rpc_request, "TpSwapNodeResult", basepath);
	}
	return hasValue;
}

bool CTpSwapNodeResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_TpSwapNodeResult.unmarshall(ctx, soapval, "TpSwapNodeResult");
	return hasValue;
}

bool CTpSwapNodeResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_TpSwapNodeResult.unmarshall(ctx, params, attachments, "TpSwapNodeResult", basepath);
	return hasValue;
}

bool CTpSwapNodeResponse::getTpSwapNodeResult() { return m_TpSwapNodeResult;}
void CTpSwapNodeResponse::setTpSwapNodeResult(bool val){ m_TpSwapNodeResult=val; }
extern "C"  IEspTpSwapNodeResponse *createTpSwapNodeResponse(const char *serv){return ((IEspTpSwapNodeResponse *)new CTpSwapNodeResponse(serv));}
extern "C"  IClientTpSwapNodeResponse *createClientTpSwapNodeResponse(const char *serv){return ((IClientTpSwapNodeResponse *)new CTpSwapNodeResponse(serv));}

//=======================================================
// class CTpXMLFileRequest Implementation
//=======================================================

CTpXMLFileRequest::CTpXMLFileRequest(const char *serviceName, IRpcMessageBinding *init)
	: m_Name(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("TpXMLFileRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CTpXMLFileRequest::CTpXMLFileRequest(const char *serviceName, const char *bc)
	: m_Name(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("TpXMLFileRequest");
}

CTpXMLFileRequest::CTpXMLFileRequest(const char *serviceName, IRpcMessage* rpcmsg)
	: m_Name(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("TpXMLFileRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CTpXMLFileRequest::CTpXMLFileRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_Name(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("TpXMLFileRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CTpXMLFileRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Name\" type=\"xsd:string\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CTpXMLFileRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CTpXMLFileRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CTpXMLFileRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Name");
	form.appendf("  <tr><td><b>Name: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CTpXMLFileRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CTpXMLFileRequest::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_Name.marshall(rpc_resp, "Name", "", "", "");
}


void CTpXMLFileRequest::copy(CTpXMLFileRequest &from)
{
	m_Name.copy(from.m_Name);
}


void CTpXMLFileRequest::copy(IConstTpXMLFileRequest &ifrom)
{
	setName(ifrom.getName());
}


void CTpXMLFileRequest::getAttributes(IProperties &attributes)
{
}


void CTpXMLFileRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_Name.toStr(ctx, buffer, "Name", "", true, "", "");
}


void CTpXMLFileRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CTpXMLFileRequest::serializer(IEspContext* ctx, IConstTpXMLFileRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<TpXMLFileRequest>");
	// field Name
	{
		const char* s = src.getName();
		if (s && *s)
		{
			buffer.append("<Name>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Name>");
		}
	}
	if (keepRootTag)
		buffer.append("</TpXMLFileRequest>");
}

bool CTpXMLFileRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_Name.unmarshall(rpc_request, "Name", basepath);
	return hasValue;
}

bool CTpXMLFileRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Name.unmarshall(ctx, soapval, "Name");
	return hasValue;
}

bool CTpXMLFileRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Name.unmarshall(ctx, params, attachments, "Name", basepath);
	return hasValue;
}

const char * CTpXMLFileRequest::getName() { return m_Name.query();}
void CTpXMLFileRequest::setName(const char * val){ m_Name.set(val); }
extern "C"  IEspTpXMLFileRequest *createTpXMLFileRequest(const char *serv){return ((IEspTpXMLFileRequest *)new CTpXMLFileRequest(serv));}
extern "C"  IClientTpXMLFileRequest *createClientTpXMLFileRequest(const char *serv){return ((IClientTpXMLFileRequest *)new CTpXMLFileRequest(serv));}

//=======================================================
// class CTpXMLFileResponse Implementation
//=======================================================

CTpXMLFileResponse::CTpXMLFileResponse(const char *serviceName, IRpcMessageBinding *init)
	: m_thefile(nilIgnore),m_thefile_mimetype("application/octet-stream")
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("TpXMLFileResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CTpXMLFileResponse::CTpXMLFileResponse(const char *serviceName, const char *bc)
	: m_thefile(nilIgnore), m_thefile_mimetype("application/octet-stream")
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("TpXMLFileResponse");
}

CTpXMLFileResponse::CTpXMLFileResponse(const char *serviceName, IRpcMessage* rpcmsg)
	: m_thefile(nilIgnore), m_thefile_mimetype("application/octet-stream")
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("TpXMLFileResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CTpXMLFileResponse::CTpXMLFileResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_thefile(nilIgnore), m_thefile_mimetype("application/octet-stream")
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("TpXMLFileResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CTpXMLFileResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		schema.append("<xsd:element name=\"Exceptions\" type=\"tns:ArrayOfEspException\" minOccurs=\"0\" maxOccurs=\"1\"/>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"thefile\" type=\"xsd:base64Binary\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CTpXMLFileResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CTpXMLFileResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CTpXMLFileResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("thefile");
	form.appendf("  <tr><td><b>thefile: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CTpXMLFileResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CTpXMLFileResponse::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
		m_thefile.marshall(rpc_resp, "thefile", "", "", "");
	}
}


void CTpXMLFileResponse::copy(CTpXMLFileResponse &from)
{
	m_thefile.copy(from.m_thefile);
}


void CTpXMLFileResponse::copy(IConstTpXMLFileResponse &ifrom)
{
	setThefile(ifrom.getThefile());
}


void CTpXMLFileResponse::getAttributes(IProperties &attributes)
{
}


void CTpXMLFileResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
		m_thefile.toStr(ctx, buffer, "thefile", "", true, "", "");
	}
}


void CTpXMLFileResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CTpXMLFileResponse::serializer(IEspContext* ctx, IConstTpXMLFileResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<TpXMLFileResponse>");
	// field thefile
	{
		StringBuffer tmp;
		JBASE64_Encode(src.getThefile().toByteArray(), src.getThefile().length(), tmp);
		if (tmp.length()>0)
			buffer.appendf("<thefile>%s</thefile>",tmp.str());
	}
	if (keepRootTag)
		buffer.append("</TpXMLFileResponse>");
}

void CTpXMLFileResponse::appendContent(IEspContext* ctx, MemoryBuffer& buffer, StringBuffer &mimetype)
{
	buffer.clear().append(m_thefile.getValue());
	mimetype.set(m_thefile_mimetype.str());
}

bool CTpXMLFileResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
		hasValue |= m_thefile.unmarshall(rpc_request, "thefile", basepath);
	}
	return hasValue;
}

bool CTpXMLFileResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_thefile.unmarshall(ctx, soapval, "thefile");
	return hasValue;
}

bool CTpXMLFileResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_thefile.unmarshall(ctx, params, attachments, "thefile", basepath);
	return hasValue;
}

const char *CTpXMLFileResponse::getThefile_mimetype(){ return m_thefile_mimetype.str(); }
const MemoryBuffer & CTpXMLFileResponse::getThefile() { return m_thefile.getValue();}
void CTpXMLFileResponse::setThefile_mimetype(const char *  val){ m_thefile_mimetype.set(val); }
void CTpXMLFileResponse::setThefile(const MemoryBuffer & val){ m_thefile->clear().append(val); }
extern "C"  IEspTpXMLFileResponse *createTpXMLFileResponse(const char *serv){return ((IEspTpXMLFileResponse *)new CTpXMLFileResponse(serv));}
extern "C"  IClientTpXMLFileResponse *createClientTpXMLFileResponse(const char *serv){return ((IClientTpXMLFileResponse *)new CTpXMLFileResponse(serv));}

//=======================================================
// class CTpLogFileRequest Implementation
//=======================================================

CTpLogFileRequest::CTpLogFileRequest(const char *serviceName, IRpcMessageBinding *init)
	: m_Name(nilRemove),m_Type(nilRemove),m_LastHours(nilRemove),m_StartDate(nilRemove),m_EndDate(nilRemove),m_FirstRows(nilRemove),m_LastRows(nilRemove),m_FilterType(0, nilRemove,false),m_Reversely(0, nilRemove,false),m_Zip(0, nilRemove,false),m_PageNumber(0, nilRemove,false),m_LoadData(0, nilRemove,false)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("TpLogFileRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CTpLogFileRequest::CTpLogFileRequest(const char *serviceName, const char *bc)
	: m_Name(nilRemove),m_Type(nilRemove),m_LastHours(nilRemove),m_StartDate(nilRemove),m_EndDate(nilRemove),m_FirstRows(nilRemove),m_LastRows(nilRemove),m_FilterType(0, nilRemove,false),m_Reversely(0, nilRemove,false),m_Zip(0, nilRemove,false),m_PageNumber(0, nilRemove,false),m_LoadData(0, nilRemove,false)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("TpLogFileRequest");
}

CTpLogFileRequest::CTpLogFileRequest(const char *serviceName, IRpcMessage* rpcmsg)
	: m_Name(nilRemove),m_Type(nilRemove),m_LastHours(nilRemove),m_StartDate(nilRemove),m_EndDate(nilRemove),m_FirstRows(nilRemove),m_LastRows(nilRemove),m_FilterType(0, nilRemove,false),m_Reversely(0, nilRemove,false),m_Zip(0, nilRemove,false),m_PageNumber(0, nilRemove,false),m_LoadData(0, nilRemove,false)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("TpLogFileRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CTpLogFileRequest::CTpLogFileRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_Name(nilRemove),m_Type(nilRemove),m_LastHours(nilRemove),m_StartDate(nilRemove),m_EndDate(nilRemove),m_FirstRows(nilRemove),m_LastRows(nilRemove),m_FilterType(0, nilRemove,false),m_Reversely(0, nilRemove,false),m_Zip(0, nilRemove,false),m_PageNumber(0, nilRemove,false),m_LoadData(0, nilRemove,false)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("TpLogFileRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CTpLogFileRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Name\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Type\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"LastHours\" type=\"xsd:int\"/>\n");
		if (!context.suppressed("TpLogFileRequest","StartDate")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"StartDate\" type=\"xsd:string\"/>\n");
		}
		if (!context.suppressed("TpLogFileRequest","EndDate")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"EndDate\" type=\"xsd:string\"/>\n");
		}
		if (!context.suppressed("TpLogFileRequest","FirstRows")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"FirstRows\" type=\"xsd:int\"/>\n");
		}
		if (!context.suppressed("TpLogFileRequest","LastRows")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"LastRows\" type=\"xsd:int\"/>\n");
		}
		if (!context.suppressed("TpLogFileRequest","FilterType")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"FilterType\" type=\"xsd:int\"/>\n");
		}
		if (!context.suppressed("TpLogFileRequest","Reversely")) {
			schema.append("<xsd:element minOccurs=\"0\" default=\"false\" name=\"Reversely\" type=\"xsd:boolean\"/>\n");
		}
		if (!context.suppressed("TpLogFileRequest","Zip")) {
			schema.append("<xsd:element minOccurs=\"0\" default=\"false\" name=\"Zip\" type=\"xsd:boolean\"/>\n");
		}
		if (!context.suppressed("TpLogFileRequest","PageNumber")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"PageNumber\" type=\"xsd:int\"/>\n");
		}
		if (!context.suppressed("TpLogFileRequest","LoadData")) {
			schema.append("<xsd:element minOccurs=\"0\" default=\"false\" name=\"LoadData\" type=\"xsd:boolean\"/>\n");
		}
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CTpLogFileRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CTpLogFileRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
	info.addMinVersion("TpLogFileRequest","StartDate",1.05);
	info.addMinVersion("TpLogFileRequest","EndDate",1.05);
	info.addMinVersion("TpLogFileRequest","FirstRows",1.05);
	info.addMinVersion("TpLogFileRequest","LastRows",1.05);
	info.addMinVersion("TpLogFileRequest","FilterType",1.05);
	info.addMinVersion("TpLogFileRequest","Reversely",1.05);
	info.addMinVersion("TpLogFileRequest","Zip",1.05);
	info.addMinVersion("TpLogFileRequest","PageNumber",1.05);
	info.addMinVersion("TpLogFileRequest","LoadData",1.05);
}

StringBuffer &CTpLogFileRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Name");
	form.appendf("  <tr><td><b>Name: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Type");
	form.appendf("  <tr><td><b>Type: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix) extfix.append(prefix).append(".");
		extfix.append("LastHours");
	form.appendf("  <tr><td><b>LastHours: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
	form.append("</td></tr>\n");
	if (!context.suppressed("TpLogFileRequest","StartDate")) {
		extfix.clear();
		if (prefix && *prefix)
			extfix.append(prefix).append(".");
		extfix.append("StartDate");
		form.appendf("  <tr><td><b>StartDate: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
		form.append("</td></tr>\n");
	}
	if (!context.suppressed("TpLogFileRequest","EndDate")) {
		extfix.clear();
		if (prefix && *prefix)
			extfix.append(prefix).append(".");
		extfix.append("EndDate");
		form.appendf("  <tr><td><b>EndDate: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
		form.append("</td></tr>\n");
	}
	if (!context.suppressed("TpLogFileRequest","FirstRows")) {
		extfix.clear();
		if (prefix && *prefix) extfix.append(prefix).append(".");
			extfix.append("FirstRows");
		form.appendf("  <tr><td><b>FirstRows: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
		form.append("</td></tr>\n");
	}
	if (!context.suppressed("TpLogFileRequest","LastRows")) {
		extfix.clear();
		if (prefix && *prefix) extfix.append(prefix).append(".");
			extfix.append("LastRows");
		form.appendf("  <tr><td><b>LastRows: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
		form.append("</td></tr>\n");
	}
	if (!context.suppressed("TpLogFileRequest","FilterType")) {
		extfix.clear();
		if (prefix && *prefix) extfix.append(prefix).append(".");
			extfix.append("FilterType");
		form.appendf("  <tr><td><b>FilterType: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
		form.append("</td></tr>\n");
	}
	if (!context.suppressed("TpLogFileRequest","Reversely")) {
		extfix.clear();
		if (prefix && *prefix)
			extfix.append(prefix).append(".");
		extfix.append("Reversely");
		
	form.appendf("  <tr><td><b>Reversely? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	}
	if (!context.suppressed("TpLogFileRequest","Zip")) {
		extfix.clear();
		if (prefix && *prefix)
			extfix.append(prefix).append(".");
		extfix.append("Zip");
		
	form.appendf("  <tr><td><b>Zip? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	}
	if (!context.suppressed("TpLogFileRequest","PageNumber")) {
		extfix.clear();
		if (prefix && *prefix) extfix.append(prefix).append(".");
			extfix.append("PageNumber");
		form.appendf("  <tr><td><b>PageNumber: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
		form.append("</td></tr>\n");
	}
	if (!context.suppressed("TpLogFileRequest","LoadData")) {
		extfix.clear();
		if (prefix && *prefix)
			extfix.append(prefix).append(".");
		extfix.append("LoadData");
		
	form.appendf("  <tr><td><b>LoadData? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	}
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CTpLogFileRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CTpLogFileRequest::serialize(IRpcMessage& rpc_resp)
{
	IEspContext* ctx = rpc_resp.queryContext();
	double clientVer= ctx ? ctx->getClientVersion() : -1; /* no context gets everything */
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_Name.marshall(rpc_resp, "Name", "", "", "");
	m_Type.marshall(rpc_resp, "Type", "", "", "");
	m_LastHours.marshall(rpc_resp, "LastHours", "", "", "");
	if ((clientVer==-1.0 || clientVer>=1.05))
		m_StartDate.marshall(rpc_resp, "StartDate", "", "", "");
	if ((clientVer==-1.0 || clientVer>=1.05))
		m_EndDate.marshall(rpc_resp, "EndDate", "", "", "");
	if ((clientVer==-1.0 || clientVer>=1.05))
		m_FirstRows.marshall(rpc_resp, "FirstRows", "", "", "");
	if ((clientVer==-1.0 || clientVer>=1.05))
		m_LastRows.marshall(rpc_resp, "LastRows", "", "", "");
	if ((clientVer==-1.0 || clientVer>=1.05))
		m_FilterType.marshall(rpc_resp, "FilterType", "", "", "");
	if ((clientVer==-1.0 || clientVer>=1.05))
		m_Reversely.marshall(rpc_resp, "Reversely", "", "", "");
	if ((clientVer==-1.0 || clientVer>=1.05))
		m_Zip.marshall(rpc_resp, "Zip", "", "", "");
	if ((clientVer==-1.0 || clientVer>=1.05))
		m_PageNumber.marshall(rpc_resp, "PageNumber", "", "", "");
	if ((clientVer==-1.0 || clientVer>=1.05))
		m_LoadData.marshall(rpc_resp, "LoadData", "", "", "");
}


void CTpLogFileRequest::copy(CTpLogFileRequest &from)
{
	m_Name.copy(from.m_Name);
	m_Type.copy(from.m_Type);
	m_LastHours.copy(from.m_LastHours);
	m_StartDate.copy(from.m_StartDate);
	m_EndDate.copy(from.m_EndDate);
	m_FirstRows.copy(from.m_FirstRows);
	m_LastRows.copy(from.m_LastRows);
	m_FilterType.copy(from.m_FilterType);
	m_Reversely.copy(from.m_Reversely);
	m_Zip.copy(from.m_Zip);
	m_PageNumber.copy(from.m_PageNumber);
	m_LoadData.copy(from.m_LoadData);
}


void CTpLogFileRequest::copy(IConstTpLogFileRequest &ifrom)
{
	setName(ifrom.getName());
	setType(ifrom.getType());
	setLastHours(ifrom.getLastHours());
	setStartDate(ifrom.getStartDate());
	setEndDate(ifrom.getEndDate());
	setFirstRows(ifrom.getFirstRows());
	setLastRows(ifrom.getLastRows());
	setFilterType(ifrom.getFilterType());
	setReversely(ifrom.getReversely());
	setZip(ifrom.getZip());
	setPageNumber(ifrom.getPageNumber());
	setLoadData(ifrom.getLoadData());
}


void CTpLogFileRequest::getAttributes(IProperties &attributes)
{
}


void CTpLogFileRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	double clientVer = ctx ? ctx->getClientVersion() : -1;
	m_Name.toStr(ctx, buffer, "Name", "", true, "", "");
	m_Type.toStr(ctx, buffer, "Type", "", true, "", "");
	m_LastHours.toStr(ctx, buffer, "LastHours", "", true, "", "");
	if ((clientVer==-1.0 || clientVer>=1.05))
		m_StartDate.toStr(ctx, buffer, "StartDate", "", true, "", "");
	if ((clientVer==-1.0 || clientVer>=1.05))
		m_EndDate.toStr(ctx, buffer, "EndDate", "", true, "", "");
	if ((clientVer==-1.0 || clientVer>=1.05))
		m_FirstRows.toStr(ctx, buffer, "FirstRows", "", true, "", "");
	if ((clientVer==-1.0 || clientVer>=1.05))
		m_LastRows.toStr(ctx, buffer, "LastRows", "", true, "", "");
	if ((clientVer==-1.0 || clientVer>=1.05))
		m_FilterType.toStr(ctx, buffer, "FilterType", "", true, "", "");
	if ((clientVer==-1.0 || clientVer>=1.05))
		m_Reversely.toStr(ctx, buffer, "Reversely", "", true, "", "");
	if ((clientVer==-1.0 || clientVer>=1.05))
		m_Zip.toStr(ctx, buffer, "Zip", "", true, "", "");
	if ((clientVer==-1.0 || clientVer>=1.05))
		m_PageNumber.toStr(ctx, buffer, "PageNumber", "", true, "", "");
	if ((clientVer==-1.0 || clientVer>=1.05))
		m_LoadData.toStr(ctx, buffer, "LoadData", "", true, "", "");
}


void CTpLogFileRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CTpLogFileRequest::serializer(IEspContext* ctx, IConstTpLogFileRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<TpLogFileRequest>");
	double clientVer = ctx ? ctx->getClientVersion() : -1;
	// field Name
	{
		const char* s = src.getName();
		if (s && *s)
		{
			buffer.append("<Name>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Name>");
		}
	}
	// field Type
	{
		const char* s = src.getType();
		if (s && *s)
		{
			buffer.append("<Type>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Type>");
		}
	}
	// field LastHours
	{
		int n = src.getLastHours();
		if (n)
			buffer.appendf("<LastHours>%d</LastHours>", n);
	}
	// field StartDate
	if ((clientVer==-1.0 || clientVer>=1.05))
	{
		const char* s = src.getStartDate();
		if (s && *s)
		{
			buffer.append("<StartDate>");
			encodeUtf8XML(s,buffer);
			buffer.append("</StartDate>");
		}
	}
	// field EndDate
	if ((clientVer==-1.0 || clientVer>=1.05))
	{
		const char* s = src.getEndDate();
		if (s && *s)
		{
			buffer.append("<EndDate>");
			encodeUtf8XML(s,buffer);
			buffer.append("</EndDate>");
		}
	}
	// field FirstRows
	if ((clientVer==-1.0 || clientVer>=1.05))
	{
		int n = src.getFirstRows();
		if (n)
			buffer.appendf("<FirstRows>%d</FirstRows>", n);
	}
	// field LastRows
	if ((clientVer==-1.0 || clientVer>=1.05))
	{
		int n = src.getLastRows();
		if (n)
			buffer.appendf("<LastRows>%d</LastRows>", n);
	}
	// field FilterType
	if ((clientVer==-1.0 || clientVer>=1.05))
	{
		int n = src.getFilterType();
		if (n)
			buffer.appendf("<FilterType>%d</FilterType>", n);
	}
	// field Reversely
	if ((clientVer==-1.0 || clientVer>=1.05))
	{
		bool b = src.getReversely();
		if (b)
			buffer.appendf("<Reversely>1</Reversely>");
	}
	// field Zip
	if ((clientVer==-1.0 || clientVer>=1.05))
	{
		bool b = src.getZip();
		if (b)
			buffer.appendf("<Zip>1</Zip>");
	}
	// field PageNumber
	if ((clientVer==-1.0 || clientVer>=1.05))
	{
		int n = src.getPageNumber();
		if (n)
			buffer.appendf("<PageNumber>%d</PageNumber>", n);
	}
	// field LoadData
	if ((clientVer==-1.0 || clientVer>=1.05))
	{
		bool b = src.getLoadData();
		if (b)
			buffer.appendf("<LoadData>1</LoadData>");
	}
	if (keepRootTag)
		buffer.append("</TpLogFileRequest>");
}

bool CTpLogFileRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_Name.unmarshall(rpc_request, "Name", basepath);
	hasValue |= m_Type.unmarshall(rpc_request, "Type", basepath);
	hasValue |= m_LastHours.unmarshall(rpc_request, "LastHours", basepath);
	hasValue |= m_StartDate.unmarshall(rpc_request, "StartDate", basepath);
	hasValue |= m_EndDate.unmarshall(rpc_request, "EndDate", basepath);
	hasValue |= m_FirstRows.unmarshall(rpc_request, "FirstRows", basepath);
	hasValue |= m_LastRows.unmarshall(rpc_request, "LastRows", basepath);
	hasValue |= m_FilterType.unmarshall(rpc_request, "FilterType", basepath);
	hasValue |= m_Reversely.unmarshall(rpc_request, "Reversely", basepath);
	hasValue |= m_Zip.unmarshall(rpc_request, "Zip", basepath);
	hasValue |= m_PageNumber.unmarshall(rpc_request, "PageNumber", basepath);
	hasValue |= m_LoadData.unmarshall(rpc_request, "LoadData", basepath);
	return hasValue;
}

bool CTpLogFileRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Name.unmarshall(ctx, soapval, "Name");
	hasValue |= m_Type.unmarshall(ctx, soapval, "Type");
	hasValue |= m_LastHours.unmarshall(ctx, soapval, "LastHours");
	hasValue |= m_StartDate.unmarshall(ctx, soapval, "StartDate");
	hasValue |= m_EndDate.unmarshall(ctx, soapval, "EndDate");
	hasValue |= m_FirstRows.unmarshall(ctx, soapval, "FirstRows");
	hasValue |= m_LastRows.unmarshall(ctx, soapval, "LastRows");
	hasValue |= m_FilterType.unmarshall(ctx, soapval, "FilterType");
	hasValue |= m_Reversely.unmarshall(ctx, soapval, "Reversely");
	hasValue |= m_Zip.unmarshall(ctx, soapval, "Zip");
	hasValue |= m_PageNumber.unmarshall(ctx, soapval, "PageNumber");
	hasValue |= m_LoadData.unmarshall(ctx, soapval, "LoadData");
	return hasValue;
}

bool CTpLogFileRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Name.unmarshall(ctx, params, attachments, "Name", basepath);
	hasValue |= m_Type.unmarshall(ctx, params, attachments, "Type", basepath);
	hasValue |= m_LastHours.unmarshall(ctx, params, attachments, "LastHours", basepath);
	hasValue |= m_StartDate.unmarshall(ctx, params, attachments, "StartDate", basepath);
	hasValue |= m_EndDate.unmarshall(ctx, params, attachments, "EndDate", basepath);
	hasValue |= m_FirstRows.unmarshall(ctx, params, attachments, "FirstRows", basepath);
	hasValue |= m_LastRows.unmarshall(ctx, params, attachments, "LastRows", basepath);
	hasValue |= m_FilterType.unmarshall(ctx, params, attachments, "FilterType", basepath);
	hasValue |= m_Reversely.unmarshall(ctx, params, attachments, "Reversely", basepath);
	hasValue |= m_Zip.unmarshall(ctx, params, attachments, "Zip", basepath);
	hasValue |= m_PageNumber.unmarshall(ctx, params, attachments, "PageNumber", basepath);
	hasValue |= m_LoadData.unmarshall(ctx, params, attachments, "LoadData", basepath);
	return hasValue;
}

const char * CTpLogFileRequest::getName() { return m_Name.query();}
const char * CTpLogFileRequest::getType() { return m_Type.query();}
bool CTpLogFileRequest::getLastHours_isNull(){return m_LastHours.is_nil();}
int CTpLogFileRequest::getLastHours() { return m_LastHours;}
const char * CTpLogFileRequest::getStartDate() { return m_StartDate.query();}
const char * CTpLogFileRequest::getEndDate() { return m_EndDate.query();}
bool CTpLogFileRequest::getFirstRows_isNull(){return m_FirstRows.is_nil();}
int CTpLogFileRequest::getFirstRows() { return m_FirstRows;}
bool CTpLogFileRequest::getLastRows_isNull(){return m_LastRows.is_nil();}
int CTpLogFileRequest::getLastRows() { return m_LastRows;}
bool CTpLogFileRequest::getFilterType_isNull(){return m_FilterType.is_nil();}
int CTpLogFileRequest::getFilterType() { return m_FilterType;}
bool CTpLogFileRequest::getReversely_isNull(){return m_Reversely.is_nil();}
bool CTpLogFileRequest::getReversely() { return m_Reversely;}
bool CTpLogFileRequest::getZip_isNull(){return m_Zip.is_nil();}
bool CTpLogFileRequest::getZip() { return m_Zip;}
bool CTpLogFileRequest::getPageNumber_isNull(){return m_PageNumber.is_nil();}
int CTpLogFileRequest::getPageNumber() { return m_PageNumber;}
bool CTpLogFileRequest::getLoadData_isNull(){return m_LoadData.is_nil();}
bool CTpLogFileRequest::getLoadData() { return m_LoadData;}
void CTpLogFileRequest::setName(const char * val){ m_Name.set(val); }
void CTpLogFileRequest::setType(const char * val){ m_Type.set(val); }
void CTpLogFileRequest::setLastHours_null(){ m_LastHours.Nil(); }void CTpLogFileRequest::setLastHours(int val){ m_LastHours=val; }
void CTpLogFileRequest::setStartDate(const char * val){ m_StartDate.set(val); }
void CTpLogFileRequest::setEndDate(const char * val){ m_EndDate.set(val); }
void CTpLogFileRequest::setFirstRows_null(){ m_FirstRows.Nil(); }void CTpLogFileRequest::setFirstRows(int val){ m_FirstRows=val; }
void CTpLogFileRequest::setLastRows_null(){ m_LastRows.Nil(); }void CTpLogFileRequest::setLastRows(int val){ m_LastRows=val; }
void CTpLogFileRequest::setFilterType_null(){ m_FilterType.Nil(); }void CTpLogFileRequest::setFilterType(int val){ m_FilterType=val; }
void CTpLogFileRequest::setReversely_null(){ m_Reversely.Nil(); }void CTpLogFileRequest::setReversely(bool val){ m_Reversely=val; }
void CTpLogFileRequest::setZip_null(){ m_Zip.Nil(); }void CTpLogFileRequest::setZip(bool val){ m_Zip=val; }
void CTpLogFileRequest::setPageNumber_null(){ m_PageNumber.Nil(); }void CTpLogFileRequest::setPageNumber(int val){ m_PageNumber=val; }
void CTpLogFileRequest::setLoadData_null(){ m_LoadData.Nil(); }void CTpLogFileRequest::setLoadData(bool val){ m_LoadData=val; }
extern "C"  IEspTpLogFileRequest *createTpLogFileRequest(const char *serv){return ((IEspTpLogFileRequest *)new CTpLogFileRequest(serv));}
extern "C"  IClientTpLogFileRequest *createClientTpLogFileRequest(const char *serv){return ((IClientTpLogFileRequest *)new CTpLogFileRequest(serv));}

//=======================================================
// class CTpLogFileResponse Implementation
//=======================================================

CTpLogFileResponse::CTpLogFileResponse(const char *serviceName, IRpcMessageBinding *init)
	: m_Name(nilIgnore),m_Type(nilIgnore),m_StartDate(nilIgnore),m_EndDate(nilIgnore),m_LastHours(nilIgnore),m_FirstRows(nilIgnore),m_LastRows(nilIgnore),m_Reversely(nilIgnore),m_Zip(nilIgnore),m_FilterType(nilIgnore),m_LogData(nilIgnore),m_HasDate(1, nilIgnore,false),m_FileSize(nilIgnore),m_PageFrom(0, nilIgnore,false),m_PageTo(nilIgnore),m_PageNumber(0, nilIgnore,false),m_PrevPage(-1, nilIgnore,false),m_NextPage(-1, nilIgnore,false),m_TotalPages(nilIgnore),m_AcceptLanguage(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("TpLogFileResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CTpLogFileResponse::CTpLogFileResponse(const char *serviceName, const char *bc)
	: m_Name(nilIgnore),m_Type(nilIgnore),m_StartDate(nilIgnore),m_EndDate(nilIgnore),m_LastHours(nilIgnore),m_FirstRows(nilIgnore),m_LastRows(nilIgnore),m_Reversely(nilIgnore),m_Zip(nilIgnore),m_FilterType(nilIgnore),m_LogData(nilIgnore),m_HasDate(1, nilIgnore,false),m_FileSize(nilIgnore),m_PageFrom(0, nilIgnore,false),m_PageTo(nilIgnore),m_PageNumber(0, nilIgnore,false),m_PrevPage(-1, nilIgnore,false),m_NextPage(-1, nilIgnore,false),m_TotalPages(nilIgnore),m_AcceptLanguage(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("TpLogFileResponse");
}

CTpLogFileResponse::CTpLogFileResponse(const char *serviceName, IRpcMessage* rpcmsg)
	: m_Name(nilIgnore),m_Type(nilIgnore),m_StartDate(nilIgnore),m_EndDate(nilIgnore),m_LastHours(nilIgnore),m_FirstRows(nilIgnore),m_LastRows(nilIgnore),m_Reversely(nilIgnore),m_Zip(nilIgnore),m_FilterType(nilIgnore),m_LogData(nilIgnore),m_HasDate(1, nilIgnore,false),m_FileSize(nilIgnore),m_PageFrom(0, nilIgnore,false),m_PageTo(nilIgnore),m_PageNumber(0, nilIgnore,false),m_PrevPage(-1, nilIgnore,false),m_NextPage(-1, nilIgnore,false),m_TotalPages(nilIgnore),m_AcceptLanguage(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("TpLogFileResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CTpLogFileResponse::CTpLogFileResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_Name(nilIgnore),m_Type(nilIgnore),m_StartDate(nilIgnore),m_EndDate(nilIgnore),m_LastHours(nilIgnore),m_FirstRows(nilIgnore),m_LastRows(nilIgnore),m_Reversely(nilIgnore),m_Zip(nilIgnore),m_FilterType(nilIgnore),m_LogData(nilIgnore),m_HasDate(1, nilIgnore,false),m_FileSize(nilIgnore),m_PageFrom(0, nilIgnore,false),m_PageTo(nilIgnore),m_PageNumber(0, nilIgnore,false),m_PrevPage(-1, nilIgnore,false),m_NextPage(-1, nilIgnore,false),m_TotalPages(nilIgnore),m_AcceptLanguage(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("TpLogFileResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CTpLogFileResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		schema.append("<xsd:element name=\"Exceptions\" type=\"tns:ArrayOfEspException\" minOccurs=\"0\" maxOccurs=\"1\"/>");
		}
		if (!context.suppressed("TpLogFileResponse","Name")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"Name\" type=\"xsd:string\"/>\n");
		}
		if (!context.suppressed("TpLogFileResponse","Type")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"Type\" type=\"xsd:string\"/>\n");
		}
		if (!context.suppressed("TpLogFileResponse","StartDate")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"StartDate\" type=\"xsd:string\"/>\n");
		}
		if (!context.suppressed("TpLogFileResponse","EndDate")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"EndDate\" type=\"xsd:string\"/>\n");
		}
		if (!context.suppressed("TpLogFileResponse","LastHours")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"LastHours\" type=\"xsd:int\"/>\n");
		}
		if (!context.suppressed("TpLogFileResponse","FirstRows")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"FirstRows\" type=\"xsd:int\"/>\n");
		}
		if (!context.suppressed("TpLogFileResponse","LastRows")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"LastRows\" type=\"xsd:int\"/>\n");
		}
		if (!context.suppressed("TpLogFileResponse","Reversely")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"Reversely\" type=\"xsd:boolean\"/>\n");
		}
		if (!context.suppressed("TpLogFileResponse","Zip")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"Zip\" type=\"xsd:boolean\"/>\n");
		}
		if (!context.suppressed("TpLogFileResponse","FilterType")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"FilterType\" type=\"xsd:int\"/>\n");
		}
		if (!context.suppressed("TpLogFileResponse","LogData")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"LogData\" type=\"xsd:string\"/>\n");
		}
		if (!context.suppressed("TpLogFileResponse","HasDate")) {
			schema.append("<xsd:element minOccurs=\"0\" default=\"true\" name=\"HasDate\" type=\"xsd:boolean\"/>\n");
		}
		if (!context.suppressed("TpLogFileResponse","FileSize")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"FileSize\" type=\"xsd:long\"/>\n");
		}
		if (!context.suppressed("TpLogFileResponse","PageFrom")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"PageFrom\" type=\"xsd:long\"/>\n");
		}
		if (!context.suppressed("TpLogFileResponse","PageTo")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"PageTo\" type=\"xsd:long\"/>\n");
		}
		if (!context.suppressed("TpLogFileResponse","PageNumber")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"PageNumber\" type=\"xsd:int\"/>\n");
		}
		if (!context.suppressed("TpLogFileResponse","PrevPage")) {
			schema.append("<xsd:element minOccurs=\"0\" default=\"-1\" name=\"PrevPage\" type=\"xsd:int\"/>\n");
		}
		if (!context.suppressed("TpLogFileResponse","NextPage")) {
			schema.append("<xsd:element minOccurs=\"0\" default=\"-1\" name=\"NextPage\" type=\"xsd:int\"/>\n");
		}
		if (!context.suppressed("TpLogFileResponse","TotalPages")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"TotalPages\" type=\"xsd:int\"/>\n");
		}
		if (!context.suppressed("TpLogFileResponse","AcceptLanguage")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"AcceptLanguage\" type=\"xsd:string\"/>\n");
		}
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CTpLogFileResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CTpLogFileResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
	info.addMinVersion("TpLogFileResponse","Name",1.05);
	info.addMinVersion("TpLogFileResponse","Type",1.05);
	info.addMinVersion("TpLogFileResponse","StartDate",1.05);
	info.addMinVersion("TpLogFileResponse","EndDate",1.05);
	info.addMinVersion("TpLogFileResponse","LastHours",1.05);
	info.addMinVersion("TpLogFileResponse","FirstRows",1.05);
	info.addMinVersion("TpLogFileResponse","LastRows",1.05);
	info.addMinVersion("TpLogFileResponse","Reversely",1.05);
	info.addMinVersion("TpLogFileResponse","Zip",1.05);
	info.addMinVersion("TpLogFileResponse","FilterType",1.05);
	info.addMinVersion("TpLogFileResponse","LogData",1.05);
	info.addMinVersion("TpLogFileResponse","HasDate",1.05);
	info.addMinVersion("TpLogFileResponse","FileSize",1.05);
	info.addMinVersion("TpLogFileResponse","PageFrom",1.05);
	info.addMinVersion("TpLogFileResponse","PageTo",1.05);
	info.addMinVersion("TpLogFileResponse","PageNumber",1.05);
	info.addMinVersion("TpLogFileResponse","PrevPage",1.05);
	info.addMinVersion("TpLogFileResponse","NextPage",1.05);
	info.addMinVersion("TpLogFileResponse","TotalPages",1.06);
	info.addMinVersion("TpLogFileResponse","AcceptLanguage",1.2);
}

StringBuffer &CTpLogFileResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	if (!context.suppressed("TpLogFileResponse","Name")) {
		extfix.clear();
		if (prefix && *prefix)
			extfix.append(prefix).append(".");
		extfix.append("Name");
		form.appendf("  <tr><td><b>Name: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
		form.append("</td></tr>\n");
	}
	if (!context.suppressed("TpLogFileResponse","Type")) {
		extfix.clear();
		if (prefix && *prefix)
			extfix.append(prefix).append(".");
		extfix.append("Type");
		form.appendf("  <tr><td><b>Type: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
		form.append("</td></tr>\n");
	}
	if (!context.suppressed("TpLogFileResponse","StartDate")) {
		extfix.clear();
		if (prefix && *prefix)
			extfix.append(prefix).append(".");
		extfix.append("StartDate");
		form.appendf("  <tr><td><b>StartDate: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
		form.append("</td></tr>\n");
	}
	if (!context.suppressed("TpLogFileResponse","EndDate")) {
		extfix.clear();
		if (prefix && *prefix)
			extfix.append(prefix).append(".");
		extfix.append("EndDate");
		form.appendf("  <tr><td><b>EndDate: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
		form.append("</td></tr>\n");
	}
	if (!context.suppressed("TpLogFileResponse","LastHours")) {
		extfix.clear();
		if (prefix && *prefix) extfix.append(prefix).append(".");
			extfix.append("LastHours");
		form.appendf("  <tr><td><b>LastHours: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
		form.append("</td></tr>\n");
	}
	if (!context.suppressed("TpLogFileResponse","FirstRows")) {
		extfix.clear();
		if (prefix && *prefix) extfix.append(prefix).append(".");
			extfix.append("FirstRows");
		form.appendf("  <tr><td><b>FirstRows: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
		form.append("</td></tr>\n");
	}
	if (!context.suppressed("TpLogFileResponse","LastRows")) {
		extfix.clear();
		if (prefix && *prefix) extfix.append(prefix).append(".");
			extfix.append("LastRows");
		form.appendf("  <tr><td><b>LastRows: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
		form.append("</td></tr>\n");
	}
	if (!context.suppressed("TpLogFileResponse","Reversely")) {
		extfix.clear();
		if (prefix && *prefix)
			extfix.append(prefix).append(".");
		extfix.append("Reversely");
		
	form.appendf("  <tr><td><b>Reversely? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	}
	if (!context.suppressed("TpLogFileResponse","Zip")) {
		extfix.clear();
		if (prefix && *prefix)
			extfix.append(prefix).append(".");
		extfix.append("Zip");
		
	form.appendf("  <tr><td><b>Zip? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	}
	if (!context.suppressed("TpLogFileResponse","FilterType")) {
		extfix.clear();
		if (prefix && *prefix) extfix.append(prefix).append(".");
			extfix.append("FilterType");
		form.appendf("  <tr><td><b>FilterType: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
		form.append("</td></tr>\n");
	}
	if (!context.suppressed("TpLogFileResponse","LogData")) {
		extfix.clear();
		if (prefix && *prefix)
			extfix.append(prefix).append(".");
		extfix.append("LogData");
		form.appendf("  <tr><td><b>LogData: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
		form.append("</td></tr>\n");
	}
	if (!context.suppressed("TpLogFileResponse","HasDate")) {
		extfix.clear();
		if (prefix && *prefix)
			extfix.append(prefix).append(".");
		extfix.append("HasDate");
		
	form.appendf("  <tr><td><b>HasDate? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\" checked=\"1\" /></td></tr>\n", extfix.str());
	}
	if (!context.suppressed("TpLogFileResponse","FileSize")) {
		extfix.clear();
		if (prefix && *prefix)
			extfix.append(prefix).append(".");
		extfix.append("FileSize");
		form.appendf("  <tr><td><b>FileSize: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
		form.append("</td></tr>\n");
	}
	if (!context.suppressed("TpLogFileResponse","PageFrom")) {
		extfix.clear();
		if (prefix && *prefix)
			extfix.append(prefix).append(".");
		extfix.append("PageFrom");
		form.appendf("  <tr><td><b>PageFrom: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
		form.append("</td></tr>\n");
	}
	if (!context.suppressed("TpLogFileResponse","PageTo")) {
		extfix.clear();
		if (prefix && *prefix)
			extfix.append(prefix).append(".");
		extfix.append("PageTo");
		form.appendf("  <tr><td><b>PageTo: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
		form.append("</td></tr>\n");
	}
	if (!context.suppressed("TpLogFileResponse","PageNumber")) {
		extfix.clear();
		if (prefix && *prefix) extfix.append(prefix).append(".");
			extfix.append("PageNumber");
		form.appendf("  <tr><td><b>PageNumber: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
		form.append("</td></tr>\n");
	}
	if (!context.suppressed("TpLogFileResponse","PrevPage")) {
		extfix.clear();
		if (prefix && *prefix) extfix.append(prefix).append(".");
			extfix.append("PrevPage");
		form.appendf("  <tr><td><b>PrevPage: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"		 value=\"-1\"/>", extfix.str());
		form.append("</td></tr>\n");
	}
	if (!context.suppressed("TpLogFileResponse","NextPage")) {
		extfix.clear();
		if (prefix && *prefix) extfix.append(prefix).append(".");
			extfix.append("NextPage");
		form.appendf("  <tr><td><b>NextPage: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"		 value=\"-1\"/>", extfix.str());
		form.append("</td></tr>\n");
	}
	if (!context.suppressed("TpLogFileResponse","TotalPages")) {
		extfix.clear();
		if (prefix && *prefix) extfix.append(prefix).append(".");
			extfix.append("TotalPages");
		form.appendf("  <tr><td><b>TotalPages: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
		form.append("</td></tr>\n");
	}
	if (!context.suppressed("TpLogFileResponse","AcceptLanguage")) {
		extfix.clear();
		if (prefix && *prefix)
			extfix.append(prefix).append(".");
		extfix.append("AcceptLanguage");
		form.appendf("  <tr><td><b>AcceptLanguage: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
		form.append("</td></tr>\n");
	}
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CTpLogFileResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CTpLogFileResponse::serialize(IRpcMessage& rpc_resp)
{
	IEspContext* ctx = rpc_resp.queryContext();
	double clientVer= ctx ? ctx->getClientVersion() : -1; /* no context gets everything */
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
		if ((clientVer==-1.0 || clientVer>=1.05))
			m_Name.marshall(rpc_resp, "Name", "", "", "");
		if ((clientVer==-1.0 || clientVer>=1.05))
			m_Type.marshall(rpc_resp, "Type", "", "", "");
		if ((clientVer==-1.0 || clientVer>=1.05))
			m_StartDate.marshall(rpc_resp, "StartDate", "", "", "");
		if ((clientVer==-1.0 || clientVer>=1.05))
			m_EndDate.marshall(rpc_resp, "EndDate", "", "", "");
		if ((clientVer==-1.0 || clientVer>=1.05))
			m_LastHours.marshall(rpc_resp, "LastHours", "", "", "");
		if ((clientVer==-1.0 || clientVer>=1.05))
			m_FirstRows.marshall(rpc_resp, "FirstRows", "", "", "");
		if ((clientVer==-1.0 || clientVer>=1.05))
			m_LastRows.marshall(rpc_resp, "LastRows", "", "", "");
		if ((clientVer==-1.0 || clientVer>=1.05))
			m_Reversely.marshall(rpc_resp, "Reversely", "", "", "");
		if ((clientVer==-1.0 || clientVer>=1.05))
			m_Zip.marshall(rpc_resp, "Zip", "", "", "");
		if ((clientVer==-1.0 || clientVer>=1.05))
			m_FilterType.marshall(rpc_resp, "FilterType", "", "", "");
		if ((clientVer==-1.0 || clientVer>=1.05))
			m_LogData.marshall(rpc_resp, "LogData", "", "", "");
		if ((clientVer==-1.0 || clientVer>=1.05))
			m_HasDate.marshall(rpc_resp, "HasDate", "", "", "");
		if ((clientVer==-1.0 || clientVer>=1.05))
			m_FileSize.marshall(rpc_resp, "FileSize", "", "", "");
		if ((clientVer==-1.0 || clientVer>=1.05))
			m_PageFrom.marshall(rpc_resp, "PageFrom", "", "", "");
		if ((clientVer==-1.0 || clientVer>=1.05))
			m_PageTo.marshall(rpc_resp, "PageTo", "", "", "");
		if ((clientVer==-1.0 || clientVer>=1.05))
			m_PageNumber.marshall(rpc_resp, "PageNumber", "", "", "");
		if ((clientVer==-1.0 || clientVer>=1.05))
			m_PrevPage.marshall(rpc_resp, "PrevPage", "", "", "");
		if ((clientVer==-1.0 || clientVer>=1.05))
			m_NextPage.marshall(rpc_resp, "NextPage", "", "", "");
		if ((clientVer==-1.0 || clientVer>=1.06))
			m_TotalPages.marshall(rpc_resp, "TotalPages", "", "", "");
		if ((clientVer==-1.0 || clientVer>=1.2))
			m_AcceptLanguage.marshall(rpc_resp, "AcceptLanguage", "", "", "");
	}
}


void CTpLogFileResponse::copy(CTpLogFileResponse &from)
{
	m_Name.copy(from.m_Name);
	m_Type.copy(from.m_Type);
	m_StartDate.copy(from.m_StartDate);
	m_EndDate.copy(from.m_EndDate);
	m_LastHours.copy(from.m_LastHours);
	m_FirstRows.copy(from.m_FirstRows);
	m_LastRows.copy(from.m_LastRows);
	m_Reversely.copy(from.m_Reversely);
	m_Zip.copy(from.m_Zip);
	m_FilterType.copy(from.m_FilterType);
	m_LogData.copy(from.m_LogData);
	m_HasDate.copy(from.m_HasDate);
	m_FileSize.copy(from.m_FileSize);
	m_PageFrom.copy(from.m_PageFrom);
	m_PageTo.copy(from.m_PageTo);
	m_PageNumber.copy(from.m_PageNumber);
	m_PrevPage.copy(from.m_PrevPage);
	m_NextPage.copy(from.m_NextPage);
	m_TotalPages.copy(from.m_TotalPages);
	m_AcceptLanguage.copy(from.m_AcceptLanguage);
}


void CTpLogFileResponse::copy(IConstTpLogFileResponse &ifrom)
{
	setName(ifrom.getName());
	setType(ifrom.getType());
	setStartDate(ifrom.getStartDate());
	setEndDate(ifrom.getEndDate());
	setLastHours(ifrom.getLastHours());
	setFirstRows(ifrom.getFirstRows());
	setLastRows(ifrom.getLastRows());
	setReversely(ifrom.getReversely());
	setZip(ifrom.getZip());
	setFilterType(ifrom.getFilterType());
	setLogData(ifrom.getLogData());
	setHasDate(ifrom.getHasDate());
	setFileSize(ifrom.getFileSize());
	setPageFrom(ifrom.getPageFrom());
	setPageTo(ifrom.getPageTo());
	setPageNumber(ifrom.getPageNumber());
	setPrevPage(ifrom.getPrevPage());
	setNextPage(ifrom.getNextPage());
	setTotalPages(ifrom.getTotalPages());
	setAcceptLanguage(ifrom.getAcceptLanguage());
}


void CTpLogFileResponse::getAttributes(IProperties &attributes)
{
}


void CTpLogFileResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
		double clientVer = ctx ? ctx->getClientVersion() : -1;
		if ((clientVer==-1.0 || clientVer>=1.05))
			m_Name.toStr(ctx, buffer, "Name", "", true, "", "");
		if ((clientVer==-1.0 || clientVer>=1.05))
			m_Type.toStr(ctx, buffer, "Type", "", true, "", "");
		if ((clientVer==-1.0 || clientVer>=1.05))
			m_StartDate.toStr(ctx, buffer, "StartDate", "", true, "", "");
		if ((clientVer==-1.0 || clientVer>=1.05))
			m_EndDate.toStr(ctx, buffer, "EndDate", "", true, "", "");
		if ((clientVer==-1.0 || clientVer>=1.05))
			m_LastHours.toStr(ctx, buffer, "LastHours", "", true, "", "");
		if ((clientVer==-1.0 || clientVer>=1.05))
			m_FirstRows.toStr(ctx, buffer, "FirstRows", "", true, "", "");
		if ((clientVer==-1.0 || clientVer>=1.05))
			m_LastRows.toStr(ctx, buffer, "LastRows", "", true, "", "");
		if ((clientVer==-1.0 || clientVer>=1.05))
			m_Reversely.toStr(ctx, buffer, "Reversely", "", true, "", "");
		if ((clientVer==-1.0 || clientVer>=1.05))
			m_Zip.toStr(ctx, buffer, "Zip", "", true, "", "");
		if ((clientVer==-1.0 || clientVer>=1.05))
			m_FilterType.toStr(ctx, buffer, "FilterType", "", true, "", "");
		if ((clientVer==-1.0 || clientVer>=1.05))
			m_LogData.toStr(ctx, buffer, "LogData", "", true, "", "");
		if ((clientVer==-1.0 || clientVer>=1.05))
			m_HasDate.toStr(ctx, buffer, "HasDate", "", true, "", "");
		if ((clientVer==-1.0 || clientVer>=1.05))
			m_FileSize.toStr(ctx, buffer, "FileSize", "", true, "", "");
		if ((clientVer==-1.0 || clientVer>=1.05))
			m_PageFrom.toStr(ctx, buffer, "PageFrom", "", true, "", "");
		if ((clientVer==-1.0 || clientVer>=1.05))
			m_PageTo.toStr(ctx, buffer, "PageTo", "", true, "", "");
		if ((clientVer==-1.0 || clientVer>=1.05))
			m_PageNumber.toStr(ctx, buffer, "PageNumber", "", true, "", "");
		if ((clientVer==-1.0 || clientVer>=1.05))
			m_PrevPage.toStr(ctx, buffer, "PrevPage", "", true, "", "");
		if ((clientVer==-1.0 || clientVer>=1.05))
			m_NextPage.toStr(ctx, buffer, "NextPage", "", true, "", "");
		if ((clientVer==-1.0 || clientVer>=1.06))
			m_TotalPages.toStr(ctx, buffer, "TotalPages", "", true, "", "");
		if ((clientVer==-1.0 || clientVer>=1.2))
			m_AcceptLanguage.toStr(ctx, buffer, "AcceptLanguage", "", true, "", "");
	}
}


void CTpLogFileResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CTpLogFileResponse::serializer(IEspContext* ctx, IConstTpLogFileResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<TpLogFileResponse>");
	double clientVer = ctx ? ctx->getClientVersion() : -1;
	// field Name
	if ((clientVer==-1.0 || clientVer>=1.05))
	{
		const char* s = src.getName();
		if (s && *s)
		{
			buffer.append("<Name>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Name>");
		}
	}
	// field Type
	if ((clientVer==-1.0 || clientVer>=1.05))
	{
		const char* s = src.getType();
		if (s && *s)
		{
			buffer.append("<Type>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Type>");
		}
	}
	// field StartDate
	if ((clientVer==-1.0 || clientVer>=1.05))
	{
		const char* s = src.getStartDate();
		if (s && *s)
		{
			buffer.append("<StartDate>");
			encodeUtf8XML(s,buffer);
			buffer.append("</StartDate>");
		}
	}
	// field EndDate
	if ((clientVer==-1.0 || clientVer>=1.05))
	{
		const char* s = src.getEndDate();
		if (s && *s)
		{
			buffer.append("<EndDate>");
			encodeUtf8XML(s,buffer);
			buffer.append("</EndDate>");
		}
	}
	// field LastHours
	if ((clientVer==-1.0 || clientVer>=1.05))
	{
		int n = src.getLastHours();
		if (n)
			buffer.appendf("<LastHours>%d</LastHours>", n);
	}
	// field FirstRows
	if ((clientVer==-1.0 || clientVer>=1.05))
	{
		int n = src.getFirstRows();
		if (n)
			buffer.appendf("<FirstRows>%d</FirstRows>", n);
	}
	// field LastRows
	if ((clientVer==-1.0 || clientVer>=1.05))
	{
		int n = src.getLastRows();
		if (n)
			buffer.appendf("<LastRows>%d</LastRows>", n);
	}
	// field Reversely
	if ((clientVer==-1.0 || clientVer>=1.05))
	{
		bool b = src.getReversely();
		if (b)
			buffer.appendf("<Reversely>1</Reversely>");
	}
	// field Zip
	if ((clientVer==-1.0 || clientVer>=1.05))
	{
		bool b = src.getZip();
		if (b)
			buffer.appendf("<Zip>1</Zip>");
	}
	// field FilterType
	if ((clientVer==-1.0 || clientVer>=1.05))
	{
		int n = src.getFilterType();
		if (n)
			buffer.appendf("<FilterType>%d</FilterType>", n);
	}
	// field LogData
	if ((clientVer==-1.0 || clientVer>=1.05))
	{
		const char* s = src.getLogData();
		if (s && *s)
		{
			buffer.append("<LogData>");
			encodeUtf8XML(s,buffer);
			buffer.append("</LogData>");
		}
	}
	// field HasDate
	if ((clientVer==-1.0 || clientVer>=1.05))
	{
		bool b = src.getHasDate();
		if (b)
			buffer.appendf("<HasDate>1</HasDate>");
	}
	// field FileSize
	if ((clientVer==-1.0 || clientVer>=1.05))
	{
		//*** default kind: TK_INT; type=int64, name=FileSize
		buffer.append("<FileSize>");
		buffer.append(src.getFileSize());
		buffer.append("</FileSize>");
	}
	// field PageFrom
	if ((clientVer==-1.0 || clientVer>=1.05))
	{
		//*** default kind: TK_INT; type=int64, name=PageFrom
		buffer.append("<PageFrom>");
		buffer.append(src.getPageFrom());
		buffer.append("</PageFrom>");
	}
	// field PageTo
	if ((clientVer==-1.0 || clientVer>=1.05))
	{
		//*** default kind: TK_INT; type=int64, name=PageTo
		buffer.append("<PageTo>");
		buffer.append(src.getPageTo());
		buffer.append("</PageTo>");
	}
	// field PageNumber
	if ((clientVer==-1.0 || clientVer>=1.05))
	{
		int n = src.getPageNumber();
		if (n)
			buffer.appendf("<PageNumber>%d</PageNumber>", n);
	}
	// field PrevPage
	if ((clientVer==-1.0 || clientVer>=1.05))
	{
		int n = src.getPrevPage();
		if (n)
			buffer.appendf("<PrevPage>%d</PrevPage>", n);
	}
	// field NextPage
	if ((clientVer==-1.0 || clientVer>=1.05))
	{
		int n = src.getNextPage();
		if (n)
			buffer.appendf("<NextPage>%d</NextPage>", n);
	}
	// field TotalPages
	if ((clientVer==-1.0 || clientVer>=1.06))
	{
		int n = src.getTotalPages();
		if (n)
			buffer.appendf("<TotalPages>%d</TotalPages>", n);
	}
	// field AcceptLanguage
	if ((clientVer==-1.0 || clientVer>=1.2))
	{
		const char* s = src.getAcceptLanguage();
		if (s && *s)
		{
			buffer.append("<AcceptLanguage>");
			encodeUtf8XML(s,buffer);
			buffer.append("</AcceptLanguage>");
		}
	}
	if (keepRootTag)
		buffer.append("</TpLogFileResponse>");
}

bool CTpLogFileResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
		hasValue |= m_Name.unmarshall(rpc_request, "Name", basepath);
		hasValue |= m_Type.unmarshall(rpc_request, "Type", basepath);
		hasValue |= m_StartDate.unmarshall(rpc_request, "StartDate", basepath);
		hasValue |= m_EndDate.unmarshall(rpc_request, "EndDate", basepath);
		hasValue |= m_LastHours.unmarshall(rpc_request, "LastHours", basepath);
		hasValue |= m_FirstRows.unmarshall(rpc_request, "FirstRows", basepath);
		hasValue |= m_LastRows.unmarshall(rpc_request, "LastRows", basepath);
		hasValue |= m_Reversely.unmarshall(rpc_request, "Reversely", basepath);
		hasValue |= m_Zip.unmarshall(rpc_request, "Zip", basepath);
		hasValue |= m_FilterType.unmarshall(rpc_request, "FilterType", basepath);
		hasValue |= m_LogData.unmarshall(rpc_request, "LogData", basepath);
		hasValue |= m_HasDate.unmarshall(rpc_request, "HasDate", basepath);
		hasValue |= m_FileSize.unmarshall(rpc_request, "FileSize", basepath);
		hasValue |= m_PageFrom.unmarshall(rpc_request, "PageFrom", basepath);
		hasValue |= m_PageTo.unmarshall(rpc_request, "PageTo", basepath);
		hasValue |= m_PageNumber.unmarshall(rpc_request, "PageNumber", basepath);
		hasValue |= m_PrevPage.unmarshall(rpc_request, "PrevPage", basepath);
		hasValue |= m_NextPage.unmarshall(rpc_request, "NextPage", basepath);
		hasValue |= m_TotalPages.unmarshall(rpc_request, "TotalPages", basepath);
		hasValue |= m_AcceptLanguage.unmarshall(rpc_request, "AcceptLanguage", basepath);
	}
	return hasValue;
}

bool CTpLogFileResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Name.unmarshall(ctx, soapval, "Name");
	hasValue |= m_Type.unmarshall(ctx, soapval, "Type");
	hasValue |= m_StartDate.unmarshall(ctx, soapval, "StartDate");
	hasValue |= m_EndDate.unmarshall(ctx, soapval, "EndDate");
	hasValue |= m_LastHours.unmarshall(ctx, soapval, "LastHours");
	hasValue |= m_FirstRows.unmarshall(ctx, soapval, "FirstRows");
	hasValue |= m_LastRows.unmarshall(ctx, soapval, "LastRows");
	hasValue |= m_Reversely.unmarshall(ctx, soapval, "Reversely");
	hasValue |= m_Zip.unmarshall(ctx, soapval, "Zip");
	hasValue |= m_FilterType.unmarshall(ctx, soapval, "FilterType");
	hasValue |= m_LogData.unmarshall(ctx, soapval, "LogData");
	hasValue |= m_HasDate.unmarshall(ctx, soapval, "HasDate");
	hasValue |= m_FileSize.unmarshall(ctx, soapval, "FileSize");
	hasValue |= m_PageFrom.unmarshall(ctx, soapval, "PageFrom");
	hasValue |= m_PageTo.unmarshall(ctx, soapval, "PageTo");
	hasValue |= m_PageNumber.unmarshall(ctx, soapval, "PageNumber");
	hasValue |= m_PrevPage.unmarshall(ctx, soapval, "PrevPage");
	hasValue |= m_NextPage.unmarshall(ctx, soapval, "NextPage");
	hasValue |= m_TotalPages.unmarshall(ctx, soapval, "TotalPages");
	hasValue |= m_AcceptLanguage.unmarshall(ctx, soapval, "AcceptLanguage");
	return hasValue;
}

bool CTpLogFileResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Name.unmarshall(ctx, params, attachments, "Name", basepath);
	hasValue |= m_Type.unmarshall(ctx, params, attachments, "Type", basepath);
	hasValue |= m_StartDate.unmarshall(ctx, params, attachments, "StartDate", basepath);
	hasValue |= m_EndDate.unmarshall(ctx, params, attachments, "EndDate", basepath);
	hasValue |= m_LastHours.unmarshall(ctx, params, attachments, "LastHours", basepath);
	hasValue |= m_FirstRows.unmarshall(ctx, params, attachments, "FirstRows", basepath);
	hasValue |= m_LastRows.unmarshall(ctx, params, attachments, "LastRows", basepath);
	hasValue |= m_Reversely.unmarshall(ctx, params, attachments, "Reversely", basepath);
	hasValue |= m_Zip.unmarshall(ctx, params, attachments, "Zip", basepath);
	hasValue |= m_FilterType.unmarshall(ctx, params, attachments, "FilterType", basepath);
	hasValue |= m_LogData.unmarshall(ctx, params, attachments, "LogData", basepath);
	hasValue |= m_HasDate.unmarshall(ctx, params, attachments, "HasDate", basepath);
	hasValue |= m_FileSize.unmarshall(ctx, params, attachments, "FileSize", basepath);
	hasValue |= m_PageFrom.unmarshall(ctx, params, attachments, "PageFrom", basepath);
	hasValue |= m_PageTo.unmarshall(ctx, params, attachments, "PageTo", basepath);
	hasValue |= m_PageNumber.unmarshall(ctx, params, attachments, "PageNumber", basepath);
	hasValue |= m_PrevPage.unmarshall(ctx, params, attachments, "PrevPage", basepath);
	hasValue |= m_NextPage.unmarshall(ctx, params, attachments, "NextPage", basepath);
	hasValue |= m_TotalPages.unmarshall(ctx, params, attachments, "TotalPages", basepath);
	hasValue |= m_AcceptLanguage.unmarshall(ctx, params, attachments, "AcceptLanguage", basepath);
	return hasValue;
}

const char * CTpLogFileResponse::getName() { return m_Name.query();}
const char * CTpLogFileResponse::getType() { return m_Type.query();}
const char * CTpLogFileResponse::getStartDate() { return m_StartDate.query();}
const char * CTpLogFileResponse::getEndDate() { return m_EndDate.query();}
int CTpLogFileResponse::getLastHours() { return m_LastHours;}
int CTpLogFileResponse::getFirstRows() { return m_FirstRows;}
int CTpLogFileResponse::getLastRows() { return m_LastRows;}
bool CTpLogFileResponse::getReversely() { return m_Reversely;}
bool CTpLogFileResponse::getZip() { return m_Zip;}
int CTpLogFileResponse::getFilterType() { return m_FilterType;}
const char * CTpLogFileResponse::getLogData() { return m_LogData.query();}
bool CTpLogFileResponse::getHasDate() { return m_HasDate;}
__int64 CTpLogFileResponse::getFileSize() { return m_FileSize;}
__int64 CTpLogFileResponse::getPageFrom() { return m_PageFrom;}
__int64 CTpLogFileResponse::getPageTo() { return m_PageTo;}
int CTpLogFileResponse::getPageNumber() { return m_PageNumber;}
int CTpLogFileResponse::getPrevPage() { return m_PrevPage;}
int CTpLogFileResponse::getNextPage() { return m_NextPage;}
int CTpLogFileResponse::getTotalPages() { return m_TotalPages;}
const char * CTpLogFileResponse::getAcceptLanguage() { return m_AcceptLanguage.query();}
void CTpLogFileResponse::setName(const char * val){ m_Name.set(val); }
void CTpLogFileResponse::setType(const char * val){ m_Type.set(val); }
void CTpLogFileResponse::setStartDate(const char * val){ m_StartDate.set(val); }
void CTpLogFileResponse::setEndDate(const char * val){ m_EndDate.set(val); }
void CTpLogFileResponse::setLastHours(int val){ m_LastHours=val; }
void CTpLogFileResponse::setFirstRows(int val){ m_FirstRows=val; }
void CTpLogFileResponse::setLastRows(int val){ m_LastRows=val; }
void CTpLogFileResponse::setReversely(bool val){ m_Reversely=val; }
void CTpLogFileResponse::setZip(bool val){ m_Zip=val; }
void CTpLogFileResponse::setFilterType(int val){ m_FilterType=val; }
void CTpLogFileResponse::setLogData(const char * val){ m_LogData.set(val); }
void CTpLogFileResponse::setHasDate(bool val){ m_HasDate=val; }
void CTpLogFileResponse::setFileSize(__int64 val){ m_FileSize=val; }
void CTpLogFileResponse::setPageFrom(__int64 val){ m_PageFrom=val; }
void CTpLogFileResponse::setPageTo(__int64 val){ m_PageTo=val; }
void CTpLogFileResponse::setPageNumber(int val){ m_PageNumber=val; }
void CTpLogFileResponse::setPrevPage(int val){ m_PrevPage=val; }
void CTpLogFileResponse::setNextPage(int val){ m_NextPage=val; }
void CTpLogFileResponse::setTotalPages(int val){ m_TotalPages=val; }
void CTpLogFileResponse::setAcceptLanguage(const char * val){ m_AcceptLanguage.set(val); }
extern "C"  IEspTpLogFileResponse *createTpLogFileResponse(const char *serv){return ((IEspTpLogFileResponse *)new CTpLogFileResponse(serv));}
extern "C"  IClientTpLogFileResponse *createClientTpLogFileResponse(const char *serv){return ((IClientTpLogFileResponse *)new CTpLogFileResponse(serv));}

//=======================================================
// class CSystemLogRequest Implementation
//=======================================================

CSystemLogRequest::CSystemLogRequest(const char *serviceName, IRpcMessageBinding *init)
	: m_Name(nilRemove),m_Type(nilRemove),m_Zip(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("SystemLogRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CSystemLogRequest::CSystemLogRequest(const char *serviceName, const char *bc)
	: m_Name(nilRemove),m_Type(nilRemove),m_Zip(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("SystemLogRequest");
}

CSystemLogRequest::CSystemLogRequest(const char *serviceName, IRpcMessage* rpcmsg)
	: m_Name(nilRemove),m_Type(nilRemove),m_Zip(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("SystemLogRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CSystemLogRequest::CSystemLogRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_Name(nilRemove),m_Type(nilRemove),m_Zip(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("SystemLogRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CSystemLogRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Name\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Type\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Zip\" type=\"xsd:int\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CSystemLogRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CSystemLogRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CSystemLogRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Name");
	form.appendf("  <tr><td><b>Name: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Type");
	form.appendf("  <tr><td><b>Type: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix) extfix.append(prefix).append(".");
		extfix.append("Zip");
	form.appendf("  <tr><td><b>Zip: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CSystemLogRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CSystemLogRequest::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_Name.marshall(rpc_resp, "Name", "", "", "");
	m_Type.marshall(rpc_resp, "Type", "", "", "");
	m_Zip.marshall(rpc_resp, "Zip", "", "", "");
}


void CSystemLogRequest::copy(CSystemLogRequest &from)
{
	m_Name.copy(from.m_Name);
	m_Type.copy(from.m_Type);
	m_Zip.copy(from.m_Zip);
}


void CSystemLogRequest::copy(IConstSystemLogRequest &ifrom)
{
	setName(ifrom.getName());
	setType(ifrom.getType());
	setZip(ifrom.getZip());
}


void CSystemLogRequest::getAttributes(IProperties &attributes)
{
}


void CSystemLogRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_Name.toStr(ctx, buffer, "Name", "", true, "", "");
	m_Type.toStr(ctx, buffer, "Type", "", true, "", "");
	m_Zip.toStr(ctx, buffer, "Zip", "", true, "", "");
}


void CSystemLogRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CSystemLogRequest::serializer(IEspContext* ctx, IConstSystemLogRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<SystemLogRequest>");
	// field Name
	{
		const char* s = src.getName();
		if (s && *s)
		{
			buffer.append("<Name>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Name>");
		}
	}
	// field Type
	{
		const char* s = src.getType();
		if (s && *s)
		{
			buffer.append("<Type>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Type>");
		}
	}
	// field Zip
	{
		int n = src.getZip();
		if (n)
			buffer.appendf("<Zip>%d</Zip>", n);
	}
	if (keepRootTag)
		buffer.append("</SystemLogRequest>");
}

bool CSystemLogRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_Name.unmarshall(rpc_request, "Name", basepath);
	hasValue |= m_Type.unmarshall(rpc_request, "Type", basepath);
	hasValue |= m_Zip.unmarshall(rpc_request, "Zip", basepath);
	return hasValue;
}

bool CSystemLogRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Name.unmarshall(ctx, soapval, "Name");
	hasValue |= m_Type.unmarshall(ctx, soapval, "Type");
	hasValue |= m_Zip.unmarshall(ctx, soapval, "Zip");
	return hasValue;
}

bool CSystemLogRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Name.unmarshall(ctx, params, attachments, "Name", basepath);
	hasValue |= m_Type.unmarshall(ctx, params, attachments, "Type", basepath);
	hasValue |= m_Zip.unmarshall(ctx, params, attachments, "Zip", basepath);
	return hasValue;
}

const char * CSystemLogRequest::getName() { return m_Name.query();}
const char * CSystemLogRequest::getType() { return m_Type.query();}
bool CSystemLogRequest::getZip_isNull(){return m_Zip.is_nil();}
int CSystemLogRequest::getZip() { return m_Zip;}
void CSystemLogRequest::setName(const char * val){ m_Name.set(val); }
void CSystemLogRequest::setType(const char * val){ m_Type.set(val); }
void CSystemLogRequest::setZip_null(){ m_Zip.Nil(); }void CSystemLogRequest::setZip(int val){ m_Zip=val; }
extern "C"  IEspSystemLogRequest *createSystemLogRequest(const char *serv){return ((IEspSystemLogRequest *)new CSystemLogRequest(serv));}
extern "C"  IClientSystemLogRequest *createClientSystemLogRequest(const char *serv){return ((IClientSystemLogRequest *)new CSystemLogRequest(serv));}

//=======================================================
// class CSystemLogResponse Implementation
//=======================================================

CSystemLogResponse::CSystemLogResponse(const char *serviceName, IRpcMessageBinding *init)
	: m_thefile(nilIgnore),m_thefile_mimetype("application/octet-stream")
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("SystemLogResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CSystemLogResponse::CSystemLogResponse(const char *serviceName, const char *bc)
	: m_thefile(nilIgnore), m_thefile_mimetype("application/octet-stream")
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("SystemLogResponse");
}

CSystemLogResponse::CSystemLogResponse(const char *serviceName, IRpcMessage* rpcmsg)
	: m_thefile(nilIgnore), m_thefile_mimetype("application/octet-stream")
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("SystemLogResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CSystemLogResponse::CSystemLogResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_thefile(nilIgnore), m_thefile_mimetype("application/octet-stream")
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("SystemLogResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CSystemLogResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		schema.append("<xsd:element name=\"Exceptions\" type=\"tns:ArrayOfEspException\" minOccurs=\"0\" maxOccurs=\"1\"/>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"thefile\" type=\"xsd:base64Binary\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CSystemLogResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CSystemLogResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CSystemLogResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("thefile");
	form.appendf("  <tr><td><b>thefile: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CSystemLogResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CSystemLogResponse::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
		m_thefile.marshall(rpc_resp, "thefile", "", "", "");
	}
}


void CSystemLogResponse::copy(CSystemLogResponse &from)
{
	m_thefile.copy(from.m_thefile);
}


void CSystemLogResponse::copy(IConstSystemLogResponse &ifrom)
{
	setThefile(ifrom.getThefile());
}


void CSystemLogResponse::getAttributes(IProperties &attributes)
{
}


void CSystemLogResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
		m_thefile.toStr(ctx, buffer, "thefile", "", true, "", "");
	}
}


void CSystemLogResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CSystemLogResponse::serializer(IEspContext* ctx, IConstSystemLogResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<SystemLogResponse>");
	// field thefile
	{
		StringBuffer tmp;
		JBASE64_Encode(src.getThefile().toByteArray(), src.getThefile().length(), tmp);
		if (tmp.length()>0)
			buffer.appendf("<thefile>%s</thefile>",tmp.str());
	}
	if (keepRootTag)
		buffer.append("</SystemLogResponse>");
}

void CSystemLogResponse::appendContent(IEspContext* ctx, MemoryBuffer& buffer, StringBuffer &mimetype)
{
	buffer.clear().append(m_thefile.getValue());
	mimetype.set(m_thefile_mimetype.str());
}

bool CSystemLogResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
		hasValue |= m_thefile.unmarshall(rpc_request, "thefile", basepath);
	}
	return hasValue;
}

bool CSystemLogResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_thefile.unmarshall(ctx, soapval, "thefile");
	return hasValue;
}

bool CSystemLogResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_thefile.unmarshall(ctx, params, attachments, "thefile", basepath);
	return hasValue;
}

const char *CSystemLogResponse::getThefile_mimetype(){ return m_thefile_mimetype.str(); }
const MemoryBuffer & CSystemLogResponse::getThefile() { return m_thefile.getValue();}
void CSystemLogResponse::setThefile_mimetype(const char *  val){ m_thefile_mimetype.set(val); }
void CSystemLogResponse::setThefile(const MemoryBuffer & val){ m_thefile->clear().append(val); }
extern "C"  IEspSystemLogResponse *createSystemLogResponse(const char *serv){return ((IEspSystemLogResponse *)new CSystemLogResponse(serv));}
extern "C"  IClientSystemLogResponse *createClientSystemLogResponse(const char *serv){return ((IClientSystemLogResponse *)new CSystemLogResponse(serv));}

//=======================================================
// class CTpGetComponentFileRequest Implementation
//=======================================================

CTpGetComponentFileRequest::CTpGetComponentFileRequest(const char *serviceName, IRpcMessageBinding *init)
	: m_CompType(nilIgnore),m_CompName(nilIgnore),m_NetAddress(nilIgnore),m_Directory(nilIgnore),m_FileType(nilIgnore),m_OsType(nilIgnore),m_PlainText(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("TpGetComponentFileRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CTpGetComponentFileRequest::CTpGetComponentFileRequest(const char *serviceName, const char *bc)
	: m_CompType(nilIgnore),m_CompName(nilIgnore),m_NetAddress(nilIgnore),m_Directory(nilIgnore),m_FileType(nilIgnore),m_OsType(nilIgnore),m_PlainText(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("TpGetComponentFileRequest");
}

CTpGetComponentFileRequest::CTpGetComponentFileRequest(const char *serviceName, IRpcMessage* rpcmsg)
	: m_CompType(nilIgnore),m_CompName(nilIgnore),m_NetAddress(nilIgnore),m_Directory(nilIgnore),m_FileType(nilIgnore),m_OsType(nilIgnore),m_PlainText(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("TpGetComponentFileRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CTpGetComponentFileRequest::CTpGetComponentFileRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_CompType(nilIgnore),m_CompName(nilIgnore),m_NetAddress(nilIgnore),m_Directory(nilIgnore),m_FileType(nilIgnore),m_OsType(nilIgnore),m_PlainText(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("TpGetComponentFileRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CTpGetComponentFileRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"CompType\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"CompName\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"NetAddress\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Directory\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"FileType\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"OsType\" type=\"xsd:int\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"PlainText\" type=\"xsd:string\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CTpGetComponentFileRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CTpGetComponentFileRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CTpGetComponentFileRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("CompType");
	form.appendf("  <tr><td><b>CompType: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("CompName");
	form.appendf("  <tr><td><b>CompName: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("NetAddress");
	form.appendf("  <tr><td><b>NetAddress: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Directory");
	form.appendf("  <tr><td><b>Directory: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("FileType");
	form.appendf("  <tr><td><b>FileType: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix) extfix.append(prefix).append(".");
		extfix.append("OsType");
	form.appendf("  <tr><td><b>OsType: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("PlainText");
	form.appendf("  <tr><td><b>PlainText: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CTpGetComponentFileRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CTpGetComponentFileRequest::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_CompType.marshall(rpc_resp, "CompType", "", "", "");
	m_CompName.marshall(rpc_resp, "CompName", "", "", "");
	m_NetAddress.marshall(rpc_resp, "NetAddress", "", "", "");
	m_Directory.marshall(rpc_resp, "Directory", "", "", "");
	m_FileType.marshall(rpc_resp, "FileType", "", "", "");
	m_OsType.marshall(rpc_resp, "OsType", "", "", "");
	m_PlainText.marshall(rpc_resp, "PlainText", "", "", "");
}


void CTpGetComponentFileRequest::copy(CTpGetComponentFileRequest &from)
{
	m_CompType.copy(from.m_CompType);
	m_CompName.copy(from.m_CompName);
	m_NetAddress.copy(from.m_NetAddress);
	m_Directory.copy(from.m_Directory);
	m_FileType.copy(from.m_FileType);
	m_OsType.copy(from.m_OsType);
	m_PlainText.copy(from.m_PlainText);
}


void CTpGetComponentFileRequest::copy(IConstTpGetComponentFileRequest &ifrom)
{
	setCompType(ifrom.getCompType());
	setCompName(ifrom.getCompName());
	setNetAddress(ifrom.getNetAddress());
	setDirectory(ifrom.getDirectory());
	setFileType(ifrom.getFileType());
	setOsType(ifrom.getOsType());
	setPlainText(ifrom.getPlainText());
}


void CTpGetComponentFileRequest::getAttributes(IProperties &attributes)
{
}


void CTpGetComponentFileRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_CompType.toStr(ctx, buffer, "CompType", "", true, "", "");
	m_CompName.toStr(ctx, buffer, "CompName", "", true, "", "");
	m_NetAddress.toStr(ctx, buffer, "NetAddress", "", true, "", "");
	m_Directory.toStr(ctx, buffer, "Directory", "", true, "", "");
	m_FileType.toStr(ctx, buffer, "FileType", "", true, "", "");
	m_OsType.toStr(ctx, buffer, "OsType", "", true, "", "");
	m_PlainText.toStr(ctx, buffer, "PlainText", "", true, "", "");
}


void CTpGetComponentFileRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CTpGetComponentFileRequest::serializer(IEspContext* ctx, IConstTpGetComponentFileRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<TpGetComponentFileRequest>");
	// field CompType
	{
		const char* s = src.getCompType();
		if (s && *s)
		{
			buffer.append("<CompType>");
			encodeUtf8XML(s,buffer);
			buffer.append("</CompType>");
		}
	}
	// field CompName
	{
		const char* s = src.getCompName();
		if (s && *s)
		{
			buffer.append("<CompName>");
			encodeUtf8XML(s,buffer);
			buffer.append("</CompName>");
		}
	}
	// field NetAddress
	{
		const char* s = src.getNetAddress();
		if (s && *s)
		{
			buffer.append("<NetAddress>");
			encodeUtf8XML(s,buffer);
			buffer.append("</NetAddress>");
		}
	}
	// field Directory
	{
		const char* s = src.getDirectory();
		if (s && *s)
		{
			buffer.append("<Directory>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Directory>");
		}
	}
	// field FileType
	{
		const char* s = src.getFileType();
		if (s && *s)
		{
			buffer.append("<FileType>");
			encodeUtf8XML(s,buffer);
			buffer.append("</FileType>");
		}
	}
	// field OsType
	{
		int n = src.getOsType();
		if (n)
			buffer.appendf("<OsType>%d</OsType>", n);
	}
	// field PlainText
	{
		const char* s = src.getPlainText();
		if (s && *s)
		{
			buffer.append("<PlainText>");
			encodeUtf8XML(s,buffer);
			buffer.append("</PlainText>");
		}
	}
	if (keepRootTag)
		buffer.append("</TpGetComponentFileRequest>");
}

bool CTpGetComponentFileRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_CompType.unmarshall(rpc_request, "CompType", basepath);
	hasValue |= m_CompName.unmarshall(rpc_request, "CompName", basepath);
	hasValue |= m_NetAddress.unmarshall(rpc_request, "NetAddress", basepath);
	hasValue |= m_Directory.unmarshall(rpc_request, "Directory", basepath);
	hasValue |= m_FileType.unmarshall(rpc_request, "FileType", basepath);
	hasValue |= m_OsType.unmarshall(rpc_request, "OsType", basepath);
	hasValue |= m_PlainText.unmarshall(rpc_request, "PlainText", basepath);
	return hasValue;
}

bool CTpGetComponentFileRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_CompType.unmarshall(ctx, soapval, "CompType");
	hasValue |= m_CompName.unmarshall(ctx, soapval, "CompName");
	hasValue |= m_NetAddress.unmarshall(ctx, soapval, "NetAddress");
	hasValue |= m_Directory.unmarshall(ctx, soapval, "Directory");
	hasValue |= m_FileType.unmarshall(ctx, soapval, "FileType");
	hasValue |= m_OsType.unmarshall(ctx, soapval, "OsType");
	hasValue |= m_PlainText.unmarshall(ctx, soapval, "PlainText");
	return hasValue;
}

bool CTpGetComponentFileRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_CompType.unmarshall(ctx, params, attachments, "CompType", basepath);
	hasValue |= m_CompName.unmarshall(ctx, params, attachments, "CompName", basepath);
	hasValue |= m_NetAddress.unmarshall(ctx, params, attachments, "NetAddress", basepath);
	hasValue |= m_Directory.unmarshall(ctx, params, attachments, "Directory", basepath);
	hasValue |= m_FileType.unmarshall(ctx, params, attachments, "FileType", basepath);
	hasValue |= m_OsType.unmarshall(ctx, params, attachments, "OsType", basepath);
	hasValue |= m_PlainText.unmarshall(ctx, params, attachments, "PlainText", basepath);
	return hasValue;
}

const char * CTpGetComponentFileRequest::getCompType() { return m_CompType.query();}
const char * CTpGetComponentFileRequest::getCompName() { return m_CompName.query();}
const char * CTpGetComponentFileRequest::getNetAddress() { return m_NetAddress.query();}
const char * CTpGetComponentFileRequest::getDirectory() { return m_Directory.query();}
const char * CTpGetComponentFileRequest::getFileType() { return m_FileType.query();}
int CTpGetComponentFileRequest::getOsType() { return m_OsType;}
const char * CTpGetComponentFileRequest::getPlainText() { return m_PlainText.query();}
void CTpGetComponentFileRequest::setCompType(const char * val){ m_CompType.set(val); }
void CTpGetComponentFileRequest::setCompName(const char * val){ m_CompName.set(val); }
void CTpGetComponentFileRequest::setNetAddress(const char * val){ m_NetAddress.set(val); }
void CTpGetComponentFileRequest::setDirectory(const char * val){ m_Directory.set(val); }
void CTpGetComponentFileRequest::setFileType(const char * val){ m_FileType.set(val); }
void CTpGetComponentFileRequest::setOsType(int val){ m_OsType=val; }
void CTpGetComponentFileRequest::setPlainText(const char * val){ m_PlainText.set(val); }
extern "C"  IEspTpGetComponentFileRequest *createTpGetComponentFileRequest(const char *serv){return ((IEspTpGetComponentFileRequest *)new CTpGetComponentFileRequest(serv));}
extern "C"  IClientTpGetComponentFileRequest *createClientTpGetComponentFileRequest(const char *serv){return ((IClientTpGetComponentFileRequest *)new CTpGetComponentFileRequest(serv));}

//=======================================================
// class CTpGetComponentFileResponse Implementation
//=======================================================

CTpGetComponentFileResponse::CTpGetComponentFileResponse(const char *serviceName, IRpcMessageBinding *init)
	: m_FileContents(nilIgnore),m_FileContents_mimetype("application/octet-stream")
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("TpGetComponentFileResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CTpGetComponentFileResponse::CTpGetComponentFileResponse(const char *serviceName, const char *bc)
	: m_FileContents(nilIgnore), m_FileContents_mimetype("application/octet-stream")
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("TpGetComponentFileResponse");
}

CTpGetComponentFileResponse::CTpGetComponentFileResponse(const char *serviceName, IRpcMessage* rpcmsg)
	: m_FileContents(nilIgnore), m_FileContents_mimetype("application/octet-stream")
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("TpGetComponentFileResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CTpGetComponentFileResponse::CTpGetComponentFileResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_FileContents(nilIgnore), m_FileContents_mimetype("application/octet-stream")
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("TpGetComponentFileResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CTpGetComponentFileResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		schema.append("<xsd:element name=\"Exceptions\" type=\"tns:ArrayOfEspException\" minOccurs=\"0\" maxOccurs=\"1\"/>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"FileContents\" type=\"xsd:base64Binary\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CTpGetComponentFileResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CTpGetComponentFileResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CTpGetComponentFileResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("FileContents");
	form.appendf("  <tr><td><b>FileContents: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CTpGetComponentFileResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CTpGetComponentFileResponse::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
		m_FileContents.marshall(rpc_resp, "FileContents", "", "", "");
	}
}


void CTpGetComponentFileResponse::copy(CTpGetComponentFileResponse &from)
{
	m_FileContents.copy(from.m_FileContents);
}


void CTpGetComponentFileResponse::copy(IConstTpGetComponentFileResponse &ifrom)
{
	setFileContents(ifrom.getFileContents());
}


void CTpGetComponentFileResponse::getAttributes(IProperties &attributes)
{
}


void CTpGetComponentFileResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
		m_FileContents.toStr(ctx, buffer, "FileContents", "", true, "", "");
	}
}


void CTpGetComponentFileResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CTpGetComponentFileResponse::serializer(IEspContext* ctx, IConstTpGetComponentFileResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<TpGetComponentFileResponse>");
	// field FileContents
	{
		StringBuffer tmp;
		JBASE64_Encode(src.getFileContents().toByteArray(), src.getFileContents().length(), tmp);
		if (tmp.length()>0)
			buffer.appendf("<FileContents>%s</FileContents>",tmp.str());
	}
	if (keepRootTag)
		buffer.append("</TpGetComponentFileResponse>");
}

void CTpGetComponentFileResponse::appendContent(IEspContext* ctx, MemoryBuffer& buffer, StringBuffer &mimetype)
{
	buffer.clear().append(m_FileContents.getValue());
	mimetype.set(m_FileContents_mimetype.str());
}

bool CTpGetComponentFileResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
		hasValue |= m_FileContents.unmarshall(rpc_request, "FileContents", basepath);
	}
	return hasValue;
}

bool CTpGetComponentFileResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_FileContents.unmarshall(ctx, soapval, "FileContents");
	return hasValue;
}

bool CTpGetComponentFileResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_FileContents.unmarshall(ctx, params, attachments, "FileContents", basepath);
	return hasValue;
}

const char *CTpGetComponentFileResponse::getFileContents_mimetype(){ return m_FileContents_mimetype.str(); }
const MemoryBuffer & CTpGetComponentFileResponse::getFileContents() { return m_FileContents.getValue();}
void CTpGetComponentFileResponse::setFileContents_mimetype(const char *  val){ m_FileContents_mimetype.set(val); }
void CTpGetComponentFileResponse::setFileContents(const MemoryBuffer & val){ m_FileContents->clear().append(val); }
extern "C"  IEspTpGetComponentFileResponse *createTpGetComponentFileResponse(const char *serv){return ((IEspTpGetComponentFileResponse *)new CTpGetComponentFileResponse(serv));}
extern "C"  IClientTpGetComponentFileResponse *createClientTpGetComponentFileResponse(const char *serv){return ((IClientTpGetComponentFileResponse *)new CTpGetComponentFileResponse(serv));}

//=======================================================
// class CTpThorStatusRequest Implementation
//=======================================================

CTpThorStatusRequest::CTpThorStatusRequest(const char *serviceName, IRpcMessageBinding *init)
	: m_Name(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("TpThorStatusRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CTpThorStatusRequest::CTpThorStatusRequest(const char *serviceName, const char *bc)
	: m_Name(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("TpThorStatusRequest");
}

CTpThorStatusRequest::CTpThorStatusRequest(const char *serviceName, IRpcMessage* rpcmsg)
	: m_Name(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("TpThorStatusRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CTpThorStatusRequest::CTpThorStatusRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_Name(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("TpThorStatusRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CTpThorStatusRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Name\" type=\"xsd:string\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CTpThorStatusRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CTpThorStatusRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CTpThorStatusRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Name");
	form.appendf("  <tr><td><b>Name: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CTpThorStatusRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CTpThorStatusRequest::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_Name.marshall(rpc_resp, "Name", "", "", "");
}


void CTpThorStatusRequest::copy(CTpThorStatusRequest &from)
{
	m_Name.copy(from.m_Name);
}


void CTpThorStatusRequest::copy(IConstTpThorStatusRequest &ifrom)
{
	setName(ifrom.getName());
}


void CTpThorStatusRequest::getAttributes(IProperties &attributes)
{
}


void CTpThorStatusRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_Name.toStr(ctx, buffer, "Name", "", true, "", "");
}


void CTpThorStatusRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CTpThorStatusRequest::serializer(IEspContext* ctx, IConstTpThorStatusRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<TpThorStatusRequest>");
	// field Name
	{
		const char* s = src.getName();
		if (s && *s)
		{
			buffer.append("<Name>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Name>");
		}
	}
	if (keepRootTag)
		buffer.append("</TpThorStatusRequest>");
}

bool CTpThorStatusRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_Name.unmarshall(rpc_request, "Name", basepath);
	return hasValue;
}

bool CTpThorStatusRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Name.unmarshall(ctx, soapval, "Name");
	return hasValue;
}

bool CTpThorStatusRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Name.unmarshall(ctx, params, attachments, "Name", basepath);
	return hasValue;
}

const char * CTpThorStatusRequest::getName() { return m_Name.query();}
void CTpThorStatusRequest::setName(const char * val){ m_Name.set(val); }
extern "C"  IEspTpThorStatusRequest *createTpThorStatusRequest(const char *serv){return ((IEspTpThorStatusRequest *)new CTpThorStatusRequest(serv));}
extern "C"  IClientTpThorStatusRequest *createClientTpThorStatusRequest(const char *serv){return ((IClientTpThorStatusRequest *)new CTpThorStatusRequest(serv));}

//=======================================================
// class CTpThorStatusResponse Implementation
//=======================================================

CTpThorStatusResponse::CTpThorStatusResponse(const char *serviceName, IRpcMessageBinding *init)
	: m_Name(nilIgnore),m_Queue(nilIgnore),m_Group(nilIgnore),m_ThorMasterIPAddress(nilIgnore),m_Port(nilIgnore),m_StartTime(nilIgnore),m_LogFile(nilIgnore),m_Wuid(nilIgnore),m_Graph(nilIgnore),m_SubGraph(nilIgnore),m_SubGraphDuration(nilIgnore),m_AutoRefresh(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("TpThorStatusResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CTpThorStatusResponse::CTpThorStatusResponse(const char *serviceName, const char *bc)
	: m_Name(nilIgnore),m_Queue(nilIgnore),m_Group(nilIgnore),m_ThorMasterIPAddress(nilIgnore),m_Port(nilIgnore),m_StartTime(nilIgnore),m_LogFile(nilIgnore),m_Wuid(nilIgnore),m_Graph(nilIgnore),m_SubGraph(nilIgnore),m_SubGraphDuration(nilIgnore),m_AutoRefresh(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("TpThorStatusResponse");
}

CTpThorStatusResponse::CTpThorStatusResponse(const char *serviceName, IRpcMessage* rpcmsg)
	: m_Name(nilIgnore),m_Queue(nilIgnore),m_Group(nilIgnore),m_ThorMasterIPAddress(nilIgnore),m_Port(nilIgnore),m_StartTime(nilIgnore),m_LogFile(nilIgnore),m_Wuid(nilIgnore),m_Graph(nilIgnore),m_SubGraph(nilIgnore),m_SubGraphDuration(nilIgnore),m_AutoRefresh(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("TpThorStatusResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CTpThorStatusResponse::CTpThorStatusResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_Name(nilIgnore),m_Queue(nilIgnore),m_Group(nilIgnore),m_ThorMasterIPAddress(nilIgnore),m_Port(nilIgnore),m_StartTime(nilIgnore),m_LogFile(nilIgnore),m_Wuid(nilIgnore),m_Graph(nilIgnore),m_SubGraph(nilIgnore),m_SubGraphDuration(nilIgnore),m_AutoRefresh(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("TpThorStatusResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CTpThorStatusResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		schema.append("<xsd:element name=\"Exceptions\" type=\"tns:ArrayOfEspException\" minOccurs=\"0\" maxOccurs=\"1\"/>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Name\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Queue\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Group\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"ThorMasterIPAddress\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Port\" type=\"xsd:int\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"StartTime\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"LogFile\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Wuid\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Graph\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"SubGraph\" type=\"xsd:int\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"SubGraphDuration\" type=\"xsd:int\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"AutoRefresh\" type=\"xsd:int\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CTpThorStatusResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CTpThorStatusResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CTpThorStatusResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Name");
	form.appendf("  <tr><td><b>Name: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Queue");
	form.appendf("  <tr><td><b>Queue: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Group");
	form.appendf("  <tr><td><b>Group: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("ThorMasterIPAddress");
	form.appendf("  <tr><td><b>ThorMasterIPAddress: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix) extfix.append(prefix).append(".");
		extfix.append("Port");
	form.appendf("  <tr><td><b>Port: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("StartTime");
	form.appendf("  <tr><td><b>StartTime: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("LogFile");
	form.appendf("  <tr><td><b>LogFile: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Wuid");
	form.appendf("  <tr><td><b>Wuid: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Graph");
	form.appendf("  <tr><td><b>Graph: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix) extfix.append(prefix).append(".");
		extfix.append("SubGraph");
	form.appendf("  <tr><td><b>SubGraph: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix) extfix.append(prefix).append(".");
		extfix.append("SubGraphDuration");
	form.appendf("  <tr><td><b>SubGraphDuration: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix) extfix.append(prefix).append(".");
		extfix.append("AutoRefresh");
	form.appendf("  <tr><td><b>AutoRefresh: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CTpThorStatusResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CTpThorStatusResponse::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	rpc_resp.setEncodeXml(false);
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
		m_Name.marshall(rpc_resp, "Name", "", "", "");
		m_Queue.marshall(rpc_resp, "Queue", "", "", "");
		m_Group.marshall(rpc_resp, "Group", "", "", "");
		m_ThorMasterIPAddress.marshall(rpc_resp, "ThorMasterIPAddress", "", "", "");
		m_Port.marshall(rpc_resp, "Port", "", "", "");
		m_StartTime.marshall(rpc_resp, "StartTime", "", "", "");
		m_LogFile.marshall(rpc_resp, "LogFile", "", "", "");
		m_Wuid.marshall(rpc_resp, "Wuid", "", "", "");
		m_Graph.marshall(rpc_resp, "Graph", "", "", "");
		m_SubGraph.marshall(rpc_resp, "SubGraph", "", "", "");
		m_SubGraphDuration.marshall(rpc_resp, "SubGraphDuration", "", "", "");
		m_AutoRefresh.marshall(rpc_resp, "AutoRefresh", "", "", "");
	}
}


void CTpThorStatusResponse::copy(CTpThorStatusResponse &from)
{
	m_Name.copy(from.m_Name);
	m_Queue.copy(from.m_Queue);
	m_Group.copy(from.m_Group);
	m_ThorMasterIPAddress.copy(from.m_ThorMasterIPAddress);
	m_Port.copy(from.m_Port);
	m_StartTime.copy(from.m_StartTime);
	m_LogFile.copy(from.m_LogFile);
	m_Wuid.copy(from.m_Wuid);
	m_Graph.copy(from.m_Graph);
	m_SubGraph.copy(from.m_SubGraph);
	m_SubGraphDuration.copy(from.m_SubGraphDuration);
	m_AutoRefresh.copy(from.m_AutoRefresh);
}


void CTpThorStatusResponse::copy(IConstTpThorStatusResponse &ifrom)
{
	setName(ifrom.getName());
	setQueue(ifrom.getQueue());
	setGroup(ifrom.getGroup());
	setThorMasterIPAddress(ifrom.getThorMasterIPAddress());
	setPort(ifrom.getPort());
	setStartTime(ifrom.getStartTime());
	setLogFile(ifrom.getLogFile());
	setWuid(ifrom.getWuid());
	setGraph(ifrom.getGraph());
	setSubGraph(ifrom.getSubGraph());
	setSubGraphDuration(ifrom.getSubGraphDuration());
	setAutoRefresh(ifrom.getAutoRefresh());
}


void CTpThorStatusResponse::getAttributes(IProperties &attributes)
{
}


void CTpThorStatusResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
		m_Name.toStr(ctx, buffer, "Name", "", false, "", "");
		m_Queue.toStr(ctx, buffer, "Queue", "", false, "", "");
		m_Group.toStr(ctx, buffer, "Group", "", false, "", "");
		m_ThorMasterIPAddress.toStr(ctx, buffer, "ThorMasterIPAddress", "", false, "", "");
		m_Port.toStr(ctx, buffer, "Port", "", false, "", "");
		m_StartTime.toStr(ctx, buffer, "StartTime", "", false, "", "");
		m_LogFile.toStr(ctx, buffer, "LogFile", "", false, "", "");
		m_Wuid.toStr(ctx, buffer, "Wuid", "", false, "", "");
		m_Graph.toStr(ctx, buffer, "Graph", "", false, "", "");
		m_SubGraph.toStr(ctx, buffer, "SubGraph", "", false, "", "");
		m_SubGraphDuration.toStr(ctx, buffer, "SubGraphDuration", "", false, "", "");
		m_AutoRefresh.toStr(ctx, buffer, "AutoRefresh", "", false, "", "");
	}
}


void CTpThorStatusResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CTpThorStatusResponse::serializer(IEspContext* ctx, IConstTpThorStatusResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<TpThorStatusResponse>");
	// field Name
	{
		const char* s = src.getName();
		if (s && *s)
		buffer.appendf("<Name>%s</Name>",s);
	}
	// field Queue
	{
		const char* s = src.getQueue();
		if (s && *s)
		buffer.appendf("<Queue>%s</Queue>",s);
	}
	// field Group
	{
		const char* s = src.getGroup();
		if (s && *s)
		buffer.appendf("<Group>%s</Group>",s);
	}
	// field ThorMasterIPAddress
	{
		const char* s = src.getThorMasterIPAddress();
		if (s && *s)
		buffer.appendf("<ThorMasterIPAddress>%s</ThorMasterIPAddress>",s);
	}
	// field Port
	{
		int n = src.getPort();
		if (n)
			buffer.appendf("<Port>%d</Port>", n);
	}
	// field StartTime
	{
		const char* s = src.getStartTime();
		if (s && *s)
		buffer.appendf("<StartTime>%s</StartTime>",s);
	}
	// field LogFile
	{
		const char* s = src.getLogFile();
		if (s && *s)
		buffer.appendf("<LogFile>%s</LogFile>",s);
	}
	// field Wuid
	{
		const char* s = src.getWuid();
		if (s && *s)
		buffer.appendf("<Wuid>%s</Wuid>",s);
	}
	// field Graph
	{
		const char* s = src.getGraph();
		if (s && *s)
		buffer.appendf("<Graph>%s</Graph>",s);
	}
	// field SubGraph
	{
		int n = src.getSubGraph();
		if (n)
			buffer.appendf("<SubGraph>%d</SubGraph>", n);
	}
	// field SubGraphDuration
	{
		int n = src.getSubGraphDuration();
		if (n)
			buffer.appendf("<SubGraphDuration>%d</SubGraphDuration>", n);
	}
	// field AutoRefresh
	{
		int n = src.getAutoRefresh();
		if (n)
			buffer.appendf("<AutoRefresh>%d</AutoRefresh>", n);
	}
	if (keepRootTag)
		buffer.append("</TpThorStatusResponse>");
}

bool CTpThorStatusResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
		hasValue |= m_Name.unmarshall(rpc_request, "Name", basepath);
		hasValue |= m_Queue.unmarshall(rpc_request, "Queue", basepath);
		hasValue |= m_Group.unmarshall(rpc_request, "Group", basepath);
		hasValue |= m_ThorMasterIPAddress.unmarshall(rpc_request, "ThorMasterIPAddress", basepath);
		hasValue |= m_Port.unmarshall(rpc_request, "Port", basepath);
		hasValue |= m_StartTime.unmarshall(rpc_request, "StartTime", basepath);
		hasValue |= m_LogFile.unmarshall(rpc_request, "LogFile", basepath);
		hasValue |= m_Wuid.unmarshall(rpc_request, "Wuid", basepath);
		hasValue |= m_Graph.unmarshall(rpc_request, "Graph", basepath);
		hasValue |= m_SubGraph.unmarshall(rpc_request, "SubGraph", basepath);
		hasValue |= m_SubGraphDuration.unmarshall(rpc_request, "SubGraphDuration", basepath);
		hasValue |= m_AutoRefresh.unmarshall(rpc_request, "AutoRefresh", basepath);
	}
	return hasValue;
}

bool CTpThorStatusResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Name.unmarshall(ctx, soapval, "Name");
	hasValue |= m_Queue.unmarshall(ctx, soapval, "Queue");
	hasValue |= m_Group.unmarshall(ctx, soapval, "Group");
	hasValue |= m_ThorMasterIPAddress.unmarshall(ctx, soapval, "ThorMasterIPAddress");
	hasValue |= m_Port.unmarshall(ctx, soapval, "Port");
	hasValue |= m_StartTime.unmarshall(ctx, soapval, "StartTime");
	hasValue |= m_LogFile.unmarshall(ctx, soapval, "LogFile");
	hasValue |= m_Wuid.unmarshall(ctx, soapval, "Wuid");
	hasValue |= m_Graph.unmarshall(ctx, soapval, "Graph");
	hasValue |= m_SubGraph.unmarshall(ctx, soapval, "SubGraph");
	hasValue |= m_SubGraphDuration.unmarshall(ctx, soapval, "SubGraphDuration");
	hasValue |= m_AutoRefresh.unmarshall(ctx, soapval, "AutoRefresh");
	return hasValue;
}

bool CTpThorStatusResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Name.unmarshall(ctx, params, attachments, "Name", basepath);
	hasValue |= m_Queue.unmarshall(ctx, params, attachments, "Queue", basepath);
	hasValue |= m_Group.unmarshall(ctx, params, attachments, "Group", basepath);
	hasValue |= m_ThorMasterIPAddress.unmarshall(ctx, params, attachments, "ThorMasterIPAddress", basepath);
	hasValue |= m_Port.unmarshall(ctx, params, attachments, "Port", basepath);
	hasValue |= m_StartTime.unmarshall(ctx, params, attachments, "StartTime", basepath);
	hasValue |= m_LogFile.unmarshall(ctx, params, attachments, "LogFile", basepath);
	hasValue |= m_Wuid.unmarshall(ctx, params, attachments, "Wuid", basepath);
	hasValue |= m_Graph.unmarshall(ctx, params, attachments, "Graph", basepath);
	hasValue |= m_SubGraph.unmarshall(ctx, params, attachments, "SubGraph", basepath);
	hasValue |= m_SubGraphDuration.unmarshall(ctx, params, attachments, "SubGraphDuration", basepath);
	hasValue |= m_AutoRefresh.unmarshall(ctx, params, attachments, "AutoRefresh", basepath);
	return hasValue;
}

const char * CTpThorStatusResponse::getName() { return m_Name.query();}
const char * CTpThorStatusResponse::getQueue() { return m_Queue.query();}
const char * CTpThorStatusResponse::getGroup() { return m_Group.query();}
const char * CTpThorStatusResponse::getThorMasterIPAddress() { return m_ThorMasterIPAddress.query();}
int CTpThorStatusResponse::getPort() { return m_Port;}
const char * CTpThorStatusResponse::getStartTime() { return m_StartTime.query();}
const char * CTpThorStatusResponse::getLogFile() { return m_LogFile.query();}
const char * CTpThorStatusResponse::getWuid() { return m_Wuid.query();}
const char * CTpThorStatusResponse::getGraph() { return m_Graph.query();}
int CTpThorStatusResponse::getSubGraph() { return m_SubGraph;}
int CTpThorStatusResponse::getSubGraphDuration() { return m_SubGraphDuration;}
int CTpThorStatusResponse::getAutoRefresh() { return m_AutoRefresh;}
void CTpThorStatusResponse::setName(const char * val){ m_Name.set(val); }
void CTpThorStatusResponse::setQueue(const char * val){ m_Queue.set(val); }
void CTpThorStatusResponse::setGroup(const char * val){ m_Group.set(val); }
void CTpThorStatusResponse::setThorMasterIPAddress(const char * val){ m_ThorMasterIPAddress.set(val); }
void CTpThorStatusResponse::setPort(int val){ m_Port=val; }
void CTpThorStatusResponse::setStartTime(const char * val){ m_StartTime.set(val); }
void CTpThorStatusResponse::setLogFile(const char * val){ m_LogFile.set(val); }
void CTpThorStatusResponse::setWuid(const char * val){ m_Wuid.set(val); }
void CTpThorStatusResponse::setGraph(const char * val){ m_Graph.set(val); }
void CTpThorStatusResponse::setSubGraph(int val){ m_SubGraph=val; }
void CTpThorStatusResponse::setSubGraphDuration(int val){ m_SubGraphDuration=val; }
void CTpThorStatusResponse::setAutoRefresh(int val){ m_AutoRefresh=val; }
extern "C"  IEspTpThorStatusResponse *createTpThorStatusResponse(const char *serv){return ((IEspTpThorStatusResponse *)new CTpThorStatusResponse(serv));}
extern "C"  IClientTpThorStatusResponse *createClientTpThorStatusResponse(const char *serv){return ((IClientTpThorStatusResponse *)new CTpThorStatusResponse(serv));}

//=======================================================
// class CTpGetServicePluginsRequest Implementation
//=======================================================

CTpGetServicePluginsRequest::CTpGetServicePluginsRequest(const char *serviceName, IRpcMessageBinding *init)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("TpGetServicePluginsRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CTpGetServicePluginsRequest::CTpGetServicePluginsRequest(const char *serviceName, const char *bc)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("TpGetServicePluginsRequest");
}

CTpGetServicePluginsRequest::CTpGetServicePluginsRequest(const char *serviceName, IRpcMessage* rpcmsg)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("TpGetServicePluginsRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CTpGetServicePluginsRequest::CTpGetServicePluginsRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("TpGetServicePluginsRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CTpGetServicePluginsRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType><xsd:all/></xsd:complexType></xsd:element>\n", msgTypeName);
		}
	}
	return schema;
}

void CTpGetServicePluginsRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CTpGetServicePluginsRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CTpGetServicePluginsRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CTpGetServicePluginsRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CTpGetServicePluginsRequest::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

}


void CTpGetServicePluginsRequest::copy(CTpGetServicePluginsRequest &from)
{
}


void CTpGetServicePluginsRequest::copy(IConstTpGetServicePluginsRequest &ifrom)
{
}


void CTpGetServicePluginsRequest::getAttributes(IProperties &attributes)
{
}


void CTpGetServicePluginsRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
}


void CTpGetServicePluginsRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CTpGetServicePluginsRequest::serializer(IEspContext* ctx, IConstTpGetServicePluginsRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<TpGetServicePluginsRequest>");
	if (keepRootTag)
		buffer.append("</TpGetServicePluginsRequest>");
}

bool CTpGetServicePluginsRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	return hasValue;
}

bool CTpGetServicePluginsRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	return hasValue;
}

bool CTpGetServicePluginsRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	return hasValue;
}

extern "C"  IEspTpGetServicePluginsRequest *createTpGetServicePluginsRequest(const char *serv){return ((IEspTpGetServicePluginsRequest *)new CTpGetServicePluginsRequest(serv));}
extern "C"  IClientTpGetServicePluginsRequest *createClientTpGetServicePluginsRequest(const char *serv){return ((IClientTpGetServicePluginsRequest *)new CTpGetServicePluginsRequest(serv));}

//=======================================================
// class CTpGetServicePluginsResponse Implementation
//=======================================================

CTpGetServicePluginsResponse::CTpGetServicePluginsResponse(const char *serviceName, IRpcMessageBinding *init)
	: m_Plugins(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("TpGetServicePluginsResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CTpGetServicePluginsResponse::CTpGetServicePluginsResponse(const char *serviceName, const char *bc)
	: m_Plugins(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("TpGetServicePluginsResponse");
}

CTpGetServicePluginsResponse::CTpGetServicePluginsResponse(const char *serviceName, IRpcMessage* rpcmsg)
	: m_Plugins(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("TpGetServicePluginsResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CTpGetServicePluginsResponse::CTpGetServicePluginsResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_Plugins(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("TpGetServicePluginsResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CTpGetServicePluginsResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		schema.append("<xsd:element name=\"Exceptions\" type=\"tns:ArrayOfEspException\" minOccurs=\"0\" maxOccurs=\"1\"/>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Plugins\">\n");
		schema.append("<xsd:complexType><xsd:sequence>\n");
		schema.append("<xsd:element minOccurs=\"0\" maxOccurs=\"unbounded\" name=\"Plugin\" type=\"tns:TpEspServicePlugin\"/>");
		schema.append("</xsd:sequence></xsd:complexType>");
		schema.append("</xsd:element>");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	if (!(flags & 0x10)  || (flags & 0x100))
	{
		CTpEspServicePlugin::getXsdDefinition(context, request, schema, added);
	}
	return schema;
}

void CTpGetServicePluginsResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CTpGetServicePluginsResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
	if (!added.getValue("TpEspServicePlugin"))
	{
		added.setValue("TpEspServicePlugin",1);
		CTpEspServicePlugin::getMapInfo(info,added);
	}
}

StringBuffer &CTpGetServicePluginsResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Plugins");
	form.appendf("<tr><td><b>Plugins: </b></td><td>");
	form.appendf("<table><tr><td><textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea></td>", extfix.str());
	form.append("</tr></table>");
	form.append("</td></tr>");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CTpGetServicePluginsResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CTpGetServicePluginsResponse::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	rpc_resp.setEncodeXml(false);
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
		m_Plugins.marshall(rpc_resp, "Plugins", "Plugin");
	}
}


void CTpGetServicePluginsResponse::copy(CTpGetServicePluginsResponse &from)
{
	m_Plugins.copy(from.m_Plugins);
}


void CTpGetServicePluginsResponse::copy(IConstTpGetServicePluginsResponse &ifrom)
{
	setPlugins(ifrom.getPlugins());
}


void CTpGetServicePluginsResponse::getAttributes(IProperties &attributes)
{
}


void CTpGetServicePluginsResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
		m_Plugins.toStr(ctx, buffer, "Plugins", "Plugin");
	}
}


void CTpGetServicePluginsResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CTpGetServicePluginsResponse::serializer(IEspContext* ctx, IConstTpGetServicePluginsResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<TpGetServicePluginsResponse>");
	// field Plugins
	{
		IArrayOf<IConstTpEspServicePlugin>& v = src.getPlugins();
		int size = v.length();
		if (size>0)
			buffer.append("<Plugins>");
		for (int i=0;i<size;i++)
		{
			buffer.append("<Plugin>");
			CTpEspServicePlugin::serializer(ctx,v.item(i),buffer,false);
			buffer.append("</Plugin>");
		}
		if (size>0)
			buffer.append("</Plugins>");
	}
	if (keepRootTag)
		buffer.append("</TpGetServicePluginsResponse>");
}

bool CTpGetServicePluginsResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
		hasValue |= m_Plugins.unmarshall(rpc_request, "Plugins", basepath);
	}
	return hasValue;
}

bool CTpGetServicePluginsResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Plugins.unmarshall(ctx, soapval, "Plugins");
	return hasValue;
}

bool CTpGetServicePluginsResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Plugins.unmarshall(ctx, params, attachments, "Plugins", basepath);
	return hasValue;
}

IArrayOf<IConstTpEspServicePlugin> & CTpGetServicePluginsResponse::getPlugins() { return (IArrayOf<IConstTpEspServicePlugin> &) m_Plugins; }
void CTpGetServicePluginsResponse::setPlugins(IArrayOf<IEspTpEspServicePlugin> &val)
{
	m_Plugins->kill();
	IArrayOf<IConstTpEspServicePlugin> &target = m_Plugins.getValue();
	ForEachItemIn(idx, val)
	{
		IEspTpEspServicePlugin &item = (val).item(idx);
		item.Link();
		target.append(item);
	}
}
void CTpGetServicePluginsResponse::setPlugins(IArrayOf<IConstTpEspServicePlugin> &val)
{
	m_Plugins->kill();
	IArrayOf<IConstTpEspServicePlugin> &target = m_Plugins.getValue();
	ForEachItemIn(idx, val)
	{
		IConstTpEspServicePlugin &item = val.item(idx);
		item.Link();
		target.append(item);
	}
}
extern "C"  IEspTpGetServicePluginsResponse *createTpGetServicePluginsResponse(const char *serv){return ((IEspTpGetServicePluginsResponse *)new CTpGetServicePluginsResponse(serv));}
extern "C"  IClientTpGetServicePluginsResponse *createClientTpGetServicePluginsResponse(const char *serv){return ((IClientTpGetServicePluginsResponse *)new CTpGetServicePluginsResponse(serv));}

//=======================================================
// class CTpDropZoneQueryRequest Implementation
//=======================================================

CTpDropZoneQueryRequest::CTpDropZoneQueryRequest(const char *serviceName, IRpcMessageBinding *init)
	: m_Name(nilIgnore),m_ECLWatchVisibleOnly(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("TpDropZoneQueryRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CTpDropZoneQueryRequest::CTpDropZoneQueryRequest(const char *serviceName, const char *bc)
	: m_Name(nilIgnore),m_ECLWatchVisibleOnly(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("TpDropZoneQueryRequest");
}

CTpDropZoneQueryRequest::CTpDropZoneQueryRequest(const char *serviceName, IRpcMessage* rpcmsg)
	: m_Name(nilIgnore),m_ECLWatchVisibleOnly(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("TpDropZoneQueryRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CTpDropZoneQueryRequest::CTpDropZoneQueryRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_Name(nilIgnore),m_ECLWatchVisibleOnly(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("TpDropZoneQueryRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CTpDropZoneQueryRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Name\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"ECLWatchVisibleOnly\" type=\"xsd:boolean\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CTpDropZoneQueryRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CTpDropZoneQueryRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CTpDropZoneQueryRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Name");
	form.appendf("  <tr><td><b>Name: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("ECLWatchVisibleOnly");
	
	form.appendf("  <tr><td><b>ECLWatchVisibleOnly? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CTpDropZoneQueryRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CTpDropZoneQueryRequest::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_Name.marshall(rpc_resp, "Name", "", "", "");
	m_ECLWatchVisibleOnly.marshall(rpc_resp, "ECLWatchVisibleOnly", "", "", "");
}


void CTpDropZoneQueryRequest::copy(CTpDropZoneQueryRequest &from)
{
	m_Name.copy(from.m_Name);
	m_ECLWatchVisibleOnly.copy(from.m_ECLWatchVisibleOnly);
}


void CTpDropZoneQueryRequest::copy(IConstTpDropZoneQueryRequest &ifrom)
{
	setName(ifrom.getName());
	setECLWatchVisibleOnly(ifrom.getECLWatchVisibleOnly());
}


void CTpDropZoneQueryRequest::getAttributes(IProperties &attributes)
{
}


void CTpDropZoneQueryRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_Name.toStr(ctx, buffer, "Name", "", true, "", "");
	m_ECLWatchVisibleOnly.toStr(ctx, buffer, "ECLWatchVisibleOnly", "", true, "", "");
}


void CTpDropZoneQueryRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CTpDropZoneQueryRequest::serializer(IEspContext* ctx, IConstTpDropZoneQueryRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<TpDropZoneQueryRequest>");
	// field Name
	{
		const char* s = src.getName();
		if (s && *s)
		{
			buffer.append("<Name>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Name>");
		}
	}
	// field ECLWatchVisibleOnly
	{
		bool b = src.getECLWatchVisibleOnly();
		if (b)
			buffer.appendf("<ECLWatchVisibleOnly>1</ECLWatchVisibleOnly>");
	}
	if (keepRootTag)
		buffer.append("</TpDropZoneQueryRequest>");
}

bool CTpDropZoneQueryRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_Name.unmarshall(rpc_request, "Name", basepath);
	hasValue |= m_ECLWatchVisibleOnly.unmarshall(rpc_request, "ECLWatchVisibleOnly", basepath);
	return hasValue;
}

bool CTpDropZoneQueryRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Name.unmarshall(ctx, soapval, "Name");
	hasValue |= m_ECLWatchVisibleOnly.unmarshall(ctx, soapval, "ECLWatchVisibleOnly");
	return hasValue;
}

bool CTpDropZoneQueryRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Name.unmarshall(ctx, params, attachments, "Name", basepath);
	hasValue |= m_ECLWatchVisibleOnly.unmarshall(ctx, params, attachments, "ECLWatchVisibleOnly", basepath);
	return hasValue;
}

const char * CTpDropZoneQueryRequest::getName() { return m_Name.query();}
bool CTpDropZoneQueryRequest::getECLWatchVisibleOnly() { return m_ECLWatchVisibleOnly;}
void CTpDropZoneQueryRequest::setName(const char * val){ m_Name.set(val); }
void CTpDropZoneQueryRequest::setECLWatchVisibleOnly(bool val){ m_ECLWatchVisibleOnly=val; }
extern "C"  IEspTpDropZoneQueryRequest *createTpDropZoneQueryRequest(const char *serv){return ((IEspTpDropZoneQueryRequest *)new CTpDropZoneQueryRequest(serv));}
extern "C"  IClientTpDropZoneQueryRequest *createClientTpDropZoneQueryRequest(const char *serv){return ((IClientTpDropZoneQueryRequest *)new CTpDropZoneQueryRequest(serv));}

//=======================================================
// class CTpDropZoneQueryResponse Implementation
//=======================================================

CTpDropZoneQueryResponse::CTpDropZoneQueryResponse(const char *serviceName, IRpcMessageBinding *init)
	: m_TpDropZones(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("TpDropZoneQueryResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CTpDropZoneQueryResponse::CTpDropZoneQueryResponse(const char *serviceName, const char *bc)
	: m_TpDropZones(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("TpDropZoneQueryResponse");
}

CTpDropZoneQueryResponse::CTpDropZoneQueryResponse(const char *serviceName, IRpcMessage* rpcmsg)
	: m_TpDropZones(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("TpDropZoneQueryResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CTpDropZoneQueryResponse::CTpDropZoneQueryResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_TpDropZones(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("TpDropZoneQueryResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CTpDropZoneQueryResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		schema.append("<xsd:element name=\"Exceptions\" type=\"tns:ArrayOfEspException\" minOccurs=\"0\" maxOccurs=\"1\"/>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"TpDropZones\" type=\"tns:ArrayOfTpDropZone\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	if (!(flags & 0x10)  || (flags & 0x100))
	{
		CTpDropZone::getXsdDefinition(context, request, schema, added);
	}
	if (added.getValue("TpDropZone") && added.getValue("ArrayOfTpDropZone")==NULL) {
		schema.append("<xsd:complexType name=\"ArrayOfTpDropZone\">\n");
		schema.append("<xsd:sequence>\n");
		schema.append("<xsd:element minOccurs=\"0\" maxOccurs=\"unbounded\" name=\"TpDropZone\" type=\"tns:TpDropZone\"/>\n");
		schema.append("</xsd:sequence>\n");
		schema.append("</xsd:complexType>\n");
		added.setValue("ArrayOfTpDropZone",1);
	}
	return schema;
}

void CTpDropZoneQueryResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CTpDropZoneQueryResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
	if (!added.getValue("TpDropZone"))
	{
		added.setValue("TpDropZone",1);
		CTpDropZone::getMapInfo(info,added);
	}
}

StringBuffer &CTpDropZoneQueryResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("TpDropZones");
	form.appendf("<tr><td><b>TpDropZones: </b></td><td>");
	form.appendf("<table><tr><td><textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea></td>", extfix.str());
	form.append("</tr></table>");
	form.append("</td></tr>");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CTpDropZoneQueryResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CTpDropZoneQueryResponse::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
		m_TpDropZones.marshall(rpc_resp, "TpDropZones", "TpDropZone");
	}
}


void CTpDropZoneQueryResponse::copy(CTpDropZoneQueryResponse &from)
{
	m_TpDropZones.copy(from.m_TpDropZones);
}


void CTpDropZoneQueryResponse::copy(IConstTpDropZoneQueryResponse &ifrom)
{
	setTpDropZones(ifrom.getTpDropZones());
}


void CTpDropZoneQueryResponse::getAttributes(IProperties &attributes)
{
}


void CTpDropZoneQueryResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
		m_TpDropZones.toStr(ctx, buffer, "TpDropZones", "TpDropZone");
	}
}


void CTpDropZoneQueryResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CTpDropZoneQueryResponse::serializer(IEspContext* ctx, IConstTpDropZoneQueryResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<TpDropZoneQueryResponse>");
	// field TpDropZones
	{
		IArrayOf<IConstTpDropZone>& v = src.getTpDropZones();
		int size = v.length();
		if (size>0)
			buffer.append("<TpDropZones>");
		for (int i=0;i<size;i++)
		{
			buffer.append("<Item>");
			CTpDropZone::serializer(ctx,v.item(i),buffer,false);
			buffer.append("</Item>");
		}
		if (size>0)
			buffer.append("</TpDropZones>");
	}
	if (keepRootTag)
		buffer.append("</TpDropZoneQueryResponse>");
}

bool CTpDropZoneQueryResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
		hasValue |= m_TpDropZones.unmarshall(rpc_request, "TpDropZones", basepath);
	}
	return hasValue;
}

bool CTpDropZoneQueryResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_TpDropZones.unmarshall(ctx, soapval, "TpDropZones");
	return hasValue;
}

bool CTpDropZoneQueryResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_TpDropZones.unmarshall(ctx, params, attachments, "TpDropZones", basepath);
	return hasValue;
}

IArrayOf<IConstTpDropZone> & CTpDropZoneQueryResponse::getTpDropZones() { return (IArrayOf<IConstTpDropZone> &) m_TpDropZones; }
void CTpDropZoneQueryResponse::setTpDropZones(IArrayOf<IEspTpDropZone> &val)
{
	m_TpDropZones->kill();
	IArrayOf<IConstTpDropZone> &target = m_TpDropZones.getValue();
	ForEachItemIn(idx, val)
	{
		IEspTpDropZone &item = (val).item(idx);
		item.Link();
		target.append(item);
	}
}
void CTpDropZoneQueryResponse::setTpDropZones(IArrayOf<IConstTpDropZone> &val)
{
	m_TpDropZones->kill();
	IArrayOf<IConstTpDropZone> &target = m_TpDropZones.getValue();
	ForEachItemIn(idx, val)
	{
		IConstTpDropZone &item = val.item(idx);
		item.Link();
		target.append(item);
	}
}
extern "C"  IEspTpDropZoneQueryResponse *createTpDropZoneQueryResponse(const char *serv){return ((IEspTpDropZoneQueryResponse *)new CTpDropZoneQueryResponse(serv));}
extern "C"  IClientTpDropZoneQueryResponse *createClientTpDropZoneQueryResponse(const char *serv){return ((IClientTpDropZoneQueryResponse *)new CTpDropZoneQueryResponse(serv));}

//=======================================================
// class CWsTopologyPingRequest Implementation
//=======================================================

CWsTopologyPingRequest::CWsTopologyPingRequest(const char *serviceName, IRpcMessageBinding *init)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("WsTopologyPingRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CWsTopologyPingRequest::CWsTopologyPingRequest(const char *serviceName, const char *bc)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("WsTopologyPingRequest");
}

CWsTopologyPingRequest::CWsTopologyPingRequest(const char *serviceName, IRpcMessage* rpcmsg)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("WsTopologyPingRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CWsTopologyPingRequest::CWsTopologyPingRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("WsTopologyPingRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CWsTopologyPingRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType><xsd:all/></xsd:complexType></xsd:element>\n", msgTypeName);
		}
	}
	return schema;
}

void CWsTopologyPingRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CWsTopologyPingRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CWsTopologyPingRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CWsTopologyPingRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CWsTopologyPingRequest::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

}


void CWsTopologyPingRequest::copy(CWsTopologyPingRequest &from)
{
}


void CWsTopologyPingRequest::copy(IConstWsTopologyPingRequest &ifrom)
{
}


void CWsTopologyPingRequest::getAttributes(IProperties &attributes)
{
}


void CWsTopologyPingRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
}


void CWsTopologyPingRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CWsTopologyPingRequest::serializer(IEspContext* ctx, IConstWsTopologyPingRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<WsTopologyPingRequest>");
	if (keepRootTag)
		buffer.append("</WsTopologyPingRequest>");
}

bool CWsTopologyPingRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	return hasValue;
}

bool CWsTopologyPingRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	return hasValue;
}

bool CWsTopologyPingRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	return hasValue;
}

extern "C"  IEspWsTopologyPingRequest *createWsTopologyPingRequest(const char *serv){return ((IEspWsTopologyPingRequest *)new CWsTopologyPingRequest(serv));}
extern "C"  IClientWsTopologyPingRequest *createClientWsTopologyPingRequest(const char *serv){return ((IClientWsTopologyPingRequest *)new CWsTopologyPingRequest(serv));}

//=======================================================
// class CWsTopologyPingResponse Implementation
//=======================================================

CWsTopologyPingResponse::CWsTopologyPingResponse(const char *serviceName, IRpcMessageBinding *init)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("WsTopologyPingResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CWsTopologyPingResponse::CWsTopologyPingResponse(const char *serviceName, const char *bc)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("WsTopologyPingResponse");
}

CWsTopologyPingResponse::CWsTopologyPingResponse(const char *serviceName, IRpcMessage* rpcmsg)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("WsTopologyPingResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CWsTopologyPingResponse::CWsTopologyPingResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("WsTopologyPingResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CWsTopologyPingResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType><xsd:all/></xsd:complexType></xsd:element>\n", msgTypeName);
		}
	}
	return schema;
}

void CWsTopologyPingResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CWsTopologyPingResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CWsTopologyPingResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CWsTopologyPingResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CWsTopologyPingResponse::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
	}
}


void CWsTopologyPingResponse::copy(CWsTopologyPingResponse &from)
{
}


void CWsTopologyPingResponse::copy(IConstWsTopologyPingResponse &ifrom)
{
}


void CWsTopologyPingResponse::getAttributes(IProperties &attributes)
{
}


void CWsTopologyPingResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
	}
}


void CWsTopologyPingResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CWsTopologyPingResponse::serializer(IEspContext* ctx, IConstWsTopologyPingResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<WsTopologyPingResponse>");
	if (keepRootTag)
		buffer.append("</WsTopologyPingResponse>");
}

bool CWsTopologyPingResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
	}
	return hasValue;
}

bool CWsTopologyPingResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	return hasValue;
}

bool CWsTopologyPingResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	return hasValue;
}

extern "C"  IEspWsTopologyPingResponse *createWsTopologyPingResponse(const char *serv){return ((IEspWsTopologyPingResponse *)new CWsTopologyPingResponse(serv));}
extern "C"  IClientWsTopologyPingResponse *createClientWsTopologyPingResponse(const char *serv){return ((IClientWsTopologyPingResponse *)new CWsTopologyPingResponse(serv));}

//=======================================================
// class CWsTopologySoapBinding Implementation
//=======================================================

CWsTopologySoapBinding::CWsTopologySoapBinding(http_soap_log_level level):CHttpSoapBinding(NULL, NULL, NULL, level)
{
	init_strings();
	setWsdlVersion(1.28);
}

CWsTopologySoapBinding::CWsTopologySoapBinding(IPropertyTree* cfg, const char *bindname, const char *procname, http_soap_log_level level):CHttpSoapBinding(cfg, bindname, procname, level)
{
	init_strings(); 
	setWsdlVersion(1.28);

}

void CWsTopologySoapBinding::init_strings()
{
	setCacheTimeout("TpClusterInfo", 180, 1);
	m_cacheMethodCount++;
	setCacheTimeout("TpClusterQuery", 180, 1);
	m_cacheMethodCount++;
	setCacheTimeout("TpDropZoneQuery", 180, 1);
	m_cacheMethodCount++;
	setCacheTimeout("TpGetServicePlugins", 180, 1);
	m_cacheMethodCount++;
	setCacheTimeout("TpGroupQuery", 180, 1);
	m_cacheMethodCount++;
	setCacheTimeout("TpListTargetClusters", 180, 1);
	m_cacheMethodCount++;
	setCacheTimeout("TpLogicalClusterQuery", 180, 1);
	m_cacheMethodCount++;
	setCacheTimeout("TpMachineInfo", 180, 1);
	m_cacheMethodCount++;
	setCacheTimeout("TpMachineQuery", 180, 1);
	m_cacheMethodCount++;
	setCacheTimeout("TpServiceQuery", 180, 1);
	m_cacheMethodCount++;
	setCacheTimeout("TpTargetClusterQuery", 180, 1);
	m_cacheMethodCount++;
	setCacheTimeout("TpThorStatus", 180, 1);
	m_cacheMethodCount++;
	setCacheTimeout("TpXMLFile", 180, 0);
	m_cacheMethodCount++;
	setCacheGroupID(nullptr, "ESPWsTP");
}

int CWsTopologySoapBinding::processRequest(IRpcMessage* rpc_call, IRpcMessage* rpc_response)
{
	if(rpc_call == NULL || rpc_response == NULL)
		return -1;

	IEspContext *ctx=rpc_call->queryContext();
	DBGLOG("Client version: %g", ctx->getClientVersion());
	StringBuffer serviceName;
	double clientVer=(ctx) ? ctx->getClientVersion() : 0.0;
	qualifyServiceName(*ctx, ctx->queryServiceName(NULL), NULL, serviceName, NULL);
	CRpcCall* thecall = static_cast<CRpcCall *>(rpc_call);
	CRpcResponse* response = static_cast<CRpcResponse*>(rpc_response);
	CHttpRequest* httprequest = thecall->getHttpReq();
	CHttpResponse* httpresponse = response->getHttpResp();

	Owned<IEspWsTopology> iserv = (IEspWsTopology*)getService();
	if(iserv == NULL)
	{
		response->set_status(SOAP_SERVER_ERROR);
		response->set_err("Service not available");
		DBGLOG("Service not available");
		return -1;
	}
	if (thecall->get_name() == NULL)
	{
		response->set_status(SOAP_CLIENT_ERROR);
		response->set_err("No service method specified");
		ERRLOG("No service method specified");
		return -1;
	}

	IEspContext& context = *rpc_call->queryContext();

	if(!stricmp(thecall->get_name(), "Ping")||!stricmp(thecall->get_name(), "WsTopologyPingRequest"))
	{
		Owned<CWsTopologyPingRequest> esp_request = new CWsTopologyPingRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CWsTopologyPingResponse> esp_response = new CWsTopologyPingResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		StringBuffer source;
		source.appendf("WsTopology::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "WsTopology", "Ping");
			iserv->onPing(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "WsTopology", "Ping");
		response->set_name("WsTopologyPingResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "SystemLog")||!stricmp(thecall->get_name(), "SystemLogRequest"))
	{
		Owned<CSystemLogRequest> esp_request = new CSystemLogRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CSystemLogResponse> esp_response = new CSystemLogResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		StringBuffer source;
		source.appendf("WsTopology::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "WsTopology", "SystemLog");
			iserv->onSystemLog(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "WsTopology", "SystemLog");
		response->set_name("SystemLogResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "TpClusterInfo")||!stricmp(thecall->get_name(), "TpClusterInfoRequest"))
	{
		Owned<CTpClusterInfoRequest> esp_request = new CTpClusterInfoRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CTpClusterInfoResponse> esp_response = new CTpClusterInfoResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		StringBuffer source;
		source.appendf("WsTopology::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "WsTopology", "TpClusterInfo");
			iserv->onTpClusterInfo(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "WsTopology", "TpClusterInfo");
		response->set_name("TpClusterInfoResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "TpClusterQuery")||!stricmp(thecall->get_name(), "TpClusterQueryRequest"))
	{
		Owned<CTpClusterQueryRequest> esp_request = new CTpClusterQueryRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CTpClusterQueryResponse> esp_response = new CTpClusterQueryResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		StringBuffer source;
		source.appendf("WsTopology::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "WsTopology", "TpClusterQuery");
			iserv->onTpClusterQuery(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "WsTopology", "TpClusterQuery");
		response->set_name("TpClusterQueryResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "TpDropZoneQuery")||!stricmp(thecall->get_name(), "TpDropZoneQueryRequest"))
	{
		Owned<CTpDropZoneQueryRequest> esp_request = new CTpDropZoneQueryRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CTpDropZoneQueryResponse> esp_response = new CTpDropZoneQueryResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		StringBuffer source;
		source.appendf("WsTopology::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			if (clientVer!=-1.0 && clientVer<1.26)
				throw MakeStringException(-1, "Client version is too old, please update your client application.");			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "WsTopology", "TpDropZoneQuery");
			iserv->onTpDropZoneQuery(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "WsTopology", "TpDropZoneQuery");
		response->set_name("TpDropZoneQueryResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "TpGetComponentFile")||!stricmp(thecall->get_name(), "TpGetComponentFileRequest"))
	{
		Owned<CTpGetComponentFileRequest> esp_request = new CTpGetComponentFileRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CTpGetComponentFileResponse> esp_response = new CTpGetComponentFileResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		StringBuffer source;
		source.appendf("WsTopology::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "WsTopology", "TpGetComponentFile");
			iserv->onTpGetComponentFile(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "WsTopology", "TpGetComponentFile");
		response->set_name("TpGetComponentFileResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "TpGetServicePlugins")||!stricmp(thecall->get_name(), "TpGetServicePluginsRequest"))
	{
		Owned<CTpGetServicePluginsRequest> esp_request = new CTpGetServicePluginsRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CTpGetServicePluginsResponse> esp_response = new CTpGetServicePluginsResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		StringBuffer source;
		source.appendf("WsTopology::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "WsTopology", "TpGetServicePlugins");
			iserv->onTpGetServicePlugins(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "WsTopology", "TpGetServicePlugins");
		response->set_name("TpGetServicePluginsResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "TpGroupQuery")||!stricmp(thecall->get_name(), "TpGroupQueryRequest"))
	{
		Owned<CTpGroupQueryRequest> esp_request = new CTpGroupQueryRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CTpGroupQueryResponse> esp_response = new CTpGroupQueryResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		StringBuffer source;
		source.appendf("WsTopology::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "WsTopology", "TpGroupQuery");
			iserv->onTpGroupQuery(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "WsTopology", "TpGroupQuery");
		response->set_name("TpGroupQueryResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "TpListTargetClusters")||!stricmp(thecall->get_name(), "TpListTargetClustersRequest"))
	{
		Owned<CTpListTargetClustersRequest> esp_request = new CTpListTargetClustersRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CTpListTargetClustersResponse> esp_response = new CTpListTargetClustersResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		StringBuffer source;
		source.appendf("WsTopology::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "WsTopology", "TpListTargetClusters");
			iserv->onTpListTargetClusters(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "WsTopology", "TpListTargetClusters");
		response->set_name("TpListTargetClustersResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "TpLogFile")||!stricmp(thecall->get_name(), "TpLogFileRequest"))
	{
		Owned<CTpLogFileRequest> esp_request = new CTpLogFileRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CTpLogFileResponse> esp_response = new CTpLogFileResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		StringBuffer source;
		source.appendf("WsTopology::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "WsTopology", "TpLogFile");
			iserv->onTpLogFile(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "WsTopology", "TpLogFile");
		response->set_name("TpLogFileResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "TpLogFileDisplay")||!stricmp(thecall->get_name(), "TpLogFileRequest"))
	{
		Owned<CTpLogFileRequest> esp_request = new CTpLogFileRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CTpLogFileResponse> esp_response = new CTpLogFileResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		StringBuffer source;
		source.appendf("WsTopology::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "WsTopology", "TpLogFileDisplay");
			iserv->onTpLogFileDisplay(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "WsTopology", "TpLogFileDisplay");
		response->set_name("TpLogFileResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "TpLogicalClusterQuery")||!stricmp(thecall->get_name(), "TpLogicalClusterQueryRequest"))
	{
		Owned<CTpLogicalClusterQueryRequest> esp_request = new CTpLogicalClusterQueryRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CTpLogicalClusterQueryResponse> esp_response = new CTpLogicalClusterQueryResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		StringBuffer source;
		source.appendf("WsTopology::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "WsTopology", "TpLogicalClusterQuery");
			iserv->onTpLogicalClusterQuery(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "WsTopology", "TpLogicalClusterQuery");
		response->set_name("TpLogicalClusterQueryResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "TpMachineInfo")||!stricmp(thecall->get_name(), "TpMachineInfoRequest"))
	{
		Owned<CTpMachineInfoRequest> esp_request = new CTpMachineInfoRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CTpMachineInfoResponse> esp_response = new CTpMachineInfoResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		StringBuffer source;
		source.appendf("WsTopology::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			if (clientVer!=-1.0 && clientVer<1.25)
				throw MakeStringException(-1, "Client version is too old, please update your client application.");			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "WsTopology", "TpMachineInfo");
			iserv->onTpMachineInfo(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "WsTopology", "TpMachineInfo");
		response->set_name("TpMachineInfoResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "TpMachineQuery")||!stricmp(thecall->get_name(), "TpMachineQueryRequest"))
	{
		Owned<CTpMachineQueryRequest> esp_request = new CTpMachineQueryRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CTpMachineQueryResponse> esp_response = new CTpMachineQueryResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		StringBuffer source;
		source.appendf("WsTopology::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "WsTopology", "TpMachineQuery");
			iserv->onTpMachineQuery(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "WsTopology", "TpMachineQuery");
		response->set_name("TpMachineQueryResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "TpServiceQuery")||!stricmp(thecall->get_name(), "TpServiceQueryRequest"))
	{
		Owned<CTpServiceQueryRequest> esp_request = new CTpServiceQueryRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CTpServiceQueryResponse> esp_response = new CTpServiceQueryResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		StringBuffer source;
		source.appendf("WsTopology::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "WsTopology", "TpServiceQuery");
			iserv->onTpServiceQuery(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "WsTopology", "TpServiceQuery");
		response->set_name("TpServiceQueryResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "TpSetMachineStatus")||!stricmp(thecall->get_name(), "TpSetMachineStatusRequest"))
	{
		Owned<CTpSetMachineStatusRequest> esp_request = new CTpSetMachineStatusRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CTpSetMachineStatusResponse> esp_response = new CTpSetMachineStatusResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		StringBuffer source;
		source.appendf("WsTopology::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "WsTopology", "TpSetMachineStatus");
			iserv->onTpSetMachineStatus(context, *esp_request, *esp_response);
			clearCacheByGroupID("ESPWsTP");
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "WsTopology", "TpSetMachineStatus");
		response->set_name("TpSetMachineStatusResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "TpSwapNode")||!stricmp(thecall->get_name(), "TpSwapNodeRequest"))
	{
		Owned<CTpSwapNodeRequest> esp_request = new CTpSwapNodeRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CTpSwapNodeResponse> esp_response = new CTpSwapNodeResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		StringBuffer source;
		source.appendf("WsTopology::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "WsTopology", "TpSwapNode");
			iserv->onTpSwapNode(context, *esp_request, *esp_response);
			clearCacheByGroupID("ESPWsTP");
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "WsTopology", "TpSwapNode");
		response->set_name("TpSwapNodeResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "TpTargetClusterQuery")||!stricmp(thecall->get_name(), "TpTargetClusterQueryRequest"))
	{
		Owned<CTpTargetClusterQueryRequest> esp_request = new CTpTargetClusterQueryRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CTpTargetClusterQueryResponse> esp_response = new CTpTargetClusterQueryResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		StringBuffer source;
		source.appendf("WsTopology::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "WsTopology", "TpTargetClusterQuery");
			iserv->onTpTargetClusterQuery(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "WsTopology", "TpTargetClusterQuery");
		response->set_name("TpTargetClusterQueryResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "TpThorStatus")||!stricmp(thecall->get_name(), "TpThorStatusRequest"))
	{
		Owned<CTpThorStatusRequest> esp_request = new CTpThorStatusRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CTpThorStatusResponse> esp_response = new CTpThorStatusResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		StringBuffer source;
		source.appendf("WsTopology::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "WsTopology", "TpThorStatus");
			iserv->onTpThorStatus(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "WsTopology", "TpThorStatus");
		response->set_name("TpThorStatusResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "TpXMLFile")||!stricmp(thecall->get_name(), "TpXMLFileRequest"))
	{
		Owned<CTpXMLFileRequest> esp_request = new CTpXMLFileRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CTpXMLFileResponse> esp_response = new CTpXMLFileResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		StringBuffer source;
		source.appendf("WsTopology::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "WsTopology", "TpXMLFile");
			iserv->onTpXMLFile(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "WsTopology", "TpXMLFile");
		response->set_name("TpXMLFileResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	response->set_status(SOAP_CLIENT_ERROR);
	StringBuffer msg, svcName;
	msg.appendf("Method %s not available in service %s",thecall->get_name(),getServiceName(svcName).str());
	ERRLOG("%s", msg.str());
	response->set_err(msg);
	return -1;
}

int CWsTopologySoapBinding::getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &content, const char *service, const char *method, bool mda)
{
	BoolHash added;
	if (context.getClientVersion()<=0)
		context.setClientVersion(1.28);

	DBGLOG("Client version: %g", context.getClientVersion());
	bool fullservice = (!Utils::strcasecmp(service, "WsTopology"));
	bool allMethods = (method==NULL || *method==0);
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "Ping"))) || Utils::strcasecmp(method, "Ping")==0)
	{
		CWsTopologyPingRequest::getMapInfo(context.queryMapInfo());
		CWsTopologyPingResponse::getMapInfo(context.queryMapInfo());
		CWsTopologyPingRequest::getXsdDefinition(context, request, "WsTopologyPingRequest", content, added);
		CWsTopologyPingResponse::getXsdDefinition(context, request, content, added);
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "SystemLog"))) || Utils::strcasecmp(method, "SystemLog")==0)
	{
		CSystemLogRequest::getMapInfo(context.queryMapInfo());
		CSystemLogResponse::getMapInfo(context.queryMapInfo());
		CSystemLogRequest::getXsdDefinition(context, request, "SystemLogRequest", content, added);
		CSystemLogResponse::getXsdDefinition(context, request, content, added);
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "TpClusterInfo"))) || Utils::strcasecmp(method, "TpClusterInfo")==0)
	{
		CTpClusterInfoRequest::getMapInfo(context.queryMapInfo());
		CTpClusterInfoResponse::getMapInfo(context.queryMapInfo());
		CTpClusterInfoRequest::getXsdDefinition(context, request, "TpClusterInfoRequest", content, added);
		CTpClusterInfoResponse::getXsdDefinition(context, request, content, added);
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "TpClusterQuery"))) || Utils::strcasecmp(method, "TpClusterQuery")==0)
	{
		CTpClusterQueryRequest::getMapInfo(context.queryMapInfo());
		CTpClusterQueryResponse::getMapInfo(context.queryMapInfo());
		CTpClusterQueryRequest::getXsdDefinition(context, request, "TpClusterQueryRequest", content, added);
		CTpClusterQueryResponse::getXsdDefinition(context, request, content, added);
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "TpDropZoneQuery"))) || Utils::strcasecmp(method, "TpDropZoneQuery")==0)
	{
		if (context.getClientVersion()>=1.26) {
			CTpDropZoneQueryRequest::getMapInfo(context.queryMapInfo());
			CTpDropZoneQueryResponse::getMapInfo(context.queryMapInfo());
			CTpDropZoneQueryRequest::getXsdDefinition(context, request, "TpDropZoneQueryRequest", content, added);
			CTpDropZoneQueryResponse::getXsdDefinition(context, request, content, added);
		}
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "TpGetComponentFile"))) || Utils::strcasecmp(method, "TpGetComponentFile")==0)
	{
		CTpGetComponentFileRequest::getMapInfo(context.queryMapInfo());
		CTpGetComponentFileResponse::getMapInfo(context.queryMapInfo());
		CTpGetComponentFileRequest::getXsdDefinition(context, request, "TpGetComponentFileRequest", content, added);
		CTpGetComponentFileResponse::getXsdDefinition(context, request, content, added);
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "TpGetServicePlugins"))) || Utils::strcasecmp(method, "TpGetServicePlugins")==0)
	{
		CTpGetServicePluginsRequest::getMapInfo(context.queryMapInfo());
		CTpGetServicePluginsResponse::getMapInfo(context.queryMapInfo());
		CTpGetServicePluginsRequest::getXsdDefinition(context, request, "TpGetServicePluginsRequest", content, added);
		CTpGetServicePluginsResponse::getXsdDefinition(context, request, content, added);
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "TpGroupQuery"))) || Utils::strcasecmp(method, "TpGroupQuery")==0)
	{
		CTpGroupQueryRequest::getMapInfo(context.queryMapInfo());
		CTpGroupQueryResponse::getMapInfo(context.queryMapInfo());
		CTpGroupQueryRequest::getXsdDefinition(context, request, "TpGroupQueryRequest", content, added);
		CTpGroupQueryResponse::getXsdDefinition(context, request, content, added);
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "TpListTargetClusters"))) || Utils::strcasecmp(method, "TpListTargetClusters")==0)
	{
		CTpListTargetClustersRequest::getMapInfo(context.queryMapInfo());
		CTpListTargetClustersResponse::getMapInfo(context.queryMapInfo());
		CTpListTargetClustersRequest::getXsdDefinition(context, request, "TpListTargetClustersRequest", content, added);
		CTpListTargetClustersResponse::getXsdDefinition(context, request, content, added);
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "TpLogFile"))) || Utils::strcasecmp(method, "TpLogFile")==0)
	{
		CTpLogFileRequest::getMapInfo(context.queryMapInfo());
		CTpLogFileResponse::getMapInfo(context.queryMapInfo());
		CTpLogFileRequest::getXsdDefinition(context, request, "TpLogFileRequest", content, added);
		CTpLogFileResponse::getXsdDefinition(context, request, content, added);
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "TpLogFileDisplay"))) || Utils::strcasecmp(method, "TpLogFileDisplay")==0)
	{
		CTpLogFileRequest::getMapInfo(context.queryMapInfo());
		CTpLogFileResponse::getMapInfo(context.queryMapInfo());
		CTpLogFileRequest::getXsdDefinition(context, request, "TpLogFileRequest", content, added);
		CTpLogFileResponse::getXsdDefinition(context, request, content, added);
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "TpLogicalClusterQuery"))) || Utils::strcasecmp(method, "TpLogicalClusterQuery")==0)
	{
		CTpLogicalClusterQueryRequest::getMapInfo(context.queryMapInfo());
		CTpLogicalClusterQueryResponse::getMapInfo(context.queryMapInfo());
		CTpLogicalClusterQueryRequest::getXsdDefinition(context, request, "TpLogicalClusterQueryRequest", content, added);
		CTpLogicalClusterQueryResponse::getXsdDefinition(context, request, content, added);
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "TpMachineInfo"))) || Utils::strcasecmp(method, "TpMachineInfo")==0)
	{
		if (context.getClientVersion()>=1.25) {
			CTpMachineInfoRequest::getMapInfo(context.queryMapInfo());
			CTpMachineInfoResponse::getMapInfo(context.queryMapInfo());
			CTpMachineInfoRequest::getXsdDefinition(context, request, "TpMachineInfoRequest", content, added);
			CTpMachineInfoResponse::getXsdDefinition(context, request, content, added);
		}
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "TpMachineQuery"))) || Utils::strcasecmp(method, "TpMachineQuery")==0)
	{
		CTpMachineQueryRequest::getMapInfo(context.queryMapInfo());
		CTpMachineQueryResponse::getMapInfo(context.queryMapInfo());
		CTpMachineQueryRequest::getXsdDefinition(context, request, "TpMachineQueryRequest", content, added);
		CTpMachineQueryResponse::getXsdDefinition(context, request, content, added);
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "TpServiceQuery"))) || Utils::strcasecmp(method, "TpServiceQuery")==0)
	{
		CTpServiceQueryRequest::getMapInfo(context.queryMapInfo());
		CTpServiceQueryResponse::getMapInfo(context.queryMapInfo());
		CTpServiceQueryRequest::getXsdDefinition(context, request, "TpServiceQueryRequest", content, added);
		CTpServiceQueryResponse::getXsdDefinition(context, request, content, added);
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "TpSetMachineStatus"))) || Utils::strcasecmp(method, "TpSetMachineStatus")==0)
	{
		CTpSetMachineStatusRequest::getMapInfo(context.queryMapInfo());
		CTpSetMachineStatusResponse::getMapInfo(context.queryMapInfo());
		CTpSetMachineStatusRequest::getXsdDefinition(context, request, "TpSetMachineStatusRequest", content, added);
		CTpSetMachineStatusResponse::getXsdDefinition(context, request, content, added);
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "TpSwapNode"))) || Utils::strcasecmp(method, "TpSwapNode")==0)
	{
		CTpSwapNodeRequest::getMapInfo(context.queryMapInfo());
		CTpSwapNodeResponse::getMapInfo(context.queryMapInfo());
		CTpSwapNodeRequest::getXsdDefinition(context, request, "TpSwapNodeRequest", content, added);
		CTpSwapNodeResponse::getXsdDefinition(context, request, content, added);
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "TpTargetClusterQuery"))) || Utils::strcasecmp(method, "TpTargetClusterQuery")==0)
	{
		CTpTargetClusterQueryRequest::getMapInfo(context.queryMapInfo());
		CTpTargetClusterQueryResponse::getMapInfo(context.queryMapInfo());
		CTpTargetClusterQueryRequest::getXsdDefinition(context, request, "TpTargetClusterQueryRequest", content, added);
		CTpTargetClusterQueryResponse::getXsdDefinition(context, request, content, added);
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "TpThorStatus"))) || Utils::strcasecmp(method, "TpThorStatus")==0)
	{
		CTpThorStatusRequest::getMapInfo(context.queryMapInfo());
		CTpThorStatusResponse::getMapInfo(context.queryMapInfo());
		CTpThorStatusRequest::getXsdDefinition(context, request, "TpThorStatusRequest", content, added);
		CTpThorStatusResponse::getXsdDefinition(context, request, content, added);
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "TpXMLFile"))) || Utils::strcasecmp(method, "TpXMLFile")==0)
	{
		CTpXMLFileRequest::getMapInfo(context.queryMapInfo());
		CTpXMLFileResponse::getMapInfo(context.queryMapInfo());
		CTpXMLFileRequest::getXsdDefinition(context, request, "TpXMLFileRequest", content, added);
		CTpXMLFileResponse::getXsdDefinition(context, request, content, added);
	}
	return 0;
}

int CWsTopologySoapBinding::getMethodHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &page, bool bIncludeFormTag)
{
	DBGLOG("Client version: %g", context.getClientVersion());
	if (Utils::strcasecmp(method, "Ping")==0)
	{
		CWsTopologyPingRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "SystemLog")==0)
	{
		CSystemLogRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "TpClusterInfo")==0)
	{
		CTpClusterInfoRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "TpClusterQuery")==0)
	{
		CTpClusterQueryRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "TpDropZoneQuery")==0)
	{
		CTpDropZoneQueryRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "TpGetComponentFile")==0)
	{
		CTpGetComponentFileRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "TpGetServicePlugins")==0)
	{
		CTpGetServicePluginsRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "TpGroupQuery")==0)
	{
		CTpGroupQueryRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "TpListTargetClusters")==0)
	{
		CTpListTargetClustersRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "TpLogFile")==0)
	{
		CTpLogFileRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "TpLogFileDisplay")==0)
	{
		CTpLogFileRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "TpLogicalClusterQuery")==0)
	{
		CTpLogicalClusterQueryRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "TpMachineInfo")==0)
	{
		CTpMachineInfoRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "TpMachineQuery")==0)
	{
		CTpMachineQueryRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "TpServiceQuery")==0)
	{
		CTpServiceQueryRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "TpSetMachineStatus")==0)
	{
		CTpSetMachineStatusRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "TpSwapNode")==0)
	{
		CTpSwapNodeRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "TpTargetClusterQuery")==0)
	{
		CTpTargetClusterQueryRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "TpThorStatus")==0)
	{
		CTpThorStatusRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "TpXMLFile")==0)
	{
		CTpXMLFileRequest::getHtmlForm(context, request, serv, method, page);
	}
	return 0;
}

int CWsTopologySoapBinding::getQualifiedNames(IEspContext& ctx, MethodInfoArray & methods)
{
	double ver = ctx.getClientVersion();
	if (ver<=0)
		ver = getWsdlVersion();
	const char *servname=ctx.queryServiceName(NULL);
	bool fullservice = (!stricmp(servname, "esp")||!stricmp(servname, "WsTopology"));
	if ((fullservice || isMethodInSubService(ctx, servname, "Ping")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("Ping", "WsTopologyPingRequest", "WsTopologyPingResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "SystemLog")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("SystemLog", "SystemLogRequest", "SystemLogResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "TpClusterInfo")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("TpClusterInfo", "TpClusterInfoRequest", "TpClusterInfoResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "TpClusterQuery")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("TpClusterQuery", "TpClusterQueryRequest", "TpClusterQueryResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "TpDropZoneQuery")) && ctx.isMethodAllowed(ver,NULL, NULL, 1.26, -1))
		methods.append(*new CMethodInfo("TpDropZoneQuery", "TpDropZoneQueryRequest", "TpDropZoneQueryResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "TpGetComponentFile")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("TpGetComponentFile", "TpGetComponentFileRequest", "TpGetComponentFileResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "TpGetServicePlugins")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("TpGetServicePlugins", "TpGetServicePluginsRequest", "TpGetServicePluginsResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "TpGroupQuery")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("TpGroupQuery", "TpGroupQueryRequest", "TpGroupQueryResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "TpListTargetClusters")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("TpListTargetClusters", "TpListTargetClustersRequest", "TpListTargetClustersResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "TpLogFile")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("TpLogFile", "TpLogFileRequest", "TpLogFileResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "TpLogFileDisplay")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("TpLogFileDisplay", "TpLogFileRequest", "TpLogFileResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "TpLogicalClusterQuery")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("TpLogicalClusterQuery", "TpLogicalClusterQueryRequest", "TpLogicalClusterQueryResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "TpMachineInfo")) && ctx.isMethodAllowed(ver,NULL, NULL, 1.25, -1))
		methods.append(*new CMethodInfo("TpMachineInfo", "TpMachineInfoRequest", "TpMachineInfoResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "TpMachineQuery")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("TpMachineQuery", "TpMachineQueryRequest", "TpMachineQueryResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "TpServiceQuery")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("TpServiceQuery", "TpServiceQueryRequest", "TpServiceQueryResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "TpSetMachineStatus")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("TpSetMachineStatus", "TpSetMachineStatusRequest", "TpSetMachineStatusResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "TpSwapNode")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("TpSwapNode", "TpSwapNodeRequest", "TpSwapNodeResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "TpTargetClusterQuery")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("TpTargetClusterQuery", "TpTargetClusterQueryRequest", "TpTargetClusterQueryResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "TpThorStatus")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("TpThorStatus", "TpThorStatusRequest", "TpThorStatusResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "TpXMLFile")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("TpXMLFile", "TpXMLFileRequest", "TpXMLFileResponse"));
	return methods.ordinality();
}

StringBuffer & CWsTopologySoapBinding::getServiceName(StringBuffer &resp)
{
	resp.append("WsTopology");
	return resp;
}

bool CWsTopologySoapBinding::isValidServiceName(IEspContext &context, const char *name)
{
	if (!Utils::strcasecmp(name, "WsTopology"))
		return true;
	else
		return (hasSubService(context, name));
}

bool CWsTopologySoapBinding::qualifyMethodName(IEspContext &context, const char *methname, StringBuffer *methQName)
{
	if (!methname || !*methname)
	{
		if (methQName!=NULL)
			methQName->clear();
		return true;
	}
	if (Utils::strcasecmp(methname, "Ping")==0)
	{
		if (methQName!=NULL)
			methQName->set("Ping");
		return true;
	}
	if (Utils::strcasecmp(methname, "SystemLog")==0)
	{
		if (methQName!=NULL)
			methQName->set("SystemLog");
		return true;
	}
	if (Utils::strcasecmp(methname, "TpClusterInfo")==0)
	{
		if (methQName!=NULL)
			methQName->set("TpClusterInfo");
		return true;
	}
	if (Utils::strcasecmp(methname, "TpClusterQuery")==0)
	{
		if (methQName!=NULL)
			methQName->set("TpClusterQuery");
		return true;
	}
	if (Utils::strcasecmp(methname, "TpDropZoneQuery")==0)
	{
		if (methQName!=NULL)
			methQName->set("TpDropZoneQuery");
		return true;
	}
	if (Utils::strcasecmp(methname, "TpGetComponentFile")==0)
	{
		if (methQName!=NULL)
			methQName->set("TpGetComponentFile");
		return true;
	}
	if (Utils::strcasecmp(methname, "TpGetServicePlugins")==0)
	{
		if (methQName!=NULL)
			methQName->set("TpGetServicePlugins");
		return true;
	}
	if (Utils::strcasecmp(methname, "TpGroupQuery")==0)
	{
		if (methQName!=NULL)
			methQName->set("TpGroupQuery");
		return true;
	}
	if (Utils::strcasecmp(methname, "TpListTargetClusters")==0)
	{
		if (methQName!=NULL)
			methQName->set("TpListTargetClusters");
		return true;
	}
	if (Utils::strcasecmp(methname, "TpLogFile")==0)
	{
		if (methQName!=NULL)
			methQName->set("TpLogFile");
		return true;
	}
	if (Utils::strcasecmp(methname, "TpLogFileDisplay")==0)
	{
		if (methQName!=NULL)
			methQName->set("TpLogFileDisplay");
		return true;
	}
	if (Utils::strcasecmp(methname, "TpLogicalClusterQuery")==0)
	{
		if (methQName!=NULL)
			methQName->set("TpLogicalClusterQuery");
		return true;
	}
	if (Utils::strcasecmp(methname, "TpMachineInfo")==0)
	{
		if (methQName!=NULL)
			methQName->set("TpMachineInfo");
		return true;
	}
	if (Utils::strcasecmp(methname, "TpMachineQuery")==0)
	{
		if (methQName!=NULL)
			methQName->set("TpMachineQuery");
		return true;
	}
	if (Utils::strcasecmp(methname, "TpServiceQuery")==0)
	{
		if (methQName!=NULL)
			methQName->set("TpServiceQuery");
		return true;
	}
	if (Utils::strcasecmp(methname, "TpSetMachineStatus")==0)
	{
		if (methQName!=NULL)
			methQName->set("TpSetMachineStatus");
		return true;
	}
	if (Utils::strcasecmp(methname, "TpSwapNode")==0)
	{
		if (methQName!=NULL)
			methQName->set("TpSwapNode");
		return true;
	}
	if (Utils::strcasecmp(methname, "TpTargetClusterQuery")==0)
	{
		if (methQName!=NULL)
			methQName->set("TpTargetClusterQuery");
		return true;
	}
	if (Utils::strcasecmp(methname, "TpThorStatus")==0)
	{
		if (methQName!=NULL)
			methQName->set("TpThorStatus");
		return true;
	}
	if (Utils::strcasecmp(methname, "TpXMLFile")==0)
	{
		if (methQName!=NULL)
			methQName->set("TpXMLFile");
		return true;
	}
	return false;
}

bool CWsTopologySoapBinding::qualifyServiceName(IEspContext &context, const char *servname, const char *methname, StringBuffer &servQName, StringBuffer *methQName)
{
	servQName.clear();
	if (!Utils::strcasecmp(servname, "WsTopology"))
	{
		servQName.append("WsTopology");
		return qualifyMethodName(context, methname, methQName);
	}
	return qualifySubServiceName(context, servname, methname, servQName, methQName);
}

int CWsTopologySoapBinding::onGetFile(IEspContext &context, CHttpRequest* request, CHttpResponse* response, const char *pathex)
{
	if(request == NULL || response == NULL)
		return -1;
	StringBuffer mimetype;
	MemoryBuffer content;

	StringBuffer filepath;
	getBaseFilePath(filepath);
	if (strchr("\\/", filepath.charAt(filepath.length()-1))==NULL)
		filepath.append("/");
	filepath.append(pathex);
	response->httpContentFromFile(filepath.str());
	response->send();
	return 0;
}

int CWsTopologySoapBinding::onGetForm(IEspContext &context, CHttpRequest* request, CHttpResponse* response, const char *service, const char *method)
{
	return onGetNotFound(context, request, response, service);
}
int CWsTopologySoapBinding::onGetXForm(IEspContext &context, CHttpRequest* request, CHttpResponse* response, const char *service, const char *method)
{
	return EspHttpBinding::onGetXForm(context, request, response, service, method);
}

int CWsTopologySoapBinding::onGetService(IEspContext &context, CHttpRequest* request, CHttpResponse* response, const char *service, const char *method, const char *pathex)
{
	if(request == NULL || response == NULL)
		return -1;
	return onGetQuery(context, request, response, service, method);
}

 IRpcRequestBinding *CWsTopologySoapBinding::createReqBinding(IEspContext &context, IHttpMessage *ireq, const char *service, const char *method)
{
	CHttpRequest *request=static_cast<CHttpRequest*>(ireq);
	IProperties *props = (request) ? request->queryParameters() : NULL;

	if (!stricmp(method, "Ping") || !stricmp(method, "WsTopologyPingRequest"))
		return new CWsTopologyPingRequest(&context, "WsTopology", props, NULL);
	if (!stricmp(method, "SystemLog") || !stricmp(method, "SystemLogRequest"))
		return new CSystemLogRequest(&context, "WsTopology", props, NULL);
	if (!stricmp(method, "TpClusterInfo") || !stricmp(method, "TpClusterInfoRequest"))
		return new CTpClusterInfoRequest(&context, "WsTopology", props, NULL);
	if (!stricmp(method, "TpClusterQuery") || !stricmp(method, "TpClusterQueryRequest"))
		return new CTpClusterQueryRequest(&context, "WsTopology", props, NULL);
	if (!stricmp(method, "TpDropZoneQuery") || !stricmp(method, "TpDropZoneQueryRequest"))
		return new CTpDropZoneQueryRequest(&context, "WsTopology", props, NULL);
	if (!stricmp(method, "TpGetComponentFile") || !stricmp(method, "TpGetComponentFileRequest"))
		return new CTpGetComponentFileRequest(&context, "WsTopology", props, NULL);
	if (!stricmp(method, "TpGetServicePlugins") || !stricmp(method, "TpGetServicePluginsRequest"))
		return new CTpGetServicePluginsRequest(&context, "WsTopology", props, NULL);
	if (!stricmp(method, "TpGroupQuery") || !stricmp(method, "TpGroupQueryRequest"))
		return new CTpGroupQueryRequest(&context, "WsTopology", props, NULL);
	if (!stricmp(method, "TpListTargetClusters") || !stricmp(method, "TpListTargetClustersRequest"))
		return new CTpListTargetClustersRequest(&context, "WsTopology", props, NULL);
	if (!stricmp(method, "TpLogFile") || !stricmp(method, "TpLogFileRequest"))
		return new CTpLogFileRequest(&context, "WsTopology", props, NULL);
	if (!stricmp(method, "TpLogFileDisplay") || !stricmp(method, "TpLogFileRequest"))
		return new CTpLogFileRequest(&context, "WsTopology", props, NULL);
	if (!stricmp(method, "TpLogicalClusterQuery") || !stricmp(method, "TpLogicalClusterQueryRequest"))
		return new CTpLogicalClusterQueryRequest(&context, "WsTopology", props, NULL);
	if (!stricmp(method, "TpMachineInfo") || !stricmp(method, "TpMachineInfoRequest"))
		return new CTpMachineInfoRequest(&context, "WsTopology", props, NULL);
	if (!stricmp(method, "TpMachineQuery") || !stricmp(method, "TpMachineQueryRequest"))
		return new CTpMachineQueryRequest(&context, "WsTopology", props, NULL);
	if (!stricmp(method, "TpServiceQuery") || !stricmp(method, "TpServiceQueryRequest"))
		return new CTpServiceQueryRequest(&context, "WsTopology", props, NULL);
	if (!stricmp(method, "TpSetMachineStatus") || !stricmp(method, "TpSetMachineStatusRequest"))
		return new CTpSetMachineStatusRequest(&context, "WsTopology", props, NULL);
	if (!stricmp(method, "TpSwapNode") || !stricmp(method, "TpSwapNodeRequest"))
		return new CTpSwapNodeRequest(&context, "WsTopology", props, NULL);
	if (!stricmp(method, "TpTargetClusterQuery") || !stricmp(method, "TpTargetClusterQueryRequest"))
		return new CTpTargetClusterQueryRequest(&context, "WsTopology", props, NULL);
	if (!stricmp(method, "TpThorStatus") || !stricmp(method, "TpThorStatusRequest"))
		return new CTpThorStatusRequest(&context, "WsTopology", props, NULL);
	if (!stricmp(method, "TpXMLFile") || !stricmp(method, "TpXMLFileRequest"))
		return new CTpXMLFileRequest(&context, "WsTopology", props, NULL);
	return NULL;
}

int CWsTopologySoapBinding::onGetInstantQuery(IEspContext &context, CHttpRequest* request, CHttpResponse* response, const char *service, const char *method)
{
	if (context.getClientVersion()<=0)
		context.setClientVersion(1.28);

	if(request == NULL || response == NULL)
		return -1;
	StringBuffer respStr;
	Owned<IEspWsTopology> iserv = (IEspWsTopology*)getService();
	if(iserv == NULL)
	{
		respStr.append("Service not available");
		response->setContent(respStr.str());
		response->setContentType("text/html");
		response->send();
	}
	else
	{
		Owned<CSoapResponseBinding> esp_response;
		StringBuffer source;
		IEspContext& context = *request->queryContext();
		if(!stricmp(method, "Ping")||!stricmp(method, "WsTopologyPingRequest"))
		{
			Owned<CWsTopologyPingRequest> esp_request = new CWsTopologyPingRequest(&context, "WsTopology", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			CWsTopologyPingResponse* resp = new CWsTopologyPingResponse("WsTopology");
			esp_response.setown(resp);
			MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
			source.setf("WsTopology::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				if(accessmap.ordinality()>0)
					onFeaturesAuthorize(context, accessmap, "WsTopology", "Ping");
				iserv->onPing(context, *esp_request.get(), *resp);
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "WsTopology", "Ping", StringBuffer(getCFD()).append("./smc_xslt/exceptions.xslt").str()))
				return 0;
		}
		if(!stricmp(method, "SystemLog")||!stricmp(method, "SystemLogRequest"))
		{
			Owned<CSystemLogRequest> esp_request = new CSystemLogRequest(&context, "WsTopology", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			CSystemLogResponse* resp = new CSystemLogResponse("WsTopology");
			esp_response.setown(resp);
			MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
			source.setf("WsTopology::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				if(accessmap.ordinality()>0)
					onFeaturesAuthorize(context, accessmap, "WsTopology", "SystemLog");
				iserv->onSystemLog(context, *esp_request.get(), *resp);
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "WsTopology", "SystemLog", StringBuffer(getCFD()).append("./smc_xslt/exceptions.xslt").str()))
				return 0;
		}
		if(!stricmp(method, "TpClusterInfo")||!stricmp(method, "TpClusterInfoRequest"))
		{
			Owned<CTpClusterInfoRequest> esp_request = new CTpClusterInfoRequest(&context, "WsTopology", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			Owned<CTpClusterInfoResponse> esp_response = new CTpClusterInfoResponse("WsTopology");
			StringBuffer source;
			source.appendf("WsTopology::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				iserv->onTpClusterInfo(*request->queryContext(), *esp_request.get(), *esp_response.get());
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "WsTopology", "TpClusterInfo", StringBuffer(getCFD()).append("./smc_xslt/exceptions.xslt").str()))
				return 0;
			if (canRedirect(*request) && esp_response->getRedirectUrl() && *esp_response->getRedirectUrl())
			{
				response->redirect(*request, esp_response->getRedirectUrl());
			}
			else
			{
				IProperties *props=request->queryParameters();
				if (skipXslt(context))
				{
					MemoryBuffer content;
					StringBuffer mimetype;
					esp_response->appendContent(&context,content, mimetype);
					onBeforeSendResponse(context,request,content,service,method);
					response->setContent(content.length(), content.toByteArray());
					response->setContentType(mimetype.str());
				}
				else
				{
					StringBuffer xml;
					StringBuffer sResponse;
					esp_response->serializeStruct(&context, xml, NULL);

					xslTransform(xml.str(), "/esp/xslt/cluster_info.xslt", sResponse.clear(), context.queryXslParameters());
					response->setContentType("text/html");
					response->setContent(sResponse.str());
				}
				response->send();
			}
			return 0;
		}
		if(!stricmp(method, "TpClusterQuery")||!stricmp(method, "TpClusterQueryRequest"))
		{
			Owned<CTpClusterQueryRequest> esp_request = new CTpClusterQueryRequest(&context, "WsTopology", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			Owned<CTpClusterQueryResponse> esp_response = new CTpClusterQueryResponse("WsTopology");
			StringBuffer source;
			source.appendf("WsTopology::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				iserv->onTpClusterQuery(*request->queryContext(), *esp_request.get(), *esp_response.get());
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "WsTopology", "TpClusterQuery", StringBuffer(getCFD()).append("./smc_xslt/exceptions.xslt").str()))
				return 0;
			if (canRedirect(*request) && esp_response->getRedirectUrl() && *esp_response->getRedirectUrl())
			{
				response->redirect(*request, esp_response->getRedirectUrl());
			}
			else
			{
				IProperties *props=request->queryParameters();
				if (skipXslt(context))
				{
					MemoryBuffer content;
					StringBuffer mimetype;
					esp_response->appendContent(&context,content, mimetype);
					onBeforeSendResponse(context,request,content,service,method);
					response->setContent(content.length(), content.toByteArray());
					response->setContentType(mimetype.str());
				}
				else
				{
					StringBuffer xml;
					StringBuffer sResponse;
					esp_response->serializeStruct(&context, xml, NULL);

					xslTransform(xml.str(), "/esp/xslt/topology.xslt", sResponse.clear(), context.queryXslParameters());
					response->setContentType("text/html");
					response->setContent(sResponse.str());
				}
				response->send();
			}
			return 0;
		}
		if(!stricmp(method, "TpDropZoneQuery")||!stricmp(method, "TpDropZoneQueryRequest"))
		{
			Owned<CTpDropZoneQueryRequest> esp_request = new CTpDropZoneQueryRequest(&context, "WsTopology", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			CTpDropZoneQueryResponse* resp = new CTpDropZoneQueryResponse("WsTopology");
			esp_response.setown(resp);
			MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
			source.setf("WsTopology::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				if(accessmap.ordinality()>0)
					onFeaturesAuthorize(context, accessmap, "WsTopology", "TpDropZoneQuery");
				iserv->onTpDropZoneQuery(context, *esp_request.get(), *resp);
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "WsTopology", "TpDropZoneQuery", StringBuffer(getCFD()).append("./smc_xslt/exceptions.xslt").str()))
				return 0;
		}
		if(!stricmp(method, "TpGetComponentFile")||!stricmp(method, "TpGetComponentFileRequest"))
		{
			Owned<CTpGetComponentFileRequest> esp_request = new CTpGetComponentFileRequest(&context, "WsTopology", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			CTpGetComponentFileResponse* resp = new CTpGetComponentFileResponse("WsTopology");
			esp_response.setown(resp);
			MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
			source.setf("WsTopology::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				if(accessmap.ordinality()>0)
					onFeaturesAuthorize(context, accessmap, "WsTopology", "TpGetComponentFile");
				iserv->onTpGetComponentFile(context, *esp_request.get(), *resp);
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "WsTopology", "TpGetComponentFile", StringBuffer(getCFD()).append("./smc_xslt/exceptions.xslt").str()))
				return 0;
		}
		if(!stricmp(method, "TpGetServicePlugins")||!stricmp(method, "TpGetServicePluginsRequest"))
		{
			Owned<CTpGetServicePluginsRequest> esp_request = new CTpGetServicePluginsRequest(&context, "WsTopology", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			CTpGetServicePluginsResponse* resp = new CTpGetServicePluginsResponse("WsTopology");
			esp_response.setown(resp);
			MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
			source.setf("WsTopology::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				if(accessmap.ordinality()>0)
					onFeaturesAuthorize(context, accessmap, "WsTopology", "TpGetServicePlugins");
				iserv->onTpGetServicePlugins(context, *esp_request.get(), *resp);
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "WsTopology", "TpGetServicePlugins", StringBuffer(getCFD()).append("./smc_xslt/exceptions.xslt").str()))
				return 0;
		}
		if(!stricmp(method, "TpGroupQuery")||!stricmp(method, "TpGroupQueryRequest"))
		{
			Owned<CTpGroupQueryRequest> esp_request = new CTpGroupQueryRequest(&context, "WsTopology", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			CTpGroupQueryResponse* resp = new CTpGroupQueryResponse("WsTopology");
			esp_response.setown(resp);
			MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
			source.setf("WsTopology::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				if(accessmap.ordinality()>0)
					onFeaturesAuthorize(context, accessmap, "WsTopology", "TpGroupQuery");
				iserv->onTpGroupQuery(context, *esp_request.get(), *resp);
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "WsTopology", "TpGroupQuery", StringBuffer(getCFD()).append("./smc_xslt/exceptions.xslt").str()))
				return 0;
		}
		if(!stricmp(method, "TpListTargetClusters")||!stricmp(method, "TpListTargetClustersRequest"))
		{
			Owned<CTpListTargetClustersRequest> esp_request = new CTpListTargetClustersRequest(&context, "WsTopology", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			CTpListTargetClustersResponse* resp = new CTpListTargetClustersResponse("WsTopology");
			esp_response.setown(resp);
			MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
			source.setf("WsTopology::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				if(accessmap.ordinality()>0)
					onFeaturesAuthorize(context, accessmap, "WsTopology", "TpListTargetClusters");
				iserv->onTpListTargetClusters(context, *esp_request.get(), *resp);
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "WsTopology", "TpListTargetClusters", StringBuffer(getCFD()).append("./smc_xslt/exceptions.xslt").str()))
				return 0;
		}
		if(!stricmp(method, "TpLogFile")||!stricmp(method, "TpLogFileRequest"))
		{
			Owned<CTpLogFileRequest> esp_request = new CTpLogFileRequest(&context, "WsTopology", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			Owned<CTpLogFileResponse> esp_response = new CTpLogFileResponse("WsTopology");
			StringBuffer source;
			source.appendf("WsTopology::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				iserv->onTpLogFile(*request->queryContext(), *esp_request.get(), *esp_response.get());
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "WsTopology", "TpLogFile", StringBuffer(getCFD()).append("./smc_xslt/exceptions.xslt").str()))
				return 0;
			if (canRedirect(*request) && esp_response->getRedirectUrl() && *esp_response->getRedirectUrl())
			{
				response->redirect(*request, esp_response->getRedirectUrl());
			}
			else
			{
				IProperties *props=request->queryParameters();
				if (skipXslt(context))
				{
					MemoryBuffer content;
					StringBuffer mimetype;
					esp_response->appendContent(&context,content, mimetype);
					onBeforeSendResponse(context,request,content,service,method);
					response->setContent(content.length(), content.toByteArray());
					response->setContentType(mimetype.str());
				}
				else
				{
					StringBuffer xml;
					StringBuffer sResponse;
					esp_response->serializeStruct(&context, xml, NULL);

					xslTransform(xml.str(), "/esp/xslt/tplog.xslt", sResponse.clear(), context.queryXslParameters());
					response->setContentType("text/html");
					response->setContent(sResponse.str());
				}
				response->send();
			}
			return 0;
		}
		if(!stricmp(method, "TpLogFileDisplay")||!stricmp(method, "TpLogFileRequest"))
		{
			Owned<CTpLogFileRequest> esp_request = new CTpLogFileRequest(&context, "WsTopology", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			Owned<CTpLogFileResponse> esp_response = new CTpLogFileResponse("WsTopology");
			StringBuffer source;
			source.appendf("WsTopology::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				iserv->onTpLogFileDisplay(*request->queryContext(), *esp_request.get(), *esp_response.get());
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "WsTopology", "TpLogFileDisplay", StringBuffer(getCFD()).append("./smc_xslt/exceptions.xslt").str()))
				return 0;
			if (canRedirect(*request) && esp_response->getRedirectUrl() && *esp_response->getRedirectUrl())
			{
				response->redirect(*request, esp_response->getRedirectUrl());
			}
			else
			{
				IProperties *props=request->queryParameters();
				if (skipXslt(context))
				{
					MemoryBuffer content;
					StringBuffer mimetype;
					esp_response->appendContent(&context,content, mimetype);
					onBeforeSendResponse(context,request,content,service,method);
					response->setContent(content.length(), content.toByteArray());
					response->setContentType(mimetype.str());
				}
				else
				{
					StringBuffer xml;
					StringBuffer sResponse;
					esp_response->serializeStruct(&context, xml, NULL);

					xslTransform(xml.str(), "/esp/xslt/tplogdisplay.xslt", sResponse.clear(), context.queryXslParameters());
					response->setContentType("text/html");
					response->setContent(sResponse.str());
				}
				response->send();
			}
			return 0;
		}
		if(!stricmp(method, "TpLogicalClusterQuery")||!stricmp(method, "TpLogicalClusterQueryRequest"))
		{
			Owned<CTpLogicalClusterQueryRequest> esp_request = new CTpLogicalClusterQueryRequest(&context, "WsTopology", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			CTpLogicalClusterQueryResponse* resp = new CTpLogicalClusterQueryResponse("WsTopology");
			esp_response.setown(resp);
			MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
			source.setf("WsTopology::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				if(accessmap.ordinality()>0)
					onFeaturesAuthorize(context, accessmap, "WsTopology", "TpLogicalClusterQuery");
				iserv->onTpLogicalClusterQuery(context, *esp_request.get(), *resp);
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "WsTopology", "TpLogicalClusterQuery", StringBuffer(getCFD()).append("./smc_xslt/exceptions.xslt").str()))
				return 0;
		}
		if(!stricmp(method, "TpMachineInfo")||!stricmp(method, "TpMachineInfoRequest"))
		{
			Owned<CTpMachineInfoRequest> esp_request = new CTpMachineInfoRequest(&context, "WsTopology", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			CTpMachineInfoResponse* resp = new CTpMachineInfoResponse("WsTopology");
			esp_response.setown(resp);
			MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
			source.setf("WsTopology::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				if(accessmap.ordinality()>0)
					onFeaturesAuthorize(context, accessmap, "WsTopology", "TpMachineInfo");
				iserv->onTpMachineInfo(context, *esp_request.get(), *resp);
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "WsTopology", "TpMachineInfo", StringBuffer(getCFD()).append("./smc_xslt/exceptions.xslt").str()))
				return 0;
		}
		if(!stricmp(method, "TpMachineQuery")||!stricmp(method, "TpMachineQueryRequest"))
		{
			Owned<CTpMachineQueryRequest> esp_request = new CTpMachineQueryRequest(&context, "WsTopology", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			Owned<CTpMachineQueryResponse> esp_response = new CTpMachineQueryResponse("WsTopology");
			StringBuffer source;
			source.appendf("WsTopology::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				iserv->onTpMachineQuery(*request->queryContext(), *esp_request.get(), *esp_response.get());
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "WsTopology", "TpMachineQuery", StringBuffer(getCFD()).append("./smc_xslt/exceptions.xslt").str()))
				return 0;
			if (canRedirect(*request) && esp_response->getRedirectUrl() && *esp_response->getRedirectUrl())
			{
				response->redirect(*request, esp_response->getRedirectUrl());
			}
			else
			{
				IProperties *props=request->queryParameters();
				if (skipXslt(context))
				{
					MemoryBuffer content;
					StringBuffer mimetype;
					esp_response->appendContent(&context,content, mimetype);
					onBeforeSendResponse(context,request,content,service,method);
					response->setContent(content.length(), content.toByteArray());
					response->setContentType(mimetype.str());
				}
				else
				{
					StringBuffer xml;
					StringBuffer sResponse;
					esp_response->serializeStruct(&context, xml, NULL);

					xslTransform(xml.str(), "/esp/xslt/machines.xslt", sResponse.clear(), context.queryXslParameters());
					response->setContentType("text/html");
					response->setContent(sResponse.str());
				}
				response->send();
			}
			return 0;
		}
		if(!stricmp(method, "TpServiceQuery")||!stricmp(method, "TpServiceQueryRequest"))
		{
			Owned<CTpServiceQueryRequest> esp_request = new CTpServiceQueryRequest(&context, "WsTopology", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			Owned<CTpServiceQueryResponse> esp_response = new CTpServiceQueryResponse("WsTopology");
			StringBuffer source;
			source.appendf("WsTopology::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				iserv->onTpServiceQuery(*request->queryContext(), *esp_request.get(), *esp_response.get());
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "WsTopology", "TpServiceQuery", StringBuffer(getCFD()).append("./smc_xslt/exceptions.xslt").str()))
				return 0;
			if (canRedirect(*request) && esp_response->getRedirectUrl() && *esp_response->getRedirectUrl())
			{
				response->redirect(*request, esp_response->getRedirectUrl());
			}
			else
			{
				IProperties *props=request->queryParameters();
				if (skipXslt(context))
				{
					MemoryBuffer content;
					StringBuffer mimetype;
					esp_response->appendContent(&context,content, mimetype);
					onBeforeSendResponse(context,request,content,service,method);
					response->setContent(content.length(), content.toByteArray());
					response->setContentType(mimetype.str());
				}
				else
				{
					StringBuffer xml;
					StringBuffer sResponse;
					esp_response->serializeStruct(&context, xml, NULL);

					xslTransform(xml.str(), "/esp/xslt/services.xslt", sResponse.clear(), context.queryXslParameters());
					response->setContentType("text/html");
					response->setContent(sResponse.str());
				}
				response->send();
			}
			return 0;
		}
		if(!stricmp(method, "TpSetMachineStatus")||!stricmp(method, "TpSetMachineStatusRequest"))
		{
			Owned<CTpSetMachineStatusRequest> esp_request = new CTpSetMachineStatusRequest(&context, "WsTopology", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			CTpSetMachineStatusResponse* resp = new CTpSetMachineStatusResponse("WsTopology");
			esp_response.setown(resp);
			MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
			source.setf("WsTopology::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				if(accessmap.ordinality()>0)
					onFeaturesAuthorize(context, accessmap, "WsTopology", "TpSetMachineStatus");
				iserv->onTpSetMachineStatus(context, *esp_request.get(), *resp);
				clearCacheByGroupID("ESPWsTP");
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "WsTopology", "TpSetMachineStatus", StringBuffer(getCFD()).append("./smc_xslt/exceptions.xslt").str()))
				return 0;
		}
		if(!stricmp(method, "TpSwapNode")||!stricmp(method, "TpSwapNodeRequest"))
		{
			Owned<CTpSwapNodeRequest> esp_request = new CTpSwapNodeRequest(&context, "WsTopology", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			CTpSwapNodeResponse* resp = new CTpSwapNodeResponse("WsTopology");
			esp_response.setown(resp);
			MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
			source.setf("WsTopology::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				if(accessmap.ordinality()>0)
					onFeaturesAuthorize(context, accessmap, "WsTopology", "TpSwapNode");
				iserv->onTpSwapNode(context, *esp_request.get(), *resp);
				clearCacheByGroupID("ESPWsTP");
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "WsTopology", "TpSwapNode", StringBuffer(getCFD()).append("./smc_xslt/exceptions.xslt").str()))
				return 0;
		}
		if(!stricmp(method, "TpTargetClusterQuery")||!stricmp(method, "TpTargetClusterQueryRequest"))
		{
			Owned<CTpTargetClusterQueryRequest> esp_request = new CTpTargetClusterQueryRequest(&context, "WsTopology", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			Owned<CTpTargetClusterQueryResponse> esp_response = new CTpTargetClusterQueryResponse("WsTopology");
			StringBuffer source;
			source.appendf("WsTopology::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				iserv->onTpTargetClusterQuery(*request->queryContext(), *esp_request.get(), *esp_response.get());
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "WsTopology", "TpTargetClusterQuery", StringBuffer(getCFD()).append("./smc_xslt/exceptions.xslt").str()))
				return 0;
			if (canRedirect(*request) && esp_response->getRedirectUrl() && *esp_response->getRedirectUrl())
			{
				response->redirect(*request, esp_response->getRedirectUrl());
			}
			else
			{
				IProperties *props=request->queryParameters();
				if (skipXslt(context))
				{
					MemoryBuffer content;
					StringBuffer mimetype;
					esp_response->appendContent(&context,content, mimetype);
					onBeforeSendResponse(context,request,content,service,method);
					response->setContent(content.length(), content.toByteArray());
					response->setContentType(mimetype.str());
				}
				else
				{
					StringBuffer xml;
					StringBuffer sResponse;
					esp_response->serializeStruct(&context, xml, NULL);

					xslTransform(xml.str(), "/esp/xslt/targetclusters.xslt", sResponse.clear(), context.queryXslParameters());
					response->setContentType("text/html");
					response->setContent(sResponse.str());
				}
				response->send();
			}
			return 0;
		}
		if(!stricmp(method, "TpThorStatus")||!stricmp(method, "TpThorStatusRequest"))
		{
			Owned<CTpThorStatusRequest> esp_request = new CTpThorStatusRequest(&context, "WsTopology", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			Owned<CTpThorStatusResponse> esp_response = new CTpThorStatusResponse("WsTopology");
			StringBuffer source;
			source.appendf("WsTopology::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				iserv->onTpThorStatus(*request->queryContext(), *esp_request.get(), *esp_response.get());
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "WsTopology", "TpThorStatus", StringBuffer(getCFD()).append("./smc_xslt/exceptions.xslt").str()))
				return 0;
			if (canRedirect(*request) && esp_response->getRedirectUrl() && *esp_response->getRedirectUrl())
			{
				response->redirect(*request, esp_response->getRedirectUrl());
			}
			else
			{
				IProperties *props=request->queryParameters();
				if (skipXslt(context))
				{
					MemoryBuffer content;
					StringBuffer mimetype;
					esp_response->appendContent(&context,content, mimetype);
					onBeforeSendResponse(context,request,content,service,method);
					response->setContent(content.length(), content.toByteArray());
					response->setContentType(mimetype.str());
				}
				else
				{
					StringBuffer xml;
					StringBuffer sResponse;
					esp_response->serializeStruct(&context, xml, NULL);

					xslTransform(xml.str(), "/esp/xslt/thor_status.xslt", sResponse.clear(), context.queryXslParameters());
					response->setContentType("text/html");
					response->setContent(sResponse.str());
				}
				response->send();
			}
			return 0;
		}
		if(!stricmp(method, "TpXMLFile")||!stricmp(method, "TpXMLFileRequest"))
		{
			Owned<CTpXMLFileRequest> esp_request = new CTpXMLFileRequest(&context, "WsTopology", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			CTpXMLFileResponse* resp = new CTpXMLFileResponse("WsTopology");
			esp_response.setown(resp);
			MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
			source.setf("WsTopology::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				if(accessmap.ordinality()>0)
					onFeaturesAuthorize(context, accessmap, "WsTopology", "TpXMLFile");
				iserv->onTpXMLFile(context, *esp_request.get(), *resp);
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "WsTopology", "TpXMLFile", StringBuffer(getCFD()).append("./smc_xslt/exceptions.xslt").str()))
				return 0;
		}

		if (esp_response.get())
		{
			if (canRedirect(*request) && esp_response->getRedirectUrl() && *esp_response->getRedirectUrl())
				response->redirect(*request, esp_response->getRedirectUrl());
			else
			{
				MemoryBuffer content;
				StringBuffer mimetype;
				esp_response->appendContent(&context,content, mimetype);
				onBeforeSendResponse(context,request,content,service,method);
				response->setContent(content.length(), content.toByteArray());
				response->setContentType(mimetype.str());
				response->send();
			}
			return 0;
		}
	}
	return onGetNotFound(context, request,  response, service);
}





//=======================================================
// client util methods
//=======================================================

//------ method Ping ---------

IClientWsTopologyPingRequest * CClientWsTopology::createPingRequest()
{
	CWsTopologyPingRequest* request = new CWsTopologyPingRequest("WsTopology");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientWsTopologyPingResponse * CClientWsTopology::Ping(IClientWsTopologyPingRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CWsTopologyPingRequest* esprequest = static_cast<CWsTopologyPingRequest*>(request);
	CWsTopologyPingResponse* espresponse = new CWsTopologyPingResponse("WsTopology");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientWsTopology::async_Ping(IClientWsTopologyPingRequest *request, IClientWsTopologyEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CWsTopologyPingRequest* esprequest = static_cast<CWsTopologyPingRequest*>(request);
	esprequest->setMethod("Ping");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientWsTopology::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientWsTopologyPingResponse *CClientWsTopology::PingFn()
{
	Owned<IClientWsTopologyPingRequest> req =  createPingRequest();
	return Ping(req.get());
}

//------ method SystemLog ---------

IClientSystemLogRequest * CClientWsTopology::createSystemLogRequest()
{
	CSystemLogRequest* request = new CSystemLogRequest("WsTopology");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientSystemLogResponse * CClientWsTopology::SystemLog(IClientSystemLogRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CSystemLogRequest* esprequest = static_cast<CSystemLogRequest*>(request);
	CSystemLogResponse* espresponse = new CSystemLogResponse("WsTopology");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientWsTopology::async_SystemLog(IClientSystemLogRequest *request, IClientWsTopologyEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CSystemLogRequest* esprequest = static_cast<CSystemLogRequest*>(request);
	esprequest->setMethod("SystemLog");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientWsTopology::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientSystemLogResponse *CClientWsTopology::SystemLogFn(const char * Name_, const char * Type_, int Zip_)
{
	Owned<IClientSystemLogRequest> req =  createSystemLogRequest();
	req->setName(Name_);
	req->setType(Type_);
	req->setZip(Zip_);
	return SystemLog(req.get());
}

//------ method TpClusterInfo ---------

IClientTpClusterInfoRequest * CClientWsTopology::createTpClusterInfoRequest()
{
	CTpClusterInfoRequest* request = new CTpClusterInfoRequest("WsTopology");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientTpClusterInfoResponse * CClientWsTopology::TpClusterInfo(IClientTpClusterInfoRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CTpClusterInfoRequest* esprequest = static_cast<CTpClusterInfoRequest*>(request);
	CTpClusterInfoResponse* espresponse = new CTpClusterInfoResponse("WsTopology");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientWsTopology::async_TpClusterInfo(IClientTpClusterInfoRequest *request, IClientWsTopologyEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CTpClusterInfoRequest* esprequest = static_cast<CTpClusterInfoRequest*>(request);
	esprequest->setMethod("TpClusterInfo");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientWsTopology::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientTpClusterInfoResponse *CClientWsTopology::TpClusterInfoFn(const char * Name_)
{
	Owned<IClientTpClusterInfoRequest> req =  createTpClusterInfoRequest();
	req->setName(Name_);
	return TpClusterInfo(req.get());
}

//------ method TpClusterQuery ---------

IClientTpClusterQueryRequest * CClientWsTopology::createTpClusterQueryRequest()
{
	CTpClusterQueryRequest* request = new CTpClusterQueryRequest("WsTopology");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientTpClusterQueryResponse * CClientWsTopology::TpClusterQuery(IClientTpClusterQueryRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CTpClusterQueryRequest* esprequest = static_cast<CTpClusterQueryRequest*>(request);
	CTpClusterQueryResponse* espresponse = new CTpClusterQueryResponse("WsTopology");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientWsTopology::async_TpClusterQuery(IClientTpClusterQueryRequest *request, IClientWsTopologyEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CTpClusterQueryRequest* esprequest = static_cast<CTpClusterQueryRequest*>(request);
	esprequest->setMethod("TpClusterQuery");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientWsTopology::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientTpClusterQueryResponse *CClientWsTopology::TpClusterQueryFn(const char * Type_)
{
	Owned<IClientTpClusterQueryRequest> req =  createTpClusterQueryRequest();
	req->setType(Type_);
	return TpClusterQuery(req.get());
}

//------ method TpDropZoneQuery ---------

IClientTpDropZoneQueryRequest * CClientWsTopology::createTpDropZoneQueryRequest()
{
	CTpDropZoneQueryRequest* request = new CTpDropZoneQueryRequest("WsTopology");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientTpDropZoneQueryResponse * CClientWsTopology::TpDropZoneQuery(IClientTpDropZoneQueryRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CTpDropZoneQueryRequest* esprequest = static_cast<CTpDropZoneQueryRequest*>(request);
	CTpDropZoneQueryResponse* espresponse = new CTpDropZoneQueryResponse("WsTopology");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientWsTopology::async_TpDropZoneQuery(IClientTpDropZoneQueryRequest *request, IClientWsTopologyEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CTpDropZoneQueryRequest* esprequest = static_cast<CTpDropZoneQueryRequest*>(request);
	esprequest->setMethod("TpDropZoneQuery");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientWsTopology::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientTpDropZoneQueryResponse *CClientWsTopology::TpDropZoneQueryFn(const char * Name_, bool ECLWatchVisibleOnly_)
{
	Owned<IClientTpDropZoneQueryRequest> req =  createTpDropZoneQueryRequest();
	req->setName(Name_);
	req->setECLWatchVisibleOnly(ECLWatchVisibleOnly_);
	return TpDropZoneQuery(req.get());
}

//------ method TpGetComponentFile ---------

IClientTpGetComponentFileRequest * CClientWsTopology::createTpGetComponentFileRequest()
{
	CTpGetComponentFileRequest* request = new CTpGetComponentFileRequest("WsTopology");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientTpGetComponentFileResponse * CClientWsTopology::TpGetComponentFile(IClientTpGetComponentFileRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CTpGetComponentFileRequest* esprequest = static_cast<CTpGetComponentFileRequest*>(request);
	CTpGetComponentFileResponse* espresponse = new CTpGetComponentFileResponse("WsTopology");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientWsTopology::async_TpGetComponentFile(IClientTpGetComponentFileRequest *request, IClientWsTopologyEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CTpGetComponentFileRequest* esprequest = static_cast<CTpGetComponentFileRequest*>(request);
	esprequest->setMethod("TpGetComponentFile");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientWsTopology::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientTpGetComponentFileResponse *CClientWsTopology::TpGetComponentFileFn(const char * CompType_, const char * CompName_, const char * NetAddress_, const char * Directory_, const char * FileType_, int OsType_, const char * PlainText_)
{
	Owned<IClientTpGetComponentFileRequest> req =  createTpGetComponentFileRequest();
	req->setCompType(CompType_);
	req->setCompName(CompName_);
	req->setNetAddress(NetAddress_);
	req->setDirectory(Directory_);
	req->setFileType(FileType_);
	req->setOsType(OsType_);
	req->setPlainText(PlainText_);
	return TpGetComponentFile(req.get());
}

//------ method TpGetServicePlugins ---------

IClientTpGetServicePluginsRequest * CClientWsTopology::createTpGetServicePluginsRequest()
{
	CTpGetServicePluginsRequest* request = new CTpGetServicePluginsRequest("WsTopology");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientTpGetServicePluginsResponse * CClientWsTopology::TpGetServicePlugins(IClientTpGetServicePluginsRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CTpGetServicePluginsRequest* esprequest = static_cast<CTpGetServicePluginsRequest*>(request);
	CTpGetServicePluginsResponse* espresponse = new CTpGetServicePluginsResponse("WsTopology");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientWsTopology::async_TpGetServicePlugins(IClientTpGetServicePluginsRequest *request, IClientWsTopologyEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CTpGetServicePluginsRequest* esprequest = static_cast<CTpGetServicePluginsRequest*>(request);
	esprequest->setMethod("TpGetServicePlugins");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientWsTopology::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientTpGetServicePluginsResponse *CClientWsTopology::TpGetServicePluginsFn()
{
	Owned<IClientTpGetServicePluginsRequest> req =  createTpGetServicePluginsRequest();
	return TpGetServicePlugins(req.get());
}

//------ method TpGroupQuery ---------

IClientTpGroupQueryRequest * CClientWsTopology::createTpGroupQueryRequest()
{
	CTpGroupQueryRequest* request = new CTpGroupQueryRequest("WsTopology");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientTpGroupQueryResponse * CClientWsTopology::TpGroupQuery(IClientTpGroupQueryRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CTpGroupQueryRequest* esprequest = static_cast<CTpGroupQueryRequest*>(request);
	CTpGroupQueryResponse* espresponse = new CTpGroupQueryResponse("WsTopology");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientWsTopology::async_TpGroupQuery(IClientTpGroupQueryRequest *request, IClientWsTopologyEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CTpGroupQueryRequest* esprequest = static_cast<CTpGroupQueryRequest*>(request);
	esprequest->setMethod("TpGroupQuery");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientWsTopology::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientTpGroupQueryResponse *CClientWsTopology::TpGroupQueryFn(const char * Kind_)
{
	Owned<IClientTpGroupQueryRequest> req =  createTpGroupQueryRequest();
	req->setKind(Kind_);
	return TpGroupQuery(req.get());
}

//------ method TpListTargetClusters ---------

IClientTpListTargetClustersRequest * CClientWsTopology::createTpListTargetClustersRequest()
{
	CTpListTargetClustersRequest* request = new CTpListTargetClustersRequest("WsTopology");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientTpListTargetClustersResponse * CClientWsTopology::TpListTargetClusters(IClientTpListTargetClustersRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CTpListTargetClustersRequest* esprequest = static_cast<CTpListTargetClustersRequest*>(request);
	CTpListTargetClustersResponse* espresponse = new CTpListTargetClustersResponse("WsTopology");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientWsTopology::async_TpListTargetClusters(IClientTpListTargetClustersRequest *request, IClientWsTopologyEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CTpListTargetClustersRequest* esprequest = static_cast<CTpListTargetClustersRequest*>(request);
	esprequest->setMethod("TpListTargetClusters");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientWsTopology::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientTpListTargetClustersResponse *CClientWsTopology::TpListTargetClustersFn()
{
	Owned<IClientTpListTargetClustersRequest> req =  createTpListTargetClustersRequest();
	return TpListTargetClusters(req.get());
}

//------ method TpLogFile ---------

IClientTpLogFileRequest * CClientWsTopology::createTpLogFileRequest()
{
	CTpLogFileRequest* request = new CTpLogFileRequest("WsTopology");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientTpLogFileResponse * CClientWsTopology::TpLogFile(IClientTpLogFileRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CTpLogFileRequest* esprequest = static_cast<CTpLogFileRequest*>(request);
	CTpLogFileResponse* espresponse = new CTpLogFileResponse("WsTopology");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientWsTopology::async_TpLogFile(IClientTpLogFileRequest *request, IClientWsTopologyEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CTpLogFileRequest* esprequest = static_cast<CTpLogFileRequest*>(request);
	esprequest->setMethod("TpLogFile");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientWsTopology::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientTpLogFileResponse *CClientWsTopology::TpLogFileFn(const char * Name_, const char * Type_, int LastHours_, const char * StartDate_, const char * EndDate_, int FirstRows_, int LastRows_, int FilterType_, bool Reversely_, bool Zip_, int PageNumber_, bool LoadData_)
{
	Owned<IClientTpLogFileRequest> req =  createTpLogFileRequest();
	req->setName(Name_);
	req->setType(Type_);
	req->setLastHours(LastHours_);
	req->setStartDate(StartDate_);
	req->setEndDate(EndDate_);
	req->setFirstRows(FirstRows_);
	req->setLastRows(LastRows_);
	req->setFilterType(FilterType_);
	req->setReversely(Reversely_);
	req->setZip(Zip_);
	req->setPageNumber(PageNumber_);
	req->setLoadData(LoadData_);
	return TpLogFile(req.get());
}

//------ method TpLogFileDisplay ---------

IClientTpLogFileRequest * CClientWsTopology::createTpLogFileDisplayRequest()
{
	CTpLogFileRequest* request = new CTpLogFileRequest("WsTopology");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientTpLogFileResponse * CClientWsTopology::TpLogFileDisplay(IClientTpLogFileRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CTpLogFileRequest* esprequest = static_cast<CTpLogFileRequest*>(request);
	CTpLogFileResponse* espresponse = new CTpLogFileResponse("WsTopology");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientWsTopology::async_TpLogFileDisplay(IClientTpLogFileRequest *request, IClientWsTopologyEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CTpLogFileRequest* esprequest = static_cast<CTpLogFileRequest*>(request);
	esprequest->setMethod("TpLogFileDisplay");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientWsTopology::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientTpLogFileResponse *CClientWsTopology::TpLogFileDisplayFn(const char * Name_, const char * Type_, int LastHours_, const char * StartDate_, const char * EndDate_, int FirstRows_, int LastRows_, int FilterType_, bool Reversely_, bool Zip_, int PageNumber_, bool LoadData_)
{
	Owned<IClientTpLogFileRequest> req =  createTpLogFileDisplayRequest();
	req->setName(Name_);
	req->setType(Type_);
	req->setLastHours(LastHours_);
	req->setStartDate(StartDate_);
	req->setEndDate(EndDate_);
	req->setFirstRows(FirstRows_);
	req->setLastRows(LastRows_);
	req->setFilterType(FilterType_);
	req->setReversely(Reversely_);
	req->setZip(Zip_);
	req->setPageNumber(PageNumber_);
	req->setLoadData(LoadData_);
	return TpLogFileDisplay(req.get());
}

//------ method TpLogicalClusterQuery ---------

IClientTpLogicalClusterQueryRequest * CClientWsTopology::createTpLogicalClusterQueryRequest()
{
	CTpLogicalClusterQueryRequest* request = new CTpLogicalClusterQueryRequest("WsTopology");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientTpLogicalClusterQueryResponse * CClientWsTopology::TpLogicalClusterQuery(IClientTpLogicalClusterQueryRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CTpLogicalClusterQueryRequest* esprequest = static_cast<CTpLogicalClusterQueryRequest*>(request);
	CTpLogicalClusterQueryResponse* espresponse = new CTpLogicalClusterQueryResponse("WsTopology");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientWsTopology::async_TpLogicalClusterQuery(IClientTpLogicalClusterQueryRequest *request, IClientWsTopologyEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CTpLogicalClusterQueryRequest* esprequest = static_cast<CTpLogicalClusterQueryRequest*>(request);
	esprequest->setMethod("TpLogicalClusterQuery");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientWsTopology::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientTpLogicalClusterQueryResponse *CClientWsTopology::TpLogicalClusterQueryFn(const char * EclServerQueue_)
{
	Owned<IClientTpLogicalClusterQueryRequest> req =  createTpLogicalClusterQueryRequest();
	req->setEclServerQueue(EclServerQueue_);
	return TpLogicalClusterQuery(req.get());
}

//------ method TpMachineInfo ---------

IClientTpMachineInfoRequest * CClientWsTopology::createTpMachineInfoRequest()
{
	CTpMachineInfoRequest* request = new CTpMachineInfoRequest("WsTopology");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientTpMachineInfoResponse * CClientWsTopology::TpMachineInfo(IClientTpMachineInfoRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CTpMachineInfoRequest* esprequest = static_cast<CTpMachineInfoRequest*>(request);
	CTpMachineInfoResponse* espresponse = new CTpMachineInfoResponse("WsTopology");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientWsTopology::async_TpMachineInfo(IClientTpMachineInfoRequest *request, IClientWsTopologyEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CTpMachineInfoRequest* esprequest = static_cast<CTpMachineInfoRequest*>(request);
	esprequest->setMethod("TpMachineInfo");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientWsTopology::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientTpMachineInfoResponse *CClientWsTopology::TpMachineInfoFn(const char * Name_, const char * NetAddress_)
{
	Owned<IClientTpMachineInfoRequest> req =  createTpMachineInfoRequest();
	req->setName(Name_);
	req->setNetAddress(NetAddress_);
	return TpMachineInfo(req.get());
}

//------ method TpMachineQuery ---------

IClientTpMachineQueryRequest * CClientWsTopology::createTpMachineQueryRequest()
{
	CTpMachineQueryRequest* request = new CTpMachineQueryRequest("WsTopology");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientTpMachineQueryResponse * CClientWsTopology::TpMachineQuery(IClientTpMachineQueryRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CTpMachineQueryRequest* esprequest = static_cast<CTpMachineQueryRequest*>(request);
	CTpMachineQueryResponse* espresponse = new CTpMachineQueryResponse("WsTopology");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientWsTopology::async_TpMachineQuery(IClientTpMachineQueryRequest *request, IClientWsTopologyEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CTpMachineQueryRequest* esprequest = static_cast<CTpMachineQueryRequest*>(request);
	esprequest->setMethod("TpMachineQuery");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientWsTopology::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientTpMachineQueryResponse *CClientWsTopology::TpMachineQueryFn(const char * Type_, const char * Cluster_, const char * OldIP_, const char * Path_, const char * Directory_, const char * LogDirectory_)
{
	Owned<IClientTpMachineQueryRequest> req =  createTpMachineQueryRequest();
	req->setType(Type_);
	req->setCluster(Cluster_);
	req->setOldIP(OldIP_);
	req->setPath(Path_);
	req->setDirectory(Directory_);
	req->setLogDirectory(LogDirectory_);
	return TpMachineQuery(req.get());
}

//------ method TpServiceQuery ---------

IClientTpServiceQueryRequest * CClientWsTopology::createTpServiceQueryRequest()
{
	CTpServiceQueryRequest* request = new CTpServiceQueryRequest("WsTopology");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientTpServiceQueryResponse * CClientWsTopology::TpServiceQuery(IClientTpServiceQueryRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CTpServiceQueryRequest* esprequest = static_cast<CTpServiceQueryRequest*>(request);
	CTpServiceQueryResponse* espresponse = new CTpServiceQueryResponse("WsTopology");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientWsTopology::async_TpServiceQuery(IClientTpServiceQueryRequest *request, IClientWsTopologyEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CTpServiceQueryRequest* esprequest = static_cast<CTpServiceQueryRequest*>(request);
	esprequest->setMethod("TpServiceQuery");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientWsTopology::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientTpServiceQueryResponse *CClientWsTopology::TpServiceQueryFn(const char * Type_)
{
	Owned<IClientTpServiceQueryRequest> req =  createTpServiceQueryRequest();
	req->setType(Type_);
	return TpServiceQuery(req.get());
}

//------ method TpSetMachineStatus ---------

IClientTpSetMachineStatusRequest * CClientWsTopology::createTpSetMachineStatusRequest()
{
	CTpSetMachineStatusRequest* request = new CTpSetMachineStatusRequest("WsTopology");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientTpSetMachineStatusResponse * CClientWsTopology::TpSetMachineStatus(IClientTpSetMachineStatusRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CTpSetMachineStatusRequest* esprequest = static_cast<CTpSetMachineStatusRequest*>(request);
	CTpSetMachineStatusResponse* espresponse = new CTpSetMachineStatusResponse("WsTopology");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientWsTopology::async_TpSetMachineStatus(IClientTpSetMachineStatusRequest *request, IClientWsTopologyEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CTpSetMachineStatusRequest* esprequest = static_cast<CTpSetMachineStatusRequest*>(request);
	esprequest->setMethod("TpSetMachineStatus");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientWsTopology::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientTpSetMachineStatusResponse *CClientWsTopology::TpSetMachineStatusFn(const char * MachinePath_, const char * StatusValue_)
{
	Owned<IClientTpSetMachineStatusRequest> req =  createTpSetMachineStatusRequest();
	req->setMachinePath(MachinePath_);
	req->setStatusValue(StatusValue_);
	return TpSetMachineStatus(req.get());
}

//------ method TpSwapNode ---------

IClientTpSwapNodeRequest * CClientWsTopology::createTpSwapNodeRequest()
{
	CTpSwapNodeRequest* request = new CTpSwapNodeRequest("WsTopology");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientTpSwapNodeResponse * CClientWsTopology::TpSwapNode(IClientTpSwapNodeRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CTpSwapNodeRequest* esprequest = static_cast<CTpSwapNodeRequest*>(request);
	CTpSwapNodeResponse* espresponse = new CTpSwapNodeResponse("WsTopology");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientWsTopology::async_TpSwapNode(IClientTpSwapNodeRequest *request, IClientWsTopologyEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CTpSwapNodeRequest* esprequest = static_cast<CTpSwapNodeRequest*>(request);
	esprequest->setMethod("TpSwapNode");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientWsTopology::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientTpSwapNodeResponse *CClientWsTopology::TpSwapNodeFn(const char * Cluster_, const char * OldIP_, const char * NewIP_)
{
	Owned<IClientTpSwapNodeRequest> req =  createTpSwapNodeRequest();
	req->setCluster(Cluster_);
	req->setOldIP(OldIP_);
	req->setNewIP(NewIP_);
	return TpSwapNode(req.get());
}

//------ method TpTargetClusterQuery ---------

IClientTpTargetClusterQueryRequest * CClientWsTopology::createTpTargetClusterQueryRequest()
{
	CTpTargetClusterQueryRequest* request = new CTpTargetClusterQueryRequest("WsTopology");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientTpTargetClusterQueryResponse * CClientWsTopology::TpTargetClusterQuery(IClientTpTargetClusterQueryRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CTpTargetClusterQueryRequest* esprequest = static_cast<CTpTargetClusterQueryRequest*>(request);
	CTpTargetClusterQueryResponse* espresponse = new CTpTargetClusterQueryResponse("WsTopology");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientWsTopology::async_TpTargetClusterQuery(IClientTpTargetClusterQueryRequest *request, IClientWsTopologyEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CTpTargetClusterQueryRequest* esprequest = static_cast<CTpTargetClusterQueryRequest*>(request);
	esprequest->setMethod("TpTargetClusterQuery");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientWsTopology::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientTpTargetClusterQueryResponse *CClientWsTopology::TpTargetClusterQueryFn(const char * Type_, const char * Name_, bool ShowDetails_)
{
	Owned<IClientTpTargetClusterQueryRequest> req =  createTpTargetClusterQueryRequest();
	req->setType(Type_);
	req->setName(Name_);
	req->setShowDetails(ShowDetails_);
	return TpTargetClusterQuery(req.get());
}

//------ method TpThorStatus ---------

IClientTpThorStatusRequest * CClientWsTopology::createTpThorStatusRequest()
{
	CTpThorStatusRequest* request = new CTpThorStatusRequest("WsTopology");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientTpThorStatusResponse * CClientWsTopology::TpThorStatus(IClientTpThorStatusRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CTpThorStatusRequest* esprequest = static_cast<CTpThorStatusRequest*>(request);
	CTpThorStatusResponse* espresponse = new CTpThorStatusResponse("WsTopology");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientWsTopology::async_TpThorStatus(IClientTpThorStatusRequest *request, IClientWsTopologyEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CTpThorStatusRequest* esprequest = static_cast<CTpThorStatusRequest*>(request);
	esprequest->setMethod("TpThorStatus");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientWsTopology::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientTpThorStatusResponse *CClientWsTopology::TpThorStatusFn(const char * Name_)
{
	Owned<IClientTpThorStatusRequest> req =  createTpThorStatusRequest();
	req->setName(Name_);
	return TpThorStatus(req.get());
}

//------ method TpXMLFile ---------

IClientTpXMLFileRequest * CClientWsTopology::createTpXMLFileRequest()
{
	CTpXMLFileRequest* request = new CTpXMLFileRequest("WsTopology");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientTpXMLFileResponse * CClientWsTopology::TpXMLFile(IClientTpXMLFileRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CTpXMLFileRequest* esprequest = static_cast<CTpXMLFileRequest*>(request);
	CTpXMLFileResponse* espresponse = new CTpXMLFileResponse("WsTopology");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientWsTopology::async_TpXMLFile(IClientTpXMLFileRequest *request, IClientWsTopologyEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CTpXMLFileRequest* esprequest = static_cast<CTpXMLFileRequest*>(request);
	esprequest->setMethod("TpXMLFile");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientWsTopology::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientTpXMLFileResponse *CClientWsTopology::TpXMLFileFn(const char * Name_)
{
	Owned<IClientTpXMLFileRequest> req =  createTpXMLFileRequest();
	req->setName(Name_);
	return TpXMLFile(req.get());
}

int CClientWsTopology::transferThunkEvent(void *data)
{
	IRpcResponseBinding *response = (IRpcResponseBinding *)data;
	if (response!=NULL)
	{
		IClientWsTopologyEvents *eventSink = (IClientWsTopologyEvents *)response->getEventSink();
		response->lock();

		if (stricmp(response->getMethod(), "Ping")==0)
		{
			IClientWsTopologyPingResponse* icresp = dynamic_cast<IClientWsTopologyPingResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onPingComplete(icresp, response->queryState());
				else
					eventSink->onPingError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "SystemLog")==0)
		{
			IClientSystemLogResponse* icresp = dynamic_cast<IClientSystemLogResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onSystemLogComplete(icresp, response->queryState());
				else
					eventSink->onSystemLogError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "TpClusterInfo")==0)
		{
			IClientTpClusterInfoResponse* icresp = dynamic_cast<IClientTpClusterInfoResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onTpClusterInfoComplete(icresp, response->queryState());
				else
					eventSink->onTpClusterInfoError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "TpClusterQuery")==0)
		{
			IClientTpClusterQueryResponse* icresp = dynamic_cast<IClientTpClusterQueryResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onTpClusterQueryComplete(icresp, response->queryState());
				else
					eventSink->onTpClusterQueryError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "TpDropZoneQuery")==0)
		{
			IClientTpDropZoneQueryResponse* icresp = dynamic_cast<IClientTpDropZoneQueryResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onTpDropZoneQueryComplete(icresp, response->queryState());
				else
					eventSink->onTpDropZoneQueryError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "TpGetComponentFile")==0)
		{
			IClientTpGetComponentFileResponse* icresp = dynamic_cast<IClientTpGetComponentFileResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onTpGetComponentFileComplete(icresp, response->queryState());
				else
					eventSink->onTpGetComponentFileError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "TpGetServicePlugins")==0)
		{
			IClientTpGetServicePluginsResponse* icresp = dynamic_cast<IClientTpGetServicePluginsResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onTpGetServicePluginsComplete(icresp, response->queryState());
				else
					eventSink->onTpGetServicePluginsError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "TpGroupQuery")==0)
		{
			IClientTpGroupQueryResponse* icresp = dynamic_cast<IClientTpGroupQueryResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onTpGroupQueryComplete(icresp, response->queryState());
				else
					eventSink->onTpGroupQueryError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "TpListTargetClusters")==0)
		{
			IClientTpListTargetClustersResponse* icresp = dynamic_cast<IClientTpListTargetClustersResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onTpListTargetClustersComplete(icresp, response->queryState());
				else
					eventSink->onTpListTargetClustersError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "TpLogFile")==0)
		{
			IClientTpLogFileResponse* icresp = dynamic_cast<IClientTpLogFileResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onTpLogFileComplete(icresp, response->queryState());
				else
					eventSink->onTpLogFileError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "TpLogFileDisplay")==0)
		{
			IClientTpLogFileResponse* icresp = dynamic_cast<IClientTpLogFileResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onTpLogFileDisplayComplete(icresp, response->queryState());
				else
					eventSink->onTpLogFileDisplayError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "TpLogicalClusterQuery")==0)
		{
			IClientTpLogicalClusterQueryResponse* icresp = dynamic_cast<IClientTpLogicalClusterQueryResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onTpLogicalClusterQueryComplete(icresp, response->queryState());
				else
					eventSink->onTpLogicalClusterQueryError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "TpMachineInfo")==0)
		{
			IClientTpMachineInfoResponse* icresp = dynamic_cast<IClientTpMachineInfoResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onTpMachineInfoComplete(icresp, response->queryState());
				else
					eventSink->onTpMachineInfoError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "TpMachineQuery")==0)
		{
			IClientTpMachineQueryResponse* icresp = dynamic_cast<IClientTpMachineQueryResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onTpMachineQueryComplete(icresp, response->queryState());
				else
					eventSink->onTpMachineQueryError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "TpServiceQuery")==0)
		{
			IClientTpServiceQueryResponse* icresp = dynamic_cast<IClientTpServiceQueryResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onTpServiceQueryComplete(icresp, response->queryState());
				else
					eventSink->onTpServiceQueryError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "TpSetMachineStatus")==0)
		{
			IClientTpSetMachineStatusResponse* icresp = dynamic_cast<IClientTpSetMachineStatusResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onTpSetMachineStatusComplete(icresp, response->queryState());
				else
					eventSink->onTpSetMachineStatusError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "TpSwapNode")==0)
		{
			IClientTpSwapNodeResponse* icresp = dynamic_cast<IClientTpSwapNodeResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onTpSwapNodeComplete(icresp, response->queryState());
				else
					eventSink->onTpSwapNodeError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "TpTargetClusterQuery")==0)
		{
			IClientTpTargetClusterQueryResponse* icresp = dynamic_cast<IClientTpTargetClusterQueryResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onTpTargetClusterQueryComplete(icresp, response->queryState());
				else
					eventSink->onTpTargetClusterQueryError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "TpThorStatus")==0)
		{
			IClientTpThorStatusResponse* icresp = dynamic_cast<IClientTpThorStatusResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onTpThorStatusComplete(icresp, response->queryState());
				else
					eventSink->onTpThorStatusError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "TpXMLFile")==0)
		{
			IClientTpXMLFileResponse* icresp = dynamic_cast<IClientTpXMLFileResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onTpXMLFileComplete(icresp, response->queryState());
				else
					eventSink->onTpXMLFileError(icresp,response->queryState());
			}
		}
		response->unlock();
	}
	return 0;
}

static IRpcResponseBinding* createWsTopologyResponseObject(IRpcRequestBinding *request)
{
	const char* method = request->getMethod();
	if (stricmp(method, "Ping")==0)
		return new CWsTopologyPingResponse("WsTopology", request);
	if (stricmp(method, "SystemLog")==0)
		return new CSystemLogResponse("WsTopology", request);
	if (stricmp(method, "TpClusterInfo")==0)
		return new CTpClusterInfoResponse("WsTopology", request);
	if (stricmp(method, "TpClusterQuery")==0)
		return new CTpClusterQueryResponse("WsTopology", request);
	if (stricmp(method, "TpDropZoneQuery")==0)
		return new CTpDropZoneQueryResponse("WsTopology", request);
	if (stricmp(method, "TpGetComponentFile")==0)
		return new CTpGetComponentFileResponse("WsTopology", request);
	if (stricmp(method, "TpGetServicePlugins")==0)
		return new CTpGetServicePluginsResponse("WsTopology", request);
	if (stricmp(method, "TpGroupQuery")==0)
		return new CTpGroupQueryResponse("WsTopology", request);
	if (stricmp(method, "TpListTargetClusters")==0)
		return new CTpListTargetClustersResponse("WsTopology", request);
	if (stricmp(method, "TpLogFile")==0)
		return new CTpLogFileResponse("WsTopology", request);
	if (stricmp(method, "TpLogFileDisplay")==0)
		return new CTpLogFileResponse("WsTopology", request);
	if (stricmp(method, "TpLogicalClusterQuery")==0)
		return new CTpLogicalClusterQueryResponse("WsTopology", request);
	if (stricmp(method, "TpMachineInfo")==0)
		return new CTpMachineInfoResponse("WsTopology", request);
	if (stricmp(method, "TpMachineQuery")==0)
		return new CTpMachineQueryResponse("WsTopology", request);
	if (stricmp(method, "TpServiceQuery")==0)
		return new CTpServiceQueryResponse("WsTopology", request);
	if (stricmp(method, "TpSetMachineStatus")==0)
		return new CTpSetMachineStatusResponse("WsTopology", request);
	if (stricmp(method, "TpSwapNode")==0)
		return new CTpSwapNodeResponse("WsTopology", request);
	if (stricmp(method, "TpTargetClusterQuery")==0)
		return new CTpTargetClusterQueryResponse("WsTopology", request);
	if (stricmp(method, "TpThorStatus")==0)
		return new CTpThorStatusResponse("WsTopology", request);
	if (stricmp(method, "TpXMLFile")==0)
		return new CTpXMLFileResponse("WsTopology", request);
	return NULL;
}

#ifdef _WIN32
void CClientWsTopology::espWorkerThread(void* data)
#else
void *CClientWsTopology::espWorkerThread(void *data)
#endif
{
	IRpcRequestBinding *request = (IRpcRequestBinding *) data;

	if (request != NULL)
	{
		request->lock();
		IRpcResponseBinding *response=createWsTopologyResponseObject(request);
		if (response!=NULL)
		{
			try{
				request->post(*response);
			}
			catch(IException* ex){
				StringBuffer errorStr;
				ex->errorMessage(errorStr);
				ERRLOG("CClientWsTopology::espWorkerThread(%s)--Exception caught while posting async request: %s", request->getMethod(), errorStr.str());
				ex->Release();
			}
			catch(...){
				ERRLOG("Unknown exception caught while posting async request");
			}
		}
#ifdef USE_CLIENT_THREAD
		ThunkToClientThread(request->getThunkHandle(), transferThunkEvent, (void *)response);
#else
		transferThunkEvent((void *)response);
#endif
		request->unlock();
		if(request->queryState()!=NULL)
			request->queryState()->Release();

		if(response!=NULL)
			response->Release();

		request->Release();
	}
#if defined(_WIN32)
#else
	return (void *) 0 ;
#endif
}



extern "C" IClientWsTopology * createWsTopologyClient() {  return new CClientWsTopology(); }


#endif //ws_topology_ESPGEN_INCLUDED
