// *** Source file generated by HIDL Version 1.3 from ws_fileio.ecm ***
// *** Not to be hand edited (changes will be lost on re-generation) ***

#ifndef ws_fileio_EX_ESPGEN_INCLUDED
#define ws_fileio_EX_ESPGEN_INCLUDED

#pragma warning( disable : 4786)

//JLib
#include "jliball.hpp"

//SCM Interfaces
#include "esp.hpp"
#include "soapesp.hpp"
#include "ws_fileio.hpp"
//ESP Bindings
#include "SOAP/Platform/soapmessage.hpp"
#include "SOAP/Platform/soapmacro.hpp"
#include "SOAP/Platform/soapservice.hpp"
#include "SOAP/Platform/soapparam.hpp"
#include "SOAP/client/soapclient.hpp"


namespace ws_fileio
{

class CCreateFileRequest : public CSoapRequestBinding,
   implements IEspCreateFileRequest,
   implements IClientCreateFileRequest
{
protected:
	SoapStringParam m_DestDropZone;
	SoapStringParam m_DestRelativePath;
	SoapParam<bool> m_Overwrite;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CCreateFileRequest(const char *serviceName, const char *bcompat);

	CCreateFileRequest(const char *serviceName, IRpcMessageBinding *init=NULL);
	CCreateFileRequest(const char *serviceName, IRpcMessage* rpcmsg);
	CCreateFileRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	IEspClientRpcSettings &rpc(){return *static_cast<IEspClientRpcSettings*>(this);}


	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "CreateFileRequest";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CCreateFileRequest &from);

	void copy(IConstCreateFileRequest &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstCreateFileRequest &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	const char * getDestDropZone();
	const char * getDestRelativePath();
	bool getOverwrite();
	void setDestDropZone(const char * val);
	void setDestRelativePath(const char * val);
	void setOverwrite(bool val);
};

class CCreateFileResponse : public CSoapResponseBinding,
   implements IEspCreateFileResponse,
   implements IClientCreateFileResponse
{
protected:
	SoapStringParam m_DestDropZone;
	SoapStringParam m_DestRelativePath;
	SoapParam<bool> m_Overwrite;
	SoapStringParam m_Result;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CCreateFileResponse(const char *serviceName, const char *bcompat);

	CCreateFileResponse(const char *serviceName, IRpcMessageBinding *init=NULL);
	CCreateFileResponse(const char *serviceName, IRpcMessage* rpcmsg);
	CCreateFileResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "CreateFileResponse";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CCreateFileResponse &from);

	void copy(IConstCreateFileResponse &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstCreateFileResponse &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	virtual void setRedirectUrl(const char *url)
	{ CSoapResponseBinding::setRedirectUrl(url); }

	virtual const IMultiException& getExceptions()
	{ return CSoapResponseBinding::getExceptions(); }

	virtual int queryClientStatus()
	{ return CSoapResponseBinding::getRpcState(); }

	virtual void noteException(IException& e)
	{  CSoapResponseBinding::noteException(e); }

	const char * getDestDropZone();
	const char * getDestRelativePath();
bool getOverwrite_isNull();
	bool getOverwrite();
	const char * getResult();
	void setDestDropZone(const char * val);
	void setDestRelativePath(const char * val);
	void setOverwrite_null();
	void setOverwrite(bool val);
	void setResult(const char * val);
};

class CWriteFileDataRequest : public CSoapRequestBinding,
   implements IEspWriteFileDataRequest,
   implements IClientWriteFileDataRequest
{
protected:
	SoapParamBinary m_Data;
	SoapStringParam m_DestDropZone;
	SoapStringParam m_DestRelativePath;
	SoapParam<__int64> m_Offset;
	SoapParam<bool> m_Append;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CWriteFileDataRequest(const char *serviceName, const char *bcompat);

	CWriteFileDataRequest(const char *serviceName, IRpcMessageBinding *init=NULL);
	CWriteFileDataRequest(const char *serviceName, IRpcMessage* rpcmsg);
	CWriteFileDataRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	IEspClientRpcSettings &rpc(){return *static_cast<IEspClientRpcSettings*>(this);}


	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "WriteFileDataRequest";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CWriteFileDataRequest &from);

	void copy(IConstWriteFileDataRequest &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstWriteFileDataRequest &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	const MemoryBuffer & getData();
	const char * getDestDropZone();
	const char * getDestRelativePath();
	__int64 getOffset();
	bool getAppend();
	void setData(const MemoryBuffer & val);
	void setDestDropZone(const char * val);
	void setDestRelativePath(const char * val);
	void setOffset(__int64 val);
	void setAppend(bool val);
};

class CWriteFileDataResponse : public CSoapResponseBinding,
   implements IEspWriteFileDataResponse,
   implements IClientWriteFileDataResponse
{
protected:
	SoapStringParam m_DestDropZone;
	SoapStringParam m_DestRelativePath;
	SoapParam<__int64> m_Offset;
	SoapParam<bool> m_Append;
	SoapStringParam m_Result;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CWriteFileDataResponse(const char *serviceName, const char *bcompat);

	CWriteFileDataResponse(const char *serviceName, IRpcMessageBinding *init=NULL);
	CWriteFileDataResponse(const char *serviceName, IRpcMessage* rpcmsg);
	CWriteFileDataResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "WriteFileDataResponse";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CWriteFileDataResponse &from);

	void copy(IConstWriteFileDataResponse &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstWriteFileDataResponse &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	virtual void setRedirectUrl(const char *url)
	{ CSoapResponseBinding::setRedirectUrl(url); }

	virtual const IMultiException& getExceptions()
	{ return CSoapResponseBinding::getExceptions(); }

	virtual int queryClientStatus()
	{ return CSoapResponseBinding::getRpcState(); }

	virtual void noteException(IException& e)
	{  CSoapResponseBinding::noteException(e); }

	const char * getDestDropZone();
	const char * getDestRelativePath();
bool getOffset_isNull();
	__int64 getOffset();
bool getAppend_isNull();
	bool getAppend();
	const char * getResult();
	void setDestDropZone(const char * val);
	void setDestRelativePath(const char * val);
	void setOffset_null();
	void setOffset(__int64 val);
	void setAppend_null();
	void setAppend(bool val);
	void setResult(const char * val);
};

class CReadFileDataRequest : public CSoapRequestBinding,
   implements IEspReadFileDataRequest,
   implements IClientReadFileDataRequest
{
protected:
	SoapStringParam m_DestDropZone;
	SoapStringParam m_DestRelativePath;
	SoapParam<__int64> m_Offset;
	SoapParam<__int64> m_DataSize;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CReadFileDataRequest(const char *serviceName, const char *bcompat);

	CReadFileDataRequest(const char *serviceName, IRpcMessageBinding *init=NULL);
	CReadFileDataRequest(const char *serviceName, IRpcMessage* rpcmsg);
	CReadFileDataRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	IEspClientRpcSettings &rpc(){return *static_cast<IEspClientRpcSettings*>(this);}


	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "ReadFileDataRequest";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CReadFileDataRequest &from);

	void copy(IConstReadFileDataRequest &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstReadFileDataRequest &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	const char * getDestDropZone();
	const char * getDestRelativePath();
	__int64 getOffset();
	__int64 getDataSize();
	void setDestDropZone(const char * val);
	void setDestRelativePath(const char * val);
	void setOffset(__int64 val);
	void setDataSize(__int64 val);
};

class CReadFileDataResponse : public CSoapResponseBinding,
   implements IEspReadFileDataResponse,
   implements IClientReadFileDataResponse
{
protected:
	SoapParamBinary m_Data;
	SoapStringParam m_DestDropZone;
	SoapStringParam m_DestRelativePath;
	SoapParam<__int64> m_Offset;
	SoapParam<__int64> m_DataSize;
	SoapStringParam m_Result;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CReadFileDataResponse(const char *serviceName, const char *bcompat);

	CReadFileDataResponse(const char *serviceName, IRpcMessageBinding *init=NULL);
	CReadFileDataResponse(const char *serviceName, IRpcMessage* rpcmsg);
	CReadFileDataResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "ReadFileDataResponse";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CReadFileDataResponse &from);

	void copy(IConstReadFileDataResponse &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstReadFileDataResponse &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	virtual void setRedirectUrl(const char *url)
	{ CSoapResponseBinding::setRedirectUrl(url); }

	virtual const IMultiException& getExceptions()
	{ return CSoapResponseBinding::getExceptions(); }

	virtual int queryClientStatus()
	{ return CSoapResponseBinding::getRpcState(); }

	virtual void noteException(IException& e)
	{  CSoapResponseBinding::noteException(e); }

	const MemoryBuffer & getData();
	const char * getDestDropZone();
	const char * getDestRelativePath();
bool getOffset_isNull();
	__int64 getOffset();
bool getDataSize_isNull();
	__int64 getDataSize();
	const char * getResult();
	void setData(const MemoryBuffer & val);
	void setDestDropZone(const char * val);
	void setDestRelativePath(const char * val);
	void setOffset_null();
	void setOffset(__int64 val);
	void setDataSize_null();
	void setDataSize(__int64 val);
	void setResult(const char * val);
};

class CWsFileIOPingRequest : public CSoapRequestBinding,
   implements IEspWsFileIOPingRequest,
   implements IClientWsFileIOPingRequest
{
protected:

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CWsFileIOPingRequest(const char *serviceName, const char *bcompat);

	CWsFileIOPingRequest(const char *serviceName, IRpcMessageBinding *init=NULL);
	CWsFileIOPingRequest(const char *serviceName, IRpcMessage* rpcmsg);
	CWsFileIOPingRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	IEspClientRpcSettings &rpc(){return *static_cast<IEspClientRpcSettings*>(this);}


	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "WsFileIOPingRequest";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CWsFileIOPingRequest &from);

	void copy(IConstWsFileIOPingRequest &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstWsFileIOPingRequest &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

};

class CWsFileIOPingResponse : public CSoapResponseBinding,
   implements IEspWsFileIOPingResponse,
   implements IClientWsFileIOPingResponse
{
protected:

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CWsFileIOPingResponse(const char *serviceName, const char *bcompat);

	CWsFileIOPingResponse(const char *serviceName, IRpcMessageBinding *init=NULL);
	CWsFileIOPingResponse(const char *serviceName, IRpcMessage* rpcmsg);
	CWsFileIOPingResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "WsFileIOPingResponse";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CWsFileIOPingResponse &from);

	void copy(IConstWsFileIOPingResponse &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstWsFileIOPingResponse &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	virtual void setRedirectUrl(const char *url)
	{ CSoapResponseBinding::setRedirectUrl(url); }

	virtual const IMultiException& getExceptions()
	{ return CSoapResponseBinding::getExceptions(); }

	virtual int queryClientStatus()
	{ return CSoapResponseBinding::getRpcState(); }

	virtual void noteException(IException& e)
	{  CSoapResponseBinding::noteException(e); }

};

class CWsFileIO : public CInterface,
	implements IEspWsFileIO
{
private:
	IEspContainer* m_container;
public:
	IMPLEMENT_IINTERFACE;

	CWsFileIO(){}
	virtual ~CWsFileIO(){}
	virtual void init(IPropertyTree *cfg, const char *process, const char *service)
	{
	}
	virtual bool init(const char * service, const char * type, IPropertyTree * cfg, const char * process)
	{
		return true;
	}
	virtual void setContainer(IEspContainer *c)
	{
		m_container = c;
	}
	virtual IEspContainer *queryContainer()
	{
		return m_container;
	}
	virtual const char* getServiceType(){return "WsFileIO";}

	virtual bool unsubscribeServiceFromDali(){return false;}

	virtual bool subscribeServiceToDali(){return false;}

	virtual bool detachServiceFromDali(){return false;}

	virtual bool attachServiceToDali(){return false;}

	virtual bool canDetachFromDali(){return false;}

	//bool onCreateFile(IEspContext &context, IEspCreateFileRequest &req, IEspCreateFileResponse &resp)
	//{
		//return false;
	//}
	bool onPing(IEspContext &context, IEspWsFileIOPingRequest &req, IEspWsFileIOPingResponse &resp)
	{
		return true;
	}
	//bool onReadFileData(IEspContext &context, IEspReadFileDataRequest &req, IEspReadFileDataResponse &resp)
	//{
		//return false;
	//}
	//bool onWriteFileData(IEspContext &context, IEspWriteFileDataRequest &req, IEspWriteFileDataResponse &resp)
	//{
		//return false;
	//}
};





class CWsFileIOSoapBinding : public CHttpSoapBinding
{
public:
	CWsFileIOSoapBinding(http_soap_log_level level=hsl_none);
	CWsFileIOSoapBinding(IPropertyTree* cfg, const char *bindname=NULL, const char *procname=NULL, http_soap_log_level level=hsl_none);
	virtual void init_strings();
	virtual unsigned getCacheMethodCount(){return m_cacheMethodCount;}
	virtual int processRequest(IRpcMessage* rpc_call, IRpcMessage* rpc_response);
	int getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &content, const char *service, const char *method, bool mda);
	virtual int getMethodHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &page, bool bIncludeFormTag);
	int getQualifiedNames(IEspContext& ctx, MethodInfoArray & methods);
	StringBuffer & getServiceName(StringBuffer &resp);
	bool isValidServiceName(IEspContext &context, const char *name);
	bool qualifyMethodName(IEspContext &context, const char *methname, StringBuffer *methQName);
	bool qualifyServiceName(IEspContext &context, const char *servname, const char *methname, StringBuffer &servQName, StringBuffer *methQName);
	virtual int onGetFile(IEspContext &context, CHttpRequest* request, CHttpResponse* response, const char *pathex);
	virtual int onGetForm(IEspContext &context, CHttpRequest* request, CHttpResponse* response, const char *service, const char *method);
	virtual int onGetXForm(IEspContext &context, CHttpRequest* request, CHttpResponse* response, const char *service, const char *method);
	virtual int onGetService(IEspContext &context, CHttpRequest* request, CHttpResponse* response, const char *service, const char *method, const char *pathex);
	virtual IRpcRequestBinding *createReqBinding(IEspContext &context, IHttpMessage* request, const char *service, const char *method);
	virtual int onGetInstantQuery(IEspContext &context, CHttpRequest* request, CHttpResponse* response, const char *service, const char *method);
	void setXslProcessor(IInterface *xslp_)
	{
		IXslProcessor *ixslp = dynamic_cast<IXslProcessor *>(xslp_);
		if (!ixslp)
			xslp.clear();
		else
			xslp.set(ixslp);
	}
private:
	Owned<IXslProcessor> xslp;
	void xslTransform(const char* xml, const char* xslFile, StringBuffer& output, IProperties *params)
	{
		if (xslp)
		{
			Owned<IXslTransform> xform = xslp->createXslTransform();
			StringBuffer xslpath;
			if (!strnicmp(xslFile, "/esp/xslt/", 10))
				if (!checkFileExists(xslpath.append(getCFD()).append("smc_xslt/").append(xslFile+10).str()) && !checkFileExists(xslpath.append(getCFD()).append("xslt/").append(xslFile+10).str()))
					return;
			xform->loadXslFromFile((xslpath.length()) ? xslpath.str() : xslFile);
			xform->setXmlSource(xml, strlen(xml)+1);
			if (params) xform->copyParameters(params);
			xform->transform(output.clear());
		}
	}
	unsigned m_cacheMethodCount = 0;
};



class CClientWsFileIO : public CInterface,
	implements IClientWsFileIO
{
protected:
	StringBuffer soap_proxy;
	StringBuffer soap_url;
	StringBuffer soap_userid;
	StringBuffer soap_password;
	StringBuffer soap_realm;
	StringBuffer soap_action;
	long soap_reqid = 0;

public:
	IMPLEMENT_IINTERFACE;

	CClientWsFileIO()
	{
		soap_reqid=0;
			soap_action.append("WsFileIO");
	}
	virtual ~CClientWsFileIO(){}
	virtual void setProxyAddress(const char *address)
	{
		soap_proxy.set(address);
	}
	virtual void addServiceUrl(const char *url)
	{
		soap_url.set(url);
	}
	virtual void removeServiceUrl(const char *url)
	{
	}
	virtual void setUsernameToken(const char *userid,const char *password,const char *realm)
	{
		 soap_userid.set(userid);
		 soap_password.set(password);
		 soap_realm.set(realm);
	}
	virtual void setAction(const char *action)
	{
		soap_action.set(action);
	}

	virtual IClientCreateFileRequest * createCreateFileRequest();
	virtual IClientCreateFileResponse * CreateFile(IClientCreateFileRequest *request);
	virtual void async_CreateFile(IClientCreateFileRequest *request, IClientWsFileIOEvents *events,IInterface* state=0);

	virtual IClientCreateFileResponse *CreateFileFn(const char * DestDropZone_, const char * DestRelativePath_, bool Overwrite_);

	virtual IClientWsFileIOPingRequest * createPingRequest();
	virtual IClientWsFileIOPingResponse * Ping(IClientWsFileIOPingRequest *request);
	virtual void async_Ping(IClientWsFileIOPingRequest *request, IClientWsFileIOEvents *events,IInterface* state=0);

	virtual IClientWsFileIOPingResponse *PingFn();

	virtual IClientReadFileDataRequest * createReadFileDataRequest();
	virtual IClientReadFileDataResponse * ReadFileData(IClientReadFileDataRequest *request);
	virtual void async_ReadFileData(IClientReadFileDataRequest *request, IClientWsFileIOEvents *events,IInterface* state=0);

	virtual IClientReadFileDataResponse *ReadFileDataFn(const char * DestDropZone_, const char * DestRelativePath_, __int64 Offset_, __int64 DataSize_);

	virtual IClientWriteFileDataRequest * createWriteFileDataRequest();
	virtual IClientWriteFileDataResponse * WriteFileData(IClientWriteFileDataRequest *request);
	virtual void async_WriteFileData(IClientWriteFileDataRequest *request, IClientWsFileIOEvents *events,IInterface* state=0);

	virtual IClientWriteFileDataResponse *WriteFileDataFn(const MemoryBuffer & Data_, const char * DestDropZone_, const char * DestRelativePath_, __int64 Offset_, bool Append_);
	static int transferThunkEvent(void *data);
#ifdef _WIN32
	static void espWorkerThread(void* data);
#else
	static void *espWorkerThread(void *data);
#endif
};



}
using namespace ws_fileio;

#endif //ws_fileio_ESPGEN_INCLUDED
