// *** Source file generated by HIDL Version 1.3 from ws_fs.ecm ***
// *** Not to be hand edited (changes will be lost on re-generation) ***

#ifndef ws_fs_EX_ESPGEN_INCLUDED
#define ws_fs_EX_ESPGEN_INCLUDED

#pragma warning( disable : 4786)

//JLib
#include "jliball.hpp"

//SCM Interfaces
#include "esp.hpp"
#include "soapesp.hpp"
#include "ws_fs.hpp"
//ESP Bindings
#include "SOAP/Platform/soapmessage.hpp"
#include "SOAP/Platform/soapmacro.hpp"
#include "SOAP/Platform/soapservice.hpp"
#include "SOAP/Platform/soapparam.hpp"
#include "SOAP/client/soapclient.hpp"


namespace ws_fs
{

class CXDFUWUActions : public SoapEnumParamNew<CDFUWUActions>
{
public:
	CXDFUWUActions(nilBehavior nilB) : SoapEnumParamNew<CDFUWUActions>(nilB)
	{ doInit(); }
	CXDFUWUActions(CDFUWUActions defvalue_) : SoapEnumParamNew<CDFUWUActions>(defvalue_)
	{ doInit(); }
	CXDFUWUActions(const char* defvalue_) : SoapEnumParamNew<CDFUWUActions>()
	{ doInit(); setDefaultValue(defvalue_); }
	static  void getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash &added)
	{ getSharedInstance().getXsdDefinitionInternal(context,request,schema,added); }
	static void getMapInfo(IMapInfo& info, BoolHash& added) { getSharedInstance().getMapInfo_(info,added); }

	static const char* stringOf(CDFUWUActions val) { return getSharedInstance().toString(val); }

	static CDFUWUActions enumOf(const char* s) { return getSharedInstance().toEnum(s); }

static const char *queryXsdElementName() { return "DFUWUActions"; }
private:
	static CXDFUWUActions& getSharedInstance() { static CXDFUWUActions instance(nilIgnore); return instance; }
	void getMapInfo_(IMapInfo& info, BoolHash& added) {  }
	void getXsdDefinitionInternal(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash &added)
	{ getXsdDefinition_(context,request,schema,added,NULL); }
	void doInit()
	{
		static const char* inits[] = {"Delete","Protect","Unprotect","Restore","SetToFailed",NULL};
		init("DFUWUActions","string",inits);
	}
};

class CDFUWorkunit : public CSoapComplexType,
   implements IEspDFUWorkunit,
   implements IClientDFUWorkunit
{
protected:
	SoapStringParam m_ID;
	SoapStringParam m_DFUServerName;
	SoapStringParam m_ClusterName;
	SoapStringParam m_JobName;
	SoapStringParam m_Queue;
	SoapStringParam m_User;
	SoapParam<bool> m_isProtected;
	SoapParam<int> m_Command;
	SoapStringParam m_CommandMessage;
	SoapParam<int> m_PercentDone;
	SoapParam<int> m_SecsLeft;
	SoapStringParam m_ProgressMessage;
	SoapStringParam m_SummaryMessage;
	SoapParam<int> m_State;
	SoapStringParam m_SourceLogicalName;
	SoapStringParam m_SourceIP;
	SoapStringParam m_SourceFilePath;
	SoapStringParam m_SourceDali;
	SoapParam<int> m_SourceRecordSize;
	SoapParam<int> m_SourceFormat;
	SoapStringParam m_RowTag;
	SoapParam<int> m_SourceNumParts;
	SoapStringParam m_SourceDirectory;
	SoapStringParam m_DestLogicalName;
	SoapStringParam m_DestGroupName;
	SoapStringParam m_DestDirectory;
	SoapStringParam m_DestIP;
	SoapStringParam m_DestFilePath;
	SoapParam<int> m_DestFormat;
	SoapParam<int> m_DestNumParts;
	SoapParam<int> m_DestRecordSize;
	SoapParam<bool> m_Replicate;
	SoapParam<bool> m_Overwrite;
	SoapParam<bool> m_Compress;
	SoapStringParam m_SourceCsvSeparate;
	SoapStringParam m_SourceCsvQuote;
	SoapStringParam m_SourceCsvTerminate;
	SoapStringParam m_SourceCsvEscape;
	SoapStringParam m_TimeStarted;
	SoapStringParam m_TimeStopped;
	SoapStringParam m_StateMessage;
	SoapStringParam m_MonitorEventName;
	SoapParam<bool> m_MonitorSub;
	SoapParam<int> m_MonitorShotLimit;
	SoapStringParam m_SourceDiffKeyName;
	SoapStringParam m_DestDiffKeyName;
	SoapParam<bool> m_Archived;
	SoapStringParam m_encrypt;
	SoapStringParam m_decrypt;
	SoapParam<bool> m_failIfNoSourceFile;
	SoapParam<bool> m_recordStructurePresent;
	SoapParam<bool> m_quotedTerminator;
	SoapParam<bool> m_preserveCompression;
	SoapParam<int> m_expireDays;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CDFUWorkunit(const char *serviceName, const char *bcompat);

	CDFUWorkunit(const char *serviceName, IRpcMessageBinding *init=NULL);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "DFUWorkunit";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CDFUWorkunit &from);

	void copy(IConstDFUWorkunit &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstDFUWorkunit &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	const char * getID();
	const char * getDFUServerName();
	const char * getClusterName();
	const char * getJobName();
	const char * getQueue();
	const char * getUser();
bool getIsProtected_isNull();
	bool getIsProtected();
bool getCommand_isNull();
	int getCommand();
	const char * getCommandMessage();
bool getPercentDone_isNull();
	int getPercentDone();
bool getSecsLeft_isNull();
	int getSecsLeft();
	const char * getProgressMessage();
	const char * getSummaryMessage();
bool getState_isNull();
	int getState();
	const char * getSourceLogicalName();
	const char * getSourceIP();
	const char * getSourceFilePath();
	const char * getSourceDali();
bool getSourceRecordSize_isNull();
	int getSourceRecordSize();
bool getSourceFormat_isNull();
	int getSourceFormat();
	const char * getRowTag();
bool getSourceNumParts_isNull();
	int getSourceNumParts();
	const char * getSourceDirectory();
	const char * getDestLogicalName();
	const char * getDestGroupName();
	const char * getDestDirectory();
	const char * getDestIP();
	const char * getDestFilePath();
bool getDestFormat_isNull();
	int getDestFormat();
bool getDestNumParts_isNull();
	int getDestNumParts();
bool getDestRecordSize_isNull();
	int getDestRecordSize();
bool getReplicate_isNull();
	bool getReplicate();
bool getOverwrite_isNull();
	bool getOverwrite();
bool getCompress_isNull();
	bool getCompress();
	const char * getSourceCsvSeparate();
	const char * getSourceCsvQuote();
	const char * getSourceCsvTerminate();
	const char * getSourceCsvEscape();
	const char * getTimeStarted();
	const char * getTimeStopped();
	const char * getStateMessage();
	const char * getMonitorEventName();
bool getMonitorSub_isNull();
	bool getMonitorSub();
bool getMonitorShotLimit_isNull();
	int getMonitorShotLimit();
	const char * getSourceDiffKeyName();
	const char * getDestDiffKeyName();
bool getArchived_isNull();
	bool getArchived();
	const char * getEncrypt();
	const char * getDecrypt();
bool getFailIfNoSourceFile_isNull();
	bool getFailIfNoSourceFile();
bool getRecordStructurePresent_isNull();
	bool getRecordStructurePresent();
bool getQuotedTerminator_isNull();
	bool getQuotedTerminator();
bool getPreserveCompression_isNull();
	bool getPreserveCompression();
bool getExpireDays_isNull();
	int getExpireDays();
	void setID(const char * val);
	void setDFUServerName(const char * val);
	void setClusterName(const char * val);
	void setJobName(const char * val);
	void setQueue(const char * val);
	void setUser(const char * val);
	void setIsProtected_null();
	void setIsProtected(bool val);
	void setCommand_null();
	void setCommand(int val);
	void setCommandMessage(const char * val);
	void setPercentDone_null();
	void setPercentDone(int val);
	void setSecsLeft_null();
	void setSecsLeft(int val);
	void setProgressMessage(const char * val);
	void setSummaryMessage(const char * val);
	void setState_null();
	void setState(int val);
	void setSourceLogicalName(const char * val);
	void setSourceIP(const char * val);
	void setSourceFilePath(const char * val);
	void setSourceDali(const char * val);
	void setSourceRecordSize_null();
	void setSourceRecordSize(int val);
	void setSourceFormat_null();
	void setSourceFormat(int val);
	void setRowTag(const char * val);
	void setSourceNumParts_null();
	void setSourceNumParts(int val);
	void setSourceDirectory(const char * val);
	void setDestLogicalName(const char * val);
	void setDestGroupName(const char * val);
	void setDestDirectory(const char * val);
	void setDestIP(const char * val);
	void setDestFilePath(const char * val);
	void setDestFormat_null();
	void setDestFormat(int val);
	void setDestNumParts_null();
	void setDestNumParts(int val);
	void setDestRecordSize_null();
	void setDestRecordSize(int val);
	void setReplicate_null();
	void setReplicate(bool val);
	void setOverwrite_null();
	void setOverwrite(bool val);
	void setCompress_null();
	void setCompress(bool val);
	void setSourceCsvSeparate(const char * val);
	void setSourceCsvQuote(const char * val);
	void setSourceCsvTerminate(const char * val);
	void setSourceCsvEscape(const char * val);
	void setTimeStarted(const char * val);
	void setTimeStopped(const char * val);
	void setStateMessage(const char * val);
	void setMonitorEventName(const char * val);
	void setMonitorSub_null();
	void setMonitorSub(bool val);
	void setMonitorShotLimit_null();
	void setMonitorShotLimit(int val);
	void setSourceDiffKeyName(const char * val);
	void setDestDiffKeyName(const char * val);
	void setArchived_null();
	void setArchived(bool val);
	void setEncrypt(const char * val);
	void setDecrypt(const char * val);
	void setFailIfNoSourceFile_null();
	void setFailIfNoSourceFile(bool val);
	void setRecordStructurePresent_null();
	void setRecordStructurePresent(bool val);
	void setQuotedTerminator_null();
	void setQuotedTerminator(bool val);
	void setPreserveCompression_null();
	void setPreserveCompression(bool val);
	void setExpireDays_null();
	void setExpireDays(int val);
};

class CGroupNode : public CSoapComplexType,
   implements IEspGroupNode,
   implements IClientGroupNode
{
protected:
	SoapStringParam m_Name;
	SoapStringParam m_ClusterType;
	SoapParam<bool> m_ReplicateOutputs;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CGroupNode(const char *serviceName, const char *bcompat);

	CGroupNode(const char *serviceName, IRpcMessageBinding *init=NULL);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "GroupNode";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CGroupNode &from);

	void copy(IConstGroupNode &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstGroupNode &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	const char * getName();
	const char * getClusterType();
bool getReplicateOutputs_isNull();
	bool getReplicateOutputs();
	void setName(const char * val);
	void setClusterType(const char * val);
	void setReplicateOutputs_null();
	void setReplicateOutputs(bool val);
};

class CDFUException : public CSoapComplexType,
   implements IEspDFUException,
   implements IClientDFUException
{
protected:
	SoapParam<int> m_Code;
	SoapStringParam m_Message;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CDFUException(const char *serviceName, const char *bcompat);

	CDFUException(const char *serviceName, IRpcMessageBinding *init=NULL);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "DFUException";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CDFUException &from);

	void copy(IConstDFUException &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstDFUException &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	int getCode();
	const char * getMessage();
	void setCode(int val);
	void setMessage(const char * val);
};

class CDFUActionResult : public CSoapComplexType,
   implements IEspDFUActionResult,
   implements IClientDFUActionResult
{
protected:
	SoapStringParam m_ID;
	SoapStringParam m_Action;
	SoapStringParam m_Result;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CDFUActionResult(const char *serviceName, const char *bcompat);

	CDFUActionResult(const char *serviceName, IRpcMessageBinding *init=NULL);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "DFUActionResult";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CDFUActionResult &from);

	void copy(IConstDFUActionResult &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstDFUActionResult &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	const char * getID();
	const char * getAction();
	const char * getResult();
	void setID(const char * val);
	void setAction(const char * val);
	void setResult(const char * val);
};

class CDFUWUSearchRequest : public CSoapRequestBinding,
   implements IEspDFUWUSearchRequest,
   implements IClientDFUWUSearchRequest
{
protected:

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CDFUWUSearchRequest(const char *serviceName, const char *bcompat);

	CDFUWUSearchRequest(const char *serviceName, IRpcMessageBinding *init=NULL);
	CDFUWUSearchRequest(const char *serviceName, IRpcMessage* rpcmsg);
	CDFUWUSearchRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	IEspClientRpcSettings &rpc(){return *static_cast<IEspClientRpcSettings*>(this);}


	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "DFUWUSearchRequest";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CDFUWUSearchRequest &from);

	void copy(IConstDFUWUSearchRequest &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstDFUWUSearchRequest &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

};

class CDFUWUSearchResponse : public CSoapResponseBinding,
   implements IEspDFUWUSearchResponse,
   implements IClientDFUWUSearchResponse
{
protected:
	SoapStringArray m_ClusterNames;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CDFUWUSearchResponse(const char *serviceName, const char *bcompat);

	CDFUWUSearchResponse(const char *serviceName, IRpcMessageBinding *init=NULL);
	CDFUWUSearchResponse(const char *serviceName, IRpcMessage* rpcmsg);
	CDFUWUSearchResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "DFUWUSearchResponse";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CDFUWUSearchResponse &from);

	void copy(IConstDFUWUSearchResponse &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstDFUWUSearchResponse &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	virtual void setRedirectUrl(const char *url)
	{ CSoapResponseBinding::setRedirectUrl(url); }

	virtual const IMultiException& getExceptions()
	{ return CSoapResponseBinding::getExceptions(); }

	virtual int queryClientStatus()
	{ return CSoapResponseBinding::getRpcState(); }

	virtual void noteException(IException& e)
	{  CSoapResponseBinding::noteException(e); }

	StringArray & getClusterNames();
	void setClusterNames(StringArray &val);
};

class CGetDFUWorkunits : public CSoapRequestBinding,
   implements IEspGetDFUWorkunits,
   implements IClientGetDFUWorkunits
{
protected:
	SoapStringParam m_Wuid;
	SoapStringParam m_Owner;
	SoapStringParam m_Cluster;
	SoapStringParam m_StateReq;
	SoapStringParam m_Type;
	SoapStringParam m_Jobname;
	SoapParam<__int64> m_PageSize;
	SoapParam<int> m_CurrentPage;
	SoapParam<__int64> m_PageStartFrom;
	SoapStringParam m_Sortby;
	SoapParam<bool> m_Descending;
	SoapParam<__int64> m_CacheHint;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CGetDFUWorkunits(const char *serviceName, const char *bcompat);

	CGetDFUWorkunits(const char *serviceName, IRpcMessageBinding *init=NULL);
	CGetDFUWorkunits(const char *serviceName, IRpcMessage* rpcmsg);
	CGetDFUWorkunits(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	IEspClientRpcSettings &rpc(){return *static_cast<IEspClientRpcSettings*>(this);}


	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "GetDFUWorkunits";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CGetDFUWorkunits &from);

	void copy(IConstGetDFUWorkunits &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstGetDFUWorkunits &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	const char * getWuid();
	const char * getOwner();
	const char * getCluster();
	const char * getStateReq();
	const char * getType();
	const char * getJobname();
	__int64 getPageSize();
	int getCurrentPage();
	__int64 getPageStartFrom();
	const char * getSortby();
	bool getDescending();
	__int64 getCacheHint();
	void setWuid(const char * val);
	void setOwner(const char * val);
	void setCluster(const char * val);
	void setStateReq(const char * val);
	void setType(const char * val);
	void setJobname(const char * val);
	void setPageSize(__int64 val);
	void setCurrentPage(int val);
	void setPageStartFrom(__int64 val);
	void setSortby(const char * val);
	void setDescending(bool val);
	void setCacheHint(__int64 val);
};

class CGetDFUWorkunitsResponse : public CSoapResponseBinding,
   implements IEspGetDFUWorkunitsResponse,
   implements IClientGetDFUWorkunitsResponse
{
protected:
	SoapStructArrayParam<IConstDFUWorkunit, CDFUWorkunit> m_results;
	SoapStringParam m_Type;
	SoapStringParam m_Owner;
	SoapStringParam m_Cluster;
	SoapStringParam m_StateReq;
	SoapParam<__int64> m_PageSize;
	SoapParam<__int64> m_PrevPage;
	SoapParam<__int64> m_NextPage;
	SoapParam<__int64> m_LastPage;
	SoapParam<__int64> m_NumWUs;
	SoapParam<__int64> m_PageStartFrom;
	SoapParam<__int64> m_PageEndAt;
	SoapParam<bool> m_First;
	SoapStringParam m_Sortby;
	SoapParam<bool> m_Descending;
	SoapStringParam m_BasicQuery;
	SoapStringParam m_Filters;
	SoapParam<__int64> m_CacheHint;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CGetDFUWorkunitsResponse(const char *serviceName, const char *bcompat);

	CGetDFUWorkunitsResponse(const char *serviceName, IRpcMessageBinding *init=NULL);
	CGetDFUWorkunitsResponse(const char *serviceName, IRpcMessage* rpcmsg);
	CGetDFUWorkunitsResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "GetDFUWorkunitsResponse";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CGetDFUWorkunitsResponse &from);

	void copy(IConstGetDFUWorkunitsResponse &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstGetDFUWorkunitsResponse &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	virtual void setRedirectUrl(const char *url)
	{ CSoapResponseBinding::setRedirectUrl(url); }

	virtual const IMultiException& getExceptions()
	{ return CSoapResponseBinding::getExceptions(); }

	virtual int queryClientStatus()
	{ return CSoapResponseBinding::getRpcState(); }

	virtual void noteException(IException& e)
	{  CSoapResponseBinding::noteException(e); }

	IArrayOf<IConstDFUWorkunit> & getResults();
	const char * getType();
	const char * getOwner();
	const char * getCluster();
	const char * getStateReq();
	__int64 getPageSize();
	__int64 getPrevPage();
	__int64 getNextPage();
	__int64 getLastPage();
	__int64 getNumWUs();
	__int64 getPageStartFrom();
	__int64 getPageEndAt();
	bool getFirst();
	const char * getSortby();
	bool getDescending();
	const char * getBasicQuery();
	const char * getFilters();
	__int64 getCacheHint();
	void setResults(IArrayOf<IEspDFUWorkunit> &val);
 void setResults(IArrayOf<IConstDFUWorkunit> &val);
	void setType(const char * val);
	void setOwner(const char * val);
	void setCluster(const char * val);
	void setStateReq(const char * val);
	void setPageSize(__int64 val);
	void setPrevPage(__int64 val);
	void setNextPage(__int64 val);
	void setLastPage(__int64 val);
	void setNumWUs(__int64 val);
	void setPageStartFrom(__int64 val);
	void setPageEndAt(__int64 val);
	void setFirst(bool val);
	void setSortby(const char * val);
	void setDescending(bool val);
	void setBasicQuery(const char * val);
	void setFilters(const char * val);
	void setCacheHint(__int64 val);
};

class CProgressRequest : public CSoapRequestBinding,
   implements IEspProgressRequest,
   implements IClientProgressRequest
{
protected:
	SoapStringParam m_wuid;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CProgressRequest(const char *serviceName, const char *bcompat);

	CProgressRequest(const char *serviceName, IRpcMessageBinding *init=NULL);
	CProgressRequest(const char *serviceName, IRpcMessage* rpcmsg);
	CProgressRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	IEspClientRpcSettings &rpc(){return *static_cast<IEspClientRpcSettings*>(this);}


	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "ProgressRequest";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CProgressRequest &from);

	void copy(IConstProgressRequest &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstProgressRequest &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	const char * getWuid();
	void setWuid(const char * val);
};

class CProgressResponse : public CSoapResponseBinding,
   implements IEspProgressResponse,
   implements IClientProgressResponse
{
protected:
	SoapStringParam m_wuid;
	SoapParam<int> m_PercentDone;
	SoapParam<int> m_SecsLeft;
	SoapParam<int> m_KbPerSecAve;
	SoapParam<int> m_KbPerSec;
	SoapParam<int> m_SlavesDone;
	SoapStringParam m_TimeTaken;
	SoapStringParam m_ProgressMessage;
	SoapStringParam m_SummaryMessage;
	SoapStringParam m_State;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CProgressResponse(const char *serviceName, const char *bcompat);

	CProgressResponse(const char *serviceName, IRpcMessageBinding *init=NULL);
	CProgressResponse(const char *serviceName, IRpcMessage* rpcmsg);
	CProgressResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "ProgressResponse";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CProgressResponse &from);

	void copy(IConstProgressResponse &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstProgressResponse &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	virtual void setRedirectUrl(const char *url)
	{ CSoapResponseBinding::setRedirectUrl(url); }

	virtual const IMultiException& getExceptions()
	{ return CSoapResponseBinding::getExceptions(); }

	virtual int queryClientStatus()
	{ return CSoapResponseBinding::getRpcState(); }

	virtual void noteException(IException& e)
	{  CSoapResponseBinding::noteException(e); }

	const char * getWuid();
	int getPercentDone();
	int getSecsLeft();
	int getKbPerSecAve();
	int getKbPerSec();
	int getSlavesDone();
	const char * getTimeTaken();
	const char * getProgressMessage();
	const char * getSummaryMessage();
	const char * getState();
	void setWuid(const char * val);
	void setPercentDone(int val);
	void setSecsLeft(int val);
	void setKbPerSecAve(int val);
	void setKbPerSec(int val);
	void setSlavesDone(int val);
	void setTimeTaken(const char * val);
	void setProgressMessage(const char * val);
	void setSummaryMessage(const char * val);
	void setState(const char * val);
};

class CGetDFUWorkunit : public CSoapRequestBinding,
   implements IEspGetDFUWorkunit,
   implements IClientGetDFUWorkunit
{
protected:
	SoapStringParam m_wuid;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CGetDFUWorkunit(const char *serviceName, const char *bcompat);

	CGetDFUWorkunit(const char *serviceName, IRpcMessageBinding *init=NULL);
	CGetDFUWorkunit(const char *serviceName, IRpcMessage* rpcmsg);
	CGetDFUWorkunit(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	IEspClientRpcSettings &rpc(){return *static_cast<IEspClientRpcSettings*>(this);}


	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "GetDFUWorkunit";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CGetDFUWorkunit &from);

	void copy(IConstGetDFUWorkunit &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstGetDFUWorkunit &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	const char * getWuid();
	void setWuid(const char * val);
};

class CGetDFUWorkunitResponse : public CSoapResponseBinding,
   implements IEspGetDFUWorkunitResponse,
   implements IClientGetDFUWorkunitResponse
{
protected:
	SoapStruct<CDFUWorkunit, IConstDFUWorkunit> m_result;
	SoapParam<int> m_AutoRefresh;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CGetDFUWorkunitResponse(const char *serviceName, const char *bcompat);

	CGetDFUWorkunitResponse(const char *serviceName, IRpcMessageBinding *init=NULL);
	CGetDFUWorkunitResponse(const char *serviceName, IRpcMessage* rpcmsg);
	CGetDFUWorkunitResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "GetDFUWorkunitResponse";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CGetDFUWorkunitResponse &from);

	void copy(IConstGetDFUWorkunitResponse &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstGetDFUWorkunitResponse &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	virtual void setRedirectUrl(const char *url)
	{ CSoapResponseBinding::setRedirectUrl(url); }

	virtual const IMultiException& getExceptions()
	{ return CSoapResponseBinding::getExceptions(); }

	virtual int queryClientStatus()
	{ return CSoapResponseBinding::getRpcState(); }

	virtual void noteException(IException& e)
	{  CSoapResponseBinding::noteException(e); }

	IConstDFUWorkunit & getResult();
	int getAutoRefresh();
	IEspDFUWorkunit & updateResult();
	void setResult(IConstDFUWorkunit &ifrom);
	void setAutoRefresh(int val);
};

class CCreateDFUWorkunit : public CSoapRequestBinding,
   implements IEspCreateDFUWorkunit,
   implements IClientCreateDFUWorkunit
{
protected:
	SoapStringParam m_DFUServerQueue;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CCreateDFUWorkunit(const char *serviceName, const char *bcompat);

	CCreateDFUWorkunit(const char *serviceName, IRpcMessageBinding *init=NULL);
	CCreateDFUWorkunit(const char *serviceName, IRpcMessage* rpcmsg);
	CCreateDFUWorkunit(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	IEspClientRpcSettings &rpc(){return *static_cast<IEspClientRpcSettings*>(this);}


	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "CreateDFUWorkunit";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CCreateDFUWorkunit &from);

	void copy(IConstCreateDFUWorkunit &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstCreateDFUWorkunit &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	const char * getDFUServerQueue();
	void setDFUServerQueue(const char * val);
};

class CCreateDFUWorkunitResponse : public CSoapResponseBinding,
   implements IEspCreateDFUWorkunitResponse,
   implements IClientCreateDFUWorkunitResponse
{
protected:
	SoapStruct<CDFUWorkunit, IConstDFUWorkunit> m_result;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CCreateDFUWorkunitResponse(const char *serviceName, const char *bcompat);

	CCreateDFUWorkunitResponse(const char *serviceName, IRpcMessageBinding *init=NULL);
	CCreateDFUWorkunitResponse(const char *serviceName, IRpcMessage* rpcmsg);
	CCreateDFUWorkunitResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "CreateDFUWorkunitResponse";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CCreateDFUWorkunitResponse &from);

	void copy(IConstCreateDFUWorkunitResponse &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstCreateDFUWorkunitResponse &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	virtual void setRedirectUrl(const char *url)
	{ CSoapResponseBinding::setRedirectUrl(url); }

	virtual const IMultiException& getExceptions()
	{ return CSoapResponseBinding::getExceptions(); }

	virtual int queryClientStatus()
	{ return CSoapResponseBinding::getRpcState(); }

	virtual void noteException(IException& e)
	{  CSoapResponseBinding::noteException(e); }

	IConstDFUWorkunit & getResult();
	IEspDFUWorkunit & updateResult();
	void setResult(IConstDFUWorkunit &ifrom);
};

class CUpdateDFUWorkunit : public CSoapRequestBinding,
   implements IEspUpdateDFUWorkunit,
   implements IClientUpdateDFUWorkunit
{
protected:
	SoapStruct<CDFUWorkunit, IConstDFUWorkunit> m_wu;
	SoapStringParam m_ClusterOrig;
	SoapStringParam m_JobNameOrig;
	SoapParam<bool> m_isProtectedOrig;
	SoapParam<int> m_StateOrig;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CUpdateDFUWorkunit(const char *serviceName, const char *bcompat);

	CUpdateDFUWorkunit(const char *serviceName, IRpcMessageBinding *init=NULL);
	CUpdateDFUWorkunit(const char *serviceName, IRpcMessage* rpcmsg);
	CUpdateDFUWorkunit(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	IEspClientRpcSettings &rpc(){return *static_cast<IEspClientRpcSettings*>(this);}


	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "UpdateDFUWorkunit";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CUpdateDFUWorkunit &from);

	void copy(IConstUpdateDFUWorkunit &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstUpdateDFUWorkunit &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	IConstDFUWorkunit & getWu();
	const char * getClusterOrig();
	const char * getJobNameOrig();
	bool getIsProtectedOrig();
	int getStateOrig();
	IEspDFUWorkunit & updateWu();
	void setWu(IConstDFUWorkunit &ifrom);
	void setClusterOrig(const char * val);
	void setJobNameOrig(const char * val);
	void setIsProtectedOrig(bool val);
	void setStateOrig(int val);
};

class CUpdateDFUWorkunitResponse : public CSoapResponseBinding,
   implements IEspUpdateDFUWorkunitResponse,
   implements IClientUpdateDFUWorkunitResponse
{
protected:

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CUpdateDFUWorkunitResponse(const char *serviceName, const char *bcompat);

	CUpdateDFUWorkunitResponse(const char *serviceName, IRpcMessageBinding *init=NULL);
	CUpdateDFUWorkunitResponse(const char *serviceName, IRpcMessage* rpcmsg);
	CUpdateDFUWorkunitResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "UpdateDFUWorkunitResponse";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CUpdateDFUWorkunitResponse &from);

	void copy(IConstUpdateDFUWorkunitResponse &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstUpdateDFUWorkunitResponse &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	virtual void setRedirectUrl(const char *url)
	{ CSoapResponseBinding::setRedirectUrl(url); }

	virtual const IMultiException& getExceptions()
	{ return CSoapResponseBinding::getExceptions(); }

	virtual int queryClientStatus()
	{ return CSoapResponseBinding::getRpcState(); }

	virtual void noteException(IException& e)
	{  CSoapResponseBinding::noteException(e); }

};

class CDeleteDFUWorkunit : public CSoapRequestBinding,
   implements IEspDeleteDFUWorkunit,
   implements IClientDeleteDFUWorkunit
{
protected:
	SoapStringParam m_wuid;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CDeleteDFUWorkunit(const char *serviceName, const char *bcompat);

	CDeleteDFUWorkunit(const char *serviceName, IRpcMessageBinding *init=NULL);
	CDeleteDFUWorkunit(const char *serviceName, IRpcMessage* rpcmsg);
	CDeleteDFUWorkunit(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	IEspClientRpcSettings &rpc(){return *static_cast<IEspClientRpcSettings*>(this);}


	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "DeleteDFUWorkunit";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CDeleteDFUWorkunit &from);

	void copy(IConstDeleteDFUWorkunit &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstDeleteDFUWorkunit &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	const char * getWuid();
	void setWuid(const char * val);
};

class CDeleteDFUWorkunitResponse : public CSoapResponseBinding,
   implements IEspDeleteDFUWorkunitResponse,
   implements IClientDeleteDFUWorkunitResponse
{
protected:
	SoapParam<bool> m_result;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CDeleteDFUWorkunitResponse(const char *serviceName, const char *bcompat);

	CDeleteDFUWorkunitResponse(const char *serviceName, IRpcMessageBinding *init=NULL);
	CDeleteDFUWorkunitResponse(const char *serviceName, IRpcMessage* rpcmsg);
	CDeleteDFUWorkunitResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "DeleteDFUWorkunitResponse";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CDeleteDFUWorkunitResponse &from);

	void copy(IConstDeleteDFUWorkunitResponse &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstDeleteDFUWorkunitResponse &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	virtual void setRedirectUrl(const char *url)
	{ CSoapResponseBinding::setRedirectUrl(url); }

	virtual const IMultiException& getExceptions()
	{ return CSoapResponseBinding::getExceptions(); }

	virtual int queryClientStatus()
	{ return CSoapResponseBinding::getRpcState(); }

	virtual void noteException(IException& e)
	{  CSoapResponseBinding::noteException(e); }

	bool getResult();
	void setResult(bool val);
};

class CDeleteDFUWorkunits : public CSoapRequestBinding,
   implements IEspDeleteDFUWorkunits,
   implements IClientDeleteDFUWorkunits
{
protected:
	SoapStringArray m_wuids;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CDeleteDFUWorkunits(const char *serviceName, const char *bcompat);

	CDeleteDFUWorkunits(const char *serviceName, IRpcMessageBinding *init=NULL);
	CDeleteDFUWorkunits(const char *serviceName, IRpcMessage* rpcmsg);
	CDeleteDFUWorkunits(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	IEspClientRpcSettings &rpc(){return *static_cast<IEspClientRpcSettings*>(this);}


	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "DeleteDFUWorkunits";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CDeleteDFUWorkunits &from);

	void copy(IConstDeleteDFUWorkunits &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstDeleteDFUWorkunits &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	StringArray & getWuids();
	void setWuids(StringArray &val);
};

class CDeleteDFUWorkunitsResponse : public CSoapResponseBinding,
   implements IEspDeleteDFUWorkunitsResponse,
   implements IClientDeleteDFUWorkunitsResponse
{
protected:

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CDeleteDFUWorkunitsResponse(const char *serviceName, const char *bcompat);

	CDeleteDFUWorkunitsResponse(const char *serviceName, IRpcMessageBinding *init=NULL);
	CDeleteDFUWorkunitsResponse(const char *serviceName, IRpcMessage* rpcmsg);
	CDeleteDFUWorkunitsResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "DeleteDFUWorkunitsResponse";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CDeleteDFUWorkunitsResponse &from);

	void copy(IConstDeleteDFUWorkunitsResponse &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstDeleteDFUWorkunitsResponse &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	virtual void setRedirectUrl(const char *url)
	{ CSoapResponseBinding::setRedirectUrl(url); }

	virtual const IMultiException& getExceptions()
	{ return CSoapResponseBinding::getExceptions(); }

	virtual int queryClientStatus()
	{ return CSoapResponseBinding::getRpcState(); }

	virtual void noteException(IException& e)
	{  CSoapResponseBinding::noteException(e); }

};

class CDFUWorkunitsActionRequest : public CSoapRequestBinding,
   implements IEspDFUWorkunitsActionRequest,
   implements IClientDFUWorkunitsActionRequest
{
protected:
	SoapStringArray m_wuids;
	CXDFUWUActions m_Type;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CDFUWorkunitsActionRequest(const char *serviceName, const char *bcompat);

	CDFUWorkunitsActionRequest(const char *serviceName, IRpcMessageBinding *init=NULL);
	CDFUWorkunitsActionRequest(const char *serviceName, IRpcMessage* rpcmsg);
	CDFUWorkunitsActionRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	IEspClientRpcSettings &rpc(){return *static_cast<IEspClientRpcSettings*>(this);}


	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "DFUWorkunitsActionRequest";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CDFUWorkunitsActionRequest &from);

	void copy(IConstDFUWorkunitsActionRequest &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstDFUWorkunitsActionRequest &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	StringArray & getWuids();
	CDFUWUActions getType();
	const char* getTypeAsString();
	void setWuids(StringArray &val);
	void setType(CDFUWUActions val);
void setType(const char* val);
};

class CDFUWorkunitsActionResponse : public CSoapResponseBinding,
   implements IEspDFUWorkunitsActionResponse,
   implements IClientDFUWorkunitsActionResponse
{
protected:
	SoapStringParam m_FirstColumn;
	SoapStructArrayParam<IConstDFUActionResult, CDFUActionResult> m_DFUActionResults;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CDFUWorkunitsActionResponse(const char *serviceName, const char *bcompat);

	CDFUWorkunitsActionResponse(const char *serviceName, IRpcMessageBinding *init=NULL);
	CDFUWorkunitsActionResponse(const char *serviceName, IRpcMessage* rpcmsg);
	CDFUWorkunitsActionResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "DFUWorkunitsActionResponse";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CDFUWorkunitsActionResponse &from);

	void copy(IConstDFUWorkunitsActionResponse &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstDFUWorkunitsActionResponse &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	virtual void setRedirectUrl(const char *url)
	{ CSoapResponseBinding::setRedirectUrl(url); }

	virtual const IMultiException& getExceptions()
	{ return CSoapResponseBinding::getExceptions(); }

	virtual int queryClientStatus()
	{ return CSoapResponseBinding::getRpcState(); }

	virtual void noteException(IException& e)
	{  CSoapResponseBinding::noteException(e); }

	const char * getFirstColumn();
	IArrayOf<IConstDFUActionResult> & getDFUActionResults();
	void setFirstColumn(const char * val);
	void setDFUActionResults(IArrayOf<IEspDFUActionResult> &val);
 void setDFUActionResults(IArrayOf<IConstDFUActionResult> &val);
};

class CSubmitDFUWorkunit : public CSoapRequestBinding,
   implements IEspSubmitDFUWorkunit,
   implements IClientSubmitDFUWorkunit
{
protected:
	SoapStringParam m_wuid;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CSubmitDFUWorkunit(const char *serviceName, const char *bcompat);

	CSubmitDFUWorkunit(const char *serviceName, IRpcMessageBinding *init=NULL);
	CSubmitDFUWorkunit(const char *serviceName, IRpcMessage* rpcmsg);
	CSubmitDFUWorkunit(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	IEspClientRpcSettings &rpc(){return *static_cast<IEspClientRpcSettings*>(this);}


	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "SubmitDFUWorkunit";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CSubmitDFUWorkunit &from);

	void copy(IConstSubmitDFUWorkunit &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstSubmitDFUWorkunit &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	const char * getWuid();
	void setWuid(const char * val);
};

class CSubmitDFUWorkunitResponse : public CSoapResponseBinding,
   implements IEspSubmitDFUWorkunitResponse,
   implements IClientSubmitDFUWorkunitResponse
{
protected:

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CSubmitDFUWorkunitResponse(const char *serviceName, const char *bcompat);

	CSubmitDFUWorkunitResponse(const char *serviceName, IRpcMessageBinding *init=NULL);
	CSubmitDFUWorkunitResponse(const char *serviceName, IRpcMessage* rpcmsg);
	CSubmitDFUWorkunitResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "SubmitDFUWorkunitResponse";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CSubmitDFUWorkunitResponse &from);

	void copy(IConstSubmitDFUWorkunitResponse &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstSubmitDFUWorkunitResponse &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	virtual void setRedirectUrl(const char *url)
	{ CSoapResponseBinding::setRedirectUrl(url); }

	virtual const IMultiException& getExceptions()
	{ return CSoapResponseBinding::getExceptions(); }

	virtual int queryClientStatus()
	{ return CSoapResponseBinding::getRpcState(); }

	virtual void noteException(IException& e)
	{  CSoapResponseBinding::noteException(e); }

};

class CAbortDFUWorkunit : public CSoapRequestBinding,
   implements IEspAbortDFUWorkunit,
   implements IClientAbortDFUWorkunit
{
protected:
	SoapStringParam m_wuid;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CAbortDFUWorkunit(const char *serviceName, const char *bcompat);

	CAbortDFUWorkunit(const char *serviceName, IRpcMessageBinding *init=NULL);
	CAbortDFUWorkunit(const char *serviceName, IRpcMessage* rpcmsg);
	CAbortDFUWorkunit(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	IEspClientRpcSettings &rpc(){return *static_cast<IEspClientRpcSettings*>(this);}


	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "AbortDFUWorkunit";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CAbortDFUWorkunit &from);

	void copy(IConstAbortDFUWorkunit &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstAbortDFUWorkunit &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	const char * getWuid();
	void setWuid(const char * val);
};

class CAbortDFUWorkunitResponse : public CSoapResponseBinding,
   implements IEspAbortDFUWorkunitResponse,
   implements IClientAbortDFUWorkunitResponse
{
protected:

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CAbortDFUWorkunitResponse(const char *serviceName, const char *bcompat);

	CAbortDFUWorkunitResponse(const char *serviceName, IRpcMessageBinding *init=NULL);
	CAbortDFUWorkunitResponse(const char *serviceName, IRpcMessage* rpcmsg);
	CAbortDFUWorkunitResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "AbortDFUWorkunitResponse";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CAbortDFUWorkunitResponse &from);

	void copy(IConstAbortDFUWorkunitResponse &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstAbortDFUWorkunitResponse &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	virtual void setRedirectUrl(const char *url)
	{ CSoapResponseBinding::setRedirectUrl(url); }

	virtual const IMultiException& getExceptions()
	{ return CSoapResponseBinding::getExceptions(); }

	virtual int queryClientStatus()
	{ return CSoapResponseBinding::getRpcState(); }

	virtual void noteException(IException& e)
	{  CSoapResponseBinding::noteException(e); }

};

class CGetDFUExceptions : public CSoapRequestBinding,
   implements IEspGetDFUExceptions,
   implements IClientGetDFUExceptions
{
protected:
	SoapStringParam m_wuid;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CGetDFUExceptions(const char *serviceName, const char *bcompat);

	CGetDFUExceptions(const char *serviceName, IRpcMessageBinding *init=NULL);
	CGetDFUExceptions(const char *serviceName, IRpcMessage* rpcmsg);
	CGetDFUExceptions(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	IEspClientRpcSettings &rpc(){return *static_cast<IEspClientRpcSettings*>(this);}


	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "GetDFUExceptions";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CGetDFUExceptions &from);

	void copy(IConstGetDFUExceptions &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstGetDFUExceptions &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	const char * getWuid();
	void setWuid(const char * val);
};

class CGetDFUExceptionsResponse : public CSoapResponseBinding,
   implements IEspGetDFUExceptionsResponse,
   implements IClientGetDFUExceptionsResponse
{
protected:
	SoapStructArrayParam<IConstDFUException, CDFUException> m_result;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CGetDFUExceptionsResponse(const char *serviceName, const char *bcompat);

	CGetDFUExceptionsResponse(const char *serviceName, IRpcMessageBinding *init=NULL);
	CGetDFUExceptionsResponse(const char *serviceName, IRpcMessage* rpcmsg);
	CGetDFUExceptionsResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "GetDFUExceptionsResponse";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CGetDFUExceptionsResponse &from);

	void copy(IConstGetDFUExceptionsResponse &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstGetDFUExceptionsResponse &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	virtual void setRedirectUrl(const char *url)
	{ CSoapResponseBinding::setRedirectUrl(url); }

	virtual const IMultiException& getExceptions()
	{ return CSoapResponseBinding::getExceptions(); }

	virtual int queryClientStatus()
	{ return CSoapResponseBinding::getRpcState(); }

	virtual void noteException(IException& e)
	{  CSoapResponseBinding::noteException(e); }

	IArrayOf<IConstDFUException> & getResult();
	void setResult(IArrayOf<IEspDFUException> &val);
 void setResult(IArrayOf<IConstDFUException> &val);
};

class CSprayFixed : public CSoapRequestBinding,
   implements IEspSprayFixed,
   implements IClientSprayFixed
{
protected:
	SoapStringParam m_sourceIP;
	SoapStringParam m_sourcePath;
	SoapParamBinary m_srcxml;
	SoapStringParam m_sourceFormat;
	SoapParam<int> m_sourceRecordSize;
	SoapStringParam m_destGroup;
	SoapStringParam m_destLogicalName;
	SoapParam<bool> m_overwrite;
	SoapParam<bool> m_replicate;
	SoapParam<int> m_ReplicateOffset;
	SoapParam<int> m_maxConnections;
	SoapParam<int> m_throttle;
	SoapParam<int> m_transferBufferSize;
	SoapStringParam m_prefix;
	SoapParam<bool> m_nosplit;
	SoapParam<bool> m_norecover;
	SoapParam<bool> m_compress;
	SoapParam<bool> m_push;
	SoapParam<bool> m_pull;
	SoapStringParam m_encrypt;
	SoapStringParam m_decrypt;
	SoapParam<bool> m_wrap;
	SoapParam<bool> m_failIfNoSourceFile;
	SoapParam<bool> m_recordStructurePresent;
	SoapParam<bool> m_quotedTerminator;
	SoapParam<int> m_expireDays;
	SoapStringParam m_DFUServerQueue;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CSprayFixed(const char *serviceName, const char *bcompat);

	CSprayFixed(const char *serviceName, IRpcMessageBinding *init=NULL);
	CSprayFixed(const char *serviceName, IRpcMessage* rpcmsg);
	CSprayFixed(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	IEspClientRpcSettings &rpc(){return *static_cast<IEspClientRpcSettings*>(this);}


	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "SprayFixed";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CSprayFixed &from);

	void copy(IConstSprayFixed &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstSprayFixed &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	const char * getSourceIP();
	const char * getSourcePath();
	const MemoryBuffer & getSrcxml();
	const char * getSourceFormat();
bool getSourceRecordSize_isNull();
	int getSourceRecordSize();
	const char * getDestGroup();
	const char * getDestLogicalName();
bool getOverwrite_isNull();
	bool getOverwrite();
bool getReplicate_isNull();
	bool getReplicate();
bool getReplicateOffset_isNull();
	int getReplicateOffset();
bool getMaxConnections_isNull();
	int getMaxConnections();
bool getThrottle_isNull();
	int getThrottle();
bool getTransferBufferSize_isNull();
	int getTransferBufferSize();
	const char * getPrefix();
bool getNosplit_isNull();
	bool getNosplit();
bool getNorecover_isNull();
	bool getNorecover();
bool getCompress_isNull();
	bool getCompress();
bool getPush_isNull();
	bool getPush();
bool getPull_isNull();
	bool getPull();
	const char * getEncrypt();
	const char * getDecrypt();
bool getWrap_isNull();
	bool getWrap();
bool getFailIfNoSourceFile_isNull();
	bool getFailIfNoSourceFile();
bool getRecordStructurePresent_isNull();
	bool getRecordStructurePresent();
bool getQuotedTerminator_isNull();
	bool getQuotedTerminator();
bool getExpireDays_isNull();
	int getExpireDays();
	const char * getDFUServerQueue();
	void setSourceIP(const char * val);
	void setSourcePath(const char * val);
	void setSrcxml(const MemoryBuffer & val);
	void setSourceFormat(const char * val);
	void setSourceRecordSize_null();
	void setSourceRecordSize(int val);
	void setDestGroup(const char * val);
	void setDestLogicalName(const char * val);
	void setOverwrite_null();
	void setOverwrite(bool val);
	void setReplicate_null();
	void setReplicate(bool val);
	void setReplicateOffset_null();
	void setReplicateOffset(int val);
	void setMaxConnections_null();
	void setMaxConnections(int val);
	void setThrottle_null();
	void setThrottle(int val);
	void setTransferBufferSize_null();
	void setTransferBufferSize(int val);
	void setPrefix(const char * val);
	void setNosplit_null();
	void setNosplit(bool val);
	void setNorecover_null();
	void setNorecover(bool val);
	void setCompress_null();
	void setCompress(bool val);
	void setPush_null();
	void setPush(bool val);
	void setPull_null();
	void setPull(bool val);
	void setEncrypt(const char * val);
	void setDecrypt(const char * val);
	void setWrap_null();
	void setWrap(bool val);
	void setFailIfNoSourceFile_null();
	void setFailIfNoSourceFile(bool val);
	void setRecordStructurePresent_null();
	void setRecordStructurePresent(bool val);
	void setQuotedTerminator_null();
	void setQuotedTerminator(bool val);
	void setExpireDays_null();
	void setExpireDays(int val);
	void setDFUServerQueue(const char * val);
};

class CSprayFixedResponse : public CSoapResponseBinding,
   implements IEspSprayFixedResponse,
   implements IClientSprayFixedResponse
{
protected:
	SoapStringParam m_wuid;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CSprayFixedResponse(const char *serviceName, const char *bcompat);

	CSprayFixedResponse(const char *serviceName, IRpcMessageBinding *init=NULL);
	CSprayFixedResponse(const char *serviceName, IRpcMessage* rpcmsg);
	CSprayFixedResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "SprayFixedResponse";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CSprayFixedResponse &from);

	void copy(IConstSprayFixedResponse &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstSprayFixedResponse &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	virtual void setRedirectUrl(const char *url)
	{ CSoapResponseBinding::setRedirectUrl(url); }

	virtual const IMultiException& getExceptions()
	{ return CSoapResponseBinding::getExceptions(); }

	virtual int queryClientStatus()
	{ return CSoapResponseBinding::getRpcState(); }

	virtual void noteException(IException& e)
	{  CSoapResponseBinding::noteException(e); }

	const char * getWuid();
	void setWuid(const char * val);
};

class CSprayVariable : public CSoapRequestBinding,
   implements IEspSprayVariable,
   implements IClientSprayVariable
{
protected:
	SoapStringParam m_sourceIP;
	SoapStringParam m_sourcePath;
	SoapParamBinary m_srcxml;
	SoapParam<int> m_sourceMaxRecordSize;
	SoapParam<int> m_sourceFormat;
	SoapParam<bool> m_NoSourceCsvSeparator;
	SoapStringParam m_sourceCsvSeparate;
	SoapStringParam m_sourceCsvTerminate;
	SoapStringParam m_sourceCsvQuote;
	SoapStringParam m_sourceCsvEscape;
	SoapStringParam m_sourceRowTag;
	SoapStringParam m_destGroup;
	SoapStringParam m_destLogicalName;
	SoapParam<bool> m_overwrite;
	SoapParam<bool> m_replicate;
	SoapParam<int> m_ReplicateOffset;
	SoapParam<int> m_maxConnections;
	SoapParam<int> m_throttle;
	SoapParam<int> m_transferBufferSize;
	SoapStringParam m_prefix;
	SoapParam<bool> m_nosplit;
	SoapParam<bool> m_norecover;
	SoapParam<bool> m_compress;
	SoapParam<bool> m_push;
	SoapParam<bool> m_pull;
	SoapStringParam m_encrypt;
	SoapStringParam m_decrypt;
	SoapParam<bool> m_failIfNoSourceFile;
	SoapParam<bool> m_recordStructurePresent;
	SoapParam<bool> m_quotedTerminator;
	SoapStringParam m_sourceRowPath;
	SoapParam<bool> m_isJSON;
	SoapParam<int> m_expireDays;
	SoapStringParam m_DFUServerQueue;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CSprayVariable(const char *serviceName, const char *bcompat);

	CSprayVariable(const char *serviceName, IRpcMessageBinding *init=NULL);
	CSprayVariable(const char *serviceName, IRpcMessage* rpcmsg);
	CSprayVariable(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	IEspClientRpcSettings &rpc(){return *static_cast<IEspClientRpcSettings*>(this);}


	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "SprayVariable";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CSprayVariable &from);

	void copy(IConstSprayVariable &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstSprayVariable &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	const char * getSourceIP();
	const char * getSourcePath();
	const MemoryBuffer & getSrcxml();
bool getSourceMaxRecordSize_isNull();
	int getSourceMaxRecordSize();
bool getSourceFormat_isNull();
	int getSourceFormat();
bool getNoSourceCsvSeparator_isNull();
	bool getNoSourceCsvSeparator();
	const char * getSourceCsvSeparate();
	const char * getSourceCsvTerminate();
	const char * getSourceCsvQuote();
	const char * getSourceCsvEscape();
	const char * getSourceRowTag();
	const char * getDestGroup();
	const char * getDestLogicalName();
bool getOverwrite_isNull();
	bool getOverwrite();
bool getReplicate_isNull();
	bool getReplicate();
bool getReplicateOffset_isNull();
	int getReplicateOffset();
bool getMaxConnections_isNull();
	int getMaxConnections();
bool getThrottle_isNull();
	int getThrottle();
bool getTransferBufferSize_isNull();
	int getTransferBufferSize();
	const char * getPrefix();
bool getNosplit_isNull();
	bool getNosplit();
bool getNorecover_isNull();
	bool getNorecover();
bool getCompress_isNull();
	bool getCompress();
bool getPush_isNull();
	bool getPush();
bool getPull_isNull();
	bool getPull();
	const char * getEncrypt();
	const char * getDecrypt();
bool getFailIfNoSourceFile_isNull();
	bool getFailIfNoSourceFile();
bool getRecordStructurePresent_isNull();
	bool getRecordStructurePresent();
bool getQuotedTerminator_isNull();
	bool getQuotedTerminator();
	const char * getSourceRowPath();
bool getIsJSON_isNull();
	bool getIsJSON();
bool getExpireDays_isNull();
	int getExpireDays();
	const char * getDFUServerQueue();
	void setSourceIP(const char * val);
	void setSourcePath(const char * val);
	void setSrcxml(const MemoryBuffer & val);
	void setSourceMaxRecordSize_null();
	void setSourceMaxRecordSize(int val);
	void setSourceFormat_null();
	void setSourceFormat(int val);
	void setNoSourceCsvSeparator_null();
	void setNoSourceCsvSeparator(bool val);
	void setSourceCsvSeparate(const char * val);
	void setSourceCsvTerminate(const char * val);
	void setSourceCsvQuote(const char * val);
	void setSourceCsvEscape(const char * val);
	void setSourceRowTag(const char * val);
	void setDestGroup(const char * val);
	void setDestLogicalName(const char * val);
	void setOverwrite_null();
	void setOverwrite(bool val);
	void setReplicate_null();
	void setReplicate(bool val);
	void setReplicateOffset_null();
	void setReplicateOffset(int val);
	void setMaxConnections_null();
	void setMaxConnections(int val);
	void setThrottle_null();
	void setThrottle(int val);
	void setTransferBufferSize_null();
	void setTransferBufferSize(int val);
	void setPrefix(const char * val);
	void setNosplit_null();
	void setNosplit(bool val);
	void setNorecover_null();
	void setNorecover(bool val);
	void setCompress_null();
	void setCompress(bool val);
	void setPush_null();
	void setPush(bool val);
	void setPull_null();
	void setPull(bool val);
	void setEncrypt(const char * val);
	void setDecrypt(const char * val);
	void setFailIfNoSourceFile_null();
	void setFailIfNoSourceFile(bool val);
	void setRecordStructurePresent_null();
	void setRecordStructurePresent(bool val);
	void setQuotedTerminator_null();
	void setQuotedTerminator(bool val);
	void setSourceRowPath(const char * val);
	void setIsJSON_null();
	void setIsJSON(bool val);
	void setExpireDays_null();
	void setExpireDays(int val);
	void setDFUServerQueue(const char * val);
};

class CSprayResponse : public CSoapResponseBinding,
   implements IEspSprayResponse,
   implements IClientSprayResponse
{
protected:
	SoapStringParam m_wuid;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CSprayResponse(const char *serviceName, const char *bcompat);

	CSprayResponse(const char *serviceName, IRpcMessageBinding *init=NULL);
	CSprayResponse(const char *serviceName, IRpcMessage* rpcmsg);
	CSprayResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "SprayResponse";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CSprayResponse &from);

	void copy(IConstSprayResponse &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstSprayResponse &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	virtual void setRedirectUrl(const char *url)
	{ CSoapResponseBinding::setRedirectUrl(url); }

	virtual const IMultiException& getExceptions()
	{ return CSoapResponseBinding::getExceptions(); }

	virtual int queryClientStatus()
	{ return CSoapResponseBinding::getRpcState(); }

	virtual void noteException(IException& e)
	{  CSoapResponseBinding::noteException(e); }

	const char * getWuid();
	void setWuid(const char * val);
};

class CReplicate : public CSoapRequestBinding,
   implements IEspReplicate,
   implements IClientReplicate
{
protected:
	SoapStringParam m_sourceLogicalName;
	SoapParam<int> m_replicateOffset;
	SoapStringParam m_cluster;
	SoapParam<bool> m_repeatLast;
	SoapParam<bool> m_onlyRepeated;
	SoapStringParam m_DFUServerQueue;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CReplicate(const char *serviceName, const char *bcompat);

	CReplicate(const char *serviceName, IRpcMessageBinding *init=NULL);
	CReplicate(const char *serviceName, IRpcMessage* rpcmsg);
	CReplicate(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	IEspClientRpcSettings &rpc(){return *static_cast<IEspClientRpcSettings*>(this);}


	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "Replicate";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CReplicate &from);

	void copy(IConstReplicate &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstReplicate &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	const char * getSourceLogicalName();
bool getReplicateOffset_isNull();
	int getReplicateOffset();
	const char * getCluster();
bool getRepeatLast_isNull();
	bool getRepeatLast();
bool getOnlyRepeated_isNull();
	bool getOnlyRepeated();
	const char * getDFUServerQueue();
	void setSourceLogicalName(const char * val);
	void setReplicateOffset_null();
	void setReplicateOffset(int val);
	void setCluster(const char * val);
	void setRepeatLast_null();
	void setRepeatLast(bool val);
	void setOnlyRepeated_null();
	void setOnlyRepeated(bool val);
	void setDFUServerQueue(const char * val);
};

class CReplicateResponse : public CSoapResponseBinding,
   implements IEspReplicateResponse,
   implements IClientReplicateResponse
{
protected:
	SoapStringParam m_wuid;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CReplicateResponse(const char *serviceName, const char *bcompat);

	CReplicateResponse(const char *serviceName, IRpcMessageBinding *init=NULL);
	CReplicateResponse(const char *serviceName, IRpcMessage* rpcmsg);
	CReplicateResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "ReplicateResponse";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CReplicateResponse &from);

	void copy(IConstReplicateResponse &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstReplicateResponse &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	virtual void setRedirectUrl(const char *url)
	{ CSoapResponseBinding::setRedirectUrl(url); }

	virtual const IMultiException& getExceptions()
	{ return CSoapResponseBinding::getExceptions(); }

	virtual int queryClientStatus()
	{ return CSoapResponseBinding::getRpcState(); }

	virtual void noteException(IException& e)
	{  CSoapResponseBinding::noteException(e); }

	const char * getWuid();
	void setWuid(const char * val);
};

class CDespray : public CSoapRequestBinding,
   implements IEspDespray,
   implements IClientDespray
{
protected:
	SoapStringParam m_sourceLogicalName;
	SoapStringParam m_destIP;
	SoapStringParam m_destPath;
	SoapParamBinary m_dstxml;
	SoapParam<bool> m_overwrite;
	SoapParam<int> m_maxConnections;
	SoapParam<int> m_throttle;
	SoapParam<int> m_transferBufferSize;
	SoapStringParam m_splitprefix;
	SoapParam<bool> m_norecover;
	SoapParam<bool> m_wrap;
	SoapParam<bool> m_multiCopy;
	SoapParam<bool> m_SingleConnection;
	SoapStringParam m_DFUServerQueue;
	SoapParam<bool> m_compress;
	SoapStringParam m_encrypt;
	SoapStringParam m_decrypt;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CDespray(const char *serviceName, const char *bcompat);

	CDespray(const char *serviceName, IRpcMessageBinding *init=NULL);
	CDespray(const char *serviceName, IRpcMessage* rpcmsg);
	CDespray(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	IEspClientRpcSettings &rpc(){return *static_cast<IEspClientRpcSettings*>(this);}


	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "Despray";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CDespray &from);

	void copy(IConstDespray &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstDespray &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	const char * getSourceLogicalName();
	const char * getDestIP();
	const char * getDestPath();
	const MemoryBuffer & getDstxml();
	bool getOverwrite();
	int getMaxConnections();
	int getThrottle();
	int getTransferBufferSize();
	const char * getSplitprefix();
	bool getNorecover();
	bool getWrap();
	bool getMultiCopy();
	bool getSingleConnection();
	const char * getDFUServerQueue();
	bool getCompress();
	const char * getEncrypt();
	const char * getDecrypt();
	void setSourceLogicalName(const char * val);
	void setDestIP(const char * val);
	void setDestPath(const char * val);
	void setDstxml(const MemoryBuffer & val);
	void setOverwrite(bool val);
	void setMaxConnections(int val);
	void setThrottle(int val);
	void setTransferBufferSize(int val);
	void setSplitprefix(const char * val);
	void setNorecover(bool val);
	void setWrap(bool val);
	void setMultiCopy(bool val);
	void setSingleConnection(bool val);
	void setDFUServerQueue(const char * val);
	void setCompress(bool val);
	void setEncrypt(const char * val);
	void setDecrypt(const char * val);
};

class CDesprayResponse : public CSoapResponseBinding,
   implements IEspDesprayResponse,
   implements IClientDesprayResponse
{
protected:
	SoapStringParam m_wuid;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CDesprayResponse(const char *serviceName, const char *bcompat);

	CDesprayResponse(const char *serviceName, IRpcMessageBinding *init=NULL);
	CDesprayResponse(const char *serviceName, IRpcMessage* rpcmsg);
	CDesprayResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "DesprayResponse";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CDesprayResponse &from);

	void copy(IConstDesprayResponse &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstDesprayResponse &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	virtual void setRedirectUrl(const char *url)
	{ CSoapResponseBinding::setRedirectUrl(url); }

	virtual const IMultiException& getExceptions()
	{ return CSoapResponseBinding::getExceptions(); }

	virtual int queryClientStatus()
	{ return CSoapResponseBinding::getRpcState(); }

	virtual void noteException(IException& e)
	{  CSoapResponseBinding::noteException(e); }

	const char * getWuid();
	void setWuid(const char * val);
};

class CCopy : public CSoapRequestBinding,
   implements IEspCopy,
   implements IClientCopy
{
protected:
	SoapStringParam m_sourceLogicalName;
	SoapStringParam m_destGroup;
	SoapStringParam m_destGroupRoxie;
	SoapStringParam m_destLogicalName;
	SoapStringParam m_sourceDali;
	SoapStringParam m_srcusername;
	SoapStringParam m_srcpassword;
	SoapParam<bool> m_overwrite;
	SoapParam<bool> m_replicate;
	SoapParam<int> m_ReplicateOffset;
	SoapParam<int> m_maxConnections;
	SoapParam<int> m_throttle;
	SoapParam<int> m_transferBufferSize;
	SoapParam<bool> m_nosplit;
	SoapParam<bool> m_norecover;
	SoapParam<bool> m_compress;
	SoapParam<bool> m_Wrap;
	SoapParam<bool> m_Multicopy;
	SoapStringParam m_SourceDiffKeyName;
	SoapStringParam m_DestDiffKeyName;
	SoapParam<bool> m_superCopy;
	SoapParam<bool> m_push;
	SoapParam<bool> m_pull;
	SoapParam<bool> m_ifnewer;
	SoapStringParam m_encrypt;
	SoapStringParam m_decrypt;
	SoapParam<bool> m_preserveCompression;
	SoapStringParam m_DFUServerQueue;
	SoapParam<int> m_ExpireDays;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CCopy(const char *serviceName, const char *bcompat);

	CCopy(const char *serviceName, IRpcMessageBinding *init=NULL);
	CCopy(const char *serviceName, IRpcMessage* rpcmsg);
	CCopy(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	IEspClientRpcSettings &rpc(){return *static_cast<IEspClientRpcSettings*>(this);}


	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "Copy";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CCopy &from);

	void copy(IConstCopy &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstCopy &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	const char * getSourceLogicalName();
	const char * getDestGroup();
	const char * getDestGroupRoxie();
	const char * getDestLogicalName();
	const char * getSourceDali();
	const char * getSrcusername();
	const char * getSrcpassword();
bool getOverwrite_isNull();
	bool getOverwrite();
bool getReplicate_isNull();
	bool getReplicate();
bool getReplicateOffset_isNull();
	int getReplicateOffset();
bool getMaxConnections_isNull();
	int getMaxConnections();
bool getThrottle_isNull();
	int getThrottle();
bool getTransferBufferSize_isNull();
	int getTransferBufferSize();
bool getNosplit_isNull();
	bool getNosplit();
bool getNorecover_isNull();
	bool getNorecover();
bool getCompress_isNull();
	bool getCompress();
bool getWrap_isNull();
	bool getWrap();
bool getMulticopy_isNull();
	bool getMulticopy();
	const char * getSourceDiffKeyName();
	const char * getDestDiffKeyName();
bool getSuperCopy_isNull();
	bool getSuperCopy();
bool getPush_isNull();
	bool getPush();
bool getPull_isNull();
	bool getPull();
bool getIfnewer_isNull();
	bool getIfnewer();
	const char * getEncrypt();
	const char * getDecrypt();
bool getPreserveCompression_isNull();
	bool getPreserveCompression();
	const char * getDFUServerQueue();
bool getExpireDays_isNull();
	int getExpireDays();
	void setSourceLogicalName(const char * val);
	void setDestGroup(const char * val);
	void setDestGroupRoxie(const char * val);
	void setDestLogicalName(const char * val);
	void setSourceDali(const char * val);
	void setSrcusername(const char * val);
	void setSrcpassword(const char * val);
	void setOverwrite_null();
	void setOverwrite(bool val);
	void setReplicate_null();
	void setReplicate(bool val);
	void setReplicateOffset_null();
	void setReplicateOffset(int val);
	void setMaxConnections_null();
	void setMaxConnections(int val);
	void setThrottle_null();
	void setThrottle(int val);
	void setTransferBufferSize_null();
	void setTransferBufferSize(int val);
	void setNosplit_null();
	void setNosplit(bool val);
	void setNorecover_null();
	void setNorecover(bool val);
	void setCompress_null();
	void setCompress(bool val);
	void setWrap_null();
	void setWrap(bool val);
	void setMulticopy_null();
	void setMulticopy(bool val);
	void setSourceDiffKeyName(const char * val);
	void setDestDiffKeyName(const char * val);
	void setSuperCopy_null();
	void setSuperCopy(bool val);
	void setPush_null();
	void setPush(bool val);
	void setPull_null();
	void setPull(bool val);
	void setIfnewer_null();
	void setIfnewer(bool val);
	void setEncrypt(const char * val);
	void setDecrypt(const char * val);
	void setPreserveCompression_null();
	void setPreserveCompression(bool val);
	void setDFUServerQueue(const char * val);
	void setExpireDays_null();
	void setExpireDays(int val);
};

class CCopyResponse : public CSoapResponseBinding,
   implements IEspCopyResponse,
   implements IClientCopyResponse
{
protected:
	SoapStringParam m_result;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CCopyResponse(const char *serviceName, const char *bcompat);

	CCopyResponse(const char *serviceName, IRpcMessageBinding *init=NULL);
	CCopyResponse(const char *serviceName, IRpcMessage* rpcmsg);
	CCopyResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "CopyResponse";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CCopyResponse &from);

	void copy(IConstCopyResponse &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstCopyResponse &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	virtual void setRedirectUrl(const char *url)
	{ CSoapResponseBinding::setRedirectUrl(url); }

	virtual const IMultiException& getExceptions()
	{ return CSoapResponseBinding::getExceptions(); }

	virtual int queryClientStatus()
	{ return CSoapResponseBinding::getRpcState(); }

	virtual void noteException(IException& e)
	{  CSoapResponseBinding::noteException(e); }

	const char * getResult();
	void setResult(const char * val);
};

class CEchoDateTime : public CSoapRequestBinding,
   implements IEspEchoDateTime,
   implements IClientEchoDateTime
{
protected:
	SoapStringParam m_dt;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CEchoDateTime(const char *serviceName, const char *bcompat);

	CEchoDateTime(const char *serviceName, IRpcMessageBinding *init=NULL);
	CEchoDateTime(const char *serviceName, IRpcMessage* rpcmsg);
	CEchoDateTime(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	IEspClientRpcSettings &rpc(){return *static_cast<IEspClientRpcSettings*>(this);}


	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "EchoDateTime";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CEchoDateTime &from);

	void copy(IConstEchoDateTime &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstEchoDateTime &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	const char * getDt();
	void setDt(const char * val);
};

class CEchoDateTimeResponse : public CSoapResponseBinding,
   implements IEspEchoDateTimeResponse,
   implements IClientEchoDateTimeResponse
{
protected:
	SoapStringParam m_result;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CEchoDateTimeResponse(const char *serviceName, const char *bcompat);

	CEchoDateTimeResponse(const char *serviceName, IRpcMessageBinding *init=NULL);
	CEchoDateTimeResponse(const char *serviceName, IRpcMessage* rpcmsg);
	CEchoDateTimeResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "EchoDateTimeResponse";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CEchoDateTimeResponse &from);

	void copy(IConstEchoDateTimeResponse &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstEchoDateTimeResponse &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	virtual void setRedirectUrl(const char *url)
	{ CSoapResponseBinding::setRedirectUrl(url); }

	virtual const IMultiException& getExceptions()
	{ return CSoapResponseBinding::getExceptions(); }

	virtual int queryClientStatus()
	{ return CSoapResponseBinding::getRpcState(); }

	virtual void noteException(IException& e)
	{  CSoapResponseBinding::noteException(e); }

	const char * getResult();
	void setResult(const char * val);
};

class CRename : public CSoapRequestBinding,
   implements IEspRename,
   implements IClientRename
{
protected:
	SoapStringParam m_srcname;
	SoapStringParam m_dstname;
	SoapParam<bool> m_overwrite;
	SoapStringParam m_DFUServerQueue;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CRename(const char *serviceName, const char *bcompat);

	CRename(const char *serviceName, IRpcMessageBinding *init=NULL);
	CRename(const char *serviceName, IRpcMessage* rpcmsg);
	CRename(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	IEspClientRpcSettings &rpc(){return *static_cast<IEspClientRpcSettings*>(this);}


	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "Rename";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CRename &from);

	void copy(IConstRename &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstRename &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	const char * getSrcname();
	const char * getDstname();
	bool getOverwrite();
	const char * getDFUServerQueue();
	void setSrcname(const char * val);
	void setDstname(const char * val);
	void setOverwrite(bool val);
	void setDFUServerQueue(const char * val);
};

class CRenameResponse : public CSoapResponseBinding,
   implements IEspRenameResponse,
   implements IClientRenameResponse
{
protected:
	SoapStringParam m_wuid;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CRenameResponse(const char *serviceName, const char *bcompat);

	CRenameResponse(const char *serviceName, IRpcMessageBinding *init=NULL);
	CRenameResponse(const char *serviceName, IRpcMessage* rpcmsg);
	CRenameResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "RenameResponse";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CRenameResponse &from);

	void copy(IConstRenameResponse &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstRenameResponse &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	virtual void setRedirectUrl(const char *url)
	{ CSoapResponseBinding::setRedirectUrl(url); }

	virtual const IMultiException& getExceptions()
	{ return CSoapResponseBinding::getExceptions(); }

	virtual int queryClientStatus()
	{ return CSoapResponseBinding::getRpcState(); }

	virtual void noteException(IException& e)
	{  CSoapResponseBinding::noteException(e); }

	const char * getWuid();
	void setWuid(const char * val);
};

class CDFUWUFileRequest : public CSoapRequestBinding,
   implements IEspDFUWUFileRequest,
   implements IClientDFUWUFileRequest
{
protected:
	SoapStringParam m_Wuid;
	SoapStringParam m_Type;
	SoapStringParam m_PlainText;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CDFUWUFileRequest(const char *serviceName, const char *bcompat);

	CDFUWUFileRequest(const char *serviceName, IRpcMessageBinding *init=NULL);
	CDFUWUFileRequest(const char *serviceName, IRpcMessage* rpcmsg);
	CDFUWUFileRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	IEspClientRpcSettings &rpc(){return *static_cast<IEspClientRpcSettings*>(this);}


	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "DFUWUFileRequest";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CDFUWUFileRequest &from);

	void copy(IConstDFUWUFileRequest &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstDFUWUFileRequest &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	const char * getWuid();
	const char * getType();
	const char * getPlainText();
	void setWuid(const char * val);
	void setType(const char * val);
	void setPlainText(const char * val);
};

class CDFUWUFileResponse : public CSoapResponseBinding,
   implements IEspDFUWUFileResponse,
   implements IClientDFUWUFileResponse
{
protected:
	SoapStringParam m_file;
	StringBuffer m_file_mimetype;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CDFUWUFileResponse(const char *serviceName, const char *bcompat);

	CDFUWUFileResponse(const char *serviceName, IRpcMessageBinding *init=NULL);
	CDFUWUFileResponse(const char *serviceName, IRpcMessage* rpcmsg);
	CDFUWUFileResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "DFUWUFileResponse";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return true;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CDFUWUFileResponse &from);

	void copy(IConstDFUWUFileResponse &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstDFUWUFileResponse &ifrom, StringBuffer& buffer, bool keepRootTag=true);

	void appendContent(IEspContext* ctx, MemoryBuffer& buffer, StringBuffer &mimetype);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	virtual void setRedirectUrl(const char *url)
	{ CSoapResponseBinding::setRedirectUrl(url); }

	virtual const IMultiException& getExceptions()
	{ return CSoapResponseBinding::getExceptions(); }

	virtual int queryClientStatus()
	{ return CSoapResponseBinding::getRpcState(); }

	virtual void noteException(IException& e)
	{  CSoapResponseBinding::noteException(e); }

	const char *getFile_mimetype();
	const char * getFile();
	void setFile_mimetype(const char *  val);
	void setFile(const char * val);
};

class CFileListRequest : public CSoapRequestBinding,
   implements IEspFileListRequest,
   implements IClientFileListRequest
{
protected:
	SoapStringParam m_Netaddr;
	SoapStringParam m_Path;
	SoapStringParam m_Mask;
	SoapStringParam m_OS;
	SoapParam<bool> m_DirectoryOnly;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CFileListRequest(const char *serviceName, const char *bcompat);

	CFileListRequest(const char *serviceName, IRpcMessageBinding *init=NULL);
	CFileListRequest(const char *serviceName, IRpcMessage* rpcmsg);
	CFileListRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	IEspClientRpcSettings &rpc(){return *static_cast<IEspClientRpcSettings*>(this);}


	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "FileListRequest";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CFileListRequest &from);

	void copy(IConstFileListRequest &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstFileListRequest &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	const char * getNetaddr();
	const char * getPath();
	const char * getMask();
	const char * getOS();
	bool getDirectoryOnly();
	void setNetaddr(const char * val);
	void setPath(const char * val);
	void setMask(const char * val);
	void setOS(const char * val);
	void setDirectoryOnly(bool val);
};

class CPhysicalFileStruct : public CSoapComplexType,
   implements IEspPhysicalFileStruct,
   implements IClientPhysicalFileStruct
{
protected:
	SoapStringParam m_name;
	SoapParam<bool> m_isDir;
	SoapParam<__int64> m_filesize;
	SoapStringParam m_modifiedtime;
	SoapStringParam m_Path;
	SoapStructArrayParam<IConstPhysicalFileStruct, CPhysicalFileStruct> m_Files;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CPhysicalFileStruct(const char *serviceName, const char *bcompat);

	CPhysicalFileStruct(const char *serviceName, IRpcMessageBinding *init=NULL);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "PhysicalFileStruct";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CPhysicalFileStruct &from);

	void copy(IConstPhysicalFileStruct &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstPhysicalFileStruct &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	const char * getName();
	bool getIsDir();
	__int64 getFilesize();
	const char * getModifiedtime();
	const char * getPath();
	IArrayOf<IConstPhysicalFileStruct> & getFiles();
	void setName(const char * val);
	void setIsDir(bool val);
	void setFilesize(__int64 val);
	void setModifiedtime(const char * val);
	void setPath(const char * val);
	void setFiles(IArrayOf<IEspPhysicalFileStruct> &val);
 void setFiles(IArrayOf<IConstPhysicalFileStruct> &val);
};

class CFileListResponse : public CSoapResponseBinding,
   implements IEspFileListResponse,
   implements IClientFileListResponse
{
protected:
	SoapStringParam m_Netaddr;
	SoapStringParam m_Path;
	SoapStringParam m_Mask;
	SoapParam<int> m_OS;
	SoapParam<bool> m_DirectoryOnly;
	SoapStringParam m_AcceptLanguage;
	SoapStructArrayParam<IConstPhysicalFileStruct, CPhysicalFileStruct> m_files;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CFileListResponse(const char *serviceName, const char *bcompat);

	CFileListResponse(const char *serviceName, IRpcMessageBinding *init=NULL);
	CFileListResponse(const char *serviceName, IRpcMessage* rpcmsg);
	CFileListResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "FileListResponse";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CFileListResponse &from);

	void copy(IConstFileListResponse &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstFileListResponse &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	virtual void setRedirectUrl(const char *url)
	{ CSoapResponseBinding::setRedirectUrl(url); }

	virtual const IMultiException& getExceptions()
	{ return CSoapResponseBinding::getExceptions(); }

	virtual int queryClientStatus()
	{ return CSoapResponseBinding::getRpcState(); }

	virtual void noteException(IException& e)
	{  CSoapResponseBinding::noteException(e); }

	const char * getNetaddr();
	const char * getPath();
	const char * getMask();
	int getOS();
	bool getDirectoryOnly();
	const char * getAcceptLanguage();
	IArrayOf<IConstPhysicalFileStruct> & getFiles();
	void setNetaddr(const char * val);
	void setPath(const char * val);
	void setMask(const char * val);
	void setOS(int val);
	void setDirectoryOnly(bool val);
	void setAcceptLanguage(const char * val);
	void setFiles(IArrayOf<IEspPhysicalFileStruct> &val);
 void setFiles(IArrayOf<IConstPhysicalFileStruct> &val);
};

class CDropZoneFileSearchRequest : public CSoapRequestBinding,
   implements IEspDropZoneFileSearchRequest,
   implements IClientDropZoneFileSearchRequest
{
protected:
	SoapStringParam m_DropZoneName;
	SoapStringParam m_Server;
	SoapParam<bool> m_ECLWatchVisibleOnly;
	SoapStringParam m_NameFilter;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CDropZoneFileSearchRequest(const char *serviceName, const char *bcompat);

	CDropZoneFileSearchRequest(const char *serviceName, IRpcMessageBinding *init=NULL);
	CDropZoneFileSearchRequest(const char *serviceName, IRpcMessage* rpcmsg);
	CDropZoneFileSearchRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	IEspClientRpcSettings &rpc(){return *static_cast<IEspClientRpcSettings*>(this);}


	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "DropZoneFileSearchRequest";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CDropZoneFileSearchRequest &from);

	void copy(IConstDropZoneFileSearchRequest &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstDropZoneFileSearchRequest &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	const char * getDropZoneName();
	const char * getServer();
bool getECLWatchVisibleOnly_isNull();
	bool getECLWatchVisibleOnly();
	const char * getNameFilter();
	void setDropZoneName(const char * val);
	void setServer(const char * val);
	void setECLWatchVisibleOnly_null();
	void setECLWatchVisibleOnly(bool val);
	void setNameFilter(const char * val);
};

class CDropZoneFileSearchResponse : public CSoapResponseBinding,
   implements IEspDropZoneFileSearchResponse,
   implements IClientDropZoneFileSearchResponse
{
protected:
	SoapStructArrayParam<IConstPhysicalFileStruct, CPhysicalFileStruct> m_Files;
	SoapStringParam m_Warning;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CDropZoneFileSearchResponse(const char *serviceName, const char *bcompat);

	CDropZoneFileSearchResponse(const char *serviceName, IRpcMessageBinding *init=NULL);
	CDropZoneFileSearchResponse(const char *serviceName, IRpcMessage* rpcmsg);
	CDropZoneFileSearchResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "DropZoneFileSearchResponse";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CDropZoneFileSearchResponse &from);

	void copy(IConstDropZoneFileSearchResponse &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstDropZoneFileSearchResponse &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	virtual void setRedirectUrl(const char *url)
	{ CSoapResponseBinding::setRedirectUrl(url); }

	virtual const IMultiException& getExceptions()
	{ return CSoapResponseBinding::getExceptions(); }

	virtual int queryClientStatus()
	{ return CSoapResponseBinding::getRpcState(); }

	virtual void noteException(IException& e)
	{  CSoapResponseBinding::noteException(e); }

	IArrayOf<IConstPhysicalFileStruct> & getFiles();
	const char * getWarning();
	void setFiles(IArrayOf<IEspPhysicalFileStruct> &val);
 void setFiles(IArrayOf<IConstPhysicalFileStruct> &val);
	void setWarning(const char * val);
};

class COpenSaveRequest : public CSoapRequestBinding,
   implements IEspOpenSaveRequest,
   implements IClientOpenSaveRequest
{
protected:
	SoapStringParam m_Location;
	SoapStringParam m_Path;
	SoapStringParam m_Name;
	SoapStringParam m_Type;
	SoapStringParam m_DateTime;
	SoapParam<bool> m_BinaryFile;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	COpenSaveRequest(const char *serviceName, const char *bcompat);

	COpenSaveRequest(const char *serviceName, IRpcMessageBinding *init=NULL);
	COpenSaveRequest(const char *serviceName, IRpcMessage* rpcmsg);
	COpenSaveRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	IEspClientRpcSettings &rpc(){return *static_cast<IEspClientRpcSettings*>(this);}


	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "OpenSaveRequest";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(COpenSaveRequest &from);

	void copy(IConstOpenSaveRequest &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstOpenSaveRequest &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	const char * getLocation();
	const char * getPath();
	const char * getName();
	const char * getType();
	const char * getDateTime();
	bool getBinaryFile();
	void setLocation(const char * val);
	void setPath(const char * val);
	void setName(const char * val);
	void setType(const char * val);
	void setDateTime(const char * val);
	void setBinaryFile(bool val);
};

class COpenSaveResponse : public CSoapResponseBinding,
   implements IEspOpenSaveResponse,
   implements IClientOpenSaveResponse
{
protected:
	SoapStringParam m_Location;
	SoapStringParam m_Path;
	SoapStringParam m_Name;
	SoapStringParam m_Type;
	SoapStringParam m_DateTime;
	SoapParam<bool> m_Viewable;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	COpenSaveResponse(const char *serviceName, const char *bcompat);

	COpenSaveResponse(const char *serviceName, IRpcMessageBinding *init=NULL);
	COpenSaveResponse(const char *serviceName, IRpcMessage* rpcmsg);
	COpenSaveResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "OpenSaveResponse";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(COpenSaveResponse &from);

	void copy(IConstOpenSaveResponse &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstOpenSaveResponse &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	virtual void setRedirectUrl(const char *url)
	{ CSoapResponseBinding::setRedirectUrl(url); }

	virtual const IMultiException& getExceptions()
	{ return CSoapResponseBinding::getExceptions(); }

	virtual int queryClientStatus()
	{ return CSoapResponseBinding::getRpcState(); }

	virtual void noteException(IException& e)
	{  CSoapResponseBinding::noteException(e); }

	const char * getLocation();
	const char * getPath();
	const char * getName();
	const char * getType();
	const char * getDateTime();
	bool getViewable();
	void setLocation(const char * val);
	void setPath(const char * val);
	void setName(const char * val);
	void setType(const char * val);
	void setDateTime(const char * val);
	void setViewable(bool val);
};

class CDfuMonitorRequest : public CSoapRequestBinding,
   implements IEspDfuMonitorRequest,
   implements IClientDfuMonitorRequest
{
protected:
	SoapStringParam m_EventName;
	SoapStringParam m_LogicalName;
	SoapStringParam m_Ip;
	SoapStringParam m_Filename;
	SoapParam<bool> m_Sub;
	SoapParam<int> m_ShotLimit;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CDfuMonitorRequest(const char *serviceName, const char *bcompat);

	CDfuMonitorRequest(const char *serviceName, IRpcMessageBinding *init=NULL);
	CDfuMonitorRequest(const char *serviceName, IRpcMessage* rpcmsg);
	CDfuMonitorRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	IEspClientRpcSettings &rpc(){return *static_cast<IEspClientRpcSettings*>(this);}


	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "DfuMonitorRequest";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CDfuMonitorRequest &from);

	void copy(IConstDfuMonitorRequest &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstDfuMonitorRequest &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	const char * getEventName();
	const char * getLogicalName();
	const char * getIp();
	const char * getFilename();
	bool getSub();
	int getShotLimit();
	void setEventName(const char * val);
	void setLogicalName(const char * val);
	void setIp(const char * val);
	void setFilename(const char * val);
	void setSub(bool val);
	void setShotLimit(int val);
};

class CDfuMonitorResponse : public CSoapResponseBinding,
   implements IEspDfuMonitorResponse,
   implements IClientDfuMonitorResponse
{
protected:
	SoapStringParam m_wuid;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CDfuMonitorResponse(const char *serviceName, const char *bcompat);

	CDfuMonitorResponse(const char *serviceName, IRpcMessageBinding *init=NULL);
	CDfuMonitorResponse(const char *serviceName, IRpcMessage* rpcmsg);
	CDfuMonitorResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "DfuMonitorResponse";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CDfuMonitorResponse &from);

	void copy(IConstDfuMonitorResponse &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstDfuMonitorResponse &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	virtual void setRedirectUrl(const char *url)
	{ CSoapResponseBinding::setRedirectUrl(url); }

	virtual const IMultiException& getExceptions()
	{ return CSoapResponseBinding::getExceptions(); }

	virtual int queryClientStatus()
	{ return CSoapResponseBinding::getRpcState(); }

	virtual void noteException(IException& e)
	{  CSoapResponseBinding::noteException(e); }

	const char * getWuid();
	void setWuid(const char * val);
};

class CShowResultRequest : public CSoapRequestBinding,
   implements IEspShowResultRequest,
   implements IClientShowResultRequest
{
protected:
	SoapStringParam m_Result;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CShowResultRequest(const char *serviceName, const char *bcompat);

	CShowResultRequest(const char *serviceName, IRpcMessageBinding *init=NULL);
	CShowResultRequest(const char *serviceName, IRpcMessage* rpcmsg);
	CShowResultRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	IEspClientRpcSettings &rpc(){return *static_cast<IEspClientRpcSettings*>(this);}


	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "ShowResultRequest";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CShowResultRequest &from);

	void copy(IConstShowResultRequest &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstShowResultRequest &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	const char * getResult();
	void setResult(const char * val);
};

class CShowResultResponse : public CSoapResponseBinding,
   implements IEspShowResultResponse,
   implements IClientShowResultResponse
{
protected:
	SoapStringParam m_Result;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CShowResultResponse(const char *serviceName, const char *bcompat);

	CShowResultResponse(const char *serviceName, IRpcMessageBinding *init=NULL);
	CShowResultResponse(const char *serviceName, IRpcMessage* rpcmsg);
	CShowResultResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "ShowResultResponse";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CShowResultResponse &from);

	void copy(IConstShowResultResponse &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstShowResultResponse &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	virtual void setRedirectUrl(const char *url)
	{ CSoapResponseBinding::setRedirectUrl(url); }

	virtual const IMultiException& getExceptions()
	{ return CSoapResponseBinding::getExceptions(); }

	virtual int queryClientStatus()
	{ return CSoapResponseBinding::getRpcState(); }

	virtual void noteException(IException& e)
	{  CSoapResponseBinding::noteException(e); }

	const char * getResult();
	void setResult(const char * val);
};

class CDropZone : public CSoapComplexType,
   implements IEspDropZone,
   implements IClientDropZone
{
protected:
	SoapStringParam m_Name;
	SoapStringParam m_NetAddress;
	SoapStringParam m_Path;
	SoapStringParam m_Computer;
	SoapStringParam m_Linux;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CDropZone(const char *serviceName, const char *bcompat);

	CDropZone(const char *serviceName, IRpcMessageBinding *init=NULL);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "DropZone";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CDropZone &from);

	void copy(IConstDropZone &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstDropZone &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	const char * getName();
	const char * getNetAddress();
	const char * getPath();
	const char * getComputer();
	const char * getLinux();
	void setName(const char * val);
	void setNetAddress(const char * val);
	void setPath(const char * val);
	void setComputer(const char * val);
	void setLinux(const char * val);
};

class CDropZoneFilesRequest : public CSoapRequestBinding,
   implements IEspDropZoneFilesRequest,
   implements IClientDropZoneFilesRequest
{
protected:
	SoapStringParam m_DropZoneName;
	SoapStringParam m_NetAddress;
	SoapStringParam m_Path;
	SoapStringParam m_OS;
	SoapStringParam m_Subfolder;
	SoapParam<bool> m_ECLWatchVisibleOnly;
	SoapParam<bool> m_DirectoryOnly;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CDropZoneFilesRequest(const char *serviceName, const char *bcompat);

	CDropZoneFilesRequest(const char *serviceName, IRpcMessageBinding *init=NULL);
	CDropZoneFilesRequest(const char *serviceName, IRpcMessage* rpcmsg);
	CDropZoneFilesRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	IEspClientRpcSettings &rpc(){return *static_cast<IEspClientRpcSettings*>(this);}


	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "DropZoneFilesRequest";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CDropZoneFilesRequest &from);

	void copy(IConstDropZoneFilesRequest &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstDropZoneFilesRequest &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	const char * getDropZoneName();
	const char * getNetAddress();
	const char * getPath();
	const char * getOS();
	const char * getSubfolder();
	bool getECLWatchVisibleOnly();
	bool getDirectoryOnly();
	void setDropZoneName(const char * val);
	void setNetAddress(const char * val);
	void setPath(const char * val);
	void setOS(const char * val);
	void setSubfolder(const char * val);
	void setECLWatchVisibleOnly(bool val);
	void setDirectoryOnly(bool val);
};

class CDropZoneFilesResponse : public CSoapResponseBinding,
   implements IEspDropZoneFilesResponse,
   implements IClientDropZoneFilesResponse
{
protected:
	SoapStringParam m_DropZoneName;
	SoapStringParam m_NetAddress;
	SoapStringParam m_Path;
	SoapParam<int> m_OS;
	SoapParam<bool> m_ECLWatchVisibleOnly;
	SoapStructArrayParam<IConstDropZone, CDropZone> m_DropZones;
	SoapStructArrayParam<IConstPhysicalFileStruct, CPhysicalFileStruct> m_Files;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CDropZoneFilesResponse(const char *serviceName, const char *bcompat);

	CDropZoneFilesResponse(const char *serviceName, IRpcMessageBinding *init=NULL);
	CDropZoneFilesResponse(const char *serviceName, IRpcMessage* rpcmsg);
	CDropZoneFilesResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "DropZoneFilesResponse";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CDropZoneFilesResponse &from);

	void copy(IConstDropZoneFilesResponse &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstDropZoneFilesResponse &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	virtual void setRedirectUrl(const char *url)
	{ CSoapResponseBinding::setRedirectUrl(url); }

	virtual const IMultiException& getExceptions()
	{ return CSoapResponseBinding::getExceptions(); }

	virtual int queryClientStatus()
	{ return CSoapResponseBinding::getRpcState(); }

	virtual void noteException(IException& e)
	{  CSoapResponseBinding::noteException(e); }

	const char * getDropZoneName();
	const char * getNetAddress();
	const char * getPath();
bool getOS_isNull();
	int getOS();
bool getECLWatchVisibleOnly_isNull();
	bool getECLWatchVisibleOnly();
	IArrayOf<IConstDropZone> & getDropZones();
	IArrayOf<IConstPhysicalFileStruct> & getFiles();
	void setDropZoneName(const char * val);
	void setNetAddress(const char * val);
	void setPath(const char * val);
	void setOS_null();
	void setOS(int val);
	void setECLWatchVisibleOnly_null();
	void setECLWatchVisibleOnly(bool val);
	void setDropZones(IArrayOf<IEspDropZone> &val);
 void setDropZones(IArrayOf<IConstDropZone> &val);
	void setFiles(IArrayOf<IEspPhysicalFileStruct> &val);
 void setFiles(IArrayOf<IConstPhysicalFileStruct> &val);
};

class CDeleteDropZoneFilesRequest : public CSoapRequestBinding,
   implements IEspDeleteDropZoneFilesRequest,
   implements IClientDeleteDropZoneFilesRequest
{
protected:
	SoapStringParam m_DropZoneName;
	SoapStringParam m_NetAddress;
	SoapStringParam m_Path;
	SoapStringParam m_OS;
	SoapStringArray m_Names;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CDeleteDropZoneFilesRequest(const char *serviceName, const char *bcompat);

	CDeleteDropZoneFilesRequest(const char *serviceName, IRpcMessageBinding *init=NULL);
	CDeleteDropZoneFilesRequest(const char *serviceName, IRpcMessage* rpcmsg);
	CDeleteDropZoneFilesRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	IEspClientRpcSettings &rpc(){return *static_cast<IEspClientRpcSettings*>(this);}


	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "DeleteDropZoneFilesRequest";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CDeleteDropZoneFilesRequest &from);

	void copy(IConstDeleteDropZoneFilesRequest &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstDeleteDropZoneFilesRequest &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	const char * getDropZoneName();
	const char * getNetAddress();
	const char * getPath();
	const char * getOS();
	StringArray & getNames();
	void setDropZoneName(const char * val);
	void setNetAddress(const char * val);
	void setPath(const char * val);
	void setOS(const char * val);
	void setNames(StringArray &val);
};

class CDeleteDropZoneFilesResponse : public CSoapResponseBinding,
   implements IEspDeleteDropZoneFilesResponse,
   implements IClientDeleteDropZoneFilesResponse
{
protected:
	SoapStructArrayParam<IConstDFUActionResult, CDFUActionResult> m_DFUActionResults;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CDeleteDropZoneFilesResponse(const char *serviceName, const char *bcompat);

	CDeleteDropZoneFilesResponse(const char *serviceName, IRpcMessageBinding *init=NULL);
	CDeleteDropZoneFilesResponse(const char *serviceName, IRpcMessage* rpcmsg);
	CDeleteDropZoneFilesResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "DeleteDropZoneFilesResponse";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CDeleteDropZoneFilesResponse &from);

	void copy(IConstDeleteDropZoneFilesResponse &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstDeleteDropZoneFilesResponse &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	virtual void setRedirectUrl(const char *url)
	{ CSoapResponseBinding::setRedirectUrl(url); }

	virtual const IMultiException& getExceptions()
	{ return CSoapResponseBinding::getExceptions(); }

	virtual int queryClientStatus()
	{ return CSoapResponseBinding::getRpcState(); }

	virtual void noteException(IException& e)
	{  CSoapResponseBinding::noteException(e); }

	IArrayOf<IConstDFUActionResult> & getDFUActionResults();
	void setDFUActionResults(IArrayOf<IEspDFUActionResult> &val);
 void setDFUActionResults(IArrayOf<IConstDFUActionResult> &val);
};

class CUploadFilesResponse : public CSoapResponseBinding,
   implements IEspUploadFilesResponse,
   implements IClientUploadFilesResponse
{
protected:
	SoapStructArrayParam<IConstDFUActionResult, CDFUActionResult> m_UploadFileResults;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CUploadFilesResponse(const char *serviceName, const char *bcompat);

	CUploadFilesResponse(const char *serviceName, IRpcMessageBinding *init=NULL);
	CUploadFilesResponse(const char *serviceName, IRpcMessage* rpcmsg);
	CUploadFilesResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "UploadFilesResponse";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CUploadFilesResponse &from);

	void copy(IConstUploadFilesResponse &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstUploadFilesResponse &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	virtual void setRedirectUrl(const char *url)
	{ CSoapResponseBinding::setRedirectUrl(url); }

	virtual const IMultiException& getExceptions()
	{ return CSoapResponseBinding::getExceptions(); }

	virtual int queryClientStatus()
	{ return CSoapResponseBinding::getRpcState(); }

	virtual void noteException(IException& e)
	{  CSoapResponseBinding::noteException(e); }

	IArrayOf<IConstDFUActionResult> & getUploadFileResults();
	void setUploadFileResults(IArrayOf<IEspDFUActionResult> &val);
 void setUploadFileResults(IArrayOf<IConstDFUActionResult> &val);
};

class CGetSprayTargetsRequest : public CSoapRequestBinding,
   implements IEspGetSprayTargetsRequest,
   implements IClientGetSprayTargetsRequest
{
protected:

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CGetSprayTargetsRequest(const char *serviceName, const char *bcompat);

	CGetSprayTargetsRequest(const char *serviceName, IRpcMessageBinding *init=NULL);
	CGetSprayTargetsRequest(const char *serviceName, IRpcMessage* rpcmsg);
	CGetSprayTargetsRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	IEspClientRpcSettings &rpc(){return *static_cast<IEspClientRpcSettings*>(this);}


	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "GetSprayTargetsRequest";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CGetSprayTargetsRequest &from);

	void copy(IConstGetSprayTargetsRequest &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstGetSprayTargetsRequest &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

};

class CGetSprayTargetsResponse : public CSoapResponseBinding,
   implements IEspGetSprayTargetsResponse,
   implements IClientGetSprayTargetsResponse
{
protected:
	SoapStructArrayParam<IConstGroupNode, CGroupNode> m_GroupNodes;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CGetSprayTargetsResponse(const char *serviceName, const char *bcompat);

	CGetSprayTargetsResponse(const char *serviceName, IRpcMessageBinding *init=NULL);
	CGetSprayTargetsResponse(const char *serviceName, IRpcMessage* rpcmsg);
	CGetSprayTargetsResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "GetSprayTargetsResponse";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CGetSprayTargetsResponse &from);

	void copy(IConstGetSprayTargetsResponse &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstGetSprayTargetsResponse &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	virtual void setRedirectUrl(const char *url)
	{ CSoapResponseBinding::setRedirectUrl(url); }

	virtual const IMultiException& getExceptions()
	{ return CSoapResponseBinding::getExceptions(); }

	virtual int queryClientStatus()
	{ return CSoapResponseBinding::getRpcState(); }

	virtual void noteException(IException& e)
	{  CSoapResponseBinding::noteException(e); }

	IArrayOf<IConstGroupNode> & getGroupNodes();
	void setGroupNodes(IArrayOf<IEspGroupNode> &val);
 void setGroupNodes(IArrayOf<IConstGroupNode> &val);
};

class CGetDFUServerQueuesRequest : public CSoapRequestBinding,
   implements IEspGetDFUServerQueuesRequest,
   implements IClientGetDFUServerQueuesRequest
{
protected:
	SoapStringParam m_DFUServerName;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CGetDFUServerQueuesRequest(const char *serviceName, const char *bcompat);

	CGetDFUServerQueuesRequest(const char *serviceName, IRpcMessageBinding *init=NULL);
	CGetDFUServerQueuesRequest(const char *serviceName, IRpcMessage* rpcmsg);
	CGetDFUServerQueuesRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	IEspClientRpcSettings &rpc(){return *static_cast<IEspClientRpcSettings*>(this);}


	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "GetDFUServerQueuesRequest";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CGetDFUServerQueuesRequest &from);

	void copy(IConstGetDFUServerQueuesRequest &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstGetDFUServerQueuesRequest &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	const char * getDFUServerName();
	void setDFUServerName(const char * val);
};

class CGetDFUServerQueuesResponse : public CSoapResponseBinding,
   implements IEspGetDFUServerQueuesResponse,
   implements IClientGetDFUServerQueuesResponse
{
protected:
	SoapStringArray m_Names;

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CGetDFUServerQueuesResponse(const char *serviceName, const char *bcompat);

	CGetDFUServerQueuesResponse(const char *serviceName, IRpcMessageBinding *init=NULL);
	CGetDFUServerQueuesResponse(const char *serviceName, IRpcMessage* rpcmsg);
	CGetDFUServerQueuesResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "GetDFUServerQueuesResponse";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CGetDFUServerQueuesResponse &from);

	void copy(IConstGetDFUServerQueuesResponse &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstGetDFUServerQueuesResponse &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	virtual void setRedirectUrl(const char *url)
	{ CSoapResponseBinding::setRedirectUrl(url); }

	virtual const IMultiException& getExceptions()
	{ return CSoapResponseBinding::getExceptions(); }

	virtual int queryClientStatus()
	{ return CSoapResponseBinding::getRpcState(); }

	virtual void noteException(IException& e)
	{  CSoapResponseBinding::noteException(e); }

	StringArray & getNames();
	void setNames(StringArray &val);
};

class CFileSprayPingRequest : public CSoapRequestBinding,
   implements IEspFileSprayPingRequest,
   implements IClientFileSprayPingRequest
{
protected:

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CFileSprayPingRequest(const char *serviceName, const char *bcompat);

	CFileSprayPingRequest(const char *serviceName, IRpcMessageBinding *init=NULL);
	CFileSprayPingRequest(const char *serviceName, IRpcMessage* rpcmsg);
	CFileSprayPingRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	IEspClientRpcSettings &rpc(){return *static_cast<IEspClientRpcSettings*>(this);}


	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "FileSprayPingRequest";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CFileSprayPingRequest &from);

	void copy(IConstFileSprayPingRequest &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstFileSprayPingRequest &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

};

class CFileSprayPingResponse : public CSoapResponseBinding,
   implements IEspFileSprayPingResponse,
   implements IClientFileSprayPingResponse
{
protected:

	void *m_eventSink = nullptr;

	IInterface* m_RequestState = nullptr;
	StringBuffer m_serviceName;
	StringBuffer m_methodName;
	StringBuffer m_msgName;

	long soap_reqid = 0;
	Mutex m_mutex;
public:
	IMPLEMENT_IINTERFACE;

	CFileSprayPingResponse(const char *serviceName, const char *bcompat);

	CFileSprayPingResponse(const char *serviceName, IRpcMessageBinding *init=NULL);
	CFileSprayPingResponse(const char *serviceName, IRpcMessage* rpcmsg);
	CFileSprayPingResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments);
	virtual const char *getNsURI(){return NULL;}

	virtual const char *getNsPrefix(){return NULL;}

	virtual const char *getRootName(){return m_msgName.str();}

	void setMsgName(const char *msgname)
	{
		m_msgName.set(msgname);
	}

	static const char *queryXsdElementName()
	{
		return "FileSprayPingResponse";
	}

	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1)
	{
		return getXsdDefinition(context, request, queryXsdElementName(), schema, added, xns, wsns, flags);
	}
	static StringBuffer &getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash&added, const char *xns="xsd", const char *wsns="tns", unsigned flags=1);
	static void getMapInfo(IMapInfo& info);
	static void getMapInfo(IMapInfo& info, BoolHash& added);
	static StringBuffer &getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag=true, const char *prefix=NULL);
	static bool hasCustomHttpContent()
	{
		return false;
	}
	StringBuffer &serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html);

	void serialize(IRpcMessage& rpc_resp);

	void copy(CFileSprayPingResponse &from);

	void copy(IConstFileSprayPingResponse &ifrom);

	void serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops=NULL);

	void serializeAttributes(IEspContext* ctx, StringBuffer& s);

	void getAttributes(IProperties &attributes);

	static void serializer(IEspContext* ctx, IConstFileSprayPingResponse &ifrom, StringBuffer& buffer, bool keepRootTag=true);
	void setEventSink(void * val){m_eventSink=val;}
	void * getEventSink(){return m_eventSink;}
	void setState(IInterface * val){m_RequestState = val;}
	IInterface * queryState(){return m_RequestState;}
	void setMethod(const char * method){m_methodName.set(method);}
	const char * getMethod(){return m_methodName.str();}

	void setReqId(unsigned val){soap_reqid=val;}
	unsigned getReqId(){return soap_reqid;}

	void lock(){m_mutex.lock();}
	void unlock(){m_mutex.unlock();}


	bool unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath);

	bool unserialize(IEspContext* ctx, CSoapValue& soapval);

	bool unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath=NULL);

	virtual void setRedirectUrl(const char *url)
	{ CSoapResponseBinding::setRedirectUrl(url); }

	virtual const IMultiException& getExceptions()
	{ return CSoapResponseBinding::getExceptions(); }

	virtual int queryClientStatus()
	{ return CSoapResponseBinding::getRpcState(); }

	virtual void noteException(IException& e)
	{  CSoapResponseBinding::noteException(e); }

};

class CFileSpray : public CInterface,
	implements IEspFileSpray
{
private:
	IEspContainer* m_container;
public:
	IMPLEMENT_IINTERFACE;

	CFileSpray(){}
	virtual ~CFileSpray(){}
	virtual void init(IPropertyTree *cfg, const char *process, const char *service)
	{
	}
	virtual bool init(const char * service, const char * type, IPropertyTree * cfg, const char * process)
	{
		return true;
	}
	virtual void setContainer(IEspContainer *c)
	{
		m_container = c;
	}
	virtual IEspContainer *queryContainer()
	{
		return m_container;
	}
	virtual const char* getServiceType(){return "FileSpray";}

	virtual bool unsubscribeServiceFromDali(){return false;}

	virtual bool subscribeServiceToDali(){return false;}

	virtual bool detachServiceFromDali(){return false;}

	virtual bool attachServiceToDali(){return false;}

	virtual bool canDetachFromDali(){return false;}

	//bool onAbortDFUWorkunit(IEspContext &context, IEspAbortDFUWorkunit &req, IEspAbortDFUWorkunitResponse &resp)
	//{
		//return false;
	//}
	//bool onCopy(IEspContext &context, IEspCopy &req, IEspCopyResponse &resp)
	//{
		//return false;
	//}
	//bool onCreateDFUWorkunit(IEspContext &context, IEspCreateDFUWorkunit &req, IEspCreateDFUWorkunitResponse &resp)
	//{
		//return false;
	//}
	//bool onDFUWUFile(IEspContext &context, IEspDFUWUFileRequest &req, IEspDFUWUFileResponse &resp)
	//{
		//return false;
	//}
	//bool onDFUWUSearch(IEspContext &context, IEspDFUWUSearchRequest &req, IEspDFUWUSearchResponse &resp)
	//{
		//return false;
	//}
	//bool onDFUWorkunitsAction(IEspContext &context, IEspDFUWorkunitsActionRequest &req, IEspDFUWorkunitsActionResponse &resp)
	//{
		//return false;
	//}
	//bool onDeleteDFUWorkunit(IEspContext &context, IEspDeleteDFUWorkunit &req, IEspDeleteDFUWorkunitResponse &resp)
	//{
		//return false;
	//}
	//bool onDeleteDFUWorkunits(IEspContext &context, IEspDeleteDFUWorkunits &req, IEspDeleteDFUWorkunitsResponse &resp)
	//{
		//return false;
	//}
	//bool onDeleteDropZoneFiles(IEspContext &context, IEspDeleteDropZoneFilesRequest &req, IEspDFUWorkunitsActionResponse &resp)
	//{
		//return false;
	//}
	//bool onDespray(IEspContext &context, IEspDespray &req, IEspDesprayResponse &resp)
	//{
		//return false;
	//}
	//bool onDfuMonitor(IEspContext &context, IEspDfuMonitorRequest &req, IEspDfuMonitorResponse &resp)
	//{
		//return false;
	//}
	//bool onDropZoneFileSearch(IEspContext &context, IEspDropZoneFileSearchRequest &req, IEspDropZoneFileSearchResponse &resp)
	//{
		//return false;
	//}
	//bool onDropZoneFiles(IEspContext &context, IEspDropZoneFilesRequest &req, IEspDropZoneFilesResponse &resp)
	//{
		//return false;
	//}
	//bool onEchoDateTime(IEspContext &context, IEspEchoDateTime &req, IEspEchoDateTimeResponse &resp)
	//{
		//return false;
	//}
	//bool onFileList(IEspContext &context, IEspFileListRequest &req, IEspFileListResponse &resp)
	//{
		//return false;
	//}
	//bool onGetDFUExceptions(IEspContext &context, IEspGetDFUExceptions &req, IEspGetDFUExceptionsResponse &resp)
	//{
		//return false;
	//}
	//bool onGetDFUProgress(IEspContext &context, IEspProgressRequest &req, IEspProgressResponse &resp)
	//{
		//return false;
	//}
	//bool onGetDFUServerQueues(IEspContext &context, IEspGetDFUServerQueuesRequest &req, IEspGetDFUServerQueuesResponse &resp)
	//{
		//return false;
	//}
	//bool onGetDFUWorkunit(IEspContext &context, IEspGetDFUWorkunit &req, IEspGetDFUWorkunitResponse &resp)
	//{
		//return false;
	//}
	//bool onGetDFUWorkunits(IEspContext &context, IEspGetDFUWorkunits &req, IEspGetDFUWorkunitsResponse &resp)
	//{
		//return false;
	//}
	//bool onGetSprayTargets(IEspContext &context, IEspGetSprayTargetsRequest &req, IEspGetSprayTargetsResponse &resp)
	//{
		//return false;
	//}
	//bool onOpenSave(IEspContext &context, IEspOpenSaveRequest &req, IEspOpenSaveResponse &resp)
	//{
		//return false;
	//}
	bool onPing(IEspContext &context, IEspFileSprayPingRequest &req, IEspFileSprayPingResponse &resp)
	{
		return true;
	}
	//bool onRename(IEspContext &context, IEspRename &req, IEspRenameResponse &resp)
	//{
		//return false;
	//}
	//bool onReplicate(IEspContext &context, IEspReplicate &req, IEspReplicateResponse &resp)
	//{
		//return false;
	//}
	//bool onShowResult(IEspContext &context, IEspShowResultRequest &req, IEspShowResultResponse &resp)
	//{
		//return false;
	//}
	//bool onSprayFixed(IEspContext &context, IEspSprayFixed &req, IEspSprayFixedResponse &resp)
	//{
		//return false;
	//}
	//bool onSprayVariable(IEspContext &context, IEspSprayVariable &req, IEspSprayResponse &resp)
	//{
		//return false;
	//}
	//bool onSubmitDFUWorkunit(IEspContext &context, IEspSubmitDFUWorkunit &req, IEspSubmitDFUWorkunitResponse &resp)
	//{
		//return false;
	//}
	//bool onUpdateDFUWorkunit(IEspContext &context, IEspUpdateDFUWorkunit &req, IEspUpdateDFUWorkunitResponse &resp)
	//{
		//return false;
	//}
};





class CFileSpraySoapBinding : public CHttpSoapBinding
{
public:
	CFileSpraySoapBinding(http_soap_log_level level=hsl_none);
	CFileSpraySoapBinding(IPropertyTree* cfg, const char *bindname=NULL, const char *procname=NULL, http_soap_log_level level=hsl_none);
	virtual void init_strings();
	virtual unsigned getCacheMethodCount(){return m_cacheMethodCount;}
	virtual int processRequest(IRpcMessage* rpc_call, IRpcMessage* rpc_response);
	int getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &content, const char *service, const char *method, bool mda);
	virtual int getMethodHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &page, bool bIncludeFormTag);
	int getQualifiedNames(IEspContext& ctx, MethodInfoArray & methods);
	StringBuffer & getServiceName(StringBuffer &resp);
	bool isValidServiceName(IEspContext &context, const char *name);
	bool qualifyMethodName(IEspContext &context, const char *methname, StringBuffer *methQName);
	bool qualifyServiceName(IEspContext &context, const char *servname, const char *methname, StringBuffer &servQName, StringBuffer *methQName);
	virtual int onGetFile(IEspContext &context, CHttpRequest* request, CHttpResponse* response, const char *pathex);
	virtual int onGetForm(IEspContext &context, CHttpRequest* request, CHttpResponse* response, const char *service, const char *method);
	virtual int onGetXForm(IEspContext &context, CHttpRequest* request, CHttpResponse* response, const char *service, const char *method);
	virtual int onGetService(IEspContext &context, CHttpRequest* request, CHttpResponse* response, const char *service, const char *method, const char *pathex);
	virtual IRpcRequestBinding *createReqBinding(IEspContext &context, IHttpMessage* request, const char *service, const char *method);
	virtual int onGetInstantQuery(IEspContext &context, CHttpRequest* request, CHttpResponse* response, const char *service, const char *method);
	void setXslProcessor(IInterface *xslp_)
	{
		IXslProcessor *ixslp = dynamic_cast<IXslProcessor *>(xslp_);
		if (!ixslp)
			xslp.clear();
		else
			xslp.set(ixslp);
	}
private:
	Owned<IXslProcessor> xslp;
	void xslTransform(const char* xml, const char* xslFile, StringBuffer& output, IProperties *params)
	{
		if (xslp)
		{
			Owned<IXslTransform> xform = xslp->createXslTransform();
			StringBuffer xslpath;
			if (!strnicmp(xslFile, "/esp/xslt/", 10))
				if (!checkFileExists(xslpath.append(getCFD()).append("smc_xslt/").append(xslFile+10).str()) && !checkFileExists(xslpath.append(getCFD()).append("xslt/").append(xslFile+10).str()))
					return;
			xform->loadXslFromFile((xslpath.length()) ? xslpath.str() : xslFile);
			xform->setXmlSource(xml, strlen(xml)+1);
			if (params) xform->copyParameters(params);
			xform->transform(output.clear());
		}
	}
	unsigned m_cacheMethodCount = 0;
};



class CClientFileSpray : public CInterface,
	implements IClientFileSpray
{
protected:
	StringBuffer soap_proxy;
	StringBuffer soap_url;
	StringBuffer soap_userid;
	StringBuffer soap_password;
	StringBuffer soap_realm;
	StringBuffer soap_action;
	long soap_reqid = 0;

public:
	IMPLEMENT_IINTERFACE;

	CClientFileSpray()
	{
		soap_reqid=0;
			soap_action.append("FileSpray");
	}
	virtual ~CClientFileSpray(){}
	virtual void setProxyAddress(const char *address)
	{
		soap_proxy.set(address);
	}
	virtual void addServiceUrl(const char *url)
	{
		soap_url.set(url);
	}
	virtual void removeServiceUrl(const char *url)
	{
	}
	virtual void setUsernameToken(const char *userid,const char *password,const char *realm)
	{
		 soap_userid.set(userid);
		 soap_password.set(password);
		 soap_realm.set(realm);
	}
	virtual void setAction(const char *action)
	{
		soap_action.set(action);
	}

	virtual IClientAbortDFUWorkunit * createAbortDFUWorkunitRequest();
	virtual IClientAbortDFUWorkunitResponse * AbortDFUWorkunit(IClientAbortDFUWorkunit *request);
	virtual void async_AbortDFUWorkunit(IClientAbortDFUWorkunit *request, IClientFileSprayEvents *events,IInterface* state=0);

	virtual IClientAbortDFUWorkunitResponse *AbortDFUWorkunitFn(const char * wuid_);

	virtual IClientCopy * createCopyRequest();
	virtual IClientCopyResponse * Copy(IClientCopy *request);
	virtual void async_Copy(IClientCopy *request, IClientFileSprayEvents *events,IInterface* state=0);

	virtual IClientCopyResponse *CopyFn(const char * sourceLogicalName_, const char * destGroup_, const char * destGroupRoxie_, const char * destLogicalName_, const char * sourceDali_, const char * srcusername_, const char * srcpassword_, bool overwrite_, bool replicate_, int ReplicateOffset_, int maxConnections_, int throttle_, int transferBufferSize_, bool nosplit_, bool norecover_, bool compress_, bool Wrap_, bool Multicopy_, const char * SourceDiffKeyName_, const char * DestDiffKeyName_, bool superCopy_, bool push_, bool pull_, bool ifnewer_, const char * encrypt_, const char * decrypt_, bool preserveCompression_, const char * DFUServerQueue_, int ExpireDays_);

	virtual IClientCreateDFUWorkunit * createCreateDFUWorkunitRequest();
	virtual IClientCreateDFUWorkunitResponse * CreateDFUWorkunit(IClientCreateDFUWorkunit *request);
	virtual void async_CreateDFUWorkunit(IClientCreateDFUWorkunit *request, IClientFileSprayEvents *events,IInterface* state=0);

	virtual IClientCreateDFUWorkunitResponse *CreateDFUWorkunitFn(const char * DFUServerQueue_);

	virtual IClientDFUWUFileRequest * createDFUWUFileRequest();
	virtual IClientDFUWUFileResponse * DFUWUFile(IClientDFUWUFileRequest *request);
	virtual void async_DFUWUFile(IClientDFUWUFileRequest *request, IClientFileSprayEvents *events,IInterface* state=0);

	virtual IClientDFUWUFileResponse *DFUWUFileFn(const char * Wuid_, const char * Type_, const char * PlainText_);

	virtual IClientDFUWUSearchRequest * createDFUWUSearchRequest();
	virtual IClientDFUWUSearchResponse * DFUWUSearch(IClientDFUWUSearchRequest *request);
	virtual void async_DFUWUSearch(IClientDFUWUSearchRequest *request, IClientFileSprayEvents *events,IInterface* state=0);

	virtual IClientDFUWUSearchResponse *DFUWUSearchFn();

	virtual IClientDFUWorkunitsActionRequest * createDFUWorkunitsActionRequest();
	virtual IClientDFUWorkunitsActionResponse * DFUWorkunitsAction(IClientDFUWorkunitsActionRequest *request);
	virtual void async_DFUWorkunitsAction(IClientDFUWorkunitsActionRequest *request, IClientFileSprayEvents *events,IInterface* state=0);

	virtual IClientDFUWorkunitsActionResponse *DFUWorkunitsActionFn(StringArray &wuids_, CDFUWUActions Type_);

	virtual IClientDeleteDFUWorkunit * createDeleteDFUWorkunitRequest();
	virtual IClientDeleteDFUWorkunitResponse * DeleteDFUWorkunit(IClientDeleteDFUWorkunit *request);
	virtual void async_DeleteDFUWorkunit(IClientDeleteDFUWorkunit *request, IClientFileSprayEvents *events,IInterface* state=0);

	virtual IClientDeleteDFUWorkunitResponse *DeleteDFUWorkunitFn(const char * wuid_);

	virtual IClientDeleteDFUWorkunits * createDeleteDFUWorkunitsRequest();
	virtual IClientDeleteDFUWorkunitsResponse * DeleteDFUWorkunits(IClientDeleteDFUWorkunits *request);
	virtual void async_DeleteDFUWorkunits(IClientDeleteDFUWorkunits *request, IClientFileSprayEvents *events,IInterface* state=0);

	virtual IClientDeleteDFUWorkunitsResponse *DeleteDFUWorkunitsFn(StringArray &wuids_);

	virtual IClientDeleteDropZoneFilesRequest * createDeleteDropZoneFilesRequest();
	virtual IClientDFUWorkunitsActionResponse * DeleteDropZoneFiles(IClientDeleteDropZoneFilesRequest *request);
	virtual void async_DeleteDropZoneFiles(IClientDeleteDropZoneFilesRequest *request, IClientFileSprayEvents *events,IInterface* state=0);

	virtual IClientDFUWorkunitsActionResponse *DeleteDropZoneFilesFn(const char * DropZoneName_, const char * NetAddress_, const char * Path_, const char * OS_, StringArray &Names_);

	virtual IClientDespray * createDesprayRequest();
	virtual IClientDesprayResponse * Despray(IClientDespray *request);
	virtual void async_Despray(IClientDespray *request, IClientFileSprayEvents *events,IInterface* state=0);

	virtual IClientDesprayResponse *DesprayFn(const char * sourceLogicalName_, const char * destIP_, const char * destPath_, const MemoryBuffer & dstxml_, bool overwrite_, int maxConnections_, int throttle_, int transferBufferSize_, const char * splitprefix_, bool norecover_, bool wrap_, bool multiCopy_, bool SingleConnection_, const char * DFUServerQueue_, bool compress_, const char * encrypt_, const char * decrypt_);

	virtual IClientDfuMonitorRequest * createDfuMonitorRequest();
	virtual IClientDfuMonitorResponse * DfuMonitor(IClientDfuMonitorRequest *request);
	virtual void async_DfuMonitor(IClientDfuMonitorRequest *request, IClientFileSprayEvents *events,IInterface* state=0);

	virtual IClientDfuMonitorResponse *DfuMonitorFn(const char * EventName_, const char * LogicalName_, const char * Ip_, const char * Filename_, bool Sub_, int ShotLimit_);

	virtual IClientDropZoneFileSearchRequest * createDropZoneFileSearchRequest();
	virtual IClientDropZoneFileSearchResponse * DropZoneFileSearch(IClientDropZoneFileSearchRequest *request);
	virtual void async_DropZoneFileSearch(IClientDropZoneFileSearchRequest *request, IClientFileSprayEvents *events,IInterface* state=0);

	virtual IClientDropZoneFileSearchResponse *DropZoneFileSearchFn(const char * DropZoneName_, const char * Server_, bool ECLWatchVisibleOnly_, const char * NameFilter_);

	virtual IClientDropZoneFilesRequest * createDropZoneFilesRequest();
	virtual IClientDropZoneFilesResponse * DropZoneFiles(IClientDropZoneFilesRequest *request);
	virtual void async_DropZoneFiles(IClientDropZoneFilesRequest *request, IClientFileSprayEvents *events,IInterface* state=0);

	virtual IClientDropZoneFilesResponse *DropZoneFilesFn(const char * DropZoneName_, const char * NetAddress_, const char * Path_, const char * OS_, const char * Subfolder_, bool ECLWatchVisibleOnly_, bool DirectoryOnly_);

	virtual IClientEchoDateTime * createEchoDateTimeRequest();
	virtual IClientEchoDateTimeResponse * EchoDateTime(IClientEchoDateTime *request);
	virtual void async_EchoDateTime(IClientEchoDateTime *request, IClientFileSprayEvents *events,IInterface* state=0);

	virtual IClientEchoDateTimeResponse *EchoDateTimeFn(const char * dt_);

	virtual IClientFileListRequest * createFileListRequest();
	virtual IClientFileListResponse * FileList(IClientFileListRequest *request);
	virtual void async_FileList(IClientFileListRequest *request, IClientFileSprayEvents *events,IInterface* state=0);

	virtual IClientFileListResponse *FileListFn(const char * Netaddr_, const char * Path_, const char * Mask_, const char * OS_, bool DirectoryOnly_);

	virtual IClientGetDFUExceptions * createGetDFUExceptionsRequest();
	virtual IClientGetDFUExceptionsResponse * GetDFUExceptions(IClientGetDFUExceptions *request);
	virtual void async_GetDFUExceptions(IClientGetDFUExceptions *request, IClientFileSprayEvents *events,IInterface* state=0);

	virtual IClientGetDFUExceptionsResponse *GetDFUExceptionsFn(const char * wuid_);

	virtual IClientProgressRequest * createGetDFUProgressRequest();
	virtual IClientProgressResponse * GetDFUProgress(IClientProgressRequest *request);
	virtual void async_GetDFUProgress(IClientProgressRequest *request, IClientFileSprayEvents *events,IInterface* state=0);

	virtual IClientProgressResponse *GetDFUProgressFn(const char * wuid_);

	virtual IClientGetDFUServerQueuesRequest * createGetDFUServerQueuesRequest();
	virtual IClientGetDFUServerQueuesResponse * GetDFUServerQueues(IClientGetDFUServerQueuesRequest *request);
	virtual void async_GetDFUServerQueues(IClientGetDFUServerQueuesRequest *request, IClientFileSprayEvents *events,IInterface* state=0);

	virtual IClientGetDFUServerQueuesResponse *GetDFUServerQueuesFn(const char * DFUServerName_);

	virtual IClientGetDFUWorkunit * createGetDFUWorkunitRequest();
	virtual IClientGetDFUWorkunitResponse * GetDFUWorkunit(IClientGetDFUWorkunit *request);
	virtual void async_GetDFUWorkunit(IClientGetDFUWorkunit *request, IClientFileSprayEvents *events,IInterface* state=0);

	virtual IClientGetDFUWorkunitResponse *GetDFUWorkunitFn(const char * wuid_);

	virtual IClientGetDFUWorkunits * createGetDFUWorkunitsRequest();
	virtual IClientGetDFUWorkunitsResponse * GetDFUWorkunits(IClientGetDFUWorkunits *request);
	virtual void async_GetDFUWorkunits(IClientGetDFUWorkunits *request, IClientFileSprayEvents *events,IInterface* state=0);

	virtual IClientGetDFUWorkunitsResponse *GetDFUWorkunitsFn(const char * Wuid_, const char * Owner_, const char * Cluster_, const char * StateReq_, const char * Type_, const char * Jobname_, __int64 PageSize_, int CurrentPage_, __int64 PageStartFrom_, const char * Sortby_, bool Descending_, __int64 CacheHint_);

	virtual IClientGetSprayTargetsRequest * createGetSprayTargetsRequest();
	virtual IClientGetSprayTargetsResponse * GetSprayTargets(IClientGetSprayTargetsRequest *request);
	virtual void async_GetSprayTargets(IClientGetSprayTargetsRequest *request, IClientFileSprayEvents *events,IInterface* state=0);

	virtual IClientGetSprayTargetsResponse *GetSprayTargetsFn();

	virtual IClientOpenSaveRequest * createOpenSaveRequest();
	virtual IClientOpenSaveResponse * OpenSave(IClientOpenSaveRequest *request);
	virtual void async_OpenSave(IClientOpenSaveRequest *request, IClientFileSprayEvents *events,IInterface* state=0);

	virtual IClientOpenSaveResponse *OpenSaveFn(const char * Location_, const char * Path_, const char * Name_, const char * Type_, const char * DateTime_, bool BinaryFile_);

	virtual IClientFileSprayPingRequest * createPingRequest();
	virtual IClientFileSprayPingResponse * Ping(IClientFileSprayPingRequest *request);
	virtual void async_Ping(IClientFileSprayPingRequest *request, IClientFileSprayEvents *events,IInterface* state=0);

	virtual IClientFileSprayPingResponse *PingFn();

	virtual IClientRename * createRenameRequest();
	virtual IClientRenameResponse * Rename(IClientRename *request);
	virtual void async_Rename(IClientRename *request, IClientFileSprayEvents *events,IInterface* state=0);

	virtual IClientRenameResponse *RenameFn(const char * srcname_, const char * dstname_, bool overwrite_, const char * DFUServerQueue_);

	virtual IClientReplicate * createReplicateRequest();
	virtual IClientReplicateResponse * Replicate(IClientReplicate *request);
	virtual void async_Replicate(IClientReplicate *request, IClientFileSprayEvents *events,IInterface* state=0);

	virtual IClientReplicateResponse *ReplicateFn(const char * sourceLogicalName_, int replicateOffset_, const char * cluster_, bool repeatLast_, bool onlyRepeated_, const char * DFUServerQueue_);

	virtual IClientShowResultRequest * createShowResultRequest();
	virtual IClientShowResultResponse * ShowResult(IClientShowResultRequest *request);
	virtual void async_ShowResult(IClientShowResultRequest *request, IClientFileSprayEvents *events,IInterface* state=0);

	virtual IClientShowResultResponse *ShowResultFn(const char * Result_);

	virtual IClientSprayFixed * createSprayFixedRequest();
	virtual IClientSprayFixedResponse * SprayFixed(IClientSprayFixed *request);
	virtual void async_SprayFixed(IClientSprayFixed *request, IClientFileSprayEvents *events,IInterface* state=0);

	virtual IClientSprayFixedResponse *SprayFixedFn(const char * sourceIP_, const char * sourcePath_, const MemoryBuffer & srcxml_, const char * sourceFormat_, int sourceRecordSize_, const char * destGroup_, const char * destLogicalName_, bool overwrite_, bool replicate_, int ReplicateOffset_, int maxConnections_, int throttle_, int transferBufferSize_, const char * prefix_, bool nosplit_, bool norecover_, bool compress_, bool push_, bool pull_, const char * encrypt_, const char * decrypt_, bool wrap_, bool failIfNoSourceFile_, bool recordStructurePresent_, bool quotedTerminator_, int expireDays_, const char * DFUServerQueue_);

	virtual IClientSprayVariable * createSprayVariableRequest();
	virtual IClientSprayResponse * SprayVariable(IClientSprayVariable *request);
	virtual void async_SprayVariable(IClientSprayVariable *request, IClientFileSprayEvents *events,IInterface* state=0);

	virtual IClientSprayResponse *SprayVariableFn(const char * sourceIP_, const char * sourcePath_, const MemoryBuffer & srcxml_, int sourceMaxRecordSize_, int sourceFormat_, bool NoSourceCsvSeparator_, const char * sourceCsvSeparate_, const char * sourceCsvTerminate_, const char * sourceCsvQuote_, const char * sourceCsvEscape_, const char * sourceRowTag_, const char * destGroup_, const char * destLogicalName_, bool overwrite_, bool replicate_, int ReplicateOffset_, int maxConnections_, int throttle_, int transferBufferSize_, const char * prefix_, bool nosplit_, bool norecover_, bool compress_, bool push_, bool pull_, const char * encrypt_, const char * decrypt_, bool failIfNoSourceFile_, bool recordStructurePresent_, bool quotedTerminator_, const char * sourceRowPath_, bool isJSON_, int expireDays_, const char * DFUServerQueue_);

	virtual IClientSubmitDFUWorkunit * createSubmitDFUWorkunitRequest();
	virtual IClientSubmitDFUWorkunitResponse * SubmitDFUWorkunit(IClientSubmitDFUWorkunit *request);
	virtual void async_SubmitDFUWorkunit(IClientSubmitDFUWorkunit *request, IClientFileSprayEvents *events,IInterface* state=0);

	virtual IClientSubmitDFUWorkunitResponse *SubmitDFUWorkunitFn(const char * wuid_);

	virtual IClientUpdateDFUWorkunit * createUpdateDFUWorkunitRequest();
	virtual IClientUpdateDFUWorkunitResponse * UpdateDFUWorkunit(IClientUpdateDFUWorkunit *request);
	virtual void async_UpdateDFUWorkunit(IClientUpdateDFUWorkunit *request, IClientFileSprayEvents *events,IInterface* state=0);

	virtual IClientUpdateDFUWorkunitResponse *UpdateDFUWorkunitFn(IConstDFUWorkunit &wu_, const char * ClusterOrig_, const char * JobNameOrig_, bool isProtectedOrig_, int StateOrig_);
	static int transferThunkEvent(void *data);
#ifdef _WIN32
	static void espWorkerThread(void* data);
#else
	static void *espWorkerThread(void *data);
#endif
};



}
using namespace ws_fs;

#endif //ws_fs_ESPGEN_INCLUDED
